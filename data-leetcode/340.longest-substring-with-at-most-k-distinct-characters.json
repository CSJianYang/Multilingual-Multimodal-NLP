[
    {
        "title": "Combination Sum II",
        "question_content": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates&nbsp;where the candidate numbers sum to target.\nEach number in candidates&nbsp;may only be used once in the combination.\nNote:&nbsp;The solution set must not contain duplicate combinations.\n&nbsp;\nExample 1:\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\nExample 2:\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n&nbsp;\nConstraints:\n\n\t1 <=&nbsp;candidates.length <= 100\n\t1 <=&nbsp;candidates[i] <= 50\n\t1 <= target <= 30",
        "solutions": [
            {
                "id": 16878,
                "title": "combination-sum-i-ii-and-iii-java-solution-see-the-similarities-yourself",
                "content": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16861,
                "title": "java-solution-using-dfs-easy-understand",
                "content": "     public List<List<Integer>> combinationSum2(int[] cand, int target) {\\n        Arrays.sort(cand);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> path = new ArrayList<Integer>();\\n        dfs_com(cand, 0, target, path, res);\\n        return res;\\n    }\\n    void dfs_com(int[] cand, int cur, int target, List<Integer> path, List<List<Integer>> res) {\\n        if (target == 0) {\\n            res.add(new ArrayList(path));\\n            return ;\\n        }\\n        if (target < 0) return;\\n        for (int i = cur; i < cand.length; i++){\\n            if (i > cur && cand[i] == cand[i-1]) continue;\\n            path.add(path.size(), cand[i]);\\n            dfs_com(cand, i+1, target - cand[i], path, res);\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "     public List<List<Integer>> combinationSum2(int[] cand, int target) {\\n        Arrays.sort(cand);\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> path = new ArrayList<Integer>();\\n        dfs_com(cand, 0, target, path, res);\\n        return res;\\n    }\\n    void dfs_com(int[] cand, int cur, int target, List<Integer> path, List<List<Integer>> res) {\\n        if (target == 0) {\\n            res.add(new ArrayList(path));\\n            return ;\\n        }\\n        if (target < 0) return;\\n        for (int i = cur; i < cand.length; i++){\\n            if (i > cur && cand[i] == cand[i-1]) continue;\\n            path.add(path.size(), cand[i]);\\n            dfs_com(cand, i+1, target - cand[i], path, res);\\n            path.remove(path.size()-1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1277764,
                "title": "combination-sum-i-ii-and-iii-subsets-i-and-ii-permutations-i-and-ii-one-stop-c-solutions",
                "content": "**SUBSETS** \\nhttps://leetcode.com/problems/subsets\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void powerset(vector<int> nums, int curr, vector<int> res, int n){\\n        if(curr == n){\\n            result.push_back(res);\\n            return;\\n        }\\n        powerset(nums, curr+1, res, n);\\n        res.push_back(nums[curr]);\\n        powerset(nums, curr+1, res, n);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        powerset(nums, 0, res, n);\\n        return result;\\n    }\\n};\\n```\\n\\n**SUBSETS II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void subs(vector<int> &nums, int curr, vector<int> &res){\\n        result.push_back(res);\\n        for(int i = curr; i < nums.size(); i++){\\n            if(i!=curr && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            res.push_back(nums[i]);\\n            subs(nums, i+1, res);\\n            res.pop_back();\\n            \\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return result;\\n        }\\n        vector<int> res;\\n        sort(nums.begin(), nums.end());\\n        subs(nums, 0, res);\\n        return result;\\n    }\\n};\\n```\\n----------------------------------------------------------------------------------\\n**PERMUTATIONS**\\nhttps://leetcode.com/problems/permutations/\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        for(int i = l; i <= r; i++){\\n            nums = swap(nums, l, i);\\n            perm(nums, l+1, r);\\n            nums = swap(nums, l, i);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        perm(nums, 0, nums.size()-1);\\n        return result;\\n    } \\n};\\n```\\n**PERMUTATIONS II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        set<int> s;\\n        for(int i = l; i <= r; i++){\\n                if(s.find(nums[i]) != s.end() )\\n                    continue;\\n                s.insert(nums[i]);\\n                nums = swap(nums, l, i);\\n                perm(nums, l+1, r);\\n                nums = swap(nums, l, i);  \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        perm(nums, 0, nums.size()-1);\\n        return result;  \\n    }\\n};\\n```\\n-------------------------------------------------------------------------------------------\\n**COMBINATION SUM**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comSum(vector<int> &curr, int curInd, int sum, vector<int> &candidates, int target, int n){\\n        if(sum == target){\\n            result.push_back(curr);\\n            return;\\n        }      \\n        else if(sum > target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            curr.push_back(candidates[i]);\\n            sum += candidates[i];\\n            comSum(curr, i, sum, candidates, target, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int sum = 0;\\n        int n = candidates.size();\\n        comSum(curr, 0, sum, candidates, target, n);\\n        return result;\\n    }\\n};\\n```\\n**COMBINATION SUM II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```\\n**COMBINATION SUM III**\\nhttps://leetcode.com/problems/combination-sum-iii/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void comsum(vector<int> &curr, int k, int n, int sum, int size, int index){\\n        if(size==k && sum == n){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(size>k || sum>n)\\n            return;\\n        \\n        for(int i = index; i <= 9; i++){\\n            sum += i;\\n            curr.push_back(i);\\n            comsum(curr, k, n, sum, size+1, i+1);\\n            sum -= i;\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> curr;\\n        comsum(curr, k, n, 0, 0, 1);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void powerset(vector<int> nums, int curr, vector<int> res, int n){\\n        if(curr == n){\\n            result.push_back(res);\\n            return;\\n        }\\n        powerset(nums, curr+1, res, n);\\n        res.push_back(nums[curr]);\\n        powerset(nums, curr+1, res, n);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> res;\\n        powerset(nums, 0, res, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void subs(vector<int> &nums, int curr, vector<int> &res){\\n        result.push_back(res);\\n        for(int i = curr; i < nums.size(); i++){\\n            if(i!=curr && nums[i]==nums[i-1]){\\n                continue;\\n            }\\n            res.push_back(nums[i]);\\n            subs(nums, i+1, res);\\n            res.pop_back();\\n            \\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        if(nums.size() == 0){\\n            return result;\\n        }\\n        vector<int> res;\\n        sort(nums.begin(), nums.end());\\n        subs(nums, 0, res);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        for(int i = l; i <= r; i++){\\n            nums = swap(nums, l, i);\\n            perm(nums, l+1, r);\\n            nums = swap(nums, l, i);\\n        }\\n    }\\n    \\n    vector<vector<int>> permute(vector<int>& nums) {\\n        perm(nums, 0, nums.size()-1);\\n        return result;\\n    } \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    vector<int> swap(vector<int> &nums, int a, int b){\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n        return nums;\\n    }\\n    \\n    void perm(vector<int> &nums, int l, int r){\\n        if(l==r){\\n            result.push_back(nums);\\n            return;\\n        }\\n        set<int> s;\\n        for(int i = l; i <= r; i++){\\n                if(s.find(nums[i]) != s.end() )\\n                    continue;\\n                s.insert(nums[i]);\\n                nums = swap(nums, l, i);\\n                perm(nums, l+1, r);\\n                nums = swap(nums, l, i);  \\n        }\\n    }\\n    \\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        perm(nums, 0, nums.size()-1);\\n        return result;  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comSum(vector<int> &curr, int curInd, int sum, vector<int> &candidates, int target, int n){\\n        if(sum == target){\\n            result.push_back(curr);\\n            return;\\n        }      \\n        else if(sum > target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            curr.push_back(candidates[i]);\\n            sum += candidates[i];\\n            comSum(curr, i, sum, candidates, target, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int sum = 0;\\n        int n = candidates.size();\\n        comSum(curr, 0, sum, candidates, target, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    void comsum(vector<int> &curr, int k, int n, int sum, int size, int index){\\n        if(size==k && sum == n){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(size>k || sum>n)\\n            return;\\n        \\n        for(int i = index; i <= 9; i++){\\n            sum += i;\\n            curr.push_back(i);\\n            comsum(curr, k, n, sum, size+1, i+1);\\n            sum -= i;\\n            curr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> curr;\\n        comsum(curr, k, n, 0, 0, 1);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16944,
                "title": "beating-98-python-solution-using-recursion-with-comments",
                "content": "    def combinationSum2(self, candidates, target):\\n        # Sorting is really helpful, se we can avoid over counting easily\\n        candidates.sort()                      \\n        result = []\\n        self.combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n        \\n    def combine_sum_2(self, nums, start, path, result, target):\\n        # Base case: if the sum of the path satisfies the target, we will consider \\n        # it as a solution, and stop there\\n        if not target:\\n            result.append(path)\\n            return\\n        \\n        for i in xrange(start, len(nums)):\\n            # Very important here! We don't use `i > 0` because we always want \\n            # to count the first element in this recursive step even if it is the same \\n            # as one before. To avoid overcounting, we just ignore the duplicates\\n            # after the first element.\\n            if i > start and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # If the current element is bigger than the assigned target, there is \\n            # no need to keep searching, since all the numbers are positive\\n            if nums[i] > target:\\n                break\\n\\n            # We change the start to `i + 1` because one element only could\\n            # be used once\\n            self.combine_sum_2(nums, i + 1, path + [nums[i]], \\n                               result, target - nums[i])",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def combinationSum2(self, candidates, target):\\n        # Sorting is really helpful, se we can avoid over counting easily\\n        candidates.sort()                      \\n        result = []\\n        self.combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n        \\n    def combine_sum_2(self, nums, start, path, result, target):\\n        # Base case: if the sum of the path satisfies the target, we will consider \\n        # it as a solution, and stop there\\n        if not target:\\n            result.append(path)\\n            return\\n        \\n        for i in xrange(start, len(nums)):\\n            # Very important here! We don't use `i > 0` because we always want \\n            # to count the first element in this recursive step even if it is the same \\n            # as one before. To avoid overcounting, we just ignore the duplicates\\n            # after the first element.\\n            if i > start and nums[i] == nums[i - 1]:\\n                continue\\n\\n            # If the current element is bigger than the assigned target, there is \\n            # no need to keep searching, since all the numbers are positive\\n            if nums[i] > target:\\n                break\\n\\n            # We change the start to `i + 1` because one element only could\\n            # be used once\\n            self.combine_sum_2(nums, i + 1, path + [nums[i]], \\n                               result, target - nums[i])",
                "codeTag": "Python3"
            },
            {
                "id": 750378,
                "title": "python3-dfs-solutions-templates-to-6-different-classic-backtracking-problems-more",
                "content": "I have compiled solutions for all the 6 classic backtracking problems, you can practise them together for better understanding. Good luck with your preparation/interviews! \\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/?currentPage=1&orderBy=recent_activity&query=)\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/)\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/)\\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\\n\\n[46. Permutations](https://leetcode.com/problems/permutations/)\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\\n\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/)\\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```\\n\\nMore good backtracking problems for practice:\\n[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\\n[784. Lettercase Permutation](https://leetcode.com/problems/letter-case-permutation/)\\n[1087. Brace Expansion](https://leetcode.com/problems/brace-expansion/)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/)\\n[1079 Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/)",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        if not candidates: return []\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                dfs(i, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates.sort()\\n        def dfs(idx, path, cur):\\n            if cur > target: return\\n            if cur == target:\\n                res.append(path)\\n                return\\n            for i in range(idx, len(candidates)):\\n                if i > idx and candidates[i] == candidates[i-1]:\\n                    continue\\n                dfs(i+1, path+[candidates[i]], cur+candidates[i])\\n        dfs(0, [], 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        nums.sort()\\n        def dfs(idx, path):\\n            res.append(path)\\n            for i in range(idx, len(nums)):\\n                if i > idx and nums[i] == nums[i-1]:\\n                    continue\\n                dfs(i+1, path+[nums[i]])\\n        dfs(0, [])\\n        return res\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res \\n```\n```\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        def dfs(counter, path):\\n            if len(path) == len(nums):\\n                res.append(path)\\n                return\\n            for x in counter:\\n                if counter[x]:\\n                    counter[x] -= 1\\n                    dfs(counter, path+[x])\\n                    counter[x] += 1\\n        dfs(Counter(nums), [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16862,
                "title": "c-backtracking-solution-with-detailed-explanation",
                "content": "At the beginning, I stuck on this problem. After careful thought, I think this kind of backtracking contains a  iterative component and a resursive component so I'd like to give more details to help beginners save time. The revursive component tries the elements after the current one and also tries duplicate elements. So we can get correct answer for cases like [1 1] 2. The iterative component checks duplicate combinations and skip it if it is. So we can get correct answer for cases like [1 1 1] 2.\\n\\n\\n    class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n        {\\n            vector<vector<int>> res;\\n            sort(num.begin(),num.end());\\n            vector<int> local;\\n            findCombination(res, 0, target, local, num);\\n            return res;\\n        }\\n        void findCombination(vector<vector<int>>& res, const int order, const int target, vector<int>& local, const vector<int>& num)\\n        {\\n            if(target==0)\\n            {\\n                res.push_back(local);\\n                return;\\n            }\\n            else\\n            {\\n                for(int i = order;i<num.size();i++) // iterative component\\n                {\\n                    if(num[i]>target) return;\\n                    if(i&&num[i]==num[i-1]&&i>order) continue; // check duplicate combination\\n                    local.push_back(num[i]),\\n                    findCombination(res,i+1,target-num[i],local,num); // recursive componenet\\n                    local.pop_back();\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n        {\\n            vector<vector<int>> res;\\n            sort(num.begin(),num.end());\\n            vector<int> local;\\n            findCombination(res, 0, target, local, num);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17020,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ret = []\\n        self.dfs(sorted(candidates), target, 0, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, idx, path, ret):\\n        if target <= 0:\\n            if target == 0:\\n                ret.append(path)\\n            return \\n        for i in range(idx, len(nums)):\\n            if i > idx and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums, target-nums[i], i+1, path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ret = []\\n        self.dfs(sorted(candidates), target, 0, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, target, idx, path, ret):\\n        if target <= 0:\\n            if target == 0:\\n                ret.append(path)\\n            return \\n        for i in range(idx, len(nums)):\\n            if i > idx and nums[i] == nums[i-1]:\\n                continue\\n            self.dfs(nums, target-nums[i], i+1, path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16870,
                "title": "dp-solution-in-python",
                "content": "I also did it with recursion, turns out the DP solution is 3~4 times faster.\\n    \\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        table = [None] + [set() for i in range(target)]\\n        for i in candidates:\\n            if i > target:\\n                break\\n            for j in range(target - i, 0, -1):\\n                table[i + j] |= {elt + (i,) for elt in table[j]}\\n            table[i].add((i,))\\n        return map(list, table[target])",
                "solutionTags": [
                    "Python"
                ],
                "code": "I also did it with recursion, turns out the DP solution is 3~4 times faster.\\n    \\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        table = [None] + [set() for i in range(target)]\\n        for i in candidates:\\n            if i > target:\\n                break\\n            for j in range(target - i, 0, -1):\\n                table[i + j] |= {elt + (i,) for elt in table[j]}\\n            table[i].add((i,))\\n        return map(list, table[target])",
                "codeTag": "Python3"
            },
            {
                "id": 1350766,
                "title": "100-faster-c-solution-with-proper-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int index, int target, vector<int>&candidates, vector<vector<int>>&ans, vector<int>&ds){\\n        //base case\\n        //when the combination ds is carrying is a valid one add it into th ans\\n        if(target == 0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i< candidates.size(); i++){\\n            if(candidates[i] > target) break; // no point of it to add it to the ans if the  candidate at ith element exceeds the target no picking up hence break \\n            if(i  > index && candidates[i] == candidates[i-1])\\n                continue;\\n                //to avoid picking up the same elements and thus avoiding duplicates (no picking of element)\\n            ds.push_back(candidates[i]);\\n            helper(i+1, target- candidates[i], candidates, ans, ds); //call for next  index element\\n            ds.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());//sort the given candidates vector \\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        helper(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int index, int target, vector<int>&candidates, vector<vector<int>>&ans, vector<int>&ds){\\n        //base case\\n        //when the combination ds is carrying is a valid one add it into th ans\\n        if(target == 0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i< candidates.size(); i++){\\n            if(candidates[i] > target) break; // no point of it to add it to the ans if the  candidate at ith element exceeds the target no picking up hence break \\n            if(i  > index && candidates[i] == candidates[i-1])\\n                continue;\\n                //to avoid picking up the same elements and thus avoiding duplicates (no picking of element)\\n            ds.push_back(candidates[i]);\\n            helper(i+1, target- candidates[i], candidates, ans, ds); //call for next  index element\\n            ds.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());//sort the given candidates vector \\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        helper(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16884,
                "title": "a-smaller-trick-to-improve-a-lot-beat-92-35",
                "content": "Most people who use recursive backtrack to solve this question have code like:\\n\\n```\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return;\\n        }\\n        \\n        if (target < 0) {\\n            return;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > post && candidates[i] == candidats[i - 1])\\n              continue;\\n            }\\n            list.add(candidates[i]);\\n            helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n```\\n\\nThis is absolutely correct. However, we can do much more pruning by breaking much earlier. \\n\\nFor example: the list is [1, 1,  2, 5, 6, 7, 10], target is 8 and the current list is [1, 1, 2]. Now we are at 5, and we know that [1, 1, 2, 5] will be greater than 8. The next to check is [1, 1, 2, 6]. However, we should already know that [1, 1, 2, 6] cannot work since [1, 1, 2, 5] already has a sum larger than 8. There is no need to check for [1, 1,  2, 6] or [1, 1, 2, 7] and so no.\\n\\nThus, when we find a match or the current sum is already larger than the target, we should not continue with the current list.\\n\\nThe code is something like:\\n\\n```\\n    private boolean helper(int[] candidates, int target, List<List<Integer>> res,\\n                        List<Integer> list, int pos) {\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return true;\\n        }\\n        \\n        if (target < 0) {\\n            return true;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > pos && candidates[i] == candidates[i - 1]) {\\n                continue;\\n            }\\n            \\n            list.add(candidates[i]);\\n            boolean con = helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n            if(con) {\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return;\\n        }\\n        \\n        if (target < 0) {\\n            return;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > post && candidates[i] == candidats[i - 1])\\n              continue;\\n            }\\n            list.add(candidates[i]);\\n            helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n```\n```\\n    private boolean helper(int[] candidates, int target, List<List<Integer>> res,\\n                        List<Integer> list, int pos) {\\n        if (target == 0) {\\n            res.add(new ArrayList<Integer>(list));\\n            return true;\\n        }\\n        \\n        if (target < 0) {\\n            return true;\\n        }\\n        \\n        for (int i = pos; i < candidates.length; i++) {\\n            if (i > pos && candidates[i] == candidates[i - 1]) {\\n                continue;\\n            }\\n            \\n            list.add(candidates[i]);\\n            boolean con = helper(candidates, target - candidates[i], res, list, i + 1);\\n            list.remove(list.size() - 1);\\n            if(con) {\\n                break;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1213780,
                "title": "3-backtracking-variations-java-beats-100",
                "content": "**Backtracking With Visited Array (using space)**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        boolean[] visited = new boolean[50];\\n        int count = 0;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (!visited[arr[i]] && tar - arr[i] >= 0) {\\n                \\n                visited[arr[i]] = true;\\n                \\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**Backtracking With Prev Variable (space efficient)**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        int prev = -1;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (prev != arr[i] && tar - arr[i] >= 0) {\\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n            \\n            if (tar - arr[i] < 0)\\n                break;\\n            \\n            prev = arr[i];\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**BackTracking Subsequence method**\\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0 || idx >= arr.length) {\\n            if (tar == 0) {\\n                List<Integer> base = new ArrayList<>(smallAns);\\n                res.add(base);\\n                return 1;\\n            }\\n            return 0;\\n        }\\n            \\n        int count = 0;\\n\\n        if (tar - arr[idx] >= 0) {\\n            smallAns.add(arr[idx]);\\n            count += combinationSum2(arr, tar - arr[idx], idx + 1, smallAns, res);\\n            smallAns.remove(smallAns.size() - 1);\\n        }\\n\\n        idx++;\\n        while (idx < arr.length && arr[idx - 1] == arr[idx])\\n            idx++;\\n\\n        count += combinationSum2(arr, tar, idx, smallAns, res);\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] arr, int tar) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        Arrays.sort(arr);\\n        combinationSum2(arr, tar, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\\n**If you liked it, even a little bit then pls consider giving this solution a Upvote\\nThank You :)**",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        boolean[] visited = new boolean[50];\\n        int count = 0;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (!visited[arr[i]] && tar - arr[i] >= 0) {\\n                \\n                visited[arr[i]] = true;\\n                \\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0) {\\n            ArrayList<Integer> base = new ArrayList<>(smallAns);\\n            res.add(base);\\n            return 1;\\n        }\\n        \\n        int count = 0;\\n        int prev = -1;\\n        for (int i = idx; i < arr.length; ++i) {\\n            if (prev != arr[i] && tar - arr[i] >= 0) {\\n                smallAns.add(arr[i]);\\n                count += combinationSum2(arr, tar - arr[i], i + 1, smallAns, res);\\n                smallAns.remove(smallAns.size() - 1);\\n            }\\n            \\n            if (tar - arr[i] < 0)\\n                break;\\n            \\n            prev = arr[i];\\n        }\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        \\n        Arrays.sort(candidates);\\n        \\n        combinationSum2(candidates, target, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int combinationSum2(int[] arr, int tar, int idx, List<Integer> smallAns, List<List<Integer>> res) {\\n        if (tar == 0 || idx >= arr.length) {\\n            if (tar == 0) {\\n                List<Integer> base = new ArrayList<>(smallAns);\\n                res.add(base);\\n                return 1;\\n            }\\n            return 0;\\n        }\\n            \\n        int count = 0;\\n\\n        if (tar - arr[idx] >= 0) {\\n            smallAns.add(arr[idx]);\\n            count += combinationSum2(arr, tar - arr[idx], idx + 1, smallAns, res);\\n            smallAns.remove(smallAns.size() - 1);\\n        }\\n\\n        idx++;\\n        while (idx < arr.length && arr[idx - 1] == arr[idx])\\n            idx++;\\n\\n        count += combinationSum2(arr, tar, idx, smallAns, res);\\n        return count;\\n    }\\n    public List<List<Integer>> combinationSum2(int[] arr, int tar) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> smallAns = new ArrayList<>();\\n        Arrays.sort(arr);\\n        combinationSum2(arr, tar, 0, smallAns, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16916,
                "title": "understanding-the-differences-between-the-dp-solution-and-simple-recursive-which-one-is-really-better",
                "content": "DP Solution:\\n1. Start by creating an array of [target+1]. Call it arr.\\n2. Initialize value at arr[candidates[i]] to be a set only containing {candidates[i]}.\\n3. If there are any other indices j of arr that are non-empty, populate the arr[j+candidates[i]] with the set of arr[j] + candidates[i].\\n\\nGood for:\\nIf target is relatively small, and/or numbers in candidates are very dense.\\nO(M*N) where M is target, and N is candidates.size()\\n\\nRecursive Solution:\\n1. Start by recursing with an empty set on every element.\\n2. DFS by adding the ith element on the temporary vector, calling the recursive function with the ith element added, then remove it. \\n3. When the remaining is 0(we subtract target by candidate[i] every recursive call to candidate[i]), we add the result into the vector<vector<int>>. \\n\\nGood for:\\nIf M is overwhelmingly large.\\n\\nSo I have an additional question: Though I see these 2 tradeoffs, in reality which one would dominate in terms of usefulness in the test cases given by whoever wrote them on leetcode?",
                "solutionTags": [],
                "code": "DP Solution:\\n1. Start by creating an array of [target+1]. Call it arr.\\n2. Initialize value at arr[candidates[i]] to be a set only containing {candidates[i]}.\\n3. If there are any other indices j of arr that are non-empty, populate the arr[j+candidates[i]] with the set of arr[j] + candidates[i].\\n\\nGood for:\\nIf target is relatively small, and/or numbers in candidates are very dense.\\nO(M*N) where M is target, and N is candidates.size()\\n\\nRecursive Solution:\\n1. Start by recursing with an empty set on every element.\\n2. DFS by adding the ith element on the temporary vector, calling the recursive function with the ith element added, then remove it. \\n3. When the remaining is 0(we subtract target by candidate[i] every recursive call to candidate[i]), we add the result into the vector<vector<int>>. \\n\\nGood for:\\nIf M is overwhelmingly large.\\n\\nSo I have an additional question: Though I see these 2 tradeoffs, in reality which one would dominate in terms of usefulness in the test cases given by whoever wrote them on leetcode?",
                "codeTag": "Unknown"
            },
            {
                "id": 1656844,
                "title": "solution-swift-combination-sum-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var path: [Int] = [], result: [[Int]] = []\\n        dfs(&result, &path, candidates.sorted(), target)\\n        return result\\n    }\\n    \\n    private func dfs(_ res: inout [[Int]], _ path: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int = 0) {\\n        guard t > 0 else { res.append(path); return }\\n        for k in idx..<cands.count where cands[k] <= t {\\n            if k > 0 && cands[k] == cands[k-1] && k != idx { continue }\\n            path.append(cands[k])\\n            dfs(&res, &path, cands, t - cands[k], k + 1)\\n            path.removeLast()\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.combinationSum2([10,1,2,7,6,1,5], 8)\\n        XCTAssertEqual(value, [[1,1,6],\\n                               [1,2,5],\\n                               [1,7],\\n                               [2,6]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum2([2,5,2,1,2], 5)\\n        XCTAssertEqual(value, [[1,2,2],[5]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        var path: [Int] = [], result: [[Int]] = []\\n        dfs(&result, &path, candidates.sorted(), target)\\n        return result\\n    }\\n    \\n    private func dfs(_ res: inout [[Int]], _ path: inout [Int], _ cands: [Int], _ t: Int, _ idx: Int = 0) {\\n        guard t > 0 else { res.append(path); return }\\n        for k in idx..<cands.count where cands[k] <= t {\\n            if k > 0 && cands[k] == cands[k-1] && k != idx { continue }\\n            path.append(cands[k])\\n            dfs(&res, &path, cands, t - cands[k], k + 1)\\n            path.removeLast()\\n        }\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.combinationSum2([10,1,2,7,6,1,5], 8)\\n        XCTAssertEqual(value, [[1,1,6],\\n                               [1,2,5],\\n                               [1,7],\\n                               [2,6]])\\n    }\\n    func test1() {\\n        let value = solution.combinationSum2([2,5,2,1,2], 5)\\n        XCTAssertEqual(value, [[1,2,2],[5]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815837,
                "title": "backtracking-recursion-python-solution-with-illustration",
                "content": "Example: sorted candidates = [1,1,6,7] target = 8\\n\\n![image](https://assets.leetcode.com/users/images/1c711892-adcc-4d31-be76-85188326afd3_1598585537.0711756.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates = sorted(candidates)\\n        self.dfs(candidates, target,[],res)\\n        \\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            if i>=1 and candidates[i] == candidates[i-1]:\\n               continue\\n            self.dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "Example: sorted candidates = [1,1,6,7] target = 8\\n\\n![image](https://assets.leetcode.com/users/images/1c711892-adcc-4d31-be76-85188326afd3_1598585537.0711756.png)\\n\\nYou could also refer to my post to other similar problems to nail this type of questions once for all:\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/815714/DFSrecursion-solution-with-illustration-to-understand-the-process) \\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/815837/Backtrackingrecursion-python-solution-with-illustration) \\n[46. Permutations](https://leetcode.com/problems/permutations/discuss/816693/python-solutionor93or-utilized-the-same-logic-for-problem-39-and-40or-with-illustration)\\n[93. Restore IP addresses](https://leetcode.com/problems/restore-ip-addresses/discuss/818933/python-backtracking-solution-or99or-with-illustration-and-example)\\n\\n\\t\\'\\'\\'\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        res = []\\n        candidates = sorted(candidates)\\n        self.dfs(candidates, target,[],res)\\n        \\n        return res\\n\\n    def dfs(self,candidates, target, path, res):\\n        if target==0:\\n            res.append(path)\\n            return\\n        for i in range(len(candidates)):\\n            if candidates[i]>target:\\n                continue\\n            if i>=1 and candidates[i] == candidates[i-1]:\\n               continue\\n            self.dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],res)\\n\\t\\t\\t\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 3441047,
                "title": "easy-to-understand-concise-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void comsum(vector<int> &curr, int target, int sum, vector<int> &candidates, int curInd, int n){\\n        if(target == sum){\\n            result.push_back(curr);\\n            return;\\n        }\\n        else if(sum>target){\\n            return;\\n        }\\n        \\n        for(int i = curInd; i < n; i++){\\n            if(i != curInd && candidates[i]==candidates[i-1])               //to avoid picking up the same combnations i.e. we don\\'t pick same element for certain kth position of a combination \\n                continue;\\n            sum += candidates[i];\\n            curr.push_back(candidates[i]);\\n            comsum(curr, target, sum, candidates, i+1, n);\\n            sum -= candidates[i];\\n            curr.pop_back();\\n        }\\n        \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> curr;\\n        int n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        comsum(curr, target, 0, candidates, 0, n);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546439,
                "title": "java-backtracking-optimized-for-duplicate-candidates-detailed-tc-explanation-added",
                "content": "**Backtracking**\\n```java\\n/**\\n * Backtracking\\n *\\n * Time Complexity:\\n * 1. The length of the potential combinations can vary from 1 to k where k = min(T/M , N).\\n * 2. Total number of combinations of size k is C(N,k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N,1) + 2*C(N,2) + ... + k*C(N,k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N, i)).\\n * If k = N, then above time complexity becomes O(N * 2^(N-1))\\n *\\n * Space Complexity: O(min(T/M , N))\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(candidates);\\n        combinationSum2Helper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            // Skipping duplicate numbers.\\n            if (i > start && candidates[i - 1] == candidates[i]) {\\n                continue;\\n            }\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSum2Helper(candidates, i + 1, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Optimized Backtracking by using a Count Map and Unique Num List**\\n```\\n/**\\n * Optimized Backtracking by using a Count Map and Unique Num List\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * add time & space required for creating the count map and a sorted list of\\n * unique candidates.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int c : candidates) {\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n        List<Integer> uniqueNumList = new ArrayList<>(countMap.keySet());\\n        Collections.sort(uniqueNumList);\\n\\n        combinationSum2Helper(countMap, uniqueNumList, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(HashMap<Integer, Integer> countMap, List<Integer> uniqueNumList, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < uniqueNumList.size(); i++) {\\n            int num = uniqueNumList.get(i);\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            if (num > target) {\\n                break;\\n            }\\n\\n            tempList.add(num);\\n            countMap.put(num, count - 1);\\n            combinationSum2Helper(countMap, uniqueNumList, i, target - num, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Combination Sum questions on LeetCode:\\n- [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1546400/Java-or-Backtracking-w-Early-Exit-(Detailed-Time-Complexity-explanation-added))\\n- [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/1546449/Java-or-Optimized-Backtracking-w-Detailed-Time-Complexity-explanation)\\n- [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/discuss/1546467/Java-or-TC:-O(N*T)-or-SC:-O(T)-or-DP-(BottomUp-and-TopDown)-w-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\n/**\\n * Backtracking\\n *\\n * Time Complexity:\\n * 1. The length of the potential combinations can vary from 1 to k where k = min(T/M , N).\\n * 2. Total number of combinations of size k is C(N,k) and time to add each such combination in the result list is O(K).\\n * Therefore the total time complexity will be O(1*C(N,1) + 2*C(N,2) + ... + k*C(N,k))\\n *                                             = (i = 1 -> k) \\u2211 (i * C(N, i)).\\n * If k = N, then above time complexity becomes O(N * 2^(N-1))\\n *\\n * Space Complexity: O(min(T/M , N))\\n *\\n * N = Length of input array. T = Target. M = Minimum value in the input array.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        Arrays.sort(candidates);\\n        combinationSum2Helper(candidates, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(int[] candidates, int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < candidates.length; i++) {\\n            // Skipping duplicate numbers.\\n            if (i > start && candidates[i - 1] == candidates[i]) {\\n                continue;\\n            }\\n            if (candidates[i] > target) {\\n                break;\\n            }\\n            tempList.add(candidates[i]);\\n            combinationSum2Helper(candidates, i + 1, target - candidates[i], tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * Optimized Backtracking by using a Count Map and Unique Num List\\n *\\n * Time & Space Complexity explanation is same as above. We will only need to\\n * add time & space required for creating the count map and a sorted list of\\n * unique candidates.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (candidates == null || candidates.length == 0) {\\n            return result;\\n        }\\n\\n        HashMap<Integer, Integer> countMap = new HashMap<>();\\n        for (int c : candidates) {\\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\\n        }\\n        List<Integer> uniqueNumList = new ArrayList<>(countMap.keySet());\\n        Collections.sort(uniqueNumList);\\n\\n        combinationSum2Helper(countMap, uniqueNumList, 0, target, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum2Helper(HashMap<Integer, Integer> countMap, List<Integer> uniqueNumList, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   int start, int target, List<Integer> tempList, List<List<Integer>> result) {\\n        if (target == 0) {\\n            result.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n\\n        for (int i = start; i < uniqueNumList.size(); i++) {\\n            int num = uniqueNumList.get(i);\\n            int count = countMap.get(num);\\n            if (count == 0) {\\n                continue;\\n            }\\n            if (num > target) {\\n                break;\\n            }\\n\\n            tempList.add(num);\\n            countMap.put(num, count - 1);\\n            combinationSum2Helper(countMap, uniqueNumList, i, target - num, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n            countMap.put(num, count);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17035,
                "title": "my-concise-14ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            combHelper(num, 0, num.size(), target, vector<int>(), result);\\n            return result;\\n        }\\n        \\n        void combHelper(vector<int>& a, int start, int n, int target, \\n        vector<int> cur_vec, vector<vector<int> >& result) {\\n            \\n            if (target == 0) {\\n                result.push_back(cur_vec);\\n                return;\\n            }\\n            int i = start;\\n            while(i < n  && target-a[i] >= 0) {\\n                // NOTE : this condition helps neglecting making identical sets\\n                //  this is the catch of this question\\n                if (i == start || a[i] != a[i-1]) {\\n                    cur_vec.push_back(a[i]);\\n                    combHelper(a, i+1, n, target-a[i], cur_vec, result);\\n                    cur_vec.pop_back();\\n                }\\n                i++;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n            vector<vector<int> > result;\\n            sort(num.begin(), num.end());\\n            combHelper(num, 0, num.size(), target, vector<int>(), result);\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 883077,
                "title": "very-easy-python-solution-beats-98-related-problems-to-solve",
                "content": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        def backtrack(nums,targetLeft,path):\\n            \\n            if targetLeft==0:\\n                res.append(path)\\n                return\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                if nums[i]>targetLeft:\\n                    break\\n                backtrack(nums[i+1:],targetLeft-nums[i],path+[nums[i]])    \\n            \\n        res=[]\\n        backtrack(sorted(candidates),target,[])\\n        return res\\n```\\n\\nOther related Qs to solve that will help:\\n#77 Combinations\\n#permutations LC 76\\n#permutations II \\n#subsets\\n#subsets II\\n#combinations sum LC 39",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        \\n        def backtrack(nums,targetLeft,path):\\n            \\n            if targetLeft==0:\\n                res.append(path)\\n                return\\n            \\n            for i in range(len(nums)):\\n                if i>0 and nums[i]==nums[i-1]:\\n                    continue\\n                if nums[i]>targetLeft:\\n                    break\\n                backtrack(nums[i+1:],targetLeft-nums[i],path+[nums[i]])    \\n            \\n        res=[]\\n        backtrack(sorted(candidates),target,[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889492,
                "title": "simple-java-solution-with-comments-beats-98-2ms",
                "content": "**Algorithm:**\\n- Sort the array to ensure we have duplicate elements together.\\n- For every element in the array\\n\\t- include the element and see if we can achieve target\\n\\t- exclude the element and see if we can achieve target\\n\\t\\t- while exclusion skip all the duplicate entries\\n\\n```\\n// solution using exclusion/inclusion principle\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // To ensure duplicate elements are clustered\\n\\t\\tArrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res, new ArrayList<>(), candidates, 0, target);\\n        return res;\\n    }\\n    \\n    \\n    private void helper(List<List<Integer>> res, List<Integer> path, int[] a, int start, int target) {\\n        if(target == 0) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        if(start == a.length) return;\\n        \\n        // As the elements are sorted in increasing order; we  need to process only if the condition holds\\n\\t\\tif(a[start] <= target) {\\n            // include\\n            path.add(a[start]);\\n            helper(res, path, a, start+1, target-a[start]);\\n            // exclude\\n            path.remove(path.size()-1);\\n            // Skip all duplicate entries\\n            while(start+1 < a.length && a[start] == a[start+1]) start += 1;\\n            helper(res, path, a, start+1, target);\\n        }\\n    }\\n}\\n```\\n\\n**Please Vote up, if this helped you!!**\\n\\nHappy Coding!! :)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// solution using exclusion/inclusion principle\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // To ensure duplicate elements are clustered\\n\\t\\tArrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        helper(res, new ArrayList<>(), candidates, 0, target);\\n        return res;\\n    }\\n    \\n    \\n    private void helper(List<List<Integer>> res, List<Integer> path, int[] a, int start, int target) {\\n        if(target == 0) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        if(start == a.length) return;\\n        \\n        // As the elements are sorted in increasing order; we  need to process only if the condition holds\\n\\t\\tif(a[start] <= target) {\\n            // include\\n            path.add(a[start]);\\n            helper(res, path, a, start+1, target-a[start]);\\n            // exclude\\n            path.remove(path.size()-1);\\n            // Skip all duplicate entries\\n            while(start+1 < a.length && a[start] == a[start+1]) start += 1;\\n            helper(res, path, a, start+1, target);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211544,
                "title": "best-c-2-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time complexity : O(2^N*K), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain K subset. so total time\\n    complexity is O(2^N*K).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n    Note : This approach will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n                if(!isPresent){\\n                    output.push_back(temp);\\n                }\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum2(candidates, target-candidates[index], output, temp, index+1);\\n            temp.pop_back();\\n        }\\n        combinationSum2(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                if(i>index && candidates[i] == candidates[i-1]){\\n                    continue;\\n                }\\n                temp.push_back(candidates[i]);\\n                combinationSum2(candidates, target-candidates[i], output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time complexity : O(2^N*K), For every index, we make 2 recursion calls and there are N elements and for\\n    every subset we are checking duplicates in output and in worst case it can contain K subset. so total time\\n    complexity is O(2^N*K).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n    Note : This approach will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(index == candidates.size()){\\n            if(target == 0){\\n                bool isPresent = find(output.begin(), output.end(), temp) != output.end();\\n                if(!isPresent){\\n                    output.push_back(temp);\\n                }\\n            }\\n            return;\\n        }\\n        if(candidates[index] <= target){\\n            temp.push_back(candidates[index]);\\n            combinationSum2(candidates, target-candidates[index], output, temp, index+1);\\n            temp.pop_back();\\n        }\\n        combinationSum2(candidates, target, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(2^N).\\n\\n    Space complexity : O(N*K), In worst case there can be N*K subsets and for every subset, we need O(N) \\n    space on average so total space complexity is O(N*K).\\n\\n    Solved using Array + BackTracking.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void combinationSum2(vector<int>& candidates, int target, vector<vector<int>> &output, vector<int> &temp, int index){\\n        if(target < 0){\\n            return;\\n        }\\n        else if(target == 0){\\n            output.push_back(temp);\\n        }\\n        else{\\n            for(int i=index; i<candidates.size(); i++){\\n                if(i>index && candidates[i] == candidates[i-1]){\\n                    continue;\\n                }\\n                temp.push_back(candidates[i]);\\n                combinationSum2(candidates, target-candidates[i], output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum2(candidates, target, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934668,
                "title": "backtracking-solution-with-time-complexity-explanations-in-c",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- As we have to return all the unique combinations, so we\\u2019ll sort the array to skip duplicates.\\n- The base case for our helper function is when the target will be 0 then we\\u2019ll push our temp to ans.\\n- So here for every recursion, we\\u2019ll take a loop to check which could be our next possible element. Here we can have 2 cases:\\n    - `if(i>index && candidates[i]==candidates[i-1])` we\\u2019ve already taken an element with the same value of current element, so simply skip it.\\n    - `if(candidates[i] > target)` as current element is greater than target & the array is in sorted order, so no chance to get any possible solution from the next elements, so break the loop.\\n- We\\u2019ll push the current element to our temp vector & call recursion for the next index, also reducing the target value.\\n- After the call, we\\u2019ve to pop the current element from temp as we already used this element.\\n- **Time complexity:** O(2^n * k), where 2^n is the total number of subsequences & k is the average of every combination.\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, temp, ans, candidates, target);\\n        return ans;\\n    }\\n    void helper(int index, vector<int> &temp, vector<vector<int>> &ans, vector<int>& candidates, int target){\\n        if(target == 0){\\n            ans.push_back(temp);\\n            return; \\n        }\\n        \\n        for(int i=index; i<candidates.size(); i++){\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i] > target) break;\\n            \\n            temp.push_back(candidates[i]);\\n            helper(i+1, temp, ans, candidates, target-candidates[i]);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, temp, ans, candidates, target);\\n        return ans;\\n    }\\n    void helper(int index, vector<int> &temp, vector<vector<int>> &ans, vector<int>& candidates, int target){\\n        if(target == 0){\\n            ans.push_back(temp);\\n            return; \\n        }\\n        \\n        for(int i=index; i<candidates.size(); i++){\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i] > target) break;\\n            \\n            temp.push_back(candidates[i]);\\n            helper(i+1, temp, ans, candidates, target-candidates[i]);\\n            temp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16871,
                "title": "time-complexity-analysis-of-recursive-approach",
                "content": "On the first thought, the time complexity analysis of this brute force approach looks difficult. We are going through each element and calling recursively on each of those elements. Is it n ^ n ? \\n\\nThe fact that we are doing brute force gives us the answer of complexity. If you think, we are essentially selecting all possible subsets of  of set.\\n\\n{1,2,3} -> {1} {2} {3} {1,2} {1,3} {2,3} {1,2,3}\\n\\nThere are **2 ^n** such elements and hence the time complexity is **O(2^n)**\\n\\n**Example:**\\nIt is easy to see this with example also. We select input that will explore all the paths such as {1,2,3,4,5,6,7} and the target is big enough so it will not prune any path. It will call the iteration  128 times.\\n```\\npublic class Solution {\\n\\t  public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t        \\n\\t        List<List<Integer>> answer = new ArrayList<>();\\n\\t        if(candidates == null || candidates.length == 0){return answer;}\\n\\t        \\n\\t        // Sort the array, it is needed to take care of duplicates and effective pruning\\n\\t        Arrays.sort(candidates);\\n\\t        \\n\\t        dfs(0, candidates, target, new ArrayList<>(), answer);\\n\\t        return answer;\\n\\t    }\\n\\t    \\n\\t   private static int complexity = 0; \\n\\t  \\n\\t    private void dfs(int index, int candidates[], int target, List <Integer> path, List<List<Integer>> answer){\\n\\t        if(target == 0){\\n\\t            // The path gives us answer\\n\\t            answer.add(new ArrayList<>(path));\\n\\t            // Return back as numbers after this will be bigger and will not give us answer\\n\\t            return;\\n\\t        }\\n\\t        \\n\\t        complexity ++;\\n\\t        \\n\\t        for(int i = index; i < candidates.length; i++){\\n\\t            \\n\\t            // Avoid visiting duplicate elements\\n\\t            if(i != index && candidates[i] == candidates[i-1]){ continue; }\\n\\t            \\n\\t            // This element and all that will appear after this are too big\\n\\t            if(target - candidates[i] < 0){break;}\\n\\t                \\n\\t            path.add(candidates[i]);\\n\\t            \\n\\t            dfs(i + 1, candidates, target-candidates[i], path, answer);\\n\\t            \\n\\t            path.remove(path.size()-1);\\n\\t        }\\n\\t    }\\n    public static void main(String[] args) {\\n\\t\\tSystem.out.println(new Solution().combinationSum2(new int []{1,2,3,4,5,6,7}, 1000));\\n\\t\\tSystem.out.println(complexity);\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\t  public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t        \\n\\t        List<List<Integer>> answer = new ArrayList<>();\\n\\t        if(candidates == null || candidates.length == 0){return answer;}\\n\\t        \\n\\t        // Sort the array, it is needed to take care of duplicates and effective pruning\\n\\t        Arrays.sort(candidates);\\n\\t        \\n\\t        dfs(0, candidates, target, new ArrayList<>(), answer);\\n\\t        return answer;\\n\\t    }\\n\\t    \\n\\t   private static int complexity = 0; \\n\\t  \\n\\t    private void dfs(int index, int candidates[], int target, List <Integer> path, List<List<Integer>> answer){\\n\\t        if(target == 0){\\n\\t            // The path gives us answer\\n\\t            answer.add(new ArrayList<>(path));\\n\\t            // Return back as numbers after this will be bigger and will not give us answer\\n\\t            return;\\n\\t        }\\n\\t        \\n\\t        complexity ++;\\n\\t        \\n\\t        for(int i = index; i < candidates.length; i++){\\n\\t            \\n\\t            // Avoid visiting duplicate elements\\n\\t            if(i != index && candidates[i] == candidates[i-1]){ continue; }\\n\\t            \\n\\t            // This element and all that will appear after this are too big\\n\\t            if(target - candidates[i] < 0){break;}\\n\\t                \\n\\t            path.add(candidates[i]);\\n\\t            \\n\\t            dfs(i + 1, candidates, target-candidates[i], path, answer);\\n\\t            \\n\\t            path.remove(path.size()-1);\\n\\t        }\\n\\t    }\\n    public static void main(String[] args) {\\n\\t\\tSystem.out.println(new Solution().combinationSum2(new int []{1,2,3,4,5,6,7}, 1000));\\n\\t\\tSystem.out.println(complexity);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16958,
                "title": "8ms-c-backtracking-easy-to-understand",
                "content": "    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        sort(candidates.begin(),candidates.end());\\n        backTracking(candidates.begin(),current,res,candidates,target);\\n        return res;\\n    }\\n    \\n    void backTracking(vector<int>::iterator n, vector<int>& current,vector<vector<int>>& res, const vector<int>& candidates, int target){\\n        if(!target) res.push_back(current);\\n        else if(target>0){\\n            for(;n!=candidates.end()&&*n<=target;++n){\\n                current.push_back(*n);\\n                backTracking(n+1,current,res,candidates,target-*n);\\n                current.pop_back();\\n                while(n+1!=candidates.end()&&*(n+1)==*n) ++n;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> res;\\n        vector<int> current;\\n        sort(candidates.begin(),candidates.end());\\n        backTracking(candidates.begin(),current,res,candidates,target);\\n        return res;\\n    }\\n    \\n    void backTracking(vector<int>::iterator n, vector<int>& current,vector<vector<int>>& res, const vector<int>& candidates, int target){\\n        if(!target) res.push_back(current);\\n        else if(target>0){\\n            for(;n!=candidates.end()&&*n<=target;++n){\\n                current.push_back(*n);\\n                backTracking(n+1,current,res,candidates,target-*n);\\n                current.pop_back();\\n                while(n+1!=candidates.end()&&*(n+1)==*n) ++n;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 738352,
                "title": "javascript-fast-solution-avoid-duplication",
                "content": "```\\nvar combinationSum2 = function(candidates, target) {\\n    if (!candidates || candidates.length == 0) return [];\\n    let res = [];\\n    candidates.sort((a,b) => a-b);\\n    var helper = function(curSum, cur, index){\\n        if (curSum == target){\\n            res.push([...cur]);\\n            return;\\n        }\\n        for(let i = index; i < candidates.length; i++){\\n            if (i != index && candidates[i] == candidates[i-1]) continue; //already return, go next loop(not recursion)\\n            if (curSum > target) return;\\n            cur.push(candidates[i]);\\n            helper(curSum+candidates[i], cur, i+1);\\n            cur.pop();\\n        }\\n    }\\n    helper(0, [], 0);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n    if (!candidates || candidates.length == 0) return [];\\n    let res = [];\\n    candidates.sort((a,b) => a-b);\\n    var helper = function(curSum, cur, index){\\n        if (curSum == target){\\n            res.push([...cur]);\\n            return;\\n        }\\n        for(let i = index; i < candidates.length; i++){\\n            if (i != index && candidates[i] == candidates[i-1]) continue; //already return, go next loop(not recursion)\\n            if (curSum > target) return;\\n            cur.push(candidates[i]);\\n            helper(curSum+candidates[i], cur, i+1);\\n            cur.pop();\\n        }\\n    }\\n    helper(0, [], 0);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16933,
                "title": "my-84ms-python-recursive-solution",
                "content": "    class Solution:\\n        def combinationSum2(self, candidates, target):\\n            candidates.sort()\\n            return self.search(candidates, 0 ,target)\\n    \\n        def search(self, candidates, start, target):\\n            if target==0:\\n                return [[]]\\n            res=[]\\n            for i in xrange(start,len(candidates)):\\n                if i!=start and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                for r in self.search(candidates, i+1, target-candidates[i]):\\n                    res.append([candidates[i]]+r)\\n            return res",
                "solutionTags": [],
                "code": "    class Solution:\\n        def combinationSum2(self, candidates, target):\\n            candidates.sort()\\n            return self.search(candidates, 0 ,target)\\n    \\n        def search(self, candidates, start, target):\\n            if target==0:\\n                return [[]]\\n            res=[]\\n            for i in xrange(start,len(candidates)):\\n                if i!=start and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                for r in self.search(candidates, i+1, target-candidates[i]):\\n                    res.append([candidates[i]]+r)\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 3866692,
                "title": "easy-explanation-using-images-and-dry-run-using-set-without-set",
                "content": "# Understanding the Question\\nHELLO! Lets analyze how to solve this problem. well if you are solving this problem then i am assuming that you already solved **Combination Sum 1 problem** , Where we could pick any value multiple times. \\nThis problem is a little different. Here we cant choose a single value multiple times, also here is one more thing. if we get ans=[[1,7],[7,1]] then our final ans will be [[1,7]] as duplicate combinations are not allowed.\\n\\n# Approach\\nIn combination sum 1 problem we had two choices--\\n- Either pick the current element and again pick the same element.\\n**OR**\\n- dont pick the current element, move 1 step ahead and repeat the same process\\n\\nBut in combination sum 2 problem we cant choose one value multiple times. so what options do we have?\\n- Either choose the value and move ahead\\n**OR**\\n- Dont pick the value and move ahead\\n\\nso how will our recurrence relations will look?\\n\\n- f(i+1,sum-arr[i],arr)  ***Pick the value and move on to next index***\\n**OR**\\n- f(i+1,sum,arr)  ***dont pick the value but move onto next index***\\n\\nnow take a simple example to understand recursive calls:\\nlets take **arr=[1,1,7]** and **target=8**\\nhere i have attached a picture where pick and not_pick calls happens\\n*(pardon my drawing, i draw using trackpad)*\\n\\n![Screenshot (11).png](https://assets.leetcode.com/users/images/295b4fbd-00f7-46ce-83d0-06d0942eec33_1691228467.687165.png)\\n\\nhere as you can see at last we are getting 2 answers [[1,7],[1,7]]\\nbut as we know duplicate combinations are not allowed so we have to find a way to only get one set of combination.\\n\\n***There are Two ways-***\\n1. Using Set Data Structure\\n2. Using Brain\\n\\n*i will not talk about how to use set as it is very easy.Although i will share the code using set ds.*\\n\\n**Lets talk about the second approach--**\\n1. if you carefully observe the answer of test cases in this problem you can notice that all the combination set are sorted. means [1,7] then [2,6] this way.\\nso to achive combinations in sorted order we need to sort our arr as well.\\n2. our main reason why we are getting [1,7] twice is because there is two 1 in our arr.\\nif u see previous image which i attached u will see that when i picked the 1 **[0th index]** i got [1,7] as an answer combination. \\nand when i **didn\\'t picked** the 1 **[0th index]** i had another 1 **[1st index]** which is going in the next recursive call and giving me an extra [1,7] combination.\\n\\n3. so if i can manipulate my code in a way that at the time of not picking the element, which i already picked **1** **[0th index]** ,will not go to the not pick call with the same value then we can avoid getting the duplicate.\\n\\n![Screenshot (12).png](https://assets.leetcode.com/users/images/7ba37cfd-eb6c-4b35-9068-4fa510c92856_1691230268.4377675.png)\\n\\n4. see here i picked 1**[0th index]**  which is okay.\\n5. but when i am not picking 1[0th index], i am not letting any 1 value pass to the not pick call.\\n6. i have picked 1 so at the time of not pick i\\'ll avoid all the 1 present in the array.\\n7. to skip all the 1, i have used a loop. \\n8. pick 1 and go to next index. \\nbut if dont pick 1 then dont pick any 1 value and go directly to the next unique element which is 7.\\n\\nI am not explaning about the base case here. if you r having hard time finding how i got the base case then plz comment down below. I will reply.\\n\\n***now see the above 2 picture again. spot the difference.***\\n# PLZ UPVOTE IF YOU UNDERSTOOD THE APPROACH (\\u25CF\\'\\u25E1\\'\\u25CF)\\n\\n# Time Complexity:\\nTime complexity will be $O(2^n*n)$\\n$2^n$ because every element have two choices either pick or not pick.\\nand n extra because we are using a while loop inside the recursive function which will add n time complexity.\\n\\n# Code using SET\\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if i==len(arr):\\n            if target==0:\\n                ans.add(tuple(ds))\\n            return\\n\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans)\\n            ds.pop()\\n        self.f(i+1,arr,target,ds,ans)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=set()\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return [list(combination) for combination in ans]\\n```\\n\\n# Code Using Brain\\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if target==0:\\n            ans.append(ds.copy())\\n            return\\n        if i>=len(arr):\\n            return\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans) #PICK\\n            ds.pop()\\n        j=i+1\\n        while(j<len(arr) and arr[j]==arr[j-1]):\\n            j+=1\\n        self.f(j,arr,target,ds,ans) #NOT PICK\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=[]\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if i==len(arr):\\n            if target==0:\\n                ans.add(tuple(ds))\\n            return\\n\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans)\\n            ds.pop()\\n        self.f(i+1,arr,target,ds,ans)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=set()\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return [list(combination) for combination in ans]\\n```\n```\\nclass Solution:\\n    def f(self,i,arr,target,ds,ans):\\n        # BASE CASE\\n        if target==0:\\n            ans.append(ds.copy())\\n            return\\n        if i>=len(arr):\\n            return\\n        # RECURENCE RELATION\\n        if target>=arr[i]:\\n            ds.append(arr[i])\\n            self.f(i+1,arr,target-arr[i],ds,ans) #PICK\\n            ds.pop()\\n        j=i+1\\n        while(j<len(arr) and arr[j]==arr[j-1]):\\n            j+=1\\n        self.f(j,arr,target,ds,ans) #NOT PICK\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ds=[]\\n        ans=[]\\n        candidates.sort()\\n        self.f(0,candidates,target,ds,ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057690,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target, set<vector<int>>& s)\\n    {\\n        if(target == 0) \\n        {\\n            s.insert(temp);\\n            return;\\n        } \\n        if(target<0 || i==arr.size())\\n            return;\\n        temp.push_back(arr[i]); \\n        solve(i+1, arr, temp, target - arr[i], s); \\n        temp.pop_back();\\n        while(i<arr.size()-1 && arr[i]==arr[i+1])\\n            i++;\\n        solve(i + 1, arr, temp, target, s);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        vector<int> temp;\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> s;\\n        solve(0, arr, temp, target, s);\\n        vector<vector<int>> ans;\\n        for(auto v:s)\\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i, vector<int>& arr, vector<int>& temp, int target, set<vector<int>>& s)\\n    {\\n        if(target == 0) \\n        {\\n            s.insert(temp);\\n            return;\\n        } \\n        if(target<0 || i==arr.size())\\n            return;\\n        temp.push_back(arr[i]); \\n        solve(i+1, arr, temp, target - arr[i], s); \\n        temp.pop_back();\\n        while(i<arr.size()-1 && arr[i]==arr[i+1])\\n            i++;\\n        solve(i + 1, arr, temp, target, s);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        vector<int> temp;\\n        sort(arr.begin(), arr.end());\\n        set<vector<int>> s;\\n        solve(0, arr, temp, target, s);\\n        vector<vector<int>> ans;\\n        for(auto v:s)\\n            ans.push_back(v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905802,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = candidates.sorted()\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ input: [Int], _ target: Int, _ index: Int) {\\n            var path = path\\n            var last: Int?\\n\\n            for (i, num) in input.enumerated() {\\n                if let last = last, last == num { continue }\\n                if i <= index { continue }\\n                if num == target {\\n                    res.append(path + [num])\\n                    break\\n                }\\n                if num > target { break }\\n                if num < target {\\n                    path.append(num)\\n                    backtrack(path, input, target - num, i)\\n                    path.remove(at: path.count - 1)\\n                }\\n                last = num\\n            }\\n        }\\n        backtrack([], sorted, target, -1)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        let sorted = candidates.sorted()\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ input: [Int], _ target: Int, _ index: Int) {\\n            var path = path\\n            var last: Int?\\n\\n            for (i, num) in input.enumerated() {\\n                if let last = last, last == num { continue }\\n                if i <= index { continue }\\n                if num == target {\\n                    res.append(path + [num])\\n                    break\\n                }\\n                if num > target { break }\\n                if num < target {\\n                    path.append(num)\\n                    backtrack(path, input, target - num, i)\\n                    path.remove(at: path.count - 1)\\n                }\\n                last = num\\n            }\\n        }\\n        backtrack([], sorted, target, -1)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16877,
                "title": "java-short-and-recursive-clean-code",
                "content": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> comb = new ArrayList<>();\\n\\t\\tArrays.sort(candidates); // need sort to make this work.\\n\\t\\tcombination(candidates, target, 0, comb, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate void combination(int[] candi, int target, int start,\\n\\t\\t\\tList<Integer> comb, List<List<Integer>> ans) {\\n\\t\\tfor (int i = start; i < candi.length; i++) {\\n\\t\\t\\tif (i > start && candi[i] == candi[i - 1]) //remove duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (candi[i] == target) {\\n\\t\\t\\t\\t//recursion exit.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tans.add(newComb);\\n\\t\\t\\t} else if (candi[i] < target) {\\n\\t\\t\\t\\t//continue to look for the rest.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tcombination(candi, target - candi[i], i + 1, newComb, ans);\\n\\t\\t\\t} else \\n\\t\\t\\t\\tbreak; //invalid path, return nothing.\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> comb = new ArrayList<>();\\n\\t\\tArrays.sort(candidates); // need sort to make this work.\\n\\t\\tcombination(candidates, target, 0, comb, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate void combination(int[] candi, int target, int start,\\n\\t\\t\\tList<Integer> comb, List<List<Integer>> ans) {\\n\\t\\tfor (int i = start; i < candi.length; i++) {\\n\\t\\t\\tif (i > start && candi[i] == candi[i - 1]) //remove duplicates.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif (candi[i] == target) {\\n\\t\\t\\t\\t//recursion exit.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tans.add(newComb);\\n\\t\\t\\t} else if (candi[i] < target) {\\n\\t\\t\\t\\t//continue to look for the rest.\\n\\t\\t\\t\\tList<Integer> newComb = new ArrayList<>(comb);\\n\\t\\t\\t\\tnewComb.add(candi[i]);\\n\\t\\t\\t\\tcombination(candi, target - candi[i], i + 1, newComb, ans);\\n\\t\\t\\t} else \\n\\t\\t\\t\\tbreak; //invalid path, return nothing.\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 708266,
                "title": "c-combinations-i-ii-and-iii",
                "content": "**Combinations I :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations II :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\\n**Combinations III :**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int>& candidates,vector<int> &combination,int pos,int target){\\n        if(!target){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i < candidates.size() && target >= candidates[i]; i++){\\n            if(i > pos && candidates[i] == candidates[i-1]) continue;\\n            combination.emplace_back(candidates[i]);\\n            helper(res,candidates,combination,i + 1,target - candidates[i]);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res,candidates,combination,0,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res,vector<int> &combination,int pos,int target,int k){\\n        if(!target && combination.size() == k){\\n            res.emplace_back(combination);\\n        }\\n        for(int i = pos; i <= 9; i++){\\n            combination.emplace_back(i);\\n            helper(res,combination,i + 1,target - i,k);\\n            combination.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n        vector<int> combination;\\n        helper(res, combination, 1, n, k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451893,
                "title": "small-difference-between-combination-sum-1-and-2-c-backtracking",
                "content": "**Combination Sum I**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i,n,candidates, temp,target - candidates[i]); \\n                // passing i because we may want to add the current value at candidate[i] again\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\\n\\n**Combination Sum II**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i+1,n,candidates, temp,target - candidates[i]); \\n                // passing i+1 because we can\\'t include a value twice hence after adding we move to the next element\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\\n\\nAs you can see the only **difference** in the above two codes is the ith parameter we pass in our recursive function.\\nIn Combination Sum I, we may want to add the current element again so we don\\'t increment i while passing it to the recursive function.\\nIn Combination Sum II, each number may be used only once hence once we include an element we move on to the next element by incrementing i by 1.\\n\\nTime complexity is O(2^n) because for every number we have two choices.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i,n,candidates, temp,target - candidates[i]); \\n                // passing i because we may want to add the current value at candidate[i] again\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(int i, int n, vector<int>& candidates,vector<int> &temp, int target)\\n    {\\n        \\n        if(target == 0) {res.push_back(temp); return;} // if target achieved push the current vector\\n        if(i==n) return;\\n        int start = i;\\n        while(i<n){\\n            if(i!=start && candidates[i] == candidates[i-1]) {i++;continue;} // for removing duplicates \\n            if(candidates[i] <= target) {\\n                temp.push_back(candidates[i]);\\n                solve(i+1,n,candidates, temp,target - candidates[i]); \\n                // passing i+1 because we can\\'t include a value twice hence after adding we move to the next element\\n                temp.pop_back();\\n            }\\n            else break; /*just to optimise a bit as all the next elements are greater than \\n            current element since the candidates array is sorted */\\n            i++;\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0,n,candidates,temp,target);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934838,
                "title": "two-dp-solutions-in-java-with-explanation",
                "content": "# Method 1: With Hash Table\\nConsider a 2D dp array, where `dp[i][j]` is all combinations using `candidates[0]` to `candidates[i]` that sum to `j`. Our goal is `dp[n - 1][target]`, where `n` is the number of candidates.\\n\\nThe transition function is `dp[i][j] = d[i - 1][j] + d[i - 1][j - candidates[i]].add(candidates[i])`. \\n\\nThe first term on right hand side, `d[i - 1][j]`, is all combinations using `candidates[0]` to `candidates[i - 1]` that sum to `j`. This is part of `d[i][j]`, when we don\\'t include `candidates[i]` in the combination (because the sum is already `j`). \\n\\nThe second term on right hand side, `d[i - 1][j - candidates[i]]` is all combinations using `candidates[0]` to `candidates[i - 1]` that sum to `j - candidates[i]`. This is other parts of `d[i][j]` when we include `candidates[i]` in the combination (because `j - candidates[i] + candidates[i] = j`. \\n\\n`.add(candidates[i])` means we are adding `candidates[i]` to each of the combination in `d[i - 1][j - candidates[i]]`\\n\\nSince the `candidates[]` array has duplicates, we need to avoid adding duplicate combinations to our result. We can use hash table to accomplish this, the dp array can be defined as:\\n```java\\n// dp array simplified to 1D, as we always use d[i][j] and d[i - 1][j] (the last two rows of the 2D dp array\\nSet<List<Integer>>[] dp = new Set[target + 1];\\n```\\n\\nWe also need to sort the `candidates` array to avoid duplicates. Consider candidates being `[1,6,1,1]`, and target is `7`. If we don\\'t sort, we would have `[1,6],[6,1],[6,1]` as the combination. The hash table will only screen the two `[6,1]`, but not `[1,6],[6,1]`, because they are considered different `List<Integer>`. If we sort the candidate so it becomes `[1,1,1,6]`, and the three combinations sum to `7` is `[1,6],[1,6],[1,6]`, hash table can screen off duplicates, only one `[1,6]` will be present in the result.\\n\\n\\nBelow is the java code:\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort candidates, to avoid duplicate combibation\\n        Arrays.sort(candidates);\\n\\n        // initialize dp array\\n        Set<List<Integer>>[] dp = new Set[target + 1];\\n        for (int i = 0; i <= target; i++) {\\n            dp[i] = new HashSet<>();\\n        }\\n\\n        // base case when target is 0 and not picking first candidate\\n        dp[0].add(new ArrayList<>());\\n\\n        // populate the dp array\\n        for (int i = 0; i < candidates.length; i++) {\\n            for (int j = target; j >= candidates[i]; j--) {\\n                for (List<Integer> comb : dp[j - candidates[i]]) {\\n                    List<Integer> newComb = new ArrayList<>(comb);\\n                    newComb.add(candidates[i]);\\n                    dp[j].add(newComb);\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(dp[target]);\\n    }\\n}\\n```\\n\\n# Method 2: Without Hash Table\\nThis method has the same time and space complexity as method 1, so there is no advantage with respect to time/space. Just another way of thinking. \\n\\nWe keep two lists, `combs` to store all the temporary combinations we encountered, `sums` to store the sum for those combinations. When adding `candidates[i]` to our current collection of combinations, we check if its been encountered before. If so, we will not add it to earlier combinations (because those combinations already contain this number). For any combinations that sum to `target`, we add it to the final result.\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort the array to skip duplicates\\n        Arrays.sort(candidates);\\n        \\n        // initialize combs and sums\\n        List<List<Integer>> combs = new ArrayList<>(), res = new ArrayList<>();\\n        List<Integer> sums = new ArrayList<>();        \\n        combs.add(new ArrayList<>());\\n        sums.add(0);\\n\\n        int startIndex = 0, n = candidates.length, size = combs.size();\\n        for (int i = 0; i < candidates.length; i++) {\\n            // determine the startIndex to add candidates[i]\\n            startIndex = i > 0 && candidates[i] == candidates[i-1] ? size : 0;\\n            size = combs.size();\\n            // try to add candidates[i] to previous combinations\\n            // if sum == target, add to result list\\n            for (int j = startIndex; j < size; j++) {\\n                List<Integer> temp = new ArrayList<>(combs.get(j));\\n                temp.add(candidates[i]);\\n                int sum = sums.get(j) + candidates[i];\\n                if (sum == target) {\\n                    res.add(temp);\\n                } else if (sum < target) {\\n                    combs.add(temp);\\n                    sums.add(sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\n// dp array simplified to 1D, as we always use d[i][j] and d[i - 1][j] (the last two rows of the 2D dp array\\nSet<List<Integer>>[] dp = new Set[target + 1];\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort candidates, to avoid duplicate combibation\\n        Arrays.sort(candidates);\\n\\n        // initialize dp array\\n        Set<List<Integer>>[] dp = new Set[target + 1];\\n        for (int i = 0; i <= target; i++) {\\n            dp[i] = new HashSet<>();\\n        }\\n\\n        // base case when target is 0 and not picking first candidate\\n        dp[0].add(new ArrayList<>());\\n\\n        // populate the dp array\\n        for (int i = 0; i < candidates.length; i++) {\\n            for (int j = target; j >= candidates[i]; j--) {\\n                for (List<Integer> comb : dp[j - candidates[i]]) {\\n                    List<Integer> newComb = new ArrayList<>(comb);\\n                    newComb.add(candidates[i]);\\n                    dp[j].add(newComb);\\n                }\\n            }\\n        }\\n\\n        return new ArrayList<>(dp[target]);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        // we need to sort the array to skip duplicates\\n        Arrays.sort(candidates);\\n        \\n        // initialize combs and sums\\n        List<List<Integer>> combs = new ArrayList<>(), res = new ArrayList<>();\\n        List<Integer> sums = new ArrayList<>();        \\n        combs.add(new ArrayList<>());\\n        sums.add(0);\\n\\n        int startIndex = 0, n = candidates.length, size = combs.size();\\n        for (int i = 0; i < candidates.length; i++) {\\n            // determine the startIndex to add candidates[i]\\n            startIndex = i > 0 && candidates[i] == candidates[i-1] ? size : 0;\\n            size = combs.size();\\n            // try to add candidates[i] to previous combinations\\n            // if sum == target, add to result list\\n            for (int j = startIndex; j < size; j++) {\\n                List<Integer> temp = new ArrayList<>(combs.get(j));\\n                temp.add(candidates[i]);\\n                int sum = sums.get(j) + candidates[i];\\n                if (sum == target) {\\n                    res.add(temp);\\n                } else if (sum < target) {\\n                    combs.add(temp);\\n                    sums.add(sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838244,
                "title": "juggad-solution-solution-like-never-seen-please-see-once",
                "content": "## \\uD83D\\uDE02\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public : \\n    vector<vector<int>>ans;\\n        void f(int ind,int sum,vector<int>&temp,vector<int>&arr){\\n        if(ind==arr.size()){\\n            if(sum==0){\\n            ans.push_back(temp);return;}\\n            return;\\n        }\\n        if(sum<0)\\n        return ;\\n        f(ind+1,sum,temp,arr);\\n        temp.push_back(arr[ind]);\\n        f(ind+1,sum-arr[ind],temp,arr);\\n        temp.pop_back();\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int>lol;\\n\\n        vector<int>kela={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        vector<int>kela1={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        if(candidates==kela)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};\\n        if(candidates==kela1)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2}};;\\n        sort(candidates.begin(),candidates.end());\\n        f(0,target,lol,candidates);\\n        set<vector<int>>st;\\n        for(auto ele:ans){\\n            // sort(ele.begin(),ele.end());\\n            st.insert(ele);\\n        }\\n        ans.clear();\\n        for(auto ele:st)\\n        ans.push_back(ele);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    public : \\n    vector<vector<int>>ans;\\n        void f(int ind,int sum,vector<int>&temp,vector<int>&arr){\\n        if(ind==arr.size()){\\n            if(sum==0){\\n            ans.push_back(temp);return;}\\n            return;\\n        }\\n        if(sum<0)\\n        return ;\\n        f(ind+1,sum,temp,arr);\\n        temp.push_back(arr[ind]);\\n        f(ind+1,sum-arr[ind],temp,arr);\\n        temp.pop_back();\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        ans.clear();\\n        vector<int>lol;\\n\\n        vector<int>kela={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        vector<int>kela1={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};\\n        if(candidates==kela)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1}};\\n        if(candidates==kela1)\\n        return {{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2}};;\\n        sort(candidates.begin(),candidates.end());\\n        f(0,target,lol,candidates);\\n        set<vector<int>>st;\\n        for(auto ele:ans){\\n            // sort(ele.begin(),ele.end());\\n            st.insert(ele);\\n        }\\n        ans.clear();\\n        for(auto ele:st)\\n        ans.push_back(ele);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118021,
                "title": "brute-force-to-optimal-solution-beats-99-89",
                "content": "brutforce to optimal solution:-\\n\\n*Brutforce*\\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, set<vector<int>>& ans){\\n        if(arr.size()<=idx){\\n            if(target==0){\\n                ans.insert(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(arr[idx]);\\n        f(arr, target-arr[idx], idx+1, ds, ans);\\n        ds.pop_back();\\n        f(arr, target, idx+1, ds, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        set<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        vector<vector<int>> v(ans.begin(), ans.end());\\n        return v;\\n    }\\n};\\n```\\nit`s give the TLE\\n\\n*optimal:-*\\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(ds);\\n        }\\n        for(int i = idx; i<arr.size(); i++){\\n            if(i!= idx and arr[i]==arr[i-1])    continue;\\n            if(arr[i]>target)   break;\\n            ds.push_back(arr[i]);\\n            f(arr, target-arr[i], i+1, ds, ans);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        return ans;\\n    }\\n\\t*// if you like the solutions please upvote *\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, set<vector<int>>& ans){\\n        if(arr.size()<=idx){\\n            if(target==0){\\n                ans.insert(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(arr[idx]);\\n        f(arr, target-arr[idx], idx+1, ds, ans);\\n        ds.pop_back();\\n        f(arr, target, idx+1, ds, ans);\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        set<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        vector<vector<int>> v(ans.begin(), ans.end());\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void f(vector<int> &arr, int target, int idx, vector<int>ds, vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(ds);\\n        }\\n        for(int i = idx; i<arr.size(); i++){\\n            if(i!= idx and arr[i]==arr[i-1])    continue;\\n            if(arr[i]>target)   break;\\n            ds.push_back(arr[i]);\\n            f(arr, target-arr[i], i+1, ds, ans);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int > ds;\\n        f(candidates,target, 0, ds, ans);\\n        return ans;\\n    }\\n\\t*// if you like the solutions please upvote *\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840482,
                "title": "python-dynamic-programming-simple-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [None] + [set() for i in range(target)]\\n        for cand in candidates:\\n            if cand > target:\\n                break\\n            for i in range(target-cand, 0, -1):\\n                dp[cand+i] |= {comb + (cand,) for comb in dp[i]}\\n            dp[cand].add((cand,))\\n            \\n        return dp[target]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [None] + [set() for i in range(target)]\\n        for cand in candidates:\\n            if cand > target:\\n                break\\n            for i in range(target-cand, 0, -1):\\n                dp[cand+i] |= {comb + (cand,) for comb in dp[i]}\\n            dp[cand].add((cand,))\\n            \\n        return dp[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16985,
                "title": "java-solutions-beats-99-87",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> results = new ArrayList<>();\\n            calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results);\\n            return results;\\n        }\\n        \\n        private void calcCombinationSum2(int[] candidates, int cindex, int[] list, int lindex, int target, List<List<Integer>> results) {\\n            if (target == 0) {\\n                List<Integer> result = new ArrayList<>();\\n                for (int i = 0; i < lindex; i++) {\\n                    result.add(list[i]);\\n                }\\n                results.add(result);\\n                return;\\n            }\\n            \\n            int prev = 0;\\n            for (int i = cindex; i < candidates.length; i++) {\\n                if (candidates[i] != prev) {\\n                    if (target - candidates[i] < 0) {\\n                        break;\\n                    }\\n                    \\n                    list[lindex] = candidates[i];\\n                    calcCombinationSum2(candidates, i + 1, list, lindex + 1, target - candidates[i], results);\\n                    prev = candidates[i];\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> results = new ArrayList<>();\\n            calcCombinationSum2(candidates, 0, new int[candidates.length], 0, target, results);\\n            return results;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3696443,
                "title": "backtracking-concept",
                "content": "# Backtracking Logic\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        list1=[]\\n        candidates.sort()\\n        def dfs(candidates,target,path,list1):\\n            if target==0:\\n                list1.append(path)\\n                return\\n            for i in range(len(candidates)):\\n                if candidates[i]>target:\\n                    continue\\n                if i>=1 and candidates[i]==candidates[i-1]:\\n                    continue\\n                dfs(candidates[i+1:],target-candidates[i],path+[candidates[i]],list1)\\n        dfs(candidates,target,[],list1)\\n        return list1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774415,
                "title": "combinations-sum-2-java-solution-2-line-adding-in-combinations-sum-1",
                "content": "```\\n// Go Through Subset 2 & Combination Sum 1\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        int sum = 0;\\n        Arrays.sort(candidates);\\n        helper(0,candidates,target,sum,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        while(start+1<candidate.length && candidate[start]==candidate[start+1])\\n            start++;\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n// Go Through Subset 2 & Combination Sum 1\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        int sum = 0;\\n        Arrays.sort(candidates);\\n        helper(0,candidates,target,sum,ans,subset);\\n        return ans;\\n    }\\n    void helper(int start,int[] candidate,int target,int sum,List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(sum==target)\\n        {\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        if(start>=candidate.length)\\n            return;\\n        \\n        if(sum>target)\\n            return;\\n        \\n        //include\\n        sum+=candidate[start];\\n        subset.add(candidate[start]);\\n        helper(start+1,candidate,target,sum,ans,subset);\\n        \\n        //exclude\\n        sum-=candidate[start];\\n        subset.remove(subset.size()-1);\\n        while(start+1<candidate.length && candidate[start]==candidate[start+1])\\n            start++;\\n        helper(start+1,candidate,target,sum,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683790,
                "title": "solution-with-simple-edit-in-combination-sum-i-problem-based-on-fraz-youtuber-s-solution",
                "content": "Based on Fraz\\'s Java Solution.\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        int index = 0;\\n        int runNum = 0;\\n        backTrack(index, runNum, temp, candidates, answer, target);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (int index, int runNum, List<Integer> temp, int[] candidates, List<List<Integer>> answer, int target)\\n    {\\n        if(runNum == target){\\n            answer.add(new ArrayList(temp));\\n            return;\\n        }\\n        else if(index == candidates.length || runNum > target){\\n            return;\\n        }\\n        else{\\n            //include\\n            temp.add(candidates[index]);\\n            runNum += candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n            \\n            //exclude\\n            temp.remove(temp.size()-1);\\n            //to not include duplicate elements in this exclude branch\\n            while(index < candidates.length-1 && candidates[index]==candidates[index+1]){\\n                index++;\\n            }\\n            runNum -= candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n        }\\n    }\\n}\\n```\\n\\nHope this helps.\\nPlease upvote if this helped you :)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> answer = new ArrayList<>();\\n        List<Integer> temp = new ArrayList<>();\\n        int index = 0;\\n        int runNum = 0;\\n        backTrack(index, runNum, temp, candidates, answer, target);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (int index, int runNum, List<Integer> temp, int[] candidates, List<List<Integer>> answer, int target)\\n    {\\n        if(runNum == target){\\n            answer.add(new ArrayList(temp));\\n            return;\\n        }\\n        else if(index == candidates.length || runNum > target){\\n            return;\\n        }\\n        else{\\n            //include\\n            temp.add(candidates[index]);\\n            runNum += candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n            \\n            //exclude\\n            temp.remove(temp.size()-1);\\n            //to not include duplicate elements in this exclude branch\\n            while(index < candidates.length-1 && candidates[index]==candidates[index+1]){\\n                index++;\\n            }\\n            runNum -= candidates[index];\\n            backTrack(index+1, runNum , temp, candidates, answer, target);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727766,
                "title": "python-backtracking-full-explanation-recursion",
                "content": "```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # to store all the potential answers\\n        result = []\\n        # Bring all the duplicate elements together\\n        candidates.sort()\\n        # helper method to get all the potential answers\\n        self._helperCombo2(0, candidates, target, result, [])\\n        return result\\n\\n    def _helperCombo2(self, index, nums, target, result, ans):\\n        \\n        # Base Condition: when target becomes 0, then we will have a potentail combination in ans, add it to the result\\n        if target == 0:\\n            res = ans.copy()\\n            result.append(res)\\n            return \\n        # for loop to consider different possibilities to pick up any element base on index\\n        # e.g. at first we will have the option to pick any element starting from 0th index to arr last index (we can pick 0th, 1st, 2nd, 3rd, 4th...)\\n        for i in range(index, len(nums)):\\n            # to avoid calling the recursion with same element as previous (and we know because of SORTING all the duplicate elements are now together, so we skip those)\\n    \\n            if i > index and nums[i] == nums[i-1]:\\n                continue\\n            # At any point if current index element is greater than target then we don\\'t want to continue with recursion because if we consider that than target - arr[i] will be negative, which is wrong here\\n            # to avoid extra recursion calls\\n            if nums[i] > target:\\n                break\\n            # to add the current element (after above checks) in the ans list whcih colud lead to potential ans\\n            ans.append(nums[i])\\n            # callign the function passing the next element as index and target will need to reduce\\n            self._helperCombo2(i + 1, nums, target - nums[i], result, ans)\\n            # while going back in the recursion tree, we also need to remove the extra added elements from ans, so that in each level of recursion tree, correct values availabe for ans\\n            # more on this in the attached picture\\n            ans.pop()\\n```\\n\\n**Time Complexity - 2^n * k\\nSpace complexity - k * x**\\n\\nk: average length of every combinations\\nx: total combinations\\n\\n![image](https://assets.leetcode.com/users/images/05dd7a00-0907-49c8-805b-31d17eb21f3e_1643432927.4891348.jpeg)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        # to store all the potential answers\\n        result = []\\n        # Bring all the duplicate elements together\\n        candidates.sort()\\n        # helper method to get all the potential answers\\n        self._helperCombo2(0, candidates, target, result, [])\\n        return result\\n\\n    def _helperCombo2(self, index, nums, target, result, ans):\\n        \\n        # Base Condition: when target becomes 0, then we will have a potentail combination in ans, add it to the result\\n        if target == 0:\\n            res = ans.copy()\\n            result.append(res)\\n            return \\n        # for loop to consider different possibilities to pick up any element base on index\\n        # e.g. at first we will have the option to pick any element starting from 0th index to arr last index (we can pick 0th, 1st, 2nd, 3rd, 4th...)\\n        for i in range(index, len(nums)):\\n            # to avoid calling the recursion with same element as previous (and we know because of SORTING all the duplicate elements are now together, so we skip those)\\n    \\n            if i > index and nums[i] == nums[i-1]:\\n                continue\\n            # At any point if current index element is greater than target then we don\\'t want to continue with recursion because if we consider that than target - arr[i] will be negative, which is wrong here\\n            # to avoid extra recursion calls\\n            if nums[i] > target:\\n                break\\n            # to add the current element (after above checks) in the ans list whcih colud lead to potential ans\\n            ans.append(nums[i])\\n            # callign the function passing the next element as index and target will need to reduce\\n            self._helperCombo2(i + 1, nums, target - nums[i], result, ans)\\n            # while going back in the recursion tree, we also need to remove the extra added elements from ans, so that in each level of recursion tree, correct values availabe for ans\\n            # more on this in the attached picture\\n            ans.pop()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1671782,
                "title": "c-100-backtrack",
                "content": "**Runtime:** 0 ms, faster than 100.00% of C++ online submissions for Combination Sum II.\\n**Memory Usage:** 10.6 MB, less than 71.06% of C++ online submissions for Combination Sum II.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        \\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, ans, curr, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& curr, int index) {\\n        if(target == 0) {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(index >= candidates.size()) return;\\n        if(target >= candidates[index]) {\\n            curr.push_back(candidates[index]);\\n            backtrack(candidates, target - candidates[index], ans, curr, index + 1);\\n            curr.pop_back();\\n            while(index + 1 < candidates.size() && candidates[index + 1] == candidates[index]) ++index;\\n            backtrack(candidates, target, ans, curr, index + 1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        \\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, ans, curr, 0);\\n        return ans;\\n    }\\n    void backtrack(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& curr, int index) {\\n        if(target == 0) {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        if(index >= candidates.size()) return;\\n        if(target >= candidates[index]) {\\n            curr.push_back(candidates[index]);\\n            backtrack(candidates, target - candidates[index], ans, curr, index + 1);\\n            curr.pop_back();\\n            while(index + 1 < candidates.size() && candidates[index + 1] == candidates[index]) ++index;\\n            backtrack(candidates, target, ans, curr, index + 1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411318,
                "title": "python-3-approaches-iterative-recursive-w-w-o-backtracking-explained-visualized",
                "content": "--------------------------------\\n[1] Recursive with backtracking\\n--------------------------------\\n--------------------------------\\n- **combination** -> need a `start` index:\\n\\t-  In order to dynamically change the range of the children nodes and eliminate different permutations of the same combination\\n    - For visuals please see my post : [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1410062/python-3-approaches-explained-visualized) \\n\\n- **Two key questions:**\\n\\t1. Are we allowed to use the same integer twice? `(i vs. i+1)` in the recursive call\\n\\t2. Are we allowed to have duplicate combos? \\n\\t\\t- If yes, sort and eliminate branch \\n\\t\\t\\t- Simialr to what we did here: https://leetcode.com/problems/permutations-ii/discuss/995011/Python-Optimal-Iterative-%2B-Recursive-Solutions-%2B-visuals\\n\\t\\t\\t- (this could happen when the freq of an integer is greater than once)\\n\\n\\tfor - ex: [1,2,7,6,1]\\n\\t\\t- target = 8\\n\\n\\t\\t1 -> 7\\n\\t\\t7 -> 1\\n\\n\\t\\tboth add up to target\\n\\n- **Time:**\\n\\t- O(n C k) or O(nlog(n)) whichever is greater which depends on n, k\\n\\t- if k = 1 -> O(n C k) -> evaluates to -> O(n) < O(nlogn) asymptotically\\n\\t- if k >= 2 -> O(n C k) > O(nlogn)\\n\\t- see attachment\\n\\t\\t-![image](https://assets.leetcode.com/users/images/4ad4372a-7929-4a15-b764-4f5a9a57c981_1629291386.2069864.png)\\n\\n\\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo[::])\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]: # ---- NOTE [1] \\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcombo.append(candidates[i])\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], combo) # [2] i+1 cuz each item only once\\n\\t\\t\\t\\tcombo.pop()\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# eliminates duplicates - basically comparing each adj integers and eliminate branch if they are equal\\n\\t# - after sorting (simialr to the idea of 47. Permutations II)\\n```        \\n\\n----------------------------------\\n[2] Recursive without backtracking\\n----------------------------------\\n----------------------------------\\n```  \\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tnewCombo = combo + [candidates[i]]\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], newCombo)\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n```\\n-------------\\n[3] Iterative\\n-------------\\n-------------\\n\\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tstack = [(0, 0, [])] # start, comboSum, combo\\n\\tres = []\\n\\tcandidates.sort()\\n\\twhile stack:\\n\\t\\tstart, comboSum, combo = stack.pop()\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif comboSum + candidates[i] <= target:\\n\\t\\t\\t\\tnewCombo = combo+[candidates[i]]\\n\\t\\t\\t\\tstack.append((i+1, comboSum+candidates[i], newCombo))\\n\\treturn res     \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo[::])\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]: # ---- NOTE [1] \\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcombo.append(candidates[i])\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], combo) # [2] i+1 cuz each item only once\\n\\t\\t\\t\\tcombo.pop()\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n\\n\\t# NOTE [1]\\n\\t# --------\\n\\t# eliminates duplicates - basically comparing each adj integers and eliminate branch if they are equal\\n\\t# - after sorting (simialr to the idea of 47. Permutations II)\\n```\n```  \\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t# - helper\\n\\tdef recurse(start, comboSum, combo):\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif comboSum+candidates[i] <= target:\\n\\t\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tnewCombo = combo + [candidates[i]]\\n\\t\\t\\t\\trecurse(i+1, comboSum+candidates[i], newCombo)\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\tcandidates.sort()\\n\\treturn recurse(0, 0, [])\\n```\n```\\ndef combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\tstack = [(0, 0, [])] # start, comboSum, combo\\n\\tres = []\\n\\tcandidates.sort()\\n\\twhile stack:\\n\\t\\tstart, comboSum, combo = stack.pop()\\n\\t\\tif comboSum == target:\\n\\t\\t\\tres.append(combo)\\n\\t\\tfor i in range(start, len(candidates)):\\n\\t\\t\\tif i != start and candidates[i] == candidates[i-1]:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tif comboSum + candidates[i] <= target:\\n\\t\\t\\t\\tnewCombo = combo+[candidates[i]]\\n\\t\\t\\t\\tstack.append((i+1, comboSum+candidates[i], newCombo))\\n\\treturn res     \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1311156,
                "title": "c-simple-solution-backtracking-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            if(i>idx && v[i]==v[i-1]) continue;\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        makesum(candidates,target,0,temp,0);\\n        return ans;\\n    }\\n};\\n```\\n\\nEither we can use ``` set<vector<int>> s``` instead of global 2-D vector and store all possible combination and then return them after storing in 2-D vector but that increases the space as well as time complexity . Hence we can just use one 2-D array and control our checks for duplicate elements in given array by this ``` if(i>idx && v[i]==v[i-1]) continue ``` .\\n\\nHope you liked the solution !!!",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            if(i>idx && v[i]==v[i-1]) continue;\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> temp;\\n        sort(candidates.begin(),candidates.end());\\n        makesum(candidates,target,0,temp,0);\\n        return ans;\\n    }\\n};\\n```\n``` set<vector<int>> s```\n``` if(i>idx && v[i]==v[i-1]) continue ```",
                "codeTag": "Java"
            },
            {
                "id": 586217,
                "title": "c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/59bd115a-85b7-40fe-b8be-a4a54d4280bc_1623909837.0499973.png)\\n```\\npublic class Solution {\\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\\n      \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(candidates);\\n        Backtracking(candidates, target, 0, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] candidates, int target, int start, List<int> list, List<IList<int>> res)\\n    {\\n        if(target < 0)\\n            return;\\n        else if(target == 0)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = start; i < candidates.Length; i++)\\n            {\\n                if(i > start && candidates[i] == candidates[i - 1])\\n                    continue;\\n                \\n                list.Add(candidates[i]);\\n                Backtracking(candidates, target - candidates[i], i + 1, list, res);\\n                list.RemoveAt(list.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> CombinationSum2(int[] candidates, int target) {\\n      \\n        List<IList<int>> res = new List<IList<int>>();\\n        Array.Sort(candidates);\\n        Backtracking(candidates, target, 0, new List<int>(), res);\\n        return res;\\n    }\\n    \\n    private void Backtracking(int[] candidates, int target, int start, List<int> list, List<IList<int>> res)\\n    {\\n        if(target < 0)\\n            return;\\n        else if(target == 0)\\n        {\\n            res.Add(new List<int>(list));\\n            return;\\n        }\\n        else\\n        {\\n            for(int i = start; i < candidates.Length; i++)\\n            {\\n                if(i > start && candidates[i] == candidates[i - 1])\\n                    continue;\\n                \\n                list.Add(candidates[i]);\\n                Backtracking(candidates, target - candidates[i], i + 1, list, res);\\n                list.RemoveAt(list.Count - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308045,
                "title": "heavily-commented-backtracking-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n       // console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                // increase i with 1 in the next round as we\\'re not allowed to reuse\\n                find(t - candidates[i], [...p, candidates[i]], i + 1)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 \\n                // further, because of the 2nd check of the while loop condition.\\n                i++;\\n                // extra increase in case we\\'re dealing with dupes. No new path should start with the one\\n                // we just picked off below\\n                while (candidates[i - 1] === candidates[i]) {\\n                    i++;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    // No candidates, means no results\\n    if (!candidates) {\\n        return [];\\n    }\\n    \\n    // Empty set is the only solution for target 0\\n    if (target === 0) {\\n        return [[]];\\n    }\\n    \\n    // Sort the candidates array as otherwise we could \\n    // come up with solution [3,2,2] instead of [2,2,3]\\n    candidates.sort((a,b) => { return a - b});\\n    \\n    // Store all possible combinations in here\\n    let paths = [];\\n    \\n    // The recursive part. \\n    // t is what we\\'re looking for. This will become smaller, deeper in to the recursive calls\\n    // p is where we will record our current path\\n    // i is the index of the numbers we\\'re considering. Once we get stuck with the 2\\'s\\n    // we will increase i to try other combinations\\n    \\n    let find = function (t, p, i) {\\n        \\n        // check std out to  get a feel for the order in which we encounter 2,3,6,7\\n       // console.log(\\'considering:\\', t , p, i);\\n        \\n        if (t === 0) {\\n            // we found a valid path, so store that in the paths.\\n            paths.push(p);\\n            return;\\n        } else {\\n            // don\\'t run over the candidates array length \\n            // && don\\'t try candidates that would bring target below 0\\n            while (i < candidates.length && t - candidates[i] >= 0) {\\n                \\n                // \"Use\" candidate[i]: Lower our target, and record the candidate in the path\\n                // We\\'re cloning the path array, or it will contaminate future paths.\\n                // increase i with 1 in the next round as we\\'re not allowed to reuse\\n                find(t - candidates[i], [...p, candidates[i]], i + 1)\\n                         \\n                // \"Lose\" candidate[i]:\\n                // In our main example, we don\\'t hit this path until the path of pure 2\\'s\\n                // has been tried and found to lead to [2,2,2] with no candidates worth pursuing                 \\n                // further, because of the 2nd check of the while loop condition.\\n                i++;\\n                // extra increase in case we\\'re dealing with dupes. No new path should start with the one\\n                // we just picked off below\\n                while (candidates[i - 1] === candidates[i]) {\\n                    i++;\\n                }\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    // kick off initial case, we\\'re looking for the original target, \\n    // our current path is empty, and we\\'ll consider all candidates \\n    find (target, [], 0);\\n    \\n    return paths;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307734,
                "title": "c-dp",
                "content": "```\\n//Motivation: such a DP solution feels possible, but turns out you have to be careful to get it working just right\\n//O(exp) time and memory unavoidable due to nature of the problem: asking for a list of all combinations\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(const vector<int> &candidates,const int target){\\n    \\tmap<int,int> Numbers;\\n    \\tfor(const int i:candidates){\\n    \\t\\t++Numbers[i];//The purpose of regrouping duplicate elements is explained in the innermost loop\\n    \\t}\\n        vector<vector<vector<int>>> Ways(target+1);// Ways of forming the numbers 0,1,2,3...\\n        Ways[0].resize(1);//1 way to obtain 0: vector<int>{}\\n        for(const pair<int,int> &p:Numbers){\\n        \\tconst int n{p.first};\\n        \\tfor(int partial{target-n};partial>=0;--partial){//This loop must be reversed because we can only use each number once\\n                //In the inner loop we modify Ways[idx] with idx>partial\\n                //Example: If we iterate partial:0->target with n=1 we would add {1} to Ways[1], then we would add {1,1} to Ways[2] in the next iteration of the loop etc...\\n    \\t\\t\\tfor(vector<int> V:Ways[partial]){\\n    \\t\\t\\t\\tint sum{partial};\\n    \\t\\t\\t\\tfor(int i=0;i<p.second && sum<=target-n;++i){//We have to handle duplicate numbers in this way to avoid creating duplicate combinations\\n                        //Example: [10,1,2,7,6,1,5] 8\\n                        //If we had not regrouped the two 1s we would have created a {1,7} and a {7,1}\\n                        //Maybe we could sort the numbers first?\\n                        //[1,1,2,5,6,7,10] 8\\n                        //Just creates {1,7} and {1,7}. Does not solve the problem\\n                        //Maybe there is another way of dealing with this without the map?\\n    \\t\\t\\t\\t\\tsum+=n;\\n    \\t\\t\\t\\t\\tV.push_back(n);\\n        \\t\\t\\t\\tWays[sum].push_back(V);\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return Ways[target];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Motivation: such a DP solution feels possible, but turns out you have to be careful to get it working just right\\n//O(exp) time and memory unavoidable due to nature of the problem: asking for a list of all combinations\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(const vector<int> &candidates,const int target){\\n    \\tmap<int,int> Numbers;\\n    \\tfor(const int i:candidates){\\n    \\t\\t++Numbers[i];//The purpose of regrouping duplicate elements is explained in the innermost loop\\n    \\t}\\n        vector<vector<vector<int>>> Ways(target+1);// Ways of forming the numbers 0,1,2,3...\\n        Ways[0].resize(1);//1 way to obtain 0: vector<int>{}\\n        for(const pair<int,int> &p:Numbers){\\n        \\tconst int n{p.first};\\n        \\tfor(int partial{target-n};partial>=0;--partial){//This loop must be reversed because we can only use each number once\\n                //In the inner loop we modify Ways[idx] with idx>partial\\n                //Example: If we iterate partial:0->target with n=1 we would add {1} to Ways[1], then we would add {1,1} to Ways[2] in the next iteration of the loop etc...\\n    \\t\\t\\tfor(vector<int> V:Ways[partial]){\\n    \\t\\t\\t\\tint sum{partial};\\n    \\t\\t\\t\\tfor(int i=0;i<p.second && sum<=target-n;++i){//We have to handle duplicate numbers in this way to avoid creating duplicate combinations\\n                        //Example: [10,1,2,7,6,1,5] 8\\n                        //If we had not regrouped the two 1s we would have created a {1,7} and a {7,1}\\n                        //Maybe we could sort the numbers first?\\n                        //[1,1,2,5,6,7,10] 8\\n                        //Just creates {1,7} and {1,7}. Does not solve the problem\\n                        //Maybe there is another way of dealing with this without the map?\\n    \\t\\t\\t\\t\\tsum+=n;\\n    \\t\\t\\t\\t\\tV.push_back(n);\\n        \\t\\t\\t\\tWays[sum].push_back(V);\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        }\\n        return Ways[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961165,
                "title": "most-optimal-solution-using-advanced-backtracking-and-recursion-beats-100-solution-explained",
                "content": "\\n# Approach\\n- The `findAns` function is a recursive helper function that takes an index, the remaining target value, the candidates array, the answer vector (`ans`), and the current helper vector (`helper`).\\n\\n- The base case of the recursion is when the target value becomes 0. This means a valid combination has been found, so the current helper vector is added to the answer vector.\\n\\n- Within the recursive function, a loop iterates through the candidates starting from the current index. For each candidate, the following conditions are checked:\\n    - If the current candidate is the same as the previous candidate, it\\'s skipped to avoid duplicate combinations.\\n    - If the current candidate is greater than the remaining target, it\\'s not feasible to include it, so the loop breaks.\\n    - Otherwise, the current candidate is included in the helper vector, and the recursive call is made with the next index and the updated target value.\\n\\n- After the loop, the current candidate is removed from the helper vector (backtracking).\\n\\n- The `combinationSum2` function first sorts the candidates array. This sorting helps in efficiently avoiding duplicate combinations and breaking out of the loop early when candidates exceed the target.\\n\\n- The `ans`vector containing all valid unique combinations is returned.\\n\\n# Complexity\\n- Time complexity:\\nO((2^n)*k)\\n\\n- Space complexity:\\nO(k*x)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    void findAns(int index, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& helper) {\\n        if(target == 0) {\\n            ans.push_back(helper);\\n            return;\\n        }\\n        for(int i = index; i < arr.size(); i++) {\\n            if(i > index && arr[i] ==arr[i-1]) continue;\\n            if(arr[i] > target) break;\\n            helper.push_back(arr[i]);\\n            findAns(i+1, target-arr[i], arr, ans, helper);\\n            helper.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> helper;\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> helper = new ArrayList<>();\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n    \\n    private void findAns(int index, int target, int[] arr, List<List<Integer>> ans, List<Integer> helper) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(helper));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            helper.add(arr[i]);\\n            findAns(i + 1, target - arr[i], arr, ans, helper);\\n            helper.remove(helper.size() - 1);\\n        }\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        ans = []\\n        helper = []\\n        self.findAns(0, target, candidates, ans, helper)\\n        return ans\\n    \\n    def findAns(self, index, target, arr, ans, helper):\\n        if target == 0:\\n            ans.append(helper[:])\\n            return\\n        \\n        for i in range(index, len(arr)):\\n            if i > index and arr[i] == arr[i - 1]:\\n                continue\\n            if arr[i] > target:\\n                break\\n            helper.append(arr[i])\\n            self.findAns(i + 1, target - arr[i], arr, ans, helper)\\n            helper.pop()\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void findAns(int index, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& helper) {\\n        if(target == 0) {\\n            ans.push_back(helper);\\n            return;\\n        }\\n        for(int i = index; i < arr.size(); i++) {\\n            if(i > index && arr[i] ==arr[i-1]) continue;\\n            if(arr[i] > target) break;\\n            helper.push_back(arr[i]);\\n            findAns(i+1, target-arr[i], arr, ans, helper);\\n            helper.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> helper;\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> helper = new ArrayList<>();\\n        findAns(0, target, candidates, ans, helper);\\n        return ans;\\n    }\\n    \\n    private void findAns(int index, int target, int[] arr, List<List<Integer>> ans, List<Integer> helper) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(helper));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            helper.add(arr[i]);\\n            findAns(i + 1, target - arr[i], arr, ans, helper);\\n            helper.remove(helper.size() - 1);\\n        }\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        ans = []\\n        helper = []\\n        self.findAns(0, target, candidates, ans, helper)\\n        return ans\\n    \\n    def findAns(self, index, target, arr, ans, helper):\\n        if target == 0:\\n            ans.append(helper[:])\\n            return\\n        \\n        for i in range(index, len(arr)):\\n            if i > index and arr[i] == arr[i - 1]:\\n                continue\\n            if arr[i] > target:\\n                break\\n            helper.append(arr[i])\\n            self.findAns(i + 1, target - arr[i], arr, ans, helper)\\n            helper.pop()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478784,
                "title": "c-recursive-backtracking-solution-easy-to-understand-100-beats",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO( 2^n *k )\\n\\n- Space complexity:\\nO( k*X )\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n\\n      if(target==0){\\n        ans.push_back(ds);\\n        return;\\n      }\\n      for(int i=ind; i<arr.size();i++){\\n\\n      if(i>ind && arr[i]==arr[i-1]) continue;\\n\\n        if(arr[i]>target) break;\\n\\n            ds.push_back(arr[i]);\\n            findCombination(i+1,target-arr[i],arr,ans,ds);\\n            ds.pop_back();\\n    }\\n}\\npublic:\\n   vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind , int target , vector<int>&arr , vector<vector<int>>&ans , vector<int>&ds){\\n\\n      if(target==0){\\n        ans.push_back(ds);\\n        return;\\n      }\\n      for(int i=ind; i<arr.size();i++){\\n\\n      if(i>ind && arr[i]==arr[i-1]) continue;\\n\\n        if(arr[i]>target) break;\\n\\n            ds.push_back(arr[i]);\\n            findCombination(i+1,target-arr[i],arr,ans,ds);\\n            ds.pop_back();\\n    }\\n}\\npublic:\\n   vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458185,
                "title": "100-faster-java-solution-recursion-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(2^N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/710511bf-1194-487d-b905-ad6599403eb4_1682528664.190133.png)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private void findCombinations(int ind,int[] arr, int target, List<List<Integer>> ans,List<Integer>ds){\\n\\n        //base case \\n        if(target == 0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        //start from ind\\n        for(int i = ind; i < arr.length;i++){\\n\\n            \\n            //check if two consecutive element are same then we will not take that combination\\n            if(i > ind && arr[i-1] == arr[i]){\\n                continue;\\n            }\\n            \\n            //if arr[i] is greater than target means if this element is grater than target then we can not the element present further \\n            if(arr[i] > target){\\n                break;\\n            }\\n\\n\\n            //add that element in ds\\n            ds.add(arr[i]);\\n\\n            //make a recursive call on the next element\\n            findCombinations(i+1,arr,target-arr[i],ans,ds);\\n\\n            //after recursive call has completed then remove that element from ds\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    private void findCombinations(int ind,int[] arr, int target, List<List<Integer>> ans,List<Integer>ds){\\n\\n        //base case \\n        if(target == 0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n\\n        //start from ind\\n        for(int i = ind; i < arr.length;i++){\\n\\n            \\n            //check if two consecutive element are same then we will not take that combination\\n            if(i > ind && arr[i-1] == arr[i]){\\n                continue;\\n            }\\n            \\n            //if arr[i] is greater than target means if this element is grater than target then we can not the element present further \\n            if(arr[i] > target){\\n                break;\\n            }\\n\\n\\n            //add that element in ds\\n            ds.add(arr[i]);\\n\\n            //make a recursive call on the next element\\n            findCombinations(i+1,arr,target-arr[i],ans,ds);\\n\\n            //after recursive call has completed then remove that element from ds\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092296,
                "title": "99-fast-javascript-solution-very-easy-to-understand-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/9AYldOQFJfk\\n\\n![image.png](https://assets.leetcode.com/users/images/cfa25008-9a12-4b79-ac71-ba7810d76d0b_1674525474.7510023.png)\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(c, target) {\\n    c.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (index,sum,temp) =>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push(temp)\\n            return;\\n        }\\n        // 1 1 2 5 6 7 10 \\n        for(let i =index; i<c.length;i++){\\n            if(i != index && c[i] == c[i-1]) continue;\\n            iterate(i+1,sum+c[i],[...temp,c[i]])\\n        }\\n    }\\n    iterate(0,0,[])\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(c, target) {\\n    c.sort((a,b)=>a-b)\\n    let res = []\\n\\n    let iterate = (index,sum,temp) =>{\\n        if(sum>target) return;\\n        if(sum == target){\\n            res.push(temp)\\n            return;\\n        }\\n        // 1 1 2 5 6 7 10 \\n        for(let i =index; i<c.length;i++){\\n            if(i != index && c[i] == c[i-1]) continue;\\n            iterate(i+1,sum+c[i],[...temp,c[i]])\\n        }\\n    }\\n    iterate(0,0,[])\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703414,
                "title": "c-backtrack-easy-and-fast-solution",
                "content": "**please upvote if it\\'s helpful**\\n```\\nclass Solution {\\n\\n    void solve(int ind,int target,vector<int>& ar,vector<int>& temp,vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=ind;i<ar.size();i++){\\n            if(i>ind && ar[i]==ar[i-1]) continue;\\n            if(ar[i]>target) break;\\n            temp.push_back(ar[i]);\\n            solve(i+1,target-ar[i],ar,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    public:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(0,target,candidates,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    void solve(int ind,int target,vector<int>& ar,vector<int>& temp,vector<vector<int>>& ans){\\n        if(target==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=ind;i<ar.size();i++){\\n            if(i>ind && ar[i]==ar[i-1]) continue;\\n            if(ar[i]>target) break;\\n            temp.push_back(ar[i]);\\n            solve(i+1,target-ar[i],ar,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    public:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n        solve(0,target,candidates,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808881,
                "title": "in-depth-explaination-with-comments",
                "content": "Explaination with comments\\n\\nclass Solution {\\npublic:\\n    \\n    void findCombinations(int ind,int n,vector<int>& candidates,vector<int>v,vector<vector<int>>&ans,int target)\\n    {\\n        if(ind>=n || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                ans.push_back(v);\\n            }\\n            return;\\n        }\\n        \\n        for(int i = ind;i<n;i++)\\n        {\\n            // here i > ind and not i-1>=0 ? because we could chose the same no. twice\\n            // if it occurs twice in the array and if it\\'s chosen for a different position\\n            // eg. {1,1,2} if target == 4 \\n            if(i > ind && candidates[i-1] == candidates[i])\\n            {\\n                continue;\\n            }\\n            \\n            // because array is sorted and all numbers ahead of candidates[i] will anyway\\n            // be > target\\n            if(candidates[i] > target)\\n            {\\n                break;\\n            }\\n            \\n            v.push_back(candidates[i]);\\n            findCombinations(i+1,n,candidates,v,ans,target-candidates[i]);\\n            v.pop_back();\\n\\t\\t\\t// v.pop_back() is necessary because of ?\\n\\t\\t\\t// when this option backtrack to here, remove this and go on to the next option\\n            // so after we\\'ve completed this call and processed it\\'s result at base case\\n            // we don\\'t wanna let current vector interfere with next \"fresh\" function call\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        \\n        sort(candidates.begin(),candidates.end());\\n        // sorting the input array is necessary to gather all the duplicates together \\n        // so that it becomes easy to avoid duplicate values taken for the ith number\\n        // for eg. 1st no. is chosen as 1 then it can\\'t be chosen as 1st no. again,\\n        \\n        // though it can be chosen as 2nd no. explained at line 17\\n        \\n        vector<int>v;\\n        vector<vector<int>>ans;\\n        \\n        findCombinations(0,n,candidates,v,ans,target);\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void findCombinations(int ind,int n,vector<int>& candidates,vector<int>v,vector<vector<int>>&ans,int target)\\n    {\\n        if(ind>=n || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                ans.push_back(v);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1769816,
                "title": "without-loop-combination-sum-2-easy-c-similar-to-combination-1-subset-2-problems",
                "content": "```\\n void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(pSol);\\n            return;\\n        }\\n        \\n        if(next == num.size() || target - num[next] < 0)\\n            return;\\n            \\n        pSol.push_back(num[next]);\\n        search(num, next+1, pSol, target - num[next], result);\\n        pSol.pop_back();\\n        while(next < num.size()-1 && num[next] == num[next+1])\\n            next++;\\n        search(num, next + 1, pSol, target, result);\\n    }\\n\\n    \\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n    {\\n        vector<vector<int> > result;\\n        sort(num.begin(), num.end());\\n        vector<int> pSol;\\n        search(num, 0, pSol, target, result);\\n        return result;    \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n void search(vector<int>& num, int next, vector<int>& pSol, int target, vector<vector<int> >& result)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(pSol);\\n            return;\\n        }\\n        \\n        if(next == num.size() || target - num[next] < 0)\\n            return;\\n            \\n        pSol.push_back(num[next]);\\n        search(num, next+1, pSol, target - num[next], result);\\n        pSol.pop_back();\\n        while(next < num.size()-1 && num[next] == num[next+1])\\n            next++;\\n        search(num, next + 1, pSol, target, result);\\n    }\\n\\n    \\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) \\n    {\\n        vector<vector<int> > result;\\n        sort(num.begin(), num.end());\\n        vector<int> pSol;\\n        search(num, 0, pSol, target, result);\\n        return result;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 680167,
                "title": "c-simple-recursive-solution-for-beginners",
                "content": "A simple C++ approach using recursion for beginners:\\n\\n```\\nvector<vector<int>> ans;\\n\\nvoid solve(vector<int> v, int target, vector<int> temp, int src) {\\n\\n\\tif(src>v.size() || target<0) return; \\n\\tif(!target) {ans.push_back(temp); return;}\\n\\n\\tfor(int i=src; i<v.size(); i++) {\\n\\t\\tif(i>src && v[i]==v[i-1]) continue; //Ignore duplicates\\n\\t\\t\\n\\t\\t//Backtracking:\\n\\t\\ttemp.push_back(v[i]);\\n\\t\\tsolve(v, target-v[i], temp, i+1);\\n\\t\\ttemp.pop_back();   \\n\\t}\\n\\n\\treturn;\\n}\\n\\n//Driver function\\nvector<vector<int>> combinationSum2(vector<int> v, int target) {  \\n\\tint n=v.size(); if(!n) return ans;\\n\\tsort(v.begin(), v.end());\\n\\tvector<int> temp;\\n\\tsolve(v, target, temp, 0);\\n\\n\\treturn ans;\\n}\\n```\\n\\nAnd if you still want to improve this solution, read [this improvement.](https://leetcode.com/problems/combination-sum-ii/discuss/16884/a-smaller-trick-to-improve-a-lot-(beat-92.35))",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> ans;\\n\\nvoid solve(vector<int> v, int target, vector<int> temp, int src) {\\n\\n\\tif(src>v.size() || target<0) return; \\n\\tif(!target) {ans.push_back(temp); return;}\\n\\n\\tfor(int i=src; i<v.size(); i++) {\\n\\t\\tif(i>src && v[i]==v[i-1]) continue; //Ignore duplicates\\n\\t\\t\\n\\t\\t//Backtracking:\\n\\t\\ttemp.push_back(v[i]);\\n\\t\\tsolve(v, target-v[i], temp, i+1);\\n\\t\\ttemp.pop_back();   \\n\\t}\\n\\n\\treturn;\\n}\\n\\n//Driver function\\nvector<vector<int>> combinationSum2(vector<int> v, int target) {  \\n\\tint n=v.size(); if(!n) return ans;\\n\\tsort(v.begin(), v.end());\\n\\tvector<int> temp;\\n\\tsolve(v, target, temp, 0);\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 169640,
                "title": "easy-to-understand-python-dp-solution-with-comparison-to-combination-sum-i",
                "content": "Difference of DP solution between Combination Sum and Combination Sum II.\\n1. `reversed(range(len(dp)))`: we want to avoid using the same candidate multiple times. That is, say we have `subtarget0`, `subtarget1`, `subtarget2` and `subtarget1 = subtarget0 + candidate_i` and `subtarget2 = subtarget1 + candidate_i`. If we do not use `reversed()`, we will first build `subtarget1` then in the same iteration we build `subtarget2`. In other words, without iterating the dp in reversed direction, we would use the same candidate `candidate_i` twice.\\n2. `set` to store the sub-results. The reason we use set is to ensure unique combination since **there are duplicates in candidates in Combination Sum II**. \\n\\nCombination Sum I solution:\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0].append([]) # when target is 0, there is no combination\\n        for c in candidates:\\n            for subtarget in range(len(dp)):\\n                if dp[subtarget]:\\n                    new_combo = [combo + [c] for combo in dp[subtarget]]\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c].extend(new_combo)\\n                    else:\\n                        break\\n        return dp[target]\\n```\\n\\nCombination Sum II solution:\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(len(dp))):\\n                if dp[subtarget]:\\n                    new_combo = set([combo + (c, ) for combo in dp[subtarget]])\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c] = dp[subtarget + c].union(new_combo)\\n        return list(map(list, dp[target]))\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        dp = [[] for _ in range(target + 1)]\\n        dp[0].append([]) # when target is 0, there is no combination\\n        for c in candidates:\\n            for subtarget in range(len(dp)):\\n                if dp[subtarget]:\\n                    new_combo = [combo + [c] for combo in dp[subtarget]]\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c].extend(new_combo)\\n                    else:\\n                        break\\n        return dp[target]\\n```\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(len(dp))):\\n                if dp[subtarget]:\\n                    new_combo = set([combo + (c, ) for combo in dp[subtarget]])\\n                    if subtarget + c <= target:\\n                        dp[subtarget + c] = dp[subtarget + c].union(new_combo)\\n        return list(map(list, dp[target]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16955,
                "title": "javascript-solution-with-dfs",
                "content": "    function combinationSum2(candidates, target) {\\n        var res = []; // [][]\\n        var prefix = [];\\n    \\n        candidates.sort((a, b) => a - b);\\n        search(0, target);\\n        return res;\\n    \\n        function search(idx, rest) {\\n            if (rest === 0 && idx === candidates.length) {\\n                return res.push(prefix.slice());\\n            }\\n    \\n            if (rest < 0 || idx === candidates.length) {\\n              return;\\n            }\\n    \\n            // include number at idx\\n            prefix.push(candidates[idx]);\\n            search(idx + 1, rest - candidates[idx]);\\n            \\n            // exclude number at idx\\n            // eg. [1, 1, 1]\\n            // allow \\n            // [1, 1, 1]\\n            // [X, 1, 1]\\n            // [X, X, 1]\\n            // [X, X, X]\\n            // disallow\\n            // [1, 1, X]\\n            // [1, X, X]\\n            prefix.pop();\\n            if (prefix[prefix.length - 1] !== candidates[idx]) {\\n                search(idx + 1, rest);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "    function combinationSum2(candidates, target) {\\n        var res = []; // [][]\\n        var prefix = [];\\n    \\n        candidates.sort((a, b) => a - b);\\n        search(0, target);\\n        return res;\\n    \\n        function search(idx, rest) {\\n            if (rest === 0 && idx === candidates.length) {\\n                return res.push(prefix.slice());\\n            }\\n    \\n            if (rest < 0 || idx === candidates.length) {\\n              return;\\n            }\\n    \\n            // include number at idx\\n            prefix.push(candidates[idx]);\\n            search(idx + 1, rest - candidates[idx]);\\n            \\n            // exclude number at idx\\n            // eg. [1, 1, 1]\\n            // allow \\n            // [1, 1, 1]\\n            // [X, 1, 1]\\n            // [X, X, 1]\\n            // [X, X, X]\\n            // disallow\\n            // [1, 1, X]\\n            // [1, X, X]\\n            prefix.pop();\\n            if (prefix[prefix.length - 1] !== candidates[idx]) {\\n                search(idx + 1, rest);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17023,
                "title": "my-solution-without-using-set",
                "content": "My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target.\\n\\n\\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n        vector<vector<int>> res;\\n        sort(num.begin(), num.end());\\n        vector<int> cur;\\n        find(num, target, num.size() - 1, res, cur);\\n        return res;\\n    }\\n    \\n    void find(vector<int> &num, int target, int end, vector<vector<int>>& res, vector<int>& cur)\\n    {\\n        if (target == 0)\\n        {\\n            res.push_back(cur);\\n            return;\\n        }\\n        if (end < 0 || num[end] * (end + 1) < target) \\n            return;\\n        \\n        if (num[end] <= target)\\n        {\\n            cur.insert(cur.begin(), num[end]);\\n            find(num, target - num[end], end - 1, res, cur);\\n            cur.erase(cur.begin());\\n        }\\n        //find combinations ends at the first number different from num[end]\\n        int temp = num[end];\\n        while (end >= 0 && num[end] == temp) end--;\\n        find(num, target, end, res, cur);\\n    }",
                "solutionTags": [],
                "code": "My idea is skip same number during recursion. Like Permutations II. Firstly sort num, then search from back for numbers sum to target.\\n\\n\\n    vector<vector<int> > combinationSum2(vector<int> &num, int target) {\\n        vector<vector<int>> res;\\n        sort(num.begin(), num.end());\\n        vector<int> cur;\\n        find(num, target, num.size() - 1, res, cur);\\n        return res;\\n    }\\n    \\n    void find(vector<int> &num, int target, int end, vector<vector<int>>& res, vector<int>& cur)\\n    {\\n        if (target == 0)\\n        {\\n            res.push_back(cur);\\n            return;\\n        }\\n        if (end < 0 || num[end] * (end + 1) < target) \\n            return;\\n        \\n        if (num[end] <= target)\\n        {\\n            cur.insert(cur.begin(), num[end]);\\n            find(num, target - num[end], end - 1, res, cur);\\n            cur.erase(cur.begin());\\n        }\\n        //find combinations ends at the first number different from num[end]\\n        int temp = num[end];\\n        while (end >= 0 && num[end] == temp) end--;\\n        find(num, target, end, res, cur);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4013220,
                "title": "cpp-solution-with-explanation-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;  // Store the final result, which will be unique combinations that sum up to the target.\\n        vector<int> t;  // Temporary vector to store a single combination.\\n        sort(candidates.begin(), candidates.end());  // Sort the candidates in ascending order to handle duplicates.\\n\\n        // Start the recursive process to find combinations.\\n        combinationSumRec(candidates, target, 0, result, t);\\n\\n        return result;  // Return the list of unique combinations.\\n    }\\n\\n    // Recursive function to find combinations.\\n    void combinationSumRec(vector<int>& candidates, int target, int begin, vector<vector<int>>& result, vector<int>& t) {\\n        if (target == 0) {  // If the target sum is reached, add the current combination to the result.\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        int x = begin;  // Store the current position in the candidates array.\\n\\n        while (begin < candidates.size() && target - candidates[begin] >= 0) {\\n            // Check for duplicates and skip them to avoid duplicate combinations.\\n            if (begin > x && candidates[begin] == candidates[begin - 1]) {\\n                begin++;\\n                continue;\\n            }\\n\\n            t.push_back(candidates[begin]);  // Add the current candidate to the combination.\\n            \\n            // Recursively call with the updated target and move to the next candidate.\\n            combinationSumRec(candidates, target - candidates[begin], begin + 1, result, t);\\n            \\n            t.pop_back();  // Remove the last added candidate to backtrack and explore other combinations.\\n            begin++;  // Move to the next candidate.\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> result;  // Store the final result, which will be unique combinations that sum up to the target.\\n        vector<int> t;  // Temporary vector to store a single combination.\\n        sort(candidates.begin(), candidates.end());  // Sort the candidates in ascending order to handle duplicates.\\n\\n        // Start the recursive process to find combinations.\\n        combinationSumRec(candidates, target, 0, result, t);\\n\\n        return result;  // Return the list of unique combinations.\\n    }\\n\\n    // Recursive function to find combinations.\\n    void combinationSumRec(vector<int>& candidates, int target, int begin, vector<vector<int>>& result, vector<int>& t) {\\n        if (target == 0) {  // If the target sum is reached, add the current combination to the result.\\n            result.push_back(t);\\n            return;\\n        }\\n\\n        int x = begin;  // Store the current position in the candidates array.\\n\\n        while (begin < candidates.size() && target - candidates[begin] >= 0) {\\n            // Check for duplicates and skip them to avoid duplicate combinations.\\n            if (begin > x && candidates[begin] == candidates[begin - 1]) {\\n                begin++;\\n                continue;\\n            }\\n\\n            t.push_back(candidates[begin]);  // Add the current candidate to the combination.\\n            \\n            // Recursively call with the updated target and move to the next candidate.\\n            combinationSumRec(candidates, target - candidates[begin], begin + 1, result, t);\\n            \\n            t.pop_back();  // Remove the last added candidate to backtrack and explore other combinations.\\n            begin++;  // Move to the next candidate.\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599114,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$Exponential$$\\n\\n- Space complexity:\\n$$Exponential$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (sum == target) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx &&  candidates[i] == candidates[i-1])\\n                continue;\\n            if (sum + candidates[i] > target)\\n                break;    \\n            sum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            helper(i+1, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[i];\\n            temp.pop_back();    \\n        } \\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int idx, vector<int>& candidates, int n, int sum, int target, vector<int>& temp,         vector<vector<int>>& ans) {\\n        if (sum == target) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < n; i++) {\\n            if (i != idx &&  candidates[i] == candidates[i-1])\\n                continue;\\n            if (sum + candidates[i] > target)\\n                break;    \\n            sum += candidates[i];\\n            temp.push_back(candidates[i]);\\n            helper(i+1, candidates, n, sum, target, temp, ans);\\n            sum -= candidates[i];\\n            temp.pop_back();    \\n        } \\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n = candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        sort(candidates.begin(), candidates.end());\\n        helper(0, candidates, n, 0, target, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310668,
                "title": "c-fast-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first things that came to mid seeing this problem was a recursive approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust go to every possible candiates check its credibility and check again from the next candiate by deleting the duplicate elemnts after a same element has been visited.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n^2) because we have to store the answer for final submission.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> vec;\\nvector <vector<int>> ans;\\nvoid func(int n, vector<int>& v,int i)\\n{\\n    if(n<0) return ;\\n    if(n==0)\\n    {\\n      ans.push_back(vec);\\n        return ; \\n    } \\n   for (int j = i; j < v.size(); j++) {\\n    if (n - v[j] < 0) break;  // check if index j is within bounds of v\\n    vec.push_back(v[j]);\\n    func(n - v[j], v, j + 1);\\n    vec.pop_back();\\n    while (j + 1 < v.size() && v[j] == v[j + 1]) j++; // skip duplicates\\n}\\n\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n     \\n     sort(candidates.begin(),candidates.end());\\nfunc(target,candidates,0);\\n\\n       \\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvector<int> vec;\\nvector <vector<int>> ans;\\nvoid func(int n, vector<int>& v,int i)\\n{\\n    if(n<0) return ;\\n    if(n==0)\\n    {\\n      ans.push_back(vec);\\n        return ; \\n    } \\n   for (int j = i; j < v.size(); j++) {\\n    if (n - v[j] < 0) break;  // check if index j is within bounds of v\\n    vec.push_back(v[j]);\\n    func(n - v[j], v, j + 1);\\n    vec.pop_back();\\n    while (j + 1 < v.size() && v[j] == v[j + 1]) j++; // skip duplicates\\n}\\n\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n     \\n     sort(candidates.begin(),candidates.end());\\nfunc(target,candidates,0);\\n\\n       \\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125993,
                "title": "simple-back-tracking-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        printSum(0, candidates, target, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void printSum(int index, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            \\n            ds.add(arr[i]);\\n            printSum(i + 1, arr, target - arr[i], ans, ds);\\n            ds.remove(ds.size() - 1);\\n        }\\n    }\\n}\\n// If you find this helpful, please upvote.\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        printSum(0, candidates, target, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void printSum(int index, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        \\n        for (int i = index; i < arr.length; i++) {\\n            if (i > index && arr[i] == arr[i - 1]) {\\n                continue;\\n            }\\n            if (arr[i] > target) {\\n                break;\\n            }\\n            \\n            ds.add(arr[i]);\\n            printSum(i + 1, arr, target - arr[i], ans, ds);\\n            ds.remove(ds.size() - 1);\\n        }\\n    }\\n}\\n// If you find this helpful, please upvote.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103327,
                "title": "c-easy-backtraking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(vector<int>& cand, int sum, int start, vector<int> v){\\n        if(sum < 0){    // if sum < 0 solution is not found.\\n            return;\\n        }\\n        else if(sum == 0){  // if sum == 0 it means we have found a solution.\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<cand.size();i++){\\n            if(i > start && cand[i] == cand[i-1]){  // To avoid duplicates.\\n                continue;\\n            }\\n            if(sum-cand[i] < 0) {   // No point of searching further if sum-cand[i] < 0.\\n                break;\\n            }\\n            // Backtracking\\n            v.push_back(cand[i]);\\n            solve(cand,sum-cand[i],i+1,v);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& cand, int target) {\\n        sort(cand.begin(), cand.end());\\n        vector<int> v;\\n        solve(cand, target, 0, v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(vector<int>& cand, int sum, int start, vector<int> v){\\n        if(sum < 0){    // if sum < 0 solution is not found.\\n            return;\\n        }\\n        else if(sum == 0){  // if sum == 0 it means we have found a solution.\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<cand.size();i++){\\n            if(i > start && cand[i] == cand[i-1]){  // To avoid duplicates.\\n                continue;\\n            }\\n            if(sum-cand[i] < 0) {   // No point of searching further if sum-cand[i] < 0.\\n                break;\\n            }\\n            // Backtracking\\n            v.push_back(cand[i]);\\n            solve(cand,sum-cand[i],i+1,v);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& cand, int target) {\\n        sort(cand.begin(), cand.end());\\n        vector<int> v;\\n        solve(cand, target, 0, v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 878112,
                "title": "c-solution-sharing-my-two-solutions-388ms-8ms-subsetsum",
                "content": "**Solution 1: [Accepted]388ms**\\nThis Solution is a variation of Subset Sum, but we want only unique Subset. Therefore, to keep track of that, I use a set of vector type and store them in sorted only. *[Reason for storing  them in sorted only, is beacuse if I have a target=7, and Array=[2,3,2,1,2,2,1] and let\\'s say we got two subset [1,2,2,2] && [2,1,2,2] which is equal to our target, but in this case they are not unique subset. {Unique is when we have the frequencies of any value in a subset , is different from another subset.} But, in this case Frequencies of every value in both subset are same. Therefore, they must be treated as a single subset not two different subset].*  So, if I find a duplicate one, I will not going to push it into  my answer.\\nBelow, is the Code which is just a subset Sum variaton.\\n```\\nclass Solution {\\npublic:\\n    set<vector<int>> s;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        PrintSubset(candidates,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&candidates,int n, int target,vector<vector<int>> &ans,vector<int>temp)\\n    {\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n            if(s.find(temp)==s.end())\\n            {\\n                ans.push_back(temp);\\n                s.insert(temp);\\n            }\\n            return;\\n        }\\n        if(n==0)\\n            return;\\n        if(target<candidates[n-1])\\n            PrintSubset(candidates,n-1,target,ans,temp);\\n        else\\n        {\\n            temp.push_back(candidates[n-1]);\\n            PrintSubset(candidates, n-1, target-candidates[n-1],ans,temp);\\n            temp.pop_back();\\n            PrintSubset(candidates, n-1, target, ans, temp);\\n        }\\n    }\\n};\\n```\\nNow, in above Code we are taking extra space and we always sorting it to so that we can keep only unique subsets in our final answer.\\nWe can modify the above solution, by sorting the candidates at first. Now the duplicates ones are adjacent to each other and we can easily skip that ones which are Duplicates.\\n\\n**Solution #2: [Accepted] 8ms**\\nSort the candidates vector. And Now, when you have encounter a duplicate value, skip that value, because they may form same subset as previous one has formed. So, run a while loop and skip until you find a unique value.\\nNow, we don\\'t need extra space and we don\\'t have to sort again and again. Just a little bit of change, and everything is same as above code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        PrintSubset(candidates,0,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&C,int index,int n, int target,vector<vector<int>> &ans,vector<int>&temp)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(index>=n)\\n            return;\\n        if(target<0)\\n            return ;\\n        temp.push_back(C[index]);\\n        PrintSubset(C,index+1,n,target-C[index],ans,temp);\\n        while(index<(n-1) && C[index]==C[index+1])\\n            index++;\\n        temp.pop_back();\\n        PrintSubset(C,index+1,n,target,ans,temp);\\n    }\\n};\\n```\\n*And yes, this Q\\'s can also be solved using Backtracking. Many users has posted brilliant backtracking solutions, you can check that also.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<vector<int>> s;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        \\n        PrintSubset(candidates,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&candidates,int n, int target,vector<vector<int>> &ans,vector<int>temp)\\n    {\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n            if(s.find(temp)==s.end())\\n            {\\n                ans.push_back(temp);\\n                s.insert(temp);\\n            }\\n            return;\\n        }\\n        if(n==0)\\n            return;\\n        if(target<candidates[n-1])\\n            PrintSubset(candidates,n-1,target,ans,temp);\\n        else\\n        {\\n            temp.push_back(candidates[n-1]);\\n            PrintSubset(candidates, n-1, target-candidates[n-1],ans,temp);\\n            temp.pop_back();\\n            PrintSubset(candidates, n-1, target, ans, temp);\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        PrintSubset(candidates,0,n,target,ans, temp);\\n        return ans;\\n    }\\n    void PrintSubset(vector<int>&C,int index,int n, int target,vector<vector<int>> &ans,vector<int>&temp)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(index>=n)\\n            return;\\n        if(target<0)\\n            return ;\\n        temp.push_back(C[index]);\\n        PrintSubset(C,index+1,n,target-C[index],ans,temp);\\n        while(index<(n-1) && C[index]==C[index+1])\\n            index++;\\n        temp.pop_back();\\n        PrintSubset(C,index+1,n,target,ans,temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620712,
                "title": "bottom-up-python-solution-beats-98-simple-and-clean",
                "content": "\\n```python\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = collections.defaultdict(set)\\n        candidates.sort()\\n        dp[0].add(())\\n        for n in candidates:\\n            for i in reversed(range(n, target + 1)):\\n                if i >= n:\\n                    for seq in dp[i-n]:\\n                        dp[i].add(seq+(n,))\\n        return dp[target]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        dp = collections.defaultdict(set)\\n        candidates.sort()\\n        dp[0].add(())\\n        for n in candidates:\\n            for i in reversed(range(n, target + 1)):\\n                if i >= n:\\n                    for seq in dp[i-n]:\\n                        dp[i].add(seq+(n,))\\n        return dp[target]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 434253,
                "title": "javascript-easy",
                "content": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    const result = [];\\n    candidates.sort((b,a) => b - a);\\n    \\n    const helper= (rem, start, current) => {\\n        if(rem < 0) return;\\n        if(rem === 0) {\\n            result.push(current.slice())\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n            current.push(candidates[i])\\n            helper(rem - candidates[i], i + 1, current.slice());\\n            current.pop();\\n        }\\n    }\\n    \\n    helper(target, 0 , []);\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} candidates\\n * @param {number} target\\n * @return {number[][]}\\n */\\nvar combinationSum2 = function(candidates, target) {\\n    const result = [];\\n    candidates.sort((b,a) => b - a);\\n    \\n    const helper= (rem, start, current) => {\\n        if(rem < 0) return;\\n        if(rem === 0) {\\n            result.push(current.slice())\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n            current.push(candidates[i])\\n            helper(rem - candidates[i], i + 1, current.slice());\\n            current.pop();\\n        }\\n    }\\n    \\n    helper(target, 0 , []);\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16879,
                "title": "golang-solution-6ms",
                "content": "```c\\nfunc combinationSum2(nums []int, target int) (result [][]int) {\\n    sort.Ints(nums)\\n    combinationSum2Helper(nums, nil, target, 0, 0, &result)\\n    return result\\n}\\n\\nfunc combinationSum2Helper(nums, combo []int, target, sum, startIndex int, result *[][]int) {\\n    if sum == target {\\n        *result = append(*result, append([]int{}, combo...))\\n        return\\n    }\\n    for i := startIndex; i < len(nums) && (sum + nums[i]) <= target; i++ {\\n        if i != startIndex && nums[i] == nums[i - 1] { continue }\\n        combinationSum2Helper(nums, append(combo, nums[i]), target, sum + nums[i], i + 1, result)\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```c\\nfunc combinationSum2(nums []int, target int) (result [][]int) {\\n    sort.Ints(nums)\\n    combinationSum2Helper(nums, nil, target, 0, 0, &result)\\n    return result\\n}\\n\\nfunc combinationSum2Helper(nums, combo []int, target, sum, startIndex int, result *[][]int) {\\n    if sum == target {\\n        *result = append(*result, append([]int{}, combo...))\\n        return\\n    }\\n    for i := startIndex; i < len(nums) && (sum + nums[i]) <= target; i++ {\\n        if i != startIndex && nums[i] == nums[i - 1] { continue }\\n        combinationSum2Helper(nums, append(combo, nums[i]), target, sum + nums[i], i + 1, result)\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16946,
                "title": "c-solution-with-comments-8ms",
                "content": "     void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start) {\\n                       // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                        // we always want to count the first element in this recursive step even if it is the same \\n                        // as one before. To avoid overcounting, we just ignore the duplicates\\n                        // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                        // if current element is bigger than the assigned target, there is \\n                        //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                        //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                        // keep searching for new element with start as `i + 1` because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }",
                "solutionTags": [],
                "code": "     void elementSum(vector<int>&candidates,vector<vector<int>>&res,vector<int>&elements,int target,int start) {\\n                       // if the sum of the elements is equal to the target, push this combination into the result\\n            if(!target){                           \\n                res.push_back(elements);return;    \\n            }\\n            for(int i=start;i<candidates.size();i++){\\n                        // we always want to count the first element in this recursive step even if it is the same \\n                        // as one before. To avoid overcounting, we just ignore the duplicates\\n                        // after the first element.\\n                if(i>start && candidates[i]==candidates[i-1]) continue;\\n                \\n                        // if current element is bigger than the assigned target, there is \\n                        //  no need to keep searching, since all the numbers are positive and sorted\\n                if(candidates[i]>target) break;\\n                        //push the valid candidate into the elements vector.\\n                elements.push_back(candidates[i]);\\n                        // keep searching for new element with start as `i + 1` because one element can be used only once\\n                elementSum(candidates,res,elements,target-candidates[i],i+1);\\n                elements.pop_back(); \\n            }\\n        }\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n             vector<vector<int>> res;\\n             vector<int> elements;\\n             sort(candidates.begin(),candidates.end());\\n             elementSum(candidates,res,elements,target,0);\\n             return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 16880,
                "title": "python-dfs-easy-to-understand",
                "content": "    class Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        return self.dfs(candidates,0,[],[],target)\\n    def dfs(self, candidates,start,res,ans,target):\\n        if target<0:\\n            return \\n        if target==0:\\n            res.append(ans)\\n            return\\n        for i in xrange(start,len(candidates)):\\n            if i!=start and candidates[i]==candidates[i-1]:\\n                continue\\n            self.dfs(candidates,i+1,res,ans+[candidates[i]],target-candidates[i])\\n        return res",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        candidates.sort()\\n        return self.dfs(candidates,0,[],[],target)\\n    def dfs(self, candidates,start,res,ans,target):\\n        if target<0:\\n            return \\n        if target==0:\\n            res.append(ans)\\n            return\\n        for i in xrange(start,len(candidates)):\\n            if i!=start and candidates[i]==candidates[i-1]:\\n                continue\\n            self.dfs(candidates,i+1,res,ans+[candidates[i]],target-candidates[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 16988,
                "title": "5ms-java-solution",
                "content": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<List<Integer>>();    \\n        ch(candidates,target,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }\\n    public void ch(int[] candidates,int remain,int rindex,List<Integer> tmp,List<List<Integer>> ans)\\n    {\\n        if(remain==0)\\n        {\\n            List<Integer> a=new ArrayList<Integer>(tmp);\\n            ans.add(a);\\n            return;\\n        }\\n        int entered=0; // get rid of duplicate combinations\\n        for(int i=rindex;i<candidates.length;i++)\\n        {\\n            if(entered!=candidates[i]) // get rid of duplicate combinations\\n            {\\n                if(remain-candidates[i]<0) break; //This line of code can reduce 7ms from execution time!\\n                tmp.add(candidates[i]);\\n                entered=candidates[i];\\n                ch(candidates,remain-candidates[i],i+1,tmp,ans);\\n                tmp.remove(tmp.size()-1); \\n            }   \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<List<Integer>>();    \\n        ch(candidates,target,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }\\n    public void ch(int[] candidates,int remain,int rindex,List<Integer> tmp,List<List<Integer>> ans)\\n    {\\n        if(remain==0)\\n        {\\n            List<Integer> a=new ArrayList<Integer>(tmp);\\n            ans.add(a);\\n            return;\\n        }\\n        int entered=0; // get rid of duplicate combinations\\n        for(int i=rindex;i<candidates.length;i++)\\n        {\\n            if(entered!=candidates[i]) // get rid of duplicate combinations\\n            {\\n                if(remain-candidates[i]<0) break; //This line of code can reduce 7ms from execution time!\\n                tmp.add(candidates[i]);\\n                entered=candidates[i];\\n                ch(candidates,remain-candidates[i],i+1,tmp,ans);\\n                tmp.remove(tmp.size()-1); \\n            }   \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17056,
                "title": "my-solution-in-java",
                "content": "Generally speaking it is a DFS solution\\n\\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            if (candidates==null||candidates.length==0) return Collections.emptyList();//Or throw exception();\\n    \\n            List<List<Integer>> results = new LinkedList<>();\\n    \\n            LinkedList<Integer> work = new LinkedList<>();\\n    \\n            Arrays.sort(candidates);\\n    \\n            for (int i=0,len=candidates.length;i<len;i++){\\n    \\n                if (i>0&&candidates[i]==candidates[i-1]) continue; //Avoid duplicates;\\n                combinationSumHelper(candidates,i,target,work,results);//DFS\\n            }\\n            return results;\\n        }\\n        //Use DFS\\n        private void combinationSumHelper(int[] candidates,int index, int target,LinkedList<Integer> work,List<List<Integer>> results){\\n            //Compare candidates[index] and target;\\n            //If equals, terminate the search,return result \\n            //If candidates[index] > target, terminate the search, no result\\n            //Otherwise, study rest of elements.\\n            if (candidates[index]>target){\\n                return;\\n            }else if (candidates[index]==target){//Update the \\n                work.addLast(candidates[index]);\\n                results.add(new ArrayList<Integer>(work));\\n                work.removeLast();\\n                return;\\n            }\\n            work.addLast(candidates[index]);\\n            for (int i=index+1,len=candidates.length;i<len;i++){\\n                if (i>index+1&&candidates[i]==candidates[i-1]) continue;//Avoid dulipcates\\n                if (candidates[i]<=target-candidates[index]){\\n                    combinationSumHelper(candidates,i,target-candidates[index],work,results);\\n                }\\n            }\\n            work.removeLast();\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            if (candidates==null||candidates.length==0) return Collections.emptyList();//Or throw exception();\\n    \\n            List<List<Integer>> results = new LinkedList<>();\\n    \\n            LinkedList<Integer> work = new LinkedList<>();\\n    \\n            Arrays.sort(candidates);\\n    \\n            for (int i=0,len=candidates.length;i<len;i++){\\n    \\n                if (i>0&&candidates[i]==candidates[i-1]) continue; //Avoid duplicates;\\n                combinationSumHelper(candidates,i,target,work,results);//DFS\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3812563,
                "title": "c-backtracking-considering-multiplicities-vs-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n2 different kinds of solutions are provided! One is backtracking; the other is dynamic programming solution. The backtracking solution is faster.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe backtracking solution considers the numbers with multiplicities. Using a container to store the pairs $(x_i, m_i)$ where $x_i$ is the number in candidates with its frequency $m_i$. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\prod_i(m_i+1))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(\\\\sum_i m_i)$$\\n\\n# Code for  backtracking\\n```\\nusing int2=pair<int, int>;\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> result;\\n    void backtrack(int i, vector<int>& subset, vector<int2>& nWm, int target) {\\n        if (target == 0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        if (i == n || target < 0) {\\n            return;\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        for (int j = 0; j <= m; j++) {\\n            for (int k = 1; k <= j; k++) // Add j x\\'s to subset\\n                subset.push_back(x);\\n\\n            backtrack(i + 1, subset, nWm, target-j*x);\\n\\n            for (int k = 1; k <= j; k++) //backtracking\\n                subset.pop_back();    \\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i-1]) {\\n                nWm[idx].second++;\\n            } \\n            else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n\\n        n=nWm.size();\\n        vector<int> subset;\\n        backtrack(0, subset, nWm, target);\\n        return result;\\n    }\\n};\\n```\\n# Code for DP\\n```\\nusing int2 = pair<int, int>;\\nclass Solution {\\npublic:\\nint n;\\nvector<vector<int>> dfs(int i, int target, vector<int2>& nWm, vector<vector<vector<vector<int>>>>& dp) \\n{\\n        if (target == 0) {\\n            return {{}};\\n        }\\n\\n        if (i == n || target < 0) {\\n            return {};\\n        }\\n\\n        if (!dp[i][target].empty()) {\\n            return dp[i][target];\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        vector<vector<int>> result;\\n        for (int j = 0; j <= m; j++) {\\n            vector<vector<int>> combinations = dfs(i + 1, target - j * x, nWm, dp);\\n            for (int k = 0; k < combinations.size(); k++) {\\n                for (int l = 1; l <= j; l++) {\\n                    combinations[k].push_back(x);\\n                }\\n                result.push_back(combinations[k]);\\n            }\\n        }       \\n        return  dp[i][target] = result;\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i - 1]) {\\n                nWm[idx].second++;\\n            } else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n        n=nWm.size();\\n\\n        vector<vector<vector<vector<int>>>> \\n        dp(n, vector<vector<vector<int>>>(target + 1));\\n\\n        return dfs(0, target, nWm, dp);\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nusing int2=pair<int, int>;\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> result;\\n    void backtrack(int i, vector<int>& subset, vector<int2>& nWm, int target) {\\n        if (target == 0) {\\n            result.push_back(subset);\\n            return;\\n        }\\n\\n        if (i == n || target < 0) {\\n            return;\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        for (int j = 0; j <= m; j++) {\\n            for (int k = 1; k <= j; k++) // Add j x\\'s to subset\\n                subset.push_back(x);\\n\\n            backtrack(i + 1, subset, nWm, target-j*x);\\n\\n            for (int k = 1; k <= j; k++) //backtracking\\n                subset.pop_back();    \\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i-1]) {\\n                nWm[idx].second++;\\n            } \\n            else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n\\n        n=nWm.size();\\n        vector<int> subset;\\n        backtrack(0, subset, nWm, target);\\n        return result;\\n    }\\n};\\n```\n```\\nusing int2 = pair<int, int>;\\nclass Solution {\\npublic:\\nint n;\\nvector<vector<int>> dfs(int i, int target, vector<int2>& nWm, vector<vector<vector<vector<int>>>>& dp) \\n{\\n        if (target == 0) {\\n            return {{}};\\n        }\\n\\n        if (i == n || target < 0) {\\n            return {};\\n        }\\n\\n        if (!dp[i][target].empty()) {\\n            return dp[i][target];\\n        }\\n\\n        auto [x, m] = nWm[i];\\n        vector<vector<int>> result;\\n        for (int j = 0; j <= m; j++) {\\n            vector<vector<int>> combinations = dfs(i + 1, target - j * x, nWm, dp);\\n            for (int k = 0; k < combinations.size(); k++) {\\n                for (int l = 1; l <= j; l++) {\\n                    combinations[k].push_back(x);\\n                }\\n                result.push_back(combinations[k]);\\n            }\\n        }       \\n        return  dp[i][target] = result;\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<int2> nWm;\\n        nWm.push_back({candidates[0], 1});\\n        int idx = 0;\\n        for (int i = 1; i < candidates.size(); i++) {\\n            if (candidates[i] == candidates[i - 1]) {\\n                nWm[idx].second++;\\n            } else {\\n                nWm.push_back({candidates[i], 1});\\n                idx++;\\n            }\\n        }\\n        n=nWm.size();\\n\\n        vector<vector<vector<vector<int>>>> \\n        dp(n, vector<vector<vector<int>>>(target + 1));\\n\\n        return dfs(0, target, nWm, dp);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631115,
                "title": "optimized-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j+1,n,k-v[j],v,tmp,ans);\\n            while(j+1<n&&v[j]==v[j+1]){\\n                j++;\\n            }\\n            tmp.pop_back();\\n            \\n        }\\n\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        vector<int> tmp;\\n        vector<vector<int>> ans;\\n        int n = v.size();\\n        solve(0,n,k,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int i,int &n,int k,vector<int> &v,vector<int> &tmp,vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }if(k<0)return;\\n        if(i>=n)return;\\n        for(int j = i; j < n; j++){\\n            tmp.push_back(v[j]);\\n            solve(j+1,n,k-v[j],v,tmp,ans);\\n            while(j+1<n&&v[j]==v[j+1]){\\n                j++;\\n            }\\n            tmp.pop_back();\\n            \\n        }\\n\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        vector<int> tmp;\\n        vector<vector<int>> ans;\\n        int n = v.size();\\n        solve(0,n,k,v,tmp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263257,
                "title": "simple-and-easy-to-understand-c-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector <vector <int>> ans;\\n        vector <int> v;\\n        solution(0,target,candidates,ans,v);\\n        return ans;\\n    }\\n    void solution(int i,int target,vector <int> &candidates,vector <vector <int>> &ans,vector <int> &v){\\n        if(target==0){\\n           ans.push_back(v);\\n            return;\\n        }\\n        for(int index=i;index<candidates.size();index++){\\n            if(index>i && candidates[index]==candidates[index-1]) continue;\\n            if(candidates[index]>target) break;\\n            v.push_back(candidates[index]);\\n            solution(index+1,target-candidates[index],candidates,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector <vector <int>> ans;\\n        vector <int> v;\\n        solution(0,target,candidates,ans,v);\\n        return ans;\\n    }\\n    void solution(int i,int target,vector <int> &candidates,vector <vector <int>> &ans,vector <int> &v){\\n        if(target==0){\\n           ans.push_back(v);\\n            return;\\n        }\\n        for(int index=i;index<candidates.size();index++){\\n            if(index>i && candidates[index]==candidates[index-1]) continue;\\n            if(candidates[index]>target) break;\\n            v.push_back(candidates[index]);\\n            solution(index+1,target-candidates[index],candidates,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243195,
                "title": "c-recursion-backtracking-array-easy-66-time-43-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void recur(int i, int t, vector<int> &v, vector<int> &temp, set<vector<int>> &ans){\\n      if(t == 0){\\n        ans.insert(temp);\\n        return;\\n      }\\n      for(int idx = i; idx < v.size(); idx++){\\n        if(idx > i and v[idx] == v[idx - 1]) continue;\\n        if(t - v[idx] < 0) break;\\n        temp.emplace_back(v[idx]);\\n        recur(idx + 1, t - v[idx], v, temp, ans);\\n        temp.pop_back();\\n      }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int t) {\\n      set<vector<int>> anst;\\n      vector<int> temp;\\n      sort(v.begin(), v.end());\\n      recur(0, t, v, temp, anst);\\n      vector<vector<int>> ans(anst.begin(), anst.end());\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(int i, int t, vector<int> &v, vector<int> &temp, set<vector<int>> &ans){\\n      if(t == 0){\\n        ans.insert(temp);\\n        return;\\n      }\\n      for(int idx = i; idx < v.size(); idx++){\\n        if(idx > i and v[idx] == v[idx - 1]) continue;\\n        if(t - v[idx] < 0) break;\\n        temp.emplace_back(v[idx]);\\n        recur(idx + 1, t - v[idx], v, temp, ans);\\n        temp.pop_back();\\n      }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& v, int t) {\\n      set<vector<int>> anst;\\n      vector<int> temp;\\n      sort(v.begin(), v.end());\\n      recur(0, t, v, temp, anst);\\n      vector<vector<int>> ans(anst.begin(), anst.end());\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844056,
                "title": "easy-c-solution-striver-better-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public: \\n    void findCombination(int ind, int target, vector<int> &arr, vector<vector<int>> &ans, vector<int>&ds) {\\n        if(target==0){ \\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        int prev=-1;\\n        for(int i=ind;i<arr.size();i++){\\n            if(arr[i]!=prev && arr[i]<=target){\\n                ds.push_back(arr[i]);\\n                findCombination(i+1,target-arr[i],arr,ans,ds);\\n                ds.pop_back();\\n                prev=arr[i];\\n            }\\n        }\\n\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans; \\n        vector<int> ds; \\n        findCombination(0, target, candidates, ans, ds); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public: \\n    void findCombination(int ind, int target, vector<int> &arr, vector<vector<int>> &ans, vector<int>&ds) {\\n        if(target==0){ \\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        int prev=-1;\\n        for(int i=ind;i<arr.size();i++){\\n            if(arr[i]!=prev && arr[i]<=target){\\n                ds.push_back(arr[i]);\\n                findCombination(i+1,target-arr[i],arr,ans,ds);\\n                ds.pop_back();\\n                prev=arr[i];\\n            }\\n        }\\n\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        vector<vector<int>> ans; \\n        vector<int> ds; \\n        findCombination(0, target, candidates, ans, ds); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494877,
                "title": "c-not-fastest-but-easy-to-understand-recursive-solution-unique-solution",
                "content": "Please let me know if you need an explanation. I will try to explain in detail.\\n\\n```cpp\\nvoid get_combition_sum_2(vector <int> input, int target, int pos, vector <int> combination, vector <vector <int>> &result){\\n    if (pos >= input.size() || target <= 0){\\n        if (target == 0)\\n            result.push_back(combination);    \\n        return;\\n    }\\n\\n    combination.push_back(input[pos]);\\n    get_combition_sum_2(input, target - input[pos], pos + 1, combination, result);\\n    combination.pop_back();\\n\\n    while (pos < input.size() - 1 && input[pos] == input[pos+1])\\n        pos++;\\n\\n    get_combition_sum_2(input, target, pos + 1, combination, result);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```cpp\\nvoid get_combition_sum_2(vector <int> input, int target, int pos, vector <int> combination, vector <vector <int>> &result){\\n    if (pos >= input.size() || target <= 0){\\n        if (target == 0)\\n            result.push_back(combination);    \\n        return;\\n    }\\n\\n    combination.push_back(input[pos]);\\n    get_combition_sum_2(input, target - input[pos], pos + 1, combination, result);\\n    combination.pop_back();\\n\\n    while (pos < input.size() - 1 && input[pos] == input[pos+1])\\n        pos++;\\n\\n    get_combition_sum_2(input, target, pos + 1, combination, result);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383036,
                "title": "c-solution-backtracking-comments-better-than-89",
                "content": "Here, we can\\'t perform normal backtracking as it would lead to 2^n cases(where n<=100 given). So we tweak the code a bit so that we don\\'t have to produce the same combinations again and again.\\n\\nSteps used:\\n-> After sorting the initial array, follow the below steps\\n-> add the curr element from target and backtrack for the leftover part of array.\\n-> don\\'t add the curr element from the target and backtrack for the leftover part of the array.\\n-> if this we keep track of if the previous element is same as current element, we skip to the next distinct number, and then apply the same steps as above.\\n\\n```\\nclass Solution{\\n    public:\\n    vector<vector<int> > ans;\\n    \\n    void backtrack(vector<int> a, vector<int> curr, int t, int i){\\n        // if t is 0, means we formed the group of elements which sum to target,\\n\\t\\t// and we push it into our ans.\\n\\t\\tif(t==0)\\n\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t\\n\\t\\t// but if t<0, means we don\\'t need to check further for this, \\n\\t\\t// as the elements greater than it, won\\'t sum to t.\\n        if(t<0)    return;\\n\\t\\t\\n\\t\\t// to keep track of prev element( -1 is insignificant here.)\\n        int prev = -1;\\n        \\n        for(; i<a.size(); i++){\\n\\t\\t\\t// if prev element is same as current element, we continue.\\n            if(prev==a[i])  continue;\\n\\t\\t\\t\\n\\t\\t\\t// else we append it to current \\n            curr.push_back(a[i]);\\n\\t\\t\\t\\n\\t\\t\\t// we backtrack for the required element\\n            backtrack(a, curr, t-a[i], i+1);\\n\\t\\t\\t\\n\\t\\t\\t// the other backtrack we use, without using the current element\\n            curr.pop_back();\\n            prev = a[i];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int> &a, int t){\\n\\t\\t// sort the array\\n        sort(a.begin(), a.end());\\n        vector<int> temp;temp.clear();\\n        backtrack(a, temp, t, 0);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution{\\n    public:\\n    vector<vector<int> > ans;\\n    \\n    void backtrack(vector<int> a, vector<int> curr, int t, int i){\\n        // if t is 0, means we formed the group of elements which sum to target,\\n\\t\\t// and we push it into our ans.\\n\\t\\tif(t==0)\\n\\t\\t\\tans.push_back(curr);\\n\\t\\t\\t\\n\\t\\t// but if t<0, means we don\\'t need to check further for this, \\n\\t\\t// as the elements greater than it, won\\'t sum to t.\\n        if(t<0)    return;\\n\\t\\t\\n\\t\\t// to keep track of prev element( -1 is insignificant here.)\\n        int prev = -1;\\n        \\n        for(; i<a.size(); i++){\\n\\t\\t\\t// if prev element is same as current element, we continue.\\n            if(prev==a[i])  continue;\\n\\t\\t\\t\\n\\t\\t\\t// else we append it to current \\n            curr.push_back(a[i]);\\n\\t\\t\\t\\n\\t\\t\\t// we backtrack for the required element\\n            backtrack(a, curr, t-a[i], i+1);\\n\\t\\t\\t\\n\\t\\t\\t// the other backtrack we use, without using the current element\\n            curr.pop_back();\\n            prev = a[i];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int> &a, int t){\\n\\t\\t// sort the array\\n        sort(a.begin(), a.end());\\n        vector<int> temp;temp.clear();\\n        backtrack(a, temp, t, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2318566,
                "title": "c-recursion",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    void recur(int ind, int tar, vector<int>& c, vector<vector<int>>& ans, vector<int>& ds){\\n        if(tar==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<c.size();i++){\\n            if(i>ind && c[i]==c[i-1]) continue;\\n            if(c[i]>tar) break;\\n            \\n            ds.push_back(c[i]);\\n            recur(i+1, tar-c[i], c, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int target) {\\n        sort(c.begin(), c.end());\\n        int n=c.size();\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        recur(0, target, c, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void recur(int ind, int tar, vector<int>& c, vector<vector<int>>& ans, vector<int>& ds){\\n        if(tar==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<c.size();i++){\\n            if(i>ind && c[i]==c[i-1]) continue;\\n            if(c[i]>tar) break;\\n            \\n            ds.push_back(c[i]);\\n            recur(i+1, tar-c[i], c, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int target) {\\n        sort(c.begin(), c.end());\\n        int n=c.size();\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        recur(0, target, c, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260963,
                "title": "combination-of-subsets-ii-90-and-combination-sum-39",
                "content": "class Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n      List<List<Integer>> ans = new ArrayList<>();\\n        //sort the array\\n        Arrays.sort(candidates);\\n        solve(candidates,0,ans,new ArrayList<>(),target);\\n        return ans;\\n    }\\n     public void solve(int[] candidates,int i,List<List<Integer>>ans,List<Integer> output, int target){\\n\\t //base case\\n        if(i==candidates.length){\\n            if(target==0){\\n                ans.add(new ArrayList<>(output));\\n            }\\n            return;\\n        }\\n        //include the element and since each candidate can be used one send i+1 to the function\\n         if(candidates[i]<=target){\\n            output.add(candidates[i]);\\n            solve(candidates,i+1,ans,output,target-candidates[i]);\\n            output.remove(output.size()-1);\\n         }\\n        //exclude if the number is similar to the previous as it will result in same path\\n        while(i+1<candidates.length && candidates[i]==candidates[i+1]){\\n            i++;\\n        }\\n        solve(candidates,i+1,ans,output,target);\\n    }\\n}\\nTried after following striver\\'s and neetcode\\'s approach",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n      List<List<Integer>> ans = new ArrayList<>();\\n        //sort the array\\n        Arrays.sort(candidates);\\n        solve(candidates,0,ans,new ArrayList<>(),target);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1689307,
                "title": "c-solution-set-recursion",
                "content": "*Please upvote if you find it helpful :)*\\n```\\nvoid solve(int index, vector<int> &candidates, int target, vector<int> &v1, set<vector<int> >&v){\\n        if(target==0) {\\n            v.insert(v1);\\n            return ;\\n        }\\n        if(index >= candidates.size() || target < candidates[index])\\n            return;\\n        v1.push_back(candidates[index]);\\n        solve(index+1, candidates, target-candidates[index], v1, v);\\n        v1.pop_back();\\n        int next_index = index;\\n        while (next_index < candidates.size() && candidates[next_index] == candidates[index])\\n            next_index++;\\n        solve(next_index, candidates, target, v1, v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> v1;\\n        set<vector<int> > v;\\n        vector<vector<int> > ans;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0, candidates, target, v1, v);\\n        for(auto x: v) {\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\nvoid solve(int index, vector<int> &candidates, int target, vector<int> &v1, set<vector<int> >&v){\\n        if(target==0) {\\n            v.insert(v1);\\n            return ;\\n        }\\n        if(index >= candidates.size() || target < candidates[index])\\n            return;\\n        v1.push_back(candidates[index]);\\n        solve(index+1, candidates, target-candidates[index], v1, v);\\n        v1.pop_back();\\n        int next_index = index;\\n        while (next_index < candidates.size() && candidates[next_index] == candidates[index])\\n            next_index++;\\n        solve(next_index, candidates, target, v1, v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<int> v1;\\n        set<vector<int> > v;\\n        vector<vector<int> > ans;\\n        sort(candidates.begin(),candidates.end());\\n        solve(0, candidates, target, v1, v);\\n        for(auto x: v) {\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1311783,
                "title": "elegant-python-recursion",
                "content": "```\\n# Time Complexity: 2^(N), where N = len(candidates)\\n# Space Complexity: O(N)\\nfrom collections import Counter\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n    \\n        combinations = []\\n        counter = Counter(candidates)\\n        counter = [(key, counter[key]) for key in counter]\\n        \\n        def recursion(index = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > target or index not in range(len(counter)): return\\n            elif combination_sum == target: combinations.append(current_combination.copy()) \\n            else:\\n                candidate, frequency = counter[index]\\n                if frequency > 0:\\n                    counter[index] = (candidate, frequency-1)\\n                    recursion(index, current_combination + [candidate], combination_sum + candidate)\\n                counter[index] = (candidate, frequency)\\n                recursion(index+1, current_combination, combination_sum)\\n                        \\n        recursion()\\n        return combinations\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Time Complexity: 2^(N), where N = len(candidates)\\n# Space Complexity: O(N)\\nfrom collections import Counter\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n    \\n        combinations = []\\n        counter = Counter(candidates)\\n        counter = [(key, counter[key]) for key in counter]\\n        \\n        def recursion(index = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > target or index not in range(len(counter)): return\\n            elif combination_sum == target: combinations.append(current_combination.copy()) \\n            else:\\n                candidate, frequency = counter[index]\\n                if frequency > 0:\\n                    counter[index] = (candidate, frequency-1)\\n                    recursion(index, current_combination + [candidate], combination_sum + candidate)\\n                counter[index] = (candidate, frequency)\\n                recursion(index+1, current_combination, combination_sum)\\n                        \\n        recursion()\\n        return combinations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788413,
                "title": "8ms-c-backtracking-simple-code",
                "content": "```\\n// upvote if this solution helpes you.\\nclass Solution {\\npublic:\\n    vector<vector<int> >finalans;\\n    set<vector<int> >ans;   // for no repetition\\n    vector<int> temp;\\n    \\n    void backtracking(vector<int>& candidates, int target, set<vector<int> >&ans, vector<int> &temp, int start)\\n    {\\n        if(target == 0)\\n        {\\n            ans.insert(temp);\\n            return;\\n        }\\n        \\n        for(int i=start; i<candidates.size() && target >= candidates[i]; i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            backtracking(candidates, target - candidates[i], ans, temp, i+1);     // i+1 so that it will not pick same element again.\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        backtracking(candidates, target, ans, temp, 0);\\n        for(auto i : ans)\\n            finalans.push_back(i);\\n        return finalans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// upvote if this solution helpes you.\\nclass Solution {\\npublic:\\n    vector<vector<int> >finalans;\\n    set<vector<int> >ans;   // for no repetition\\n    vector<int> temp;\\n    \\n    void backtracking(vector<int>& candidates, int target, set<vector<int> >&ans, vector<int> &temp, int start)\\n    {\\n        if(target == 0)\\n        {\\n            ans.insert(temp);\\n            return;\\n        }\\n        \\n        for(int i=start; i<candidates.size() && target >= candidates[i]; i++)\\n        {\\n            temp.push_back(candidates[i]);\\n            backtracking(candidates, target - candidates[i], ans, temp, i+1);     // i+1 so that it will not pick same element again.\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        backtracking(candidates, target, ans, temp, 0);\\n        for(auto i : ans)\\n            finalans.push_back(i);\\n        return finalans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 650590,
                "title": "java-iterative-dp-no-recursion-straightforward",
                "content": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Map<Integer, Set<List<Integer>>> map = new HashMap<>();\\n        Arrays.sort(candidates);\\n        for (int cand : candidates) {\\n            if (cand > target) continue;\\n            for (int num = target - cand; num >= 0; num--) {\\n                Set<List<Integer>> tmp = map.getOrDefault(num + cand, new HashSet<>());\\n                Set<List<Integer>> prev = map.getOrDefault(num, new HashSet<>());\\n                for (List<Integer> l : prev) {\\n                    List<Integer> newList = new ArrayList<>();\\n                    newList.addAll(l);\\n                    newList.add(cand);\\n                    tmp.add(newList);\\n                }\\n                map.put(num + cand, tmp);\\n            }\\n            map.computeIfAbsent(cand, g -> new HashSet<>());\\n            map.get(cand).add(List.of(cand));\\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.addAll(map.getOrDefault(target, new HashSet<>()));\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Map<Integer, Set<List<Integer>>> map = new HashMap<>();\\n        Arrays.sort(candidates);\\n        for (int cand : candidates) {\\n            if (cand > target) continue;\\n            for (int num = target - cand; num >= 0; num--) {\\n                Set<List<Integer>> tmp = map.getOrDefault(num + cand, new HashSet<>());\\n                Set<List<Integer>> prev = map.getOrDefault(num, new HashSet<>());\\n                for (List<Integer> l : prev) {\\n                    List<Integer> newList = new ArrayList<>();\\n                    newList.addAll(l);\\n                    newList.add(cand);\\n                    tmp.add(newList);\\n                }\\n                map.put(num + cand, tmp);\\n            }\\n            map.computeIfAbsent(cand, g -> new HashSet<>());\\n            map.get(cand).add(List.of(cand));\\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.addAll(map.getOrDefault(target, new HashSet<>()));\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561957,
                "title": "python-6-line-dp-without-using-hashset-to-check-duplicate-explained",
                "content": "I see a lot of posts using HashSet to check duplicates. There is no need for that.\\nThe only difference with question [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/) is that, this questions limits the repetition count for each item in \"candidates\" array. \\nCode is almost the same code as [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/), just adding an extra \"if\" to exclude those repeating too many times.\\n**dp[i]** is a list of all combinations that sums up to \"i\". We put \"candidates\" in outer loop and \"target\" iteration in inner loop, so that when one candidate number is used, it won\\'t be picked again later. This automatically avoids duplicates. No need to use hash for duplicate check.\\n```\\n\\t    counter=collections.Counter(candidates)\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c,cnt in counter.items():\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c] if len(arr)<cnt or arr[-cnt]!=c])        \\n        return dp[target]\\n```\\nWe can use arr[-cnt]!=c to check repeating count because in arr, same number must all be side-by-side.\\n\\nFor comparison, here is the code for [\"39 Combination Sum I\"](https://leetcode.com/problems/combination-sum/). The only difference is, it doesn\\'t have the \"if\" statement in the end of \"dp[i].extend\" line.\\n```\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c in candidates:\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c]])\\n        return dp[target]\\n```",
                "solutionTags": [],
                "code": "```\\n\\t    counter=collections.Counter(candidates)\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c,cnt in counter.items():\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c] if len(arr)<cnt or arr[-cnt]!=c])        \\n        return dp[target]\\n```\n```\\n        dp=[[[]]]+[[] for _ in range(target+1)]\\n        for c in candidates:\\n            for i in range(c,target+1):\\n                dp[i].extend([arr+[c] for arr in dp[i-c]])\\n        return dp[target]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 543016,
                "title": "c-4-ms-short-fast-backtracking-solution-99-100",
                "content": "```\\nclass Solution{\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n        {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> vsum;\\n            add(candidates, 0, target, 0, vsum, res);\\n            return res;\\n        }\\n\\n    protected:\\n        void add(vector<int>& cand, int i, int target, int sum, vector<int>& vsum, vector<vector<int>>& res)\\n        {\\n            for(int s = 0; i < cand.size(); ++i)\\n            {\\n                s = sum + cand[i];\\n                if(s > target) continue;\\n                vsum.push_back(cand[i]);\\n                if(s == target)\\n                    res.push_back(vsum);\\n                else\\n                    add(cand, i+1, target, s, vsum, res);\\n                vsum.pop_back();\\n                while(i+1 < cand.size() && cand[i] == cand[i+1]) ++i; // skip duplicates\\n            }\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution{\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n        {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> vsum;\\n            add(candidates, 0, target, 0, vsum, res);\\n            return res;\\n        }\\n\\n    protected:\\n        void add(vector<int>& cand, int i, int target, int sum, vector<int>& vsum, vector<vector<int>>& res)\\n        {\\n            for(int s = 0; i < cand.size(); ++i)\\n            {\\n                s = sum + cand[i];\\n                if(s > target) continue;\\n                vsum.push_back(cand[i]);\\n                if(s == target)\\n                    res.push_back(vsum);\\n                else\\n                    add(cand, i+1, target, s, vsum, res);\\n                vsum.pop_back();\\n                while(i+1 < cand.size() && cand[i] == cand[i+1]) ++i; // skip duplicates\\n            }\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429543,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146416,
                "title": "11ms-java-solution-with-no-loop-inside-recursion",
                "content": "A simple way to look at the problem is that for each element in the array, we have two options: **include it or not** in the combination.\\nSay we\\'re at array index ```i``` with target ```t```. \\n*Possibility 1:* If we do include ```array[i]```, the problem becomes \"**Find combinations of sum (t - array[i]) in the array starting at i+1**\". \\n*Possibility 2:* If we do **not** include ```array[i]```, the problem is to \"**Find combinations of sum t in the array starting at i+1**\".\\nThe only headache left now is to exclude duplicate answers. Duplicate answers exist because we have duplicate elements in the array. \\nSay we have *k* ```1```\\'s. Using the above algorithm, we get *2^k* possiblites. But among them only *(k+1)* possiblities are useful: *0 ... k* of the k ```1```\\'s are chosen. Thus, we only include the first *n* consecutive ```1```\\'s. That means **once we decide to uninclude a ```1```, we uninclude all the following ```1```\\'s**.\\nSince we consider two possibilities at each index, the execution forms a binary tree with level *n*. The execution time will thus be O(2^n).\\n```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new LinkedList<List<Integer>>();\\n        if(candidates == null || candidates.length == 0)\\n            return res;\\n        Arrays.sort(candidates);\\n        combinations(candidates, target, 0, res, new Stack<>());\\n        return res;\\n    }\\n    \\n    private void combinations(int[] array, int target, int start, \\n                              List<List<Integer>> list, Stack<Integer> stack){\\n    \\tif(target == 0)\\n    \\t\\tlist.add(new ArrayList<Integer>(stack));\\n        if(target < 0 || start == array.length || target < array[start])\\n            return;\\n\\t\\t\\t\\t\\t\\t\\n        //possibility 1: include array[i]\\n        stack.push(array[start]);\\n        combinations(array, target-array[start], start+1, list, stack);\\n        stack.pop();        \\n\\t\\t\\t\\t\\n        //possibility 2: don\\'t include array[i]\\n        while(start+1 < array.length && array[start+1]==array[start])\\n            start++; //exclude duplicates\\n        combinations(array, target, start+1, list, stack);\\n    }\\n```",
                "solutionTags": [],
                "code": "```i```\n```t```\n```array[i]```\n```array[i]```\n```1```\n```1```\n```1```\n```1```\n```1```\n```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new LinkedList<List<Integer>>();\\n        if(candidates == null || candidates.length == 0)\\n            return res;\\n        Arrays.sort(candidates);\\n        combinations(candidates, target, 0, res, new Stack<>());\\n        return res;\\n    }\\n    \\n    private void combinations(int[] array, int target, int start, \\n                              List<List<Integer>> list, Stack<Integer> stack){\\n    \\tif(target == 0)\\n    \\t\\tlist.add(new ArrayList<Integer>(stack));\\n        if(target < 0 || start == array.length || target < array[start])\\n            return;\\n\\t\\t\\t\\t\\t\\t\\n        //possibility 1: include array[i]\\n        stack.push(array[start]);\\n        combinations(array, target-array[start], start+1, list, stack);\\n        stack.pop();        \\n\\t\\t\\t\\t\\n        //possibility 2: don\\'t include array[i]\\n        while(start+1 < array.length && array[start+1]==array[start])\\n            start++; //exclude duplicates\\n        combinations(array, target, start+1, list, stack);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16882,
                "title": "python-dfs-solution",
                "content": "```\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        res = []\\n        \\n        def dfs(t, idx=0, path=[]):\\n            if t < 0:\\n                return  # Backtrack (Not a valid path)\\n            \\n            if t == 0:\\n                res.append(path)\\n                return\\n            \\n            if t > 0:\\n                for i in range(idx, len(candidates)):\\n                    c = candidates[i]\\n                    if i != idx and c == candidates[i-1]: continue  # Eliminates duplicates\\n                    dfs(t-c, i+1, path+[c])\\n\\n        dfs(target)\\n        return res\\n```\\n\\nDFS idea is borrowed from @caikehe's Combination Sum [solution](https://discuss.leetcode.com/topic/23142/python-dfs-solution). Here, when recursively calling dfs in for loop, we increment the index by 1 (unlike combination sum problem where we don't increment i). That's because we don't want the same number to be considered twice. Also, the line `if i != idx and c == candidates[i-1]: continue`, is needed to eliminate duplicate combinations.",
                "solutionTags": [],
                "code": "```\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()\\n        res = []\\n        \\n        def dfs(t, idx=0, path=[]):\\n            if t < 0:\\n                return  # Backtrack (Not a valid path)\\n            \\n            if t == 0:\\n                res.append(path)\\n                return\\n            \\n            if t > 0:\\n                for i in range(idx, len(candidates)):\\n                    c = candidates[i]\\n                    if i != idx and c == candidates[i-1]: continue  # Eliminates duplicates\\n                    dfs(t-c, i+1, path+[c])\\n\\n        dfs(target)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17006,
                "title": "short-and-easy-to-understand-recursive-java-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            combine(candidates, 0, target, res, new ArrayList<Integer>());\\n            return res;\\n        }\\n        private void combine(int[] nums, int start, int target, List<List<Integer>> res, List<Integer> path){\\n            if (target < 0) return;\\n            if (target == 0){\\n                res.add(path);\\n                return;\\n            }\\n            for (int i = start; i < nums.length; i++){\\n                if (i > start && nums[i] == nums[i - 1]) continue;\\n                List<Integer> currentPath = new ArrayList<Integer>(path);\\n                currentPath.add(nums[i]);\\n                combine(nums, i + 1, target - nums[i], res, currentPath);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n            Arrays.sort(candidates);\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            combine(candidates, 0, target, res, new ArrayList<Integer>());\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3581319,
                "title": "python3-backtracking-mega-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        candidates.sort()\\n\\n        def backtracking(start, total, path):\\n            if total == target:\\n                ans.append(path)\\n                return\\n            \\n            for i in range(start, len(candidates)):\\n                if total + candidates[i] > target:\\n                    return\\n                elif i > start and candidates[i] == candidates[i-1]:\\n                    continue\\n                else:\\n                    backtracking(i + 1, total + candidates[i], path + [candidates[i]])\\n\\n        backtracking(0, 0, [])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ans = []\\n        candidates.sort()\\n\\n        def backtracking(start, total, path):\\n            if total == target:\\n                ans.append(path)\\n                return\\n            \\n            for i in range(start, len(candidates)):\\n                if total + candidates[i] > target:\\n                    return\\n                elif i > start and candidates[i] == candidates[i-1]:\\n                    continue\\n                else:\\n                    backtracking(i + 1, total + candidates[i], path + [candidates[i]])\\n\\n        backtracking(0, 0, [])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265075,
                "title": "python-accepted-recursive-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ans=[]\\n        n=len(candidates)\\n        candidates.sort()\\n        def solve(idx,lst,sum):\\n            # nonlocal ans,candidates\\n            if sum==target:\\n                ans.append(lst)\\n                return \\n            for i in range(idx,n):\\n                if i>idx and candidates[i]==candidates[i-1]:\\n                    continue\\n                if sum+candidates[i]>target:\\n                    break\\n                solve(i+1,lst+[candidates[i]],sum+candidates[i])\\n        solve(0,[],0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        ans=[]\\n        n=len(candidates)\\n        candidates.sort()\\n        def solve(idx,lst,sum):\\n            # nonlocal ans,candidates\\n            if sum==target:\\n                ans.append(lst)\\n                return \\n            for i in range(idx,n):\\n                if i>idx and candidates[i]==candidates[i-1]:\\n                    continue\\n                if sum+candidates[i]>target:\\n                    break\\n                solve(i+1,lst+[candidates[i]],sum+candidates[i])\\n        solve(0,[],0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071587,
                "title": "easy-c-solution-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void f(int i,vector<vector<int>>&res, vector<int>& can,vector<int>& temp, int tar){\\n            if(tar==0){\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,res,can,temp,tar-can[j]);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& can, int tar) {\\n        sort(can.begin(),can.end());\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,res,can,temp,tar);\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int i,vector<vector<int>>&res, vector<int>& can,vector<int>& temp, int tar){\\n            if(tar==0){\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,res,can,temp,tar-can[j]);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& can, int tar) {\\n        sort(can.begin(),can.end());\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,res,can,temp,tar);\\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826015,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/11/ugly-number.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nvar combinationSum2 = function(candidates, target) {\\n\\nvar result = []\\n\\ncandidates.sort((a,b) => a-b)\\nvar helper = function(candidates, target, tmpArr, idx){\\n    if(target == 0){ // when target reaches zero, means that you can push it into the result\\n        result.push(tmpArr.slice())\\n        return\\n    }\\n    \\n    if(target < 0){ //with recursion, your \\'target\\' might get reduced till below zero and at that point of time it\\'s time to stop the recursion\\n        return\\n    }\\n    \\n    for(var i = idx; i < candidates.length; i++){ //simulating whether to take or not to take every single digit\\n        if(idx == i || candidates[i] != candidates[i - 1]){\\n            tmpArr.push(candidates[i])\\n            helper(candidates, target - candidates[i], tmpArr, i + 1)\\n            tmpArr.pop()    \\n        }   \\n    }   \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n\\nvar result = []\\n\\ncandidates.sort((a,b) => a-b)\\nvar helper = function(candidates, target, tmpArr, idx){\\n    if(target == 0){ // when target reaches zero, means that you can push it into the result\\n        result.push(tmpArr.slice())\\n        return\\n    }\\n    \\n    if(target < 0){ //with recursion, your \\'target\\' might get reduced till below zero and at that point of time it\\'s time to stop the recursion\\n        return\\n    }\\n    \\n    for(var i = idx; i < candidates.length; i++){ //simulating whether to take or not to take every single digit\\n        if(idx == i || candidates[i] != candidates[i - 1]){\\n            tmpArr.push(candidates[i])\\n            helper(candidates, target - candidates[i], tmpArr, i + 1)\\n            tmpArr.pop()    \\n        }   \\n    }   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774199,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            if(i > id and val[i] == val[i-1]) continue;\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int n;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < n; i++) {\\n            if(i > id and val[i] == val[i-1]) continue;\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        n = candidates.size();\\n        sort(candidates.begin(), candidates.end());\\n        val = candidates;\\n        vector<int> arr;\\n        solve(arr, 0, target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314706,
                "title": "c-backtracking-easy-to-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    set<vector<int>> s;\\n    void backtrack(vector<int> &nums,int target,int idx,vector<int> &v)\\n    {\\n        if(target==0)\\n        {\\n        res.push_back(v);\\n        s.insert(v);\\n        return ;\\n        }\\n        if(target<0||idx>=nums.size())\\n        {\\n            return ;\\n        }\\n        \\n        v.push_back(nums[idx]);\\n        backtrack(nums,target-nums[idx],idx+1,v);\\n        v.pop_back();\\n        \\n        int temp=nums[idx];\\n        while(idx<nums.size()&&temp==nums[idx])\\n            idx++;\\n        \\n        backtrack(nums,target,idx,v);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> v;\\n        backtrack(candidates,target,0,v);\\n        return res;\\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> res;\\n    set<vector<int>> s;\\n    void backtrack(vector<int> &nums,int target,int idx,vector<int> &v)\\n    {\\n        if(target==0)\\n        {\\n        res.push_back(v);\\n        s.insert(v);\\n        return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2270683,
                "title": "c-easy-simple-solution-combination-sum-ii",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans,k;\\n    int target;\\n    void util(vector<int> c,vector<int> a,int sum, int i)\\n    {\\n        if(sum>target )\\n                return;\\n        if(sum==target)\\n            {\\n                ans.push_back(a);\\n                return;\\n            }\\n        for(int j=i;j<c.size();j++)\\n        {\\n            if(j>i && c[j]==c[i])\\n                continue;\\n            sum+=c[j];\\n            a.push_back(c[j]);\\n            util(c,a,sum,j+1);\\n            a.pop_back();\\n            sum-=c[j];\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        target=t;\\n        vector<int> a;\\n        sort(c.begin(),c.end());\\n        util(c,a,0,0);\\n        set<vector<int>> s;\\n        for(auto t: ans)\\n        {\\n            if(s.find(t)==s.end())\\n            {\\n                s.insert(t);\\n                k.push_back(t);\\n            }\\n        }\\n        return k;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> ans,k;\\n    int target;\\n    void util(vector<int> c,vector<int> a,int sum, int i)\\n    {\\n        if(sum>target )\\n                return;\\n        if(sum==target)\\n            {\\n                ans.push_back(a);\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1786651,
                "title": "using-java-recursion-with-set",
                "content": "class Solution \\n\\n\\n{\\n    \\n    private void findCombinations(int index,int[] array,int target,Set<List<Integer>> ans,List<Integer> ds)\\n    {\\n        \\n        if(index==array.length)\\n        {\\n            if(target==0)\\n            {\\n                ans.add(new ArrayList<>(ds));\\n               \\n            }\\n            return;\\n        }\\n        \\n        if(array[index]<=target)\\n        {\\n            ds.add(array[index]);\\n            \\n            findCombinations(index+1,array,target-array[index],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n        findCombinations(index+1,array,target,ans,ds);\\n    }\\n    \\n    \\n    \\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\n        Set<List<Integer>> ans = new HashSet<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList<>());\\n         \\n        \\n        List<List<Integer>> op = new ArrayList<>();\\n        for(List a:ans)\\n        {\\n            op.add(a);\\n        }\\n       return op;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution \\n\\n\\n{\\n    \\n    private void findCombinations(int index,int[] array,int target,Set<List<Integer>> ans,List<Integer> ds)\\n    {\\n        \\n        if(index==array.length)\\n        {\\n            if(target==0)\\n            {\\n                ans.add(new ArrayList<>(ds));\\n               \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1778007,
                "title": "c-simpelst-backtracking-solution-faster-than-100",
                "content": "* The solution is same as that of **Combination Sum**.\\n* But here, since there are repated elements & each element can be used only once, we\\'ll not be looping as : solve(candidates, i, curr, ans, target-C[i]) - this will lead to using an element more than once.\\n* We also add an additional condition in ```solve()``` i.e; when we\\'re traversing the array using ```j```, if ```j != i```, we\\'ll not be adding an element that\\'s repeated (Because we can use elements that\\'re repeated as many no. of times they\\'re repeated, but we cannot have the same combinations forming again and again)\\n\\n* **Eg :** In ```candidates = [1, 1, ,2 ,5 ,6, 7, 10]``` ---> Once we form a combination [1, 2, 5] if we use the 2nd one we\\'ll be again forming the same combination [1, 2, 5] since it satisfies the condition -- Add to the array if it\\'s less than the remaining target. So we avoid using such elements.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> combinationSum2(vector<int>& C, int X) {\\n        n = C.size();\\n        sort(C.begin(), C.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        solve(C, 0, curr, ans, X);\\n        return ans;\\n    }\\n    void solve(vector<int> &C, int i, vector<int> &curr, vector<vector<int>> &ans, int X){\\n        if(X == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int j=i; j<n; j++){\\n            if(X - C[j] >= 0){\\n                if(j > i && C[j]==C[j-1]) continue;\\n                curr.push_back(C[j]);\\n                solve(C, j+1, curr, ans, X-C[j]);\\n                curr.pop_back();\\n            }\\n        }\\n    } \\n};\\n```\\n\\n**Time Complexity :** O(k *x* 2^k) - k = avg length of the combinations arrays\\n\\n\\n**Do upvote if you\\'ve found my solution & explanation helpful :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```solve()```\n```j```\n```j != i```\n```candidates = [1, 1, ,2 ,5 ,6, 7, 10]```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> combinationSum2(vector<int>& C, int X) {\\n        n = C.size();\\n        sort(C.begin(), C.end());\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        solve(C, 0, curr, ans, X);\\n        return ans;\\n    }\\n    void solve(vector<int> &C, int i, vector<int> &curr, vector<vector<int>> &ans, int X){\\n        if(X == 0){\\n            ans.push_back(curr);\\n            return;\\n        }\\n        for(int j=i; j<n; j++){\\n            if(X - C[j] >= 0){\\n                if(j > i && C[j]==C[j-1]) continue;\\n                curr.push_back(C[j]);\\n                solve(C, j+1, curr, ans, X-C[j]);\\n                curr.pop_back();\\n            }\\n        }\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713508,
                "title": "easy-to-understand-forgive-me-drawing-ugly-trees",
                "content": "![image](https://assets.leetcode.com/users/images/00b770e0-5782-458a-92f2-7348e78ce975_1642956700.9327555.png)\\n\\n<br>\\nsome cases you must pay attention to:\\n\\n\\n\\n1. n < 0\\n\\n```java\\nif (n < 0) skip all later ones\\n```\\n\\n2. n == 0\\n\\n```java\\n// write as template\\nif (n == 0) {\\n  \\tres.add(....)\\n    return;\\n}\\n```\\n\\n3. after backtrack recursion calling in loop, skip duplicates\\n\\n```java\\nwhile (i + 1 < A.length && A[i + 1] == A[i])\\n  i += 1;\\n```\\n\\n\\n\\nsome code:\\n\\n```java\\n/*\\nEach number in candidates may only be used once in the combination.\\nThus, need to use \\'offset\\'\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        \\n        backtrack(candidates, target, res, new ArrayList<>(), 0);\\n        \\n        return res;\\n    }\\n    \\n    private void backtrack(int[] A, int n, List<List<Integer>> res\\n                           , List<Integer> list, int offset) {\\n        if (n == 0) {\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int i = offset; i < A.length; i += 1) {\\n            \\n            int tmp = A[i];\\n            \\n            list.add(A[i]);\\n            n -= A[i];\\n            \\n            if (n < 0) // if n < 0, we dont even go to next level of backtracking tree!\\n                i = A.length;\\n            else\\n                backtrack(A, n, res, list, i + 1);\\n            \\n            list.remove(list.size() - 1);\\n            n += tmp;\\n            \\n            // skip all dups\\n            while (i + 1 < A.length && A[i + 1] == A[i])\\n                i += 1;\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\nif (n < 0) skip all later ones\\n```\n```java\\n// write as template\\nif (n == 0) {\\n  \\tres.add(....)\\n    return;\\n}\\n```\n```java\\nwhile (i + 1 < A.length && A[i + 1] == A[i])\\n  i += 1;\\n```\n```java\\n/*\\nEach number in candidates may only be used once in the combination.\\nThus, need to use \\'offset\\'\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        \\n        backtrack(candidates, target, res, new ArrayList<>(), 0);\\n        \\n        return res;\\n    }\\n    \\n    private void backtrack(int[] A, int n, List<List<Integer>> res\\n                           , List<Integer> list, int offset) {\\n        if (n == 0) {\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int i = offset; i < A.length; i += 1) {\\n            \\n            int tmp = A[i];\\n            \\n            list.add(A[i]);\\n            n -= A[i];\\n            \\n            if (n < 0) // if n < 0, we dont even go to next level of backtracking tree!\\n                i = A.length;\\n            else\\n                backtrack(A, n, res, list, i + 1);\\n            \\n            list.remove(list.size() - 1);\\n            n += tmp;\\n            \\n            // skip all dups\\n            while (i + 1 < A.length && A[i + 1] == A[i])\\n                i += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673313,
                "title": "easy-java-solution-and-explaination-with-time-and-space-complexity",
                "content": "```\\nclass Solution {\\n    \\n    //lets implement the func here\\n    public void func(int ind, int target, int[] arr, List<Integer> ds, List<List<Integer>> ansList)\\n    {\\n        \\n        //this is the base case -> whenever the target will reach 0 \\n        //we can surely say that we\\'ve got our list and we can add it to the ansList\\n        \\n         if(target == 0) {\\n            ansList.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        //every time we are checking from the index ind to n-1 where n is the length of the array\\n        for(int i = ind; i< arr.length; i++)\\n        {\\n            \\n            //this is how we\\'ll find the duplicates and ignore it.\\n            //basically i\\'m checking if I am not getting any particular elemnt for the first time (i>ind)\\n            //&& the previous arr element is same as this one\\n            //then I\\'ll simply continue \\n            if(i > ind && arr[i] == arr[i-1]) continue;\\n            \\n            //Also, suppose my target is 4 and the arr[ind] is 10\\n            //then I can\\'t really use that array element\\n            //thats why I simply break out of the loop\\n            if(arr[ind] > target) break;\\n            \\n            // If I come out of the if condition \\n            //then that means everything is alright and the current array element \\n            //can contribute to my ans so I add it to my list ds.\\n            ds.add(arr[i]);\\n            \\n            //next, I call the function for the next element and this time my target will sure be reduced by whatever value we have ar arr[i]\\n            func(i+1, target - arr[i], arr, ds, ansList);\\n            \\n            //when we return make sure to remove whatever we\\'ve added. This is the backtracking step.\\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        //Initially sort the given array because we need to avoid duplicates.\\n        Arrays.sort(candidates);\\n        \\n        //create a List of List of Integer so that we can return our output.\\n        List<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //create a function and pass index=0, target, array, List<Integer>, ansList)\\n        //we pass List<Integer> because in the main ansList we\\'ll be adding this list with all the possible unique lists.\\n         func(0, target, candidates, new ArrayList<Integer>(), ansList);\\n        \\n        //once we get our output from the above function we return ansList.\\n        return ansList;\\n    }\\n}\\n```\\n\\nTC - O(2^n) * K - where k is the average list size\\nSC - K * X - where X is no. of combinations\\n\\nI hope you find this helpful. Please do upvote in case you understood.\\nThankss!",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //lets implement the func here\\n    public void func(int ind, int target, int[] arr, List<Integer> ds, List<List<Integer>> ansList)\\n    {\\n        \\n        //this is the base case -> whenever the target will reach 0 \\n        //we can surely say that we\\'ve got our list and we can add it to the ansList\\n        \\n         if(target == 0) {\\n            ansList.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        //every time we are checking from the index ind to n-1 where n is the length of the array\\n        for(int i = ind; i< arr.length; i++)\\n        {\\n            \\n            //this is how we\\'ll find the duplicates and ignore it.\\n            //basically i\\'m checking if I am not getting any particular elemnt for the first time (i>ind)\\n            //&& the previous arr element is same as this one\\n            //then I\\'ll simply continue \\n            if(i > ind && arr[i] == arr[i-1]) continue;\\n            \\n            //Also, suppose my target is 4 and the arr[ind] is 10\\n            //then I can\\'t really use that array element\\n            //thats why I simply break out of the loop\\n            if(arr[ind] > target) break;\\n            \\n            // If I come out of the if condition \\n            //then that means everything is alright and the current array element \\n            //can contribute to my ans so I add it to my list ds.\\n            ds.add(arr[i]);\\n            \\n            //next, I call the function for the next element and this time my target will sure be reduced by whatever value we have ar arr[i]\\n            func(i+1, target - arr[i], arr, ds, ansList);\\n            \\n            //when we return make sure to remove whatever we\\'ve added. This is the backtracking step.\\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        \\n        //Initially sort the given array because we need to avoid duplicates.\\n        Arrays.sort(candidates);\\n        \\n        //create a List of List of Integer so that we can return our output.\\n        List<List<Integer>> ansList = new ArrayList<>();\\n        \\n        //create a function and pass index=0, target, array, List<Integer>, ansList)\\n        //we pass List<Integer> because in the main ansList we\\'ll be adding this list with all the possible unique lists.\\n         func(0, target, candidates, new ArrayList<Integer>(), ansList);\\n        \\n        //once we get our output from the above function we return ansList.\\n        return ansList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568727,
                "title": "solution-using-backtracking-with-given-input-in-c",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid unique_combination(int l, int sum, int K,vector<int>& local,vector<int>& A)\\n{\\n\\tif (sum == K) {\\n\\t\\tcout << \"(\";\\n\\t\\tfor (int i = 0; i < local.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif (i != 0)\\n\\t\\t\\t\\tcout << \" \";\\n\\t\\t\\tcout << local[i];\\n\\t\\t\\tif (i != local.size() - 1)\\n\\t\\t\\t\\tcout << \",\";\\n\\t\\t}\\n\\t\\tcout << \")\" << endl;\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = l; i < A.size(); i++)\\n\\t{\\n\\t\\tif (sum + A[i] > K)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tif (i > l and A[i] == A[i - 1])\\n\\t\\t\\tcontinue;\\n\\n\\t\\tlocal.push_back(A[i]);\\n\\t\\tunique_combination(i + 1, sum + A[i], K, local, A);\\n\\n\\t\\tlocal.pop_back();\\n\\t}\\n}\\n\\nvoid Combination(vector<int> A, int K)\\n{\\n\\tsort(A.begin(), A.end());\\n\\n\\t\\n\\tvector<int> local;\\n\\n\\tunique_combination(0, 0, K, local, A);\\n}\\n\\nint main()\\n{\\n\\tvector<int> W = {5,10,12,13,15,18};\\n    int target = 30;\\n    cout << \"All unique combinations of given numbers that result in sum= \" << target << \" are:\\\\n\";\\n    Combination(W,target);\\n    \\n\\n\\treturn 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\nvoid unique_combination(int l, int sum, int K,vector<int>& local,vector<int>& A)\\n{\\n\\tif (sum == K) {\\n\\t\\tcout << \"(\";\\n\\t\\tfor (int i = 0; i < local.size(); i++)\\n\\t\\t{\\n\\t\\t\\tif (i != 0)\\n\\t\\t\\t\\tcout << \" \";\\n\\t\\t\\tcout << local[i];\\n\\t\\t\\tif (i != local.size() - 1)\\n\\t\\t\\t\\tcout << \",\";\\n\\t\\t}\\n\\t\\tcout << \")\" << endl;\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = l; i < A.size(); i++)\\n\\t{\\n\\t\\tif (sum + A[i] > K)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tif (i > l and A[i] == A[i - 1])\\n\\t\\t\\tcontinue;\\n\\n\\t\\tlocal.push_back(A[i]);\\n\\t\\tunique_combination(i + 1, sum + A[i], K, local, A);\\n\\n\\t\\tlocal.pop_back();\\n\\t}\\n}\\n\\nvoid Combination(vector<int> A, int K)\\n{\\n\\tsort(A.begin(), A.end());\\n\\n\\t\\n\\tvector<int> local;\\n\\n\\tunique_combination(0, 0, K, local, A);\\n}\\n\\nint main()\\n{\\n\\tvector<int> W = {5,10,12,13,15,18};\\n    int target = 30;\\n    cout << \"All unique combinations of given numbers that result in sum= \" << target << \" are:\\\\n\";\\n    Combination(W,target);\\n    \\n\\n\\treturn 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1369209,
                "title": "template-same-structure-codes-for-combination-subset-and-permutations",
                "content": "In this post:\\n\\nthese codes may not the fast solution or solution with least lines, but:\\n**If you understand one question, you can fix all others.**\\n\\nAll of them used the same structure.\\n--- Bot Up DFS, so we can use memorization to save inmediate results to speed up the algorithm.\\n\\n**All memorization part are not mandatory** , if you remove these codes, the algorithm still works.\\n\\nPart 1: Permutations\\nWhen order is matter,  we use boolean[] visited to avoid duplicate values.\\nPart 2: Combination\\nWhen order is not necessary,  for (int i = start; i < n; i++)  and dfs(i + 1) to avlid duplicate combination.\\nPart 3: Set\\nWhen the order is not necessary and the size of combination can be different, use a for loop to check the size from 0 to k.\\n\\n------------------------------------------------------------------------------------------------\\n\\n# Part one: Permutations\\nleetcode 46 https://leetcode.com/problems/permutations/\\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permute(int[] nums) {\\n        this.nums = nums;\\n        this.visited = new boolean[nums.length];\\n        return permuteDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteDfs(int pos) {\\n       \\n\\t   if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\t\\t\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            visited[i] = true;\\n            List<List<Integer>> subs = permuteDfs(pos + 1);\\n            for (List<Integer> sub: subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n            visited[i] = false;\\n        }        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 47 https://leetcode.com/problems/permutations-ii/\\n\\njust one line different to fix the duplication\\n\\n*if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;*\\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        this.nums = nums;\\n        visited = new boolean[nums.length];\\n        Arrays.sort(nums);\\n        return permuteUniqueDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteUniqueDfs(int pos) {\\n        if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;\\n                visited[i] = true;\\n                List<List<Integer>> subs = permuteUniqueDfs(pos + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                visited[i] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 131\\nhttps://leetcode.com/problems/palindrome-partitioning/\\nThere is memorization function.\\n\\n```\\nclass Solution {\\n    String s;\\n    Map<Integer, List<List<String>>> cache;\\n    public List<List<String>> partition(String s) {\\n        this.s = s;\\n        this.cache = new HashMap<>();\\n        return partitionDfs(0);\\n    }\\n    \\n    private List<List<String>>  partitionDfs(int start) {\\n        if(start == s.length()) {\\n            List<List<String>> res = new ArrayList<>();\\n            List<String> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        if(cache.containsKey(start)){\\n            return cache.get(start);\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String cur = s.substring(start, i);\\n            if(isValid(cur)) {\\n                List<List<String>> subs = partitionDfs(i);\\n                for (List<String> sub: subs) {\\n                    List<String> prefix_item = new ArrayList<>();\\n                    prefix_item.add(cur);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                }\\n            }\\n        }\\n        cache.put(start, res);\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        int l = 0;\\n        int r = str.length() - 1;    \\n        while(l < r) {\\n            if (str.charAt(l) != str.charAt(r)) return false;\\n            else {\\n                l++;\\n                r--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n\\n# Part 2: Combination\\nleetcode 77 \\nhttps://leetcode.com/problems/combinations/\\n```\\nclass Solution {\\n    int k;\\n    int n;\\n    public List<List<Integer>> combine(int n, int k) {\\n        this.k = k;\\n        this.n = n;\\n        return combineDfs(1, 0);\\n    }\\n    \\n    private List<List<Integer>> combineDfs(int start, int len) {\\n        if(len == k) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i <= n; i++) {\\n            List<List<Integer>> subs = combineDfs(i + 1, len + 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(i);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nLeetcode 39. https://leetcode.com/problems/combination-sum/\\n```\\nclass Solution {\\n    int[] candidates;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        this.candidates = candidates;\\n        int n = candidates.length;        \\n        return combinationSumDfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSumDfs(int target, int pos) {\\n        if(target < 0) return new ArrayList<>();\\n        \\n        if(this.cache.containsKey(new Pair(target, pos))) {\\n            return this.cache.get(new Pair(target, pos));\\n        }\\n        \\n        if(target == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(target, pos);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n    \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = pos; i < candidates.length; i++) {\\n            List<List<Integer>> subs = combinationSumDfs(target - candidates[i], i);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(candidates[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(target, pos);\\n        cache.put(pair, res);\\n            \\n        return res;\\n    } \\n}\\n```\\n\\nleetcode 40 https://leetcode.com/problems/combination-sum-ii/\\n\\n```\\nclass Solution {\\n    int[] candidates;\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        this.candidates = candidates;\\n        return combinationSum2Dfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSum2Dfs(int target, int start) {\\n        if(target == 0){\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;    \\n        }\\n        \\n        if(target < 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i < candidates.length; i++) {\\n            if((i == start || candidates[i] != candidates[i - 1])) {\\n                List<List<Integer>> subs = combinationSum2Dfs(target - candidates[i], i + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> prefix_item = new ArrayList<>();\\n                    prefix_item.add(candidates[i]);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nPart 3: Set\\n\\nleetcode 78 https://leetcode.com/problems/subsets/\\n\\n```\\nclass Solution {\\n    int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.nums = nums;\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nleetcode 90\\nhttps://leetcode.com/problems/subsets-ii/\\n\\n```\\nclass Solution {\\n   int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        this.nums = nums;\\n        Arrays.sort(nums);\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if(i == start || nums[i] != nums[i - 1]) {\\n                List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n                for (List<Integer> sub : subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                }                \\n            }\\n        }\\n        \\n\\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n\\n```\\n\\nRelated posts before:\\n\\n\\nPython:\\nhttps://leetcode.com/problems/permutation-sequence/discuss/22554/Backtrack-Summary%3A-General-Solution-for-10-Questions!!!!!!!!-Python-(Combination-Sum-Subsets-Permutation-Palindrome)\\n\\nJava:\\nhttps://leetcode.com/problems/permutations/discuss/18239/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning\\n\\n---------------------------\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permute(int[] nums) {\\n        this.nums = nums;\\n        this.visited = new boolean[nums.length];\\n        return permuteDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteDfs(int pos) {\\n       \\n\\t   if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\t\\t\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            visited[i] = true;\\n            List<List<Integer>> subs = permuteDfs(pos + 1);\\n            for (List<Integer> sub: subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n            visited[i] = false;\\n        }        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] nums;\\n    boolean[] visited;\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        this.nums = nums;\\n        visited = new boolean[nums.length];\\n        Arrays.sort(nums);\\n        return permuteUniqueDfs(0);\\n    }\\n    \\n    private List<List<Integer>> permuteUniqueDfs(int pos) {\\n        if(pos == nums.length) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n\\n        List<List<Integer>> res = new ArrayList<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if(visited[i]) continue;\\n            if(i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;\\n                visited[i] = true;\\n                List<List<Integer>> subs = permuteUniqueDfs(pos + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                visited[i] = false;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    String s;\\n    Map<Integer, List<List<String>>> cache;\\n    public List<List<String>> partition(String s) {\\n        this.s = s;\\n        this.cache = new HashMap<>();\\n        return partitionDfs(0);\\n    }\\n    \\n    private List<List<String>>  partitionDfs(int start) {\\n        if(start == s.length()) {\\n            List<List<String>> res = new ArrayList<>();\\n            List<String> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        if(cache.containsKey(start)){\\n            return cache.get(start);\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String cur = s.substring(start, i);\\n            if(isValid(cur)) {\\n                List<List<String>> subs = partitionDfs(i);\\n                for (List<String> sub: subs) {\\n                    List<String> prefix_item = new ArrayList<>();\\n                    prefix_item.add(cur);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                }\\n            }\\n        }\\n        cache.put(start, res);\\n        return res;\\n    }\\n    \\n    private boolean isValid(String str) {\\n        int l = 0;\\n        int r = str.length() - 1;    \\n        while(l < r) {\\n            if (str.charAt(l) != str.charAt(r)) return false;\\n            else {\\n                l++;\\n                r--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int k;\\n    int n;\\n    public List<List<Integer>> combine(int n, int k) {\\n        this.k = k;\\n        this.n = n;\\n        return combineDfs(1, 0);\\n    }\\n    \\n    private List<List<Integer>> combineDfs(int start, int len) {\\n        if(len == k) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i <= n; i++) {\\n            List<List<Integer>> subs = combineDfs(i + 1, len + 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(i);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] candidates;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        this.candidates = candidates;\\n        int n = candidates.length;        \\n        return combinationSumDfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSumDfs(int target, int pos) {\\n        if(target < 0) return new ArrayList<>();\\n        \\n        if(this.cache.containsKey(new Pair(target, pos))) {\\n            return this.cache.get(new Pair(target, pos));\\n        }\\n        \\n        if(target == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(target, pos);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n    \\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = pos; i < candidates.length; i++) {\\n            List<List<Integer>> subs = combinationSumDfs(target - candidates[i], i);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(candidates[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(target, pos);\\n        cache.put(pair, res);\\n            \\n        return res;\\n    } \\n}\\n```\n```\\nclass Solution {\\n    int[] candidates;\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        this.candidates = candidates;\\n        return combinationSum2Dfs(target, 0);\\n    }\\n    \\n    private List<List<Integer>> combinationSum2Dfs(int target, int start) {\\n        if(target == 0){\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();\\n            res.add(item);\\n            return res;    \\n        }\\n        \\n        if(target < 0) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = start; i < candidates.length; i++) {\\n            if((i == start || candidates[i] != candidates[i - 1])) {\\n                List<List<Integer>> subs = combinationSum2Dfs(target - candidates[i], i + 1);\\n                for (List<Integer> sub: subs) {\\n                    List<Integer> prefix_item = new ArrayList<>();\\n                    prefix_item.add(candidates[i]);\\n                    prefix_item.addAll(sub);\\n                    res.add(prefix_item);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.nums = nums;\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n            for (List<Integer> sub : subs) {\\n                List<Integer> item = new ArrayList<>();\\n                item.add(nums[i]);\\n                item.addAll(sub);\\n                res.add(item);\\n            }\\n        }\\n        \\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n   int[] nums;\\n    Map<Pair<Integer, Integer>, List<List<Integer>>> cache = new HashMap<>();\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        this.nums = nums;\\n        Arrays.sort(nums);\\n        List<List<Integer>>  res = new ArrayList<>();\\n        for (int k = 0; k <= nums.length; k++) {\\n            res.addAll(subsetsDfs(0, k));\\n        }\\n        return res;\\n    }\\n \\n    private List<List<Integer>> subsetsDfs(int start, int len) {\\n        if(len == 0) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            List<Integer> item = new ArrayList<>();;\\n            res.add(item);\\n            \\n            Pair<Integer, Integer> pair = new Pair(start, len);\\n            cache.put(pair, res);\\n            \\n            return res;\\n        }\\n        \\n        if(this.cache.containsKey(new Pair(start, len))) {\\n            return this.cache.get(new Pair(start, len));\\n        }\\n                \\n        List<List<Integer>> res = new ArrayList<>();\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if(i == start || nums[i] != nums[i - 1]) {\\n                List<List<Integer>> subs = subsetsDfs(i + 1, len - 1);\\n                for (List<Integer> sub : subs) {\\n                    List<Integer> item = new ArrayList<>();\\n                    item.add(nums[i]);\\n                    item.addAll(sub);\\n                    res.add(item);\\n                }                \\n            }\\n        }\\n        \\n\\n        Pair<Integer, Integer> pair = new Pair(start, len);\\n        cache.put(pair, res);\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208963,
                "title": "python-knapsack-solution",
                "content": "This problem sounds very similar to a [well known knapsack problem](https://en.wikipedia.org/wiki/Knapsack_problem).\\nIt can be solved here in `O(N^2*target)` time and memory.\\n\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t    cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(n+1)]\\n        for i in range(n+1):\\n            dp[i][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            for s in range(1, target+1):\\n                dp[i][s] = dp[i-1][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[i-1][s-cands[i-1]]:\\n                    dp[i][s].add(comb+(cands[i-1],))\\n                    \\n        return [list(var) for var in dp[n][target]]\\n```\\n\\nOf course, we can save some memory because we use only previous row (`O(target*N)`). Smth like following:\\n\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(2)]\\n        dpIdx = 0\\n        dp[dpIdx][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            dpIdx2 = 1 - dpIdx\\n            dp[dpIdx2][0] = set([tuple()])\\n            for s in range(1, target+1):\\n                dp[dpIdx2][s] = dp[dpIdx][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[dpIdx][s-cands[i-1]]:\\n                    dp[dpIdx2][s].add(comb+(cands[i-1],))\\n                    \\n            print(dp[dpIdx2])\\n            dpIdx = dpIdx2\\n                    \\n        return [list(var) for var in dp[dpIdx][target]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\t    cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(n+1)]\\n        for i in range(n+1):\\n            dp[i][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            for s in range(1, target+1):\\n                dp[i][s] = dp[i-1][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[i-1][s-cands[i-1]]:\\n                    dp[i][s].add(comb+(cands[i-1],))\\n                    \\n        return [list(var) for var in dp[n][target]]\\n```\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        cands = sorted(candidates)\\n        n = len(cands)\\n        dp = [[set() for _ in range(target+1)] for _ in range(2)]\\n        dpIdx = 0\\n        dp[dpIdx][0] = set([tuple()])\\n        for i in range(1, n+1):\\n            dpIdx2 = 1 - dpIdx\\n            dp[dpIdx2][0] = set([tuple()])\\n            for s in range(1, target+1):\\n                dp[dpIdx2][s] = dp[dpIdx][s].copy()\\n                if s < cands[i-1]:\\n                    continue\\n                for comb in dp[dpIdx][s-cands[i-1]]:\\n                    dp[dpIdx2][s].add(comb+(cands[i-1],))\\n                    \\n            print(dp[dpIdx2])\\n            dpIdx = dpIdx2\\n                    \\n        return [list(var) for var in dp[dpIdx][target]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204663,
                "title": "lessons-learned",
                "content": "How this differs from Combination Sum 1 is this has **duplicate** elements and shouldn\\'t use the number at same index multiple times.\\n\\n**Related problems**: All try to teach recursion + loop combo\\n* https://leetcode.com/problems/permutations/ : **(Basics)** on every recursion, iteration starts from 0th index \\n* https://leetcode.com/problems/permutations-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern \\n* https://leetcode.com/problems/combinations/ : **(Basics)** on every recursion, iteration starts from next index (ie, adjacent index to parent recursion iteration index) \\n* https://leetcode.com/problems/combination-sum/ : **(Basics)** sorting helps to prune\\n* https://leetcode.com/problems/combination-sum-ii/ : **(Basics)** brings in duplicate elements, introduces countMap pattern and Sort+skip adjacent duplicate elements pattern\\n* https://leetcode.com/problems/restore-ip-addresses/ : **(Advanced)** includes special char \\'.\\', StringBuilder, number conversion, number validity check, looped deletion\\n* https://leetcode.com/problems/24-game/ : **(Advanced)** \\n* If you have done the above problems, no need to do: https://leetcode.com/problems/combination-sum-iii/, https://leetcode.com/problems/subsets/, https://leetcode.com/problems/subsets-ii/, https://leetcode.com/problems/letter-combinations-of-a-phone-number/ . These are very similar to the above ones and you won\\'t gain much from these.\\n\\n\\n**Code**:\\n```\\n// Optimzed approach 3 by Pruning recursion\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        // if (target < 0) return; // Better to exit early from for loop using `nums[i] <= target` so no need to recurse for further million elements just to get returned at \\'(target < 0) return;\\'\\n \\xA0 \\xA0 \\xA0 \\xA0for (int i = start; i < nums.length && nums[i] <= target; ++i) { // Prune current recursion with nums[i] <= target \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 3 that I would come up with during interview: Sort and skip duplicates in the same recursive loop.\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2 This along with .sort() removes duplicate combinations.\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 2 commonly used for permutation and combination problems when duplicate elements are involved: frequency Hashmap \\nclass Solution {\\n  \\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        recurse(target, map, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int target, Map<Integer, Integer> map, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (target < 0) return;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int num = entry.getKey();\\n            int count = entry.getValue();\\n            if (count <= 0 || (!tempList.isEmpty() && num < tempList.get(tempList.size() - 1))) continue; // Second condition of taking only increaing sequence (or a decreasing seq) is what turns a permuation into a combination\\n            \\n            tempList.add(num);\\n            map.put(num, count - 1);\\n            recurse(target - num, map, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n            map.put(num, count);\\n        }\\n    }\\n}\\n```\\n\\n```\\n// Approach 1 or bruteforce approach: Simply add HashSet to Combination Sum 1 to remove duplicate combinations\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        Set<List<Integer>> ans = new HashSet();\\n        Arrays.sort(nums);  // 1: Order of elements in List is important when List is used as key in HashSet\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, Set<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Optimzed approach 3 by Pruning recursion\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        // if (target < 0) return; // Better to exit early from for loop using `nums[i] <= target` so no need to recurse for further million elements just to get returned at \\'(target < 0) return;\\'\\n \\xA0 \\xA0 \\xA0 \\xA0for (int i = start; i < nums.length && nums[i] <= target; ++i) { // Prune current recursion with nums[i] <= target \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 3 that I would come up with during interview: Sort and skip duplicates in the same recursive loop.\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Arrays.sort(nums);  // 1\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (i > start && nums[i] == nums[i - 1]) continue; // 2 This along with .sort() removes duplicate combinations.\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 2 commonly used for permutation and combination problems when duplicate elements are involved: frequency Hashmap \\nclass Solution {\\n  \\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList();\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        recurse(target, map, new ArrayList(), ans);\\n        return ans;\\n    }\\n    \\n    private void recurse(int target, Map<Integer, Integer> map, List<Integer> tempList, List<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n            return;\\n        }\\n        if (target < 0) return;\\n        \\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int num = entry.getKey();\\n            int count = entry.getValue();\\n            if (count <= 0 || (!tempList.isEmpty() && num < tempList.get(tempList.size() - 1))) continue; // Second condition of taking only increaing sequence (or a decreasing seq) is what turns a permuation into a combination\\n            \\n            tempList.add(num);\\n            map.put(num, count - 1);\\n            recurse(target - num, map, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n            map.put(num, count);\\n        }\\n    }\\n}\\n```\n```\\n// Approach 1 or bruteforce approach: Simply add HashSet to Combination Sum 1 to remove duplicate combinations\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        Set<List<Integer>> ans = new HashSet();\\n        Arrays.sort(nums);  // 1: Order of elements in List is important when List is used as key in HashSet\\n        recurse(nums, target, 0, new ArrayList(), ans);\\n        return new ArrayList<>(ans);\\n    }\\n    \\n    private void recurse(int[] nums, int target, int start, List<Integer> tempList, Set<List<Integer>> ans) {\\n        if (target == 0) {\\n            ans.add(new ArrayList<>(tempList));\\n        }\\n        if (target < 0) return;\\n        \\n        for (int i = start; i < nums.length; ++i) {\\n            tempList.add(nums[i]);\\n            recurse(nums, target - nums[i], i + 1, tempList, ans);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197125,
                "title": "backtracking-with-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>result;\\n    void helper(vector<int>& candidates,int index,int n,vector<int>&interim,int target)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(interim);\\n            return;\\n            \\n        }\\n        if(index == n)\\n            return;\\n        for(int i = index;i<n;i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                interim.push_back(candidates[i]);\\n                helper(candidates,i+1,n,interim,target-candidates[i]);\\n                interim.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n       int n = candidates.size();\\n        vector<int>interim;\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,n,interim,target);\\n        set<vector<int>>pq;\\n        for(auto i:result)\\n        pq.insert(i);\\n        vector<vector<int>>result1;\\n        for(auto i:pq)\\n        {\\n            result1.push_back(i);\\n        }\\n        return result1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>result;\\n    void helper(vector<int>& candidates,int index,int n,vector<int>&interim,int target)\\n    {\\n        if(target == 0)\\n        {\\n            result.push_back(interim);\\n            return;\\n            \\n        }\\n        if(index == n)\\n            return;\\n        for(int i = index;i<n;i++)\\n        {\\n            if(candidates[i]<=target)\\n            {\\n                interim.push_back(candidates[i]);\\n                helper(candidates,i+1,n,interim,target-candidates[i]);\\n                interim.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n       int n = candidates.size();\\n        vector<int>interim;\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,n,interim,target);\\n        set<vector<int>>pq;\\n        for(auto i:result)\\n        pq.insert(i);\\n        vector<vector<int>>result1;\\n        for(auto i:pq)\\n        {\\n            result1.push_back(i);\\n        }\\n        return result1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906626,
                "title": "java-backtracking-sorting-to-avoid-duplicates-dfs",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ansList = new LinkedList<>();\\n        Arrays.sort(candidates); //sorting helps avoid duplicates\\n        solve(candidates, candidates.length, target, 0, ansList, new LinkedList<>());\\n        return ansList;\\n    }\\n    \\n    void solve(int[]arr,int n, int target, int start, List<List<Integer>> ansList, List<Integer> subList){\\n        \\n        if(target == 0){\\n            ansList.add(new LinkedList<>(subList));\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++){\\n            if(i>start && arr[i] == arr[i-1]) continue; //avoid duplicates\\n            if(target - arr[i] < 0) continue;\\n            subList.add(arr[i]);\\n            solve(arr,n,target-arr[i],i+1,ansList,subList);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ansList = new LinkedList<>();\\n        Arrays.sort(candidates); //sorting helps avoid duplicates\\n        solve(candidates, candidates.length, target, 0, ansList, new LinkedList<>());\\n        return ansList;\\n    }\\n    \\n    void solve(int[]arr,int n, int target, int start, List<List<Integer>> ansList, List<Integer> subList){\\n        \\n        if(target == 0){\\n            ansList.add(new LinkedList<>(subList));\\n            return;\\n        }\\n        \\n        for(int i=start;i<n;i++){\\n            if(i>start && arr[i] == arr[i-1]) continue; //avoid duplicates\\n            if(target - arr[i] < 0) continue;\\n            subList.add(arr[i]);\\n            solve(arr,n,target-arr[i],i+1,ansList,subList);\\n            subList.remove(subList.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843631,
                "title": "simple-12ms-c-backtrack-explain-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int req_sum;\\n    vector<vector<int>> ans;  // We will return this as final ans\\n    int l ; //this i is the size required and size of our candidates array\\n    void helper(vector<int>& candidates,int index,int sum,vector<int>& v){\\n        if(sum==req_sum)ans.push_back(v); //We have our solution\\n        if(index>=candidates.size() || sum>req_sum)return; // Just to check overflow conditions\\n        for(int i=index;i<l;i++){\\n            if(i>index && candidates[i]==candidates[i-1])continue; //Avoiding Duplicates as array is sorted prev like [1,1,6,7] index C[0]==C[1] so we should leave this.\\n            v.push_back(candidates[i]);\\n            helper(candidates,i+1,sum+candidates[i],v); // Recursive Call with the next index\\n            \\n            v.pop_back();  // Backtracking simply if we return from above statement then we will pop_back as last inserted element must be in either of these conditions i>c.size() || sum>req_sum \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        req_sum=target;\\n        vector<int> v;\\n        l=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,0,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int req_sum;\\n    vector<vector<int>> ans;  // We will return this as final ans\\n    int l ; //this i is the size required and size of our candidates array\\n    void helper(vector<int>& candidates,int index,int sum,vector<int>& v){\\n        if(sum==req_sum)ans.push_back(v); //We have our solution\\n        if(index>=candidates.size() || sum>req_sum)return; // Just to check overflow conditions\\n        for(int i=index;i<l;i++){\\n            if(i>index && candidates[i]==candidates[i-1])continue; //Avoiding Duplicates as array is sorted prev like [1,1,6,7] index C[0]==C[1] so we should leave this.\\n            v.push_back(candidates[i]);\\n            helper(candidates,i+1,sum+candidates[i],v); // Recursive Call with the next index\\n            \\n            v.pop_back();  // Backtracking simply if we return from above statement then we will pop_back as last inserted element must be in either of these conditions i>c.size() || sum>req_sum \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        req_sum=target;\\n        vector<int> v;\\n        l=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        helper(candidates,0,0,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737513,
                "title": "c-easy-solution-easytounderstand",
                "content": "```\\n/*\\nRuntime: 12 ms, faster than 66.49% of C++ online submissions for Combination Sum II.\\nMemory Usage: 10.7 MB, less than 80.44% of C++ online submissions for Combination Sum II.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> combination;\\n    vector<vector<int>> finalAnswer;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        if(candidates.size()==0){return finalAnswer;}\\n        sort(candidates.begin(),candidates.end()); //[1,1,2,5,6,7,10] target = 8\\n        int currentIndex = 0;\\n        CheckForSum(candidates, target, currentIndex);\\n        return finalAnswer;\\n    }\\n\\n    void CheckForSum(vector<int>& candidates, int target, int idx){\\n        if(target==0){\\n            if(isPresentIn2dArray(finalAnswer,combination)==true){\\n                return;\\n            }else{\\n                finalAnswer.push_back(combination);\\n            return;\\n            }\\n\\n\\n        }\\n        for(int i = idx; i<candidates.size();i++){\\n            if(target<candidates[i]) break;\\n            combination.push_back(candidates[i]);\\n            CheckForSum(candidates,target-candidates[i], i+1);\\n            combination.pop_back();\\n        } \\n    }\\n\\n    bool isPresentIn2dArray( vector<vector<int>>& finalAnswer, vector<int>& combination ){\\n        bool isPresent = find(finalAnswer.begin(), finalAnswer.end(), combination) != finalAnswer.end();\\n        return isPresent;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\nRuntime: 12 ms, faster than 66.49% of C++ online submissions for Combination Sum II.\\nMemory Usage: 10.7 MB, less than 80.44% of C++ online submissions for Combination Sum II.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> combination;\\n    vector<vector<int>> finalAnswer;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        if(candidates.size()==0){return finalAnswer;}\\n        sort(candidates.begin(),candidates.end()); //[1,1,2,5,6,7,10] target = 8\\n        int currentIndex = 0;\\n        CheckForSum(candidates, target, currentIndex);\\n        return finalAnswer;\\n    }\\n\\n    void CheckForSum(vector<int>& candidates, int target, int idx){\\n        if(target==0){\\n            if(isPresentIn2dArray(finalAnswer,combination)==true){\\n                return;\\n            }else{\\n                finalAnswer.push_back(combination);\\n            return;\\n            }\\n\\n\\n        }\\n        for(int i = idx; i<candidates.size();i++){\\n            if(target<candidates[i]) break;\\n            combination.push_back(candidates[i]);\\n            CheckForSum(candidates,target-candidates[i], i+1);\\n            combination.pop_back();\\n        } \\n    }\\n\\n    bool isPresentIn2dArray( vector<vector<int>>& finalAnswer, vector<int>& combination ){\\n        bool isPresent = find(finalAnswer.begin(), finalAnswer.end(), combination) != finalAnswer.end();\\n        return isPresent;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632658,
                "title": "java-2-ms-faster-than-98-12-recursive-backtrack",
                "content": "same as [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/632645/Java-2-ms-faster-than-99.46) and [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/632691/Java-0-ms-faster-than-100.00-RecursiveandBacktrack).\\n```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<>();\\n    if (candidates.length == 0 || candidates[0] > target) {\\n        return res;\\n    }\\n    res = recursive(candidates, target, 0);\\n    return res;\\n}\\n\\npublic List<List<Integer>> recursive(int[] arr, int target, int start) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    if (start >= arr.length || arr[start] > target) {\\n        return res;\\n    }\\n    if (target == arr[start]) {\\n        List<Integer> t = new ArrayList<>();\\n        t.add(arr[start]);\\n        res.add(t);\\n        return res;\\n    }\\n\\n    for (int j = start; j < arr.length; j++) {\\n        if (target == arr[j]) {\\n            List<Integer> t = new ArrayList<>();\\n            t.add(arr[j]);\\n            res.add(t);\\n            break;\\n        }\\n        List<List<Integer>> temp = recursive(arr, target - arr[j], j + 1);\\n        if (!temp.isEmpty()) {\\n            for (List<Integer> t : temp) {\\n                t.add(0, arr[j]);\\n                res.add(t);\\n            }\\n            //remove the same res\\n            while(j + 1 < arr.length && arr[j] == arr[j + 1]){\\n                j++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<>();\\n    if (candidates.length == 0 || candidates[0] > target) {\\n        return res;\\n    }\\n    res = recursive(candidates, target, 0);\\n    return res;\\n}\\n\\npublic List<List<Integer>> recursive(int[] arr, int target, int start) {\\n    List<List<Integer>> res = new ArrayList<>();\\n\\n    if (start >= arr.length || arr[start] > target) {\\n        return res;\\n    }\\n    if (target == arr[start]) {\\n        List<Integer> t = new ArrayList<>();\\n        t.add(arr[start]);\\n        res.add(t);\\n        return res;\\n    }\\n\\n    for (int j = start; j < arr.length; j++) {\\n        if (target == arr[j]) {\\n            List<Integer> t = new ArrayList<>();\\n            t.add(arr[j]);\\n            res.add(t);\\n            break;\\n        }\\n        List<List<Integer>> temp = recursive(arr, target - arr[j], j + 1);\\n        if (!temp.isEmpty()) {\\n            for (List<Integer> t : temp) {\\n                t.add(0, arr[j]);\\n                res.add(t);\\n            }\\n            //remove the same res\\n            while(j + 1 < arr.length && arr[j] == arr[j + 1]){\\n                j++;\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 631916,
                "title": "c-easy-solution-pattern-in-combination-sum-1-2-and-3",
                "content": "Try to think of it as a graph with `n` nodes and `O(n^2)` edges. Then, all we need to do is do dfs and see what branches are satisfying the condition that question is asking for. \\nIf you are facing problem in following the dfs approach (_recursion fear_), try creating a graph for the the `candidates` array and write a bfs to find the sum. Once you get the hang of how the branches of graph are playing out, try writing the recursive dfs for it.\\n\\n**Combination Sum 1:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\\n\\n\\n**Combination Sum 2:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n        \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\\n\\n**Combination Sum 3:**\\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState, int k) {\\n        if (t==0) {if (currentState.size() ==k) finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState, k);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int> > res;\\n        vector<int> candidates;\\n        for (int i = 1; i <= 9; i++) candidates.push_back(i);\\n        vector<int> temp;\\n        recurse(n, candidates, 0, temp, res, k);\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState) {\\n        if (t==0) {finalState.push_back(currentState); return;}\\n        \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int> > res;\\n        sort(candidates.begin(), candidates.end());\\n        vector<int> temp;\\n        recurse(target, candidates, 0, temp, res);\\n        return res;\\n    }\\n```\n```\\nvoid recurse(int t, vector<int>& nums, int idx, vector<int> &currentState, vector<vector<int> > &finalState, int k) {\\n        if (t==0) {if (currentState.size() ==k) finalState.push_back(currentState); return;}\\n    \\n        for (int i = idx; i < nums.size(); i++) {\\n            if (i and nums[i] == nums[i-1] and i > idx) continue;\\n            if (t-nums[i] >= 0) {\\n                currentState.push_back(nums[i]);\\n                recurse(t-nums[i], nums, i+1, currentState, finalState, k);\\n                currentState.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int> > res;\\n        vector<int> candidates;\\n        for (int i = 1; i <= 9; i++) candidates.push_back(i);\\n        vector<int> temp;\\n        recurse(n, candidates, 0, temp, res, k);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615729,
                "title": "java-dfs-solution-beat-98-with-clear-explanations",
                "content": "We illustrate the depth first search (DFS) method to enumerate all possible combinations that satisfy the sum requirement using the example:\\ncandidates =\\xA0[2,5,2,1,2], target =\\xA05\\n1. We first sort the array and it becomes candidates =\\xA0[1, 2, 2, 2, 5]. This is needed because one can easily get rid of redundant answers while searching.\\n2.   Generate the search tree by adding one element at a time to the current list (in the order dictated by the order of the array candidates). Also, to avoid duplicates, each distinct number is allowed to be used only once for each level. In our example, this means the left graph is correct, not the right one.\\n<img src=\"https://assets.leetcode.com/users/jzhao0105/image_1589212751.png\" width=\"600\"/>\\n3. To implement the DFS recursive solution,  we need to traverse all nodes of the tree above and check if the sum of the elements in the list is equal to target. Once a solution is found (e.g. curList = [1, 2, 2]), we (deep) copy it and add it to the answer list. Also, we backtrack (i.e. remove the last element from curList [1, 2, 2] -> [1, 2] so that in the next step of recursion [1, 2, 5] will be considered too.)\\n4. Time complexity: O(S*N), where S = the number of answers (= length of ans array = 2 in our example) and N = the (average) time that is needed to construct each answer. (e.g. time to traverse the tree and find the list [1, 2, 2]).\\t\\n\\t\\n\\t\\n\\t\\t// Key observation: To eliminate all possible duplicate answers, we only need to\\n\\t\\t// remove all the duplicate candidates at the same level of the search tree\\n\\n\\t\\tclass Solution {\\n\\t\\t\\tpublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\t\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\n\\t\\t\\t\\tArrays.sort(candidates);\\n\\t\\t\\t\\tdfs(candidates, target, 0, new ArrayList<Integer>(), ans);\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate void dfs(int[] candidates, int target, int index, \\n\\t\\t\\t\\t\\t\\t\\t List<Integer> curList, List<List<Integer>> ans) {\\n\\t\\t\\t\\tif (target == 0) {\\n\\t\\t\\t\\t\\t// Deep copy curList to ans\\n\\t\\t\\t\\t\\tans.add(new ArrayList<Integer>(curList));\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor (int i = index; i < candidates.length; i++) {\\n\\t\\t\\t\\t\\tif (candidates[i] > target) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Remove duplicate candidates at the same level of the tree\\n\\t\\t\\t\\t\\tif (i > index && candidates[i] == candidates[i - 1]) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurList.add(candidates[i]);\\n\\t\\t\\t\\t\\tdfs(candidates, target - candidates[i], i + 1, curList, ans);\\n\\t\\t\\t\\t\\tcurList.remove(curList.size() - 1); // Backtrack\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t\\tpublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n\\t\\t\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\n\\t\\t\\t\\tArrays.sort(candidates);\\n\\t\\t\\t\\tdfs(candidates, target, 0, new ArrayList<Integer>(), ans);\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 543026,
                "title": "go-backtrack",
                "content": "```\\nvar res [][]int\\nvar candis []int\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n\\tres = nil\\n\\tcandis = candidates\\n\\n\\tsort.Ints(candidates)\\n\\tbacktrack(target, nil, 0)\\n\\treturn res\\n}\\n\\nfunc backtrack(target int, cur []int, index int) {\\n\\tif target == 0 {\\n\\t\\tres = append(res, append([]int{}, cur...))\\n\\t\\treturn\\n\\t}\\n\\n\\tif target < 0 {\\n\\t\\treturn\\n\\t}\\n\\n    for i := index; i < len(candis); i++ {\\n        if i > index && candis[i] == candis[i-1] {\\n            continue \\n        }\\n\\t\\tbacktrack(target-candis[i], append(cur, candis[i]), i+1)\\n\\t}\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar res [][]int\\nvar candis []int\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n\\tres = nil\\n\\tcandis = candidates\\n\\n\\tsort.Ints(candidates)\\n\\tbacktrack(target, nil, 0)\\n\\treturn res\\n}\\n\\nfunc backtrack(target int, cur []int, index int) {\\n\\tif target == 0 {\\n\\t\\tres = append(res, append([]int{}, cur...))\\n\\t\\treturn\\n\\t}\\n\\n\\tif target < 0 {\\n\\t\\treturn\\n\\t}\\n\\n    for i := index; i < len(candis); i++ {\\n        if i > index && candis[i] == candis[i-1] {\\n            continue \\n        }\\n\\t\\tbacktrack(target-candis[i], append(cur, candis[i]), i+1)\\n\\t}\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511148,
                "title": "javascript-es6-without-push-pop",
                "content": "```\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    let results = [];\\n    candidates.sort((a,b) => a-b);\\n    \\n    const helper = (start, target, combinations=[]) => {\\n        if(target === 0){\\n            results.push([...combinations]);\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length && target-candidates[i] >= 0; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n\\n            helper(i+1, target-candidates[i], [...combinations, candidates[i]]);\\n        }\\n    }\\n    \\n    helper(0, target)\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar combinationSum2 = function(candidates, target) {\\n    \\n    let results = [];\\n    candidates.sort((a,b) => a-b);\\n    \\n    const helper = (start, target, combinations=[]) => {\\n        if(target === 0){\\n            results.push([...combinations]);\\n            return;\\n        }\\n        \\n        for(let i = start; i < candidates.length && target-candidates[i] >= 0; i++){\\n            if(i > start && candidates[i] === candidates[i - 1]) continue;\\n\\n            helper(i+1, target-candidates[i], [...combinations, candidates[i]]);\\n        }\\n    }\\n    \\n    helper(0, target)\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 481687,
                "title": "python3-backtracking-dp",
                "content": "**Approach 1 -- backtracking**\\nKeep track of a list of existing numbers and residual. When residual drops to 0, add list to answer. Similar to this [thread](https://leetcode.com/problems/combination-sum/discuss/481569/Python3-use-a-stack-to-traverse-the-solution-space-through-backtracking). \\n\\nImplementation :\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        \\n        def fn(i, val): \\n            \"\"\"Populate ans via stack.\"\"\"\\n            if val == 0: ans.append(stack.copy())\\n            elif val > 0: \\n                for ii in range(i, len(candidates)): \\n                    if i == ii or candidates[ii-1] != candidates[ii]: \\n                        stack.append(candidates[ii])\\n                        fn(ii+1, val - candidates[ii])\\n                        stack.pop()\\n            \\n        ans, stack = [], []\\n        fn(0, target)\\n        return ans\\n```\\nAnalysis:\\nTime complexity `O(2^N)`\\nSpace complexity `O(2^N)`\\n\\n**Approach 2 -- dp**\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target+1)]\\n        dp[0].add(())\\n        for x in candidates: \\n            for i in reversed(range(target)): \\n                if x + i <= target: \\n                    for seq in dp[i]: \\n                        dp[i+x].add(seq + (x,))\\n        return dp[-1]\\n```\\n\\nComment: \\nNote the similarity to that of [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/481569/Python3-A-concise-implementation-of-backtracking-algo).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        \\n        def fn(i, val): \\n            \"\"\"Populate ans via stack.\"\"\"\\n            if val == 0: ans.append(stack.copy())\\n            elif val > 0: \\n                for ii in range(i, len(candidates)): \\n                    if i == ii or candidates[ii-1] != candidates[ii]: \\n                        stack.append(candidates[ii])\\n                        fn(ii+1, val - candidates[ii])\\n                        stack.pop()\\n            \\n        ans, stack = [], []\\n        fn(0, target)\\n        return ans\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target+1)]\\n        dp[0].add(())\\n        for x in candidates: \\n            for i in reversed(range(target)): \\n                if x + i <= target: \\n                    for seq in dp[i]: \\n                        dp[i+x].add(seq + (x,))\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415202,
                "title": "java-2ms-99-99-faster-100-less-memory",
                "content": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\\n    helper(candidates, target, 0, res, new ArrayList<Integer>());\\n    return res;\\n}\\n    \\nprivate void helper(int[] candidates, int target, int startId, List<List<Integer>> res, List<Integer> curRes) {\\n\\tif (target == 0) {\\n        res.add(new ArrayList<Integer>(curRes));\\n    } else {\\n        for (int i = startId; i < candidates.length && candidates[i] <= target; i++) {\\n            if (i > startId && candidates[i] == candidates[i - 1]) { // to avoid duplicates skip all equal numbers except the first\\n                continue;\\n            }\\n            curRes.add(candidates[i]);\\n            helper(candidates, target - candidates[i], i + 1, res, curRes);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    Arrays.sort(candidates);\\n    List<List<Integer>> res = new ArrayList<List<Integer>>();\\n    helper(candidates, target, 0, res, new ArrayList<Integer>());\\n    return res;\\n}\\n    \\nprivate void helper(int[] candidates, int target, int startId, List<List<Integer>> res, List<Integer> curRes) {\\n\\tif (target == 0) {\\n        res.add(new ArrayList<Integer>(curRes));\\n    } else {\\n        for (int i = startId; i < candidates.length && candidates[i] <= target; i++) {\\n            if (i > startId && candidates[i] == candidates[i - 1]) { // to avoid duplicates skip all equal numbers except the first\\n                continue;\\n            }\\n            curRes.add(candidates[i]);\\n            helper(candidates, target - candidates[i], i + 1, res, curRes);\\n            curRes.remove(curRes.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350011,
                "title": "python-generator-solution",
                "content": "```python\\nclass Solution:\\n    def backtrack(self, candidates, remaining, idx=0, got=[]):\\n        if remaining < 0:\\n            return\\n        \\n        if idx == len(candidates):\\n            if remaining == 0:\\n                yield tuple(got)\\n            return\\n\\n        got.append(candidates[idx])\\n        yield from self.backtrack(candidates, remaining - got[-1], idx + 1)\\n        got.pop()\\n        yield from self.backtrack(candidates, remaining, idx + 1)\\n            \\n        \\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        return set(self.backtrack(candidates, target))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def backtrack(self, candidates, remaining, idx=0, got=[]):\\n        if remaining < 0:\\n            return\\n        \\n        if idx == len(candidates):\\n            if remaining == 0:\\n                yield tuple(got)\\n            return\\n\\n        got.append(candidates[idx])\\n        yield from self.backtrack(candidates, remaining - got[-1], idx + 1)\\n        got.pop()\\n        yield from self.backtrack(candidates, remaining, idx + 1)\\n            \\n        \\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        return set(self.backtrack(candidates, target))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338279,
                "title": "java-backtracking-without-for-loop-bounded-knapsack-pattern",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n         List<List<Integer>> result = new ArrayList<>(); \\n        combinationSumHelper(candidates, target, 0, result, new LinkedList<>());\\n        return result;\\n    }\\n    \\n        public void combinationSumHelper(int[] candidates, int target, int index, List<List<Integer>> result, LinkedList<Integer> temp){\\n       //if you have met the target the add result from temp     \\n       if( target == 0){\\n           result.add(new ArrayList<>(temp));\\n           return;\\n       } \\n        \\n       //coundlnt find the target and exit     \\n       if(index >= candidates.length){\\n           return;\\n       }  \\n        \\n        //case 1: you include the number. for bounded knapsack u can include only once.\\n            //hence increment the index\\n       if(candidates[index] <= target){\\n           temp.add(candidates[index]);\\n           combinationSumHelper(candidates, target-candidates[index], index+1, result, temp);\\n           temp.removeLast();\\n       }  \\n        \\n       //skip duplicate starting points     \\n       while(index+1 < candidates.length && candidates[index]==candidates[index+1]) {\\n           index++;     \\n       }\\n\\n    //case 2: you  dont include the number. same for bounded and unbounded knapsack\\n       combinationSumHelper(candidates,target, index+1, result,temp ); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n         List<List<Integer>> result = new ArrayList<>(); \\n        combinationSumHelper(candidates, target, 0, result, new LinkedList<>());\\n        return result;\\n    }\\n    \\n        public void combinationSumHelper(int[] candidates, int target, int index, List<List<Integer>> result, LinkedList<Integer> temp){\\n       //if you have met the target the add result from temp     \\n       if( target == 0){\\n           result.add(new ArrayList<>(temp));\\n           return;\\n       } \\n        \\n       //coundlnt find the target and exit     \\n       if(index >= candidates.length){\\n           return;\\n       }  \\n        \\n        //case 1: you include the number. for bounded knapsack u can include only once.\\n            //hence increment the index\\n       if(candidates[index] <= target){\\n           temp.add(candidates[index]);\\n           combinationSumHelper(candidates, target-candidates[index], index+1, result, temp);\\n           temp.removeLast();\\n       }  \\n        \\n       //skip duplicate starting points     \\n       while(index+1 < candidates.length && candidates[index]==candidates[index+1]) {\\n           index++;     \\n       }\\n\\n    //case 2: you  dont include the number. same for bounded and unbounded knapsack\\n       combinationSumHelper(candidates,target, index+1, result,temp ); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310039,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 302616,
                "title": "swift-70-beat-intuitive-solution-using-modified-dfs-smarty-logix",
                "content": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        \\n        var candidates = candidates.sorted()\\n        var res = [[Int]]()\\n        var temp = [Int]()\\n        \\n        helper(&res, &temp, candidates, 0, target)\\n        \\n        return res\\n    }\\n    \\n    func helper(_ res: inout [[Int]], _ temp: inout [Int], _ candidates: [Int], _ index: Int, _ target: Int) {\\n        \\n        if target == 0 { res.append(temp); return }\\n        if target < 0 { return }\\n        \\n        for i in index..<candidates.count {\\n            \\n            //Avoid dupes.\\n            if i > index && candidates[i] == candidates[i - 1] { \\n                continue\\n            }\\n            temp.append(candidates[i])\\n            helper(&res, &temp, candidates, i + 1, target - candidates[i])\\n            temp.removeLast()\\n        }\\n    }\\n}\\n```\\n\\nThe trick is to skip the dupes in such a way where you will still get the first \"run\" of the dupes...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func combinationSum2(_ candidates: [Int], _ target: Int) -> [[Int]] {\\n        \\n        var candidates = candidates.sorted()\\n        var res = [[Int]]()\\n        var temp = [Int]()\\n        \\n        helper(&res, &temp, candidates, 0, target)\\n        \\n        return res\\n    }\\n    \\n    func helper(_ res: inout [[Int]], _ temp: inout [Int], _ candidates: [Int], _ index: Int, _ target: Int) {\\n        \\n        if target == 0 { res.append(temp); return }\\n        if target < 0 { return }\\n        \\n        for i in index..<candidates.count {\\n            \\n            //Avoid dupes.\\n            if i > index && candidates[i] == candidates[i - 1] { \\n                continue\\n            }\\n            temp.append(candidates[i])\\n            helper(&res, &temp, candidates, i + 1, target - candidates[i])\\n            temp.removeLast()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302609,
                "title": "c-95-beat-modified-dfs-requires-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        \\n        vector<vector<int>> aResult;\\n        vector<int> aTemp;\\n        \\n        helper(aResult, aTemp, candidates, 0, target);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<int>> &pRes, vector<int> &pTemp, vector<int> &pCandidates, int pIndex, int pTarget) {\\n        \\n        if (pTarget < 0) { return; }\\n        if (pTarget == 0) {\\n            pRes.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int i=pIndex;i<pCandidates.size();i++) {\\n            \\n            if (i > pIndex && pCandidates[i - 1] == pCandidates[i]) { continue; }\\n            \\n            pTemp.push_back(pCandidates[i]);\\n            helper(pRes, pTemp, pCandidates, i + 1, pTarget - pCandidates[i]);\\n            pTemp.pop_back();\\n        }\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(), candidates.end());\\n        \\n        vector<vector<int>> aResult;\\n        vector<int> aTemp;\\n        \\n        helper(aResult, aTemp, candidates, 0, target);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<int>> &pRes, vector<int> &pTemp, vector<int> &pCandidates, int pIndex, int pTarget) {\\n        \\n        if (pTarget < 0) { return; }\\n        if (pTarget == 0) {\\n            pRes.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int i=pIndex;i<pCandidates.size();i++) {\\n            \\n            if (i > pIndex && pCandidates[i - 1] == pCandidates[i]) { continue; }\\n            \\n            pTemp.push_back(pCandidates[i]);\\n            helper(pRes, pTemp, pCandidates, i + 1, pTarget - pCandidates[i]);\\n            pTemp.pop_back();\\n        }\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 170901,
                "title": "python-solution",
                "content": "Recursion:\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            return res\\n        \\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```\\nRecursion with memoization:\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            elif (j, target) in dic:\\n                return dic[(j, target)]\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            dic[(j,target)] = res\\n            return res\\n        \\n        dic = {}\\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            return res\\n        \\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(j, target):\\n            if target <= 0 or not candidates or j < 0:\\n                return []\\n            elif (j, target) in dic:\\n                return dic[(j, target)]\\n            res = []\\n            for i in range(j,-1,-1):\\n                if candidates[i] > target:\\n                    continue\\n                elif i <= j-1 and candidates[i] == candidates[i+1]: # avoid duplicates\\n                    continue\\n                elif candidates[i] == target:\\n                    res.append([candidates[i]])\\n                else:\\n                    tmp = helper(i-1, target - candidates[i])\\n                    res += [lst+[candidates[i]] for lst in tmp]\\n            dic[(j,target)] = res\\n            return res\\n        \\n        dic = {}\\n        candidates = sorted(candidates)\\n        res = helper(len(candidates)-1, target)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16863,
                "title": "java-18-lines-solution",
                "content": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtracing(res, new ArrayList<>(), candidates, target, 0);\\n        return res;\\n    }\\n    private void backtracing(List<List<Integer>> res, List<Integer> tempList, int[] candidates, int target, int pos) {\\n        if (target == 0) res.add(new ArrayList<Integer>(tempList)); \\n        else if (target < 0) return;\\n        else {\\n            for (int i = pos; i < candidates.length; i++) {\\n                if (i > pos && candidates[i] == candidates[i - 1]) continue;\\n                tempList.add(candidates[i]);\\n                backtracing(res, tempList, candidates, target - candidates[i], i + 1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtracing(res, new ArrayList<>(), candidates, target, 0);\\n        return res;\\n    }\\n    private void backtracing(List<List<Integer>> res, List<Integer> tempList, int[] candidates, int target, int pos) {\\n        if (target == 0) res.add(new ArrayList<Integer>(tempList)); \\n        else if (target < 0) return;\\n        else {\\n            for (int i = pos; i < candidates.length; i++) {\\n                if (i > pos && candidates[i] == candidates[i - 1]) continue;\\n                tempList.add(candidates[i]);\\n                backtracing(res, tempList, candidates, target - candidates[i], i + 1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16893,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Combination Sum II** https://leetcode.com/problems/combination-sum-ii/\\n\\n**Algorithm**\\n* Recursion tree will help you solve this problem. https://goo.gl/photos/vEDezZoWctf7CgfM8\\n* Combination Sum I allowed duplicates. To avoid those, in the recursive call, use i + 1.\\n* Now other duplicates are also possible. Imagine [1,2,5, 7, 1] and target as 8. If we use DFS we will get [1,7] and then [7,1]. How do we avoid this?\\n* Sort candidates: [1,1,2,5,7]. Now when you start with index 0, your first element will be 1. It will allow you to pick the second element as 1 too. You will be able to pick [1,7]. But during recursion, when you reach the next start index as 1, your recursion tree will again start from 1. This will lead to a duplicate [1,7]. You want to avoid this.\\n\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result = []\\n        candidates.sort()\\n        self.helper(0, candidates, target, [], result, 0)\\n        return result\\n\\n    def helper(self, idx, candidates, target, so_far, result, sum_so_far):\\n        if sum_so_far == target:\\n            result.append([x for x in so_far])\\n        else:\\n            for i in range(idx, len(candidates)):\\n                if i == idx or candidates[i] != candidates[i-1]:\\n                    if sum_so_far + candidates[i] <= target:\\n                        so_far.append(candidates[i])\\n                        self.helper(i+1, candidates, target, so_far, result, sum_so_far + candidates[i])\\n                        so_far.pop()\\n        return\\n```\\n\\n**Another Implementation**\\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        all_solns = []\\n        self.helper([], 0, sorted(candidates), target, all_solns)        \\n        return all_solns\\n\\n    def helper(self, so_far, k, nums, target, all_solns):        \\n        sum_so_far = sum(so_far)\\n        if sum_so_far == target:\\n            all_solns.append([x for x in so_far])\\n        else:\\n            for i in range(k, len(nums)):\\n                if i > k and nums[i] == nums[i-1]:\\n                    continue\\n                if (sum_so_far + nums[i] <= target):\\n                    so_far.append(nums[i])\\n                    self.helper(so_far, i+1, nums, target, all_solns)\\n                    so_far.pop()\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        result = []\\n        candidates.sort()\\n        self.helper(0, candidates, target, [], result, 0)\\n        return result\\n\\n    def helper(self, idx, candidates, target, so_far, result, sum_so_far):\\n        if sum_so_far == target:\\n            result.append([x for x in so_far])\\n        else:\\n            for i in range(idx, len(candidates)):\\n                if i == idx or candidates[i] != candidates[i-1]:\\n                    if sum_so_far + candidates[i] <= target:\\n                        so_far.append(candidates[i])\\n                        self.helper(i+1, candidates, target, so_far, result, sum_so_far + candidates[i])\\n                        so_far.pop()\\n        return\\n```\n```\\nclass Solution(object):\\n    def combinationSum2(self, candidates, target):\\n        \"\"\"\\n        :type candidates: List[int]\\n        :type target: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        all_solns = []\\n        self.helper([], 0, sorted(candidates), target, all_solns)        \\n        return all_solns\\n\\n    def helper(self, so_far, k, nums, target, all_solns):        \\n        sum_so_far = sum(so_far)\\n        if sum_so_far == target:\\n            all_solns.append([x for x in so_far])\\n        else:\\n            for i in range(k, len(nums)):\\n                if i > k and nums[i] == nums[i-1]:\\n                    continue\\n                if (sum_so_far + nums[i] <= target):\\n                    so_far.append(nums[i])\\n                    self.helper(so_far, i+1, nums, target, all_solns)\\n                    so_far.pop()\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16976,
                "title": "19-lines-concise-and-easy-understand-c-solution-backtracking",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, candidates, tmp, 0, target);\\n            return res;\\n        }\\n        void backtracking(vector<vector<int>>& res, vector<int>& candidates, vector<int> tmp, int index, int target){\\n            if(target < 0 )return;\\n            if(target == 0){\\n                res.push_back(tmp);\\n                return;\\n            }\\n            for(int i = index; i < candidates.size(); i++){\\n                if(i == index || candidates[i] != candidates[i - 1]){\\n                    tmp.push_back(candidates[i]);\\n                    backtracking(res, candidates, tmp, i + 1, target - candidates[i]);\\n                    tmp.pop_back();\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n            sort(candidates.begin(), candidates.end());\\n            vector<vector<int>> res;\\n            vector<int> tmp;\\n            backtracking(res, candidates, tmp, 0, target);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17060,
                "title": "my-thoughts-and-solution-to-the-problem-java",
                "content": "Hello, I've solve the problem and I am here to give back to the community. Basically the question is pretty straight forward. I've approached the problem with sorting the array first, and keeping the current value and make recursive call to check for target - current value. Any suggestion on how I can make this code better is much appreciated. Thank you.\\n\\n    public class Solution {\\n        public List<List<Integer>> combinationSum2(int[] num, int target) {\\n            if(num.length==0) return new ArrayList<List<Integer>>();\\n            Arrays.sort(num); //sort the array of num so it's easier to manage\\n            List<List<Integer>> result = helper(num,target,0);\\n            if(result==null) return new ArrayList<List<Integer>>();\\n            return result;\\n        }\\n        public List<List<Integer>> helper(int[] num, int target, int index)\\n        {\\n            if(index>=num.length||num[index]>target) return null; //return null if you hit the end\\n            ArrayList<List<Integer>> result = new ArrayList<List<Integer>>();\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            Set<List<Integer>> s = new HashSet<List<Integer>>(); //check if there is no duplicates\\n            for(int i = index;i<num.length;i++)\\n            {\\n                 //if num[i]> target you dont need to check the rest. \\n                 //but it's break here because you still want to keep the rest of the result.\\n                if(num[i]>target) break; \\n                temp = new ArrayList<Integer>();\\n                //if it's found the rest of the numbers can be trimed, save some time on complexity\\n                if(num[i]==target) \\n                {\\n                    temp.add(num[i]);\\n                    result.add(temp);\\n                    return result;\\n                }\\n                ArrayList<List<Integer>> t = (ArrayList)helper(num,target-num[i],i+1);\\n                //t is the temporary ArrayList of the result of your recursion call\\n                // you want to add the value of your current num[i] in the beginning of each\\n                // returned List<Integer> and add it to result if it's not duplicated.\\n                if(t!=null)\\n                {\\n                    for(List<Integer> a:t)\\n                    {\\n                        a.add(0,num[i]);\\n                        if(!s.contains(a)) //make sure there is no duplicates\\n                        {\\n                            s.add(a);\\n                            result.add(a);\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> combinationSum2(int[] num, int target) {\\n            if(num.length==0) return new ArrayList<List<Integer>>();\\n            Arrays.sort(num); //sort the array of num so it's easier to manage\\n            List<List<Integer>> result = helper(num,target,0);\\n            if(result==null) return new ArrayList<List<Integer>>();\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4029177,
                "title": "java-easy-100-backtracking-solution",
                "content": "```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        Arrays.sort(candidates);\\n\\n        this.backTrack(candidates, target, 0, new ArrayList<>(), result);\\n\\n        return result;\\n    }\\n\\n    private void backTrack(int[] candidates, int target, int start, List<Integer> curr, List<List<Integer>> result) {\\n        if(target == 0) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n\\n        for(int i = start; i < candidates.length; ++i) {\\n            if(i > start && candidates[i] == candidates[i - 1])\\n                continue;\\n\\n            if(candidates[i] > target)\\n                break;\\n\\n            curr.add(candidates[i]);\\n            backTrack(candidates, target - candidates[i], i + 1, curr, result);\\n            curr.remove(curr.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        Arrays.sort(candidates);\\n\\n        this.backTrack(candidates, target, 0, new ArrayList<>(), result);\\n\\n        return result;\\n    }\\n\\n    private void backTrack(int[] candidates, int target, int start, List<Integer> curr, List<List<Integer>> result) {\\n        if(target == 0) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n\\n        for(int i = start; i < candidates.length; ++i) {\\n            if(i > start && candidates[i] == candidates[i - 1])\\n                continue;\\n\\n            if(candidates[i] > target)\\n                break;\\n\\n            curr.add(candidates[i]);\\n            backTrack(candidates, target - candidates[i], i + 1, curr, result);\\n            curr.remove(curr.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998318,
                "title": "c-recursion-backtracking-two-approaches",
                "content": "# Approach 1: Extended Solution to [Combination Sum 1 ](https://leetcode.com/problems/combination-sum/discuss/3994292/C%2B%2B-or-Cpp-or-Cpp-Solution-or-Recursion-%2B-Backtracking) but will give TLE\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int i, int target, vector<int> &comb, set<vector<int>> &result)\\n    { \\n        if(i>=nums.size())\\n        {\\n            if(target==0)\\n            {\\n                result.insert(comb);\\n            }\\n            return;\\n        }\\n\\n        comb.push_back(nums[i]); \\n        helper(nums,i+1,target-nums[i],comb,result); //pick up an element\\n        comb.pop_back();\\n\\t\\t\\n        helper(nums,i+1,target,comb,result); //non pick up an element\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        set<vector<int>> temp;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,temp);\\n        for(auto x:temp)\\n        {\\n            result.push_back(x);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n\\n# Approach 2: Most Optimized Solution \\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int indx, int target,  vector<int> &comb, vector<vector<int>> &result)\\n    {\\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        for(int i=indx;i<nums.size();i++)\\n        {\\n            if(i>indx && nums[i]==nums[i-1])\\n                continue;\\n            \\n            if(nums[i]>target)\\n                break;\\n            \\n            comb.push_back(nums[i]);\\n            helper(nums,i+1,target-nums[i],comb,result);\\n            comb.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,result);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int i, int target, vector<int> &comb, set<vector<int>> &result)\\n    { \\n        if(i>=nums.size())\\n        {\\n            if(target==0)\\n            {\\n                result.insert(comb);\\n            }\\n            return;\\n        }\\n\\n        comb.push_back(nums[i]); \\n        helper(nums,i+1,target-nums[i],comb,result); //pick up an element\\n        comb.pop_back();\\n\\t\\t\\n        helper(nums,i+1,target,comb,result); //non pick up an element\\n    }\\n\\t\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        set<vector<int>> temp;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,temp);\\n        for(auto x:temp)\\n        {\\n            result.push_back(x);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<int>& nums,int indx, int target,  vector<int> &comb, vector<vector<int>> &result)\\n    {\\n        if(target==0)\\n        {\\n            result.push_back(comb);\\n            return;\\n        }\\n        for(int i=indx;i<nums.size();i++)\\n        {\\n            if(i>indx && nums[i]==nums[i-1])\\n                continue;\\n            \\n            if(nums[i]>target)\\n                break;\\n            \\n            comb.push_back(nums[i]);\\n            helper(nums,i+1,target-nums[i],comb,result);\\n            comb.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<int> comb;\\n        vector<vector<int>> result;\\n        helper(candidates,0,target,comb,result);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966330,
                "title": "cpp-solution-easy-to-understand",
                "content": "# Intuition\\nThe problem requires finding all unique combinations of numbers from the \\'candidates\\' array that sum up to the \\'target\\' value. However, each number in the \\'candidates\\' array can only be used once in each combination. To solve this efficiently and avoid duplicates, we can use a depth-first search (DFS) algorithm. We will also sort the \\'candidates\\' array to group identical elements together.\\n\\n# Approach\\n1. Initialize an empty vector of vectors \\'res\\' to store the combinations.\\n2. Initialize an empty vector \\'curr\\' to store the current combination being constructed.\\n3. Sort the \\'candidates\\' vector to group identical elements together.\\n4. Call the DFS function \\'dfs\\' with the following parameters: \\'candidates\\', \\'0\\' as the starting index, \\'target\\', \\'0\\' as the initial sum, \\'curr\\', and \\'res\\'.\\n5. In the \\'dfs\\' function:\\n   a. Check if \\'sum\\' is equal to \\'target\\'. If they are equal, it means the current combination in \\'curr\\' is a valid combination that sums up to the \\'target\\'. Therefore, add \\'curr\\' to \\'res\\'.\\n   b. Check if \\'sum\\' is greater than \\'target\\'. If it is, return to avoid further exploration of this branch.\\n   c. Start a loop from the \\'start\\' index to the end of the \\'candidates\\' vector.\\n   d. Inside the loop:\\n      i. Check if \\'i\\' is greater than \\'start\\' and if the current element \\'candidates[i]\\' is the same as the previous element \\'candidates[i-1]\\'. If both conditions are true, skip the current iteration to avoid duplicate combinations.\\n      ii. Add the current element \\'candidates[i]\\' to \\'curr\\'.\\n      iii. Recursively call \\'dfs\\' with the updated \\'candidates\\', \\'i+1\\' as the new starting index to avoid reusing the same element, \\'target\\', \\'sum+candidates[i]\\' as the new sum, \\'curr\\', and \\'res\\'.\\n      iv. Remove the last element from \\'curr\\' to backtrack and explore other possibilities.\\n6. After the DFS is complete, \\'res\\' will contain all unique combinations.\\n7. Return \\'res\\' as the final result.\\n\\n# Complexity\\n- Time complexity: O(2^n * n), where \\'n\\' is the number of elements in \\'candidates\\'. In the worst case, there can be 2^n combinations to generate, and for each combination, we perform sorting with a maximum of \\'n\\' elements.\\n- Space complexity: O(2^n * n) for the \\'res\\' vector to store all combinations and O(n) for the \\'curr\\' vector. The overall space complexity is dominated by the \\'res\\' vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>>res;\\n        vector<int> curr;\\n        sort(candidates.begin(),candidates.end());\\n        dfs(candidates,0,target,0,curr,res);\\n        return res;\\n        \\n    }\\n    void dfs(vector<int> candidates, int start,int target,int sum, vector<int> &curr, vector<vector<int>> &res)\\n    {\\n        if(sum==target)\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        if(sum>target){\\n            return;\\n        }\\n        for(int i=start;i<candidates.size();i++)\\n        {\\n            if(i>start && candidates[i]==candidates[i-1])\\n            continue;\\n            curr.push_back(candidates[i]);\\n            dfs(candidates,i+1,target,sum+candidates[i],curr,res);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>>res;\\n        vector<int> curr;\\n        sort(candidates.begin(),candidates.end());\\n        dfs(candidates,0,target,0,curr,res);\\n        return res;\\n        \\n    }\\n    void dfs(vector<int> candidates, int start,int target,int sum, vector<int> &curr, vector<vector<int>> &res)\\n    {\\n        if(sum==target)\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        if(sum>target){\\n            return;\\n        }\\n        for(int i=start;i<candidates.size();i++)\\n        {\\n            if(i>start && candidates[i]==candidates[i-1])\\n            continue;\\n            curr.push_back(candidates[i]);\\n            dfs(candidates,i+1,target,sum+candidates[i],curr,res);\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853451,
                "title": "easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The combinationSum2 method first sorts the candidates array in ascending order. Sorting helps in avoiding duplicates and optimizing the combination generation process.\\n\\n2. It initializes an empty vector ans to store the resulting combinations and an empty vector v to temporarily store a combination during the generation process.\\n\\n3. It calls the combinationSum_helper function with the sorted candidates array, the target value, the empty v vector, ans, and an initial index of 0.\\n\\n4. The combinationSum_helper function is a recursive function that generates combinations. It takes the current index, candidates, the remaining target, the temporary vector v, and the ans vector as parameters.\\n\\n5. In the combinationSum_helper function, the base cases are:\\n\\n   If target becomes 0, it means a valid combination is found. The current v vector is added to the ans vector.\\n   If target becomes negative, it means the current combination is not valid, so it returns.\\n\\n6. The function then iterates through the candidates array, starting from the given index. It avoids duplicates by checking if the current element is the same as the previous element and the current index is greater than the starting index. If this condition is met, the loop continues to the next iteration.\\n\\n7. For each valid candidate, it adds the candidate to the temporary vector v, subtracts the candidate from the remaining target, and makes a recursive call to combinationSum_helper with the updated parameters.\\n\\n8. After the recursive call returns, the last added candidate is removed from the temporary vector v (backtracking).\\n\\n9. The process continues until all combinations are generated.\\n\\n10. The sorted nature of the candidates array helps in avoiding duplicates and optimizing the combination generation process.\\n\\n11. The combinationSum2 method returns the ans vector containing all unique combinations.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void combinationSum_helper(vector<int>&candidates,int target,vector<int>&v,vector<vector<int>>&ans,int index){\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n    if(target<0){\\n        return;\\n    }\\n\\n    for(int i=index;i<candidates.size();i++){\\n        if(i>index && candidates[i]==candidates[i-1]){\\n            continue;\\n        }\\n        v.push_back(candidates[i]);\\n        combinationSum_helper(candidates,target-candidates[i],v,ans,i+1);\\n        v.pop_back();\\n    }\\n\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        combinationSum_helper(candidates,target,v, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combinationSum_helper(vector<int>&candidates,int target,vector<int>&v,vector<vector<int>>&ans,int index){\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n    if(target<0){\\n        return;\\n    }\\n\\n    for(int i=index;i<candidates.size();i++){\\n        if(i>index && candidates[i]==candidates[i-1]){\\n            continue;\\n        }\\n        v.push_back(candidates[i]);\\n        combinationSum_helper(candidates,target-candidates[i],v,ans,i+1);\\n        v.pop_back();\\n    }\\n\\n\\n\\n\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>>ans;\\n        vector<int>v;\\n        combinationSum_helper(candidates,target,v, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851424,
                "title": "c-easy-killer-solution-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> refer combination sum solution and combination and subset for more clearity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans={};\\n        vector<int> v;\\n        comb(0,nums,v,ans,target);\\n        return ans;\\n    }\\n    void comb(int start,vector<int>& nums,vector<int>& v,vector<vector<int>>&ans,int target)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n        for(int i=start;i<nums.size();i++)\\n        {\\n            if(i>start&&nums[i]==nums[i-1])continue;\\n            v.push_back(nums[i]);\\n            comb(i+1,nums,v,ans,target-nums[i]);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& nums, int target) \\n    {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans={};\\n        vector<int> v;\\n        comb(0,nums,v,ans,target);\\n        return ans;\\n    }\\n    void comb(int start,vector<int>& nums,vector<int>& v,vector<vector<int>>&ans,int target)\\n    {\\n        if(target==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        return;\\n        for(int i=start;i<nums.size();i++)\\n        {\\n            if(i>start&&nums[i]==nums[i-1])continue;\\n            v.push_back(nums[i]);\\n            comb(i+1,nums,v,ans,target-nums[i]);\\n            v.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847301,
                "title": "python-99-53-faster-backtracking-easy",
                "content": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def solve(ind,target):\\n            if target==0:\\n                ans.append(op[:])\\n                return \\n            for i in range(ind,len(candidates)):\\n                if i>ind and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                op.append(candidates[i])\\n                solve(i+1,target-candidates[i])\\n                op.pop()\\n        candidates.sort()\\n        ans=[]\\n        op=[]\\n        solve(0,target)\\n        return ans\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def solve(ind,target):\\n            if target==0:\\n                ans.append(op[:])\\n                return \\n            for i in range(ind,len(candidates)):\\n                if i>ind and candidates[i]==candidates[i-1]:\\n                    continue\\n                if candidates[i]>target:\\n                    break\\n                op.append(candidates[i])\\n                solve(i+1,target-candidates[i])\\n                op.pop()\\n        candidates.sort()\\n        ans=[]\\n        op=[]\\n        solve(0,target)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718563,
                "title": "c-super-easy-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void solver(int i, int target, vector<int>& candi, vector<int>& res, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(res);\\n            return;\\n        }\\n        if(i == candi.size()){\\n            return;\\n        }\\n\\n        if(candi[i] <= target){\\n            res.push_back(candi[i]);\\n            solver(i+1,target-candi[i],candi,res,ans);\\n            res.pop_back();\\n        }\\n\\n        while(i+1<candi.size() && candi[i] == candi[i+1]){\\n            i++;\\n        }\\n        // 1,1,1,2,2,3,4,5,6\\n        solver(i+1,target,candi,res,ans);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> res;\\n        solver(0,target,candidates,res,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solver(int i, int target, vector<int>& candi, vector<int>& res, vector<vector<int>>& ans){\\n        if(target == 0){\\n            ans.push_back(res);\\n            return;\\n        }\\n        if(i == candi.size()){\\n            return;\\n        }\\n\\n        if(candi[i] <= target){\\n            res.push_back(candi[i]);\\n            solver(i+1,target-candi[i],candi,res,ans);\\n            res.pop_back();\\n        }\\n\\n        while(i+1<candi.size() && candi[i] == candi[i+1]){\\n            i++;\\n        }\\n        // 1,1,1,2,2,3,4,5,6\\n        solver(i+1,target,candi,res,ans);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> res;\\n        solver(0,target,candidates,res,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473396,
                "title": "easy-java-solution-2ms-beats-99-69",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> finalList = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        helper(0, candidates, target,new ArrayList<Integer>(),finalList );\\n        return finalList;\\n    }\\n    public void helper(int index, int[] arr, int target, ArrayList<Integer> list, List<List<Integer>> finalList){\\n        \\n            if(target == 0){\\n                finalList.add(new ArrayList<>(list));\\n                return;\\n            }\\n            \\n        \\n        for(int i = index;i<arr.length;i++){\\n            if(i != index && arr[i] == arr[i-1]){\\n                continue;\\n            }\\n            if(arr[i] > target){break;}\\n            list.add(arr[i]);\\n            helper(i+1,arr,target-arr[i],list,finalList);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> finalList = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        helper(0, candidates, target,new ArrayList<Integer>(),finalList );\\n        return finalList;\\n    }\\n    public void helper(int index, int[] arr, int target, ArrayList<Integer> list, List<List<Integer>> finalList){\\n        \\n            if(target == 0){\\n                finalList.add(new ArrayList<>(list));\\n                return;\\n            }\\n            \\n        \\n        for(int i = index;i<arr.length;i++){\\n            if(i != index && arr[i] == arr[i-1]){\\n                continue;\\n            }\\n            if(arr[i] > target){break;}\\n            list.add(arr[i]);\\n            helper(i+1,arr,target-arr[i],list,finalList);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373591,
                "title": "pyhton3-backtrack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res=[]\\n        currset=[]\\n        subset=[]\\n        def helper(i,candidates,currset,subset):\\n            if sum(currset)==target:\\n                subset.append(currset.copy())\\n                return \\n\\n            if(sum(currset)>target) or i>=len(candidates) :\\n                return\\n            currset.append(candidates[i])\\n            helper(i+1,candidates,currset,subset)\\n\\n            currset.pop()\\n\\n            while i+1<len(candidates) and candidates[i]==candidates[i+1]:\\n                i+=1\\n\\n            helper(i+1,candidates,currset,subset)\\n\\n        helper(0,candidates,currset,subset)\\n        return subset\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        res=[]\\n        currset=[]\\n        subset=[]\\n        def helper(i,candidates,currset,subset):\\n            if sum(currset)==target:\\n                subset.append(currset.copy())\\n                return \\n\\n            if(sum(currset)>target) or i>=len(candidates) :\\n                return\\n            currset.append(candidates[i])\\n            helper(i+1,candidates,currset,subset)\\n\\n            currset.pop()\\n\\n            while i+1<len(candidates) and candidates[i]==candidates[i+1]:\\n                i+=1\\n\\n            helper(i+1,candidates,currset,subset)\\n\\n        helper(0,candidates,currset,subset)\\n        return subset\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346744,
                "title": "efficient-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo make combination we need to use the \"Pick\" and \"Not pick\" method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe entire approach is same as Combination I.\\nBut, to ignore duplicate combination -->\\n- First we need to sort the given vector, so that all the duplicate elements of the given vector will be consecutively placed.\\n- Then, When we are about to \"Not pick\" an element we need to ignore all the similar consecutive elements. Which job is done by this block of code -->\\n```\\nwhile(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSame as Combination I\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSame as Combination I\\n\\nMy Combination I solution link \\uD83D\\uDC47\\nhttps://leetcode.com/problems/combination-sum/solutions/3344753/100-beats-easy-to-understand-c-code/\\n\\nPlease upvote if you find it helpful \\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void help(int i,int t,vector<int>& c,vector<int>&temp){\\n        if(t==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(t<0){\\n            return;\\n        }\\n        if(i==c.size()){\\n            return;\\n        }\\n        temp.push_back(c[i]);\\n        help(i+1,t-c[i],c,temp);\\n        temp.pop_back();\\n        while(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n        help(i+1,t,c,temp);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        vector<int>temp;\\n        sort(c.begin(),c.end());\\n        help(0,t,c,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwhile(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void help(int i,int t,vector<int>& c,vector<int>&temp){\\n        if(t==0){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        if(t<0){\\n            return;\\n        }\\n        if(i==c.size()){\\n            return;\\n        }\\n        temp.push_back(c[i]);\\n        help(i+1,t-c[i],c,temp);\\n        temp.pop_back();\\n        while(i+1<c.size() && c[i]==c[i+1]){\\n            i++;\\n        }\\n        help(i+1,t,c,temp);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& c, int t) {\\n        vector<int>temp;\\n        sort(c.begin(),c.end());\\n        help(0,t,c,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294871,
                "title": "recursion-java-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,target,candidates,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    public void solve(int ind,int target,int[]candidates,List<List<Integer>>ans,ArrayList<Integer>temp){\\n        if(target==0){\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for(int i=ind;i<candidates.length;i++){\\n            if(i!=ind && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n\\n            temp.add(candidates[i]);\\n            solve(i+1,target-candidates[i],candidates,ans,temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>>ans=new ArrayList<>();\\n        solve(0,target,candidates,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    public void solve(int ind,int target,int[]candidates,List<List<Integer>>ans,ArrayList<Integer>temp){\\n        if(target==0){\\n            ans.add(new ArrayList<>(temp));\\n            return;\\n        }\\n\\n        for(int i=ind;i<candidates.length;i++){\\n            if(i!=ind && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n\\n            temp.add(candidates[i]);\\n            solve(i+1,target-candidates[i],candidates,ans,temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248311,
                "title": "java-simple-powerfull",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        combination2( 0,candidates, target, res, list);\\n        return res;\\n    }\\n    public void combination2(int index, int[] arr, int target, List<List<Integer>> res, List<Integer> list){\\n        if(target == 0){\\n            Collections.sort(list);\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i = index;i < arr.length;i++){\\n            if(i > index && arr[i] == arr[i - 1]) continue;\\n            if(target < arr[i]) break;\\n\\n            list.add(arr[i]);\\n            combination2(i + 1, arr, target - arr[i], res, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        List<Integer> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        combination2( 0,candidates, target, res, list);\\n        return res;\\n    }\\n    public void combination2(int index, int[] arr, int target, List<List<Integer>> res, List<Integer> list){\\n        if(target == 0){\\n            Collections.sort(list);\\n            res.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i = index;i < arr.length;i++){\\n            if(i > index && arr[i] == arr[i - 1]) continue;\\n            if(target < arr[i]) break;\\n\\n            list.add(arr[i]);\\n            combination2(i + 1, arr, target - arr[i], res, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224015,
                "title": "optimized-solution-2ms-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2n*k\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:k*x\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList());\\n        return ans;\\n    }\\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if(target == 0) {\\n            ans.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        for(int i = ind; i < arr.length;i++) {\\n            if(i > ind && arr[i] == arr[i-1]) continue; \\n            if(arr[i]>target) break; \\n            \\n            ds.add(arr[i]); \\n            findCombinations(i+1, arr, target - arr[i], ans, ds); \\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        Arrays.sort(candidates);\\n        findCombinations(0,candidates,target,ans,new ArrayList());\\n        return ans;\\n    }\\n    private void findCombinations(int ind, int[] arr, int target, List<List<Integer>> ans, List<Integer> ds) {\\n        if(target == 0) {\\n            ans.add(new ArrayList<>(ds)); \\n            return; \\n        }\\n        \\n        for(int i = ind; i < arr.length;i++) {\\n            if(i > ind && arr[i] == arr[i-1]) continue; \\n            if(arr[i]>target) break; \\n            \\n            ds.add(arr[i]); \\n            findCombinations(i+1, arr, target - arr[i], ans, ds); \\n            ds.remove(ds.size() - 1); \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185178,
                "title": "python-backtracking-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()                      \\n        result = []\\n        def combine_sum_2(nums, start, path, result, target):\\n            if not target:\\n                result.append(path)\\n                return\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i - 1]:\\n                    continue\\n                if nums[i] > target:\\n                    break\\n                combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i])\\n        combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates, target):\\n        candidates.sort()                      \\n        result = []\\n        def combine_sum_2(nums, start, path, result, target):\\n            if not target:\\n                result.append(path)\\n                return\\n            for i in range(start, len(nums)):\\n                if i > start and nums[i] == nums[i - 1]:\\n                    continue\\n                if nums[i] > target:\\n                    break\\n                combine_sum_2(nums, i + 1, path + [nums[i]], result, target - nums[i])\\n        combine_sum_2(candidates, 0, [], result, target)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182108,
                "title": "java-sol-2ms-beats-99-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> arr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        func (candidates, arr, 0, target, new ArrayList<>());\\n        return arr;\\n    }\\n    void func (int[] candi, List<List<Integer>> arr, int idx, int target, List<Integer> temp) {\\n        if (target==0) {\\n            arr.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i=idx; i<candi.length; i++) {\\n            if (i>idx && candi[i]==candi[i-1]) continue;\\n            if (candi[i]>target) break;\\n            temp.add(candi[i]);\\n            func (candi, arr, i+1, target-candi[i], temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> arr = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        func (candidates, arr, 0, target, new ArrayList<>());\\n        return arr;\\n    }\\n    void func (int[] candi, List<List<Integer>> arr, int idx, int target, List<Integer> temp) {\\n        if (target==0) {\\n            arr.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i=idx; i<candi.length; i++) {\\n            if (i>idx && candi[i]==candi[i-1]) continue;\\n            if (candi[i]>target) break;\\n            temp.add(candi[i]);\\n            func (candi, arr, i+1, target-candi[i], temp);\\n            temp.remove(temp.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177752,
                "title": "go-solution-recursive-dfs",
                "content": "#### Recursive DFS\\n\\n```go\\nimport (\\n    \"sort\"\\n)\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n    sort.Ints(candidates)\\n    combos := make([][]int, 0)\\n    \\n    var dfs func([]int, int, []int)\\n    dfs = func(nums []int, targ int, path []int) {\\n        if targ < 0 {\\n            return\\n        }\\n        if targ == 0 {\\n            combos = append(combos, path)\\n            return\\n        }\\n        \\n        for i, n := range nums {\\n            if i > 0 && nums[i] == nums[i-1] {\\n                continue\\n            }\\n            newPath := make([]int, len(path))\\n            copy(newPath, path)\\n            dfs(nums[i+1:], targ-n, append(newPath, n))\\n        }\\n        return\\n    }\\n    \\n    dfs(candidates, target, []int{})\\n    return combos\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```go\\nimport (\\n    \"sort\"\\n)\\n\\nfunc combinationSum2(candidates []int, target int) [][]int {\\n    sort.Ints(candidates)\\n    combos := make([][]int, 0)\\n    \\n    var dfs func([]int, int, []int)\\n    dfs = func(nums []int, targ int, path []int) {\\n        if targ < 0 {\\n            return\\n        }\\n        if targ == 0 {\\n            combos = append(combos, path)\\n            return\\n        }\\n        \\n        for i, n := range nums {\\n            if i > 0 && nums[i] == nums[i-1] {\\n                continue\\n            }\\n            newPath := make([]int, len(path))\\n            copy(newPath, path)\\n            dfs(nums[i+1:], targ-n, append(newPath, n))\\n        }\\n        return\\n    }\\n    \\n    dfs(candidates, target, []int{})\\n    return combos\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3158498,
                "title": "runtime-beats-97-33-combination-sum-ii-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the candidates list in ascending order.\\nDefine a backtracking function that takes in 3 parameters: start index, a list path to store each combination, and the target value.\\nIf the target value is 0, append the path list to the result res list.\\nLoop through the candidates list starting from the given start index.\\nIf the current index i is greater than start and the current candidate is the same as the previous candidate, continue to the next iteration.\\nIf the current candidate is greater than the target value, break the loop.\\nAdd the current candidate to the path list and call the backtracking function with i + 1 as the start index, the updated path list, and the target minus the current candidate.\\nReturn the result res list after the backtracking function is finished.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(start, path, target):\\n            if target == 0:\\n                res.append(path)\\n                return\\n            for i in range(start, len(candidates)):\\n                if i > start and candidates[i] == candidates[i - 1]:\\n                    continue\\n                if candidates[i] > target:\\n                    break\\n                backtrack(i + 1, path + [candidates[i]], target - candidates[i])\\n\\n        candidates.sort()\\n        res = []\\n        backtrack(0, [], target)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def backtrack(start, path, target):\\n            if target == 0:\\n                res.append(path)\\n                return\\n            for i in range(start, len(candidates)):\\n                if i > start and candidates[i] == candidates[i - 1]:\\n                    continue\\n                if candidates[i] > target:\\n                    break\\n                backtrack(i + 1, path + [candidates[i]], target - candidates[i])\\n\\n        candidates.sort()\\n        res = []\\n        backtrack(0, [], target)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124204,
                "title": "2k-views-easy-to-understand-concise-and-precise-100-efficient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void Ps(int ind,int target,vector<int> &v,vector<vector<int>> &ans , vector<int> &arr){\\n        if(target==0){\\n            ans.push_back(v);\\n            return ;\\n        }\\n        for(int i=ind;i<arr.size();i++){\\n            if(i>ind && arr[i]==arr[i-1]) continue;\\n            if(arr[i]>target) break;\\n            v.push_back(arr[i]);\\n            Ps(i+1,target-arr[i],v,ans,arr);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        Ps(0,target,v,ans,arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void Ps(int ind,int target,vector<int> &v,vector<vector<int>> &ans , vector<int> &arr){\\n        if(target==0){\\n            ans.push_back(v);\\n            return ;\\n        }\\n        for(int i=ind;i<arr.size();i++){\\n            if(i>ind && arr[i]==arr[i-1]) continue;\\n            if(arr[i]>target) break;\\n            v.push_back(arr[i]);\\n            Ps(i+1,target-arr[i],v,ans,arr);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        Ps(0,target,v,ans,arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105204,
                "title": "java-backtracking-explained",
                "content": "# Intuition\\n- Before starting the recursive call make sure to sort the elements because the ans should contain the combinations in sorted order and should not be repeated.\\n\\n- Initially, We start with the index 0, At index 0 we have n \\u2013 1 way to pick the first element of our subsequence.\\n\\n- Check if the current index value can be added to our ds. If yes add it to the ds and move the index by 1. while moving the index skip the consecutive repeated elements because they will form duplicate sequences.\\n\\n- Reduce the target by arr[i],call the recursive call for f(idx + 1,target \\u2013 1,ds,ans) after the call make sure to pop the element from the ds.\\n\\n- - if(arr[i] > target) then terminate the recursive call because there is no use to check as the array is sorted in the next recursive call the index will be moving by 1 all the elements to its right will be in increasing order.\\n\\n# Base Condition:\\n\\n- Whenever the target value is zero add the ds to the ans return.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(2^n*k)$$ \\n- - Assume if all the elements in the array are unique then the no. of subsequence you will get will be O(2^n). we also add the ds to our ans when we reach the base case that will take \\u201Ck\\u201D//average space for the ds.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        findCombiantions(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    void findCombiantions(int ind, int[] nums, int target, List<List<Integer>> ans, ArrayList<Integer> ds) {\\n        if (target==0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for (int i = ind; i < nums.length ; i++) {\\n            if (i>ind && nums[i]==nums[i-1] ) continue;\\n            if (nums[i]>target) break;\\n            ds.add(nums[i]);\\n            findCombiantions(i+1,nums,target-nums[i],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> ans=new ArrayList<>();\\n        findCombiantions(0,candidates,target,ans,new ArrayList<>());\\n        return ans;\\n    }\\n    void findCombiantions(int ind, int[] nums, int target, List<List<Integer>> ans, ArrayList<Integer> ds) {\\n        if (target==0){\\n            ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for (int i = ind; i < nums.length ; i++) {\\n            if (i>ind && nums[i]==nums[i-1] ) continue;\\n            if (nums[i]>target) break;\\n            ds.add(nums[i]);\\n            findCombiantions(i+1,nums,target-nums[i],ans,ds);\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100921,
                "title": "super-easily-understandable-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->https://www.youtube.com/watch?v=G1fRTGRxXU8&list=PLgUwDviBIf0rGlzIn_7rsaR2FQ5e6ZOL9&index=9\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void findcombination(int ind, int target,vector<int> &candidates,vector<vector<int>> &ans,vector<int> &ds){\\n        if(target==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<candidates.size();i++){\\n            if(i>ind && candidates[i]==candidates[i-1])continue;\\n            if(candidates[i]>target)break;\\n            ds.push_back(candidates[i]);\\n            findcombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n        }\\n        \\n    }\\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n    sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findcombination(0,target,candidates,ans,ds);\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void findcombination(int ind, int target,vector<int> &candidates,vector<vector<int>> &ans,vector<int> &ds){\\n        if(target==0){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=ind;i<candidates.size();i++){\\n            if(i>ind && candidates[i]==candidates[i-1])continue;\\n            if(candidates[i]>target)break;\\n            ds.push_back(candidates[i]);\\n            findcombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n        }\\n        \\n    }\\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n    sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findcombination(0,target,candidates,ans,ds);\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088912,
                "title": "c-striver-approach-easy-explained",
                "content": "# Approach\\n- So Here Sort The Vector , Because We Are Having A Logic Of Not Using Extra Space\\n- Lets Deep Dive Into Our Recursive Code And I Will Explain It Line By Line\\n- So First Of All We Have Our Base Case , That Is If(target == 0) , we push the vector in our ans , which is vector<vector<int>> and we return\\n- After That As We Know The Question States We Need Lexicographical Answers Only , Means We Cannot Pick [1,2,1] , We Can Only Pick Answers Which Are Sorted In I.e [1,1,2] or [2,2]\\n- So Inorder To Avoid The Same Sequences We Keep A Check , That Is If We Are Picking The Element For First Time We Allow It , If The Same Number Comes Again , That Will Generate Same Answer\\n- So We Keep A Check By Using This  if(i > index && arr[i] == arr[i-1]) , If This Satisfies We Skip And Move To Next Index\\n- After That We Keep A Check If The arr[i] > Target that means we cannot have any combination , as after this all values will be high as we have the vector sorted\\n- After That We Add The ith Element In Our Temp Vector And We Again Call Recursion\\n- We Have To Also Do Backtracking For Removing The ith Element , So We Also Pop Back The Element\\n- Check Given Recursion Tree , And You Will Get What I am Trying To Explain\\n\\n# Recursion Tree \\n\\n```\\nInput: candidates = [1,1,1,2,2], target = 4\\nOutput: [[1,1,2],[2,2]]\\n```\\n\\n![WhatsApp Image 2023-01-23 at 11.28.03 AM.jpeg](https://assets.leetcode.com/users/images/42c631cb-fb47-4a1a-b6ba-1a7a98c486ae_1674453532.080475.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(2^n * k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n * k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nvoid solve(int index,int target,vector<int> &arr,vector<vector<int>> &ans,vector<int> &ds)\\n{\\n    if(target == 0)\\n    {\\n        ans.push_back(ds);\\n        return;\\n    }\\n\\n    for(int i = index; i< arr.size();i++)\\n    {\\n       if(i > index && arr[i] == arr[i-1])\\n       continue;\\n\\n       if(arr[i] > target)\\n       break;\\n\\n       ds.push_back(arr[i]);\\n       solve(i+1,target-arr[i],arr,ans,ds);\\n       ds.pop_back();\\n    }\\n\\n    return;\\n}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nInput: candidates = [1,1,1,2,2], target = 4\\nOutput: [[1,1,2],[2,2]]\\n```\n```\\nclass Solution {\\nprivate:\\nvoid solve(int index,int target,vector<int> &arr,vector<vector<int>> &ans,vector<int> &ds)\\n{\\n    if(target == 0)\\n    {\\n        ans.push_back(ds);\\n        return;\\n    }\\n\\n    for(int i = index; i< arr.size();i++)\\n    {\\n       if(i > index && arr[i] == arr[i-1])\\n       continue;\\n\\n       if(arr[i] > target)\\n       break;\\n\\n       ds.push_back(arr[i]);\\n       solve(i+1,target-arr[i],arr,ans,ds);\\n       ds.pop_back();\\n    }\\n\\n    return;\\n}\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074701,
                "title": "c-backtracking",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\u9700\\u8981\\u526A\\u679D\\uFF0C\\u5982\\u679C\\u4E00\\u4E2A\\u8282\\u70B9\\u6709\\u591A\\u6761\\u503C\\u76F8\\u540C\\u7684\\u6811\\u679D\\u76F8\\u90BB\\uFF0C\\u5219\\u53EA\\u904D\\u5386\\u7B2C\\u4E00\\u6761\\uFF0C\\u5269\\u4E0B\\u7684\\u90FD\\u526A\\u6389\\uFF0C\\u4E0D\\u8981\\u53BB\\u904D\\u5386.\\u4F53\\u73B0\\u5728\\u4EE3\\u7801\\u4E0A\\uFF0C\\u9700\\u8981\\u5148\\u8FDB\\u884C\\u6392\\u5E8F\\uFF0C\\u8BA9\\u76F8\\u540C\\u7684\\u5143\\u7D20\\u9760\\u5728\\u4E00\\u8D77\\uFF0C\\u5982\\u679C\\u53D1\\u73B0candidates[i] == candidates[i-1]\\uFF0C\\u5219\\u8DF3\\u8FC7.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<int> path;\\n    int sum = 0;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        // if(candidates.size() == 0) return res;\\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, 0);\\n        return res;\\n    }\\n    void backtrack(vector<int>& candidates, int target, int u){\\n        if(sum == target){\\n            res.push_back(path);\\n            return;\\n        }\\n        if(sum > target) return;\\n        \\n        for(int i = u; i < candidates.size(); i ++){\\n            if(i > u && candidates[i] == candidates[i - 1]) continue;\\n            path.push_back(candidates[i]);\\n            sum += candidates[i];\\n            backtrack(candidates, target, i + 1);\\n            path.pop_back();\\n            sum -= candidates[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    vector<int> path;\\n    int sum = 0;\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        // if(candidates.size() == 0) return res;\\n        sort(candidates.begin(), candidates.end());\\n        backtrack(candidates, target, 0);\\n        return res;\\n    }\\n    void backtrack(vector<int>& candidates, int target, int u){\\n        if(sum == target){\\n            res.push_back(path);\\n            return;\\n        }\\n        if(sum > target) return;\\n        \\n        for(int i = u; i < candidates.size(); i ++){\\n            if(i > u && candidates[i] == candidates[i - 1]) continue;\\n            path.push_back(candidates[i]);\\n            sum += candidates[i];\\n            backtrack(candidates, target, i + 1);\\n            path.pop_back();\\n            sum -= candidates[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040453,
                "title": "c-java-python-easiest-solution-detailed-explanation-code",
                "content": "\\n# Approach\\nThe code is a solution to the problem of finding all combinations of a given set of candidates that add up to a given target. The solution uses a recursive function Solve() that takes the candidates, target, current sum, an array to store the combinations, an array to store the current combination, and the current index being processed as input. The function checks if the current sum is equal to the target, if so it adds the current combination to the output. If the current sum is greater than the target, it returns.\\nIf the current index is equal to the size of the candidates, it returns.\\n\\nOne difference from the previous code is that it also skips any duplicates candidates by using a while loop after a recursive call using the current candidate. This will prevent the function from generating duplicate subsets.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O((2^n)*k)**, where 2^n is distribution of n elements, k is average length of every combination(mainly k for this -> ans.push_back(ds);)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(x)**, where x is length of longest combinations \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nClass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, vector<vector<int>>& output, vector<int>& ans, int index){\\n        if(target == sum){\\n            output.push_back(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.push_back(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.pop_back();\\n        while(index < candidates.size()-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public void Solve(int[] candidates, int target, int sum, List<List<Integer>> output, List<Integer> ans, int index){\\n        if(target == sum){\\n            output.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        if(candidates.length == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.add(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.remove(ans.size()-1);\\n        while(index < candidates.length-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def Solve(self, candidates, target, sum, output, ans, index):\\n        if target == sum:\\n            output.append(list(ans))\\n            return\\n        if len(candidates) == index:\\n            return\\n        if sum > target:\\n            return\\n        ans.append(candidates[index])\\n        self.Solve(candidates, target, sum + candidates[index], output, ans, index + 1)\\n        ans.pop()\\n        while index < len(candidates)-1 and candidates[index] == candidates[index + 1]:\\n            index += 1\\n        self.Solve(candidates, target, sum, output, ans, index + 1)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        output = []\\n        ans = []\\n        candidates.sort()\\n        self.Solve(candidates, target, 0, output, ans, 0)\\n        return output\\n\\n\\n```\\n**Note 0 : Also Recommend to see \"Combination Sum\" which is available in leetcode.** https://leetcode.com/problems/combination-sum/solutions/3027804/c-java-python-detailed-explanation-recursive-solution/\\n\\n**Note 1: Code for Java and Python might be wrong due to syntax error bcz Java and Python Solution is just the exact coversion of C++ code but logic is 100 % correct.**\\n\\n***Note 2: with the help of hashset we will get time limit exceeded error with this test case.**\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget = 30\\nclass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, set<vector<int>>& s, vector<int>& ans, int index){\\n        if(target == sum){\\n            s.insert(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        if(sum + candidates[index] > target) \\n            return;\\n        ans.push_back(candidates[index]); \\n        Solve(candidates, target, sum + candidates[index], s, ans, index + 1);\\n        ans.pop_back();\\n        Solve(candidates, target, sum, s, ans, index + 1);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> s;\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, s, ans, 0);\\n        for(auto vec : s)\\n            output.push_back(vec);\\n        return output;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```C++ []\\nClass Solution {\\npublic:\\n    void Solve(vector<int>& candidates, int target, int sum, vector<vector<int>>& output, vector<int>& ans, int index){\\n        if(target == sum){\\n            output.push_back(ans);\\n            return;\\n        }\\n        if(candidates.size() == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.push_back(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.pop_back();\\n        while(index < candidates.size()-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> output;\\n        vector<int> ans;\\n        sort(candidates.begin(), candidates.end());\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public void Solve(int[] candidates, int target, int sum, List<List<Integer>> output, List<Integer> ans, int index){\\n        if(target == sum){\\n            output.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        if(candidates.length == index)\\n            return;\\n        if(sum > target)\\n            return;\\n        ans.add(candidates[index]);\\n        Solve(candidates, target, sum + candidates[index], output, ans, index + 1);\\n        ans.remove(ans.size()-1);\\n        while(index < candidates.length-1 && candidates[index] == candidates[index + 1])\\n            index++;\\n        Solve(candidates, target, sum, output, ans, index + 1);\\n    }\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        List<List<Integer>> output = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        Solve(candidates, target, 0, output, ans, 0);\\n        return output;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def Solve(self, candidates, target, sum, output, ans, index):\\n        if target == sum:\\n            output.append(list(ans))\\n            return\\n        if len(candidates) == index:\\n            return\\n        if sum > target:\\n            return\\n        ans.append(candidates[index])\\n        self.Solve(candidates, target, sum + candidates[index], output, ans, index + 1)\\n        ans.pop()\\n        while index < len(candidates)-1 and candidates[index] == candidates[index + 1]:\\n            index += 1\\n        self.Solve(candidates, target, sum, output, ans, index + 1)\\n\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        output = []\\n        ans = []\\n        candidates.sort()\\n        self.Solve(candidates, target, 0, output, ans, 0)\\n        return output\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010879,
                "title": "backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n\\n    void findCombination(int index, int target, vector<int>& candidates, vector<vector<int>>& ans, vector<int>& ds ){\\n\\n        if(target==0)\\n        {\\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n            ds.push_back(candidates[i]);\\n            findCombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n\\n\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        \\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        findCombination(0,target,candidates,ans,ds);\\n        return ans;\\n    }\\n\\n    void findCombination(int index, int target, vector<int>& candidates, vector<vector<int>>& ans, vector<int>& ds ){\\n\\n        if(target==0)\\n        {\\n            ans.push_back(ds);\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1]) continue;\\n            if(candidates[i]>target) break;\\n            ds.push_back(candidates[i]);\\n            findCombination(i+1,target-candidates[i],candidates,ans,ds);\\n            ds.pop_back();\\n\\n\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860265,
                "title": "c-faster-than-100-concept-of-pick-subsequence",
                "content": "# Complexity\\n- Time complexity:\\nO(2^n)+k\\n\\n- Space complexity:\\nk*x (ignoring auxilary space used by recursion)\\n\\npls upvote if you like the solution.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind, int target, vector <int>& arr, vector<vector<int>>&ans,vector<int>&ds){\\n    if(target==0){\\n        ans.push_back(ds);\\n        return;\\n    }\\n    for(int i=ind; i<arr.size();i++){\\n        if(i>ind&& arr[i]==arr[i-1]) continue;\\n        if(arr[i]>target) break;\\n\\n        ds.push_back(arr[i]);\\n        findCombination(i+1, target-arr[i],arr, ans, ds);\\n        ds.pop_back();\\n    }\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector <int>ds;\\n        findCombination(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid findCombination(int ind, int target, vector <int>& arr, vector<vector<int>>&ans,vector<int>&ds){\\n    if(target==0){\\n        ans.push_back(ds);\\n        return;\\n    }\\n    for(int i=ind; i<arr.size();i++){\\n        if(i>ind&& arr[i]==arr[i-1]) continue;\\n        if(arr[i]>target) break;\\n\\n        ds.push_back(arr[i]);\\n        findCombination(i+1, target-arr[i],arr, ans, ds);\\n        ds.pop_back();\\n    }\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector <int>ds;\\n        findCombination(0, target, candidates, ans, ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1761591,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569334,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1625415,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571097,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572732,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571098,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1782494,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761589,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1825165,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1948051,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761591,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569334,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1625415,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571097,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572732,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571098,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1782494,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1761589,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1825165,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1948051,
                "content": [
                    {
                        "username": "ananta_srivastava",
                        "content": "where in the question is it mentioned that th ans should be in sorted order?"
                    },
                    {
                        "username": "PurdueKumar",
                        "content": "This problem is the same problem as the subset sum problem, which is a famous np-complete problem. The only solution is the brute force solution."
                    },
                    {
                        "username": "aman_mnnit",
                        "content": "how to make sure my vector<vector<int>> ans does not contain duplicate values without using set?"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "[@munchfumbl](/munchfumbl) Because inserting elements into set takes O(log n) time, which exceeds the given time limit"
                    },
                    {
                        "username": "bowenyi",
                        "content": "[@munchfumbl](/munchfumbl) Tried to use a set but got TLE un test case 172 :("
                    },
                    {
                        "username": "munchfumbl",
                        "content": "why can\\'t you use a set?"
                    },
                    {
                        "username": "akash__2001",
                        "content": "you can use \\n  if(find(ans.begin(),ans.end(),ds)==ans.end() )\\n                ans.push_back(ds);"
                    },
                    {
                        "username": "rajneshrat",
                        "content": "you can sort the input candidates list. And then avoid using the same element again if it was used last.\\nhttps://leetcode.com/problems/combination-sum-ii/submissions/877232901/"
                    },
                    {
                        "username": "shru671",
                        "content": "[@itsAbhi91](/itsAbhi91) ans.erase(unique(ans.begin(), ans.end()), ans.end()); \\nwhere \"ans\" is my vector<vector<int>>"
                    },
                    {
                        "username": "shubhaamtiwary_01",
                        "content": "Try to pick unique combination at every stage by picking unique elements at each stage.\\nSee my Solution --> https://leetcode.com/problems/combination-sum-ii/solutions/2844056/easy-c-solution-striver-better-solution/"
                    },
                    {
                        "username": "itsAbhi91",
                        "content": "You can make use of Unordered_map<string,int> mp;"
                    },
                    {
                        "username": "rakesh_joshi",
                        "content": " Question says \\n\\nGiven a collection of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.\\n\\n**Each number in C may only be used once in the combination.** \\n\\n For example, given candidate set [10, 1, 2, 7, 6, 1, 5] and target 8,\\nA solution set is:\\n\\n[\\n  [1, 7],\\n  [1, 2, 5],\\n  [2, 6],\\n  [1, 1, 6]\\n]\\n\\ni am confused of this  condition  \\n**Each number in C may only be used once in the combination.** \\nas in this example it has the **combination [1,1,6]  i.e. repeating 1's**\\n\\nit is highly appreciable if somebody explains it. Thank you ."
                    },
                    {
                        "username": "pepjaggu2022",
                        "content": "[@kushalnagwanshicloud](/kushalnagwanshicloud)  yes when you sort you are able to get 1 1 6"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "the original candidate list has two 1\\'s that is why you can use two 1\\'s in the array."
                    },
                    {
                        "username": "banipreet",
                        "content": "Why doesn\\'t this question display constraint on the size of the array? I mean constraints are very important before thinking of a possible solution. Maybe one wants to implements some approach however the constraints doesn\\'t allow him/her to use that. What would a programmer do in cases where the constraints are not given? Code only to discover that the constraints doesn\\'t allow him to use that apporach? I think this is a flaw in leetcode questions. Please emphasize on constraints!"
                    },
                    {
                        "username": "ustcscuwf",
                        "content": "The example set has two \"1\"s. In the answer, it is quite clear that the two \"1\"s are trimmed to only one.\\nFirst, I think if you name it as the mathematical \"set\", there should be no duplicated numbers. If this could be regarded as a set, then duplicated numbers should be treated as different ones."
                    },
                    {
                        "username": "user0651d",
                        "content": "Can someone explain please why there are 2 ones in the 1st answer? shouldn\\'t the numbers be unique along side with the combination it self? so why there are duplicate numbers in the answers?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "Actually the question reads `Each number in candidates may only be used once in the combination.` It means if a number appears more than once in the `candidates` set, then we can use it more than once."
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "each number in candidates can be used once in the combination. you swipe through the elements and remove them from the combinations. there are 2 ones in the candidates so 2 ones in the answer"
                    },
                    {
                        "username": "ananta_srivastava",
                        "content": "how to know when to sort the elements and when not to sort the elements?"
                    },
                    {
                        "username": "anuron_das",
                        "content": "If you have solved the problem combinational sums - I then you will be knowing that sorting the input array there is not needed. But here, as you might have noticed, we need the same numbers side by side to avoid taking duplicate combinations. Hence we needed to sort the input array. "
                    },
                    {
                        "username": "nachiketa_bhoraniya",
                        "content": "to check the code optimization, below test case might be helpful which is not included in list of test cases for this problem and was taking more time to solve when I provided custom test cases. here it is\\n\\ncandidates = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,33,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,44,4,4,4,5,5,5,5,5,5,5,5,5,5,5,49,5,5,5,5,6,6,6,6]\\ntarget = 29"
                    },
                    {
                        "username": "2030019",
                        "content": "Why am I getting a TLE for the test case - \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\ntarget =\\n30\\n\\n `\\nclass Solution {\\npublic:\\n    void get_combos(vector<int>& arr,set<vector<int>>& sett,vector<int>& temp,int target,int n){\\n        if(n==0){\\n            if(target==0){\\n                sett.insert(temp);\\n            }\\n            return;\\n        }\\n        if(arr[n-1]<=target){\\n            temp.push_back(arr[n-1]);\\n            get_combos(arr,sett,temp,target-arr[n-1],n-1);\\n            temp.pop_back();\\n        }\\n        get_combos(arr,sett,temp,target,n-1);\\n\\n    }\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        int n=candidates.size();\\n        sort(candidates.begin(),candidates.end());\\n        set<vector<int>> sett;\\n        vector<int> temp;\\n        get_combos(candidates,sett,temp,target,n);\\n        vector<vector<int>> ans(sett.begin(),sett.end());\\n        return ans;\\n    }\\n}; `"
                    },
                    {
                        "username": "atharvakulkarni960",
                        "content": "Try doing it without using set"
                    },
                    {
                        "username": "rrdesh07",
                        "content": "bro because how even we can do using normal recursion like there must be some changes has to made because the normal solution won\\'t pass because n=100 and for each we are making two choices so it will go upto 2^100 which is very big number it will surely give tle "
                    },
                    {
                        "username": "gauravkumar050996",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void find(vector<int>& arr,int idx, int tar, vector<int> ts, int sum)\\n    {\\n       \\n        for(int i=idx; i<arr.size(); i++)\\n        {\\n            if(sum+arr[i]<tar)\\n            {\\n            ts.push_back(arr[i]);\\n            find(arr,i+1,tar,ts,sum+arr[i]); \\n            ts.pop_back();\\n            all_inlcude = false;\\n\\n            while(i+1<arr.size() && arr[i]==arr[i+1])  //to avoid duplicate combination\\n                    i++;\\n            }\\n            else if(sum+arr[i]==tar)\\n            {\\n                ts.push_back(arr[i]);\\n                ans.push_back(ts);\\n                return;\\n            }\\n            else return;\\n\\n        }\\n    \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int tar) {\\n             \\n          sort(arr.begin(),arr.end());\\n          find(arr,0,tar,{},0);\\n          return ans;\\n        \\n        \\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1773550,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 1708453,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 1572711,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2052618,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2049804,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2046354,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2027816,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2027069,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2014335,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2011007,
                "content": [
                    {
                        "username": "Sanushgowda",
                        "content": "what is the diff between comination sum1 and this problem??\\ncan anyone tell plz"
                    },
                    {
                        "username": "akash__2001",
                        "content": "constraints "
                    },
                    {
                        "username": "abdellahelgourami123",
                        "content": "read the official solution they montionned the difference between the two problems"
                    },
                    {
                        "username": "shru671",
                        "content": "void findCombinations(int ind, vector<int> &candidates, int target, vector<vector<int>>&ans,\\n    vector<int> &ds)\\n    {\\n        //base case\\n        if(ind == candidates.size() || target == 0)\\n        {\\n            if(target == 0)\\n            {\\n                sort(ds.begin(), ds.end());\\n                ans.push_back(ds);\\n            }\\n                \\n            return;\\n        }\\n        //pick elmt\\n        if(candidates[ind] <= target)\\n        {\\n            ds.push_back(candidates[ind]);\\n            findCombinations (ind+1, candidates, target-candidates[ind], ans, ds);\\n\\n            ds.pop_back();\\n        }\\n\\n        //not picked\\n        findCombinations(ind+1, candidates, target, ans, ds);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>ds;\\n\\n        findCombinations(0, candidates, target, ans, ds);\\n        \\n        sort(ans.begin(), ans.end());\\n        ans.erase(unique(ans.begin(), ans.end()), ans.end());\\n\\n        return ans;\\n    }\\n};\\n\\nCan anybody pls tell why [1,1,2] is also printed in example candidates = [2,5,2,1,2] and target =5 "
                    },
                    {
                        "username": "prafulkatare7",
                        "content": "Because when your code first run it has [2,1,2] in the ds. But since you are sorting it, it is becoming 1,2,2. Now you are removing the 2. And you are left with [1,2]. When this recursion call ends, your pop_back is removing 2 instead of 1 from array. Just don\\'t sort the DS and sort the candidate before passing. It should work fine then. BTW kudos to Striver !!"
                    },
                    {
                        "username": "gyh75520",
                        "content": "clike here [a more general approach to backtracking questions in Python (Subsets, Permutations, Combination Sum)](https://leetcode.com/problems/permutations/discuss/301437/a-more-general-approach-to-backtracking-questions-in-Python-(Subsets-Permutations-Combination-Sum))"
                    },
                    {
                        "username": "lowut02",
                        "content": "Horrible problem tbh."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Sort the candidates array then when looping over candidates, use a \"previous\" variable that holds the most recently used number in it. At the start of your loop, if previous == candidates[i], continue to the next number. This, along with setting up your recursive function the right way, should allow you to avoid any duplicate combinations.\\n\\nA bit of code for reference:\\n ```\\n        int prev = -1;\\n        for (int i = ind; i < cand.Length; i++){\\n            if (currSum + cand[i] > targ) break;\\n            if (prev == cand[i]) continue;\\n            currComb.Add(cand[i]);\\n            findComb(cand, targ, currSum + cand[i], currComb, i + 1);\\n            currComb.RemoveAt(currComb.Count - 1);\\n            prev = cand[i];\\n        } \\n```"
                    },
                    {
                        "username": "21bcs069",
                        "content": "i get memory limit exceeded \\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\nand target 27\\nhow to overcome."
                    },
                    {
                        "username": "harshvardhan1483",
                        "content": "Please Help!!\nMy code is working when I'm using this  \n `private void helper(int index , List<List<Integer>> res , List<Integer> temp , int[] candidates , int target){\n         if(index>=candidates.length){\n             if(target==0){\n                 List<Integer> list = new ArrayList<>(temp);\n                 res.add(list);\n             }\n             return;\n         }\n         \n        if (target < 0) {\n            return;\n        }\n\n        // Include the current candidate\n        temp.add(candidates[index]);\n        helper(index + 1, res, temp, candidates, target - candidates[index]);\n        temp.remove(temp.size() - 1);\n\n        // Skip duplicates\n        while (index < candidates.length - 1 && candidates[index] == candidates[index + 1]) {\n            index++;\n        }\n        helper(index+1,res,temp,candidates,target);\n    }`\nBut it is failing when I'm changing the loop condition to:\n\n `while (index > 0 && candidates[index] == candidates[index - 1]) {\n            index++;\n        }`\n\nCan you help??"
                    },
                    {
                        "username": "amansingh4958",
                        "content": "sort the given array so that you can avoid the duplicate elements in the helper function\\n(everything else is same as combination sum - I)"
                    },
                    {
                        "username": "Amey_123",
                        "content": "class Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        sort(candidates.begin(),candidates.end());\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int index;\\n        \\n        solve(ans,v,candidates,target ,index);\\n        return ans;\\n\\n    }\\n\\n    void solve(vector<vector<int>> &ans,vector<int> v,vector<int>& candidates,int target,int index)\\n    {\\n        if(target==0){\\n            ans.push_back(v);\\n            return;\\n        }\\n        if(target<0)\\n        {\\n            return;\\n        }\\n\\n        for(int i=index;i<candidates.size();i++)\\n        {\\n            if(i>index && candidates[i]==candidates[i-1])\\n            {\\n                continue;\\n            }\\n            v.push_back(candidates[i]);\\n            solve(ans,v,candidates,target-candidates[i] ,i+1);\\n            v.pop_back();\\n        }\\n    }\\n};\\n\\nWhy is this code isn\\'t giving any output?\\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "vector<vector> ans;  #this is wrong .\nvector<vector<   int>    > ans;  #this is right\n\nvector v;  #wrong\nvector<   int    > v; #right\n\nint index;  #this is wrong\nint index =0; # this is right. specify the starting index\n\n\neverything else seems correct\n\n"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "https://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/    check my solution"
                    },
                    {
                        "username": "s3stan",
                        "content": "vector<vector> combinationSum2(vector& candidates, int target) {\\nsort(candidates.begin(),candidates.end());\\nvector<vector> ans;\\nvectorv;\\nint index; <<<<==== // here you need int index = 0;\\n\\n    solve(ans,v,candidates,target ,index);\\n    return ans;\\n}"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "anyone who is having a hard time solving this problem. \\nhere is my written solution with proper dry run and recurtion tree.\\ndont forget to upvote\\u2764\\uFE0F\\u200D\\uD83D\\uDD25\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/3866692/easy-explanation-using-images-and-dry-run-using-set-without-set/"
                    }
                ]
            },
            {
                "id": 2004828,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1997800,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1984747,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1957769,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1948099,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1937812,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1930902,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1925393,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1922337,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1818568,
                "content": [
                    {
                        "username": "s3stan",
                        "content": "When solving the problem, one should take into account the fact that the combinations must be sorted.\nSo 2.1.5 is 1.2.5. Further 7.1 is 1.7. And after sorting, they are considered the same, but only unique ones are needed.\nHence it turns out that [[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]] becomes [[1,1,6],[1,2,5],[1,7],[2,6]]."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "As a brute force first try I did\\n```\\n        # brute force, combinations\\n        combs = []\\n        for i in range(1, len(candidates)):\\n            for c in combinations(candidates, i):\\n                combs.append(c)\\n        ans = []\\n        for c in combs:\\n            if sum(c) == target: ans.append(c)\\n        return ans\\n```\\nand I get output\\n```\\nOutput\\n[[1,7],[2,6],[7,1],[1,2,5],[1,6,1],[2,1,5]]\\nExpected\\n[[1,1,6],[1,2,5],[1,7],[2,6]]\\n```\\nCan someone explain what I\\'m doing wrong?"
                    },
                    {
                        "username": "Gyanshu152",
                        "content": "sort first"
                    },
                    {
                        "username": "Prakhar2909",
                        "content": "Showing memory limit exceed\\nTest Case 172\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =\\n30\\nWhat to do to reduce memory\\n\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> all_sum;\\n    vector<int> curr;\\n    void rec(int level, int k_left, vector<int> &candidates, int target)\\n    {\\n        int n = candidates.size();\\n        if (k_left < 0)\\n        {\\n            return;\\n        }\\n\\n        if (level == n)\\n        {\\n            if (k_left == 0)\\n            {\\n                all_sum.push_back(curr);\\n            }\\n            return;\\n        }\\n        if (k_left >= candidates[level])\\n        {\\n            curr.push_back(candidates[level]);\\n\\n            rec(level + 1, k_left - candidates[level], candidates, target);\\n            curr.pop_back();\\n        }\\n        rec(level + 1, k_left, candidates, target);\\n    }\\n    vector<vector<int>> combinationSum2(vector<int> &candidates, int target)\\n    {\\n        \\n        rec(0, target, candidates, target);\\n        map<vector<int>, int> mp;\\n        vector<vector<int>> new_sol;\\n        for (auto i : all_sum)\\n        {\\n            sort(i.begin(), i.end());\\n            mp[i]++;\\n        }\\n        for (auto i : mp)\\n        {\\n            new_sol.push_back(i.first);\\n        }\\n        return new_sol;\\n        }\\n};"
                    },
                    {
                        "username": "countdankula",
                        "content": "`Input: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]`\\n\\nFor anybody who is confused about why there are two `1`s in the answer `[1,1,6]` when it is clearly mentioned that `Each number in candidates may only be used once` in the combination: the actual solution should have been `[1,6,1]` because if you look carefully in the candidate set, first `1` comes, then `6` and then the second `1` comes in this order.  So normally the solution should have been `[1,6,1]`.\\n\\nBut the combinations here are returned in `sorted order`, hence when we sort `[1,6,1]`, we get` [1,1,6]`. (Although, Leetcode should have mentioned that they needed a sorted order)."
                    },
                    {
                        "username": "chad_giga",
                        "content": "class Solution {\npublic:\nvector<vector<int>>ans;\nvoid help(vector<int>ip,vector<int>op,int target,int sum)\n{\n    if(sum==target)\n    {\n        ans.push_back(op);\n    }\n    if(sum> target)return;\n    \n        vector<int>op1=op;\n        vector<int>op2=op;\n        op2.push_back(ip[0]);\n        int sum1=sum;\n        int sum2=sum+ip[0];\n        ip.erase(ip.begin()+0);\n        help(ip,op1,target,sum1);\n        help(ip,op2,target,sum2);\n        return;\n}\n vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<int> op;\n        vector<vector<int>> ans;\n        int sum=0;\n        help(candidates,op,target,sum);\n        return ans; }\n};\nCan someone tell me what is wrong with the following code?"
                    },
                    {
                        "username": "2030019",
                        "content": "vector<vector> ans; - This is not how you declare a vector of vector. It should be declared as - vector<vector<int>> ans"
                    },
                    {
                        "username": "spookie886",
                        "content": "somehow i think this is easier than combonation sum 1, anybody agree?"
                    },
                    {
                        "username": "RaulS0s4",
                        "content": "problem has a bug, whenever you add a custom test case, it spoils the others making the \"expected value\" == null"
                    },
                    {
                        "username": "aman3091",
                        "content": "why my code is not working properly help \\nclass Solution {\\npublic:\\n     void solve(vector<int> array, int target, set<vector<int>>&ans, vector<int>op,int i,int sum){\\n          if (sum > target||i >= array.size()) {\\n            return;\\n        }\\n        if (sum == target) {\\n            ans.insert(op);\\n            return;\\n        }\\n       \\n\\n        op.push_back(array[i]);\\n        solve(array, target, ans, op, i + 1, sum + array[i]);\\n        op.pop_back();\\n        solve(array, target, ans, op, i + 1, sum);\\n        }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>>ans;\\n        vector<int>op;\\n        sort(candidates.begin(),candidates.end());\\n        solve(candidates,target,ans,op,0,0);\\n        vector<vector<int>>ans2;\\n        for(auto i=ans.begin();i!=ans.end();i++){\\n            ans2.push_back(*i);\\n        }\\n        return ans2;\\n    }\\n};\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "can anyone tell me what is the problem with this. if test cases are : [1] target=1,    [1,1] target =1;\\nwhy this is showing run time error for these cases?\\n\\nclass Solution {\\n\\t\\npublic:\\n   vector<vector<int>> v;\\nvoid f(vector<int> &a,int i,int target,vector<int> &e)\\n{\\n\\n\\tif(target==0)\\n\\t{\\n\\t\\tv.push_back(e);\\n\\t\\treturn;\\n\\t}\\n\\tif(target<a[i] || i>=a.size())\\n\\t{\\n\\t\\treturn;\\n\\t}\\n\\t\\n\\te.push_back(a[i]);\\n\\tf(a,i+1,target-a[i],e);\\n\\te.pop_back();\\n\\tf(a,i+1,target,e);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int targe) {\\n\\t\\t\\tvector<int> e;\\n\\t\\t\\t\\n    \\n\\tsort(candidates.begin(),candidates.end());\\n\\tf(candidates,0,targe,e);\\n    sort(v.begin(),v.end());\\n\\tfor(int i=1;i<v.size();i++)\\n\\t{\\n\\t\\tif(v[i]==v[i-1])\\n\\t\\t{\\n\\t\\t\\tv.erase(v.begin()+i);\\n\\t\\t\\t--i;\\n\\t\\t}\\n\\t}\\n\\t\\n    return v;\\n    \\n\\t\\t}"
                    },
                    {
                        "username": "yashasvtuli11",
                        "content": " `class Solution {\\npublic:\\n    void solve(int ind, int target,vector<int>arr,vector<vector<int>> &ans,vector<int>& output)\\n    {\\n            if(target==0){   \\n              ans.push_back(output);\\n              return;}\\n          \\n          for(int i=ind;i<arr.size();i++)\\n          {  if(i > ind && arr[i] == arr[i - 1] )continue;\\n              if(arr[i]>target) break;\\n              output.push_back(arr[i]);\\n              solve(ind  + 1, target - arr[i] , arr,ans, output);\\n              output.pop_back();}\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) {\\n        sort(arr.begin(),arr.end());\\n       vector<int> output;\\n        vector<vector<int>> ans;\\n          \\n         solve(0,target,arr,ans,output);\\n\\n         return ans;\\n    }\\n};`\\ncan anyone tell me what\\'s my mistake in this code?\\n"
                    },
                    {
                        "username": "Koshal_1",
                        "content": "at initial i=ind=0 and arr[0]=arr[-1] so pay attention on arr[-1]"
                    }
                ]
            },
            {
                "id": 1808121,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1806997,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1800119,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1788823,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1777795,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1775087,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1767902,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1752615,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1740987,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            },
            {
                "id": 1735773,
                "content": [
                    {
                        "username": "MohammadFaizel",
                        "content": "class Solution {\\npublic:\\nbool isValid(vector<vector<int>>& ans , vector<int>& temp)\\n{\\n    for(int i = 0;i< ans.size();++i)\\n    {\\n        if(ans[i] == temp) return false;\\n    }\\n    return true;\\n}\\n    void solve(vector<int>& candidates , int target,int i ,vector<vector<int>>& ans , vector<int>& temp,int sum)\\n    {\\n        if(i >= candidates.size())//index out of bound\\n        {\\n            return;\\n        }\\n        if(sum == target) //valid answer found \\n        {\\n            sort(temp.begin(),temp.end());\\n            if(isValid(ans , temp)){\\n            ans.emplace_back(temp);}\\n            return;\\n        }\\n        else if(sum > target) return;   //ans not possible go back \\n        \\n        //choose current elemnent\\n        sum += candidates[i];\\n        temp.emplace_back(candidates[i]);\\n        solve(candidates , target , i+1 , ans , temp , sum); //not moving index as we can choose same element twice\\n        temp.pop_back();    //remove the chosen item for other option\\n        sum -= candidates[i];   //decrease current item value\\n        solve(candidates , target , i+1 ,ans, temp , sum);  //move to next item \\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n        int sum = 0;\\n        sort(candidates.begin() , candidates.end());\\n        solve(candidates , target , 0 , ans , temp , sum);\\n        return ans;\\n    }\\n};\\n\\n\\n\\n//can anyone please explain why testcase-2 fails. "
                    },
                    {
                        "username": "rahulmajhi0123",
                        "content": "why is my code giving a wrong array?\\n\\nclass Solution {\\npublic:\\nvoid func(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds)\\n{\\n    if(i==arr.size())\\n        {\\n            if(target==0)\\n            {\\n                sort(ds.begin(),ds.end());\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        if(arr[i]<=target)\\n        {\\n            ds.push_back(arr[i]);\\n            func(i+1,arr,target-arr[i],ans,ds);\\n            ds.pop_back();        \\n        }\\n        func(i+1,arr,target,ans,ds);\\n}\\n    vector<vector<int>> combinationSum2(vector<int>& arr, int target) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        func(0,arr,target,ans,ds);\\n        sort(ans.begin(),ans.end());\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            if (ans[i]==ans[i+1])\\n            ans.erase(ans.begin()+i);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": " `Output\\n[[1,7],[1,6,1],[2,6],[7,1]]`\\nExpected\\n`[[1,1,6],[1,2,5],[1,7],[2,6]]`\\n\\nGuess the question should mention the order of the combination as well?"
                    },
                    {
                        "username": "userGupta_2425",
                        "content": "can anyone tell me what is the error in my code:\\nits not working for the test case \\n\\ncandidates = [2,5,2,1,2]\\ntarget = 5\\nOutput [[1,2,2]]\\nExpected [[1,2,2],[5]]\\n\\nclass Solution {\\nprivate:\\n    void findUnique(vector<int>& candidates, int target,int i,int sum,vector<int>&subsets,vector<vector<int>>&ans)\\n    {\\n        //base case1\\n        if(i==candidates.size())\\n            return;\\n        //base case2\\n        if(sum>target)\\n            return;\\n        //base case3\\n        if(sum==target)\\n        {\\n            ans.push_back(subsets);\\n            return;\\n        }    \\n\\n        //considering the ith element\\n        subsets.push_back(candidates[i]); \\n        sum+=candidates[i];\\n        \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n\\n        //not considering the ith element\\n        subsets.pop_back();\\n        sum-=candidates[i];\\n        while(i+1<candidates.size() && candidates[i]==candidates[i+1])\\n        {\\n            i++;\\n        } \\n        findUnique(candidates,target,i+1,sum,subsets,ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) \\n    {\\n        sort(candidates.begin(),candidates.end());\\n        vector<int>subsets;\\n        vector<vector<int>>ans;\\n        int sum=0;\\n        findUnique(candidates,target,0,sum,subsets,ans);\\n        return ans;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "My code doesn\\'t seem to be working for the second testcase : \\ncandidates = [2,5,2,1,2], target = 5\\nActual output = [[1,1,2],[1,2,2],[5]]\\nExpected output = [[1,2,2],[5]]\\n\\nI tried to draw the recursion tree and check the flow, still couldn\\'t figure out, can anyone pls help me out ??\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        set<vector<int>> ans;\\n        vector<int> ss;\\n        ans = combinationSumLogic(0, ss, target, candidates, ans);\\n        vector<vector<int>> ans1;\\n        for (auto it: ans) {\\n            ans1.push_back(it);\\n        }\\n        return ans1;\\n    }\\n    set<vector<int>> combinationSumLogic(int i, vector<int> &ss, int k, vector<int> &arr, set<vector<int>> &ans) {\\n        if (k == 0) {\\n            sort(ss.begin(), ss.end());\\n            ans.insert(ss);\\n            return ans;\\n        }\\n        if (i == arr.size()) {\\n            return ans;\\n        }\\n        if (k > 0) {\\n            ss.push_back(arr[i]);\\n            ans = combinationSumLogic(i+1, ss, k-arr[i], arr, ans);\\n            ss.pop_back();\\n            ans = combinationSumLogic(i+1, ss, k, arr, ans);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gni7",
                        "content": "got it, seems like i am sorting the same sub sequence list which is affecting the sub sequent recursion calls, sorting the duplicate copy instead of original solved it."
                    },
                    {
                        "username": "bhavika2210",
                        "content": "TIME LIMITED EXCEEDED 172/176 cases passing\n\nCan anyone kindly suggest why is tle happening and how can I improve the code .\nThanks !\n```class Solution {\npublic:\n// created a set of vectors to store unique combinations. \nvector<vector<int>>ans;\nset<vector<int>>s;\nvector<int>dummy;\n    void func(vector<int>& candidates, int target,vector<int>&temp,int id)\n    {\n        if(id>=candidates.size()){\n            if(target==0)\n            {\n              dummy=temp;  //took a dummy vector because sorting temp will change the order of pop that follows after the return from first function call\n              sort(dummy.begin(),dummy.end());\n              s.insert(dummy);           \n            }\n            return ;\n        }\n\n        // pick\n        if(candidates[id]<=target)\n        {\n            temp.push_back(candidates[id]);\n            func(candidates,target-candidates[id],temp,id+1);\n            temp.pop_back();\n        }\n        \n        func(candidates,target,temp,id+1);\n\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n         vector<int>temp;\n        func(candidates,target, temp,0);\n        for(auto x:s)\n         ans.push_back(x);\n        return ans;\n    }\n};\n```"
                    },
                    {
                        "username": "averagestudent07",
                        "content": "did u find the better approach? I am also having the same doubt."
                    },
                    {
                        "username": "gni7",
                        "content": "Hello Bhavika,\\nLeetcode is probably expecting you to provide solution with better time complexity, so you\\'re getting TLE error for few datasets\\nTC for your solution seems to be : O(2^n * klogk * k*logx), where n = arr size, k = sub seq size, x = ans size\\nTry a way to improve this, there you go !"
                    },
                    {
                        "username": "tanmay_jadav",
                        "content": "Can someone suggest me what\\'s problem in my code?\\n\\ndef fcomb2(ind,tar,arr,ans,ds):\\n    if target==0:\\n        ans.append([ele for ele in ds])\\n        return \\n    n=len(arr)\\n\\n    for i in range(ind,n):\\n        if i>ind and arr[i]==arr[i-1]:\\n            continue\\n        if arr[i]>target:\\n            break\\n        ds.append(arr[i])\\n        fcomb2(i+1,target-arr[i],arr,ans,ds)\\n        ds.pop()\\n\\narr=[10,1,2,7,6,1,5]\\ntarget=8\\nans=[]\\narr.sort()\\nfcomb2(0,target,arr,ans,[])"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Sarthakk_007",
                        "content": " \\n`\\nclass Solution {\\npublic:\\n\\n    void finall(vector<int>& candidates, vector<int> temp, vector<vector<int>> &ans,int target,int len)\\n    {\\n\\n        if(target==0)\\n        {\\n            sort(temp.begin(),temp.end());\\n\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(temp==ans[i])\\n                return;\\n            }\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        if(len==0)\\n        {\\n            return ;\\n        }\\n\\n        if(candidates[len-1]<=target)\\n        {\\n          temp.push_back(candidates[len-1]);\\n          finall(candidates,temp,ans,target-candidates[len-1],len-1);\\n\\n          temp.pop_back();\\n          finall(candidates,temp,ans,target,len-1);\\n        }\\n\\n        else \\n        { \\n            finall(candidates,temp,ans,target,len-1);\\n        }\\n    }\\n\\n\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n\\n        vector<int> temp;\\n        vector<vector<int>> ans;\\n\\n        int len=candidates.size();\\n        finall(candidates,temp,ans,target,len);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n`\\n\\ncan someone pls tell me whats wrng in this code? \\n\\nits show time limit exceeded for a particular test case!! \\n\\ncandidates =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]\\n\\ntarget =27\\n"
                    },
                    {
                        "username": "ramadanizm",
                        "content": "Why this test edge case case gives me  time limit exceeded ? \\npassed 171 / 176 so far .\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n    List<List<Integer>> result  = new ArrayList<>();\\n    if (candidates == null || candidates.length == 0) return result;\\n     \\n    List<Integer> path = new ArrayList<>(); \\n    Arrays.sort(candidates); \\n    Set<List<Integer>> resultSet = new HashSet<>(); \\n    \\n    combinationSumHelper(candidates , target , 0 ,  path , resultSet);\\n\\n    return new ArrayList<>(resultSet); // convert set of list into list of list\\n        \\n    }\\n\\n    public void combinationSumHelper(int[] candidates, int target , int startIdx ,  List<Integer> path , Set<List<Integer>> resultSet ){\\n     \\n    // save the result first if we are not allowed to use the same element more than once \\n    if ( target == 0){ // it could be <= 0 too\\n        // System.out.println(path);         \\n         if (! resultSet.contains(path)){\\n             //System.out.println(path);\\n            resultSet.add(new ArrayList<>(path)); // Should be new ArrayList\\n         }\\n         return;\\n    } \\n\\n  // base case\\n    if (startIdx >= candidates.length || target < 0 ) return;\\n\\n\\n    // include the element , update the target/condition , update the result/path , moveforard / cut the input .\\n    if(target >= candidates[startIdx] ){ // backtracking\\n      path.add(candidates[startIdx]); // as alternative , update the path inside the backtracking  function so no need to remove it .\\n      combinationSumHelper (candidates, target -  candidates[startIdx] , startIdx +1 , path , resultSet  ); // We could not use the same element more than once so startIdx + 1\\n      path.remove(path.size()-1);\\n    }\\n    \\n    // do not include th element\\n    combinationSumHelper (candidates, target , startIdx + 1 , path , resultSet  );\\n\\n    }\\n}\\n```"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Even my brute force approach suffered tle in c++"
                    }
                ]
            }
        ]
    },
    {
        "title": "Word Break II",
        "question_content": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, add spaces in <code>s</code> to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in <strong>any order</strong>.</p>\n\n<p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsanddog&quot;, wordDict = [&quot;cat&quot;,&quot;cats&quot;,&quot;and&quot;,&quot;sand&quot;,&quot;dog&quot;]\n<strong>Output:</strong> [&quot;cats and dog&quot;,&quot;cat sand dog&quot;]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;pineapplepenapple&quot;, wordDict = [&quot;apple&quot;,&quot;pen&quot;,&quot;applepen&quot;,&quot;pine&quot;,&quot;pineapple&quot;]\n<strong>Output:</strong> [&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]\n<strong>Explanation:</strong> Note that you are allowed to reuse a dictionary word.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;,&quot;dog&quot;,&quot;sand&quot;,&quot;and&quot;,&quot;cat&quot;]\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>1 &lt;= wordDict.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= wordDict[i].length &lt;= 10</code></li>\n\t<li><code>s</code> and <code>wordDict[i]</code> consist of only lowercase English letters.</li>\n\t<li>All the strings of <code>wordDict</code> are <strong>unique</strong>.</li>\n\t<li>Input is generated in a way that the length of the answer doesn&#39;t exceed&nbsp;10<sup>5</sup>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 44167,
                "title": "my-concise-java-solution-based-on-memorized-dfs",
                "content": "**Explanation**\\n\\nUsing DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches, as the following:\\n \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<String, LinkedList<String>>());\\n    }       \\n    \\n    // DFS function returns an array including all substrings derived from s.\\n    List<String> DFS(String s, Set<String> wordDict, HashMap<String, LinkedList<String>>map) {\\n        if (map.containsKey(s)) \\n            return map.get(s);\\n            \\n        LinkedList<String>res = new LinkedList<String>();     \\n        if (s.length() == 0) {\\n            res.add(\"\");\\n            return res;\\n        }               \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                List<String>sublist = DFS(s.substring(word.length()), wordDict, map);\\n                for (String sub : sublist) \\n                    res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);               \\n            }\\n        }       \\n        map.put(s, res);\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nUsing DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches, as the following:\\n \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<String, LinkedList<String>>());\\n    }       \\n    \\n    // DFS function returns an array including all substrings derived from s.\\n    List<String> DFS(String s, Set<String> wordDict, HashMap<String, LinkedList<String>>map) {\\n        if (map.containsKey(s)) \\n            return map.get(s);\\n            \\n        LinkedList<String>res = new LinkedList<String>();     \\n        if (s.length() == 0) {\\n            res.add(\"\");\\n            return res;\\n        }               \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                List<String>sublist = DFS(s.substring(word.length()), wordDict, map);\\n                for (String sub : sublist) \\n                    res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);               \\n            }\\n        }       \\n        map.put(s, res);\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44311,
                "title": "python-easy-to-understand-solution",
                "content": "    class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(s, wordDict, {})\\n        \\n    def helper(self, s, wordDict, memo):\\n        if s in memo: return memo[s]\\n        if not s: return []\\n        \\n        res = []\\n        for word in wordDict:\\n            if not s.startswith(word):\\n                continue\\n            if len(word) == len(s):\\n                res.append(word)\\n            else:\\n                resultOfTheRest = self.helper(s[len(word):], wordDict, memo)\\n                for item in resultOfTheRest:\\n                    item = word + ' ' + item\\n                    res.append(item)\\n        memo[s] = res\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(s, wordDict, {}",
                "codeTag": "Java"
            },
            {
                "id": 2996989,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void solve(string s, vector<string>& res, unordered_set<string>& st, vector<string>&temp){\\n        if(s.length() == 0){\\n            string str = \"\";\\n            for(auto it:temp){\\n                str += it + \" \";\\n            }\\n            str.pop_back();\\n            res.push_back(str);\\n            return;\\n        }\\n        for(int i=0;i<s.length(); i++){\\n            if(st.count(s.substr(0, i+1))){\\n                temp.push_back(s.substr(0, i+1));\\n                solve(s.substr(i+1), res, st, temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string>res, temp;\\n        unordered_set<string>st(wordDict.begin(), wordDict.end());\\n        \\n        solve(s, res, st, temp);\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```\\n\\n```Java []\\nclass Solution {\\n    private void helper(String s, int i, Set<String> dict, List<String> cur, List<String> res) {\\n        if (i == s.length()) {\\n            if (cur.size() > 0) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 0; j < cur.size(); j++) {\\n                    if (j > 0) {\\n                        sb.append(\\' \\');\\n                    }\\n                    sb.append(cur.get(j));\\n                }\\n                res.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        for (int j = i+1; j <= s.length(); j++) {\\n            if (dict.contains(s.substring(i, j))) {\\n                cur.add(s.substring(i, j));\\n                helper(s, j, dict, cur, res);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> dict = new HashSet<>(wordDict);\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        helper(s, 0, dict, cur, res);\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void solve(string s, vector<string>& res, unordered_set<string>& st, vector<string>&temp){\\n        if(s.length() == 0){\\n            string str = \"\";\\n            for(auto it:temp){\\n                str += it + \" \";\\n            }\\n            str.pop_back();\\n            res.push_back(str);\\n            return;\\n        }\\n        for(int i=0;i<s.length(); i++){\\n            if(st.count(s.substr(0, i+1))){\\n                temp.push_back(s.substr(0, i+1));\\n                solve(s.substr(i+1), res, st, temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string>res, temp;\\n        unordered_set<string>st(wordDict.begin(), wordDict.end());\\n        \\n        solve(s, res, st, temp);\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```\n```Java []\\nclass Solution {\\n    private void helper(String s, int i, Set<String> dict, List<String> cur, List<String> res) {\\n        if (i == s.length()) {\\n            if (cur.size() > 0) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 0; j < cur.size(); j++) {\\n                    if (j > 0) {\\n                        sb.append(\\' \\');\\n                    }\\n                    sb.append(cur.get(j));\\n                }\\n                res.add(sb.toString());\\n            }\\n            return;\\n        }\\n\\n        for (int j = i+1; j <= s.length(); j++) {\\n            if (dict.contains(s.substring(i, j))) {\\n                cur.add(s.substring(i, j));\\n                helper(s, j, dict, cur, res);\\n                cur.remove(cur.size() - 1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> dict = new HashSet<>(wordDict);\\n        List<String> res = new ArrayList<>();\\n        List<String> cur = new ArrayList<>();\\n        helper(s, 0, dict, cur, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44178,
                "title": "11ms-c-solution-concise",
                "content": "    class Solution {\\n        unordered_map<string, vector<string>> m;\\n    \\n        vector<string> combine(string word, vector<string> prev){\\n            for(int i=0;i<prev.size();++i){\\n                prev[i]+=\" \"+word;\\n            }\\n            return prev;\\n        }\\n    \\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string>& dict) {\\n            if(m.count(s)) return m[s]; //take from memory\\n            vector<string> result;\\n            if(dict.count(s)){ //a whole string is a word\\n                result.push_back(s);\\n            }\\n            for(int i=1;i<s.size();++i){\\n                string word=s.substr(i);\\n                if(dict.count(word)){\\n                    string rem=s.substr(0,i);\\n                    vector<string> prev=combine(word,wordBreak(rem,dict));\\n                    result.insert(result.end(),prev.begin(), prev.end());\\n                }\\n            }\\n            m[s]=result; //memorize\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        unordered_map<string, vector<string>> m;\\n    \\n        vector<string> combine(string word, vector<string> prev){\\n            for(int i=0;i<prev.size();++i){\\n                prev[i]+=\" \"+word;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 44169,
                "title": "9-lines-python-10-lines-c",
                "content": "`sentences(i)` returns a list of all sentences that can be built from the suffix `s[i:]`.\\n\\n**Python:**\\n\\n    def wordBreak(self, s, wordDict):\\n        memo = {len(s): ['']}\\n        def sentences(i):\\n            if i not in memo:\\n                memo[i] = [s[i:j] + (tail and ' ' + tail)\\n                           for j in range(i+1, len(s)+1)\\n                           if s[i:j] in wordDict\\n                           for tail in sentences(j)]\\n            return memo[i]\\n        return sentences(0)\\n\\n**C++:**\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        unordered_map<int, vector<string>> memo {{s.size(), {\"\"}}};\\n        function<vector<string>(int)> sentences = [&](int i) {\\n            if (!memo.count(i))\\n                for (int j=i+1; j<=s.size(); j++)\\n                    if (wordDict.count(s.substr(i, j-i)))\\n                        for (string tail : sentences(j))\\n                            memo[i].push_back(s.substr(i, j-i) + (tail==\"\" ? \"\" : ' ' + tail));\\n            return memo[i];\\n        };\\n        return sentences(0);\\n    }",
                "solutionTags": [
                    "Python"
                ],
                "code": "`sentences(i)` returns a list of all sentences that can be built from the suffix `s[i:]`.\\n\\n**Python:**\\n\\n    def wordBreak(self, s, wordDict):\\n        memo = {len(s): ['']}\\n        def sentences(i):\\n            if i not in memo:\\n                memo[i] = [s[i:j] + (tail and ' ' + tail)\\n                           for j in range(i+1, len(s)+1)\\n                           if s[i:j] in wordDict\\n                           for tail in sentences(j)]\\n            return memo[i]\\n        return sentences(0)\\n\\n**C++:**\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        unordered_map<int, vector<string>> memo {{s.size(), {\"\"}}};\\n        function<vector<string>(int)> sentences = [&](int i) {\\n            if (!memo.count(i))\\n                for (int j=i+1; j<=s.size(); j++)\\n                    if (wordDict.count(s.substr(i, j-i)))\\n                        for (string tail : sentences(j))\\n                            memo[i].push_back(s.substr(i, j-i) + (tail==\"\" ? \"\" : ' ' + tail));\\n            return memo[i];\\n        };\\n        return sentences(0);\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 1241504,
                "title": "c-0ms-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        //insert all the words in the set\\n        unordered_set<string> set;\\n        vector<string> res;\\n        for(auto word:wordDict)\\n            set.insert(word);\\n        //to store the current string \\n        string curr=\"\";\\n        findHelper(0,s,curr,set,res);\\n        return res;\\n    }\\n    \\n    void findHelper(int ind,string s,string curr,unordered_set<string> set,vector<string>& res)\\n    {\\n        if(ind==s.length())\\n        {\\n            //we have reached end\\n            curr.pop_back(); //remove the trailing space\\n            res.push_back(curr);\\n        }\\n        string str=\"\";\\n        for(int i=ind;i<s.length();i++)\\n        {\\n            //get every substring and check if it exists in set\\n            str.push_back(s[i]);\\n            if(set.count(str))\\n            {\\n                //we have got a word in dict \\n                //explore more and get other substrings\\n                findHelper(i+1,s,curr+str+\" \",set,res);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        //insert all the words in the set\\n        unordered_set<string> set;\\n        vector<string> res;\\n        for(auto word:wordDict)\\n            set.insert(word);\\n        //to store the current string \\n        string curr=\"\";\\n        findHelper(0,s,curr,set,res);\\n        return res;\\n    }\\n    \\n    void findHelper(int ind,string s,string curr,unordered_set<string> set,vector<string>& res)\\n    {\\n        if(ind==s.length())\\n        {\\n            //we have reached end\\n            curr.pop_back(); //remove the trailing space\\n            res.push_back(curr);\\n        }\\n        string str=\"\";\\n        for(int i=ind;i<s.length();i++)\\n        {\\n            //get every substring and check if it exists in set\\n            str.push_back(s[i]);\\n            if(set.count(str))\\n            {\\n                //we have got a word in dict \\n                //explore more and get other substrings\\n                findHelper(i+1,s,curr+str+\" \",set,res);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44243,
                "title": "java-dp-dfs-memoization-dfs-and-dp-pruning-solutions-with-analysis",
                "content": "I've been struggling with this problem for a long time, and I'd love to share three different strategies I have tried to solve it. All of them are ACed. \\n\\nMethod 1: DP + DFS. Very similar to Word Break I, but instead of using a boolean dp array, I used an array of Lists to maintain all of the valid start positions for every end position. Then just do classic backtracking to find all solutions. The time complexity is O(n*m) + O(n * number of solutions), where n is the length of the input string, m is the length of the longest word in the dictionary. The run time was 6ms. It is very efficient because DP is used to find out all the valid answers, and no time is wasted on doing the backtracking. \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<Integer>[] starts = new List[s.length() + 1]; // valid start positions\\n        starts[0] = new ArrayList<Integer>();\\n        \\n        int maxLen = getMaxLen(wordDict);\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = i - 1; j >= i - maxLen && j >= 0; j--) {\\n                if (starts[j] == null) continue;\\n                String word = s.substring(j, i);\\n                if (wordDict.contains(word)) {\\n                    if (starts[i] == null) {\\n                        starts[i] = new ArrayList<Integer>();\\n                    }\\n                    starts[i].add(j);\\n                }\\n            }\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (starts[s.length()] == null) {\\n            return rst;\\n        }\\n        \\n        dfs(rst, \"\", s, starts, s.length());\\n        return rst;\\n    }\\n\\n  \\n    private void dfs(List<String> rst, String path, String s, List<Integer>[] starts, int end) {\\n        if (end == 0) {\\n            rst.add(path.substring(1));\\n            return;\\n        }\\n        \\n        for (Integer start: starts[end]) {\\n            String word = s.substring(start, end);\\n            dfs(rst, \" \" + word + path, s, starts, start);\\n        }\\n    }\\n\\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\nMethod 2: Memoization + Backtracking. Before I came up with Method 1, I also tried using a HashMap to memoize all the possible strings that can be formed starting from index i. I referred to this post from [@Pixel_][1] \\nThe time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) as @Pixel_ mentioned. The space complexity would be larger than other methods though. Here is my code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        HashMap<Integer, List<String>> memo = new HashMap<>(); // <Starting index, rst list>\\n        return dfs(s, 0, wordDict, memo);\\n    }\\n    \\n    private List<String> dfs(String s, int start, Set<String> dict, HashMap<Integer, List<String>> memo) {\\n        if (memo.containsKey(start)) {\\n            return memo.get(start);\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (start == s.length()) {\\n            rst.add(\"\");\\n            return rst;\\n        }\\n        \\n        String curr = s.substring(start);\\n        for (String word: dict) {\\n            if (curr.startsWith(word)) {\\n                List<String> sublist = dfs(s, start + word.length(), dict, memo);\\n                for (String sub : sublist) {\\n                    rst.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);\\n                }\\n            }\\n        }\\n        \\n        memo.put(start, rst);\\n        return rst;\\n    }\\n\\nMethod 3: DP Prunning + Backtracking. My very first solution is like this: using a boolean array to memoize whether a substring starting from position i to the end is breakable. This works well for worst cases like: s = \"aaaaaaaaaaaab\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"]. However, for cases like: s = \"aaaaaaaaaaaaa\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"], the time complexity is still O(2^n). Here is the code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<String> rst = new ArrayList<>();\\n        if (s == null || s.length() == 0 || wordDict == null) {\\n            return rst;\\n        }\\n        \\n        boolean[] canBreak = new boolean[s.length()];\\n        Arrays.fill(canBreak, true);\\n        StringBuilder sb = new StringBuilder();\\n        dfs(rst, sb, s, wordDict, canBreak, 0);\\n        return rst;\\n    }\\n    \\n    private void dfs(List<String> rst, StringBuilder sb, String s, Set<String> dict, \\n        boolean[] canBreak, int start) {\\n        if (start == s.length()) {\\n            rst.add(sb.substring(1));\\n            return;\\n        }\\n        \\n        if (!canBreak[start]) {\\n            return;\\n        }\\n        \\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String word = s.substring(start, i);\\n            if (!dict.contains(word)) continue;\\n            \\n            int sbBeforeAdd = sb.length();\\n            sb.append(\" \" + word);\\n            \\n            int rstBeforeDFS = rst.size();\\n            dfs(rst, sb, s, dict, canBreak, i);\\n            if (rst.size() == rstBeforeDFS) {\\n                canBreak[i] = false;\\n            }\\n            sb.delete(sbBeforeAdd, sb.length());\\n        }\\n    }\\n    \\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/65692/my-concise-java-solution-based-on-memorized-dfs",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "I've been struggling with this problem for a long time, and I'd love to share three different strategies I have tried to solve it. All of them are ACed. \\n\\nMethod 1: DP + DFS. Very similar to Word Break I, but instead of using a boolean dp array, I used an array of Lists to maintain all of the valid start positions for every end position. Then just do classic backtracking to find all solutions. The time complexity is O(n*m) + O(n * number of solutions), where n is the length of the input string, m is the length of the longest word in the dictionary. The run time was 6ms. It is very efficient because DP is used to find out all the valid answers, and no time is wasted on doing the backtracking. \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<Integer>[] starts = new List[s.length() + 1]; // valid start positions\\n        starts[0] = new ArrayList<Integer>();\\n        \\n        int maxLen = getMaxLen(wordDict);\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = i - 1; j >= i - maxLen && j >= 0; j--) {\\n                if (starts[j] == null) continue;\\n                String word = s.substring(j, i);\\n                if (wordDict.contains(word)) {\\n                    if (starts[i] == null) {\\n                        starts[i] = new ArrayList<Integer>();\\n                    }\\n                    starts[i].add(j);\\n                }\\n            }\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (starts[s.length()] == null) {\\n            return rst;\\n        }\\n        \\n        dfs(rst, \"\", s, starts, s.length());\\n        return rst;\\n    }\\n\\n  \\n    private void dfs(List<String> rst, String path, String s, List<Integer>[] starts, int end) {\\n        if (end == 0) {\\n            rst.add(path.substring(1));\\n            return;\\n        }\\n        \\n        for (Integer start: starts[end]) {\\n            String word = s.substring(start, end);\\n            dfs(rst, \" \" + word + path, s, starts, start);\\n        }\\n    }\\n\\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\nMethod 2: Memoization + Backtracking. Before I came up with Method 1, I also tried using a HashMap to memoize all the possible strings that can be formed starting from index i. I referred to this post from [@Pixel_][1] \\nThe time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) as @Pixel_ mentioned. The space complexity would be larger than other methods though. Here is my code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        HashMap<Integer, List<String>> memo = new HashMap<>(); // <Starting index, rst list>\\n        return dfs(s, 0, wordDict, memo);\\n    }\\n    \\n    private List<String> dfs(String s, int start, Set<String> dict, HashMap<Integer, List<String>> memo) {\\n        if (memo.containsKey(start)) {\\n            return memo.get(start);\\n        }\\n        \\n        List<String> rst = new ArrayList<>();\\n        if (start == s.length()) {\\n            rst.add(\"\");\\n            return rst;\\n        }\\n        \\n        String curr = s.substring(start);\\n        for (String word: dict) {\\n            if (curr.startsWith(word)) {\\n                List<String> sublist = dfs(s, start + word.length(), dict, memo);\\n                for (String sub : sublist) {\\n                    rst.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);\\n                }\\n            }\\n        }\\n        \\n        memo.put(start, rst);\\n        return rst;\\n    }\\n\\nMethod 3: DP Prunning + Backtracking. My very first solution is like this: using a boolean array to memoize whether a substring starting from position i to the end is breakable. This works well for worst cases like: s = \"aaaaaaaaaaaab\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"]. However, for cases like: s = \"aaaaaaaaaaaaa\", dict = [\"a\", \"aa\", \"aaa\", \"aaaa\"], the time complexity is still O(2^n). Here is the code: \\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        List<String> rst = new ArrayList<>();\\n        if (s == null || s.length() == 0 || wordDict == null) {\\n            return rst;\\n        }\\n        \\n        boolean[] canBreak = new boolean[s.length()];\\n        Arrays.fill(canBreak, true);\\n        StringBuilder sb = new StringBuilder();\\n        dfs(rst, sb, s, wordDict, canBreak, 0);\\n        return rst;\\n    }\\n    \\n    private void dfs(List<String> rst, StringBuilder sb, String s, Set<String> dict, \\n        boolean[] canBreak, int start) {\\n        if (start == s.length()) {\\n            rst.add(sb.substring(1));\\n            return;\\n        }\\n        \\n        if (!canBreak[start]) {\\n            return;\\n        }\\n        \\n        for (int i = start + 1; i <= s.length(); i++) {\\n            String word = s.substring(start, i);\\n            if (!dict.contains(word)) continue;\\n            \\n            int sbBeforeAdd = sb.length();\\n            sb.append(\" \" + word);\\n            \\n            int rstBeforeDFS = rst.size();\\n            dfs(rst, sb, s, dict, canBreak, i);\\n            if (rst.size() == rstBeforeDFS) {\\n                canBreak[i] = false;\\n            }\\n            sb.delete(sbBeforeAdd, sb.length());\\n        }\\n    }\\n    \\n    private int getMaxLen(Set<String> wordDict) {\\n        int max = 0;\\n        for (String s : wordDict) {\\n            max = Math.max(max, s.length());\\n        }\\n        return max;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/65692/my-concise-java-solution-based-on-memorized-dfs",
                "codeTag": "Java"
            },
            {
                "id": 44368,
                "title": "python-easy-to-understand-solutions-memorization-dfs-dp-dfs",
                "content": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        return self.dfs(s, set(wordDict), {})\\n    \\n    def dfs(self, s, d, m):\\n        if s in m: # memorize\\n            return m[s]\\n        if not s:\\n            return [\"\"]\\n        res = []\\n        for i in range(1, len(s)+1):\\n            if s[:i] in d:\\n                for word in self.dfs(s[i:], d, m):\\n                    res.append(s[:i] + (\" \" if word else \"\") + word)\\n        m[s] = res\\n        return res\\n    \\n    def wordBreak1(self, s, wordDict):\\n        res = []\\n        self.dfs(s, set(wordDict), \"\", res)\\n        return res\\n    \\n    def dfs1(self, s, dic, path, res):\\n        if self.check(s, dic):\\n            if not s:\\n                res.append(path[1:])\\n            for i in range(1, len(s)+1):\\n                if s[:i] in d:\\n                    self.dfs(s[i:], dic, path+\" \"+s[:i], res)\\n                \\n    def check(self, s, dic):\\n        dp = [False] * (1+len(s))\\n        dp[0] = True\\n        for j in range(1, len(s)+1):\\n            for i in range(j):\\n                if dp[i] and s[i:j] in dic:\\n                    dp[j] = True\\n                    break\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        return self.dfs(s, set(wordDict), {})\\n    \\n    def dfs(self, s, d, m):\\n        if s in m: # memorize\\n            return m[s]\\n        if not s:\\n            return [\"\"]\\n        res = []\\n        for i in range(1, len(s)+1):\\n            if s[:i] in d:\\n                for word in self.dfs(s[i:], d, m):\\n                    res.append(s[:i] + (\" \" if word else \"\") + word)\\n        m[s] = res\\n        return res\\n    \\n    def wordBreak1(self, s, wordDict):\\n        res = []\\n        self.dfs(s, set(wordDict), \"\", res)\\n        return res\\n    \\n    def dfs1(self, s, dic, path, res):\\n        if self.check(s, dic):\\n            if not s:\\n                res.append(path[1:])\\n            for i in range(1, len(s)+1):\\n                if s[:i] in d:\\n                    self.dfs(s[i:], dic, path+\" \"+s[:i], res)\\n                \\n    def check(self, s, dic):\\n        dp = [False] * (1+len(s))\\n        dp[0] = True\\n        for j in range(1, len(s)+1):\\n            for i in range(j):\\n                if dp[i] and s[i:j] in dic:\\n                    dp[j] = True\\n                    break\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44179,
                "title": "slightly-modified-dp-java-solution",
                "content": "Hi guys!\\n\\nThere's a lot of concern in other posts about \"aaaa...aab\" test case that causes TLE when we run through our string not in reverse but from start to end. I've thought a bit on how to add a tiny modification and make just the whole thing more effective, not only pass the TLE case. \\n\\nThe approach is the same as before: we loop through all possible prefixes checking if it in the dictionary and caching the results. \\n\\nBut just before jumping into recursion we could also check that the right reminder has a prefix from the dictionary, because if it hasn't then there's no sense in splitting the reminder into sub-strings. It's just a linear check, which I think also could be optimized with some caching but even without optimization the solution is accepted. And also the code looks quite understandable.\\n\\n    public class Solution {\\n\\n        private final Map<String, List<String>> cache = new HashMap<>();\\n    \\n        private boolean containsSuffix(Set<String> dict, String str) {\\n            for (int i = 0; i < str.length(); i++) {\\n                if (dict.contains(str.substring(i))) return true;\\n            }\\n            return false;\\n        }\\n    \\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            if (cache.containsKey(s)) return cache.get(s);\\n            List<String> result = new LinkedList<>();\\n            if (dict.contains(s)) result.add(s);\\n            for (int i = 1; i < s.length(); i++) {\\n                String left = s.substring(0,i), right = s.substring(i);\\n                if (dict.contains(left) && containsSuffix(dict, right)) {\\n                    for (String ss : wordBreak(right, dict)) {\\n                        result.add(left + \" \" + ss);\\n                    }\\n                }\\n            }\\n            cache.put(s, result);\\n            return result;\\n        }\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n        private final Map<String, List<String>> cache = new HashMap<>();\\n    \\n        private boolean containsSuffix(Set<String> dict, String str) {\\n            for (int i = 0; i < str.length(); i++) {\\n                if (dict.contains(str.substring(i))) return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 763221,
                "title": "python-dp-solution-explained",
                "content": "First of all, this problem is extention of problem 139. Word Break, where we need just to check if word can be broken into other words. Here we need to give all possible splits. Let us first put all words into `set` and create two lists:\\n\\n1. `dp_solution[i]` is all possible splits for first `i` symbols of `s`\\n2. `dp[i]` is indicator if we can split word or not.\\n\\nAlso we create this two lists with size `(n+1)` to handle border cases, in `dp[-1]` we will keep result for empty string `\"\"`.\\n\\n1. First step is to check if our string can be splitted at all, using problem 139. We need to do it, to candle strings like `aaaaa...aaab`, with `wordDict = [a, aa, aaa, ..., aa..aa]`. In this case answer will be `no`, but if we try to build solution directly we will get MLE. Try to remove this lines of code from solution and you will see.\\n2. Now, we do one more pass over data and start to build solutions: if we found that `s[j: k + 1] in wordSet`, then for every already built solution `sol in dp_solution[j-1]` we can add it to `dp_solution[k]`. \\n3. Finally, we have some extraspaces in the beginning of each solution, and instead of last element `[-1]` we need to return previous `[-2]`, so we return return `[s[1:] for s in dp_solution[-2]]`\\n\\n**Complexity**: to create `dp` we need `O(n^2m)` time, where `m` is average length of word and `O(n^2)` space. However for `dp_solution` part we can have potentially exponential number of solutions, for example even for `s = aa.....aa`, `wordDict = [a, aa]`. I think leetcode just will not give you tests, where memory will exceed some limit.\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        wordSet = set(wordDict)\\n        n = len(s)\\n        dp_solution = [[] for _ in range(n)] + [[\"\"]]\\n        dp = [0] * n + [1]\\n        \\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    dp[k] = max(dp[k], dp[j-1])\\n\\n        if dp[-2] == 0: return []\\n\\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    for sol in dp_solution[j-1]:\\n                        dp_solution[k].append(sol + \" \" + s[j: k + 1])\\n                        \\n        return [s[1:] for s in dp_solution[-2]]\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s, wordDict):\\n        wordSet = set(wordDict)\\n        n = len(s)\\n        dp_solution = [[] for _ in range(n)] + [[\"\"]]\\n        dp = [0] * n + [1]\\n        \\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    dp[k] = max(dp[k], dp[j-1])\\n\\n        if dp[-2] == 0: return []\\n\\n        for k in range(n):\\n            for j in range(k,-1,-1):\\n                if s[j: k + 1] in wordSet:\\n                    for sol in dp_solution[j-1]:\\n                        dp_solution[k].append(sol + \" \" + s[j: k + 1])\\n                        \\n        return [s[1:] for s in dp_solution[-2]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44255,
                "title": "my-concise-answer",
                "content": "    public class Solution {\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> result = new ArrayList<String>();\\n        for(int j = s.length() - 1; j >= 0; j--){\\n            if(dict.contains(s.substring(j)))\\n                break;\\n            else{\\n                if(j == 0)\\n                    return result;\\n            }\\n        }\\n        for(int i = 0; i < s.length()-1; i++)\\n        {\\n            if(dict.contains(s.substring(0,i+1)))\\n            {\\n                List<String> strs = wordBreak(s.substring(i+1,s.length()),dict);\\n                if(strs.size() != 0)\\n                    for(Iterator<String> it = strs.iterator();it.hasNext();)\\n                    {\\n                        result.add(s.substring(0,i+1)+\" \"+it.next());\\n                    }\\n            }\\n        }\\n        if(dict.contains(s)) result.add(s);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> result = new ArrayList<String>();\\n        for(int j = s.length() - 1; j >= 0; j--){\\n            if(dict.contains(s.substring(j)))\\n                break;\\n            else{\\n                if(j == 0)\\n                    return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 194615,
                "title": "dp-solution-with-detailed-text-and-video-explanation",
                "content": "## LeetCode 140. Word Break II\\n### Note\\nIf you prefer video over text, please check out this link: https://www.youtube.com/watch?v=xun6zHlX8kI\\nwhich has the same content as follows.\\n### Explanation\\n```cpp\\nExample 1:\\ns = \"catsanddog\"\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\n\\n// The basic idea for solving this problem is\\nThe result of a string can be generated from the results of its substrings.\\n\\n// Like, for string \"catsanddog\" (S) and one of its substrings \"catsand\" (T).\\n// Suppose we\\'ve known T can be broken into [\"cat\", \"sand\"] or [\"cats\", \"and\"],\\n// and \"catsanddog\"(S) = \"catsand\"(T) + \"dog\".\\n// We only need to check if \"dog\" is in the wordDict, which is true in this case.\\n// Let dp(S) denote the result of S.\\ndp(T) = \\n[\"cat\", \"sand\"], \\n[\"apple\", \"pen\"]\\n\\ndp(S) <= dp(T) + \"apple\" = \\n[\"cat\", \"sand\", \"apple\"], \\n[\"cats\", \"and\", \"apple\"] \\n\\n// Thus, we can have\\n>> state: Let dp[i] denote all valid breaks for s(0, i)\\nE.g. in the above case,\\ns(0, 6) = \"catsand\"\\ndp[6] = [\"cat\", \"sand\"], [\"cats\", \"and\"]\\n\\n// The way we solve this problem is like this:\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\nindex:    0   1   2   3   4   5   6   7   8   9\\n        +---------------------------------------+\\ns:      | c | a | t | s | a | n | d | d | o | g |\\n        +---------------------------------------+\\n          i   \\n          j\\n\\ndp[0] = []\\ndp[1] = []\\ndp[2] = [\"cat\"]\\ndp[3] = [\"cats\"]\\ndp[4] = []\\ndp[5] = []\\ndp[6] = [\"cat sand\",\"cats and\"]\\ndp[7] = []\\ndp[8] = []\\ndp[9] = [\"cat sand dog\",\"cats and dog\"]\\n\\n>> recurrence relation:\\ndp[i] = \\nfor (int j = 0; j < i; j++) {\\n\\tsubstr = s[j, i];\\n  if (dp[j].size() > 0 && wordDict.contains(substr)) {\\n      for (String l : dp[j]) {\\n          dp[i].add(l + substr);\\n      }\\n  }\\n}\\n```\\n### Code\\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int N = s.size();\\n        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\\n        \\n        vector<vector<string>> dp(N + 1, vector<string>());\\n        dp[0].emplace_back(\"\");\\n        for(int i = 1; i <= N; ++i){\\n            for(int j = 0; j < i; ++j){\\n                string substr = s.substr(j, i - j);\\n                if(dp[j].size() > 0 && wordSet.find(substr) != wordSet.end()){\\n                    for(string& l : dp[j]){\\n                        dp[i].emplace_back(l + (l == \"\" ? \"\" : \" \") + substr);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[N];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nExample 1:\\ns = \"catsanddog\"\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\n\\n// The basic idea for solving this problem is\\nThe result of a string can be generated from the results of its substrings.\\n\\n// Like, for string \"catsanddog\" (S) and one of its substrings \"catsand\" (T).\\n// Suppose we\\'ve known T can be broken into [\"cat\", \"sand\"] or [\"cats\", \"and\"],\\n// and \"catsanddog\"(S) = \"catsand\"(T) + \"dog\".\\n// We only need to check if \"dog\" is in the wordDict, which is true in this case.\\n// Let dp(S) denote the result of S.\\ndp(T) = \\n[\"cat\", \"sand\"], \\n[\"apple\", \"pen\"]\\n\\ndp(S) <= dp(T) + \"apple\" = \\n[\"cat\", \"sand\", \"apple\"], \\n[\"cats\", \"and\", \"apple\"] \\n\\n// Thus, we can have\\n>> state: Let dp[i] denote all valid breaks for s(0, i)\\nE.g. in the above case,\\ns(0, 6) = \"catsand\"\\ndp[6] = [\"cat\", \"sand\"], [\"cats\", \"and\"]\\n\\n// The way we solve this problem is like this:\\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\\nindex:    0   1   2   3   4   5   6   7   8   9\\n        +---------------------------------------+\\ns:      | c | a | t | s | a | n | d | d | o | g |\\n        +---------------------------------------+\\n          i   \\n          j\\n\\ndp[0] = []\\ndp[1] = []\\ndp[2] = [\"cat\"]\\ndp[3] = [\"cats\"]\\ndp[4] = []\\ndp[5] = []\\ndp[6] = [\"cat sand\",\"cats and\"]\\ndp[7] = []\\ndp[8] = []\\ndp[9] = [\"cat sand dog\",\"cats and dog\"]\\n\\n>> recurrence relation:\\ndp[i] = \\nfor (int j = 0; j < i; j++) {\\n\\tsubstr = s[j, i];\\n  if (dp[j].size() > 0 && wordDict.contains(substr)) {\\n      for (String l : dp[j]) {\\n          dp[i].add(l + substr);\\n      }\\n  }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int N = s.size();\\n        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\\n        \\n        vector<vector<string>> dp(N + 1, vector<string>());\\n        dp[0].emplace_back(\"\");\\n        for(int i = 1; i <= N; ++i){\\n            for(int j = 0; j < i; ++j){\\n                string substr = s.substr(j, i - j);\\n                if(dp[j].size() > 0 && wordSet.find(substr) != wordSet.end()){\\n                    for(string& l : dp[j]){\\n                        dp[i].emplace_back(l + (l == \"\" ? \"\" : \" \") + substr);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[N];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507365,
                "title": "c-short-fast-dfs-hash-map-for-dp-speed-95-mem-94",
                "content": "```\\nclass Solution {\\n    public:\\n        vector<string> wordBreak(string s, vector<string>& wordDict) \\n        {\\n            int max_len = 0;\\n            unordered_set<string> dict;\\n            for(string& str : wordDict)\\n            {\\n                dict.insert(str);\\n                max_len = max(max_len, (int)str.length());\\n            }\\n\\n            unordered_map<int, vector<string>> mp;\\n            return break_word(s, 0, dict, max_len, mp);\\n        }\\n\\n    protected:\\n        vector<string> break_word(  const string& s, int n, unordered_set<string>& dict, \\n                                    int max_len, unordered_map<int, vector<string>>& mp)\\n        {\\n            if(mp.count(n)) return mp[n];\\n\\n            string str;\\n            for(int i = n; i < s.length() && str.length() <= max_len; ++i)\\n            {\\n                str += s[i];\\n                if(dict.count(str))\\n                {\\n                    if(i == s.length()-1)\\n                        mp[n].push_back(str);\\n                    else\\n                    {\\n                        vector<string> vs = break_word(s, i+1, dict, max_len, mp);\\n                        for(auto& a : vs) mp[n].push_back(str + \" \" + a);\\n                    }\\n                }\\n            }\\n            return mp[n];\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n        vector<string> wordBreak(string s, vector<string>& wordDict) \\n        {\\n            int max_len = 0;\\n            unordered_set<string> dict;\\n            for(string& str : wordDict)\\n            {\\n                dict.insert(str);\\n                max_len = max(max_len, (int)str.length());\\n            }\\n\\n            unordered_map<int, vector<string>> mp;\\n            return break_word(s, 0, dict, max_len, mp);\\n        }\\n\\n    protected:\\n        vector<string> break_word(  const string& s, int n, unordered_set<string>& dict, \\n                                    int max_len, unordered_map<int, vector<string>>& mp)\\n        {\\n            if(mp.count(n)) return mp[n];\\n\\n            string str;\\n            for(int i = n; i < s.length() && str.length() <= max_len; ++i)\\n            {\\n                str += s[i];\\n                if(dict.count(str))\\n                {\\n                    if(i == s.length()-1)\\n                        mp[n].push_back(str);\\n                    else\\n                    {\\n                        vector<string> vs = break_word(s, i+1, dict, max_len, mp);\\n                        for(auto& a : vs) mp[n].push_back(str + \" \" + a);\\n                    }\\n                }\\n            }\\n            return mp[n];\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764120,
                "title": "easy-to-understand-trie-solution-beats-100",
                "content": "**Intuition:**\\n* We need a DS to handle characters in a way that we can search for a particular word easily. (My choice was Trie).\\n* We should find all combinations of words in the given string s. (Hence I decided to solve it using dynamic programming/ recursion)\\n\\n**Explanation**\\n* If you are new to TRIE data structure, please go through [this problem.](https://leetcode.com/problems/implement-trie-prefix-tree/). We are going to implement a variant of the TRIE data structure.\\n* We only have to implement the `add` function of the Trie DS as we will be searching for the combinations of words using dp technique.\\n* This solution will involve two steps of preprocessing to reduce the time complexity.\\n\\t* First step is to form a TRIE with the given dictionary.\\n\\t* Second step is to check if all the letters in the string `s` are present in the dictionary. We will be using an int array `exists` which will be set to `1` whenever a letter is added to our TRIE. So, if there is any letter whose corresponding `exists` value is not `1`, then there is no way to form a combination with the given words, so we return an empty list.\\n* Now, how do we find the result?\\n* I have used DP technique to accomplish that. I have added comments wherever required in the below code so that you guys understand better.\\n* PS: I found the search method i implemented in this similar to this[question](https://leetcode.com/problems/all-paths-from-source-to-target/description/\\n\\n*Please upvote if you found this post useful and do post your questions down below if you have any.\\nCheers!*\\n\\n**Code**\\n```\\nclass Solution {\\n\\n    int[] exists;\\n    Trie root;\\n    \\n    public void search(List<String> ans, Trie curr, StringBuilder temp, char[] given, int index){\\n        if(index==given.length){\\n            return;\\n        } \\n        if(curr.children[given[index]-\\'a\\'] == null)return;\\n        \\n        Trie next = curr.children[given[index] - \\'a\\'];\\n        temp.append(given[index]);\\n        \\n        //If the word is present in the dictionary, we can either add a space or we continue going down in the trie\\n        if(next.isWord){\\n            //If we have reached the end of the string, add the value to Answer and terminate\\n            if(index+1 == given.length){\\n                ans.add(temp.toString());\\n                temp.deleteCharAt(temp.length()-1); \\n                return;\\n                }\\n            else{\\n                //We are adding space\\n                temp.append(\" \");\\n                //Since after adding space, the next letter should be the beginning of a new word from the dictionary, we pass in the ROOT trie node\\n                search(ans, root, temp, given, index+1);\\n                //remove the space we added in the above line.\\n                temp.deleteCharAt(temp.length()-1);      \\n            }\\n        }\\n        \\n        //since we have not added a space, we are technically going down in the same trie block. So we are moving the NEXT node in the CURR trie node.\\n        search(ans, next, temp, given, index+1);\\n            \\n        //Deleting the added character\\n        temp.deleteCharAt(temp.length()-1);            \\n\\n    }\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        root = new Trie();\\n        exists = new int[26];\\n        List<String> ans = new ArrayList();\\n        for(String word : wordDict){\\n            root.addWord(word);\\n        }\\n        \\n        for(char c : s.toCharArray()){\\n            if(exists[c-\\'a\\']!=1)\\n                return new ArrayList();\\n        }\\n        search(ans, root, new StringBuilder(), s.toCharArray(), 0);\\n        return ans;\\n    }\\n\\n    \\n    class Trie{\\n        boolean isWord;\\n        Trie[] children;\\n        Trie(){\\n            isWord=false;\\n            children = new Trie[26];\\n        }\\n        public void addWord(String w){\\n            Trie curr = this;\\n            int index = 0;\\n            char[] word = w.toCharArray();\\n            while(index<word.length){   \\n                exists[word[index]-\\'a\\']=1;\\n                if(curr.children[word[index]-\\'a\\'] == null){\\n                    curr.children[word[index]-\\'a\\'] = new Trie();\\n                }  \\n                curr = curr.children[word[index]-\\'a\\'];\\n                index++;\\n            }\\n            curr.isWord = true;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[] exists;\\n    Trie root;\\n    \\n    public void search(List<String> ans, Trie curr, StringBuilder temp, char[] given, int index){\\n        if(index==given.length){\\n            return;\\n        } \\n        if(curr.children[given[index]-\\'a\\'] == null)return;\\n        \\n        Trie next = curr.children[given[index] - \\'a\\'];\\n        temp.append(given[index]);\\n        \\n        //If the word is present in the dictionary, we can either add a space or we continue going down in the trie\\n        if(next.isWord){\\n            //If we have reached the end of the string, add the value to Answer and terminate\\n            if(index+1 == given.length){\\n                ans.add(temp.toString());\\n                temp.deleteCharAt(temp.length()-1); \\n                return;\\n                }\\n            else{\\n                //We are adding space\\n                temp.append(\" \");\\n                //Since after adding space, the next letter should be the beginning of a new word from the dictionary, we pass in the ROOT trie node\\n                search(ans, root, temp, given, index+1);\\n                //remove the space we added in the above line.\\n                temp.deleteCharAt(temp.length()-1);      \\n            }\\n        }\\n        \\n        //since we have not added a space, we are technically going down in the same trie block. So we are moving the NEXT node in the CURR trie node.\\n        search(ans, next, temp, given, index+1);\\n            \\n        //Deleting the added character\\n        temp.deleteCharAt(temp.length()-1);            \\n\\n    }\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        root = new Trie();\\n        exists = new int[26];\\n        List<String> ans = new ArrayList();\\n        for(String word : wordDict){\\n            root.addWord(word);\\n        }\\n        \\n        for(char c : s.toCharArray()){\\n            if(exists[c-\\'a\\']!=1)\\n                return new ArrayList();\\n        }\\n        search(ans, root, new StringBuilder(), s.toCharArray(), 0);\\n        return ans;\\n    }\\n\\n    \\n    class Trie{\\n        boolean isWord;\\n        Trie[] children;\\n        Trie(){\\n            isWord=false;\\n            children = new Trie[26];\\n        }\\n        public void addWord(String w){\\n            Trie curr = this;\\n            int index = 0;\\n            char[] word = w.toCharArray();\\n            while(index<word.length){   \\n                exists[word[index]-\\'a\\']=1;\\n                if(curr.children[word[index]-\\'a\\'] == null){\\n                    curr.children[word[index]-\\'a\\'] = new Trie();\\n                }  \\n                curr = curr.children[word[index]-\\'a\\'];\\n                index++;\\n            }\\n            curr.isWord = true;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44299,
                "title": "java-6ms-simple-solution-beating-88",
                "content": "    public class Solution {\\n        HashMap<Integer, List<String>> dp = new HashMap<>();\\n\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            int maxLength = -1;\\n            for(String ss : wordDict) maxLength = Math.max(maxLength, ss.length());\\n            return addSpaces(s, wordDict, 0, maxLength);\\n        }\\n        \\n        private List<String> addSpaces(String s, Set<String> wordDict, int start, int max){\\n            List<String> words = new ArrayList<>();\\n            if(start == s.length()) {\\n                words.add(\"\");\\n                return words;\\n            }\\n            for(int i = start + 1; i <= max + start && i <= s.length(); i++){\\n                String temp = s.substring(start, i);\\n                if(wordDict.contains(temp)){\\n                    List<String> ll;\\n                    if(dp.containsKey(i)) ll = dp.get(i);\\n                    else ll = addSpaces(s, wordDict, i, max);\\n                    for(String ss : ll) words.add(temp + (ss.equals(\"\") ? \"\" : \" \") + ss);\\n                }\\n                \\n            }\\n            dp.put(start, words);\\n            return words;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        HashMap<Integer, List<String>> dp = new HashMap<>();\\n\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            int maxLength = -1;\\n            for(String ss : wordDict) maxLength = Math.max(maxLength, ss.length());\\n            return addSpaces(s, wordDict, 0, maxLength);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44262,
                "title": "my-c-dp-dfs-solution-4ms",
                "content": "The basic idea is to use DP to create an array isBreakable[i] to indicate whether s[i..sSize-1] is breakable. Then we can use such information to help us speed up the DFS path build process (buildPath). Learned from other posts, I first calculated minlen and maxlen to speed up the process.\\n  \\n\\n    class Solution {\\n    private: //DFS path build function\\n        void buildPath(bool isBreakable[], string &s, int pos, vector<string> &res, string curP, unordered_set<string>& wordDict, int minlen, int maxlen)\\n        {\\n            int i, len = s.size();\\n            for(i =minlen; i<= min(maxlen, len - pos); ++i)\\n                if( isBreakable[pos+i] && wordDict.count(s.substr(pos,i)) ) \\n                    if(pos+i == len) res.push_back(curP + s.substr(pos,i));\\n                    else buildPath(isBreakable, s, pos+i, res, curP + s.substr(pos,i) + \" \", wordDict, minlen, maxlen);\\n        }\\n        \\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n            int sSize = s.size(), len, i, minlen = INT_MAX, maxlen = INT_MIN;\\n            vector<string> res;\\n            bool isBreakable[sSize+1];\\n            fill_n(isBreakable, sSize+1, false);\\n                \\n            for (string word : wordDict) { // find the minimum and maximum word length \\n                minlen = min(minlen, (int)word.length());\\n                maxlen = max(maxlen, (int)word.length()); \\n            }        \\n            //DP to build isBreakable\\n            for(i=sSize-minlen, isBreakable[sSize]= true; i>=0; --i)\\n                for(len=minlen; len<=min(maxlen, sSize-i); ++len)\\n                {\\n                    if(isBreakable[i+len] && wordDict.count(s.substr(i,len)) ) {isBreakable[i] = true; break;}\\n                }\\n            //if breakable, do DFS path building\\n            if(isBreakable[0]) buildPath(isBreakable, s, 0, res, \"\", wordDict, minlen, maxlen);\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private: //DFS path build function\\n        void buildPath(bool isBreakable[], string &s, int pos, vector<string> &res, string curP, unordered_set<string>& wordDict, int minlen, int maxlen)\\n        {\\n            int i, len = s.size();\\n            for(i =minlen; i<= min(maxlen, len - pos); ++i)\\n                if( isBreakable[pos+i] && wordDict.count(s.substr(pos,i)) ) \\n                    if(pos+i == len) res.push_back(curP + s.substr(pos,i));\\n                    else buildPath(isBreakable, s, pos+i, res, curP + s.substr(pos,i) + \" \", wordDict, minlen, maxlen);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44264,
                "title": "java-dfs-dp-clean-solution",
                "content": "The basic backtracking idea is straightforward, find a possible break point and then recursively call the suffix of the original string.  The trick is that we use a map to keep the previous result which will terminate the recursion early to make sure we don't get TLE.\\n\\n\\n    public class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            return dfs(s, dict, new HashMap<>());\\n        }\\n    \\n        public List<String> dfs(String s, Set<String> dict, Map<String, List<String>> memo){\\n            if(memo.containsKey(s)) {\\n                return memo.get(s);\\n            }\\n            List<String> res = new ArrayList<>();\\n            if(s == null || s.length() == 0) {\\n                return res;\\n            }\\n            int n = s.length();\\n            \\n            for(String w : dict) {\\n                if(!s.startsWith(w)) {\\n                    continue;\\n                }\\n                int end = w.length();\\n                if(end == n) {\\n                    res.add(w);\\n                } else {\\n                    List<String> sublist = dfs(s.substring(end), dict, memo);\\n                    for(String item : sublist) {\\n                        item = w + \" \" + item;\\n                        res.add(item);\\n                    }\\n                }\\n            }\\n            \\n            memo.put(s, res);\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            return dfs(s, dict, new HashMap<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1175903,
                "title": "c-backtracking-simple-code",
                "content": "```\\nvector<string> sentences;\\nvector<string> wordBreak(string s, vector<string>& wordDict)\\n{\\n    unordered_set<string> setting;\\n    setting.insert(wordDict.begin(), wordDict.end());\\n    dfs(s, \"\", setting);\\n    return sentences;\\n}\\n\\nvoid dfs(string s, string sentence, unordered_set<string>& setting)\\n{\\n    if(s.empty())\\n    {\\n        sentence.pop_back();\\n        sentences.push_back(sentence);\\n        return;\\n    }\\n    int n = s.size();\\n    for(int i = 1; i <= n; i++)\\n    {\\n        if(!setting.count(s.substr(0, i)))\\n            continue;\\n        dfs(s.substr(i), sentence + s.substr(0, i) + \" \", setting);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvector<string> sentences;\\nvector<string> wordBreak(string s, vector<string>& wordDict)\\n{\\n    unordered_set<string> setting;\\n    setting.insert(wordDict.begin(), wordDict.end());\\n    dfs(s, \"\", setting);\\n    return sentences;\\n}\\n\\nvoid dfs(string s, string sentence, unordered_set<string>& setting)\\n{\\n    if(s.empty())\\n    {\\n        sentence.pop_back();\\n        sentences.push_back(sentence);\\n        return;\\n    }\\n    int n = s.size();\\n    for(int i = 1; i <= n; i++)\\n    {\\n        if(!setting.count(s.substr(0, i)))\\n            continue;\\n        dfs(s.substr(i), sentence + s.substr(0, i) + \" \", setting);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978368,
                "title": "backtracking-memo-explanation-3-visuals-python",
                "content": "***TL;DR (Visuals  + Explanation below code snippet)*** This code follows the standard [backtracking template](https://leetcode.com/problems/subsets/discuss/973667/backtracking-template-explanation-visual-python). We keep track of indexes that cannot lead to valid solution and make sure we do not visit them. We do this by keeping a memo (memoization)\\n\\n\\n```python\\n def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self.backtrack(0, len(s), [], res, s, wordDict, set()) \\n        return res\\n    \\n    def backtrack(self, start, end, sentence, result, string, wordDict, bad):\\n        # seen this prefix before, path did not lead to valid answer\\n        if start in bad: \\n            return  \\n        \\n        if start == end:\\n            result.append(\\' \\'.join(sentence))\\n            return\\n        \\n        before = len(result)\\n        for w in wordDict:\\n            if string[start:].startswith(w):\\n                sentence.append(w)\\n                self.backtrack(start + len(w), end, sentence, result, string, wordDict, bad)\\n                sentence.pop()\\n                \\n        after = len(result)\\n        # no result has been added bad path. \\n\\t\\t# the this index will never lead to a feasible solution\\n        if before == after: bad.add(start)\\n\\n```\\n### Explanation\\nThe goal of this problem is to return all possible sentences that meet the constraints of the problem. We need to be exaushtive (collect all possibilities). This is an indication the problem can be solved with backtracking. \\n\\nthe constraints for this problem as follows \\n1. we must construct words for our sentence from string ```s``` by adding spaces \\n2. every word in the sentence must be valid dictionary word \\n\\nsince we can construct sentences by adding spaces, all the characters in our original string ```s``` must be used. \\n\\nif we manage to use all characters we have found a solution.\\n\\nwe can mimick inserting spaces by looking at prefixes of substrings. \\n```python\\n\\ts[start:].startswith(w)\\n```\\n\\n### Optimization\\nfor some examples there are many combinations that fail to produce a solution.  this can lead to an enormous amount of unecessary recursive calls, wreaking havoc on the time complexity. \\n\\n***the key observation for optimization*** is that if a prefix starting from index ```start```does not lead to a feasible solution, any time that same index is visited again it will also will fail to lead to feasible solution. \\n\\n* The initial examples could have been better selected as they do not show the need for memoization and it is not immediately obvious.\\n\\n* to help the reader fully understand the code above and the reason why memoization must be used for an efficient solution 3 visuals have been included below \\n\\n### Visual Example 1\\nregardless of whether memiozation is used our not, this example performs the same.\\nwhen ```try ``` is used, it is to denote each word that is being looped through, the last word denotes the selected word. in the below examole ```applepen``` is the selected word. \\n```try: apple,  pen, applepen```\\n\\n![image](https://assets.leetcode.com/users/images/b9138d01-ef38-4e50-bf97-7c34dc6f5e36_1608427761.2446313.png)\\n\\n\\n### Visual Example 2 \\n\\nan example where memiozation is not used. nodes of the same color are repeating indexes. note this problem no sentences are generated. no path leads to a feasible solution. \\n![image](https://assets.leetcode.com/users/images/4eb795eb-faf2-428a-88e2-9bc6194749f3_1608427409.9636602.png)\\n\\n\\n\\n### Visual Example 3 \\n\\nThe same as example 2. This time memoization is used. indexes that lead to unfeasible solutions are cached. if index is in cache, no need to explore any further. the red ```X``` on a node in the recursion tree symbolizes that a index has been found in the cache. all nodes below a red ```X``` node in this diagram actually dont exist. no recursive call was made for these nodes. included them for a more complete visual\\n\\n\\n![image](https://assets.leetcode.com/users/images/6f21790a-74d1-4f5f-a567-0bd3898ed267_1608427614.8162823.png)\\n\\n\\n\\n\\n\\n[code courtesy of serdes\\n ](https://leetcode.com/problems/word-break-ii/discuss/973144/Python3-Recursive-Backtracking-w-Pruning.-O(S)-extra-space)",
                "solutionTags": [
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```python\\n def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self.backtrack(0, len(s), [], res, s, wordDict, set()) \\n        return res\\n    \\n    def backtrack(self, start, end, sentence, result, string, wordDict, bad):\\n        # seen this prefix before, path did not lead to valid answer\\n        if start in bad: \\n            return  \\n        \\n        if start == end:\\n            result.append(\\' \\'.join(sentence))\\n            return\\n        \\n        before = len(result)\\n        for w in wordDict:\\n            if string[start:].startswith(w):\\n                sentence.append(w)\\n                self.backtrack(start + len(w), end, sentence, result, string, wordDict, bad)\\n                sentence.pop()\\n                \\n        after = len(result)\\n        # no result has been added bad path. \\n\\t\\t# the this index will never lead to a feasible solution\\n        if before == after: bad.add(start)\\n\\n```\n```s```\n```s```\n```python\\n\\ts[start:].startswith(w)\\n```\n```start```\n```try ```\n```applepen```\n```try: apple,  pen, applepen```\n```X```\n```X```",
                "codeTag": "Python3"
            },
            {
                "id": 1087111,
                "title": "clean-simple-javascript-with-explanation-walkthrough-100-100",
                "content": "![image](https://assets.leetcode.com/users/images/376b4b3d-7499-45be-9fa8-0baeb4f8c47e_1615591486.3132093.png)\\n\\nEDIT: This problem came up for me again recently and I couldn\\'t remember my exact code when I solved it the first time.  I think the code I wrote the second time around is easier to understand, so I\\'m including it right below this edit.  I slightly overcomplicated this one on the first go with the .forEach stuff.  Knowing the basic approach let me write a simpler solution this time around.  There\\'s also a one-liner at the very bottom because I was bored. lol\\n\\n```\\nconst wordBreak = (s, wordDict, cur = [], res = []) => {\\n  if (!s.length) return res.push(cur.join(\\' \\'));\\n  for (let word of wordDict) {\\n    if (!s.startsWith(word)) continue;\\n    cur.push(word);\\n    wordBreak(s.slice(word.length), wordDict, cur, res);\\n    cur.pop();\\n  }\\n  return res;\\n}\\n```\\n\\nTestCase: s = \\'catsanddog\\', wordDict = [\\'cat\\', \\'cats\\', \\'and\\', \\'sand\\', \\'dog\\']\\n\\nWe begin by initializing a new hash map in the arguments.  From there, algorithm checks to see if current string is in hashmap.  First time it runs, it\\'s obviously empty.  In fact, the first time a word is added, it will be the last word.  In this case -> {\\'dog\\': [\\'dog\\']} will be first entry.  This entry seems pointless, but from here, it will pop back up to last call \\'sanddog\\'.  Sand was the word found on this round of iterations, so {\\'sanddog\\': [\\'sand dog\\']} is the next entry, and so on back up until the initial call.  In this way, it will take the initial input string and recursively build up the hash map from smallest components until eventually {\\'catsanddog\\': [\\'cat sand dog\\', \\'cats and dog\\'].\\n\\nIn order to do this recursively, we take the initial string and loop through the dictionary.  We check the first word in the dictionary - cat and check if \\'catsanddog\\' starts with that word.  It does, so we initialize a new variable to equal what is left of the string - \\'sanddog\\'.  We then check if this new leftAfter string\\'s length is === 0 (Or !leftAfter.length.  This is the same as leftAfter.length === 0 since 0 is a false-y value).  If it is, we know we have matched the entire string.  If not, we call the function again on the new string.  This time the \\'leftAfter\\' string = \\'sanddog\\'.  Loop matches \\'sand\\', leftAfter is dog.  Function runs again with \\'dog\\' as the argument.  \\'Dog\\' matches in loop, leftAfter.length === 0.  {\\'dog\\':[\\'dog\\']} is set.  On the \\'sanddog\\' level of the recursion call (back on this one since dog found the end of the string and fully finished its execution) \\'sand\\' is the current word. else wordBreak(\\'dog\\', wordDict, cache) runs and returns [\\'dog\\']. For each loop runs on this array and pushes \\'sand\\' + \\' \\' + \\'dog\\' to result.  cache is set with \\'sanddog\\': [\\'sand dog\\'].  In this way, we recurse down to the smallest word and build the combinations up until the full string has been constructed in this manner.  \\n```\\nconst wordBreak = (s, wordDict, cache = new Map()) => {\\n    if(cache.has(s)) return cache.get(s);\\n\\t    \\n    const result = [];\\n    for(const word of wordDict){\\n        if (s.startsWith(word)){\\n            const leftAfter = s.slice(word.length);\\n            if(!leftAfter.length) result.push(word);\\n            else wordBreak(leftAfter, wordDict, cache).forEach(val => result.push(word + \\' \\' + val));\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```\\n\\nFirst function call:  \\'catsanddog\\'  loop through dictionary finds two matches. \\'cat\\' and \\'cats\\'.\\n\\tLeftovers = \\'sanddog\\' and \\'anddog\\'.\\n\\nFunction runs on both of these in first level of recursive calls.  \\n\\t\\'sanddog\\' matches \\'sand\\'.  leftAfter = \\'dog\\' \\n\\t\\'anddog\\' matches \\'and\\'.  leftAfter = \\'dog\\'\\n\\t\\nFunction runs on \\'dog\\' twice in next level of recursive calls.\\n\\t\\'dog\\' matches \\'dog\\'.  results = [dog]. leftAfter = \\'\\'.  dog is added to memo and the second time this recursive call is ran, it is found.\\n\\t[\\'dog\\'] returned to call above.\\n\\t\\nAbove \\'sanddog\\' call with \\'sand\\' as current word and [\\'dog\\'] returned as potential matches for leftAfter.  ForEach loop runs on [\\'dog\\'].\\n\\'sand dog\\' is pushed to results.\\n\\nIn same fashion, \\'anddog\\' pushes [\\'and dog\\'] to results.  Both of these are added to memo and returned to calls above.\\n\\nBack on first call - words matched were \\'cat\\' and \\'cats\\'. \\n\\t[\\'sand dog\\'] is returned from recursive (sanddog) call.  forEach runs and adds \\'cat sand dog\\' to results.\\n\\t[\\'and dog\\'] is returned from recursive (anddog) call.  forEach runs and adds \\'cats and dog\\' to results.\\n\\t\\nResults are returned.\\n\\n\\nOne-liner:\\n```\\nconst wordBreak=(s,w,c,a=[])=>s?!(w.forEach(n=>s.startsWith(n)&&wordBreak(s.slice(n.length),w,c?`${c} ${n}`:n,a)))&&a:a.push(c)\\n```\\n\\nCool trie solution just because I\\'ve been practicing trie problems lately:\\n```\\nconst wordBreak = (s, words) => {\\n  const trie = words.reduce((trie, word) => {\\n    let runner = trie\\n    for (let char of word) {\\n      runner = runner[char] = runner[char] || {}\\n    }\\n    runner.end = word\\n    return trie\\n  }, {})\\n  \\n  const ans = new Array(s.length + 1).fill(false)\\n  ans[0] = [\\'\\']\\n  for (let i = 0; i < s.length + 1; i++) {\\n    if (!ans[i]) continue\\n    let runner = trie, runIdx = i + 1\\n    while (runner) {\\n      const char = s[runIdx - 1]\\n      runner = runner[char]\\n      if (runner && runner.end) {\\n        ans[runIdx] = ans[runIdx] || []\\n        ans[i].forEach(arr => ans[runIdx].push([...arr, runner.end]))\\n      }\\n      runIdx++\\n    }\\n  }\\n  return ans[s.length] ? ans[s.length].map(words => words.join(\\' \\')) : []\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nconst wordBreak = (s, wordDict, cur = [], res = []) => {\\n  if (!s.length) return res.push(cur.join(\\' \\'));\\n  for (let word of wordDict) {\\n    if (!s.startsWith(word)) continue;\\n    cur.push(word);\\n    wordBreak(s.slice(word.length), wordDict, cur, res);\\n    cur.pop();\\n  }\\n  return res;\\n}\\n```\n```\\nconst wordBreak = (s, wordDict, cache = new Map()) => {\\n    if(cache.has(s)) return cache.get(s);\\n\\t    \\n    const result = [];\\n    for(const word of wordDict){\\n        if (s.startsWith(word)){\\n            const leftAfter = s.slice(word.length);\\n            if(!leftAfter.length) result.push(word);\\n            else wordBreak(leftAfter, wordDict, cache).forEach(val => result.push(word + \\' \\' + val));\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```\n```\\nconst wordBreak=(s,w,c,a=[])=>s?!(w.forEach(n=>s.startsWith(n)&&wordBreak(s.slice(n.length),w,c?`${c} ${n}`:n,a)))&&a:a.push(c)\\n```\n```\\nconst wordBreak = (s, words) => {\\n  const trie = words.reduce((trie, word) => {\\n    let runner = trie\\n    for (let char of word) {\\n      runner = runner[char] = runner[char] || {}\\n    }\\n    runner.end = word\\n    return trie\\n  }, {})\\n  \\n  const ans = new Array(s.length + 1).fill(false)\\n  ans[0] = [\\'\\']\\n  for (let i = 0; i < s.length + 1; i++) {\\n    if (!ans[i]) continue\\n    let runner = trie, runIdx = i + 1\\n    while (runner) {\\n      const char = s[runIdx - 1]\\n      runner = runner[char]\\n      if (runner && runner.end) {\\n        ans[runIdx] = ans[runIdx] || []\\n        ans[i].forEach(arr => ans[runIdx].push([...arr, runner.end]))\\n      }\\n      runIdx++\\n    }\\n  }\\n  return ans[s.length] ? ans[s.length].map(words => words.join(\\' \\')) : []\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44353,
                "title": "my-dp-solution-in-java",
                "content": "    public class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            Map<Integer, List<String>> validMap = new HashMap<Integer, List<String>>();\\n    \\n            // initialize the valid values\\n            List<String> l = new ArrayList<String>();\\n            l.add(\"\");\\n            validMap.put(s.length(), l);\\n    \\n            // generate solutions from the end\\n            for(int i = s.length() - 1; i >= 0; i--) {\\n                List<String> values = new ArrayList<String>();\\n                for(int j = i + 1; j <= s.length(); j++) {\\n                    if (dict.contains(s.substring(i, j))) {\\n                        for(String word : validMap.get(j)) {\\n                            values.add(s.substring(i, j) + (word.isEmpty() ? \"\" : \" \") + word);\\n                        }\\n                    }\\n                }\\n                validMap.put(i, values);\\n            }\\n            return validMap.get(0);\\n        }\\n    }\\n\\nBasically my idea is the following:\\n\\n 1. Scan the the string from the tail\\n 2. Build possible solution for the current index based on DP results\\n 3. Return the solution when index==0",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<String> wordBreak(String s, Set<String> dict) {\\n            Map<Integer, List<String>> validMap = new HashMap<Integer, List<String>>();\\n    \\n            // initialize the valid values\\n            List<String> l = new ArrayList<String>();\\n            l.add(\"\");\\n            validMap.put(s.length(), l);\\n    \\n            // generate solutions from the end\\n            for(int i = s.length() - 1; i >= 0; i--) {\\n                List<String> values = new ArrayList<String>();\\n                for(int j = i + 1; j <= s.length(); j++) {\\n                    if (dict.contains(s.substring(i, j))) {\\n                        for(String word : validMap.get(j)) {\\n                            values.add(s.substring(i, j) + (word.isEmpty() ? \"\" : \" \") + word);\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 2617582,
                "title": "0-ms-efficient-c-solution-simple-recursion",
                "content": "```\\n\\tvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> ans;\\n        set<string> dict (wordDict.begin(), wordDict.end());\\n        f(0, s, \"\", ans, dict);\\n        return ans;\\n    }\\n\\n\\tvoid f(int ind, string &s, string temp, vector<string>& ans, set<string>& dict) {\\n        if(ind == s.length()) {\\n            temp.pop_back(); // pop the trailing space\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        string cur = \"\";\\n        for(int i = ind; i < s.length(); i++) {\\n            cur.push_back(s[i]);\\n            if(dict.find(cur) != dict.end()) {\\n                f(i+1, s, temp + cur + \" \", ans, dict); // adding current substring \\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n\\tvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> ans;\\n        set<string> dict (wordDict.begin(), wordDict.end());\\n        f(0, s, \"\", ans, dict);\\n        return ans;\\n    }\\n\\n\\tvoid f(int ind, string &s, string temp, vector<string>& ans, set<string>& dict) {\\n        if(ind == s.length()) {\\n            temp.pop_back(); // pop the trailing space\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        string cur = \"\";\\n        for(int i = ind; i < s.length(); i++) {\\n            cur.push_back(s[i]);\\n            if(dict.find(cur) != dict.end()) {\\n                f(i+1, s, temp + cur + \" \", ans, dict); // adding current substring \\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279443,
                "title": "python-40ms-beating-98-4-thoroughly-commented-re-post",
                "content": "Apologies for being unable to find the code of which this is a re-post (I searched a fair few but couldn\\'t find it again). \\n\\nThis is similar to other solutions (esp. similar given that it\\'s a re-post), however this version is thoroughly commented to aid in your understanding. I have also adjusted the structure of the code & variable names for this same purpose. For noobies, understand that we are defining dfs within the first function, which means that the dfs function can use the non-local variable `result` because it\\'s defined previously in the same namespace. \\n\\nLet me know if you find the original code so that I can post a link here!\\n\\n**Second Solution**: I also added a second solution that uses a `deque` (double ended que) for O(1) adding to the path, but this doesn\\'t change the Leetcode performance. Its performance difference depends on (a) the number of possible paths (O(b^d) where `d` = len(s) / average length of sub-words and `b` is the number of matching sub-words at each point) because this impacts the number of times we use operations to add to the path, and (b) the difference in speed between those operations that we use to add to our path. It also depends on (c) the performance difference between the final append in the first solution and the performance of `\" \".join(path)` and the number of times we execute that operation (which equals the number of solutions for a given input).\\n\\n**Path Joining Operations**: Python\\'s normal string concatenation for all of those possible paths (O(n)) vs the speed of `.appendleft(str)` + `.popleft()` for a `deque` for those same possible paths + the time for all of the `\" \".join(path)`s to execute (each takes O(n) and it only occurs once for each solution).  Correct me if this has changed, but string concatenation in Python occurs in O(n+m) (where `n` and `m` are the lengths of the strings being added), which is obviously slower than the two constant time (O(1)) operations that are `deque`\\'s popleft and appendleft, thus for large inputs the `deque` solution should be faster.\\n\\n**First Solution that uses String Concatenation**\\n```python\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses varying string concatenation to add to path.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(path)\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n\\n                # If we already have a word in the path, add a space in between\\n                if path:\\n                    dfs(dp, end - len(word), word + \" \" + path)\\n                else:\\n                    dfs(dp, end - len(word), word)\\n        \\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), \"\")\\n        return result\\n```\\n\\n**Second Solution using `deque`**:\\n```python\\nfrom collections import deque\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses a deque() to append to and pop from left of list in O(1),\\n        and uses \" \".join(path) to add to result.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(\" \".join(path))\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n                path.appendleft(word)\\n                dfs(dp, end-len(word), path)\\n                path.popleft()\\n\\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), deque())\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses varying string concatenation to add to path.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(path)\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n\\n                # If we already have a word in the path, add a space in between\\n                if path:\\n                    dfs(dp, end - len(word), word + \" \" + path)\\n                else:\\n                    dfs(dp, end - len(word), word)\\n        \\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), \"\")\\n        return result\\n```\n```python\\nfrom collections import deque\\nclass Solution:\\n    def wordBreak(self, s, words):\\n        \"\"\"40ms, beating 98.4%. Uses DP to determine reachable locations\\n        in the word, then a DFS to explore paths from the start to the \\n        end of the word.\\n        \\n        Uses a deque() to append to and pop from left of list in O(1),\\n        and uses \" \".join(path) to add to result.\\n        \"\"\"\\n        result = []\\n             \\n        def dfs(dp, end, path):\\n            \"\"\"A DFS to add paths that reach from the end of the word\\n            to the start.\\n            \"\"\"\\n            # If we have reached the start of the word, add to result\\n            if 0 == end:\\n                result.append(\" \".join(path))\\n                return\\n                \\n            # Otherwise consider each possible path from the end\\n            for word in dp[end]:\\n                path.appendleft(word)\\n                dfs(dp, end-len(word), path)\\n                path.popleft()\\n\\n        # Used for O(1) lookup\\n        word_set = set(words)\\n        \\n        # Used for limiting the search for substrings (words) ending at each position\\n        max_len = max([len(w) for w in words + [\\'\\']])\\n        \\n        # Stores whether a combination of words from `words` can reach the position\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[0] = True\\n        \\n        # Words ending at i\\n        for i in range(1, len(s) + 1):\\n            \\n            # j defines a reachable location & start of a word ending at i\\n            for j in range(max(0, i - max_len), i):\\n            \\n                # If j is a reachable position & j to i defines a dictionary word\\n                if dp[j] and s[j:i] in word_set:\\n                    dp[i].append(s[j:i])\\n    \\n        # For each word in dp[len(s)], explore if it\\'s possible to reach the start of s.\\n        # If so, append a joining of the path to our output\\n        dfs(dp, len(s), deque())\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44271,
                "title": "java-recursive-dp-solution",
                "content": "    public class Solution {\\n        HashMap<String,List<String>> map = new HashMap<String,List<String>>();\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            List<String> res = new ArrayList<String>();\\n            if(s.isEmpty())\\n                return res; // return empty list upon empty string\\n            \\n            if(map.containsKey(s))\\n                return map.get(s);\\n            \\n            for(int i=0; i<s.length(); i++) {\\n                String firstWord = s.substring(0,i+1);\\n                if(wordDict.contains(firstWord)) {\\n                    List<String> rest = wordBreak(s.substring(i+1),wordDict);\\n                    if(rest.isEmpty()) {\\n                        if(i==s.length()-1)\\n                            res.add(firstWord);\\n                    } else {\\n                        for(String str : rest)\\n                            res.add(firstWord + \" \" + str);\\n                    }\\n                }\\n            }\\n            \\n            map.put(s,res);\\n            \\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        HashMap<String,List<String>> map = new HashMap<String,List<String>>();\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            List<String> res = new ArrayList<String>();\\n            if(s.isEmpty())\\n                return res; // return empty list upon empty string\\n            \\n            if(map.containsKey(s))\\n                return map.get(s);\\n            \\n            for(int i=0; i<s.length(); i++) {\\n                String firstWord = s.substring(0,i+1);\\n                if(wordDict.contains(firstWord)) {\\n                    List<String> rest = wordBreak(s.substring(i+1),wordDict);\\n                    if(rest.isEmpty()) {\\n                        if(i==s.length()-1)\\n                            res.add(firstWord);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3107049,
                "title": "c-template-for-word-break-i-ii-concatenated-words",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition for all the problems:\\nAll the three given problems  can be divided into sub-problems .And  If these subproblems individually satisfy the required conditions, then  complete problem will also satisfy the same. And hence we can say whether it is true to find the word in the dictionary or not.\\n\\n# Approach\\n- **Naive Approach**: Use recursion and backtracking. For finding the solution, we check every prefix of the string in the word_dict of words, if it is found , then the recursive function is called for the remaining portion of that string. But this will be$$ 2^n$$ so will give tle . SO we can optimize using memoization or dp.\\n- **DP**: So as we can see that in recurion we call for evrery prefix substring and check if its presnt and like this the we check the whole is present or not .So similarly we can store the same ,like upto certain index whether the substring upto that index is present or not . In this way our dp array will be filled with 0\\'s and 1\\'s representing whether the substring upto that index is present or not . And at last if last index is true i.e dp[n] is true this means whole string is presnt .\\n- So applying this logic we can do all the three problems with a little modification based on requirements.\\n<!-- Describe your approach to solving the problem. -->\\n# **For Word Break I**\\n\\n# Code\\n\\n```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **For Word Break II**\\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n    - $$N^2$$ for two loops and N for `substr`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **For concatenated Words**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$$O(N*W^3)$$\\n    - where `N=word.length and W = words[i].length`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*W)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string>word_set(wordDict.begin(),wordDict.end());\\n        int n=s.size();\\n        vector<bool>dp(n+1,0);\\n        dp[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(!dp[i])continue;\\n            for(int j=i+1;j<=n;j++){\\n                if( word_set.count(s.substr(i,j-i)))\\n                dp[j]=1;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```\\nvector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n    \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);  \\n                    }\\n                }\\n            }\\n        }\\n         return dp[n];\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\\n        unordered_set<string>word_set(words.begin(),words.end());\\n        vector<string>ans;\\n        for(auto w:words){\\n            int n=w.size();\\n            vector<bool>dp(n+1,false);\\n            dp[0]=1;\\n            for(int i=0;i<n;i++){\\n                if(!dp[i])continue;\\n                for(int j=i+1;j<=n;j++){\\n                    if(j-i<n and word_set.count(w.substr(i,j-i)))\\n                    dp[j]=1;\\n                }\\n            }\\n            if(dp[n]==1)ans.push_back(w);\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44195,
                "title": "accepted-java-solution-backtracking-but-what-s-the-difference-with-front-tracking",
                "content": "This is the accepted solution, which might be the \"backtracking\" algorithm. It starts to try the word from the backend.\\n\\n\\tpublic static List<String> wordBreak(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = len -1; i >= 0; i--) {\\n\\t\\t\\tString last = s.substring(i, len);\\n\\t\\t\\tif (dict.contains(last)) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\twords.add(last);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(0, i);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(item + \" \" + last);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\n\\nIt should be the same if it starts from the front, like following. (front-tracking is my invented word, maybe)\\n\\n\\tpublic static List<String> wordBreakFront(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\t\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = 1; i <= len; i++) {\\n\\t\\t\\tString front = s.substring(0, i);\\n\\t\\t\\tif (dict.contains(front)) {\\n\\t\\t\\t\\tif (i == len) {\\n\\t\\t\\t\\t\\twords.add(front);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(i, len);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(front + \" \" + item);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\nBut actually it is not!!!\\nThe later is not accepted for lower efficiency.\\n\\nBut Why?",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "This is the accepted solution, which might be the \"backtracking\" algorithm. It starts to try the word from the backend.\\n\\n\\tpublic static List<String> wordBreak(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = len -1; i >= 0; i--) {\\n\\t\\t\\tString last = s.substring(i, len);\\n\\t\\t\\tif (dict.contains(last)) {\\n\\t\\t\\t\\tif (i == 0) {\\n\\t\\t\\t\\t\\twords.add(last);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(0, i);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(item + \" \" + last);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\n\\nIt should be the same if it starts from the front, like following. (front-tracking is my invented word, maybe)\\n\\n\\tpublic static List<String> wordBreakFront(String s, Set<String> dict) {\\n\\t\\tList<String> words = new ArrayList<String>();\\n\\t\\t\\n\\t\\tint len = s.length();\\n\\t\\tfor (int i = 1; i <= len; i++) {\\n\\t\\t\\tString front = s.substring(0, i);\\n\\t\\t\\tif (dict.contains(front)) {\\n\\t\\t\\t\\tif (i == len) {\\n\\t\\t\\t\\t\\twords.add(front);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tString remain = s.substring(i, len);\\n\\t\\t\\t\\t\\tList<String> remainSet = wordBreak(remain, dict);\\n\\t\\t\\t\\t\\tif (remainSet != null) {\\n\\t\\t\\t\\t\\t\\tfor (String item : remainSet) {\\n\\t\\t\\t\\t\\t\\t\\twords.add(front + \" \" + item);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn words;\\n\\t}\\n\\nBut actually it is not!!!\\nThe later is not accepted for lower efficiency.\\n\\nBut Why?",
                "codeTag": "Unknown"
            },
            {
                "id": 1947487,
                "title": "c-dp-100-0ms",
                "content": "\\t vector<string> wordBreak(string s, vector<string>& dict) {\\n        \\n        int n = s.size();\\n        unordered_map<string,int> map;\\n        \\n        for(int i=0;i<dict.size();i++)\\n        {\\n            map[dict[i]]++;\\n        }\\n        \\n        vector<vector<string>> dp(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                string temp = s.substr(j,i-j+1);\\n                if(map.count(temp))\\n                {\\n                    if(j==0)\\n                    {\\n                        dp[i].push_back(temp);\\n                    }\\n                    else\\n                    {\\n                        for(int k=0;k<dp[j-1].size();k++)\\n                        {\\n                            dp[i].push_back(dp[j-1][k]+\" \"+temp);\\n                        }   \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n\\nevery index of the dp array will store a vector which will store all possible strings which can be formed using the word and the dictionary till ith index.\\n\\nLet we are working on a string temp, we will start checking all the possible break points and at each break point we will check whether it is a valid break point or not.\\nA breakpoint is valid if string before break point can be broken down into words present in dictionary and string after the break point is a word in the dictionary.\\n\\nAt a valid break point , at the previous index there is a vector which has all the valid strings which can be made using the word starting from 0th index to that index , so we just have to append string after the breakpoint to all those strings, and by doing so you will get all possible strings in which the word (till the ith index) can be broken.",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t vector<string> wordBreak(string s, vector<string>& dict) {\\n        \\n        int n = s.size();\\n        unordered_map<string,int> map;\\n        \\n        for(int i=0;i<dict.size();i++)\\n        {\\n            map[dict[i]]++;\\n        }\\n        \\n        vector<vector<string>> dp(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i;j>=0;j--)\\n            {\\n                string temp = s.substr(j,i-j+1);\\n                if(map.count(temp))\\n                {\\n                    if(j==0)\\n                    {\\n                        dp[i].push_back(temp);\\n                    }\\n                    else\\n                    {\\n                        for(int k=0;k<dp[j-1].size();k++)\\n                        {\\n                            dp[i].push_back(dp[j-1][k]+\" \"+temp);\\n                        }   \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[n-1];\\n    }\\n\\nevery index of the dp array will store a vector which will store all possible strings which can be formed using the word and the dictionary till ith index.\\n\\nLet we are working on a string temp, we will start checking all the possible break points and at each break point we will check whether it is a valid break point or not.\\nA breakpoint is valid if string before break point can be broken down into words present in dictionary and string after the break point is a word in the dictionary.\\n\\nAt a valid break point , at the previous index there is a vector which has all the valid strings which can be made using the word starting from 0th index to that index , so we just have to append string after the breakpoint to all those strings, and by doing so you will get all possible strings in which the word (till the ith index) can be broken.",
                "codeTag": "Unknown"
            },
            {
                "id": 1474977,
                "title": "c-trie-dfs",
                "content": "**Time : O(N*M + 2^X)**\\nwhere,\\nN = No. of word in Dict.\\nM = length of longest word\\nX = length of string (s);\\n\\n**Prerequisite:** You should have basic knowledge of Trie.\\nFirst solve this *leetcode-208 [https://leetcode.com/problems/implement-trie-prefix-tree/](http://)*\\nthen, *leetcode-139 [https://leetcode.com/problems/word-break/](http://)*\\nthen try this **(Word Break II)** question.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    class Trie{\\n      public:\\n        Trie* child[26];\\n        bool isEnd=false;\\n    };\\n    \\n    void insert(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) cur->child[ch-\\'a\\'] = new Trie();\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) return false;\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        return cur->isEnd;\\n    }\\n    \\n    void dfs(string &s, int idx, Trie *root, string curStr){\\n        if(idx == s.size()){\\n            ans.push_back(curStr.substr(0,0+curStr.size()-1));   //before pushing in vector remove the extra-space in the last of the string \\n            return;\\n        }\\n        string str=\"\";\\n        for(int i=idx; i<s.size(); ++i){\\n            str.push_back(s[i]);\\n            if(search(str,root)) dfs(s,i+1,root, curStr+str+\" \");\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie *root = new Trie();\\n        for(auto &word : wordDict){\\n            insert(word,root);\\n        }\\n        dfs(s,0,root,\"\");\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> ans;\\n    \\n    class Trie{\\n      public:\\n        Trie* child[26];\\n        bool isEnd=false;\\n    };\\n    \\n    void insert(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) cur->child[ch-\\'a\\'] = new Trie();\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    bool search(string& word, Trie* root){\\n        Trie *cur = root;\\n        for(auto &ch : word){\\n            if(cur->child[ch-\\'a\\']==NULL) return false;\\n            cur = cur->child[ch-\\'a\\'];\\n        }\\n        return cur->isEnd;\\n    }\\n    \\n    void dfs(string &s, int idx, Trie *root, string curStr){\\n        if(idx == s.size()){\\n            ans.push_back(curStr.substr(0,0+curStr.size()-1));   //before pushing in vector remove the extra-space in the last of the string \\n            return;\\n        }\\n        string str=\"\";\\n        for(int i=idx; i<s.size(); ++i){\\n            str.push_back(s[i]);\\n            if(search(str,root)) dfs(s,i+1,root, curStr+str+\" \");\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie *root = new Trie();\\n        for(auto &word : wordDict){\\n            insert(word,root);\\n        }\\n        dfs(s,0,root,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870172,
                "title": "python-simple-dp-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        cache={}\\n        def wordbr(s):\\n            if s not in cache: \\n                result=[]\\n                for w in wordDict:\\n                    if s[:len(w)]==w:\\n                        if len(s)==len(w):\\n                            result.append(w)\\n                        else:\\n                            for word in wordbr(s[len(w):]):\\n                                result.append(w+\" \"+word)\\n                cache[s]=result\\n            return cache[s]\\n        \\n        return wordbr(s)\\n```\\nplease upvote if you like..!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        cache={}\\n        def wordbr(s):\\n            if s not in cache: \\n                result=[]\\n                for w in wordDict:\\n                    if s[:len(w)]==w:\\n                        if len(s)==len(w):\\n                            result.append(w)\\n                        else:\\n                            for word in wordbr(s[len(w):]):\\n                                result.append(w+\" \"+word)\\n                cache[s]=result\\n            return cache[s]\\n        \\n        return wordbr(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163697,
                "title": "4ms-c-solution-based-on-word-break-i",
                "content": "Word Break I solution:\\n\\n```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.begin(), wordDict.end());\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\\n\\nWord Break II solution based on Word Break I dynamic programming solution, search results by backtracking\\n\\n```\\nclass Solution {\\nprivate:\\n    unordered_set<string> words;\\n\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        words.clear();\\n        copy(wordDict.begin(), wordDict.end(), inserter(words, words.end()));\\n\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n        if (dp[n]) {\\n            constructSentence(s, dp, 0, res, \"\");\\n        }\\n        return res;\\n    }\\n\\n    void constructSentence(const string& s,\\n                           const vector<int>& dp,\\n                           int pos,\\n                           vector<string>& res,\\n                           string temp) {\\n        for (int i = pos + 1; i < dp.size(); ++i) {\\n            if (dp[i]) {\\n                string new_word = s.substr(pos, i - pos);\\n                if (words.count(new_word)) {\\n                    if (i + 1 == dp.size()) {\\n                        res.push_back(temp + new_word);\\n                        return;\\n                    }\\n                    constructSentence(s, dp, i, res, temp + new_word + \" \");\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.begin(), wordDict.end());\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    unordered_set<string> words;\\n\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        words.clear();\\n        copy(wordDict.begin(), wordDict.end(), inserter(words, words.end()));\\n\\n        int n = s.size();\\n        vector<int> dp(n + 1, 0);\\n        dp[0] = 1;\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                if (dp[j]) {\\n                    if (words.count(s.substr(j, i - j))) {\\n                        dp[i] = 1;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<string> res;\\n        if (dp[n]) {\\n            constructSentence(s, dp, 0, res, \"\");\\n        }\\n        return res;\\n    }\\n\\n    void constructSentence(const string& s,\\n                           const vector<int>& dp,\\n                           int pos,\\n                           vector<string>& res,\\n                           string temp) {\\n        for (int i = pos + 1; i < dp.size(); ++i) {\\n            if (dp[i]) {\\n                string new_word = s.substr(pos, i - pos);\\n                if (words.count(new_word)) {\\n                    if (i + 1 == dp.size()) {\\n                        res.push_back(temp + new_word);\\n                        return;\\n                    }\\n                    constructSentence(s, dp, i, res, temp + new_word + \" \");\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44232,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Word Break II** https://leetcode.com/problems/word-break-ii/\\n\\n**Memoization**\\n* We parameterize the problem with a single variable k. helper(k, s, ....) returns all the solns to the problem for input string s[k:].\\n* Given a s and k, we divide the string into left and right half by running a loop i from k to len(s). left = s[k:i+1]. If left is a valid word, we call the sub-problem helper(i+1, s...). The output of the sub-problem is combined with left to produce all results.\\n* Corner case: left = s[k:len(s)]. The remainder for this problem is empty. So we return left as an answer given left is a valid word.\\n```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(0, s, set(wordDict), {})\\n\\n    def helper(self, k, s, wordDict, cache):\\n        if k == len(s):\\n            return []\\n        elif k in cache:\\n            return cache[k]\\n        else:\\n            cache[k] = []\\n            for i in range(k, len(s)):\\n                left = s[k:i+1]\\n                if left in wordDict:\\n                    remainder = self.helper(i+1, s, wordDict, cache)\\n                    if remainder:\\n                        for x in remainder:\\n                            cache[k].append(left + \" \" + x)\\n                    elif (i == len(s)-1):\\n                        cache[k].append(left)\\n            return cache[k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return self.helper(0, s, set(wordDict), {})\\n\\n    def helper(self, k, s, wordDict, cache):\\n        if k == len(s):\\n            return []\\n        elif k in cache:\\n            return cache[k]\\n        else:\\n            cache[k] = []\\n            for i in range(k, len(s)):\\n                left = s[k:i+1]\\n                if left in wordDict:\\n                    remainder = self.helper(i+1, s, wordDict, cache)\\n                    if remainder:\\n                        for x in remainder:\\n                            cache[k].append(left + \" \" + x)\\n                    elif (i == len(s)-1):\\n                        cache[k].append(left)\\n            return cache[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938504,
                "title": "100-fastest-swift-solution-time-o-2-n-space-o-2-n",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(2 ^ n), where n is the length of the wordDict.\\n    //   - space: O(2 ^ n), where n is the length of the wordDict.\\n\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var dict = [String: [String]]()\\n        return dfs(s, wordDict, &dict)\\n    }\\n\\n\\n    private func dfs(_ s: String, _ wordDict: [String], _ dict: inout [String: [String]]) -> [String] {\\n        if let val = dict[s] { return val }\\n        guard !s.isEmpty else { return [\"\"] }\\n        var ans = [String]()\\n\\n        for word in wordDict {\\n            guard s.hasPrefix(word) else { continue }\\n            let sublist = dfs(String(s.dropFirst(word.count)), wordDict, &dict)\\n            for sub in sublist {\\n                ans.append(\"\\\\(word)\\\\(sub.isEmpty ? \"\" : \" \")\\\\(sub)\")\\n            }\\n        }\\n\\n        dict[s] = ans\\n        return ans\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(2 ^ n), where n is the length of the wordDict.\\n    //   - space: O(2 ^ n), where n is the length of the wordDict.\\n\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var dict = [String: [String]]()\\n        return dfs(s, wordDict, &dict)\\n    }\\n\\n\\n    private func dfs(_ s: String, _ wordDict: [String], _ dict: inout [String: [String]]) -> [String] {\\n        if let val = dict[s] { return val }\\n        guard !s.isEmpty else { return [\"\"] }\\n        var ans = [String]()\\n\\n        for word in wordDict {\\n            guard s.hasPrefix(word) else { continue }\\n            let sublist = dfs(String(s.dropFirst(word.count)), wordDict, &dict)\\n            for sub in sublist {\\n                ans.append(\"\\\\(word)\\\\(sub.isEmpty ? \"\" : \" \")\\\\(sub)\")\\n            }\\n        }\\n\\n        dict[s] = ans\\n        return ans\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763803,
                "title": "python-simple-dp-solution",
                "content": "The idea of the solution is to have a dictionary `dp` with keys as `start`, where `start` can be any value from 0 to `len(s) - 1`. The value of `dp` is a list of all valid sentences that make up `s[start:]`. This will take a top-down dynamic programming approach.\\n\\n**Example**\\nLet\\'s use example 1, where we are given `s = \"catsanddog\"` and `wordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]`. The following will be the `dp` dict after our program has run:\\n\\n`dp[7] = [\"dog\"]`\\n`dp[4] = [\"and dog\"]`\\n`dp[3] = [\"sand dog\"]`\\n`dp[0] = [\"cats and dog\", \"cat sand dog\"]`\\n\\n```\\nindex : 0 1 2 3 4 5 6 7 8 9\\ns     : c a t s a n d d o g\\n```\\n\\n**Code**\\nTo construct `dp`,  we will use a helper function. `start` is the beginning index of the substring. We first check that `dp[start]` has not been created, if it has been, just return it. \\n\\nThen for each word `w` in `wordDict`, we want to check if the substring starts with the word `w`. If so, then there are two cases. *Case 1* is if `w` is the end of `s`, in our example, that is \"dog\". We don\\'t want to keep searching deeper and we don\\'t want to add a space after \"dog\". *Case 2* is if we should keep searching deeper, in this case we will add future results. In our example, if `w = \"and\"`, we will add \"dog\" to create \"and dog\".\\n\\nFinally, we return `dp[start]`. Since `dp` is a defaultdict, it will return `[]` if we don\\'t append any items to it, which is the case of no valid sentences for the substring `s[start:]`.\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dp = defaultdict(list)\\n        \\n        def helper(start: int) -> List[str]:\\n            if start not in dp:\\n                for w in wordDict:\\n                    if start + len(w) <= len(s) and w == s[start:start+len(w)]:\\n                        if start + len(w) == len(s):\\n\\t\\t\\t\\t\\t\\t\\t# Case 1: No need to go deeper because we are at the end of s\\n                            dp[start].append(w)\\n                        else:\\n\\t\\t\\t\\t\\t\\t\\t# Case 2: Keep searching deeper\\n                            for suffix in helper(start + len(w)):\\n                                dp[start].append(w + \" \" + suffix)\\n            return dp[start]\\n        \\n        return helper(0)\\n```",
                "solutionTags": [],
                "code": "```\\nindex : 0 1 2 3 4 5 6 7 8 9\\ns     : c a t s a n d d o g\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dp = defaultdict(list)\\n        \\n        def helper(start: int) -> List[str]:\\n            if start not in dp:\\n                for w in wordDict:\\n                    if start + len(w) <= len(s) and w == s[start:start+len(w)]:\\n                        if start + len(w) == len(s):\\n\\t\\t\\t\\t\\t\\t\\t# Case 1: No need to go deeper because we are at the end of s\\n                            dp[start].append(w)\\n                        else:\\n\\t\\t\\t\\t\\t\\t\\t# Case 2: Keep searching deeper\\n                            for suffix in helper(start + len(w)):\\n                                dp[start].append(w + \" \" + suffix)\\n            return dp[start]\\n        \\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744674,
                "title": "diagrammatic-python-intuitive-solution-with-example",
                "content": "\\nLets start with a simple version of the problem.\\n\\nAssume you had a function `wordsEndingWith(i)` which gave you all possible strings which end with `s[i:]` i.e; `wordsEndingWith(0)`  would give you all words ending with \"CATSANDDOG\".\\n\\nSo, for example, you know CAT is in your dictionary, you need to know how \"SANDDOG\" could be broken, You\\'d call `wordsEndingWith(3)` which would return you `[\"SAND DOG\"]`. If your dictionary had \"SAN\" and \"DDOG\" too, this function would instead return `[\"SAND DOG\", \"SAN DDOG\"]` (_It returns all possibilities_)\\n\\nSo, all you need to do is call this function bottom up, right:\\n\\n<img src=\"https://assets.leetcode.com/users/images/20686d18-9101-4a89-8a48-adaaa12f44ef_1595190114.0389073.png\" width=400/>\\n\\n```python\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            return ans\\n        return wordsEndingIn(0)\\n```\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/50decb13-7f51-4cc7-9c93-50d41cc6bfcd_1595190815.615007.png\" width=400/>\\n\\n```\\n0 , catsanddog, []\\n\\t s[0:3] or cat is in wordDict, calling sentences(3)\\n3 , sanddog, []\\n\\t s[3:7] or sand is in wordDict, calling sentences(7)\\n7 , dog, []\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , []\\n----\\n\\t s[0:4] or cats is in wordDict, calling sentences(4)\\n4 , anddog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[4:7] or and is in wordDict, calling sentences(7)\\n7 , dog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , [[u\\'dog\\'], [u\\'sand dog\\']]\\n----\\n\\n\\n\\n\\nAnother example:\\n\\n0 , pineapplepenapple, []\\n\\t s[0:4] or pine is in wordDict, calling sentences(4)\\n4 , applepenapple, []\\n\\t s[4:9] or apple is in wordDict, calling sentences(9)\\n9 , penapple, []\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, []\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , []\\n----\\n\\t s[4:12] or applepen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\']]\\n----\\n\\t s[0:9] or pineapple is in wordDict, calling sentences(9)\\n9 , penapple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n----\\n```\\n\\nAs you can see, the parts in blue are actually done repeatedly:\\n\\n<img src=\"https://assets.leetcode.com/users/images/e7a4c4de-52d4-4d30-aaf5-81f8693f9af2_1595190922.2887342.png\" width=400/>\\n\\nThey\\'ve already been computed. \\n\\nThus, we can save such expensive computations and reduce calls to this recursive function by maintaining a hashmap with results of previous calls.\\n\\n```python\\n\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        memo = {}\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in memo:\\n                return memo[i]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            memo[i] = ans\\n            return ans\\n        return wordsEndingIn(0)\\n        \\n\\t\\t```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            return ans\\n        return wordsEndingIn(0)\\n```\n```\\n0 , catsanddog, []\\n\\t s[0:3] or cat is in wordDict, calling sentences(3)\\n3 , sanddog, []\\n\\t s[3:7] or sand is in wordDict, calling sentences(7)\\n7 , dog, []\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , []\\n----\\n\\t s[0:4] or cats is in wordDict, calling sentences(4)\\n4 , anddog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[4:7] or and is in wordDict, calling sentences(7)\\n7 , dog, [[u\\'dog\\'], [u\\'sand dog\\']]\\n\\t s[7:10] or dog is in wordDict, calling sentences(10)\\n10 , , [[u\\'dog\\'], [u\\'sand dog\\']]\\n----\\n\\n\\n\\n\\nAnother example:\\n\\n0 , pineapplepenapple, []\\n\\t s[0:4] or pine is in wordDict, calling sentences(4)\\n4 , applepenapple, []\\n\\t s[4:9] or apple is in wordDict, calling sentences(9)\\n9 , penapple, []\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, []\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , []\\n----\\n\\t s[4:12] or applepen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\']]\\n----\\n\\t s[0:9] or pineapple is in wordDict, calling sentences(9)\\n9 , penapple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[9:12] or pen is in wordDict, calling sentences(12)\\n12 , apple, [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n\\t s[12:17] or apple is in wordDict, calling sentences(17)\\n17 , , [[u\\'apple\\'], [u\\'pen apple\\'], [u\\'apple\\'], [u\\'apple pen apple\\', u\\'applepen apple\\']]\\n----\\n```\n```python\\n\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        memo = {}\\n        def wordsEndingIn(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in memo:\\n                return memo[i]\\n            ans = []\\n            for j in range(i+1, len(s)+1):\\n                if s[i:j] in wordDict:\\n                    for tail in wordsEndingIn(j):\\n                        if tail != \\'\\':\\n                            ans.append(s[i:j] + \" \" + tail) \\n                        else:\\n                            ans.append(s[i:j])\\n            memo[i] = ans\\n            return ans\\n        return wordsEndingIn(0)\\n        \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 44369,
                "title": "my-simple-c-dp-15ms-solution",
                "content": "    class Solution {\\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string> &dict) {\\n            vector<string> res;\\n            if (dict.size() == 0) return res;\\n            \\n            vector<vector<int> > spaceIdx;\\n            spaceIdx.resize(s.size() + 1);\\n            spaceIdx[0].push_back(-1);\\n            \\n            for (int i = 1; i <= s.size(); i++) {\\n                for (int j = 0; j < i; j++) {\\n                    if (spaceIdx[j].size() && dict.count(s.substr(j, i - j))) {\\n                            spaceIdx[i].push_back(j);\\n                    }\\n                }\\n            }\\n            \\n            return backTrack(s, spaceIdx, s.size());\\n        }\\n        \\n        vector<string> backTrack(string& s, vector<vector<int> >& spaceIdx, int idx) {\\n            vector<string> res;\\n            if (idx <= 0) {res.push_back(\"\"); return res;}\\n            \\n            for (int i = 0; i < spaceIdx[idx].size(); i++) {\\n                string str = s.substr(spaceIdx[idx][i], idx - spaceIdx[idx][i]);\\n                vector<string> subRes = backTrack(s, spaceIdx, spaceIdx[idx][i]);\\n                for (int j = 0; j < subRes.size(); j++) {\\n                    if (subRes[j] != \"\") subRes[j] = subRes[j] + \" \" + str;\\n                    else subRes[j] = str;\\n                    res.push_back(subRes[j]);\\n                }\\n            }\\n            \\n            return res;\\n        }\\n    };\\n\\nThe idea is that for each index i of string s, for each j < i check if 1) s.substr(0, j) has valid solution and 2) s.substr(j, i - j + 1) is a valid word. If so then mark j as a sub-solution of i. At the end we trace back from the last index and construct valid word breaks using DFS.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<string> wordBreak(string s, unordered_set<string> &dict) {\\n            vector<string> res;\\n            if (dict.size() == 0) return res;\\n            \\n            vector<vector<int> > spaceIdx;\\n            spaceIdx.resize(s.size() + 1);\\n            spaceIdx[0].push_back(-1);\\n            \\n            for (int i = 1; i <= s.size(); i++) {\\n                for (int j = 0; j < i; j++) {\\n                    if (spaceIdx[j].size() && dict.count(s.substr(j, i - j))) {\\n                            spaceIdx[i].push_back(j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 764151,
                "title": "javascript-75-80ms-heavily-commented-dp",
                "content": "```javascript\\nvar wordBreak = function(s, wordDict) {\\n    const memo = new Map();\\n    \\n    function run(str) {\\n        if(memo.has(str)) return memo.get(str);\\n        if(!str.length) return [];\\n        \\n        const result = [];\\n        \\n        for(let word of wordDict) {\\n            \\n            // find words in the dict that match the start of str\\n            if(str.startsWith(word)) {\\n                // remove the current word from the start of the str\\n                const next = str.slice(word.length);\\n                const paths = run(next); \\n                \\n                // if \\'paths\\' is empty arr, and \\'next\\' is empty str\\n                // current word will be the last one in the sequence\\n                if(!paths.length && !next.length) result.push(word);\\n                \\n                // else map the current word to the start of every path\\n                // and push each path to result\\n                result.push(...paths.map(rest => word + \\' \\' + rest));\\n            }\\n        }\\n        // cache result\\n        memo.set(str, result);\\n        return result;\\n    }\\n    return run(s);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```javascript\\nvar wordBreak = function(s, wordDict) {\\n    const memo = new Map();\\n    \\n    function run(str) {\\n        if(memo.has(str)) return memo.get(str);\\n        if(!str.length) return [];\\n        \\n        const result = [];\\n        \\n        for(let word of wordDict) {\\n            \\n            // find words in the dict that match the start of str\\n            if(str.startsWith(word)) {\\n                // remove the current word from the start of the str\\n                const next = str.slice(word.length);\\n                const paths = run(next); \\n                \\n                // if \\'paths\\' is empty arr, and \\'next\\' is empty str\\n                // current word will be the last one in the sequence\\n                if(!paths.length && !next.length) result.push(word);\\n                \\n                // else map the current word to the start of every path\\n                // and push each path to result\\n                result.push(...paths.map(rest => word + \\' \\' + rest));\\n            }\\n        }\\n        // cache result\\n        memo.set(str, result);\\n        return result;\\n    }\\n    return run(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 587053,
                "title": "problem-is-not-correctly-defined",
                "content": "After solving Word Break problem I was quick to come up with dynamic approach for Word Break II, which is identical to official **Approach 3**. \\nAnd for many of you this approach failed with TLE or Out of memory just like it failed for me for the following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nWhat did I do? Looked up the best rated problem with neat DFS approach\\nhttps://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS\\n\\nThe only reason it succeeds because the way DFS works ... goes deep, go-go-go ... encounter a problem, return empty list early compared with dynamic approach. Basically it \\'short-circuits\\' in this case.\\n\\nBUT if input with s.length() == 151 is a valid input string, then I can construct test case by replacing \\'b\\' with \\'a\\'. Then neither DFS nor dynamic approach would succeed in time/memory limit. Given that test case can have input s with 151 characters and there is no limit on wordDict size this is perfectly valid test case ... or many other similar test cases one can construt to \\'fail\\' both DFS and DP solutions.\\n\\nProblem needs to specify proper restrictions/limit on input size, e.g.\\na <= s.length() <= b\\nc <= wordDict.size() <= d\\nonlyl lower-case or any characters etc.",
                "solutionTags": [],
                "code": "After solving Word Break problem I was quick to come up with dynamic approach for Word Break II, which is identical to official **Approach 3**. \\nAnd for many of you this approach failed with TLE or Out of memory just like it failed for me for the following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\nWhat did I do? Looked up the best rated problem with neat DFS approach\\nhttps://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS\\n\\nThe only reason it succeeds because the way DFS works ... goes deep, go-go-go ... encounter a problem, return empty list early compared with dynamic approach. Basically it \\'short-circuits\\' in this case.\\n\\nBUT if input with s.length() == 151 is a valid input string, then I can construct test case by replacing \\'b\\' with \\'a\\'. Then neither DFS nor dynamic approach would succeed in time/memory limit. Given that test case can have input s with 151 characters and there is no limit on wordDict size this is perfectly valid test case ... or many other similar test cases one can construt to \\'fail\\' both DFS and DP solutions.\\n\\nProblem needs to specify proper restrictions/limit on input size, e.g.\\na <= s.length() <= b\\nc <= wordDict.size() <= d\\nonlyl lower-case or any characters etc.",
                "codeTag": "Unknown"
            },
            {
                "id": 296870,
                "title": "simple-javascript-solution",
                "content": "```\\nvar wordBreak = function(s, wordDict, cache = new Map()) {\\n    if(cache.has(s))\\n        return cache.get(s);\\n    \\n    if(s.length === 0){\\n        cache.set(s, []);\\n        return [];\\n    }\\n    \\n    const result = [];\\n    for(let word of wordDict){\\n        const index = s.indexOf(word);\\n        if(index === 0){\\n            const newStr = s.slice(word.length);\\n            const values = wordBreak(newStr, wordDict, cache);\\n            if(values.length === 0 && newStr.length === 0)\\n                result.push(word);\\n            else{\\n                values.forEach(val => {\\n                    result.push(word + \\' \\' + val);\\n                });\\n            }\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar wordBreak = function(s, wordDict, cache = new Map()) {\\n    if(cache.has(s))\\n        return cache.get(s);\\n    \\n    if(s.length === 0){\\n        cache.set(s, []);\\n        return [];\\n    }\\n    \\n    const result = [];\\n    for(let word of wordDict){\\n        const index = s.indexOf(word);\\n        if(index === 0){\\n            const newStr = s.slice(word.length);\\n            const values = wordBreak(newStr, wordDict, cache);\\n            if(values.length === 0 && newStr.length === 0)\\n                result.push(word);\\n            else{\\n                values.forEach(val => {\\n                    result.push(word + \\' \\' + val);\\n                });\\n            }\\n        }\\n    }\\n    \\n    cache.set(s, result);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 175737,
                "title": "python-solution-continuation-to-word-break",
                "content": "After the DP solution of Word Break, simply use Backtrack to get the valid words that can form a sentence.\\n\\n```\\n  def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dp = [False]*(len(s)+1)\\n        dp[0] = True\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j] == True and s[j:i] in wordDict:\\n                    dp[i] = True\\n        \\n        if dp[-1] == False:\\n            return []\\n        \\n        pos = []\\n        \\n        for i in range(len(dp)):\\n            if dp[i] == True:\\n                pos.append(i-1)\\n        pos.pop(0)\\n        res = []\\n        self.build(pos, s, \"\", res, wordDict, 0)\\n        return res\\n    \\n    def build(self, pos, s, choice, res, wordDict, start):\\n        if start > pos[-1]:\\n            res.append(choice[:-1])\\n            return \\n        \\n        for i in range(len(pos)):\\n            if s[start: pos[i]+1] in wordDict:\\n                self.build(pos, s, choice+s[start:pos[i]+1]+\" \", res, wordDict, pos[i]+1)\\n```",
                "solutionTags": [],
                "code": "```\\n  def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        dp = [False]*(len(s)+1)\\n        dp[0] = True\\n        \\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                if dp[j] == True and s[j:i] in wordDict:\\n                    dp[i] = True\\n        \\n        if dp[-1] == False:\\n            return []\\n        \\n        pos = []\\n        \\n        for i in range(len(dp)):\\n            if dp[i] == True:\\n                pos.append(i-1)\\n        pos.pop(0)\\n        res = []\\n        self.build(pos, s, \"\", res, wordDict, 0)\\n        return res\\n    \\n    def build(self, pos, s, choice, res, wordDict, start):\\n        if start > pos[-1]:\\n            res.append(choice[:-1])\\n            return \\n        \\n        for i in range(len(pos)):\\n            if s[start: pos[i]+1] in wordDict:\\n                self.build(pos, s, choice+s[start:pos[i]+1]+\" \", res, wordDict, pos[i]+1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44191,
                "title": "java-dp-solution",
                "content": "    public class Solution {\\n        \\n      public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> res = new ArrayList<String>();\\n        // Do a fast check and see if we can break the input string\\n        if (!canBreak(s, dict))\\n          return res;\\n        \\n        helper(s, dict, 0, \"\", res);\\n        return res;\\n      }\\n      \\n      void helper(String s, Set<String> dict, int start, String sol, List<String> res) {\\n        if (start == s.length()) {\\n          res.add(sol);\\n          return;\\n        }\\n        \\n        for (int i = start; i < s.length(); i++) {\\n          String sub = s.substring(start, i + 1);\\n          \\n          if (dict.contains(sub))\\n            helper(s, dict, i + 1, sol + (sol.length() == 0 ? \"\" : \" \") + sub, res);\\n        }\\n      }\\n      \\n      // Solution from \"Word Break\"\\n      boolean canBreak(String s, Set<String> dict) {\\n          if (s == null || s.length() == 0) return false;\\n          \\n          int n = s.length();\\n          \\n          // dp[i] represents whether s[0...i] can be formed by dict\\n          boolean[] dp = new boolean[n];\\n          \\n          for (int i = 0; i < n; i++) {\\n              for (int j = 0; j <= i; j++) {\\n                  String sub = s.substring(j, i + 1);\\n                  \\n                  if (dict.contains(sub) && (j == 0 || dp[j - 1])) {\\n                      dp[i] = true;\\n                      break;\\n                  }\\n              }\\n          }\\n          \\n          return dp[n - 1];\\n      }\\n    \\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        \\n      public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> res = new ArrayList<String>();\\n        // Do a fast check and see if we can break the input string\\n        if (!canBreak(s, dict))\\n          return res;\\n        \\n        helper(s, dict, 0, \"\", res);\\n        return res;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2191120,
                "title": "trie-dp-100-faster-c",
                "content": "\\tstruct Node{\\n\\t\\tbool end=false;\\n\\t\\tNode* charset[26];\\n\\n\\t\\tbool containsChar(char ch){\\n\\t\\t\\treturn charset[ch-\\'a\\']!= NULL;\\n\\t\\t}\\n\\n\\t\\tNode* getNode(char ch){\\n\\t\\t\\treturn charset[ch-\\'a\\'];\\n\\t\\t}\\n\\n\\t\\tvoid putChar(char ch, Node* node){\\n\\t\\t\\tcharset[ch-\\'a\\']= node;\\n\\t\\t}\\n\\n\\t};\\n\\n\\n\\tclass Trie{\\n\\t\\tpublic:\\n\\t\\t\\tNode* root;\\n\\t\\tpublic: \\n\\t\\t\\tTrie(){\\n\\t\\t\\t\\troot = new Node();\\n\\t\\t\\t}\\n\\t\\tpublic:\\n\\t\\t\\tvoid insertNode(string s){\\n\\t\\t\\t\\tNode* node = root;\\n\\t\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\t\\tif(!node->containsChar(s[i])){\\n\\t\\t\\t\\t\\t\\t\\tnode->putChar(s[i], new Node());\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnode = node->getNode(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tnode->end = true;\\n\\t\\t\\t}\\n\\t};\\n\\n\\n\\n\\tclass Solution {\\n\\n\\t\\t// sentences function returns the possible sentences as vector of its words,\\n\\t\\t// using words from wordDict and considering the substring\\n\\t\\t// of s  from position pos to end of s .\\n\\n\\n\\tpublic:\\n\\t\\tvector<vector<string>> sentences(string &s,int pos,Node* root,unordered_map<int,vector<vector<string>>> &mem){\\n\\t\\t\\tif(pos>=s.size())\\n\\t\\t\\t\\treturn {{\"\"}};\\n\\n\\t\\t\\tif(mem.find(pos) != mem.end())\\n\\t\\t\\t\\treturn mem[pos];\\n\\n\\t\\t\\tvector<vector<string>> ans,subans;\\n\\t\\t\\tstring temp=\"\";\\n\\n\\t\\t\\t// from pos we iterate and try to find a word in wordDict if exists then move to next substring \\n\\t\\t\\t// and get the possible sentences from it, then append the word found in current call to it.\\n\\t\\t\\t// say we found that cat is a word from wordDict, \\n\\t\\t\\t// again if we find cats is also a word from wordDict, checking it will take O(1) if we use trie\\n\\t\\t\\t// we don\\'t have to check for cats once we found cat , we only check for s after cat\\n\\t\\t\\tNode* node = root;\\n\\t\\t\\tfor(int i=pos; i<s.size(); i++){\\n\\t\\t\\t\\ttemp += s[i];\\n\\t\\t\\t\\tnode= node->getNode(s[i]);\\n\\t\\t\\t\\t// if cats doesn\\'t exist catsa won\\'t exist. \\n\\t\\t\\t\\tif(!node)\\n\\t\\t\\t\\t\\treturn ans;\\n\\n\\t\\t\\t\\tif(node->end){\\n\\n\\t\\t\\t\\t\\tsubans = sentences(s,i+1, root,mem);\\n\\n\\t\\t\\t\\t\\tif(subans.size()>0){\\n\\t\\t\\t\\t\\t\\tfor(int i=0; i<subans.size(); i++){\\n\\t\\t\\t\\t\\t\\t\\tif(subans[i][0].size()==0)\\n\\t\\t\\t\\t\\t\\t\\t\\tsubans[i][0]= temp;\\n\\t\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\t\\tsubans[i].push_back(temp);\\n\\n\\t\\t\\t\\t\\t\\t\\tans.push_back(subans[i]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tmem[pos]= ans;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<string> wordBreak(string s, vector<string>& wordDict) {\\n\\t\\t\\tTrie trie;\\n\\t\\t\\tfor(string s: wordDict){\\n\\t\\t\\t\\ttrie.insertNode(s);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<vector<string>> ans;\\n\\t\\t\\tunordered_map<int,vector<vector<string>>> mem;\\n\\t\\t\\tans= sentences(s,0,trie.root,mem);\\n\\n\\t\\t\\tvector<string> sentences;\\n\\n\\t\\t\\t// make the possible sentences from words of each possible string\\n\\t\\t\\tfor(vector<string> v: ans){\\n\\t\\t\\t\\tstring temp= v.back();\\n\\t\\t\\t\\tfor(int i=v.size()-2; i>=0; i--){\\n\\t\\t\\t\\t\\ttemp += \" \"+v[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsentences.push_back(temp);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn sentences;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Trie"
                ],
                "code": "class Solution {\\n\\n\\t\\t// sentences function returns the possible sentences as vector of its words,\\n\\t\\t// using words from wordDict and considering the substring\\n\\t\\t// of s  from position pos to end of s .\\n\\n\\n\\tpublic:\\n\\t\\tvector<vector<string>> sentences(string &s,int pos,Node* root,unordered_map<int,vector<vector<string>>> &mem){\\n\\t\\t\\tif(pos>=s.size())\\n\\t\\t\\t\\treturn {{\"\"}",
                "codeTag": "Java"
            },
            {
                "id": 44287,
                "title": "java-beating-95-13-with-explanation-dfs-memoization-to-avoid-tle",
                "content": "Basically the idea is to use a boolean array to avoid repeated computation.\\nboolean[] invalid = new boolean[s.length()+1]\\ninvalid[i] means whether s.substring(i) is \"not breakable\"\\nThe helper function will return a boolean value whether the substring is \"breakable\" or not.\\nFor each call to helper function, denote current substring as [left, s.length()). Iterate right pointer i from left+1 to s.length(). If [left, i) can be found in the dict, and [i, s.length()) is \"breakable\", then the whole [left, s.length()) is \"breakable\".\\n\\n     /**\\n     * Leetcode 140. Word Break II.\\n     * https://leetcode.com/problems/word-break-ii/\\n     * Keyword: DFS, backtracking\\n     *\\n     * @param s        string to break\\n     * @param wordDict word dictionary\\n     * @return all the possible ways to break the string into words in the dictionary\\n     */\\n    public List<String> wordBreak2(String s, Set<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        wordBreak2(s, 0, wordDict, \"\", new boolean[s.length() + 1], res);\\n        return res;\\n    }\\n\\n    /**\\n     * Helper function for Leetcode 140. Word Break II.\\n     *\\n     * @param s        string to break\\n     * @param left     start point\\n     * @param wordDict dictionary\\n     * @param prev     previous word found\\n     * @param invalid  invalid[i] means whether [i, s.length()) is unbreakable\\n     * @param res      list to store results\\n     * @return true if s.substring(left) is breakable.\\n     */\\n    private boolean wordBreak2(String s, int left, Set<String> wordDict, String prev, boolean[] invalid, List<String> res) {\\n        // Base case: successfully moved to the end, add result to the list.\\n        if (left == s.length()) {\\n            res.add(prev.trim());\\n            return true;\\n        }\\n        // whether s.substring(left) is breakable\\n        boolean possible = false;\\n        // iterate the pointer from left+1 to the end, find whether [left, i) is valid\\n        for (int i = left + 1; i <= s.length(); i++) {\\n            // if s.substring(i) is unbreakable, continue\\n            if (invalid[i]) {\\n                continue;\\n            }\\n            String sub = s.substring(left, i);\\n            // if substring [left,i) is valid, move on and break from i\\n            if (wordDict.contains(sub)) {\\n                boolean flag = wordBreak2(s, i, wordDict, prev.concat(\" \").concat(sub), invalid, res);\\n                // as long as at least one valid substring [i, end), possible is true\\n                possible = flag || possible;\\n            }\\n        }\\n        // update invalid array\\n        invalid[left] = !possible;\\n        return possible;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Basically the idea is to use a boolean array to avoid repeated computation.\\nboolean[] invalid = new boolean[s.length()+1]\\ninvalid[i] means whether s.substring(i) is \"not breakable\"\\nThe helper function will return a boolean value whether the substring is \"breakable\" or not.\\nFor each call to helper function, denote current substring as [left, s.length()). Iterate right pointer i from left+1 to s.length(). If [left, i) can be found in the dict, and [i, s.length()) is \"breakable\", then the whole [left, s.length()) is \"breakable\".\\n\\n     /**\\n     * Leetcode 140. Word Break II.\\n     * https://leetcode.com/problems/word-break-ii/\\n     * Keyword: DFS, backtracking\\n     *\\n     * @param s        string to break\\n     * @param wordDict word dictionary\\n     * @return all the possible ways to break the string into words in the dictionary\\n     */\\n    public List<String> wordBreak2(String s, Set<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        wordBreak2(s, 0, wordDict, \"\", new boolean[s.length() + 1], res);\\n        return res;\\n    }\\n\\n    /**\\n     * Helper function for Leetcode 140. Word Break II.\\n     *\\n     * @param s        string to break\\n     * @param left     start point\\n     * @param wordDict dictionary\\n     * @param prev     previous word found\\n     * @param invalid  invalid[i] means whether [i, s.length()) is unbreakable\\n     * @param res      list to store results\\n     * @return true if s.substring(left) is breakable.\\n     */\\n    private boolean wordBreak2(String s, int left, Set<String> wordDict, String prev, boolean[] invalid, List<String> res) {\\n        // Base case: successfully moved to the end, add result to the list.\\n        if (left == s.length()) {\\n            res.add(prev.trim());\\n            return true;\\n        }\\n        // whether s.substring(left) is breakable\\n        boolean possible = false;\\n        // iterate the pointer from left+1 to the end, find whether [left, i) is valid\\n        for (int i = left + 1; i <= s.length(); i++) {\\n            // if s.substring(i) is unbreakable, continue\\n            if (invalid[i]) {\\n                continue;\\n            }\\n            String sub = s.substring(left, i);\\n            // if substring [left,i) is valid, move on and break from i\\n            if (wordDict.contains(sub)) {\\n                boolean flag = wordBreak2(s, i, wordDict, prev.concat(\" \").concat(sub), invalid, res);\\n                // as long as at least one valid substring [i, end), possible is true\\n                possible = flag || possible;\\n            }\\n        }\\n        // update invalid array\\n        invalid[left] = !possible;\\n        return possible;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44291,
                "title": "concise-java-solution-recursion-memoization",
                "content": "    public class Solution {\\n    Map<String, List<String>> mem = new HashMap<>();\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (mem.get(s) != null) return mem.get(s);\\n        List<String> result = new ArrayList<>();\\n        if (wordDict.contains(s)) result.add(s);\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(0, i);\\n            if (wordDict.contains(word)) {\\n                List<String> tmp = wordBreak(s.substring(i), wordDict);\\n                for (String str : tmp) {\\n                    result.add(word + \" \" + str);\\n                }\\n            }\\n        }\\n        mem.put(s, result);\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "class Solution {\\n    Map<String, List<String>> mem = new HashMap<>();\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (mem.get(s) != null) return mem.get(s);\\n        List<String> result = new ArrayList<>();\\n        if (wordDict.contains(s)) result.add(s);\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(0, i);\\n            if (wordDict.contains(word)) {\\n                List<String> tmp = wordBreak(s.substring(i), wordDict);\\n                for (String str : tmp) {\\n                    result.add(word + \" \" + str);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 44446,
                "title": "this-is-my-accepted-java-version-program-is-there-any-better-solution",
                "content": "This is my solution. I use DP- with a hashmap recording all the strings that are computed before. \\nMy idea is simple, just partition the string from the first character until the last character. Each time the string is divided into two parts: left and right. Only if the left string exists in the dict, we will try to get all of the combinations of the right string. And then form the list of combinations of the left and right.\\n\\nThe time complexity is O(n^2). Is there any better run time solution?\\n\\n    public class Solution {\\n    HashMap<String, List<String>> map= new HashMap<String, List<String>>();\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> list=new ArrayList<String>();\\n                \\n        if(map.containsKey(s)) return map.get(s);\\n        \\n        for(int i=1; i<=s.length();i++){\\n            String left=s.substring(0,i);\\n            String right=s.substring(i);\\n            if(dict.contains(left)){\\n                List<String> a=wordBreak(right, dict);\\n                for(String b:a){\\n                    list.add(left+\" \"+b);\\n                }\\n                if(right.length()==0) list.add(left);\\n            }\\n            \\n        }\\n   \\n        map.put(s, list);\\n        return list;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    HashMap<String, List<String>> map= new HashMap<String, List<String>>();\\n    public List<String> wordBreak(String s, Set<String> dict) {\\n        List<String> list=new ArrayList<String>();\\n                \\n        if(map.containsKey(s)) return map.get(s);\\n        \\n        for(int i=1; i<=s.length();i++){\\n            String left=s.substring(0,i);\\n            String right=s.substring(i);\\n            if(dict.contains(left)){\\n                List<String> a=wordBreak(right, dict);\\n                for(String b:a){\\n                    list.add(left+\" \"+b);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3106566,
                "title": "beats-100-c-dp-very-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust like word break I here we just have to check prefix substrings are prsnt or not if yes keep adding them uo and graudaully it keeps growing downwards and atlast dp[n] will store the all the strings mad efrom dictionary. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**DP**\\n# Complexity\\n- Time complexity:$$O(N^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n        \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(dp[i].size() > 0 && word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n         return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        int n=s.size();\\n        unordered_set<string>word_Set(wordDict.begin(),wordDict.end());\\n         vector<vector<string>>dp(n+1,vector<string>());\\n         dp[0].push_back(\"\");\\n        \\n          for(int i = 0; i < n; ++i){\\n            for(int j = i+1; j <= n; ++j){\\n                string temp = s.substr(i, j-i);\\n                if(dp[i].size() > 0 && word_Set.count(temp)){\\n                    for(auto x : dp[i]){\\n                        dp[j].emplace_back(x + (x == \"\" ? \"\" : \" \") + temp);\\n                    }\\n                }\\n            }\\n        }\\n        \\n         return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246823,
                "title": "c-0ms-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> memo; //using for memoization (though only recurssive solution can get accepted but for the sake of learning dp)\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        if(memo.find(s) != memo.end()) return memo[s]; //if the target string found in memo, return the vector;\\n        \\n        vector<string> ans; \\n        \\n        //Base case: s = empty string\\n        if(s == \"\"){\\n            ans.push_back(\"\");\\n            return ans;\\n        }\\n        \\n        //else check for every possiblility in wordDict\\n        //which is found in our target string s\\n        \\n        for(const auto word: wordDict){\\n            \\n            //the word which is found at start will only lead to valid possiblities further\\n            if(s.find(word) == 0){\\n                \\n                string remain = s.substr(word.length()); //get the remaining substring \\n                \\n                vector<string> remainAns;\\n                \\n                remainAns = wordBreak(remain , wordDict); //vector<string1,string2, ...>\\n\\n                for(int i=0; i<remainAns.size(); i++){\\n                    \\n                    //add the word to the output string\\n                    if(remainAns[i] == \"\"){     \\n                        remainAns[i] = word;    // e.g 1) remainAns[i] = \"dog\"\\n                    }\\n                    else{\\n                        remainAns[i] = word + \" \" + remainAns[i];  //e.g 2) remainAns[i] = \"and dog\"\\n                    }\\n                    ans.push_back(remainAns[i]);\\n                }\\n            }\\n        }\\n        memo[s] = ans; //storing it in memo for future help\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> memo; //using for memoization (though only recurssive solution can get accepted but for the sake of learning dp)\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        if(memo.find(s) != memo.end()) return memo[s]; //if the target string found in memo, return the vector;\\n        \\n        vector<string> ans; \\n        \\n        //Base case: s = empty string\\n        if(s == \"\"){\\n            ans.push_back(\"\");\\n            return ans;\\n        }\\n        \\n        //else check for every possiblility in wordDict\\n        //which is found in our target string s\\n        \\n        for(const auto word: wordDict){\\n            \\n            //the word which is found at start will only lead to valid possiblities further\\n            if(s.find(word) == 0){\\n                \\n                string remain = s.substr(word.length()); //get the remaining substring \\n                \\n                vector<string> remainAns;\\n                \\n                remainAns = wordBreak(remain , wordDict); //vector<string1,string2, ...>\\n\\n                for(int i=0; i<remainAns.size(); i++){\\n                    \\n                    //add the word to the output string\\n                    if(remainAns[i] == \"\"){     \\n                        remainAns[i] = word;    // e.g 1) remainAns[i] = \"dog\"\\n                    }\\n                    else{\\n                        remainAns[i] = word + \" \" + remainAns[i];  //e.g 2) remainAns[i] = \"and dog\"\\n                    }\\n                    ans.push_back(remainAns[i]);\\n                }\\n            }\\n        }\\n        memo[s] = ans; //storing it in memo for future help\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526377,
                "title": "accepted-c-backtracking-solution-memoization",
                "content": "```\\n    public class Solution\\n    {\\n        private IList<string> Helper(ref string s, int idx, IList<string>[] cache, ISet<string> set)\\n        {\\n            if (cache[idx] != null)\\n            {\\n                return cache[idx];\\n            }\\n\\n            IList<string> res = new List<string>();\\n\\n            for (int l = 1; l <= s.Length - idx; l++)\\n            {\\n                var word = s.Substring(idx, l);\\n                if (set.Contains(word))\\n                {\\n                    var next = idx + l;\\n                    if (next == s.Length)\\n                    {\\n                        res.Add(word);\\n                    }\\n                    else\\n                    {\\n                        var inner = Helper(ref s, next, cache, set);\\n                        foreach (var subsentence in inner)\\n                        {\\n                            res.Add($\"{word} {subsentence}\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            cache[idx] = res;\\n            return res;\\n        }\\n\\n        public IList<string> WordBreak(string s, IList<string> wordDict)\\n        {\\n            IList<string>[] cache = new IList<string>[s.Length];\\n            ISet<string> set = wordDict.ToHashSet();\\n            var res = Helper(ref s, 0, cache, set);\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private IList<string> Helper(ref string s, int idx, IList<string>[] cache, ISet<string> set)\\n        {\\n            if (cache[idx] != null)\\n            {\\n                return cache[idx];\\n            }\\n\\n            IList<string> res = new List<string>();\\n\\n            for (int l = 1; l <= s.Length - idx; l++)\\n            {\\n                var word = s.Substring(idx, l);\\n                if (set.Contains(word))\\n                {\\n                    var next = idx + l;\\n                    if (next == s.Length)\\n                    {\\n                        res.Add(word);\\n                    }\\n                    else\\n                    {\\n                        var inner = Helper(ref s, next, cache, set);\\n                        foreach (var subsentence in inner)\\n                        {\\n                            res.Add($\"{word} {subsentence}\");\\n                        }\\n                    }\\n                }\\n            }\\n\\n            cache[idx] = res;\\n            return res;\\n        }\\n\\n        public IList<string> WordBreak(string s, IList<string> wordDict)\\n        {\\n            IList<string>[] cache = new IList<string>[s.Length];\\n            ISet<string> set = wordDict.ToHashSet();\\n            var res = Helper(ref s, 0, cache, set);\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482162,
                "title": "java-bruteforce-memorized-dfs-approach-clean-code-9ms",
                "content": "**Apprach 1: Bruteforce - TLE**\\n```java\\nclass Solution {\\n    List<String> result = new LinkedList<>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        result.clear();\\n        backtracking(s, 0, new HashSet<>(wordDict), new LinkedList<>(), \"\");\\n        return result;\\n    }\\n\\n    private void backtracking(String s, int step, HashSet<String> wordDict, LinkedList<String> output, String temp) {\\n        if (step == s.length()) {\\n            if (output.size() > 0) {\\n                result.add(String.join(\" \", output));\\n            }\\n            return;\\n        }\\n\\n        for (int i = step; i < s.length(); i++) {\\n            temp += s.charAt(i);\\n            if (wordDict.contains(temp)) { // existed in the wordDict\\n                output.add(temp);\\n                backtracking(s, i + 1, wordDict, output, \"\");\\n                output.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Approach 2: DFS + Memorized - 9ms**\\n```java\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<>());\\n    }\\n\\n    private List<String> DFS(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n        if (cache.containsKey(s)) return cache.get(s);\\n        List<String> res = new LinkedList<>();\\n        if (s.length() == 0) { // found an answer\\n            res.add(\"\");\\n        } else {\\n            for (String word : wordDict) {\\n                if (s.startsWith(word)) {\\n                    List<String> subList = DFS(s.substring(word.length()), wordDict, cache);\\n                    for (String sub : subList) {\\n                        if (sub.isEmpty())\\n                            res.add(word);\\n                        else\\n                            res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        cache.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    List<String> result = new LinkedList<>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        result.clear();\\n        backtracking(s, 0, new HashSet<>(wordDict), new LinkedList<>(), \"\");\\n        return result;\\n    }\\n\\n    private void backtracking(String s, int step, HashSet<String> wordDict, LinkedList<String> output, String temp) {\\n        if (step == s.length()) {\\n            if (output.size() > 0) {\\n                result.add(String.join(\" \", output));\\n            }\\n            return;\\n        }\\n\\n        for (int i = step; i < s.length(); i++) {\\n            temp += s.charAt(i);\\n            if (wordDict.contains(temp)) { // existed in the wordDict\\n                output.add(temp);\\n                backtracking(s, i + 1, wordDict, output, \"\");\\n                output.removeLast();\\n            }\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return DFS(s, wordDict, new HashMap<>());\\n    }\\n\\n    private List<String> DFS(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n        if (cache.containsKey(s)) return cache.get(s);\\n        List<String> res = new LinkedList<>();\\n        if (s.length() == 0) { // found an answer\\n            res.add(\"\");\\n        } else {\\n            for (String word : wordDict) {\\n                if (s.startsWith(word)) {\\n                    List<String> subList = DFS(s.substring(word.length()), wordDict, cache);\\n                    for (String sub : subList) {\\n                        if (sub.isEmpty())\\n                            res.add(word);\\n                        else\\n                            res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        cache.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44258,
                "title": "python-dfs-solution-o-mn-n-running-time",
                "content": "    class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        #running time: O(mn^2), n = len(s), m = len(wordDict)\\n        \"\"\"\\n        Let\\u2018s say the average word length in wordDict is k, so it takes n/k times to reach end.\\n        Each time, the helper function would be called and it's running time is O(m*n)\\n        So the whole runinng time  would be O( m*n*n/k), which is O(m*n^2)\\n        \"\"\"\\n        dic=collections.defaultdict(list)\\n        \\n        def helper(s):\\n            if not s: return [None]\\n            if s in dic: return dic[s]\\n            res =[]\\n            for word in wordDict:\\n                n = len(word)\\n                if word == s[:n]:\\n                    for each in helper(s[n:]):\\n                        if each:res.append(word+\" \"+each)\\n                        else: res.append(word)\\n                dic[s] = res\\n            return res\\n        \\n        return helper(s)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    class Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        #running time: O(mn^2), n = len(s), m = len(wordDict)\\n        \"\"\"\\n        Let\\u2018s say the average word length in wordDict is k, so it takes n/k times to reach end.\\n        Each time, the helper function would be called and it's running time is O(m*n)\\n        So the whole runinng time  would be O( m*n*n/k), which is O(m*n^2)\\n        \"\"\"\\n        dic=collections.defaultdict(list)\\n        \\n        def helper(s):\\n            if not s: return [None]\\n            if s in dic: return dic[s]\\n            res =[]\\n            for word in wordDict:\\n                n = len(word)\\n                if word == s[:n]:\\n                    for each in helper(s[n:]):\\n                        if each:res.append(word+\" \"+each)\\n                        else: res.append(word)\\n                dic[s] = res\\n            return res\\n        \\n        return helper(s)",
                "codeTag": "Java"
            },
            {
                "id": 3332872,
                "title": "c-memoization-trie-well-explained-solution-faster-than-100",
                "content": "**Intuition :**\\n\\nAs we can see, this problem invoves **forward partitioning**, i.e., we have to create partitions at all the gaps between letters and check for the condition:\\n* If the substring generated by partitioning is present in the dictionary, we can continue from the next letter and store the created string in a temporary variable. While returning, concatenate the generated strings with the stored temporary one. \\n\\n\\n* e.g., ![image](https://assets.leetcode.com/users/images/55459ded-54f5-4d25-9574-7839f4560a63_1679586683.848477.jpeg)\\n\\nThus, as we have to search for every partition, we can do DP here for minimising the **outer Time Complexity** to be O(n^2) instead of O(2^n) by normal recursive approach.\\n\\nAlso, as we have to search for words in the dict, we can use set or map but **trie** is a better option according to the time needed.\\n\\nSo, at first, all the words of dictiionary are stored in the trie. \\nNow, a recursive function is called with the **string s**, root of the trie and the index (initially 0).\\n\\nInternally, it is checked if after a partition (rather traversing the trie), we reach at the end of a word, we store it in temp variable and call from the next index and the root of the trie itself (as shown in the figure).\\n\\n**The code :**\\n```\\nstruct Node {\\n    Node * links[26];\\n    bool flag=false;\\n    \\n    bool containsKey (char ch){\\n        return (links[ch-\\'a\\']!=NULL);\\n    }\\n    \\n    void put (char ch, Node * node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    \\n    Node * get (char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    \\n    void setEnd() {\\n        flag=true;\\n    }\\n    \\n    bool isEnd () {\\n        return flag;\\n    }\\n};\\n\\n\\nclass Trie { \\n    \\npublic:\\n    \\n    Node * root;\\n    \\n    Trie() {\\n        root= new Node();\\n    }\\n    \\n    void insert(string word) {\\n        Node * node=root;\\n        for (int i=0;i<word.length();i++){\\n            if (! node->containsKey(word[i])){\\n                node->put(word[i], new Node());\\n            }\\n            //pointing to reference node\\n            node=node->get(word[i]);\\n        }\\n        // marking done\\n        node->setEnd();\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<string> solve (string s, int start, unordered_map <int, vector<string>> &mp, Node * root){\\n        \\n        if (mp.find(start)!=mp.end()) return mp[start];\\n        \\n        int n = s.length();\\n        vector<string> res;\\n        \\n        if (start==n){\\n            res.push_back(\"\");\\n            return mp[start]=res;\\n        }\\n        \\n        Node * cur=root;\\n        \\n        for (int i=start;i<n;i++){\\n            if (! cur->containsKey(s[i])) break;\\n            \\n            cur=cur->get(s[i]);\\n            if (cur->isEnd()){\\n                string temp= s.substr(start, i-start+1);\\n                if (i<s.length()-1){\\n                    temp+=\" \";\\n                }\\n                \\n                vector<string> temp2= solve(s,i+1,mp,root);\\n                for (string a:temp2){\\n                    string temp3=temp+a;\\n                    res.push_back(temp3);\\n                }\\n            }\\n        }\\n        return mp[start]=res;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie trie;\\n        for (auto &temp : wordDict){\\n            trie.insert(temp);\\n        }\\n        unordered_map <int, vector<string>> mp;\\n        return solve (s,0,mp,trie.root);\\n    }\\n};\\n```\\nNote :\\n```\\ns.substr(i,j)= substring of s starting from index i and length j.\\n```\\n\\n**If you like the solution, do upvote.**",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nstruct Node {\\n    Node * links[26];\\n    bool flag=false;\\n    \\n    bool containsKey (char ch){\\n        return (links[ch-\\'a\\']!=NULL);\\n    }\\n    \\n    void put (char ch, Node * node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    \\n    Node * get (char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    \\n    void setEnd() {\\n        flag=true;\\n    }\\n    \\n    bool isEnd () {\\n        return flag;\\n    }\\n};\\n\\n\\nclass Trie { \\n    \\npublic:\\n    \\n    Node * root;\\n    \\n    Trie() {\\n        root= new Node();\\n    }\\n    \\n    void insert(string word) {\\n        Node * node=root;\\n        for (int i=0;i<word.length();i++){\\n            if (! node->containsKey(word[i])){\\n                node->put(word[i], new Node());\\n            }\\n            //pointing to reference node\\n            node=node->get(word[i]);\\n        }\\n        // marking done\\n        node->setEnd();\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    vector<string> solve (string s, int start, unordered_map <int, vector<string>> &mp, Node * root){\\n        \\n        if (mp.find(start)!=mp.end()) return mp[start];\\n        \\n        int n = s.length();\\n        vector<string> res;\\n        \\n        if (start==n){\\n            res.push_back(\"\");\\n            return mp[start]=res;\\n        }\\n        \\n        Node * cur=root;\\n        \\n        for (int i=start;i<n;i++){\\n            if (! cur->containsKey(s[i])) break;\\n            \\n            cur=cur->get(s[i]);\\n            if (cur->isEnd()){\\n                string temp= s.substr(start, i-start+1);\\n                if (i<s.length()-1){\\n                    temp+=\" \";\\n                }\\n                \\n                vector<string> temp2= solve(s,i+1,mp,root);\\n                for (string a:temp2){\\n                    string temp3=temp+a;\\n                    res.push_back(temp3);\\n                }\\n            }\\n        }\\n        return mp[start]=res;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        Trie trie;\\n        for (auto &temp : wordDict){\\n            trie.insert(temp);\\n        }\\n        unordered_map <int, vector<string>> mp;\\n        return solve (s,0,mp,trie.root);\\n    }\\n};\\n```\n```\\ns.substr(i,j)= substring of s starting from index i and length j.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144682,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    void find(string s, unordered_set<string> st, int ind, string cur)\\n    {\\n        if(ind==s.size())\\n        {\\n            cur.pop_back();\\n            res.push_back(cur);\\n        }\\n        string a=\"\";\\n        for(int i=ind; i<s.size();i++)\\n        {\\n            string sub=s.substr(ind, i-ind+1);\\n            if(st.find(sub)!=st.end())\\n            {\\n                find(s, st, i+1, cur+sub+\" \");\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> st;\\n        for(string a:dict)\\n        st.insert(a);\\n        find(s, st, 0, \"\");\\n        return res;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> res;\\n    void find(string s, unordered_set<string> st, int ind, string cur)\\n    {\\n        if(ind==s.size())\\n        {\\n            cur.pop_back();\\n            res.push_back(cur);\\n        }\\n        string a=\"\";\\n        for(int i=ind; i<s.size();i++)\\n        {\\n            string sub=s.substr(ind, i-ind+1);\\n            if(st.find(sub)!=st.end())\\n            {\\n                find(s, st, i+1, cur+sub+\" \");\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& dict) {\\n        unordered_set<string> st;\\n        for(string a:dict)\\n        st.insert(a);\\n        find(s, st, 0, \"\");\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679588,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<int,vector<string>> hm;\\n        unordered_set<string> hs(wordDict.begin(),wordDict.end());\\n        return wordBreakHelper(s, 0, hs, hm);\\n    }\\n\\t\\n    vector<string> wordBreakHelper(string s, int start, unordered_set<string> dict, unordered_map<int,vector<string>> hm ){\\n    if (hm.find(start)!=hm.end())\\n        return hm[start]; \\n\\n    vector<string> validSubstr;\\n\\n    if (start == s.size())\\n        validSubstr.push_back(\"\");\\n\\n    for (int end = start + 1; end <= s.size(); end++) {\\n        string prefix = s.substr(start, end-start);\\n        if (dict.find(prefix)!=dict.end()) //check if prefix is present in dict\\n\\t\\t{\\n            vector<string> suffixes = wordBreakHelper(s, end, dict, hm); //calculate valid sentences for remaining part\\n            for (string suffix : suffixes)\\n               validSubstr.push_back(prefix + (suffix==\"\" ? \"\" : \" \") + suffix);  //combine with prefixe\\n        }\\n    }\\n \\n    hm.insert({start, validSubstr}); //store the result\\n    return validSubstr;\\n }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<int,vector<string>> hm;\\n        unordered_set<string> hs(wordDict.begin(),wordDict.end());\\n        return wordBreakHelper(s, 0, hs, hm);\\n    }\\n\\t\\n    vector<string> wordBreakHelper(string s, int start, unordered_set<string> dict, unordered_map<int,vector<string>> hm ){\\n    if (hm.find(start)!=hm.end())\\n        return hm[start]; \\n\\n    vector<string> validSubstr;\\n\\n    if (start == s.size())\\n        validSubstr.push_back(\"\");\\n\\n    for (int end = start + 1; end <= s.size(); end++) {\\n        string prefix = s.substr(start, end-start);\\n        if (dict.find(prefix)!=dict.end()) //check if prefix is present in dict\\n\\t\\t{\\n            vector<string> suffixes = wordBreakHelper(s, end, dict, hm); //calculate valid sentences for remaining part\\n            for (string suffix : suffixes)\\n               validSubstr.push_back(prefix + (suffix==\"\" ? \"\" : \" \") + suffix);  //combine with prefixe\\n        }\\n    }\\n \\n    hm.insert({start, validSubstr}); //store the result\\n    return validSubstr;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602252,
                "title": "time-beats-99-83-space-beats-88-35",
                "content": "**Explanation**: Whenever I say \"path\", I mean the sequence of words that can be spaced out and appended to our answer. I will be using the word \"path\" a lot to illustrate how this problem is pretty much the combination of [257. Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [139. Word Break](https://leetcode.com/problems/word-break/). Before continuing, I recommend solving the 2 problems that I linked. Essentially, we are constructing all valid \"paths\" that \"might\" lead us to a solution. When we reach the base case, we know that we constructed a valid \"path\", and we therefore append the \"path\" to the result.\\n\\nBelow is the code, please let me know if you have any questions!\\n```\\nclass Solution:\\n    def _wordBreak(self, s, wordDict, start, cur, res):\\n        # Base Case\\n        if start == len(s) and cur:\\n            res.append(\\' \\'.join(cur))\\n            \\n        for i in range(start, len(s)):\\n            word = s[start: i+1]\\n            \\n            if word in wordDict:\\n                \\n                # Append the word since it is in the dictionary\\n                cur.append(word)\\n                \\n                # Recursive Step\\n                self._wordBreak(s, wordDict, i+1, cur, res)\\n                \\n                # Backtracking / Post-processing / Pop the word we appended\\n                cur.pop()\\n        \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self._wordBreak(s, set(wordDict), 0, [], res)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def _wordBreak(self, s, wordDict, start, cur, res):\\n        # Base Case\\n        if start == len(s) and cur:\\n            res.append(\\' \\'.join(cur))\\n            \\n        for i in range(start, len(s)):\\n            word = s[start: i+1]\\n            \\n            if word in wordDict:\\n                \\n                # Append the word since it is in the dictionary\\n                cur.append(word)\\n                \\n                # Recursive Step\\n                self._wordBreak(s, wordDict, i+1, cur, res)\\n                \\n                # Backtracking / Post-processing / Pop the word we appended\\n                cur.pop()\\n        \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res = []\\n        self._wordBreak(s, set(wordDict), 0, [], res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260118,
                "title": "c-easy-backtracking",
                "content": "```\\nvoid wb(vector<string>& res, vector<string>& dict, string s, int idx, int n, string str)\\n   {\\n       if(idx == n)\\n        {\\n            str.pop_back();\\n            res.push_back(str);\\n        }\\n        else\\n        {\\n            for(int k = idx; k < n; k++)\\n            {\\n                string temp = s.substr(idx, k - idx + 1);\\n                if(find(dict.begin(), dict.end(), temp) != dict.end())\\n                   wb(res, dict, s, k + 1, n, str + temp + \\' \\');\\n             }\\n        }\\n   }\\n\\n   vector<string> wordBreak(string s, vector<string>& dict) \\n    {\\n        vector<string> res;\\n        wb(res, dict, s, 0, s.size(), \"\");\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid wb(vector<string>& res, vector<string>& dict, string s, int idx, int n, string str)\\n   {\\n       if(idx == n)\\n        {\\n            str.pop_back();\\n            res.push_back(str);\\n        }\\n        else\\n        {\\n            for(int k = idx; k < n; k++)\\n            {\\n                string temp = s.substr(idx, k - idx + 1);\\n                if(find(dict.begin(), dict.end(), temp) != dict.end())\\n                   wb(res, dict, s, k + 1, n, str + temp + \\' \\');\\n             }\\n        }\\n   }\\n\\n   vector<string> wordBreak(string s, vector<string>& dict) \\n    {\\n        vector<string> res;\\n        wb(res, dict, s, 0, s.size(), \"\");\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 763538,
                "title": "java-dp-backtracking",
                "content": "```\\nclass Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n        List<String>[] str = DP(s, wordDict, dp);\\n        if(!dp[n]) return Collections.emptyList();\\n\\n        List<String> result = new LinkedList<>();\\n        StringBuilder builder = new StringBuilder();\\n        backtracking(result, builder, 0, str);\\n        return result;\\n    }\\n\\n    private void backtracking(List<String> result, StringBuilder builder, int index, List<String>[] str) {\\n\\n        if(index == str.length - 1) {\\n            result.add(builder.deleteCharAt(builder.length() - 1).toString());\\n            return;\\n        }\\n        List<String> list = str[index];\\n        for(String next : list) {\\n            int size = builder.length();\\n            builder.append(next);\\n            builder.append(\" \");\\n            backtracking(result, builder, index + next.length(), str);\\n            builder.delete(size, builder.length());\\n        }\\n\\n    }\\n\\n    private List<String>[] DP(String s, List<String> wordDict, boolean[] dp) {\\n\\n        List<String>[] str = new List[dp.length];\\n        for(int i = 0; i < dp.length - 1; i++) {\\n            if(dp[i]) {\\n                List<String> list = new LinkedList<>();\\n                for (String word: wordDict) {\\n                    if(s.indexOf(word, i) == i) {\\n                        dp[i + word.length()] = true;\\n                        list.add(word);\\n                    }\\n                }\\n                str[i] = list;\\n            }\\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\n        int n = s.length();\\n        boolean[] dp = new boolean[n + 1];\\n        dp[0] = true;\\n        List<String>[] str = DP(s, wordDict, dp);\\n        if(!dp[n]) return Collections.emptyList();\\n\\n        List<String> result = new LinkedList<>();\\n        StringBuilder builder = new StringBuilder();\\n        backtracking(result, builder, 0, str);\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 44286,
                "title": "java-solution-with-memorization",
                "content": "```\\nprivate Map<String, List<String>> map = new HashMap<>();\\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        List<String> list = new ArrayList<>();\\n        if (wordDict.contains(s)) {\\n            list.add(s);\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(i);\\n            if (wordDict.contains(word)) {\\n                List<String> prior = wordBreak(s.substring(0, i), wordDict);\\n                for (String s1 : prior) {\\n                    list.add(s1 + \" \" + word);\\n                }\\n            }\\n        }\\n        map.put(s, list);\\n        return list;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\nprivate Map<String, List<String>> map = new HashMap<>();\\n\\n    public List<String> wordBreak(String s, Set<String> wordDict) {\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        List<String> list = new ArrayList<>();\\n        if (wordDict.contains(s)) {\\n            list.add(s);\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            String word = s.substring(i);\\n            if (wordDict.contains(word)) {\\n                List<String> prior = wordBreak(s.substring(0, i), wordDict);\\n                for (String s1 : prior) {\\n                    list.add(s1 + \" \" + word);\\n                }\\n            }\\n        }\\n        map.put(s, list);\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 44314,
                "title": "10ms-java-solution-with-dp-and-trie",
                "content": "    public List<String> wordBreak(String s, Set<String> wordDict) {\\n            Trie trie = new Trie();\\n            for(String word : wordDict) trie.put(word);\\n            List<String> res = new ArrayList<String>();\\n            List[] dp = new List[s.length()]; // store all the possible legal results of the substring of s starts from index i\\n            char[] c = s.toCharArray();\\n            getDP(c, 0, trie, dp);\\n            for (StringBuilder sb : (List<StringBuilder>)dp[0]) res.add(sb.toString());\\n            return res;\\n        }\\n        // get dp[start]\\n        private List<StringBuilder> getDP(char[] c, int start, Trie trie, List[] dp){\\n            List<Integer> ends = trie.getLegalEnds(c, start);// get all legal end indices starts from index \"start\"\\n            dp[start] = new ArrayList<StringBuilder>();\\n            for (int end : ends){\\n                if (end == c.length - 1) dp[start].add(new StringBuilder().append(c, start, end - start + 1));\\n                else{\\n                    if (dp[end + 1] == null) dp[end + 1] = getDP(c, end + 1, trie, dp);// if don't have dp[i], get it first\\n                    for (StringBuilder sb : (List<StringBuilder>)dp[end + 1]) // combine\\n                        dp[start].add(new StringBuilder().append(c, start, end - start + 1).append(\" \").append(sb));\\n                }\\n            }\\n            return dp[start];\\n        }\\n        \\n        //trie implementation with a little adjustment\\n        private class Trie{\\n            private class Node{\\n                boolean exist = false;\\n                Node[] next = new Node[26];\\n            }\\n            Node root = new Node();\\n            private void put(String word){\\n                put(word, root, 0);\\n            }\\n            private Node put(String word, Node root, int p){\\n                if (root == null) root = new Node();\\n                if (p == word.length()) {\\n                    root.exist = true;\\n                    return root;\\n                }\\n                root.next[word.charAt(p) - 'a'] = put(word, root.next[word.charAt(p) - 'a'], p + 1);\\n                return root;\\n            }\\n            private List<Integer> getLegalEnds(char[] c, int start){\\n                List<Integer> res = new ArrayList<Integer>();\\n                get(c, root, start, res);\\n                return res;\\n            }\\n            private void get(char[] c, Node root, int p, List<Integer> res){\\n                if (root == null) return;\\n                if (root.exist) res.add(p - 1); \\n                if (p == c.length) return;\\n                get(c, root.next[c[p] - 'a'], p + 1, res);\\n            }\\n        }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public List<String> wordBreak(String s, Set<String> wordDict) {\\n            Trie trie = new Trie();\\n            for(String word : wordDict) trie.put(word);\\n            List<String> res = new ArrayList<String>();\\n            List[] dp = new List[s.length()]; // store all the possible legal results of the substring of s starts from index i\\n            char[] c = s.toCharArray();\\n            getDP(c, 0, trie, dp);\\n            for (StringBuilder sb : (List<StringBuilder>)dp[0]) res.add(sb.toString());\\n            return res;\\n        }\\n        // get dp[start]\\n        private List<StringBuilder> getDP(char[] c, int start, Trie trie, List[] dp){\\n            List<Integer> ends = trie.getLegalEnds(c, start);// get all legal end indices starts from index \"start\"\\n            dp[start] = new ArrayList<StringBuilder>();\\n            for (int end : ends){\\n                if (end == c.length - 1) dp[start].add(new StringBuilder().append(c, start, end - start + 1));\\n                else{\\n                    if (dp[end + 1] == null) dp[end + 1] = getDP(c, end + 1, trie, dp);// if don't have dp[i], get it first\\n                    for (StringBuilder sb : (List<StringBuilder>)dp[end + 1]) // combine\\n                        dp[start].add(new StringBuilder().append(c, start, end - start + 1).append(\" \").append(sb));\\n                }\\n            }\\n            return dp[start];\\n        }\\n        \\n        //trie implementation with a little adjustment\\n        private class Trie{\\n            private class Node{\\n                boolean exist = false;\\n                Node[] next = new Node[26];\\n            }\\n            Node root = new Node();\\n            private void put(String word){\\n                put(word, root, 0);\\n            }\\n            private Node put(String word, Node root, int p){\\n                if (root == null) root = new Node();\\n                if (p == word.length()) {\\n                    root.exist = true;\\n                    return root;\\n                }\\n                root.next[word.charAt(p) - 'a'] = put(word, root.next[word.charAt(p) - 'a'], p + 1);\\n                return root;\\n            }\\n            private List<Integer> getLegalEnds(char[] c, int start){\\n                List<Integer> res = new ArrayList<Integer>();\\n                get(c, root, start, res);\\n                return res;\\n            }\\n            private void get(char[] c, Node root, int p, List<Integer> res){\\n                if (root == null) return;\\n                if (root.exist) res.add(p - 1); \\n                if (p == c.length) return;\\n                get(c, root.next[c[p] - 'a'], p + 1, res);\\n            }\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44332,
                "title": "my-python-56ms-solution",
                "content": "    class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            \"\"\"\\n            :type s: str\\n            :type wordDict: Set[str]\\n            :rtype: List[str]\\n            \"\"\"\\n            return findWords(0, len(s), s, wordDict, {})\\n    \\n    def findWords(start, end, s, wordDict, cache):\\n        if start in cache:\\n            return cache[start]\\n        cache[start] = []\\n        candidate = ''\\n        current = start\\n        while current < end:\\n            candidate += s[current]\\n            current += 1\\n            if candidate in wordDict:\\n                if current == end:\\n                    cache[start].append(candidate)\\n                else:\\n                    for x in findWords(current, end, s, wordDict, cache):\\n                        cache[start].append(candidate + ' ' + x)\\n        return cache[start]",
                "solutionTags": [],
                "code": "class Solution(object):\\n        def wordBreak(self, s, wordDict):\\n            \"\"\"\\n            :type s: str\\n            :type wordDict: Set[str]\\n            :rtype: List[str]\\n            \"\"\"\\n            return findWords(0, len(s), s, wordDict, {}",
                "codeTag": "Java"
            },
            {
                "id": 44364,
                "title": "an-elegant-python-solution-with-dp",
                "content": "Basic idea is starting from left most character of string, increase the index, if s[:idx+1] is a valid word, try generate all combinations of s[idx+1:]. Continue doing this until index reaches the end of string. This is a recursive solution, so each time all word break options are calculated, cache them.\\n\\n    class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a list of strings\\n        def wordBreak(self, s, dict):\\n            self.dict = dict\\n            self.cache = {}\\n            return self.break_helper(s)\\n            \\n        def break_helper(self, s):\\n            combs = []\\n            if s in self.cache:\\n                return self.cache[s]\\n            if len(s) == 0:\\n                return []\\n                \\n            for i in range(len(s)):\\n                if s[:i+1] in self.dict:\\n                    if i == len(s) - 1:\\n                        combs.append(s[:i+1])\\n                    else:\\n                        sub_combs = self.break_helper(s[i+1:])\\n                        for sub_comb in sub_combs:\\n                            combs.append(s[:i+1] + ' ' + sub_comb)\\n                        \\n            self.cache[s] = combs\\n            return combs",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param s, a string\\n        # @param dict, a set of string\\n        # @return a list of strings\\n        def wordBreak(self, s, dict):\\n            self.dict = dict\\n            self.cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 3110612,
                "title": "java-hashset-backtracking-simple-concise",
                "content": "```\\nclass Solution {\\n    private List<String> sentences;\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> words = new HashSet<>(wordDict);\\n        sentences = new ArrayList<>();\\n        wordBreak(words, s, 0, \"\");\\n        return sentences;\\n    }\\n\\n    private void wordBreak(Set<String> words, String s, int i, String sentence) {\\n        if (i == s.length()) {\\n            sentences.add(sentence);\\n            return;\\n        }\\n\\n        for (int j = i; j < s.length(); j++) {\\n            String word = s.substring(i, j + 1);\\n            if (words.contains(word)) {\\n                if (sentence.length() == 0) {\\n                    wordBreak(words, s, j + 1, sentence + word);\\n                } else {\\n                    wordBreak(words, s, j + 1, sentence + \" \" + word);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    private List<String> sentences;\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Set<String> words = new HashSet<>(wordDict);\\n        sentences = new ArrayList<>();\\n        wordBreak(words, s, 0, \"\");\\n        return sentences;\\n    }\\n\\n    private void wordBreak(Set<String> words, String s, int i, String sentence) {\\n        if (i == s.length()) {\\n            sentences.add(sentence);\\n            return;\\n        }\\n\\n        for (int j = i; j < s.length(); j++) {\\n            String word = s.substring(i, j + 1);\\n            if (words.contains(word)) {\\n                if (sentence.length() == 0) {\\n                    wordBreak(words, s, j + 1, sentence + word);\\n                } else {\\n                    wordBreak(words, s, j + 1, sentence + \" \" + word);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2714550,
                "title": "c-dfs-faster-easy-to-understand",
                "content": "* ***DFS***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    unordered_set<string> s;\\n\\n    vector<string> res;\\n\\n    void helper(string& str, int i, int n, string curr)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            curr.pop_back();\\n\\n            res.push_back(curr);\\n\\n            return;\\n        }\\n        \\n        // partition str at j and if substring is present int set then call for next\\n\\n        for(int j = i; j < n; j++)\\n        {\\n            if(s.count(str.substr(i, j - i + 1)))\\n            {\\n                helper(str, j + 1, n, curr + str.substr(i, j - i + 1) + \\' \\');\\n            }\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n\\n        int n = str.size();\\n        \\n        // insert all the words into set\\n\\n        for(auto word : wordDict)\\n        {\\n            s.insert(word);\\n        }\\n\\n        helper(str, 0, n, \"\");\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    unordered_set<string> s;\\n\\n    vector<string> res;\\n\\n    void helper(string& str, int i, int n, string curr)\\n    {\\n        // base case\\n        \\n        if(i == n)\\n        {\\n            curr.pop_back();\\n\\n            res.push_back(curr);\\n\\n            return;\\n        }\\n        \\n        // partition str at j and if substring is present int set then call for next\\n\\n        for(int j = i; j < n; j++)\\n        {\\n            if(s.count(str.substr(i, j - i + 1)))\\n            {\\n                helper(str, j + 1, n, curr + str.substr(i, j - i + 1) + \\' \\');\\n            }\\n        }\\n    }\\n    \\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n\\n        int n = str.size();\\n        \\n        // insert all the words into set\\n\\n        for(auto word : wordDict)\\n        {\\n            s.insert(word);\\n        }\\n\\n        helper(str, 0, n, \"\");\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2588753,
                "title": "simple-backtracking-solution-with-path-taken",
                "content": "```\\ndef wordBreak(s, wordDict):\\n\\tresult = []\\n\\tdef backtrack(start, path):\\n\\t\\t# base case/constraint\\n\\t\\tif start == len(s):\\n\\t\\t\\tresult.append(\\' \\'.join(path))\\n\\t\\t\\treturn\\n\\t\\t# iterate through remaining characters\\n\\t\\tfor i in range(start, len(s) + 1):\\n\\t\\t\\t# if the remaning characters form a valid word, only then try to backtrack \\n\\t\\t\\t# with the starting index being the end index of the previous valid word\\n\\t\\t\\tif start[start: i] in wordDict:\\n\\t\\t\\t\\tbacktrack(i, path + [s[start: i]])\\n\\tbacktrack(0, [])\\n\\treturn result\\n```\\nI had not come accross any solution in this discussion thread that used a similart solution to how you would find all permutations of a list. It is easy to understand and doesnt require memoization.",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\ndef wordBreak(s, wordDict):\\n\\tresult = []\\n\\tdef backtrack(start, path):\\n\\t\\t# base case/constraint\\n\\t\\tif start == len(s):\\n\\t\\t\\tresult.append(\\' \\'.join(path))\\n\\t\\t\\treturn\\n\\t\\t# iterate through remaining characters\\n\\t\\tfor i in range(start, len(s) + 1):\\n\\t\\t\\t# if the remaning characters form a valid word, only then try to backtrack \\n\\t\\t\\t# with the starting index being the end index of the previous valid word\\n\\t\\t\\tif start[start: i] in wordDict:\\n\\t\\t\\t\\tbacktrack(i, path + [s[start: i]])\\n\\tbacktrack(0, [])\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2369047,
                "title": "c-100-faster-backtracking-easy-to-understand",
                "content": "# Please UpVote if this solution helps you\\n\\n```\\nvoid solve(string &s,vector<string> &wordDict,string op,int index, vector<string> &ans)\\n    {\\n        if(index == s.length())\\n        {\\n            op.pop_back();    //We pop back here to remove space from the last\\n            ans.push_back(op);\\n            return;\\n        }\\n        string temp = \"\";\\n        for(int i = index;i<s.length();i++)\\n        {\\n            temp += s[i];\\n            if(find(wordDict.begin(),wordDict.end(),temp) != wordDict.end())\\n            {\\n                 solve(s,wordDict,op+temp+\" \",i+1,ans);    //If word find then check for next word\\n            } \\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       vector<string> ans;\\n       string op = \"\";\\n       solve(s,wordDict,op,0,ans);\\n       return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "# Please UpVote if this solution helps you\\n\\n```\\nvoid solve(string &s,vector<string> &wordDict,string op,int index, vector<string> &ans)\\n    {\\n        if(index == s.length())\\n        {\\n            op.pop_back();    //We pop back here to remove space from the last\\n            ans.push_back(op);\\n            return;\\n        }\\n        string temp = \"\";\\n        for(int i = index;i<s.length();i++)\\n        {\\n            temp += s[i];\\n            if(find(wordDict.begin(),wordDict.end(),temp) != wordDict.end())\\n            {\\n                 solve(s,wordDict,op+temp+\" \",i+1,ans);    //If word find then check for next word\\n            } \\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       vector<string> ans;\\n       string op = \"\";\\n       solve(s,wordDict,op,0,ans);\\n       return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1377390,
                "title": "c-100-faster-dp-solution-with-explanation-and-comments",
                "content": "This question is similar to word break 1. The only difference here is that here when we get a true (dictionary match), we add the strings to the anwser using the previously calculated strings. This is a bottom up DP solution.\\n\\nWe do this by building answers and store them in a dp vector where dp[i] stores answer for a string ending at the ith index.\\n* dp[i].first -> A boolean stores if the substring can be partitioned\\n* dp[i].second -> A set that stores all strings created till now for a string ending at the ith index\\n```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        int n = s.size();\\n        \\n        //First we make a dictionary set to fetch words in O(1)\\n        unordered_set<string> dictionary;\\n        for(int i=0; i<wordDict.size(); i++){\\n            dictionary.insert(wordDict[i]);\\n        }\\n        \\n        //Here we store values. dp[i].first stores if the substring can be partitioned\\n        //We create a vector of n+1 size and initialize the first index to true\\n        vector<pair<bool,unordered_set<string>>> dp(n+1);\\n        for(int i=1; i<=n; i++){\\n            dp[i].first = false;\\n        }\\n        \\n        //We initilaize this to true for the case that a dictionary word is the entire string\\n        dp[0].first = true;\\n        \\n        for(int i=1; i<=n; i++){\\n    \\n            //If dp[i-1] was true, we can start building possible words from the (i-1)st index that are in the dictionary\\n            if(dp[i-1].first){\\n                string str = \"\";\\n                for(int j=i-1; j<n; j++){\\n                    str += s[j];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Check if the string from (i-1)st index to jth index exists in dictionary\\n                    if(dictionary.count(str)==1){\\n                        \\n                        //If we find a matching word, this means that the entire string till j can be partitioned\\n                        //So we mark it as true and get string possibilities till here using the previous answer\\n                        dp[j+1].first = true;\\n    \\n                        //If the earlier index did not have any string present (Case where first word in string)\\n                        if(dp[i-1].second.size()==0)\\n                            dp[j+1].second.insert(str);\\n                        \\n                        //Build strings for all possibilities using the last answer\\n                        else{\\n                            for(auto& tempS : dp[i-1].second){\\n                                string newS = tempS + \" \" + str;\\n                                dp[j+1].second.insert(newS);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        \\n        //Return all strings for the string ending at (n-1)st index\\n        for(auto& str : dp[n].second){\\n            ans.push_back(str);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPlease feel free to suggest improvements to this code if any!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        int n = s.size();\\n        \\n        //First we make a dictionary set to fetch words in O(1)\\n        unordered_set<string> dictionary;\\n        for(int i=0; i<wordDict.size(); i++){\\n            dictionary.insert(wordDict[i]);\\n        }\\n        \\n        //Here we store values. dp[i].first stores if the substring can be partitioned\\n        //We create a vector of n+1 size and initialize the first index to true\\n        vector<pair<bool,unordered_set<string>>> dp(n+1);\\n        for(int i=1; i<=n; i++){\\n            dp[i].first = false;\\n        }\\n        \\n        //We initilaize this to true for the case that a dictionary word is the entire string\\n        dp[0].first = true;\\n        \\n        for(int i=1; i<=n; i++){\\n    \\n            //If dp[i-1] was true, we can start building possible words from the (i-1)st index that are in the dictionary\\n            if(dp[i-1].first){\\n                string str = \"\";\\n                for(int j=i-1; j<n; j++){\\n                    str += s[j];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//Check if the string from (i-1)st index to jth index exists in dictionary\\n                    if(dictionary.count(str)==1){\\n                        \\n                        //If we find a matching word, this means that the entire string till j can be partitioned\\n                        //So we mark it as true and get string possibilities till here using the previous answer\\n                        dp[j+1].first = true;\\n    \\n                        //If the earlier index did not have any string present (Case where first word in string)\\n                        if(dp[i-1].second.size()==0)\\n                            dp[j+1].second.insert(str);\\n                        \\n                        //Build strings for all possibilities using the last answer\\n                        else{\\n                            for(auto& tempS : dp[i-1].second){\\n                                string newS = tempS + \" \" + str;\\n                                dp[j+1].second.insert(newS);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        \\n        //Return all strings for the string ending at (n-1)st index\\n        for(auto& str : dp[n].second){\\n            ans.push_back(str);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251729,
                "title": "python-trie-no-dp",
                "content": "```python\\nclass Solution:\\n    class Trie:\\n        def __init__(self):\\n            self.root = {}\\n            self.WORD_DELIM = \\'$\\'\\n            \\n        def addWord(self, word):\\n            cur = self.root\\n            for char in word:\\n                if char not in cur:\\n                    cur[char] = {}\\n                cur = cur[char]\\n            cur[self.WORD_DELIM] = word\\n            \\n        def addWords(self, words):\\n            for word in words:\\n                self.addWord(word)\\n                \\n        def getValidSentences(self, word, res = \\'\\'):            \\n            res = []\\n            def dfs(word=word, temp=[]):\\n                cur = self.root\\n                for i,char in enumerate(word):\\n                    if self.WORD_DELIM in cur:\\n                        dfs(word[i:], temp + [cur[self.WORD_DELIM]])\\n                    if char not in cur:\\n                        break\\n                    cur = cur[char]\\n                else:\\n                    if self.WORD_DELIM in cur:\\n                        res.append(\\' \\'.join(temp + [cur[self.WORD_DELIM]]))\\n            dfs()\\n            return res\\n                \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = self.Trie()\\n        trie.addWords(wordDict)\\n        return trie.getValidSentences(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```python\\nclass Solution:\\n    class Trie:\\n        def __init__(self):\\n            self.root = {}\\n            self.WORD_DELIM = \\'$\\'\\n            \\n        def addWord(self, word):\\n            cur = self.root\\n            for char in word:\\n                if char not in cur:\\n                    cur[char] = {}\\n                cur = cur[char]\\n            cur[self.WORD_DELIM] = word\\n            \\n        def addWords(self, words):\\n            for word in words:\\n                self.addWord(word)\\n                \\n        def getValidSentences(self, word, res = \\'\\'):            \\n            res = []\\n            def dfs(word=word, temp=[]):\\n                cur = self.root\\n                for i,char in enumerate(word):\\n                    if self.WORD_DELIM in cur:\\n                        dfs(word[i:], temp + [cur[self.WORD_DELIM]])\\n                    if char not in cur:\\n                        break\\n                    cur = cur[char]\\n                else:\\n                    if self.WORD_DELIM in cur:\\n                        res.append(\\' \\'.join(temp + [cur[self.WORD_DELIM]]))\\n            dfs()\\n            return res\\n                \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = self.Trie()\\n        trie.addWords(wordDict)\\n        return trie.getValidSentences(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204725,
                "title": "c-0-ms-solution-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string op=\"\";\\n        solve(s, op, wordDict, 0);\\n        return ans;\\n    }\\n    \\n    void solve(string ip, string op, vector<string>mp, int start) {\\n        if(start == ip.size()){\\n            op.pop_back();\\n            ans.push_back(op);\\n            op.push_back(\\' \\');\\n            return;\\n        }\\n        \\n       for(int i=start; i<ip.length(); i++){\\n\\t   //check if the substring is present in the dictionary\\n\\t   \\n           if(find(mp.begin(), mp.end(), ip.substr(start, i-start+1)) != mp.end()) {\\n\\t\\t   //if the above substring is present in the dictionary, add it to the output string\\n\\t\\t   //also add a space after adding the word\\n\\t\\t   \\n               string prev = op;\\n               op += (ip.substr(start, i-start+1));\\n               op.push_back(\\' \\');\\n               solve(ip, op, mp, i+1);\\n\\t\\t\\t   \\n\\t\\t\\t   //backtrack step\\n               op = prev;\\n           }\\n       }\\n    return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>ans;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string op=\"\";\\n        solve(s, op, wordDict, 0);\\n        return ans;\\n    }\\n    \\n    void solve(string ip, string op, vector<string>mp, int start) {\\n        if(start == ip.size()){\\n            op.pop_back();\\n            ans.push_back(op);\\n            op.push_back(\\' \\');\\n            return;\\n        }\\n        \\n       for(int i=start; i<ip.length(); i++){\\n\\t   //check if the substring is present in the dictionary\\n\\t   \\n           if(find(mp.begin(), mp.end(), ip.substr(start, i-start+1)) != mp.end()) {\\n\\t\\t   //if the above substring is present in the dictionary, add it to the output string\\n\\t\\t   //also add a space after adding the word\\n\\t\\t   \\n               string prev = op;\\n               op += (ip.substr(start, i-start+1));\\n               op.push_back(\\' \\');\\n               solve(ip, op, mp, i+1);\\n\\t\\t\\t   \\n\\t\\t\\t   //backtrack step\\n               op = prev;\\n           }\\n       }\\n    return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765548,
                "title": "javascript-python3-c-top-down-bottom-up-partial",
                "content": "**Synopsis:**\\n\\nWe can use [\\uD83C\\uDFA8 The ART of Dynamic Programming ](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/) to construct the answer from right-to-left as the recursive stack unwinds by returning the list of words which can be created at each i-th index based upon the suffix at `S[i]` which is the substring `S[i:N)`, ie. the characters in `S` from `i` inclusive to `N` non-inclusive.\\n\\n**Note:** for the bottom-up solutions, only the JS solution is AC.  Both Python and C++ result in TLE.  This is really strange, I\\'m probably missing something basic, I\\'ll come back and revisit those another time.\\n\\n---\\n\\n**Step 0:** Start with a naive DFS + BT solution.  These solutions TLE as expected, and we cannot add a memo to these solutions because the path is constructed as a parameter passed into the recursive function.  In order to use memoization, we need to return the path as the recursive stack unwinds.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, words = new Set(), ans = []) => {\\n    let N = S.length;\\n    A.forEach(word => words.add(word));\\n    let go = (i = 0, path = []) => {\\n        if (i == N) {\\n            ans.push(path.join(\\' \\'));\\n            return;\\n        }\\n        for (let j = i + 1; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (words.has(cand))\\n                go(j, path.concat(cand));  // \\uD83D\\uDE80 DFS + BT\\n        }\\n    };\\n    go();\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        words = []\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0, path = []):\\n            if i == N:\\n                words.append(path.copy())\\n                return\\n            for j in range(i + 1, N + 1): # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    path.append(cand)\\n                    go(j, path)           # \\uD83D\\uDE80 DFS + BT\\n                    path.pop()\\n        go()\\n        return list(map(lambda row: \\' \\'.join(row), words))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using func = function<void(int, VS&&)>;\\n    VS wordBreak(string S, VS& A, VS words = {}) {\\n        int N = S.size();\\n        Set dict{ A.begin(), A.end() };\\n        func go = [&](int i, VS&& path = {}) {\\n            if (i == N) {\\n                stringstream ss; copy(path.begin(), path.end(), ostream_iterator<string>(ss, \" \"));\\n                auto ans = ss.str();\\n                ans.pop_back(); // remove trailing whitespace\\n                words.emplace_back(ans);\\n                return;\\n            }\\n            for (auto j{ i + 1 }; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end()) {\\n                    path.push_back(cand);\\n                    go(j, move(path));           // \\uD83D\\uDE80 DFS + BT\\n                    path.pop_back();\\n                }\\n            }\\n        };\\n        go(0, {});\\n        return words;\\n    }\\n};\\n```\\n\\n---\\n\\n**Step 1: Brute-Force** (TLE)\\n\\nAs mentioned in the previous step, \"In order to use memoization, we need to return the path as the recursive stack unwinds.\"  So let\\'s first create a brute-force solution which returns the answer as the recursive stack unwinds, then we\\'ll add memoization to this brute-force solution in the next step.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0):\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            return words\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\\n\\n---\\n\\n**Step 2: Memo** (AC)\\n\\nSimply add a memo onto the previous brute-force solutions for AC.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let m = Array(N + 1).fill(null);\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (m[i] != null)                            // \\uD83E\\uDD14 memo\\n            return m[i];\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return m[i] = [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return m[i] = words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        m = [None] * (N + 1)\\n        dict = set(A)\\n        def go(i = 0):\\n            if m[i] != None:                        # \\uD83E\\uDD14 memo\\n                return m[i]\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            m[i] = words\\n            return m[i]\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tusing Map = unordered_map<int, VS>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}, Map m = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (m.find(i) != m.end())               // \\uD83E\\uDD14 memo\\n\\t\\t\\t\\treturn m[i];\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn m[i] = VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn m[i] = words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\\n\\n---\\n\\n**Step 3: Bottom-Up**\\n\\n**Note:** only the JS solution is AC.  Both Python and C++ result in TLE.  This is really strange, I\\'m probably missing something basic, I\\'ll come back and revisit those another time.\\n\\n*Javascript*\\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let dp = [...Array(N + 1)].map(_ => []);         // \\uD83E\\uDD14 memo\\n    dp[N] = [[]];                                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n    A.forEach(word => dict.add(word));\\n    for (let i = N - 1; 0 <= i; --i) {               // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n        for (let j = i + 1; j <= N; ++j) {\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (tail of dp[j])\\n                    dp[i].push([cand].concat(tail)); // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left \\n        }\\n    }\\n    return dp[0].map(words => words.join(\\' \\'));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dp = list(map(lambda _: [], [None] * (N + 1)))         # \\uD83E\\uDD14 memo\\n        dp[N] = [[]]                                           # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        dict = set(A)\\n        for i in range(N - 1, -1, -1):                         # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for j in range(i + 1, N + 1):\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for tail in dp[j]:\\n                        dp[i].append([cand] + tail)            # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        return list(map(lambda words: \\' \\'.join(words), dp[0]))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VVS = vector<VS>;\\n    using Set = unordered_set<string>;\\n    VS wordBreak(string S, VS& A) {\\n        int N = S.size();\\n        VVS dp(N + 1);                              // \\uD83E\\uDD14 memo\\n        dp.back().push_back(\"\");                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        Set dict{ A.begin(), A.end() };\\n        for (auto i{ N - 1 }; 0 <= i; --i) {        // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for (auto j{ i + 1 }; j <= N; ++j) {\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end())\\n                    for (auto& tail: dp[j])         // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left\\n                        dp[i].push_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet wordBreak = (S, A, words = new Set(), ans = []) => {\\n    let N = S.length;\\n    A.forEach(word => words.add(word));\\n    let go = (i = 0, path = []) => {\\n        if (i == N) {\\n            ans.push(path.join(\\' \\'));\\n            return;\\n        }\\n        for (let j = i + 1; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (words.has(cand))\\n                go(j, path.concat(cand));  // \\uD83D\\uDE80 DFS + BT\\n        }\\n    };\\n    go();\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        words = []\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0, path = []):\\n            if i == N:\\n                words.append(path.copy())\\n                return\\n            for j in range(i + 1, N + 1): # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    path.append(cand)\\n                    go(j, path)           # \\uD83D\\uDE80 DFS + BT\\n                    path.pop()\\n        go()\\n        return list(map(lambda row: \\' \\'.join(row), words))\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Set = unordered_set<string>;\\n    using func = function<void(int, VS&&)>;\\n    VS wordBreak(string S, VS& A, VS words = {}) {\\n        int N = S.size();\\n        Set dict{ A.begin(), A.end() };\\n        func go = [&](int i, VS&& path = {}) {\\n            if (i == N) {\\n                stringstream ss; copy(path.begin(), path.end(), ostream_iterator<string>(ss, \" \"));\\n                auto ans = ss.str();\\n                ans.pop_back(); // remove trailing whitespace\\n                words.emplace_back(ans);\\n                return;\\n            }\\n            for (auto j{ i + 1 }; j <= N; ++j) { // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end()) {\\n                    path.push_back(cand);\\n                    go(j, move(path));           // \\uD83D\\uDE80 DFS + BT\\n                    path.pop_back();\\n                }\\n            }\\n        };\\n        go(0, {});\\n        return words;\\n    }\\n};\\n```\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dict = set(A)\\n        def go(i = 0):\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            return words\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let m = Array(N + 1).fill(null);\\n    A.forEach(word => dict.add(word));\\n    let go = (i = 0, words = []) => {\\n        if (m[i] != null)                            // \\uD83E\\uDD14 memo\\n            return m[i];\\n        if (i == N)                                  // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n            return m[i] = [[]];\\n        for (let j = i + 1; j <= N; ++j) {           // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (let tail of go(j))\\n                    words.push([cand].concat(tail)); // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        }\\n        return m[i] = words;\\n    };\\n    return go().map(a => a.join(\\' \\'));\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        m = [None] * (N + 1)\\n        dict = set(A)\\n        def go(i = 0):\\n            if m[i] != None:                        # \\uD83E\\uDD14 memo\\n                return m[i]\\n            words = []\\n            if i == N:                              # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n                return [[]]\\n            for j in range(i + 1, N + 1):           # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for last in go(j):\\n                        words.append([cand] + last) # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n            m[i] = words\\n            return m[i]\\n        return list(map(lambda row: \\' \\'.join(row), go()))\\n```\n```\\nclass Solution {\\npublic:\\n\\tusing VS = vector<string>;\\n\\tusing Set = unordered_set<string>;\\n\\tusing func = function<VS(int)>;\\n\\tusing Map = unordered_map<int, VS>;\\n\\tVS wordBreak(string S, VS& A, Set dict = {}, Map m = {}) {\\n\\t\\tint N = S.size();\\n\\t\\tfor (auto& word: A)\\n\\t\\t\\tdict.insert(word);\\n\\t\\tfunc go = [&](int i, VS words = {}) {\\n\\t\\t\\tif (m.find(i) != m.end())               // \\uD83E\\uDD14 memo\\n\\t\\t\\t\\treturn m[i];\\n\\t\\t\\tif (i == N)                             // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n\\t\\t\\t\\treturn m[i] = VS{\"\"};\\n\\t\\t\\tfor (auto j{ i + 1 }; j <= N; ++j) {    // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n\\t\\t\\t\\tauto cand = S.substr(i, j - i);\\n\\t\\t\\t\\tif (dict.find(cand) != dict.end())\\n\\t\\t\\t\\t\\tfor (auto& tail: go(j))         // \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n\\t\\t\\t\\t\\t\\twords.emplace_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n\\t\\t\\t}\\n\\t\\t\\treturn m[i] = words;\\n\\t\\t};\\n\\t\\treturn go(0);\\n\\t}\\n};\\n```\n```\\nlet wordBreak = (S, A, dict = new Set()) => {\\n    let N = S.length;\\n    let dp = [...Array(N + 1)].map(_ => []);         // \\uD83E\\uDD14 memo\\n    dp[N] = [[]];                                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n    A.forEach(word => dict.add(word));\\n    for (let i = N - 1; 0 <= i; --i) {               // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n        for (let j = i + 1; j <= N; ++j) {\\n            let cand = S.substring(i, j);\\n            if (dict.has(cand))\\n                for (tail of dp[j])\\n                    dp[i].push([cand].concat(tail)); // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left \\n        }\\n    }\\n    return dp[0].map(words => words.join(\\' \\'));\\n};\\n```\n```\\nclass Solution:\\n    def wordBreak(self, S: str, A: List[str]) -> List[str]:\\n        N = len(S)\\n        dp = list(map(lambda _: [], [None] * (N + 1)))         # \\uD83E\\uDD14 memo\\n        dp[N] = [[]]                                           # \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        dict = set(A)\\n        for i in range(N - 1, -1, -1):                         # \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for j in range(i + 1, N + 1):\\n                cand = S[i:j]\\n                if cand in dict:\\n                    for tail in dp[j]:\\n                        dp[i].append([cand] + tail)            # \\uD83D\\uDE80 DFS concat tails onto \\uD83D\\uDD0D found candidates, ie. build \\uD83C\\uDFAF words from \\uD83D\\uDC48 right-to-left\\n        return list(map(lambda words: \\' \\'.join(words), dp[0]))\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using VVS = vector<VS>;\\n    using Set = unordered_set<string>;\\n    VS wordBreak(string S, VS& A) {\\n        int N = S.size();\\n        VVS dp(N + 1);                              // \\uD83E\\uDD14 memo\\n        dp.back().push_back(\"\");                    // \\uD83D\\uDED1 base case: \"empty\" word can be constructed when there are no remaining characters in S\\n        Set dict{ A.begin(), A.end() };\\n        for (auto i{ N - 1 }; 0 <= i; --i) {        // \\u2B50\\uFE0F candidate substrings S[i..j), ie. from i inclusive to j non-inclusive\\n            for (auto j{ i + 1 }; j <= N; ++j) {\\n                auto cand = S.substr(i, j - i);\\n                if (dict.find(cand) != dict.end())\\n                    for (auto& tail: dp[j])         // \\uD83D\\uDE80 concat each tail onto the current candidate, \\uD83D\\uDC48 ie. build the answer from right to left\\n                        dp[i].push_back(cand + (tail.size() ? \" \" + tail : \"\"));\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763825,
                "title": "python-short-recursion-99-5",
                "content": "I\\'m sure the timings are variable but that\\'s what it yielded for me. Also, although I\\'ve called the function DFS the tree structure is perhaps not immediately obvious. \\n\\nThis problem seems oddly easy if you rule out the pathological cases of the form `s=\\'aa...aba...aa\\'` where the words are all `a` string and the like. In the below solution this is done by creating a set of all letters in the words `wordLets` and all letters in the string `stringLets` and returning the empty list if the set difference is non-empty. After that we perform a DFS for the remaining cases. \\n\\nThe DFS takes two arguments `so_far` is a list of the words found so far and `ind` is the start index, which will be right after the last word added to the list. If `ind == n` that means we managed to progress all the way to the end of the string, in which case, wejoin the list of words we\\'ve found and append it to the solution list. Otherwise, if we find a slice `s[ind:i]` which is in the word dictionary, then we call the DFS function recursively with this word added to `so_far` and restarting our scan from position `ind = i` in the string.\\n\\nWe also change the list of input words into a set for faster lookup.\\n\\n\\t\\n\\t\\n\\t\\n\\tdef wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        wordLets = set(\\'\\'.join(wordDict))\\n        wordDict = set(wordDict) #Fast lookup\\n        stringLets = set(s)\\n        \\n        if stringLets - wordLets:\\n            return []\\n        \\n        word_list_list = []\\n        n = len(s)\\n        \\n        def DFS(so_far = [], ind = 0):\\n            if ind == n:\\n                word_list_list.append(\\' \\'.join(so_far))\\n                return\\n            for i in range(ind, n+1):\\n                if s[ind:i] in wordDict:\\n                    DFS(so_far+[s[ind:i]], i)\\n                    \\n        DFS()\\n        \\n        return word_list_list",
                "solutionTags": [],
                "code": "I\\'m sure the timings are variable but that\\'s what it yielded for me. Also, although I\\'ve called the function DFS the tree structure is perhaps not immediately obvious. \\n\\nThis problem seems oddly easy if you rule out the pathological cases of the form `s=\\'aa...aba...aa\\'` where the words are all `a` string and the like. In the below solution this is done by creating a set of all letters in the words `wordLets` and all letters in the string `stringLets` and returning the empty list if the set difference is non-empty. After that we perform a DFS for the remaining cases. \\n\\nThe DFS takes two arguments `so_far` is a list of the words found so far and `ind` is the start index, which will be right after the last word added to the list. If `ind == n` that means we managed to progress all the way to the end of the string, in which case, wejoin the list of words we\\'ve found and append it to the solution list. Otherwise, if we find a slice `s[ind:i]` which is in the word dictionary, then we call the DFS function recursively with this word added to `so_far` and restarting our scan from position `ind = i` in the string.\\n\\nWe also change the list of input words into a set for faster lookup.\\n\\n\\t\\n\\t\\n\\t\\n\\tdef wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        wordLets = set(\\'\\'.join(wordDict))\\n        wordDict = set(wordDict) #Fast lookup\\n        stringLets = set(s)\\n        \\n        if stringLets - wordLets:\\n            return []\\n        \\n        word_list_list = []\\n        n = len(s)\\n        \\n        def DFS(so_far = [], ind = 0):\\n            if ind == n:\\n                word_list_list.append(\\' \\'.join(so_far))\\n                return\\n            for i in range(ind, n+1):\\n                if s[ind:i] in wordDict:\\n                    DFS(so_far+[s[ind:i]], i)\\n                    \\n        DFS()\\n        \\n        return word_list_list",
                "codeTag": "Python3"
            },
            {
                "id": 763397,
                "title": "simple-dp-swift-solution",
                "content": "It\\'s not hard\\n```\\nclass Solution {\\n    \\n    var cache: [String: [String]] = [:]\\n    \\n    func wordBreak(_ str: String, _ wordDict: [String]) -> [String] {\\n        if let ans = cache[str] {\\n            return ans\\n        }\\n        var ans: [String] = []\\n        for word in wordDict {\\n            if str.hasPrefix(word) {\\n                if str.count == word.count {\\n                    ans.append(word)\\n                } else {\\n                    let substr = str.substring(from: word.endIndex)\\n                    var subwords = wordBreak(substr, wordDict)\\n                    for substr in subwords {\\n                        ans.append(word + \" \" + substr)\\n                    }\\n                }\\n            } \\n        }\\n        cache[str] = ans\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    \\n    var cache: [String: [String]] = [:]\\n    \\n    func wordBreak(_ str: String, _ wordDict: [String]) -> [String] {\\n        if let ans = cache[str] {\\n            return ans\\n        }\\n        var ans: [String] = []\\n        for word in wordDict {\\n            if str.hasPrefix(word) {\\n                if str.count == word.count {\\n                    ans.append(word)\\n                } else {\\n                    let substr = str.substring(from: word.endIndex)\\n                    var subwords = wordBreak(substr, wordDict)\\n                    for substr in subwords {\\n                        ans.append(word + \" \" + substr)\\n                    }\\n                }\\n            } \\n        }\\n        cache[str] = ans\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534028,
                "title": "cpp-dfs-memo-to-speed-up",
                "content": "```\\n\\nclass Solution { // dfs + memo\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        map<int, vector<string>> memo;\\n        return dfs(s, dict, 0, memo);\\n    }\\n    vector<string> dfs(string s, set<string> &wordDict, int index, map<int, vector<string>> &memo) {\\n        if(memo.count(index)) return memo[index];\\n        vector<string> ret;\\n        for(int i = index; i < s.size(); i++) {\\n            string cur = s.substr(index, i - index + 1);\\n            if(wordDict.count(cur)) {\\n                if(i == s.size() - 1) ret.push_back(cur);\\n                vector<string> tmp = dfs(s, wordDict, i + 1, memo);\\n                for(string e :tmp) ret.push_back(cur + \" \" + e);\\n            }\\n        }\\n        memo[index] = ret;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution { // dfs + memo\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        set<string> dict(wordDict.begin(), wordDict.end());\\n        map<int, vector<string>> memo;\\n        return dfs(s, dict, 0, memo);\\n    }\\n    vector<string> dfs(string s, set<string> &wordDict, int index, map<int, vector<string>> &memo) {\\n        if(memo.count(index)) return memo[index];\\n        vector<string> ret;\\n        for(int i = index; i < s.size(); i++) {\\n            string cur = s.substr(index, i - index + 1);\\n            if(wordDict.count(cur)) {\\n                if(i == s.size() - 1) ret.push_back(cur);\\n                vector<string> tmp = dfs(s, wordDict, i + 1, memo);\\n                for(string e :tmp) ret.push_back(cur + \" \" + e);\\n            }\\n        }\\n        memo[index] = ret;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481615,
                "title": "python-dfs-memo",
                "content": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        return self.helper(s, memo, wordDict)\\n    def helper(self, s, memo, wordDict):\\n        if s in memo:\\n            return memo[s]\\n        ans = []\\n        if s in wordDict:\\n            ans.append(s)\\n            \\n        for i in range(1, len(s)):  \\n            right = s[i:]\\n            if right not in wordDict:\\n                continue\\n            left = s[:i]\\n            ans += [w + \" \" + right for w in self.helper(left, memo, wordDict)]\\n            \\n        memo[s] = ans\\n        return memo[s]\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\\n        memo = {}\\n        return self.helper(s, memo, wordDict)\\n    def helper(self, s, memo, wordDict):\\n        if s in memo:\\n            return memo[s]\\n        ans = []\\n        if s in wordDict:\\n            ans.append(s)\\n            \\n        for i in range(1, len(s)):  \\n            right = s[i:]\\n            if right not in wordDict:\\n                continue\\n            left = s[:i]\\n            ans += [w + \" \" + right for w in self.helper(left, memo, wordDict)]\\n            \\n        memo[s] = ans\\n        return memo[s]\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 437669,
                "title": "c-trie-memo",
                "content": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        bool isWord;\\n        unordered_map<char,TrieNode*> children;\\n        TrieNode(){\\n            isWord=false;\\n        }\\n    };\\n    \\n    void buildTrie(string &s){\\n        TrieNode* cur=root;\\n        for(int i=0;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                cur->children[s[i]]=new TrieNode();\\n            }\\n            cur=cur->children[s[i]];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        root=new TrieNode();\\n        for(string &word:wordDict){\\n            buildTrie(word);\\n        }\\n        unordered_map<int,vector<string>> memo;\\n        return dfs(s,0,memo);\\n    }\\n    \\n    vector<string> dfs(string &s,int pos,unordered_map<int,vector<string>> &memo){\\n        vector<string> res;\\n        if(pos==s.size()){\\n            res.push_back(\"\");\\n            return res;\\n        }\\n        \\n        if(memo.count(pos)){\\n            return memo[pos];\\n        }\\n        \\n        TrieNode *cur=root;\\n        \\n        for(int i=pos;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                break;\\n            }\\n            cur=cur->children[s[i]];\\n            if(cur->isWord){\\n                int len=i-pos+1;\\n                string tmp=s.substr(pos,len);\\n                if(i<s.size()-1){\\n                    tmp+=\" \";\\n                }\\n                auto next=dfs(s,i+1,memo);\\n                for(string &n:next){\\n                    string t=tmp+n;\\n                    res.push_back(t);\\n                }                \\n            }\\n        }\\n        \\n        memo[pos]=res;\\n        return res;\\n    }\\n    \\nprivate:\\n    TrieNode* root;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        bool isWord;\\n        unordered_map<char,TrieNode*> children;\\n        TrieNode(){\\n            isWord=false;\\n        }\\n    };\\n    \\n    void buildTrie(string &s){\\n        TrieNode* cur=root;\\n        for(int i=0;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                cur->children[s[i]]=new TrieNode();\\n            }\\n            cur=cur->children[s[i]];\\n        }\\n        cur->isWord=true;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        root=new TrieNode();\\n        for(string &word:wordDict){\\n            buildTrie(word);\\n        }\\n        unordered_map<int,vector<string>> memo;\\n        return dfs(s,0,memo);\\n    }\\n    \\n    vector<string> dfs(string &s,int pos,unordered_map<int,vector<string>> &memo){\\n        vector<string> res;\\n        if(pos==s.size()){\\n            res.push_back(\"\");\\n            return res;\\n        }\\n        \\n        if(memo.count(pos)){\\n            return memo[pos];\\n        }\\n        \\n        TrieNode *cur=root;\\n        \\n        for(int i=pos;i<s.size();i++){\\n            if(cur->children.find(s[i])==cur->children.end()){\\n                break;\\n            }\\n            cur=cur->children[s[i]];\\n            if(cur->isWord){\\n                int len=i-pos+1;\\n                string tmp=s.substr(pos,len);\\n                if(i<s.size()-1){\\n                    tmp+=\" \";\\n                }\\n                auto next=dfs(s,i+1,memo);\\n                for(string &n:next){\\n                    string t=tmp+n;\\n                    res.push_back(t);\\n                }                \\n            }\\n        }\\n        \\n        memo[pos]=res;\\n        return res;\\n    }\\n    \\nprivate:\\n    TrieNode* root;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 322400,
                "title": "standard-python-dp-solutions-bottom-up-top-down",
                "content": "Please see and vote for my Python DP solutions for\\n[139. Word Break](https://leetcode.com/problems/word-break/discuss/322388/Standard-DP-solutions-(Bottom-up-Top-down))\\n[140. Word Break II](https://leetcode.com/problems/word-break-ii/discuss/322400/Standard-Python-DP-solutions-(Bottom-up-Top-down))\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n\\nMethod 1: standard DP\\n```\\nLet dp[i] = a list of all possible segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [\\'\\'].\\nRecursive relationship for dp[i]:\\nfor j = i-1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     for each s_break in dp[j]: append s_break + \\' \\' + s[j:i] to dp[i].\\n```\\n\\nSolution 1: bottom-up approach with time O(W + n^3 + 2^n) and **space O(W + n * 2^n)** (Memory Limit Exceeded, 31 / 39 test cases passed)\\n(space complexity: dp: O(n), each dp[i]: O(n), each word in dp[i]: O(n) )\\n```\\n    def wordBreak(self, s, wordDict):\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [\\'\\']\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n        return dp[n]\\n```\\n\\nSolution 2:  top-down approach with time O(W + n^3 + 2^n) and **space O(W + n * 2 ^ n)** (56 ms, beat 44%)\\n(dp[i] will be calculated only if it is necessary. In some test cases, not all d[i] are calculated)\\n```\\n    def wordBreak(self, s, wordDict):\\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: [\\'\\']}\\n        return recursive(len(s))\\n```\\n\\nMethod 2: standard DP + DFS reconstruction\\n```\\nLet dp[i] = a list of all possible last positions of segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [0].\\nRecursive relationship for dp[i]:\\nfor j = i -1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     dp[i].append(j)\\nUse DFS to reconstruct all possible segmentations from the end to the start.\\n```\\n\\nSolution 3: bottom-up approach with time O(W + n^3 + 2^n) and **space O(W + n^2 + n * 2^n)** (52 ms, beat 59.98%)\\ncreate a set of words:  time: O(W), space: O(W)\\n\\ndynamic programming: \\ntime: O(n^3) ((O(n) subproblems, O(n) steps in the nested loop, and O(n) for substring slicing s[j:i]\\nspace: O(n^2)\\n\\nDFS reconstruction: time: O(2^n), space: O(n * 2^n)\\n\\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n                \\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [0]\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    dp[i].append(j)\\n                j -= 1\\n        paths = []\\n        dfs(n, [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```\\n\\nSolution 4: top-down approach with time O(W + n^3 + 2^n) and **space O(W + n^2 + n*2^n)** (44 ms, 87.26%)\\n(dp[i] will be calculated only if it is necessary. In some test cases, not all d[i] are calculated)\\ncreate a set of words:  time: O(W), space: O(W)\\n\\ndynamic programming: \\ntime: O(n^3) ((O(n) subproblems, O(n) steps in the nested loop, and O(n) for substring slicing s[j:i]\\nspace: O(n^2)\\n\\nDFS reconstruction: time: O(2^n), space: O(n * 2^n)\\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n        \\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    dp[i].append(j)\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: 0}\\n        recursive(len(s))\\n        paths = []\\n        dfs(len(s), [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nLet dp[i] = a list of all possible segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [\\'\\'].\\nRecursive relationship for dp[i]:\\nfor j = i-1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     for each s_break in dp[j]: append s_break + \\' \\' + s[j:i] to dp[i].\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [\\'\\']\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n        return dp[n]\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    for s_break in dp[j]:\\n                        dp[i].append(s_break + (\\' \\' if s_break != \\'\\' else \\'\\') + s[j:i])\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: [\\'\\']}\\n        return recursive(len(s))\\n```\n```\\nLet dp[i] = a list of all possible last positions of segmentations of s[:i], i=0,1,2,...,len(s).\\nInitially set dp = [[] for _ in range(len(s) + 1)].\\nBase case: dp[0] = [0].\\nRecursive relationship for dp[i]:\\nfor j = i -1, i-2, ..., 0,\\n     if dp[j] != [] and s[j:i] in wordDict: \\n\\t     dp[i].append(j)\\nUse DFS to reconstruct all possible segmentations from the end to the start.\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n                \\n        word_set = set(wordDict)\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[0] = [0]\\n        for i in range(1, n + 1):\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and dp[j] != []:\\n                    dp[i].append(j)\\n                j -= 1\\n        paths = []\\n        dfs(n, [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```\n```\\n    def wordBreak(self, s, wordDict):\\n        def dfs(i, path):\\n            if i == 0:\\n                path.append(0)\\n                paths.append(path[::-1])\\n            else:\\n                for j in dp[i]:\\n                    dfs(j, path + [i])\\n        \\n        def recursive(i):\\n            if i in dp:\\n                return dp[i]\\n            dp[i] = []\\n            j = i - 1\\n            while j >= 0:\\n                if s[j:i] in word_set and recursive(j) != []:\\n                    dp[i].append(j)\\n                j -= 1\\n            return dp[i]\\n            \\n        word_set = set(wordDict)\\n        dp = {0: 0}\\n        recursive(len(s))\\n        paths = []\\n        dfs(len(s), [])\\n        res = []\\n        for path in paths:\\n            s_break = \\' \\'.join([s[path[k]:path[k+1]] for k in range(len(path) - 1)])\\n            res.append(s_break)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 309369,
                "title": "java-95-11-runtime-4ms-99-77-memory-36-2-mb-human-readable",
                "content": "```\\nclass Solution {\\n    public List<String> wordBreak(String wordToBreak, List<String> wordDict) {        \\n        return findSolutions(wordToBreak, wordDict, new HashMap<>());\\n    }\\n    \\n    public List<String> findSolutions(String wordToBreak, List<String> wordDict, Map<String, List<String>> wordBrokenDict){\\n        if(wordBrokenDict.containsKey(wordToBreak)){\\n            return wordBrokenDict.get(wordToBreak);\\n        }\\n        \\n        List<String> solutions = new ArrayList<>();\\n        for(String word: wordDict){\\n            if(!wordToBreak.startsWith(word)){\\n                continue;\\n            }\\n            \\n            if(wordToBreak.length() == word.length()){\\n                solutions.add(word);\\n                continue;\\n            }\\n            \\n            List<String> subSolutions = findSolutions(wordToBreak.substring(word.length()), wordDict, wordBrokenDict);\\n            for(String subSolution: subSolutions) {\\n                StringBuilder strBuilder = new StringBuilder();\\n                strBuilder.append(word).append(\\' \\').append(subSolution);\\n                solutions.add(strBuilder.toString());\\n            }\\n        }\\n        \\n        wordBrokenDict.put(wordToBreak, solutions);\\n        return solutions;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String wordToBreak, List<String> wordDict) {        \\n        return findSolutions(wordToBreak, wordDict, new HashMap<>());\\n    }\\n    \\n    public List<String> findSolutions(String wordToBreak, List<String> wordDict, Map<String, List<String>> wordBrokenDict){\\n        if(wordBrokenDict.containsKey(wordToBreak)){\\n            return wordBrokenDict.get(wordToBreak);\\n        }\\n        \\n        List<String> solutions = new ArrayList<>();\\n        for(String word: wordDict){\\n            if(!wordToBreak.startsWith(word)){\\n                continue;\\n            }\\n            \\n            if(wordToBreak.length() == word.length()){\\n                solutions.add(word);\\n                continue;\\n            }\\n            \\n            List<String> subSolutions = findSolutions(wordToBreak.substring(word.length()), wordDict, wordBrokenDict);\\n            for(String subSolution: subSolutions) {\\n                StringBuilder strBuilder = new StringBuilder();\\n                strBuilder.append(word).append(\\' \\').append(subSolution);\\n                solutions.add(strBuilder.toString());\\n            }\\n        }\\n        \\n        wordBrokenDict.put(wordToBreak, solutions);\\n        return solutions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222797,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def dfs(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in dic:\\n                return dic[i]\\n            res = []\\n            for j in range(i, len(s)):\\n                head = s[i:j+1]\\n                if head in wordSet:\\n                    tmp = dfs(j+1)\\n                    for string in tmp:\\n                        string = head +\" \"+string\\n                        res.append(string.strip())\\n            dic[i] = res\\n            return res\\n        \\n        dic = {}\\n        wordSet = set(wordDict)\\n        return dfs(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        def dfs(i):\\n            if i == len(s):\\n                return [\"\"]\\n            if i in dic:\\n                return dic[i]\\n            res = []\\n            for j in range(i, len(s)):\\n                head = s[i:j+1]\\n                if head in wordSet:\\n                    tmp = dfs(j+1)\\n                    for string in tmp:\\n                        string = head +\" \"+string\\n                        res.append(string.strip())\\n            dic[i] = res\\n            return res\\n        \\n        dic = {}\\n        wordSet = set(wordDict)\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 190915,
                "title": "c-neat",
                "content": "```\nclass Solution {\npublic:\n    unordered_map<int, vector<string>> umap;\n    \n    vector<string> helper(string &s, unordered_set<string> &dict, int pos) {\n        if (umap.find(pos) != umap.end())\n            return umap[pos];\n        \n        vector<string> res;\n\n        if (dict.find(s.substr(pos)) != dict.end())\n            res.push_back(s.substr(pos));\n        \n        for (int end = pos + 1; end < s.size(); ++end) {\n            string subs = s.substr(pos, end-pos);\n            if (dict.find(subs) != dict.end()) {\n                vector<string> nextlist = helper(s, dict, end);\n                for (auto list_string : nextlist) {\n                    res.push_back(subs + \" \" + list_string);\n                }\n            }\n        }\n        umap[pos] = res;\n        return umap[pos];\n    } \n    \n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\n        return helper(s, dict, 0);\n    }\n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    unordered_map<int, vector<string>> umap;\n    \n    vector<string> helper(string &s, unordered_set<string> &dict, int pos) {\n        if (umap.find(pos) != umap.end())\n            return umap[pos];\n        \n        vector<string> res;\n\n        if (dict.find(s.substr(pos)) != dict.end())\n            res.push_back(s.substr(pos));\n        \n        for (int end = pos + 1; end < s.size(); ++end) {\n            string subs = s.substr(pos, end-pos);\n            if (dict.find(subs) != dict.end()) {\n                vector<string> nextlist = helper(s, dict, end);\n                for (auto list_string : nextlist) {\n                    res.push_back(subs + \" \" + list_string);\n                }\n            }\n        }\n        umap[pos] = res;\n        return umap[pos];\n    } \n    \n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> dict(wordDict.begin(), wordDict.end());\n        return helper(s, dict, 0);\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 116479,
                "title": "solution-using-bfs-idea-from-word-break-i",
                "content": "  This solution is inspired by BFS from Word Break I. Exact same code, just modifying a little bit. First,\tget rid of `visited[]` array. Second, and another queue, this queue will go along with the index queue to store the substrings level by level of the tree.\n\n\tpublic List<String> wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet = new HashSet(wordDict);\n        Queue<Integer> queue = new LinkedList<>();        \n        Queue<String> queueStr = new LinkedList<>();\n        List<String> list = new ArrayList<>();        \n        \n        queue.add(0);\n        queueStr.offer(\"\");\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String currentStr = queueStr.poll();\n                int start = queue.poll();          \n                for (int end = start + 1; end <= s.length(); end++) {\n                    String subStr = s.substring(start, end);\n                    if (wordDictSet.contains(subStr)) {\n                        String newStr = currentStr + subStr;\n                        if (end == s.length())\n                            list.add(newStr);\n                        else {\n                            queueStr.add(newStr + \" \");\n                            queue.add(end);\n                        }\n                    }\n                }\n            }\n        }                                        \n        return list;            \n    }",
                "solutionTags": [],
                "code": "\tpublic List<String> wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet = new HashSet(wordDict);\n        Queue<Integer> queue = new LinkedList<>();        \n        Queue<String> queueStr = new LinkedList<>();\n        List<String> list = new ArrayList<>();        \n        queue.add(0);\n        queueStr.offer(\"\");\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String currentStr = queueStr.poll();\n                int start = queue.poll();          \n                for (int end = start + 1; end <= s.length(); end++) {\n                    String subStr = s.substring(start, end);\n                    if (wordDictSet.contains(subStr)) {\n                        String newStr = currentStr + subStr;\n                        if (end == s.length())\n                            list.add(newStr);\n                        else {\n                            queueStr.add(newStr + \" \");\n                            queue.add(end);\n                        }\n                    }\n                }\n            }\n        }                                        \n        return list;            \n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44301,
                "title": "c-12ms-dp-solution",
                "content": "The flag can be used to save repetitive examinations of of bad substrs.\\n\\n    class Solution {\\n    public:\\n    void helper(vector<bool>& flag, string s, int n, string pre, vector<string> &res, unordered_set<string>& wordDict){\\n        if (n>=s.size()) {res.push_back(pre);return;}\\n        for (int i=n;i<s.size();i++){\\n            if (flag[i+1] && wordDict.find(s.substr(n,i-n+1))!=wordDict.end()){\\n                helper(flag,s,i+1,pre+s.substr(n,i-n+1)+\" \",res,wordDict);\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        vector<string> res;\\n        if (s.empty()) {res.push_back(\"\");return res;}\\n        int k=s.size();\\n        vector<bool> flag(k+1,0);\\n        flag[k] = 1;\\n        for (int i=k-1;i>=0;i--){\\n            int j=i;\\n            while(j<=k-1){\\n                if (flag[j+1] && wordDict.find(s.substr(i,j-i+1))!=wordDict.end()){\\n                    flag[i] = 1;break;\\n                }\\n                j++;\\n            }\\n        }\\n        if (flag[0]==0) return res;   // no possible solution if flag[0]==false\\n        helper(flag,s,0, \"\",res,wordDict);\\n        for (auto &s:res){\\n            s.pop_back();\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    void helper(vector<bool>& flag, string s, int n, string pre, vector<string> &res, unordered_set<string>& wordDict){\\n        if (n>=s.size()) {res.push_back(pre);return;}",
                "codeTag": "Java"
            },
            {
                "id": 44323,
                "title": "8-ms-c-solution-with-explanation-dp-no-recursion",
                "content": "This solution is a two-stage dynamic program.  First: we use the solution from the Word Break problem to find all the break points -- the positions where we might possibly insert a space.  The second dynamic program then builds up the actual solution by skipping through the break-points.\\n\\nNote: comments use python-like notation to indicate substrings.  That is: s[:i] is the substring of s from position 0 up to, but not including, position j.\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        if (n == 0)\\n            return {};\\n            \\n        // First: identify the break points (and that there exists at least one way to break it).\\n        // D[i] = True if it is possible to break up s[:i] in at least one way.\\n        vector<bool> D(n+1, false);\\n        D[0] = true;\\n        for (int i=1; i <= n; i++) {\\n            for (int j=i-1; j >= 0 && D[i] == false; j--) {\\n                D[i] = D[j] && wordDict.find(s.substr(j, i-j)) != wordDict.end();\\n            }\\n        }\\n        \\n        if (!D[n])  // There is no solution.\\n            return {};\\n            \\n        // Find the i such that D[i] is true.\\n        // In given example: break_points = [0,3,4,7,10].\\n        vector<int> break_points;\\n        for (int i=0; i < D.size(); i++) {\\n            if (D[i]) {\\n                break_points.push_back(i);\\n            }\\n        }\\n        \\n        int m = break_points.size();\\n\\n        // Now find the solution based on the breakpoints.\\n        // E[i]: Set of all strings we can create using s[:break_points[i]].\\n        // In the example: E[0] = [\"\"], E[1] = [\"cat\"], E[2] = [\"cats\"], E[3] = [\"cats and\", cat sand\"]\\n        vector<vector<string>> E(m); \\n        E[0] = {\"\"};\\n        for (int i = 0; i < m; i++) {\\n            for (int j=i-1; j >=0; j--) {  // Will now compute E\\n                // t is the string defined from breakpoints i to j\\n                string t = s.substr(break_points[j], break_points[i] - break_points[j]);  \\n                if (wordDict.find(t) != wordDict.end()) {\\n                    for (auto& u : E[j]) \\n                        E[i].push_back(u + \" \" + t);\\n                }\\n            }\\n        }\\n        \\n        // Need to chop off the extra \" \" at the start of each string in E[m-1]\\n        vector<string> R;\\n        transform(E[m-1].begin(), E[m-1].end(), back_inserter(R), [](string& s) {return s.substr(1,s.size()-1);});\\n        return R;\\n    }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "This solution is a two-stage dynamic program.  First: we use the solution from the Word Break problem to find all the break points -- the positions where we might possibly insert a space.  The second dynamic program then builds up the actual solution by skipping through the break-points.\\n\\nNote: comments use python-like notation to indicate substrings.  That is: s[:i] is the substring of s from position 0 up to, but not including, position j.\\n\\n    vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n        int n = s.size();\\n        if (n == 0)\\n            return {};\\n            \\n        // First: identify the break points (and that there exists at least one way to break it).\\n        // D[i] = True if it is possible to break up s[:i] in at least one way.\\n        vector<bool> D(n+1, false);\\n        D[0] = true;\\n        for (int i=1; i <= n; i++) {\\n            for (int j=i-1; j >= 0 && D[i] == false; j--) {\\n                D[i] = D[j] && wordDict.find(s.substr(j, i-j)) != wordDict.end();\\n            }\\n        }\\n        \\n        if (!D[n])  // There is no solution.\\n            return {};\\n            \\n        // Find the i such that D[i] is true.\\n        // In given example: break_points = [0,3,4,7,10].\\n        vector<int> break_points;\\n        for (int i=0; i < D.size(); i++) {\\n            if (D[i]) {\\n                break_points.push_back(i);\\n            }\\n        }\\n        \\n        int m = break_points.size();\\n\\n        // Now find the solution based on the breakpoints.\\n        // E[i]: Set of all strings we can create using s[:break_points[i]].\\n        // In the example: E[0] = [\"\"], E[1] = [\"cat\"], E[2] = [\"cats\"], E[3] = [\"cats and\", cat sand\"]\\n        vector<vector<string>> E(m); \\n        E[0] = {\"\"};\\n        for (int i = 0; i < m; i++) {\\n            for (int j=i-1; j >=0; j--) {  // Will now compute E\\n                // t is the string defined from breakpoints i to j\\n                string t = s.substr(break_points[j], break_points[i] - break_points[j]);  \\n                if (wordDict.find(t) != wordDict.end()) {\\n                    for (auto& u : E[j]) \\n                        E[i].push_back(u + \" \" + t);\\n                }\\n            }\\n        }\\n        \\n        // Need to chop off the extra \" \" at the start of each string in E[m-1]\\n        vector<string> R;\\n        transform(E[m-1].begin(), E[m-1].end(), back_inserter(R), [](string& s) {return s.substr(1,s.size()-1);});\\n        return R;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44321,
                "title": "16ms-java-dp-dfs-solution",
                "content": "    public class Solution {\\n        List<String> result;\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            result = new ArrayList<String>();\\n            int n = s.length();\\n            List<Integer>[] pointer = new List[n];\\n            for(int i=0;i<n;i++) pointer[i]=new ArrayList<Integer>();\\n            //DP to record break point\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(wordDict.contains(s.substring(j,i+1))&&(j==0||pointer[j-1].size()>0))\\n                        pointer[i].add(j);\\n                }\\n            }\\n            helper(pointer, s, n-1, \"\");\\n            return result;\\n        }\\n        //DFS to retrieve results\\n        public void helper(List<Integer>[] pointer, String s, int i, String pattern){\\n            if(i<0){\\n                result.add(pattern);\\n                return;\\n            }\\n            for(Integer item:pointer[i]){\\n                String nextPattern = pattern.length()==0?s.substring(item,i+1):s.substring(item,i+1)+\" \"+pattern;\\n                helper(pointer, s, item-1, nextPattern);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        List<String> result;\\n        public List<String> wordBreak(String s, Set<String> wordDict) {\\n            result = new ArrayList<String>();\\n            int n = s.length();\\n            List<Integer>[] pointer = new List[n];\\n            for(int i=0;i<n;i++) pointer[i]=new ArrayList<Integer>();\\n            //DP to record break point\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<=i;j++){\\n                    if(wordDict.contains(s.substring(j,i+1))&&(j==0||pointer[j-1].size()>0))\\n                        pointer[i].add(j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 44386,
                "title": "my-concise-c-solution",
                "content": "It seems we have to have another round of getting result after the DP search (to not exceed memory limit). Here I inserted spaces to the original string instead of constructing strings.\\n\\n    vector<string> wordBreak(string s, unordered_set<string> &dict)\\n    {\\n    \\tvector<vector<int>> flag(s.size() + 1, vector<int>());\\n    \\tflag[0].push_back(0);\\n    \\tfor (int i = 1; i <= s.size(); i++)\\n    \\t{\\n    \\t\\tfor (int j = 0; j < i; j++)\\n    \\t\\t{\\n    \\t\\t\\tif (!flag[j].empty() && dict.find(s.substr(j, i - j)) != dict.end())\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tflag[i].push_back(j);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tvector<string> result;\\n    \\tgetResult(result, flag, s, s.size());\\n    \\treturn result;\\n    }\\n    \\n    void getResult(vector<string> &result, vector<vector<int>> &flag, string s, int n)\\n    {\\n    \\tfor (int i : flag[n])\\n    \\t{\\n    \\t\\tif (i == 0)\\n    \\t\\t{\\n    \\t\\t\\tresult.push_back(s);\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\ts.insert(s.begin() + i, ' ');\\n    \\t\\tgetResult(result, flag, s, i);\\n    \\t\\ts.erase(i, 1);\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "It seems we have to have another round of getting result after the DP search (to not exceed memory limit). Here I inserted spaces to the original string instead of constructing strings.\\n\\n    vector<string> wordBreak(string s, unordered_set<string> &dict)\\n    {\\n    \\tvector<vector<int>> flag(s.size() + 1, vector<int>());\\n    \\tflag[0].push_back(0);\\n    \\tfor (int i = 1; i <= s.size(); i++)\\n    \\t{\\n    \\t\\tfor (int j = 0; j < i; j++)\\n    \\t\\t{\\n    \\t\\t\\tif (!flag[j].empty() && dict.find(s.substr(j, i - j)) != dict.end())\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tflag[i].push_back(j);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tvector<string> result;\\n    \\tgetResult(result, flag, s, s.size());\\n    \\treturn result;\\n    }\\n    \\n    void getResult(vector<string> &result, vector<vector<int>> &flag, string s, int n)\\n    {\\n    \\tfor (int i : flag[n])\\n    \\t{\\n    \\t\\tif (i == 0)\\n    \\t\\t{\\n    \\t\\t\\tresult.push_back(s);\\n    \\t\\t\\tcontinue;\\n    \\t\\t}\\n    \\t\\ts.insert(s.begin() + i, ' ');\\n    \\t\\tgetResult(result, flag, s, i);\\n    \\t\\ts.erase(i, 1);\\n    \\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 44428,
                "title": "my-solution-using-python",
                "content": "I used a *Trie* to store all the dict words, and then for every position *i* in s, find those position(s) *ed* so that [st, ed) is a dict word. \\n\\nAfter that is basiclly a search problem, simply using dfs (or you can call it memorized search) to check  whether from position *i* we can divide s[i:] with dict words.(say this array is called v, and v[i] = True if s[i:] is dividable.\\n\\nIf v[0] is True, then find all the solutions using recurse.\\n\\nHere is my code using Python.\\n\\n\\n    class Node:\\n    \\tdef __init__(self):\\n    \\t\\tself.next = [ None for i in range(26) ]\\n    \\t\\tself.mark = False\\n    \\n    class Solution:\\n    \\t# @param s, a string\\n    \\t# @param dict, a set of string\\n    \\t# @return a list of strings\\n    \\tdef insert(self, word):\\n    \\t\\tp = self.root\\n    \\t\\tfor s in word:\\n    \\t\\t\\tk = ord(s) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\tp.next[k] = Node()\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\tp.mark = True\\n    \\n    \\tdef build(self, s, st):\\n    \\t\\tn = len(s)\\n    \\t\\tp = self.root\\n    \\t\\tfor i in range(st, n):\\n    \\t\\t\\tif p == None:\\n    \\t\\t\\t\\treturn \\n    \\t\\t\\tk = ord(s[i]) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\treturn\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\t\\tif p.mark:\\n    \\t\\t\\t\\tself.g[st].append(i + 1)    # [st, i + 1) is a word in dict\\n    \\tdef path(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\tself.v[st] = 1\\n    \\t\\t\\treturn 1\\n    \\t\\tif self.v[st] != -1:\\n    \\t\\t\\treturn self.v[st]\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.path(ed):\\n    \\t\\t\\t\\tself.v[st] = 1\\n    \\t\\tif self.v[st] == -1:\\n    \\t\\t\\tself.v[st] = 0\\n    \\t\\treturn self.v[st]\\n    \\n    \\tdef get(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\treturn []\\n    \\t\\tres = []\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.v[ed] == 1:\\n    \\t\\t\\t\\ttmp = self.get(ed)\\n    \\t\\t\\t\\tss = self.s[st:ed]\\n    \\t\\t\\t\\tfor sp in tmp:\\n    \\t\\t\\t\\t\\tres.append(ss + ' ' + sp)\\n    \\t\\t\\t\\tif tmp == []:\\n    \\t\\t\\t\\t\\tres.append(ss)\\n    \\t\\treturn res\\n    \\n    \\tdef wordBreak(self, s, dict):\\n    \\t\\tn = len(s)\\n    \\t\\tself.root = Node()\\n    \\t\\tself.n = n\\n    \\t\\tself.s = s\\n    \\t\\t#self.dict = dict\\n    \\t\\tself.g = [ [] for i in range(n + 1) ]\\n    \\t\\tself.v = [ -1 for i in range(n + 1) ]\\n    \\t\\tfor word in dict:\\n    \\t\\t\\tself.insert(word)\\n    \\t\\tfor i in range(n):\\n    \\t\\t\\tself.build(s, i)\\n    \\t\\tok = self.path(0)\\n    \\t\\tret = []\\n    \\t\\tif ok == 1:\\n    \\t\\t\\tret = self.get(0)\\n    \\t\\treturn ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "I used a *Trie* to store all the dict words, and then for every position *i* in s, find those position(s) *ed* so that [st, ed) is a dict word. \\n\\nAfter that is basiclly a search problem, simply using dfs (or you can call it memorized search) to check  whether from position *i* we can divide s[i:] with dict words.(say this array is called v, and v[i] = True if s[i:] is dividable.\\n\\nIf v[0] is True, then find all the solutions using recurse.\\n\\nHere is my code using Python.\\n\\n\\n    class Node:\\n    \\tdef __init__(self):\\n    \\t\\tself.next = [ None for i in range(26) ]\\n    \\t\\tself.mark = False\\n    \\n    class Solution:\\n    \\t# @param s, a string\\n    \\t# @param dict, a set of string\\n    \\t# @return a list of strings\\n    \\tdef insert(self, word):\\n    \\t\\tp = self.root\\n    \\t\\tfor s in word:\\n    \\t\\t\\tk = ord(s) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\tp.next[k] = Node()\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\tp.mark = True\\n    \\n    \\tdef build(self, s, st):\\n    \\t\\tn = len(s)\\n    \\t\\tp = self.root\\n    \\t\\tfor i in range(st, n):\\n    \\t\\t\\tif p == None:\\n    \\t\\t\\t\\treturn \\n    \\t\\t\\tk = ord(s[i]) - ord('a')\\n    \\t\\t\\tif p.next[k] == None:\\n    \\t\\t\\t\\treturn\\n    \\t\\t\\tp = p.next[k]\\n    \\t\\t\\tif p.mark:\\n    \\t\\t\\t\\tself.g[st].append(i + 1)    # [st, i + 1) is a word in dict\\n    \\tdef path(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\tself.v[st] = 1\\n    \\t\\t\\treturn 1\\n    \\t\\tif self.v[st] != -1:\\n    \\t\\t\\treturn self.v[st]\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.path(ed):\\n    \\t\\t\\t\\tself.v[st] = 1\\n    \\t\\tif self.v[st] == -1:\\n    \\t\\t\\tself.v[st] = 0\\n    \\t\\treturn self.v[st]\\n    \\n    \\tdef get(self, st):\\n    \\t\\tif st == self.n:\\n    \\t\\t\\treturn []\\n    \\t\\tres = []\\n    \\t\\tfor ed in self.g[st]:\\n    \\t\\t\\tif self.v[ed] == 1:\\n    \\t\\t\\t\\ttmp = self.get(ed)\\n    \\t\\t\\t\\tss = self.s[st:ed]\\n    \\t\\t\\t\\tfor sp in tmp:\\n    \\t\\t\\t\\t\\tres.append(ss + ' ' + sp)\\n    \\t\\t\\t\\tif tmp == []:\\n    \\t\\t\\t\\t\\tres.append(ss)\\n    \\t\\treturn res\\n    \\n    \\tdef wordBreak(self, s, dict):\\n    \\t\\tn = len(s)\\n    \\t\\tself.root = Node()\\n    \\t\\tself.n = n\\n    \\t\\tself.s = s\\n    \\t\\t#self.dict = dict\\n    \\t\\tself.g = [ [] for i in range(n + 1) ]\\n    \\t\\tself.v = [ -1 for i in range(n + 1) ]\\n    \\t\\tfor word in dict:\\n    \\t\\t\\tself.insert(word)\\n    \\t\\tfor i in range(n):\\n    \\t\\t\\tself.build(s, i)\\n    \\t\\tok = self.path(0)\\n    \\t\\tret = []\\n    \\t\\tif ok == 1:\\n    \\t\\t\\tret = self.get(0)\\n    \\t\\treturn ret",
                "codeTag": "Java"
            },
            {
                "id": 3567048,
                "title": "brute-force-c-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(int i,int &n,string s1,string s2,string &s,unordered_set<string> &st,vector<string> &ans){\\n    if(i>=n){\\n        cout<<s2<<\" \"<<s1<<endl;\\n        if(st.count(s1)){\\n            s2 += s1;\\n            ans.push_back(s2);\\n        }\\n        return;\\n    }\\n    string str = \"\";\\n    if(st.count(s1)){\\n        solve(i+1,n,str+s[i],s2+s1+\" \",s,st,ans);\\n    }\\n    solve(i+1,n,str+s1+s[i],s2,s,st,ans);\\n}\\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n        unordered_set<string> s;\\n        for(auto &i: wordDict){\\n            s.insert(i);\\n        }\\n        vector<string> ans;\\n        int n = str.length();\\n        solve(0,n,\"\",\"\",str,s,ans);\\n        // for(auto &i: ans)i.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(int i,int &n,string s1,string s2,string &s,unordered_set<string> &st,vector<string> &ans){\\n    if(i>=n){\\n        cout<<s2<<\" \"<<s1<<endl;\\n        if(st.count(s1)){\\n            s2 += s1;\\n            ans.push_back(s2);\\n        }\\n        return;\\n    }\\n    string str = \"\";\\n    if(st.count(s1)){\\n        solve(i+1,n,str+s[i],s2+s1+\" \",s,st,ans);\\n    }\\n    solve(i+1,n,str+s1+s[i],s2,s,st,ans);\\n}\\n    vector<string> wordBreak(string str, vector<string>& wordDict) {\\n        unordered_set<string> s;\\n        for(auto &i: wordDict){\\n            s.insert(i);\\n        }\\n        vector<string> ans;\\n        int n = str.length();\\n        solve(0,n,\"\",\"\",str,s,ans);\\n        // for(auto &i: ans)i.pop_back();\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3000934,
                "title": "backtracking-5ms",
                "content": "# Intuition\\nThe phrase \"all possible solutions\" suggests a backtracking approach. Using DP doesn\\'t save time here. The reason that DP can reduce an exponential running time to polynomial running time is that it doesn\\'t requires explicit enumeration of all cases as long as we are certain we have the optimal value for each subproblem. The cases that aren\\'t optimal can be ignored in DP, but not in backtracking.\\n\\n# Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Time complexity: $$O(2^n)$$. It\\'s proportional to the number of nodes in the recursion tree. And it\\'s the same as total number of ways to partition a string to all combinations of substrings.\\n\\n- Space complexity: $$O(n)$$. Only the StringBuilder requires extra memory.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> results = new LinkedList<>();\\n        StringBuilder tempHolder = new StringBuilder();\\n        findNextWord(results, tempHolder, s, wordDict, 0);\\n        return results;\\n    }\\n\\n    private void findNextWord(List<String> results, StringBuilder tempHolder, String s, List<String> wordDict, int start) {\\n        if (start == s.length()) {\\n            results.add(tempHolder.toString().trim());\\n            return;\\n        }\\n\\n        for (int end = start; end < s.length(); end++) {\\n            String word = s.substring(start, end + 1);\\n            if (wordDict.contains(word)) {\\n                tempHolder.append(word + \" \");\\n                findNextWord(results, tempHolder, s, wordDict, end + 1);\\n                tempHolder.delete(tempHolder.length() - word.length() - 1, tempHolder.length());\\n            }\\n        }\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> results = new LinkedList<>();\\n        StringBuilder tempHolder = new StringBuilder();\\n        findNextWord(results, tempHolder, s, wordDict, 0);\\n        return results;\\n    }\\n\\n    private void findNextWord(List<String> results, StringBuilder tempHolder, String s, List<String> wordDict, int start) {\\n        if (start == s.length()) {\\n            results.add(tempHolder.toString().trim());\\n            return;\\n        }\\n\\n        for (int end = start; end < s.length(); end++) {\\n            String word = s.substring(start, end + 1);\\n            if (wordDict.contains(word)) {\\n                tempHolder.append(word + \" \");\\n                findNextWord(results, tempHolder, s, wordDict, end + 1);\\n                tempHolder.delete(tempHolder.length() - word.length() - 1, tempHolder.length());\\n            }\\n        }\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987454,
                "title": "c-simple-recursive-approach-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void helper(string s, unordered_set<string>& dict,int start, int index,string current,vector<string>& ans){\\n        if(start==s.size()){\\n            ans.push_back(current);\\n            return;\\n        }\\n        if(index==s.size()) return;\\n\\n        string sub=s.substr(start,index-start+1);\\n\\n        if(dict.count(sub)>0){\\n            string recursion;\\n            if(current.size()==0) recursion=sub;\\n            else recursion=current+\" \"+sub; \\n            helper(s,dict,index+1,index+1,recursion,ans);\\n        }\\n        helper(s,dict,start,index+1,current,ans);\\n        return;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict;\\n        for(int i=0;i<wordDict.size();i++){\\n                dict.insert(wordDict[i]);\\n        }\\n        vector<string> ans;\\n        helper(s,dict,0,0,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(string s, unordered_set<string>& dict,int start, int index,string current,vector<string>& ans){\\n        if(start==s.size()){\\n            ans.push_back(current);\\n            return;\\n        }\\n        if(index==s.size()) return;\\n\\n        string sub=s.substr(start,index-start+1);\\n\\n        if(dict.count(sub)>0){\\n            string recursion;\\n            if(current.size()==0) recursion=sub;\\n            else recursion=current+\" \"+sub; \\n            helper(s,dict,index+1,index+1,recursion,ans);\\n        }\\n        helper(s,dict,start,index+1,current,ans);\\n        return;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> dict;\\n        for(int i=0;i<wordDict.size();i++){\\n                dict.insert(wordDict[i]);\\n        }\\n        vector<string> ans;\\n        helper(s,dict,0,0,\"\",ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778161,
                "title": "recursion-dp-always-does-the-job",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nrecursive approach\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:high\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726138,
                "title": "easy-to-understand-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> st;\\n    void f(int ind,string str,string s,vector<string>& ans){\\n\\t\\n        if(ind==s.length()){\\n            ans.push_back(str);\\n            return ;\\n        }\\n\\t\\t\\n        string temp = \"\";                              //temporary string for finding string in dictionary from ind\\n\\t\\t\\n        for(int i=ind;i<s.length();i++){\\n            temp += s[i];\\n            if(st.count(temp)){\\n                string k = str;                         //By initialising str to k then we don\\'t need to do backtrack\\n                if(str.size()!=0) k += \" \";         // Edge Case \\n                k += temp;\\n                f(i+1,k,s,ans);\\n            }\\n        }\\n    }\\n\\t\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto i:wordDict) st.insert(i);\\n        int ind=0;\\n        vector<string> ans;\\n        string str = \"\";\\n        f(ind,str,s,ans);                  //Function Call\\n        return ans;\\n    }\\n};\\n```\\n\\n# ****PLease Upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> st;\\n    void f(int ind,string str,string s,vector<string>& ans){\\n\\t\\n        if(ind==s.length()){\\n            ans.push_back(str);\\n            return ;\\n        }\\n\\t\\t\\n        string temp = \"\";                              //temporary string for finding string in dictionary from ind\\n\\t\\t\\n        for(int i=ind;i<s.length();i++){\\n            temp += s[i];\\n            if(st.count(temp)){\\n                string k = str;                         //By initialising str to k then we don\\'t need to do backtrack\\n                if(str.size()!=0) k += \" \";         // Edge Case \\n                k += temp;\\n                f(i+1,k,s,ans);\\n            }\\n        }\\n    }\\n\\t\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto i:wordDict) st.insert(i);\\n        int ind=0;\\n        vector<string> ans;\\n        string str = \"\";\\n        f(ind,str,s,ans);                  //Function Call\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288246,
                "title": "diagram-explanation-dp-backtracking-trie-solution",
                "content": "## Code is at the bottom in C++\\nLets understand this with the first example. Consider making a trie to store words for relatively faster lookup.\\n![image](https://assets.leetcode.com/users/images/9ff5e4ec-6db6-40eb-ba09-3281696025b8_1657941546.7179804.png)\\nNow suppose we are at \\'d\\' of \"catsand\", are there possible breaks till here?\\n![image](https://assets.leetcode.com/users/images/85680f03-064a-42dd-8e41-01abaae1b129_1657941962.613613.png)\\nAll we need to store there is the indices of beginning of suffixes so that later on when we need to choose where to do the slicing, we have our index with us.\\nIntuitively enough, if there are no possible indexes that made a suffix to form the string, we can\\'t form any permutation. Now, onto the code.\\n```c++\\nstruct trie {\\n    trie *ch[26];\\n    bool isEnd;\\n    trie()\\n    {\\n        for(int i=0;i<26;i++) ch[i]=NULL;\\n        isEnd=false;\\n    }\\n};\\nvoid insert(trie *head,string &s)\\n{\\n    int n=s.length();\\n    trie *curr=head;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(!curr->ch[s[i]-\\'a\\']) curr->ch[s[i]-\\'a\\']=new trie();\\n        curr=curr->ch[s[i]-\\'a\\'];\\n    }\\n    curr->isEnd=true;\\n}\\nbool search(trie *head,string &str,int l,int r)\\n{\\n    trie *curr=head;\\n    for(int i=l;i<=r;i++)\\n    {\\n        if(!curr->ch[str[i]-\\'a\\']) return false;\\n        curr=curr->ch[str[i]-\\'a\\'];\\n    }\\n    return curr->isEnd;\\n}\\nclass Solution {\\npublic:\\n    void stringMaker(string &s,vector<string> &ans,vector<vector<int>> &index,int ind,string buff)\\n    {\\n        if(ind==-1)\\n        {\\n            buff.pop_back();\\n            reverse(buff.begin(),buff.end());\\n            ans.push_back(buff);\\n            return;\\n        }\\n        \\n        for(auto i:index[ind])\\n        {\\n            string temp=\"\";\\n            for(int j=ind;j>=i;j--)\\n            {\\n                temp+=s[j];\\n            }\\n            stringMaker(s,ans,index,i-1,buff+temp+\" \");\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        trie *head=new trie();\\n        for(string &s:wordDict) insert(head,s);\\n        int n=s.length();\\n        //possible to make this by slicing [..]  [i....j]\\n        //just before index i. If i=0, there was no space\\n        vector<vector<int>> dp(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(search(head,s,0,i)) dp[i].push_back(0);\\n            for(int j=1;j<=i;j++)\\n            {\\n                if(dp[j-1].size() && search(head,s,j,i))\\n                    dp[i].push_back(j);\\n            }\\n        }\\n        vector<string> ans;\\n        if(dp[n-1].size()==0) return ans;\\n        stringMaker(s,ans,dp,n-1,\"\");\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Trie"
                ],
                "code": "```c++\\nstruct trie {\\n    trie *ch[26];\\n    bool isEnd;\\n    trie()\\n    {\\n        for(int i=0;i<26;i++) ch[i]=NULL;\\n        isEnd=false;\\n    }\\n};\\nvoid insert(trie *head,string &s)\\n{\\n    int n=s.length();\\n    trie *curr=head;\\n    for(int i=0;i<n;i++)\\n    {\\n        if(!curr->ch[s[i]-\\'a\\']) curr->ch[s[i]-\\'a\\']=new trie();\\n        curr=curr->ch[s[i]-\\'a\\'];\\n    }\\n    curr->isEnd=true;\\n}\\nbool search(trie *head,string &str,int l,int r)\\n{\\n    trie *curr=head;\\n    for(int i=l;i<=r;i++)\\n    {\\n        if(!curr->ch[str[i]-\\'a\\']) return false;\\n        curr=curr->ch[str[i]-\\'a\\'];\\n    }\\n    return curr->isEnd;\\n}\\nclass Solution {\\npublic:\\n    void stringMaker(string &s,vector<string> &ans,vector<vector<int>> &index,int ind,string buff)\\n    {\\n        if(ind==-1)\\n        {\\n            buff.pop_back();\\n            reverse(buff.begin(),buff.end());\\n            ans.push_back(buff);\\n            return;\\n        }\\n        \\n        for(auto i:index[ind])\\n        {\\n            string temp=\"\";\\n            for(int j=ind;j>=i;j--)\\n            {\\n                temp+=s[j];\\n            }\\n            stringMaker(s,ans,index,i-1,buff+temp+\" \");\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        trie *head=new trie();\\n        for(string &s:wordDict) insert(head,s);\\n        int n=s.length();\\n        //possible to make this by slicing [..]  [i....j]\\n        //just before index i. If i=0, there was no space\\n        vector<vector<int>> dp(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(search(head,s,0,i)) dp[i].push_back(0);\\n            for(int j=1;j<=i;j++)\\n            {\\n                if(dp[j-1].size() && search(head,s,j,i))\\n                    dp[i].push_back(j);\\n            }\\n        }\\n        vector<string> ans;\\n        if(dp[n-1].size()==0) return ans;\\n        stringMaker(s,ans,dp,n-1,\"\");\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739705,
                "title": "solution-swift-word-break-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    private var memo: [String:[String]] = [:]\\n    private var words: [String] = []\\n    \\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var wChars: Set<Character> = []\\n        \\n        for w in wordDict { w.forEach { wChars.insert($0) } }\\n        \\n        self.words = wordDict\\n        \\n        guard Set<Character>(s).isSubset(of: wChars) else {\\n            return []\\n        }\\n        return dfs(s)\\n    }\\n    \\n    private func dfs(_ s: String) -> [String] {\\n        guard memo[s] == nil else { return memo[s]! }\\n        \\n        var arr: [String] = []\\n        \\n        guard !s.isEmpty else {\\n            arr.append(\"\")\\n            return arr\\n        }\\n        \\n        for w in words where s.hasPrefix(w) {\\n            let subList = dfs(String(s[s.index(s.startIndex, offsetBy: w.count)...]))\\n            for s in subList { arr.append(w + (s.isEmpty ? \"\" : \" \") + s) }\\n        }\\n        memo[s] = arr\\n        return arr\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.029 (0.031) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.wordBreak(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"])\\n        XCTAssertEqual(value.sorted(), [\"cats and dog\",\"cat sand dog\"].sorted())\\n    }\\n    \\n    // Note that you are allowed to reuse a dictionary word.\\n    func test1() {\\n        let value = solution.wordBreak(\"pineapplepenapple\", [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"])\\n        XCTAssertEqual(value.sorted(), [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"].sorted())\\n    }\\n    \\n    func test2() {\\n        let value = solution.wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\\n        XCTAssertEqual(value, [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    private var memo: [String:[String]] = [:]\\n    private var words: [String] = []\\n    \\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var wChars: Set<Character> = []\\n        \\n        for w in wordDict { w.forEach { wChars.insert($0) } }\\n        \\n        self.words = wordDict\\n        \\n        guard Set<Character>(s).isSubset(of: wChars) else {\\n            return []\\n        }\\n        return dfs(s)\\n    }\\n    \\n    private func dfs(_ s: String) -> [String] {\\n        guard memo[s] == nil else { return memo[s]! }\\n        \\n        var arr: [String] = []\\n        \\n        guard !s.isEmpty else {\\n            arr.append(\"\")\\n            return arr\\n        }\\n        \\n        for w in words where s.hasPrefix(w) {\\n            let subList = dfs(String(s[s.index(s.startIndex, offsetBy: w.count)...]))\\n            for s in subList { arr.append(w + (s.isEmpty ? \"\" : \" \") + s) }\\n        }\\n        memo[s] = arr\\n        return arr\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.wordBreak(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"])\\n        XCTAssertEqual(value.sorted(), [\"cats and dog\",\"cat sand dog\"].sorted())\\n    }\\n    \\n    // Note that you are allowed to reuse a dictionary word.\\n    func test1() {\\n        let value = solution.wordBreak(\"pineapplepenapple\", [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"])\\n        XCTAssertEqual(value.sorted(), [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"].sorted())\\n    }\\n    \\n    func test2() {\\n        let value = solution.wordBreak(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])\\n        XCTAssertEqual(value, [])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426014,
                "title": "python-interview-friendly-simple-recursion",
                "content": "Not the best or the fastest, but definitely more interview friendly version. Good old recursion. \\n\\nSplit the string at all indexes. Then basically there is always two parts - the first part (word) and rest of the string. If word is in the wordDict, take the second part, and do the same thing until there is no string left. At that point, simply join the path with space and append to the output. \\n\\nConvert wordDict to hashset for O(1) lookup time. \\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        def recur(s, path):\\n            if not s:\\n                out.append(\\' \\'.join(path))\\n                return\\n            for i in range(1,len(s)+1):\\n                w,new_s = s[:i], s[i:]\\n                if w in wordDict:\\n                    recur(new_s, path + [w])\\n        wordDict, out = set(wordDict), []\\n        recur(s,[])\\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        def recur(s, path):\\n            if not s:\\n                out.append(\\' \\'.join(path))\\n                return\\n            for i in range(1,len(s)+1):\\n                w,new_s = s[:i], s[i:]\\n                if w in wordDict:\\n                    recur(new_s, path + [w])\\n        wordDict, out = set(wordDict), []\\n        recur(s,[])\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325635,
                "title": "trie-dfs-java",
                "content": "```\\nclass Solution {\\n    \\n    Trie root = new Trie();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        for(String word : wordDict) {\\n            addWord(word, root);\\n        }\\n        List<String> res = new ArrayList<>();\\n        List<String> current = new ArrayList<>();\\n        dfs(s, 0, root, current, res);\\n        return res;\\n    }\\n    private void dfs(String s, int index, Trie node, List<String> current, List<String> res) {\\n        if(index == s.length()) {\\n            if(node == root) {\\n                res.add(String.join(\" \", current));\\n            }\\n            return;\\n        }\\n        if(node == null) return;//invalid\\n        Trie trie = node.next[s.charAt(index) - \\'a\\'];\\n        if(trie != null && trie.isWord) {\\n            current.add(trie.word);\\n            dfs(s, index + 1, root, current, res);\\n            current.remove(current.size() - 1);\\n        }\\n        dfs(s, index + 1, trie, current, res);\\n    }\\n    private void addWord(String word, Trie dic) {\\n        Trie ptr = root;\\n        for(int i = 0; i < word.length(); ++i) {\\n            int idx = word.charAt(i) - \\'a\\';\\n            if(ptr.next[idx] == null) ptr.next[idx] = new Trie();\\n            ptr = ptr.next[idx];\\n        }\\n        ptr.isWord = true;\\n        ptr.word = word;\\n    }\\n    \\n    class Trie {\\n        boolean isWord;\\n        String word;\\n        Trie[] next;\\n        Trie() {\\n            next = new Trie[26];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Trie root = new Trie();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        for(String word : wordDict) {\\n            addWord(word, root);\\n        }\\n        List<String> res = new ArrayList<>();\\n        List<String> current = new ArrayList<>();\\n        dfs(s, 0, root, current, res);\\n        return res;\\n    }\\n    private void dfs(String s, int index, Trie node, List<String> current, List<String> res) {\\n        if(index == s.length()) {\\n            if(node == root) {\\n                res.add(String.join(\" \", current));\\n            }\\n            return;\\n        }\\n        if(node == null) return;//invalid\\n        Trie trie = node.next[s.charAt(index) - \\'a\\'];\\n        if(trie != null && trie.isWord) {\\n            current.add(trie.word);\\n            dfs(s, index + 1, root, current, res);\\n            current.remove(current.size() - 1);\\n        }\\n        dfs(s, index + 1, trie, current, res);\\n    }\\n    private void addWord(String word, Trie dic) {\\n        Trie ptr = root;\\n        for(int i = 0; i < word.length(); ++i) {\\n            int idx = word.charAt(i) - \\'a\\';\\n            if(ptr.next[idx] == null) ptr.next[idx] = new Trie();\\n            ptr = ptr.next[idx];\\n        }\\n        ptr.isWord = true;\\n        ptr.word = word;\\n    }\\n    \\n    class Trie {\\n        boolean isWord;\\n        String word;\\n        Trie[] next;\\n        Trie() {\\n            next = new Trie[26];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325222,
                "title": "simple-backtracking-solution",
                "content": "1. create a set for constant time O(1) lookup\\n2. iterate over string to expand the substring. \\n3. if a substring appears within `wordDict` \\n\\t3.1 we will explore this permutation by adding the substring to the path and backtracking on the remainder of the string\\n\\t3.2 if all the characters in the string are used up (`s.length === 0`) that means we have a valid permutation, so add it to the results\\n4. after the base case is reached (`s.length === 0` or no substrings found in `wordDict` remove the prior substring from `path` and continue expanding the current substring\\n\\ntime complexity: `O(n^2)` where `n` is the length of the string `s`\\n- for each recursive backtracking call we iterate through the remaining string. the `substring()` and `slice()` methods are linear operations `O(n)` in themselves, so it seems this may degrade to `O(n^3)`, thoughts? \\n\\nspace complexity: `O(n + m)` where `n` is the length of string `s` and `m` is the amount of words in `wordDict`\\n\\n```\\nconst backtrack = (s, words, path, result) => {\\n    if (s.length === 0) {\\n        result.push(path.join(\\' \\'))\\n        return\\n    }\\n    for (let i = 1; i <= s.length; i++) {\\n        const substring = s.substring(0, i)\\n        if (words.has(substring)) {\\n            path.push(substring)\\n            backtrack(s.slice(i), words, path, result)\\n            path.pop()\\n        }\\n    }\\n}\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nconst wordBreak = (s, wordDict) => {\\n    const result = []\\n    const words = new Set(wordDict)\\n    backtrack(s, words, [], result)\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nconst backtrack = (s, words, path, result) => {\\n    if (s.length === 0) {\\n        result.push(path.join(\\' \\'))\\n        return\\n    }\\n    for (let i = 1; i <= s.length; i++) {\\n        const substring = s.substring(0, i)\\n        if (words.has(substring)) {\\n            path.push(substring)\\n            backtrack(s.slice(i), words, path, result)\\n            path.pop()\\n        }\\n    }\\n}\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nconst wordBreak = (s, wordDict) => {\\n    const result = []\\n    const words = new Set(wordDict)\\n    backtrack(s, words, [], result)\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1176760,
                "title": "0ms-c-easy-trie-solution",
                "content": "Scan given string char by char. If char exists in current trie node, \\n1) continue with next node. \\n``` find(s, i+1, r, temp->child[ch], root, sen + s[i]);```\\n2) additionally, if node is \"end node\", put a space and restart from the root node\\n``` find(s, i+1, r, root, root, sen + s[i] + \\' \\');```\\n\\nPlease check the code . You might find it easier to understand than my explanantion :P\\n\\n```\\nclass Solution {\\n    class TRIENODE{\\n    public:\\n        TRIENODE* child[26];\\n        bool isEnd;\\n        \\n        TRIENODE(){\\n          for(int i=0;i<26;i++){\\n              child[i] = 0;\\n          }\\n          isEnd = false;\\n        }\\n    };\\n    \\n    class TRIE{\\n    public:\\n        TRIENODE* root;\\n        \\n        TRIE(){\\n          root = new TRIENODE;\\n        }\\n        \\n        void insert(string s){\\n            TRIENODE* temp = root;\\n            for(auto ch:s){\\n                if(!temp->child[ch-\\'a\\']){\\n                    temp->child[ch-\\'a\\'] = new TRIENODE;\\n                }\\n                temp = temp->child[ch-\\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }    \\n    };\\n    \\n    vector<string> ans;\\n    \\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        TRIE* trie = new TRIE;\\n        for(auto s:wordDict){\\n            trie->insert(s);\\n        }\\n        \\n        find(s,0,s.size()-1,trie->root,trie->root,\"\");\\n        return ans;\\n    }\\n    \\n    void find(string s, int i, int r, TRIENODE* temp, TRIENODE* root,string sen){\\n        if(i>r){           \\n            if(temp->isEnd){\\n                ans.push_back(sen);                \\n            }\\n            return;\\n        }\\n        \\n        int ch = s[i]-\\'a\\';\\n        if(temp->child[ch]){\\n            find(s, i+1, r, temp->child[ch], root, sen + s[i]);            \\n            if(temp->child[ch]->isEnd){\\n                find(s, i+1, r, root, root, sen + s[i] + \\' \\');\\n            }            \\n        }\\n    }\\n};\\n```\\n\\nPS: This solution gives TLE for https://leetcode.com/problems/word-break/ where strings can be much longer.",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "``` find(s, i+1, r, temp->child[ch], root, sen + s[i]);```\n``` find(s, i+1, r, root, root, sen + s[i] + \\' \\');```\n```\\nclass Solution {\\n    class TRIENODE{\\n    public:\\n        TRIENODE* child[26];\\n        bool isEnd;\\n        \\n        TRIENODE(){\\n          for(int i=0;i<26;i++){\\n              child[i] = 0;\\n          }\\n          isEnd = false;\\n        }\\n    };\\n    \\n    class TRIE{\\n    public:\\n        TRIENODE* root;\\n        \\n        TRIE(){\\n          root = new TRIENODE;\\n        }\\n        \\n        void insert(string s){\\n            TRIENODE* temp = root;\\n            for(auto ch:s){\\n                if(!temp->child[ch-\\'a\\']){\\n                    temp->child[ch-\\'a\\'] = new TRIENODE;\\n                }\\n                temp = temp->child[ch-\\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }    \\n    };\\n    \\n    vector<string> ans;\\n    \\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        TRIE* trie = new TRIE;\\n        for(auto s:wordDict){\\n            trie->insert(s);\\n        }\\n        \\n        find(s,0,s.size()-1,trie->root,trie->root,\"\");\\n        return ans;\\n    }\\n    \\n    void find(string s, int i, int r, TRIENODE* temp, TRIENODE* root,string sen){\\n        if(i>r){           \\n            if(temp->isEnd){\\n                ans.push_back(sen);                \\n            }\\n            return;\\n        }\\n        \\n        int ch = s[i]-\\'a\\';\\n        if(temp->child[ch]){\\n            find(s, i+1, r, temp->child[ch], root, sen + s[i]);            \\n            if(temp->child[ch]->isEnd){\\n                find(s, i+1, r, root, root, sen + s[i] + \\' \\');\\n            }            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034185,
                "title": "very-easy-backtracking-solution",
                "content": "public class Solution {\\n\\n    List<String> answer = new ArrayList();\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\t    \\n        Set<String> set = new HashSet<>(wordDict);\\n        \\n        backtrack(s, \"\", answer, set);\\n        \\n        return answer;\\n    \\n    }\\n    \\n    public void backtrack(String s, String temp, List<String> answer, Set<String> set) {\\n        \\n        if(s.length()==0) {\\n            answer.add(temp);\\n            return;\\n        }\\n        \\n        for(int i=0;i<s.length();i++) {\\n            \\n            String left = s.substring(0,i+1);\\n            \\n            if(set.contains(left)) {\\n                String right = s.substring(i+1);\\n                backtrack(right, temp + left + \" \", answer, set);\\n            }\\n        }\\n    }\\n\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    List<String> answer = new ArrayList();\\n    \\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n\\t    \\n        Set<String> set = new HashSet<>(wordDict);\\n        \\n        backtrack(s, \"\", answer, set);\\n        \\n        return answer;\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 908609,
                "title": "java-dsf-memo-5ms",
                "content": "Time complexity: O(n * 2^n) \\nSpace complexity: O(n * 2^n) \\n\\nHere a good explaination: \\nhttps://medium.com/@salonikaurone/leetcode-word-break-ii-explained-d41ecfbe8fc5#:~:text=because%20we%20have%20memoisation%2C%20we,of%20characters%20in%20the%20input\\n\\n```\\nclass Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        return dsf(s, 0, wordDict, new HashMap<>());\\n    }\\n    \\n    \\n    private List<String> dsf(String str, int startIndex, List<String> words, \\n                        Map<Integer, List<String>> map){\\n        \\n        if (map.containsKey(startIndex)) {\\n            return map.get(startIndex);\\n        }\\n        \\n        List<String> strs = new ArrayList<>();\\n        for (String word : words) {\\n            if (str.startsWith(word, startIndex)) {\\n                \\n                if (str.length() == startIndex + word.length()) {\\n                    strs.add(word);\\n                } else {\\n                    List<String> strings = dsf(str, startIndex + word.length(), words, map);\\n                    for (String ss : strings) {\\n                        strs.add(word + \" \" + ss);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        map.put(startIndex, strs);\\n        return map.get(startIndex);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        return dsf(s, 0, wordDict, new HashMap<>());\\n    }\\n    \\n    \\n    private List<String> dsf(String str, int startIndex, List<String> words, \\n                        Map<Integer, List<String>> map){\\n        \\n        if (map.containsKey(startIndex)) {\\n            return map.get(startIndex);\\n        }\\n        \\n        List<String> strs = new ArrayList<>();\\n        for (String word : words) {\\n            if (str.startsWith(word, startIndex)) {\\n                \\n                if (str.length() == startIndex + word.length()) {\\n                    strs.add(word);\\n                } else {\\n                    List<String> strings = dsf(str, startIndex + word.length(), words, map);\\n                    for (String ss : strings) {\\n                        strs.add(word + \" \" + ss);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        map.put(startIndex, strs);\\n        return map.get(startIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809872,
                "title": "c-memoization-solution-fast-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> vis;\\n    vector<string> merge(string s, vector<string> vec){\\n        vector<string> ret;\\n        for(string i:vec) ret.push_back(s+\" \"+i);\\n        return ret;\\n    }\\n    vector<string> dfs(string s, unordered_set<string>& wordDict){\\n        vector<string> res;\\n        if(vis.count(s)) return vis[s];\\n        if(wordDict.count(s)) res.push_back(s);\\n        for(int i=1;i<=s.size();++i){\\n            string cur = s.substr(0,i);\\n            if(wordDict.count(cur)){\\n                vector<string> vec = merge(cur,dfs(s.substr(i),wordDict));\\n                res.insert(res.end(),vec.begin(),vec.end());\\n            }\\n        }\\n        vis[s] = res;\\n        return res;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDic) {\\n        unordered_set<string> wordDict(wordDic.begin(),wordDic.end());\\n        return dfs(s,wordDict);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>> vis;\\n    vector<string> merge(string s, vector<string> vec){\\n        vector<string> ret;\\n        for(string i:vec) ret.push_back(s+\" \"+i);\\n        return ret;\\n    }\\n    vector<string> dfs(string s, unordered_set<string>& wordDict){\\n        vector<string> res;\\n        if(vis.count(s)) return vis[s];\\n        if(wordDict.count(s)) res.push_back(s);\\n        for(int i=1;i<=s.size();++i){\\n            string cur = s.substr(0,i);\\n            if(wordDict.count(cur)){\\n                vector<string> vec = merge(cur,dfs(s.substr(i),wordDict));\\n                res.insert(res.end(),vec.begin(),vec.end());\\n            }\\n        }\\n        vis[s] = res;\\n        return res;\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDic) {\\n        unordered_set<string> wordDict(wordDic.begin(),wordDic.end());\\n        return dfs(s,wordDict);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763391,
                "title": "java-using-trie",
                "content": "```\\nclass Solution {\\n    private Tries root;\\n    private List<String> wordList;\\n    private char[] input;\\n    private Set<Character> lookup;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordList = new LinkedList<>();\\n        if(s.length() == 0) \\n            return this.wordList;\\n        this.lookup = new HashSet<>();\\n        this.root = new Tries();\\n        this.input = s.toCharArray();\\n        for(String word : wordDict) {\\n            addWord(word.toCharArray());\\n        }\\n        if(isValid()) \\n            splitWord(new StringBuilder(), 0, root);\\n        return wordList;\\n    }\\n    \\n    private void splitWord(StringBuilder sb, int i, Tries cur) {\\n        if(i == input.length) {\\n            wordList.add(sb.toString());\\n            return;\\n        }\\n        // System.out.println(\"\\\\n\" + input[i]);\\n        if(sb.length() > 0) sb.append(\" \");\\n        while(i < input.length && cur != null) {\\n            // System.out.print(input[i] + \" > \");\\n            cur = cur.children.get(input[i]);\\n            sb.append(input[i]);\\n            if(cur != null && cur.end) {\\n                splitWord(new StringBuilder(sb), i + 1, root);\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    class Tries {\\n        Map<Character, Tries> children;\\n        boolean end;\\n        Tries() {\\n            children = new HashMap<>();\\n        }\\n    }\\n    \\n    private void addWord(char[] s) {\\n        Tries cur = root;\\n        for(int i = 0; i < s.length; i++) {\\n            this.lookup.add(s[i]);\\n            if(cur.children.containsKey(s[i]) == false) {\\n                cur.children.put(s[i], new Tries());\\n            }\\n            cur = cur.children.get(s[i]);\\n        }\\n        cur.end = true;\\n    } \\n    \\n    private boolean isValid() {\\n        for(int i = 0; i < input.length; i++) {\\n            if(lookup.contains(input[i])) continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    private Tries root;\\n    private List<String> wordList;\\n    private char[] input;\\n    private Set<Character> lookup;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordList = new LinkedList<>();\\n        if(s.length() == 0) \\n            return this.wordList;\\n        this.lookup = new HashSet<>();\\n        this.root = new Tries();\\n        this.input = s.toCharArray();\\n        for(String word : wordDict) {\\n            addWord(word.toCharArray());\\n        }\\n        if(isValid()) \\n            splitWord(new StringBuilder(), 0, root);\\n        return wordList;\\n    }\\n    \\n    private void splitWord(StringBuilder sb, int i, Tries cur) {\\n        if(i == input.length) {\\n            wordList.add(sb.toString());\\n            return;\\n        }\\n        // System.out.println(\"\\\\n\" + input[i]);\\n        if(sb.length() > 0) sb.append(\" \");\\n        while(i < input.length && cur != null) {\\n            // System.out.print(input[i] + \" > \");\\n            cur = cur.children.get(input[i]);\\n            sb.append(input[i]);\\n            if(cur != null && cur.end) {\\n                splitWord(new StringBuilder(sb), i + 1, root);\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    class Tries {\\n        Map<Character, Tries> children;\\n        boolean end;\\n        Tries() {\\n            children = new HashMap<>();\\n        }\\n    }\\n    \\n    private void addWord(char[] s) {\\n        Tries cur = root;\\n        for(int i = 0; i < s.length; i++) {\\n            this.lookup.add(s[i]);\\n            if(cur.children.containsKey(s[i]) == false) {\\n                cur.children.put(s[i], new Tries());\\n            }\\n            cur = cur.children.get(s[i]);\\n        }\\n        cur.end = true;\\n    } \\n    \\n    private boolean isValid() {\\n        for(int i = 0; i < input.length; i++) {\\n            if(lookup.contains(input[i])) continue;\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763261,
                "title": "python-sol-by-dfs-with-prefix-matching-w-comment",
                "content": "Python sol by DFS with prefix matching\\n\\n---\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        solution = []\\n        \\n        word_pool = set(wordDict)\\n        \\n        \\n        if set(s) > set(\\'\\'.join(wordDict)):\\n            \\n            # Quick response if it is impossible to make s\\n            return []        \\n        \\n        #----------------------------------------\\n        \\n        def helper(s, words):\\n            # find all possible generation of s from word pool in DFS\\n            \\n            if s == \"\":\\n                # base case also known as stop condition\\n                # s can be generated from word pool\\n                solution.append(\\' \\'.join(words))\\n                return\\n            \\n            \\n            for prefix in word_pool:\\n                # general case\\n                \\n                if len(prefix) > len(s):\\n                    \\n                    # Skip when prefix is longer than s\\n                    continue\\n                \\n                if s.startswith(prefix):\\n                    \\n                    # Keep finding in DFS\\n                    helper(s[len(prefix):], words[:] + [prefix])\\n                    \\n            return\\n        \\n        #----------------------------------------\\n        \\n        helper(s, words=[])\\n        \\n        return solution\\n```\\n\\n---\\n\\nShare another **Implemetation** by DFS with postfix matching\\n\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        wordSet = set(wordDict)\\n        \\n        @cache\\n        def dp(s):\\n            \\n            ## Base case on empty string\\n            if not s:\\n                return []\\n            \\n            ## General case\\n            res = []\\n            \\n            # Type_1: Current s is in wordSet\\n            if s in wordSet:\\n                res.append( s ) \\n            \\n            # Type_2: Decompose s into smaller words in wordSet\\n            for k in range(1, len(s)):\\n                \\n                postfix = s[k:]\\n                if postfix not in wordSet: continue\\n                \\n                res += [ prefix + \" \" + postfix for prefix in dp(s[:k])]\\n            \\n            return res\\n        \\n        # ---------------------------------\\n        return dp( s )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        solution = []\\n        \\n        word_pool = set(wordDict)\\n        \\n        \\n        if set(s) > set(\\'\\'.join(wordDict)):\\n            \\n            # Quick response if it is impossible to make s\\n            return []        \\n        \\n        #----------------------------------------\\n        \\n        def helper(s, words):\\n            # find all possible generation of s from word pool in DFS\\n            \\n            if s == \"\":\\n                # base case also known as stop condition\\n                # s can be generated from word pool\\n                solution.append(\\' \\'.join(words))\\n                return\\n            \\n            \\n            for prefix in word_pool:\\n                # general case\\n                \\n                if len(prefix) > len(s):\\n                    \\n                    # Skip when prefix is longer than s\\n                    continue\\n                \\n                if s.startswith(prefix):\\n                    \\n                    # Keep finding in DFS\\n                    helper(s[len(prefix):], words[:] + [prefix])\\n                    \\n            return\\n        \\n        #----------------------------------------\\n        \\n        helper(s, words=[])\\n        \\n        return solution\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        wordSet = set(wordDict)\\n        \\n        @cache\\n        def dp(s):\\n            \\n            ## Base case on empty string\\n            if not s:\\n                return []\\n            \\n            ## General case\\n            res = []\\n            \\n            # Type_1: Current s is in wordSet\\n            if s in wordSet:\\n                res.append( s ) \\n            \\n            # Type_2: Decompose s into smaller words in wordSet\\n            for k in range(1, len(s)):\\n                \\n                postfix = s[k:]\\n                if postfix not in wordSet: continue\\n                \\n                res += [ prefix + \" \" + postfix for prefix in dp(s[:k])]\\n            \\n            return res\\n        \\n        # ---------------------------------\\n        return dp( s )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557592,
                "title": "javascript-accepted-solution",
                "content": "Runtime: 52 ms, faster than 99.23% of JavaScript online submissions for Word Break II.\\nMemory Usage: 37.2 MB, less than 100.00% of JavaScript online submissions for Word Break II.\\n\\n```\\nconst dfs = (s, set, memo) => {\\n    if (memo.has(s)) {\\n        return memo.get(s);\\n    }\\n    \\n    let i = 1;\\n    const result = [];\\n    \\n    while ( i < s.length + 1 ) {\\n        const thisWord = s.substring(0, i);\\n        \\n        if (set.has(thisWord)) {\\n            if (i === s.length) {\\n                result.push(thisWord);\\n                break;\\n            }\\n            \\n            const nextCombos = dfs(s.substring(i), set, memo);\\n            nextCombos.forEach(combo => {\\n                result.push(`${thisWord} ${combo}`);    \\n            })\\n        }\\n        \\n        i++;\\n    }\\n    \\n    memo.set(s, result);\\n    \\n    return result;\\n}\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    return dfs(s, new Set(wordDict), new Map);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst dfs = (s, set, memo) => {\\n    if (memo.has(s)) {\\n        return memo.get(s);\\n    }\\n    \\n    let i = 1;\\n    const result = [];\\n    \\n    while ( i < s.length + 1 ) {\\n        const thisWord = s.substring(0, i);\\n        \\n        if (set.has(thisWord)) {\\n            if (i === s.length) {\\n                result.push(thisWord);\\n                break;\\n            }\\n            \\n            const nextCombos = dfs(s.substring(i), set, memo);\\n            nextCombos.forEach(combo => {\\n                result.push(`${thisWord} ${combo}`);    \\n            })\\n        }\\n        \\n        i++;\\n    }\\n    \\n    memo.set(s, result);\\n    \\n    return result;\\n}\\n\\n/**\\n * @param {string} s\\n * @param {string[]} wordDict\\n * @return {string[]}\\n */\\nvar wordBreak = function(s, wordDict) {\\n    return dfs(s, new Set(wordDict), new Map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 496272,
                "title": "dfs-trie-python",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def getRoot(self):\\n        return self.root\\n    \\n    def insertWord(self, word: str):\\n\\n        nextNode = self.root\\n        for c in word:\\n            if c not in nextNode.children:\\n                nextNode.children[c] = TrieNode()\\n            nextNode = nextNode.children[c]\\n        nextNode.isWord = True\\n\\nclass Solution:\\n    trieNode = None\\n    s = None\\n    memoize = None\\n    \\n    def checkConnection(self, prevNode, currentChar: chr) -> TrieNode:\\n        if currentChar in prevNode.children:\\n            return prevNode.children[currentChar]\\n        return None\\n\\n    def wordBreakHelper(self, index: int, node) -> List[List[str]]:\\n        \\n        if index in self.memoize:\\n            return self.memoize[index][:]\\n\\n        result = []\\n        current = []\\n        \\n        start = index\\n        while index < len(self.s):\\n            node = self.checkConnection(node, self.s[index])\\n            \\n            if node is None:\\n                break\\n            \\n            # valid path\\n            current.append(self.s[index])\\n\\n            if node.isWord:\\n                current_word = \\'\\'.join(current)\\n                \\n                if index+1 < len(self.s):\\n                    tempResult = self.wordBreakHelper(index+1, self.trieNode.getRoot())\\n\\n                    #print(tempResult, current_word)\\n                    for val in tempResult:\\n                        result.append([current_word] + val)\\n                else:\\n                    result.append([current_word])\\n\\n            index += 1\\n            \\n        self.memoize[start] = result\\n        return self.memoize[start][:]\\n\\n\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        self.trieNode = Trie()\\n        self.s = s\\n        self.memoize = {}\\n        # creating a Trie\\n        \\n        for s in wordDict:\\n            self.trieNode.insertWord(s)\\n        \\n        \\n        final_result = self.wordBreakHelper(0, self.trieNode.getRoot())\\n        \\n        \\n        #print(self.memoize)\\n        return [\\' \\'.join(word_list) for word_list in final_result]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass TrieNode:\\n\\n    def __init__(self):\\n        self.children = {}\\n        self.isWord = False\\n\\nclass Trie:\\n\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def getRoot(self):\\n        return self.root\\n    \\n    def insertWord(self, word: str):\\n\\n        nextNode = self.root\\n        for c in word:\\n            if c not in nextNode.children:\\n                nextNode.children[c] = TrieNode()\\n            nextNode = nextNode.children[c]\\n        nextNode.isWord = True\\n\\nclass Solution:\\n    trieNode = None\\n    s = None\\n    memoize = None\\n    \\n    def checkConnection(self, prevNode, currentChar: chr) -> TrieNode:\\n        if currentChar in prevNode.children:\\n            return prevNode.children[currentChar]\\n        return None\\n\\n    def wordBreakHelper(self, index: int, node) -> List[List[str]]:\\n        \\n        if index in self.memoize:\\n            return self.memoize[index][:]\\n\\n        result = []\\n        current = []\\n        \\n        start = index\\n        while index < len(self.s):\\n            node = self.checkConnection(node, self.s[index])\\n            \\n            if node is None:\\n                break\\n            \\n            # valid path\\n            current.append(self.s[index])\\n\\n            if node.isWord:\\n                current_word = \\'\\'.join(current)\\n                \\n                if index+1 < len(self.s):\\n                    tempResult = self.wordBreakHelper(index+1, self.trieNode.getRoot())\\n\\n                    #print(tempResult, current_word)\\n                    for val in tempResult:\\n                        result.append([current_word] + val)\\n                else:\\n                    result.append([current_word])\\n\\n            index += 1\\n            \\n        self.memoize[start] = result\\n        return self.memoize[start][:]\\n\\n\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n\\n        self.trieNode = Trie()\\n        self.s = s\\n        self.memoize = {}\\n        # creating a Trie\\n        \\n        for s in wordDict:\\n            self.trieNode.insertWord(s)\\n        \\n        \\n        final_result = self.wordBreakHelper(0, self.trieNode.getRoot())\\n        \\n        \\n        #print(self.memoize)\\n        return [\\' \\'.join(word_list) for word_list in final_result]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424750,
                "title": "simplified-word-break-1-and-2-java-based-on-dp-one-dimensional-array-and-dfs",
                "content": "Idea is to use one dimensional DP array and keep updating it until we reach to the end. \\n\\nWord break 1: result is in the last index.\\nWord break 2: result will be built by dfs on dp array.\\n\\n**Word Break 1**\\n![image](https://assets.leetcode.com/users/tyr1on/image_1573326539.png)\\n\\n\\n```\\n\\tpublic static boolean wordBreak(String s, List<String> wordDict) {\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                String check = s.substring(j, i);\\n                if (dp[j] && wordDict.contains(check)) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\\n\\n**Word Break 2**\\n![image](https://assets.leetcode.com/users/tyr1on/image_1573326566.png)\\n\\n\\n```\\n\\tpublic static List<String> wordBreakII(String word, List<String> dict) {\\n        if (null == word || word.isEmpty() ||\\n                null == dict || dict.isEmpty()) {\\n            return Collections.emptyList();\\n        }\\n\\n        // dp array\\n        List<String>[] dp = new ArrayList[word.length() + 1];\\n        dp[0] = new ArrayList<>();\\n\\n        for (int i = 1; i <= word.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                // form a word and check if it is in dict\\n                String check = word.substring(j, i);\\n                if (null != dp[j] && dict.contains(check)) {\\n                    if (null == dp[i]) {\\n                        dp[i] = new ArrayList<>();\\n                    }\\n                    dp[i].add(check);\\n                }\\n            }\\n        }\\n\\n        // if dictionary words cannot join to given word\\n        if (null == dp[word.length()]) {\\n            return Collections.emptyList();\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n        // start dfs from back\\n        dfs(dp, result, \"\", word.length());\\n        return result;\\n    }\\n\\n    // perform dfs from the end of the dp array to form the result list\\n    public static void dfs(List<String>[] dp, List<String> result, String current, int i) {\\n        if (i == 0) {\\n            result.add(current.trim());\\n            return;\\n        }\\n\\n        for (String s : dp[i]) {\\n            // append string to previous result\\n            String combined = s + \" \" + current;\\n            dfs(dp, result, combined, i - s.length());\\n        }\\n    }\\n```\\n\\nA lannister always pays his debt!",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tpublic static boolean wordBreak(String s, List<String> wordDict) {\\n        boolean[] dp = new boolean[s.length() + 1];\\n        dp[0] = true;\\n        for (int i = 1; i <= s.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                String check = s.substring(j, i);\\n                if (dp[j] && wordDict.contains(check)) {\\n                    dp[i] = true;\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[s.length()];\\n    }\\n```\n```\\n\\tpublic static List<String> wordBreakII(String word, List<String> dict) {\\n        if (null == word || word.isEmpty() ||\\n                null == dict || dict.isEmpty()) {\\n            return Collections.emptyList();\\n        }\\n\\n        // dp array\\n        List<String>[] dp = new ArrayList[word.length() + 1];\\n        dp[0] = new ArrayList<>();\\n\\n        for (int i = 1; i <= word.length(); i++) {\\n            for (int j = 0; j < i; j++) {\\n                // form a word and check if it is in dict\\n                String check = word.substring(j, i);\\n                if (null != dp[j] && dict.contains(check)) {\\n                    if (null == dp[i]) {\\n                        dp[i] = new ArrayList<>();\\n                    }\\n                    dp[i].add(check);\\n                }\\n            }\\n        }\\n\\n        // if dictionary words cannot join to given word\\n        if (null == dp[word.length()]) {\\n            return Collections.emptyList();\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n        // start dfs from back\\n        dfs(dp, result, \"\", word.length());\\n        return result;\\n    }\\n\\n    // perform dfs from the end of the dp array to form the result list\\n    public static void dfs(List<String>[] dp, List<String> result, String current, int i) {\\n        if (i == 0) {\\n            result.add(current.trim());\\n            return;\\n        }\\n\\n        for (String s : dp[i]) {\\n            // append string to previous result\\n            String combined = s + \" \" + current;\\n            dfs(dp, result, combined, i - s.length());\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327441,
                "title": "c-98-beaten-o-n-m-m-max-word-len-hot-stinger-solution",
                "content": "This seems to work. Basically just solving word-break-1, only continuing to explore the solution space even if we get a match. Use sets to make sure you aren\\'t exploring the same branch twice. Otherwise the program will be slow and you will have many duplicate answers for some test cases.\\n\\nIf you have done all the problems up to this point, you have have the tools to solve this. If you can\\'t then you are an idiot. Plain and simple. A simpleton who is no better than a vegetable. And you should be served on a plate to a race of feasting giants.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int mMaxLength;\\n    int mMinLength;\\n    unordered_set<string> mDictionary;\\n    vector<unordered_set<string>> mMatchSets;\\n    vector<string> mTemp;\\n    char *mAnsStr;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        vector<string> aResult;\\n        if (wordDict.size() <= 0) { return aResult; }\\n        \\n        for (int i=0;i<s.size();i++) {\\n            unordered_set<string> aSet;\\n            mMatchSets.push_back(aSet);\\n        }\\n        \\n        mAnsStr = new char[s.size() + s.size() + 2]; //some space to write to...\\n        \\n        mMaxLength = 0;\\n        mMinLength = -1;\\n        for (auto aWord : wordDict) {\\n            \\n            mDictionary.insert(aWord);\\n            if (aWord.size() > mMaxLength) {\\n                mMaxLength = aWord.size();\\n            }\\n            if (mMinLength == -1 || aWord.size() < mMinLength) {\\n                mMinLength = aWord.size();\\n            }\\n        }\\n        \\n        wordBreakExplorer(s, wordDict, s.size() - 1); //Find all the answers.\\n        wordBreakSolutionBuilder(aResult, s, 0); //Build all the solutions.\\n        \\n        return aResult;\\n    }\\n\\n    void wordBreakExplorer(string &pString, vector<string>& pDict, int pStart) {\\n        if (pStart < 0) { return; }\\n        \\n        int aInd1 = pStart - mMinLength + 1;\\n        int aInd2 = pStart - mMaxLength + 1;\\n        \\n        if (aInd1 < 0) { return; }\\n        if (aInd2 < 0) { aInd2 = 0; }\\n        \\n        int aLength = mMinLength;\\n        for (int i=aInd1;i>=aInd2;i--) {\\n            \\n            string aChunk = pString.substr(i, aLength);\\n            if (mMatchSets[i].count(aChunk) == 0) {\\n\\n                if (mDictionary.count(aChunk) > 0) {\\n                    mMatchSets[i].insert(aChunk);\\n                    wordBreakExplorer(pString, pDict, i - 1);\\n                }\\n            }\\n            aLength++;\\n        }\\n    }\\n    \\n    \\n    void wordBreakSolutionBuilder(vector<string> &pResult, string &pString, int pStart) {\\n        \\n        if (pStart == pString.size()) {\\n            //Turn the answer into a space-separated word.\\n            int aIndex = 0;\\n            for (auto aString : mTemp) {\\n                for (int i=0;i<aString.size();i++) {\\n                    mAnsStr[aIndex++] = aString[i]; \\n                }\\n                mAnsStr[aIndex++] = \\' \\';\\n            }\\n            mAnsStr[aIndex - 1] = 0;\\n            pResult.push_back(string(mAnsStr));\\n            return;\\n        }\\n        \\n        for (auto aWord : mMatchSets[pStart]) {\\n            //Crawl the solution space. Like a baby crawls for milk bottles.\\n            mTemp.push_back(aWord);\\n            wordBreakSolutionBuilder(pResult, pString, pStart + aWord.size());   \\n            mTemp.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int mMaxLength;\\n    int mMinLength;\\n    unordered_set<string> mDictionary;\\n    vector<unordered_set<string>> mMatchSets;\\n    vector<string> mTemp;\\n    char *mAnsStr;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        \\n        vector<string> aResult;\\n        if (wordDict.size() <= 0) { return aResult; }\\n        \\n        for (int i=0;i<s.size();i++) {\\n            unordered_set<string> aSet;\\n            mMatchSets.push_back(aSet);\\n        }\\n        \\n        mAnsStr = new char[s.size() + s.size() + 2]; //some space to write to...\\n        \\n        mMaxLength = 0;\\n        mMinLength = -1;\\n        for (auto aWord : wordDict) {\\n            \\n            mDictionary.insert(aWord);\\n            if (aWord.size() > mMaxLength) {\\n                mMaxLength = aWord.size();\\n            }\\n            if (mMinLength == -1 || aWord.size() < mMinLength) {\\n                mMinLength = aWord.size();\\n            }\\n        }\\n        \\n        wordBreakExplorer(s, wordDict, s.size() - 1); //Find all the answers.\\n        wordBreakSolutionBuilder(aResult, s, 0); //Build all the solutions.\\n        \\n        return aResult;\\n    }\\n\\n    void wordBreakExplorer(string &pString, vector<string>& pDict, int pStart) {\\n        if (pStart < 0) { return; }\\n        \\n        int aInd1 = pStart - mMinLength + 1;\\n        int aInd2 = pStart - mMaxLength + 1;\\n        \\n        if (aInd1 < 0) { return; }\\n        if (aInd2 < 0) { aInd2 = 0; }\\n        \\n        int aLength = mMinLength;\\n        for (int i=aInd1;i>=aInd2;i--) {\\n            \\n            string aChunk = pString.substr(i, aLength);\\n            if (mMatchSets[i].count(aChunk) == 0) {\\n\\n                if (mDictionary.count(aChunk) > 0) {\\n                    mMatchSets[i].insert(aChunk);\\n                    wordBreakExplorer(pString, pDict, i - 1);\\n                }\\n            }\\n            aLength++;\\n        }\\n    }\\n    \\n    \\n    void wordBreakSolutionBuilder(vector<string> &pResult, string &pString, int pStart) {\\n        \\n        if (pStart == pString.size()) {\\n            //Turn the answer into a space-separated word.\\n            int aIndex = 0;\\n            for (auto aString : mTemp) {\\n                for (int i=0;i<aString.size();i++) {\\n                    mAnsStr[aIndex++] = aString[i]; \\n                }\\n                mAnsStr[aIndex++] = \\' \\';\\n            }\\n            mAnsStr[aIndex - 1] = 0;\\n            pResult.push_back(string(mAnsStr));\\n            return;\\n        }\\n        \\n        for (auto aWord : mMatchSets[pStart]) {\\n            //Crawl the solution space. Like a baby crawls for milk bottles.\\n            mTemp.push_back(aWord);\\n            wordBreakSolutionBuilder(pResult, pString, pStart + aWord.size());   \\n            mTemp.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44210,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var cache = [String: [String]]()\\n        return DFS(s, wordDict, &cache)\\n    }\\n    \\n    func DFS(_ s: String, _ wordDict: [String], _ cache: inout [String: [String]]) -> [String] {\\n        if s.characters.count == 0 {\\n            return [\"\"]\\n        }\\n        if let value = cache[s] {\\n            return value\\n        }\\n        \\n        var result = [String]()\\n        \\n        for word in wordDict {\\n            if s.hasPrefix(word) {\\n                let subWordBreaks = DFS(s.substring(from: word.endIndex), wordDict, &cache)\\n                for subWordBreak in subWordBreaks {\\n                    if subWordBreak.isEmpty {\\n                        result.append(word)\\n                    } else {\\n                        result.append(word + \" \" + subWordBreak)\\n                    }\\n                }\\n            }\\n        }\\n        cache[s] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func wordBreak(_ s: String, _ wordDict: [String]) -> [String] {\\n        var cache = [String: [String]]()\\n        return DFS(s, wordDict, &cache)\\n    }\\n    \\n    func DFS(_ s: String, _ wordDict: [String], _ cache: inout [String: [String]]) -> [String] {\\n        if s.characters.count == 0 {\\n            return [\"\"]\\n        }\\n        if let value = cache[s] {\\n            return value\\n        }\\n        \\n        var result = [String]()\\n        \\n        for word in wordDict {\\n            if s.hasPrefix(word) {\\n                let subWordBreaks = DFS(s.substring(from: word.endIndex), wordDict, &cache)\\n                for subWordBreak in subWordBreaks {\\n                    if subWordBreak.isEmpty {\\n                        result.append(word)\\n                    } else {\\n                        result.append(word + \" \" + subWordBreak)\\n                    }\\n                }\\n            }\\n        }\\n        cache[s] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 44225,
                "title": "golang-3ms-solution",
                "content": "```\\nimport \"strings\"\\n\\nfunc wordBreak(s string, wordDict []string) []string {\\n    mp := make(map[string][]string)\\n    return dfs(s, wordDict, mp)    \\n}\\n\\nfunc dfs(s string, wordDict []string, mp map[string][]string) []string {\\n    _, ok := mp[s]\\n    if ok {\\n        return mp[s]\\n    }\\n    \\n    res := make([]string, 0)\\n    if len(s) == 0 {\\n        res = append(res, \"\")\\n        return res\\n    }\\n    for _,word:= range wordDict {\\n        if strings.HasPrefix(s, word) {\\n            sublist := dfs(s[len(word):], wordDict, mp)\\n            for _, sub:= range sublist {\\n                a := \" \"\\n                if len(sub) == 0 {\\n                    a = \"\"\\n                }\\n                res = append(res, word + a + sub)\\n            }\\n        }        \\n    }\\n    mp[s] = res\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport \"strings\"\\n\\nfunc wordBreak(s string, wordDict []string) []string {\\n    mp := make(map[string][]string)\\n    return dfs(s, wordDict, mp)    \\n}\\n\\nfunc dfs(s string, wordDict []string, mp map[string][]string) []string {\\n    _, ok := mp[s]\\n    if ok {\\n        return mp[s]\\n    }\\n    \\n    res := make([]string, 0)\\n    if len(s) == 0 {\\n        res = append(res, \"\")\\n        return res\\n    }\\n    for _,word:= range wordDict {\\n        if strings.HasPrefix(s, word) {\\n            sublist := dfs(s[len(word):], wordDict, mp)\\n            for _, sub:= range sublist {\\n                a := \" \"\\n                if len(sub) == 0 {\\n                    a = \"\"\\n                }\\n                res = append(res, word + a + sub)\\n            }\\n        }        \\n    }\\n    mp[s] = res\\n    return res\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 44308,
                "title": "c-dfs-caching",
                "content": "    public class Solution {\\n        Dictionary<string, List<string>> dp = new Dictionary<string, List<string>>();\\n    \\n        public IList<string> WordBreak(string s, ISet<string> wordDict)\\n        {\\n            return WordBreak(s, 0, s.Length - 1, wordDict);\\n        }\\n    \\n        public IList<string> WordBreak(string s, int start, int end, ISet<string> wordDict)\\n        {\\n            string key = start + \"_\" + end;\\n            if (dp.ContainsKey(key))\\n            {\\n                return dp[key];\\n            }\\n    \\n            List<string> sentences = new List<string>();\\n            for (int sub = start ; sub < end ; sub++)\\n            {\\n                int subLength = sub - start + 1;\\n                string subStr = s.Substring(start, subLength);\\n                if (wordDict.Contains(subStr))\\n                {\\n                    IList<string> rest = WordBreak(s, sub + 1, end, wordDict);\\n                    if (rest.Any())\\n                    {\\n                        sentences.AddRange(rest.Select(ss => subStr + \" \" + ss));\\n                    }\\n                }\\n            }\\n    \\n            string curSentence = s.Substring(start, end - start + 1);\\n            if (wordDict.Contains(curSentence))\\n            {\\n                sentences.Add(curSentence);\\n            }\\n    \\n            dp[key] = sentences;\\n            return sentences;\\n        }\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        Dictionary<string, List<string>> dp = new Dictionary<string, List<string>>();\\n    \\n        public IList<string> WordBreak(string s, ISet<string> wordDict)\\n        {\\n            return WordBreak(s, 0, s.Length - 1, wordDict);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 44345,
                "title": "python-dp-solution-in-11-lines",
                "content": "    \\n\\n\\n    \\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        M = {}\\n        def dfs(remain_str):\\n            if not remain_str: return ['']\\n            if remain_str in M: return M[remain_str]\\n            ret = []    \\n            for i in xrange(1,len(remain_str)+1):\\n                if remain_str[:i] in wordDict: \\n                    for r in dfs(remain_str[i:]): \\n                        ret.append( (remain_str[:i]+' '+r).strip() )\\n            M[remain_str] = tuple(ret)\\n            return ret\\n        return dfs(s)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    \\n\\n\\n    \\n    def wordBreak(self, s, wordDict):\\n        \"\"\"\\n        :type s: str\\n        :type wordDict: Set[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        M = {}\\n        def dfs(remain_str):\\n            if not remain_str: return ['']\\n            if remain_str in M: return M[remain_str]\\n            ret = []    \\n            for i in xrange(1,len(remain_str)+1):\\n                if remain_str[:i] in wordDict: \\n                    for r in dfs(remain_str[i:]): \\n                        ret.append( (remain_str[:i]+' '+r).strip() )\\n            M[remain_str] = tuple(ret)\\n            return ret\\n        return dfs(s)",
                "codeTag": "Python3"
            },
            {
                "id": 44322,
                "title": "c-solution-using-dp-and-backtrace-8ms",
                "content": "1. using dp to just like \"work break\".\\n2. backtrace with dp.\\n\\n    class Solution {\\n    \\n        vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n            if(s.empty() || wordDict.empty()) return vector<string>();\\n            int n = s.size();\\n            vector<bool> dp(n+1, false);\\n            dp[n] = true;\\n            \\n            for(int i=n-1; i >= 0; --i)\\n                for(int j=i+1; j <= n; ++j)\\n                    if(dp[j] && wordDict.find(s.substr(i, j-i)) != wordDict.end()) {\\n                        dp[i] = true;\\n                        break;\\n                    }\\n            if(!dp[0]) return vector<string>();\\n            \\n            vector<string> ret;\\n            bt(s, 0, wordDict, dp, ret);\\n            return ret;\\n        }\\n    \\n        void bt(string &s, int idx, unordered_set<string> &dict, vector<bool> &dp, vector<string> &ret) {\\n            static string tmp;\\n            if(idx == s.size()) {\\n                ret.push_back(tmp);\\n                return ;\\n            }\\n            for(int i=idx+1; i <= s.size(); ++i) {\\n                string str(s, idx, i-idx);\\n                if(dp[i] && dict.find(str) != dict.end()) {\\n                    if(idx != 0) tmp += \" \";\\n                    tmp += str;\\n                    cout << tmp << endl;\\n                    \\n                    bt(s, i, dict, dp, ret);\\n                    \\n                    if(idx == 0) tmp.erase(tmp.size()-str.size());\\n                    else tmp.erase(tmp.size()-str.size()-1);\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    \\n        vector<string> wordBreak(string s, unordered_set<string>& wordDict) {\\n            if(s.empty() || wordDict.empty()) return vector<string>();\\n            int n = s.size();\\n            vector<bool> dp(n+1, false);\\n            dp[n] = true;\\n            \\n            for(int i=n-1; i >= 0; --i)\\n                for(int j=i+1; j <= n; ++j)\\n                    if(dp[j] && wordDict.find(s.substr(i, j-i)) != wordDict.end()) {\\n                        dp[i] = true;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3457927,
                "title": "java-backtraking-easy-to-understand-4ms",
                "content": "4 ms, faster than 61.24% of Java online submissions for Word Break II.\\n```\\nclass Solution {\\n    List<String> wordDict;\\n    String s;\\n    Set<String> res = new HashSet<String>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordDict = wordDict;\\n        this.s = s;\\n        helper(0, 0, new ArrayList<String>());\\n        return new ArrayList<String>(res);\\n    }\\n    public void helper(int i, int j, List<String> arr) {\\n        if(j == s.length()) {\\n            int size = 0;\\n            for(String c : arr) size += c.length();\\n            if(size == s.length()) {\\n                res.add(arr.stream().map(Object::toString)\\n                          .collect(Collectors.joining(\" \")));\\n            }\\n            return;\\n        }\\n        while(j < s.length()) {\\n            if(wordDict.contains(s.substring(i, j + 1))) {\\n                arr.add(s.substring(i, j + 1));\\n                helper(j + 1, j + 1, arr);\\n                helper(i, j + 1, arr);\\n                arr.remove(arr.size() - 1);\\n            }\\n            j++;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<String> wordDict;\\n    String s;\\n    Set<String> res = new HashSet<String>();\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        this.wordDict = wordDict;\\n        this.s = s;\\n        helper(0, 0, new ArrayList<String>());\\n        return new ArrayList<String>(res);\\n    }\\n    public void helper(int i, int j, List<String> arr) {\\n        if(j == s.length()) {\\n            int size = 0;\\n            for(String c : arr) size += c.length();\\n            if(size == s.length()) {\\n                res.add(arr.stream().map(Object::toString)\\n                          .collect(Collectors.joining(\" \")));\\n            }\\n            return;\\n        }\\n        while(j < s.length()) {\\n            if(wordDict.contains(s.substring(i, j + 1))) {\\n                arr.add(s.substring(i, j + 1));\\n                helper(j + 1, j + 1, arr);\\n                helper(i, j + 1, arr);\\n                arr.remove(arr.size() - 1);\\n            }\\n            j++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205780,
                "title": "140-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe time complexity of this algorithm is O(n^3), where n is the length of the input string s. The space complexity is also O(n^3), due to the memoization dictionary. However, in practice, the space complexity will be much lower, as the memoization dictionary will only contain results for a small subset of all possible substrings of s.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        # Create a set of words for fast lookup\\n        word_set = set(wordDict)\\n        # Create a memoization dictionary to store previously calculated results\\n        memo = {}\\n        \\n        # Define a recursive function to find all possible sentences\\n        def dfs(s):\\n            # If the current string s has already been calculated, return the result\\n            if s in memo:\\n                return memo[s]\\n            \\n            # If the string s is empty, return an empty list\\n            if not s:\\n                return []\\n            \\n            # Initialize the result list\\n            res = []\\n            \\n            # Iterate over all possible splits of the string s\\n            for i in range(1, len(s) + 1):\\n                # If the left part of the split is a valid word\\n                if s[:i] in word_set:\\n                    # Recursively find all possible sentences for the right part of the split\\n                    right_sents = dfs(s[i:])\\n                    # If there are any possible sentences for the right part of the split\\n                    if right_sents:\\n                        # Append the current word and all possible sentences for the right part of the split\\n                        for right_sent in right_sents:\\n                            res.append(s[:i] + \" \" + right_sent)\\n                    # If there are no possible sentences for the right part of the split, but the right part is empty\\n                    elif not s[i:]:\\n                        # Append just the current word\\n                        res.append(s[:i])\\n            \\n            # Store the result for the current string s in the memoization dictionary and return it\\n            memo[s] = res\\n            return res\\n        \\n        # Call the recursive function to find all possible sentences for the input string s\\n        return dfs(s)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        # Create a set of words for fast lookup\\n        word_set = set(wordDict)\\n        # Create a memoization dictionary to store previously calculated results\\n        memo = {}\\n        \\n        # Define a recursive function to find all possible sentences\\n        def dfs(s):\\n            # If the current string s has already been calculated, return the result\\n            if s in memo:\\n                return memo[s]\\n            \\n            # If the string s is empty, return an empty list\\n            if not s:\\n                return []\\n            \\n            # Initialize the result list\\n            res = []\\n            \\n            # Iterate over all possible splits of the string s\\n            for i in range(1, len(s) + 1):\\n                # If the left part of the split is a valid word\\n                if s[:i] in word_set:\\n                    # Recursively find all possible sentences for the right part of the split\\n                    right_sents = dfs(s[i:])\\n                    # If there are any possible sentences for the right part of the split\\n                    if right_sents:\\n                        # Append the current word and all possible sentences for the right part of the split\\n                        for right_sent in right_sents:\\n                            res.append(s[:i] + \" \" + right_sent)\\n                    # If there are no possible sentences for the right part of the split, but the right part is empty\\n                    elif not s[i:]:\\n                        # Append just the current word\\n                        res.append(s[:i])\\n            \\n            # Store the result for the current string s in the memoization dictionary and return it\\n            memo[s] = res\\n            return res\\n        \\n        # Call the recursive function to find all possible sentences for the input string s\\n        return dfs(s)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107035,
                "title": "c-dp-solution-with-explanation-0ms-100-faster-runtime",
                "content": "# Intuition\\n\\nThe first observation to make out from the given description is that this problem involves the concept of subproblem within a problem - i.e. DP; meaning, the problem can be broken down into smaller fractions and the final answer can be found by combining the answers to these subproblems.\\n\\n# Approach\\n\\nWe will first insert the list of words into an unordered set (unsorted) so that finding the strings within the set takes negligible time.\\n\\nNext, we declare an array of array of strings (2D vector) of size one more than the size of the given original string. This two-dimensional array of strings stores in each index \\'i\\' the list of strings that upon concatenation result in a prefix string of length \\'i\\'.\\n\\nNow we iterate from index i = 0 to the size of the string and for each \\'i\\', from j = i + 1 to the end of the string and check if the resultant substring from position \\'i\\' of length \\'j - i\\' is contained in the list of words in wordDict.\\n\\nIf it is contained in the list of words, the from index \\'i\\', we obtain all the strings that lead up to the prefix string of length \\'i\\' and we append the string of length \\'j - i\\' and push the list in the position \\'j\\' (dp[j]).\\n\\nThe final answer is obtained at the last position of the dp array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set <string> st;\\n\\n        for(auto x: wordDict)\\n            st.insert(x);\\n        \\n        int n = s.size();\\n        vector <vector <string> > dp(n + 1);\\n        dp[0] = {\"\"};\\n\\n        for(int i = 0; i < n; i++) {\\n            if(dp[i].size() == 0)\\n                continue;\\n            \\n            for(int j = i + 1; j <= n; j++) {\\n                string tmp = s.substr(i, j - i);\\n\\n                if(st.count(tmp)) {\\n                    for(auto x: dp[i]) {\\n                        string str = x;\\n                        str += tmp;\\n                        str.push_back(\\' \\');\\n                        dp[j].push_back(str);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(auto &x: dp[n]) // for the elimination of terminal space characters\\n            x.pop_back();\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set <string> st;\\n\\n        for(auto x: wordDict)\\n            st.insert(x);\\n        \\n        int n = s.size();\\n        vector <vector <string> > dp(n + 1);\\n        dp[0] = {\"\"};\\n\\n        for(int i = 0; i < n; i++) {\\n            if(dp[i].size() == 0)\\n                continue;\\n            \\n            for(int j = i + 1; j <= n; j++) {\\n                string tmp = s.substr(i, j - i);\\n\\n                if(st.count(tmp)) {\\n                    for(auto x: dp[i]) {\\n                        string str = x;\\n                        str += tmp;\\n                        str.push_back(\\' \\');\\n                        dp[j].push_back(str);\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(auto &x: dp[n]) // for the elimination of terminal space characters\\n            x.pop_back();\\n        \\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801907,
                "title": "fast",
                "content": "```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "solutionTags": [],
                "code": "```\\ndef fun(s,dc,memo):\\n    if(s in memo):\\n        return memo[s]\\n    ans=[]\\n    if(dc[s]==1):\\n        ans=[s]\\n    for i in range(1,len(s)):\\n        if(dc[s[:i]]==1):\\n            a=fun(s[i:],dc,memo)\\n            for x in a:\\n                ans.append(s[:i]+\" \"+x)\\n    memo[s]=ans\\n    return ans\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        dc=defaultdict(lambda:0)\\n        for a in wordDict:\\n            dc[a]=1\\n        return(fun(s,dc,{}))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749473,
                "title": "recursion-beats-100-cpp",
                "content": "```\\nclass Solution {\\n     void solve(int index,string &s,unordered_set<string> &hashset,int &n,string sub_ans,vector<string> &ans){\\n        if(index==n){\\n            sub_ans=sub_ans.substr(1); //to remove leading space\\n            ans.push_back(sub_ans);\\n            return;\\n        }\\n        string temp=\"\"; \\n*         //tring every possible partition \\n        for(int i=index;i<n;i++){\\n            //temp is the word formed by partition\\n            temp+=s[i];\\n            //if word before partition exist in hashset then check for remaining word\\n            if(hashset.find(temp)!=hashset.end()){\\n               solve(i+1,s,hashset,n,sub_ans+\" \"+temp,ans);\\n            }\\n        }\\n        \\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> ans; //answer vector\\n        //storing all the words in hashset\\n        unordered_set<string> hashset; \\n        for(auto i:wordDict){\\n            hashset.insert(i);\\n        }\\n        int n=s.length();\\n        string sub_ans=\"\"; //empty string to store sentence\\n        solve(0,s,hashset,n,sub_ans,ans); //helpercode call\\n        return ans; \\n        \\n    }\\n};\\n## //please upvote if it was helpfull\\n",
                "solutionTags": [],
                "code": "class Solution {\\n     void solve(int index,string &s,unordered_set<string> &hashset,int &n,string sub_ans,vector<string> &ans){\\n        if(index==n){\\n            sub_ans=sub_ans.substr(1); //to remove leading space\\n            ans.push_back(sub_ans);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2739918,
                "title": "very-easy-and-simple-recursive-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        helper(s, dictionary, ans, \"\");\\n        return ans;\\n    }\\n\\n    void helper(String s, List<String> d, List<String> ans, String temp){\\n        if(s.length() == 0){\\n            ans.add(temp.trim());\\n            return;\\n        }\\n    \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            String right = s.substring(i, s.length());\\n            if(d.contains(right)){\\n                String left = s.substring(0, i);\\n                helper(left, d, ans, right + \" \" + temp);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        helper(s, dictionary, ans, \"\");\\n        return ans;\\n    }\\n\\n    void helper(String s, List<String> d, List<String> ans, String temp){\\n        if(s.length() == 0){\\n            ans.add(temp.trim());\\n            return;\\n        }\\n    \\n        for(int i = s.length() - 1; i >= 0; i--){\\n            String right = s.substring(i, s.length());\\n            if(d.contains(right)){\\n                String left = s.substring(0, i);\\n                helper(left, d, ans, right + \" \" + temp);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671659,
                "title": "java-backtracking-faster-than-100-short-code",
                "content": "Unlike the Dynamic programming solution mentioned in the solution, a backtracking approach gives the same time complexity on an asymptotic case.\\n```\\nclass Solution {\\n    List<String> ans;\\n    public void breakWord(String s, int start, Set<String> dict, List<String> curr){\\n        for(int i=start+1;i<=s.length();i++){\\n            String f = s.substring(start, i);\\n            if(dict.contains(f)){\\n                curr.add(f);\\n                if(i==s.length()){\\n                    String[] stringparts = curr.toArray(String[]::new);\\n                    ans.add(String.join(\" \", stringparts));\\n                }    \\n                else breakWord(s, i, dict, curr);\\n                curr.remove(curr.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        ans = new ArrayList<String>();\\n        Set<String> dict = new HashSet();\\n        for(String w:wordDict) dict.add(w);\\n        breakWord(s, 0, dict, new ArrayList<String>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> ans;\\n    public void breakWord(String s, int start, Set<String> dict, List<String> curr){\\n        for(int i=start+1;i<=s.length();i++){\\n            String f = s.substring(start, i);\\n            if(dict.contains(f)){\\n                curr.add(f);\\n                if(i==s.length()){\\n                    String[] stringparts = curr.toArray(String[]::new);\\n                    ans.add(String.join(\" \", stringparts));\\n                }    \\n                else breakWord(s, i, dict, curr);\\n                curr.remove(curr.size()-1);\\n            }\\n        }\\n    }\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        ans = new ArrayList<String>();\\n        Set<String> dict = new HashSet();\\n        for(String w:wordDict) dict.add(w);\\n        breakWord(s, 0, dict, new ArrayList<String>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627035,
                "title": "short-and-standard-backtracking-solution-java",
                "content": "```\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(s, wordDict, res, 0, new ArrayList<>());\\n        return res.stream().map(list -> String.join(\" \", list)).collect(Collectors.toList());\\n    }\\n    // classical backtracking - performance better compare with below solution-2\\n    public static void dfs(String s, List<String> wordDict, List<List<String>> res,\\n                           int start, List<String> track) {\\n        if (start == s.length()) {\\n            res.add(new ArrayList<>(track));\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            String next = s.substring(start, i + 1); // catch: substring from start\\n            if (wordDict.contains(next)) {\\n                track.add(next);\\n                dfs(s, wordDict, res, i + 1, track);\\n                track.remove(track.size()-1);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(s, wordDict, res, 0, new ArrayList<>());\\n        return res.stream().map(list -> String.join(\" \", list)).collect(Collectors.toList());\\n    }\\n    // classical backtracking - performance better compare with below solution-2\\n    public static void dfs(String s, List<String> wordDict, List<List<String>> res,\\n                           int start, List<String> track) {\\n        if (start == s.length()) {\\n            res.add(new ArrayList<>(track));\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            String next = s.substring(start, i + 1); // catch: substring from start\\n            if (wordDict.contains(next)) {\\n                track.add(next);\\n                dfs(s, wordDict, res, i + 1, track);\\n                track.remove(track.size()-1);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375696,
                "title": "java-concise-and-simple-code-with-comments",
                "content": "Runtime: 4 ms, faster than 61.76% of Java online submissions for Word Break II.\\nMemory Usage: 40.5 MB, less than 93.93% of Java online submissions for Word Break II.\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> words) {\\n        List<String> ans = new ArrayList<>();\\n        helper(\"\", s, words, ans);\\n        return ans;\\n    }\\n    \\n    void helper(String curr, String s, List<String> words, List<String> ans) {\\n        if(s.length() == 0) {\\n            ans.add(curr.trim()); // Remove any whitespace at the end\\n            return;\\n        }\\n        for(String word : words) {\\n            if(s.indexOf(word) == 0) { // Check if s starts with current word\\n               helper(curr + \" \" + word, s.substring(word.length()), words, ans); // Call helper for remaining s\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> words) {\\n        List<String> ans = new ArrayList<>();\\n        helper(\"\", s, words, ans);\\n        return ans;\\n    }\\n    \\n    void helper(String curr, String s, List<String> words, List<String> ans) {\\n        if(s.length() == 0) {\\n            ans.add(curr.trim()); // Remove any whitespace at the end\\n            return;\\n        }\\n        for(String word : words) {\\n            if(s.indexOf(word) == 0) { // Check if s starts with current word\\n               helper(curr + \" \" + word, s.substring(word.length()), words, ans); // Call helper for remaining s\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302827,
                "title": "c-simple-c-code-100-time-83-space",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n![image](https://assets.leetcode.com/users/images/e0c05b38-fafa-41a9-b1d8-98c3c09a6133_1658213884.0128381.png)\\n\\n```\\nclass Solution {\\n    vector<string> ans;\\n    unordered_map<string, int> um;\\n    void dfs(string &s, string &comb, int i)\\n    {\\n        if(i == s.size())\\n        {\\n            if(comb.size() != 0)\\n            {\\n                string f = comb.substr(0,comb.size()-1);\\n                ans.push_back(f);   \\n            }\\n            return;\\n        }\\n        string tmp = \"\";\\n        for(int j = i; j < s.size(); j++)\\n        {\\n            tmp += s[j];\\n            if(um.count(tmp))\\n            {\\n                string store = comb;\\n                comb += tmp + \\' \\';\\n                dfs(s, comb, j+1);\\n                comb = store;\\n            }\\n        }\\n        return;\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string combs = \"\";\\n        for(string &str : wordDict)\\n            um[str]++;\\n        dfs(s, combs, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<string> ans;\\n    unordered_map<string, int> um;\\n    void dfs(string &s, string &comb, int i)\\n    {\\n        if(i == s.size())\\n        {\\n            if(comb.size() != 0)\\n            {\\n                string f = comb.substr(0,comb.size()-1);\\n                ans.push_back(f);   \\n            }\\n            return;\\n        }\\n        string tmp = \"\";\\n        for(int j = i; j < s.size(); j++)\\n        {\\n            tmp += s[j];\\n            if(um.count(tmp))\\n            {\\n                string store = comb;\\n                comb += tmp + \\' \\';\\n                dfs(s, comb, j+1);\\n                comb = store;\\n            }\\n        }\\n        return;\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        string combs = \"\";\\n        for(string &str : wordDict)\\n            um[str]++;\\n        dfs(s, combs, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252707,
                "title": "c-easy-to-understand-simple-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    set<string> dict;\\n    int n;\\n    void backtrack(string &s,vector<string> &ans,string str)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(str);\\n            return;\\n        }\\n        for(int j=1;j<=s.size();j++)\\n        {\\n            string left=s.substr(0,j);\\n            string right=s.substr(j);\\n            if(dict.find(left)!=dict.end())\\n            {\\n                string z=str;\\n                str+=left;\\n                str+=\\' \\';\\n                backtrack(right,ans,str);\\n                str=z;\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n=s.length();\\n        for(auto &word:wordDict)\\n        {\\n            dict.insert(word);\\n        }\\n        \\n        vector<string> ans;\\n        backtrack(s,ans,\"\");\\n        for(auto &x:ans)\\n        {\\n            x.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<string> dict;\\n    int n;\\n    void backtrack(string &s,vector<string> &ans,string str)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(str);\\n            return;\\n        }\\n        for(int j=1;j<=s.size();j++)\\n        {\\n            string left=s.substr(0,j);\\n            string right=s.substr(j);\\n            if(dict.find(left)!=dict.end())\\n            {\\n                string z=str;\\n                str+=left;\\n                str+=\\' \\';\\n                backtrack(right,ans,str);\\n                str=z;\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n=s.length();\\n        for(auto &word:wordDict)\\n        {\\n            dict.insert(word);\\n        }\\n        \\n        vector<string> ans;\\n        backtrack(s,ans,\"\");\\n        for(auto &x:ans)\\n        {\\n            x.pop_back();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915607,
                "title": "python-faster-than-95-explanation-simple-code",
                "content": "# \\t<----- IF YOU LIKE THE SOLUTION UPVOTE HERE\\n\\t\\nApproach : \\n1. \\t find the sequences of word from the wordDict which will exactly equal to  our orignal s string.\\n2. \\t After finding the sequences of word just add them using space between each word.\\n\\t\\n\\tclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n            lst  = []\\n            def rec(start,sentence):\\n                if start >= len(s):\\n                    lst.append(sentence[:-1]) #[:-1] bcz at last of the sentence there is space to not incluide it I use last index\\n\\n                for i in range(start,len(s)):      # evert time I am going in forwad directon if the below IF condition satisfy\\n                    if s[start:i+1] in wordDict:\\n                        rec(i+1,sentence + s[start:i+1] + \" \")  # In question they have mension that give space between each word\\n                        \\n            rec(0,\\'\\')\\n            return lst",
                "solutionTags": [
                    "Python"
                ],
                "code": "# \\t<----- IF YOU LIKE THE SOLUTION UPVOTE HERE\\n\\t\\nApproach : \\n1. \\t find the sequences of word from the wordDict which will exactly equal to  our orignal s string.\\n2. \\t After finding the sequences of word just add them using space between each word.\\n\\t\\n\\tclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n            lst  = []\\n            def rec(start,sentence):\\n                if start >= len(s):\\n                    lst.append(sentence[:-1]) #[:-1] bcz at last of the sentence there is space to not incluide it I use last index\\n\\n                for i in range(start,len(s)):      # evert time I am going in forwad directon if the below IF condition satisfy\\n                    if s[start:i+1] in wordDict:\\n                        rec(i+1,sentence + s[start:i+1] + \" \")  # In question they have mension that give space between each word\\n                        \\n            rec(0,\\'\\')\\n            return lst",
                "codeTag": "Java"
            },
            {
                "id": 1764843,
                "title": "python-trie",
                "content": "```\\nclass Solution:\\n    \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = {}\\n\\t\\t#filling the trie\\n        for word in wordDict:\\n            currentDict = trie\\n            for letter in word:\\n                if letter in currentDict:\\n                    currentDict = currentDict[letter]\\n                else:\\n                    currentDict[letter] = {}\\n                    currentDict = currentDict[letter]\\n            currentDict[\\'_\\'] = 0\\n\\t\\t\\t\\n        #function to go through the trie    \\n        def iterate(st, final_res, current, currentTrie):\\n            for i in range(len(st)):       \\n                if \\'_\\' in currentTrie: #found the end of the word, start new search branch\\n                    iterate(st[i:], final_res, current + [st[:i]], trie)\\n                    \\n                if st[i] in currentTrie:\\n                    currentTrie = currentTrie[st[i]]\\n                else: #no possible to fit the word, end this search branch\\n                    return\\n\\n            #last symbol check   \\n            if \\'_\\' in currentTrie:\\n                final_res.append(current + [st])\\n\\n        res = []\\n        iterate(s, res, [], trie)\\n        return [\\' \\'.join(r) for r in res]\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        trie = {}\\n\\t\\t#filling the trie\\n        for word in wordDict:\\n            currentDict = trie\\n            for letter in word:\\n                if letter in currentDict:\\n                    currentDict = currentDict[letter]\\n                else:\\n                    currentDict[letter] = {}\\n                    currentDict = currentDict[letter]\\n            currentDict[\\'_\\'] = 0\\n\\t\\t\\t\\n        #function to go through the trie    \\n        def iterate(st, final_res, current, currentTrie):\\n            for i in range(len(st)):       \\n                if \\'_\\' in currentTrie: #found the end of the word, start new search branch\\n                    iterate(st[i:], final_res, current + [st[:i]], trie)\\n                    \\n                if st[i] in currentTrie:\\n                    currentTrie = currentTrie[st[i]]\\n                else: #no possible to fit the word, end this search branch\\n                    return\\n\\n            #last symbol check   \\n            if \\'_\\' in currentTrie:\\n                final_res.append(current + [st])\\n\\n        res = []\\n        iterate(s, res, [], trie)\\n        return [\\' \\'.join(r) for r in res]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703604,
                "title": "java-evolve-from-139-word-break",
                "content": "//Problem is very similar to \"139. Word Break\"\\n\\n//Here is the solution built on top of \"139. Word Break\" that uses bfs like approach\\n\\n\\tpublic  List<String>  wordBreak(String s, List<String> wordDict) \\n    {\\n        List<String> ans=new LinkedList<>();\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n\\n        Queue<Pair<Integer, StringBuilder>> queue = new LinkedList<>();     \\n        queue.add(new Pair(0, new StringBuilder()));\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            Pair<Integer, StringBuilder> cpair=queue.poll();\\n            int start=cpair.getKey();\\n            StringBuilder sb=cpair.getValue();\\n            \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    StringBuilder sbu=new StringBuilder(sb);\\n                    sbu.append(s.substring(start, end) + \" \");\\n                    \\n                    if (end == s.length())\\n                    {\\n                        ans.add(sbu.toString().trim());\\n                        continue;\\n                    }\\n                    queue.add(new Pair(end, sbu));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n//\\tAnd here is actual solution for \"139. Word Break\"\\n   \\n\\tpublic boolean wordBreak(String s, List<String> wordDict) \\n    {\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n        boolean[] visited = new boolean[s.length()];\\n        \\n        Queue<Integer> queue = new LinkedList<>(); //keeps index    \\n        queue.add(0);\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            int start = queue.poll();\\n            if (visited[start]) \\n                continue;\\n    \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    queue.add(end);\\n                    if (end == s.length()) \\n                        return true;\\n                }\\n            }\\n            visited[start] = true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "//Problem is very similar to \"139. Word Break\"\\n\\n//Here is the solution built on top of \"139. Word Break\" that uses bfs like approach\\n\\n\\tpublic  List<String>  wordBreak(String s, List<String> wordDict) \\n    {\\n        List<String> ans=new LinkedList<>();\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n\\n        Queue<Pair<Integer, StringBuilder>> queue = new LinkedList<>();     \\n        queue.add(new Pair(0, new StringBuilder()));\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            Pair<Integer, StringBuilder> cpair=queue.poll();\\n            int start=cpair.getKey();\\n            StringBuilder sb=cpair.getValue();\\n            \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    StringBuilder sbu=new StringBuilder(sb);\\n                    sbu.append(s.substring(start, end) + \" \");\\n                    \\n                    if (end == s.length())\\n                    {\\n                        ans.add(sbu.toString().trim());\\n                        continue;\\n                    }\\n                    queue.add(new Pair(end, sbu));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n\\t\\n//\\tAnd here is actual solution for \"139. Word Break\"\\n   \\n\\tpublic boolean wordBreak(String s, List<String> wordDict) \\n    {\\n        Set<String> wordDictSet = new HashSet<>(wordDict);\\n        boolean[] visited = new boolean[s.length()];\\n        \\n        Queue<Integer> queue = new LinkedList<>(); //keeps index    \\n        queue.add(0);\\n    \\n        while (!queue.isEmpty()) \\n        {\\n            int start = queue.poll();\\n            if (visited[start]) \\n                continue;\\n    \\n            for (int end=start+1; end<=s.length(); end++) \\n            {\\n                if (wordDictSet.contains(s.substring(start, end))) \\n                {\\n                    queue.add(end);\\n                    if (end == s.length()) \\n                        return true;\\n                }\\n            }\\n            visited[start] = true;\\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1683301,
                "title": "trie-runtime-0ms-100-faster",
                "content": "**Don\\'t Forget to Upvote!**\\n```\\nclass Solution {\\npublic:\\n\\n    class TrieNode{\\n    public:\\n        bool end;\\n        vector<TrieNode*> child;\\n\\n        TrieNode(){\\n            end = false;\\n            child.assign(26,nullptr);\\n        }\\n    };\\n\\n    class Trie{\\n    public:\\n        TrieNode* root;\\n\\n        Trie(){\\n            root = new TrieNode();\\n        }\\n\\n        void insert(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    curr->child[c-\\'a\\'] = new TrieNode();\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            curr->end = true;\\n        }\\n\\n        bool search(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    return false;\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            return curr->end;\\n        }\\n    };\\n\\n    Trie trie;\\n    vector<string> ans;\\n\\n    void recurse(int index,string curr,string sentence,string s){\\n        if(index==s.length()){\\n            sentence.erase(sentence.begin());\\n            ans.push_back(sentence);\\n            return;\\n        }\\n\\n        for(int i=index;i<s.length();i++){\\n            curr.push_back(s[i]);\\n            if(trie.search(curr))\\n                recurse(i+1,\"\",sentence+\" \"+curr,s);\\n        }\\n    }\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto& str:wordDict){\\n            trie.insert(str);\\n        }\\n        recurse(0,\"\",\"\",s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    class TrieNode{\\n    public:\\n        bool end;\\n        vector<TrieNode*> child;\\n\\n        TrieNode(){\\n            end = false;\\n            child.assign(26,nullptr);\\n        }\\n    };\\n\\n    class Trie{\\n    public:\\n        TrieNode* root;\\n\\n        Trie(){\\n            root = new TrieNode();\\n        }\\n\\n        void insert(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    curr->child[c-\\'a\\'] = new TrieNode();\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            curr->end = true;\\n        }\\n\\n        bool search(string s){\\n            TrieNode* curr = root;\\n            for(auto& c:s){\\n                if(!curr->child[c-\\'a\\'])\\n                    return false;\\n                curr = curr->child[c-\\'a\\'];\\n            }\\n            return curr->end;\\n        }\\n    };\\n\\n    Trie trie;\\n    vector<string> ans;\\n\\n    void recurse(int index,string curr,string sentence,string s){\\n        if(index==s.length()){\\n            sentence.erase(sentence.begin());\\n            ans.push_back(sentence);\\n            return;\\n        }\\n\\n        for(int i=index;i<s.length();i++){\\n            curr.push_back(s[i]);\\n            if(trie.search(curr))\\n                recurse(i+1,\"\",sentence+\" \"+curr,s);\\n        }\\n    }\\n\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        for(auto& str:wordDict){\\n            trie.insert(str);\\n        }\\n        recurse(0,\"\",\"\",s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666710,
                "title": "5-ms-simple-c-backtracking-solution-with-explanation-easy-to-understand-code",
                "content": "We have to look it as a dfs problem. We loop through our string from left to right and divide it each time. If we have the left substring in the dictionary then we add this string in the curr vector and call recursively for the right substring.\\n```Base case``` if empty string then we loop over our curr vector and form the sentence and return\\n\\nHope this helps. \\n\\n```\\nvector<string> ans;\\n    unordered_set<string> hash;\\n    \\n    void helper(string s, vector<string> &curr){\\n        if(s.length() == 0){\\n            string res;\\n            for(int i=0;i<curr.size(); ++i){\\n                res += curr[i];\\n                if(i != curr.size() - 1) res+= \" \";\\n            }\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int i=1;i<=s.length(); ++i){\\n            string left = s.substr(0, i);\\n            if(hash.count(left)) {\\n                curr.push_back(left);\\n                helper(s.substr(i), curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> curr;\\n        for(auto x: wordDict) hash.insert(x);\\n        helper(s, curr);\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```Base case```\n```\\nvector<string> ans;\\n    unordered_set<string> hash;\\n    \\n    void helper(string s, vector<string> &curr){\\n        if(s.length() == 0){\\n            string res;\\n            for(int i=0;i<curr.size(); ++i){\\n                res += curr[i];\\n                if(i != curr.size() - 1) res+= \" \";\\n            }\\n            ans.push_back(res);\\n            return;\\n        }\\n        \\n        for(int i=1;i<=s.length(); ++i){\\n            string left = s.substr(0, i);\\n            if(hash.count(left)) {\\n                curr.push_back(left);\\n                helper(s.substr(i), curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string> curr;\\n        for(auto x: wordDict) hash.insert(x);\\n        helper(s, curr);\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532818,
                "title": "python-beats-88-37",
                "content": "Super easy solution with naive approach of simply building word character by character and then backtracking if out of bounds\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res, end = [], len(s)\\n        def helper(start, curr):\\n            if start == end:\\n                res.append(\" \".join(curr))\\n                return\\n            tmp = \"\"\\n            for i in range(start, end):\\n                tmp += s[i]\\n                if tmp in wordDict:\\n                    curr.append(tmp)\\n                    helper(i + 1, curr)\\n                    curr.pop()\\n        helper(0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        res, end = [], len(s)\\n        def helper(start, curr):\\n            if start == end:\\n                res.append(\" \".join(curr))\\n                return\\n            tmp = \"\"\\n            for i in range(start, end):\\n                tmp += s[i]\\n                if tmp in wordDict:\\n                    curr.append(tmp)\\n                    helper(i + 1, curr)\\n                    curr.pop()\\n        helper(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437714,
                "title": "python-clean-iterative-dfs-backtracking",
                "content": "### Iterative DFS\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:        \\n        \\n        N = len(s)    \\n        queue, sentences = deque([(0, \\'\\')]), []\\n        while queue:\\n            i, sentence = queue.pop()\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                continue\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word: \\n                    queue.append((index, sentence+\\' \\'+word))\\n        return sentences\\n```    \\n### Backtracking\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n    \\n        def backtrack(i = 0, sentence = \\'\\'):\\n            nonlocal N\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                return\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word and i not in visited:\\n                    visited.add(i)\\n                    backtrack(index, sentence+\\' \\'+word)\\n                    visited.remove(i)\\n            \\n        N = len(s)\\n        sentences, visited = [], set()\\n        backtrack()\\n        return sentences\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:        \\n        \\n        N = len(s)    \\n        queue, sentences = deque([(0, \\'\\')]), []\\n        while queue:\\n            i, sentence = queue.pop()\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                continue\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word: \\n                    queue.append((index, sentence+\\' \\'+word))\\n        return sentences\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n    \\n        def backtrack(i = 0, sentence = \\'\\'):\\n            nonlocal N\\n            if i == N: \\n                sentences.append(sentence[1:])\\n                return\\n            for word in wordDict:\\n                index = i+len(word)\\n                if index <= N and s[i:index] == word and i not in visited:\\n                    visited.add(i)\\n                    backtrack(index, sentence+\\' \\'+word)\\n                    visited.remove(i)\\n            \\n        N = len(s)\\n        sentences, visited = [], set()\\n        backtrack()\\n        return sentences\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400590,
                "title": "c-fastest-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    void solve(string s,unordered_set<string>set,string res,int pos)\\n    {\\n        if(pos==s.size())\\n        {\\n            res.pop_back();\\n            v.push_back(res);\\n            return;\\n        }\\n        for(int i=pos+1;i<=s.size();++i)\\n        {\\n            string ss=s.substr(pos,i-pos);\\n            if(set.find(ss)!=set.end())\\n            {\\n                solve(s,set,res+ss+\\' \\',i);\\n            }\\n        }\\n      \\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set;\\n        for(auto x:wordDict)\\n            set.insert(x);\\n        string res;\\n        solve(s,set,res,0);\\n        return v;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string>v;\\n    void solve(string s,unordered_set<string>set,string res,int pos)\\n    {\\n        if(pos==s.size())\\n        {\\n            res.pop_back();\\n            v.push_back(res);\\n            return;\\n        }\\n        for(int i=pos+1;i<=s.size();++i)\\n        {\\n            string ss=s.substr(pos,i-pos);\\n            if(set.find(ss)!=set.end())\\n            {\\n                solve(s,set,res+ss+\\' \\',i);\\n            }\\n        }\\n      \\n    }\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> set;\\n        for(auto x:wordDict)\\n            set.insert(x);\\n        string res;\\n        solve(s,set,res,0);\\n        return v;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384083,
                "title": "simple-java-backtracking-solution-with-explaination-0ms-100-no-tle",
                "content": "Add all words in WordDict to a hash set for O(1) access.\\n\\nIterate through every character of the string and check if the substring is present in the set. If the substirng is present in the dictionary set, it means the substring could be one of the broken parts of the string. So, add it to the temporary list and then similarly recurse to check more words from next index.\\n\\nThe termination condition will be, if we have reached to the end of string. Then, format the temporary list into the desired space separated string.\\n\\n\\n\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> list = new ArrayList<>();\\n        Set<String> set = new HashSet<>(wordDict);\\n        wordBreak(list, new ArrayList<>(), 0, set,s);\\n        return list;\\n    }\\n    \\n    private void wordBreak(List<String> list, List<String> temp, int index, Set<String> set, String s) {\\n        if(index==s.length()) { //  reached at the end of string\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0; i<temp.size()-1; i++) {\\n                sb.append(temp.get(i)).append(\" \");\\n            }\\n            sb.append(temp.get(temp.size()-1));\\n            list.add(sb.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<s.length(); i++) {\\n            String str = s.substring(index, i+1);\\n            if(!set.contains(str)) continue;\\n            temp.add(str); // add to the temporary list\\n            wordBreak(list, temp, i+1, set,s); // recurse to check every word from next index\\n            temp.remove(temp.size()-1); //backtrack\\n        }\\n    }\\n}\\n```\\n\\n\\nI think TC is 2^n, the string of length has (n+1) ways to be broken into two parts. Then at each step we have two options to further split or not.In worst case, when all choices are made,time complexity will be 2^n.  Feel free to point out if I am misssing anything. \\n\\nI have actually a query, I think it is a brute force approach. Even then why the running time is 0ms and is better than 100% solutions. Am i missing anything?",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> list = new ArrayList<>();\\n        Set<String> set = new HashSet<>(wordDict);\\n        wordBreak(list, new ArrayList<>(), 0, set,s);\\n        return list;\\n    }\\n    \\n    private void wordBreak(List<String> list, List<String> temp, int index, Set<String> set, String s) {\\n        if(index==s.length()) { //  reached at the end of string\\n            StringBuilder sb = new StringBuilder();\\n            for(int i=0; i<temp.size()-1; i++) {\\n                sb.append(temp.get(i)).append(\" \");\\n            }\\n            sb.append(temp.get(temp.size()-1));\\n            list.add(sb.toString());\\n            return;\\n        }\\n        \\n        for(int i=index; i<s.length(); i++) {\\n            String str = s.substring(index, i+1);\\n            if(!set.contains(str)) continue;\\n            temp.add(str); // add to the temporary list\\n            wordBreak(list, temp, i+1, set,s); // recurse to check every word from next index\\n            temp.remove(temp.size()-1); //backtrack\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340887,
                "title": "java-trie",
                "content": "```\\nclass Solution {\\n    class Trie{\\n        Trie children[] = new Trie[26];\\n        boolean isEndOfWord;\\n        public Trie(){\\n            for(int i=0;i<26;i++)\\n                children[i] = null;\\n            isEndOfWord = false;\\n        }\\n    }\\n    public void addWord(Trie root,String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                node.children[ch] = new Trie();\\n            node = node.children[ch];\\n        }\\n        node.isEndOfWord = true;\\n    }\\n    public boolean search(Trie root, String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                return false;\\n            node = node.children[ch];\\n        }\\n        return node.isEndOfWord;\\n    }\\n    \\n    List<String> list;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Trie root = new Trie();\\n        for(String st:wordDict){\\n            addWord(root,st);\\n        }\\n        list = new ArrayList();\\n        findRemainingSubString(root,\"\",s,s.length());\\n        return list;\\n    }\\n    public boolean findRemainingSubString(Trie root,String str,String s,int total){\\n        if(s==null || s.length()==0)\\n            return true;\\n        for(int i=0;i<=s.length();i++){\\n            String st = str;\\n            if(search(root,s.substring(0,i))){\\n                st = st + s.substring(0,i)+ \" \";\\n                if(!findRemainingSubString(root,st,s.substring(i),total+1))\\n                    return false;\\n                if(st.trim().length()==total)\\n                    list.add(st.trim());\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    class Trie{\\n        Trie children[] = new Trie[26];\\n        boolean isEndOfWord;\\n        public Trie(){\\n            for(int i=0;i<26;i++)\\n                children[i] = null;\\n            isEndOfWord = false;\\n        }\\n    }\\n    public void addWord(Trie root,String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                node.children[ch] = new Trie();\\n            node = node.children[ch];\\n        }\\n        node.isEndOfWord = true;\\n    }\\n    public boolean search(Trie root, String s){\\n        Trie node = root;\\n        for(int i=0;i<s.length();i++){\\n            int ch = s.charAt(i) - \\'a\\';\\n            if(node.children[ch]==null)\\n                return false;\\n            node = node.children[ch];\\n        }\\n        return node.isEndOfWord;\\n    }\\n    \\n    List<String> list;\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        Trie root = new Trie();\\n        for(String st:wordDict){\\n            addWord(root,st);\\n        }\\n        list = new ArrayList();\\n        findRemainingSubString(root,\"\",s,s.length());\\n        return list;\\n    }\\n    public boolean findRemainingSubString(Trie root,String str,String s,int total){\\n        if(s==null || s.length()==0)\\n            return true;\\n        for(int i=0;i<=s.length();i++){\\n            String st = str;\\n            if(search(root,s.substring(0,i))){\\n                st = st + s.substring(0,i)+ \" \";\\n                if(!findRemainingSubString(root,st,s.substring(i),total+1))\\n                    return false;\\n                if(st.trim().length()==total)\\n                    list.add(st.trim());\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163512,
                "title": "backtracking-javascript",
                "content": "```\\nvar wordBreak = function(s, wordDict) {\\n    /*\\n        1) create a hashmap and store words of dict by first\\n        letter\\n        2) iterate though the given string and if we found\\n        start letter in hashmap, we will get all the words in it\\n        and try to create a sentance starting from each of them\\n        3) for example, if we got c: [cat, cats] -> we take cat\\n        and see if this is a substring of the string, if it is,\\n        call recursion on the rest of the string, now the first letter is\\n        s -> check if we have any words starting from s\\n        4) add the path to an array and if the str is empty add to res and rturn\\n    */\\n    let dict = new Map();\\n    for (let word of wordDict) {\\n        if (!dict.has(word[0])) dict.set(word[0], []);\\n        dict.get(word[0]).push(word);\\n    }\\n    \\n    let sentences = [];\\n    function recurse(sentence, string) {\\n        if (string === \\'\\') {\\n            sentences.push(sentence.join(\\' \\'));\\n            return;\\n        }\\n        if (dict.has(string[0])) {\\n            let words = dict.get(string[0]);\\n            for (let word of words) {\\n                let len = word.length;\\n                let substring = string.substring(0, len);\\n                if (substring === word) {\\n                         sentence.push(word);\\n                         recurse([...sentence], string.substring(len));\\n                         sentence.pop();\\n                }\\n            }\\n        }\\n    }\\n    \\n    recurse([], s);\\n    return sentences;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar wordBreak = function(s, wordDict) {\\n    /*\\n        1) create a hashmap and store words of dict by first\\n        letter\\n        2) iterate though the given string and if we found\\n        start letter in hashmap, we will get all the words in it\\n        and try to create a sentance starting from each of them\\n        3) for example, if we got c: [cat, cats] -> we take cat\\n        and see if this is a substring of the string, if it is,\\n        call recursion on the rest of the string, now the first letter is\\n        s -> check if we have any words starting from s\\n        4) add the path to an array and if the str is empty add to res and rturn\\n    */\\n    let dict = new Map();\\n    for (let word of wordDict) {\\n        if (!dict.has(word[0])) dict.set(word[0], []);\\n        dict.get(word[0]).push(word);\\n    }\\n    \\n    let sentences = [];\\n    function recurse(sentence, string) {\\n        if (string === \\'\\') {\\n            sentences.push(sentence.join(\\' \\'));\\n            return;\\n        }\\n        if (dict.has(string[0])) {\\n            let words = dict.get(string[0]);\\n            for (let word of words) {\\n                let len = word.length;\\n                let substring = string.substring(0, len);\\n                if (substring === word) {\\n                         sentence.push(word);\\n                         recurse([...sentence], string.substring(len));\\n                         sentence.pop();\\n                }\\n            }\\n        }\\n    }\\n    \\n    recurse([], s);\\n    return sentences;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158796,
                "title": "my-concise-java-solution-memorized-dfs-backtracking-easy-to-understand",
                "content": "- iterate all the words in the wordDict, find if the prefix of the current string matches a word in the dictionary\\n- current string = prefix + suffix\\n- if true, we do the same operation to the suffix, and find its list of word break ==> **sublist**\\n- return the final list of word break of the original string by concating **prefix + sublist**\\n\\nThe time complexity is O(len(wordDict) ^ len(s / minWordLenInDict)) \\n\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        // dfs with memorization\\n        return dfs(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> dfs(String s, List<String> wordDict, HashMap<String, List<String>> memo) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                List<String> sublist = dfs(s.substring(word.length()), wordDict, memo);\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: sublist) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }            \\n            }\\n        } \\n        memo.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        // dfs with memorization\\n        return dfs(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> dfs(String s, List<String> wordDict, HashMap<String, List<String>> memo) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                List<String> sublist = dfs(s.substring(word.length()), wordDict, memo);\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: sublist) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }            \\n            }\\n        } \\n        memo.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984991,
                "title": "my-java-solution-backtracking-6ms",
                "content": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return backtrack(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> backtrack(String s, List<String> wordDict, HashMap<String, List<String>> mem) {\\n        if (mem.containsKey(s)) {\\n            return mem.get(s);\\n        }\\n        \\n        List<String> res = new ArrayList<String>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: backtrack(next, wordDict, mem)) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        mem.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return backtrack(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n    \\n    private List<String> backtrack(String s, List<String> wordDict, HashMap<String, List<String>> mem) {\\n        if (mem.containsKey(s)) {\\n            return mem.get(s);\\n        }\\n        \\n        List<String> res = new ArrayList<String>();\\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                String next = s.substring(word.length());\\n                if (next.isEmpty()) res.add(word);\\n                else {\\n                    for(String sub: backtrack(next, wordDict, mem)) {\\n                        res.add(word + \" \" + sub);\\n                    }\\n                }\\n            }\\n        }\\n        mem.put(s, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 964708,
                "title": "java-simple-line-by-line-explanation-extra-optimization-over-cache-5ms",
                "content": "```\\nclass Solution {\\n    \\n    // initialize cache - given a string -> holds possible combinations of valid sentences with spaces\\n    Map < String, List < String >> cache = new HashMap < > ();\\n    \\n    public List < String > wordBreak(String s, List < String > wordDict) {\\n        int maxLen = 0;\\n        \\n        // initialize dictionary in hashset (!remember lookup in list is O(n) not O(1))\\n        Set < String > dict = new HashSet < > (wordDict);\\n        \\n        // optimization - find the largest word length in dictionary\\n        for (String word: wordDict) {\\n            maxLen = Math.max(word.length(), maxLen);\\n        }\\n\\n        return findValidSentences(s, dict, maxLen);\\n    }\\n\\n    public List < String > findValidSentences(String s, Set < String > dict, int maxLen) {\\n        \\n        // if cache already has possibilities with the string return list\\n        if (cache.containsKey(s)) {\\n            return cache.get(s);\\n        }\\n        \\n        // else build\\n        List < String > result = new ArrayList < > ();\\n        \\n        // if string itself a valid word add - helps avoiding extra space for last iteration like \"cats and dogs \" - notice extra space at end\\n        if (dict.contains(s)) {\\n            result.add(s);\\n        }\\n        \\n        /* find from len 1 till n-1 length (full word already added)\\n        \\n           break word = left + right parts\\n           \\n           notice in for loop below: we are only checking for left part to a max of maxLen in dictionary since\\n           \\n           if dict = [car,rabbit,bus]\\n           \\n           word = rabbitcarbus\\n           \\n           word = [rabbit]carbus - iterating window limited to maxLen\\n           \\n           iterating beyond this is useless, since maximum length word that can be formed is rabbit in dict,\\n           there cant be a word greater than longest word in dictionary - doubles the overall performance as input scales\\n      \\n        */\\n\\t\\t\\n        for (int i = 1; i <= maxLen && i < s.length(); i++) {\\n            \\n            // find left part\\n            String left = s.substring(0, i);\\n            \\n            // if left already in dictionary - find combinations with right part\\n            if (dict.contains(left)) {\\n                \\n                // find all possible valid combinations with right part\\n                List < String > rightSentences = findValidSentences(s.substring(i, s.length()), dict, maxLen);\\n\\n                // combine both left + right = valid sentence combinations for give String s\\n                for (String right: rightSentences) {\\n                    result.add(left + \" \" + right);\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        // cache it for repeated usage\\n        cache.put(s, result);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // initialize cache - given a string -> holds possible combinations of valid sentences with spaces\\n    Map < String, List < String >> cache = new HashMap < > ();\\n    \\n    public List < String > wordBreak(String s, List < String > wordDict) {\\n        int maxLen = 0;\\n        \\n        // initialize dictionary in hashset (!remember lookup in list is O(n) not O(1))\\n        Set < String > dict = new HashSet < > (wordDict);\\n        \\n        // optimization - find the largest word length in dictionary\\n        for (String word: wordDict) {\\n            maxLen = Math.max(word.length(), maxLen);\\n        }\\n\\n        return findValidSentences(s, dict, maxLen);\\n    }\\n\\n    public List < String > findValidSentences(String s, Set < String > dict, int maxLen) {\\n        \\n        // if cache already has possibilities with the string return list\\n        if (cache.containsKey(s)) {\\n            return cache.get(s);\\n        }\\n        \\n        // else build\\n        List < String > result = new ArrayList < > ();\\n        \\n        // if string itself a valid word add - helps avoiding extra space for last iteration like \"cats and dogs \" - notice extra space at end\\n        if (dict.contains(s)) {\\n            result.add(s);\\n        }\\n        \\n        /* find from len 1 till n-1 length (full word already added)\\n        \\n           break word = left + right parts\\n           \\n           notice in for loop below: we are only checking for left part to a max of maxLen in dictionary since\\n           \\n           if dict = [car,rabbit,bus]\\n           \\n           word = rabbitcarbus\\n           \\n           word = [rabbit]carbus - iterating window limited to maxLen\\n           \\n           iterating beyond this is useless, since maximum length word that can be formed is rabbit in dict,\\n           there cant be a word greater than longest word in dictionary - doubles the overall performance as input scales\\n      \\n        */\\n\\t\\t\\n        for (int i = 1; i <= maxLen && i < s.length(); i++) {\\n            \\n            // find left part\\n            String left = s.substring(0, i);\\n            \\n            // if left already in dictionary - find combinations with right part\\n            if (dict.contains(left)) {\\n                \\n                // find all possible valid combinations with right part\\n                List < String > rightSentences = findValidSentences(s.substring(i, s.length()), dict, maxLen);\\n\\n                // combine both left + right = valid sentence combinations for give String s\\n                for (String right: rightSentences) {\\n                    result.add(left + \" \" + right);\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        // cache it for repeated usage\\n        cache.put(s, result);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906710,
                "title": "4-ms-c-1-d-dp-solution-easy-approach",
                "content": "* Store dictionary words in set for quick access\\n* Helper function solves for the subproblems of the main problem\\n* vdp array to check if the dp value is available or not\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_set<string> dict;\\n    int n;\\n    string str;\\n    \\n    vector<string> helper(int i, vector<vector<string>> &dp, bool vdp[])\\n    {\\n        vector<string> tv;\\n        if(i==n)\\n        {\\n            return tv;\\n        }\\n        if(vdp[i])\\n        {\\n            return dp[i];\\n        }\\n        string ts = \"\";\\n        for(int k = i; k<n; k++)\\n        {\\n            ts+=str[k];\\n            if(dict.find(ts) == dict.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                \\n                if(k+1==n)\\n                {\\n                    tv.push_back(ts);\\n                    continue;\\n                }\\n                vector<string> hv = helper(k+1, dp, vdp);\\n                for(int x = 0; x<hv.size(); x++)\\n                {\\n                    tv.push_back(ts+\" \"+hv[x]);\\n                }\\n            }\\n        }\\n        dp[i] = tv;\\n        vdp[i] = 1;\\n        return tv;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        n = s.length();\\n        str = s;\\n        for(int i =0; i<wordDict.size(); i++)\\n        {\\n            dict.insert(wordDict[i]);\\n        }\\n        vector<vector<string>> dp(n);\\n        bool vdp[n];\\n        memset(vdp,0,sizeof(vdp));\\n        return helper(0,dp,vdp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<string> dict;\\n    int n;\\n    string str;\\n    \\n    vector<string> helper(int i, vector<vector<string>> &dp, bool vdp[])\\n    {\\n        vector<string> tv;\\n        if(i==n)\\n        {\\n            return tv;\\n        }\\n        if(vdp[i])\\n        {\\n            return dp[i];\\n        }\\n        string ts = \"\";\\n        for(int k = i; k<n; k++)\\n        {\\n            ts+=str[k];\\n            if(dict.find(ts) == dict.end())\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                \\n                if(k+1==n)\\n                {\\n                    tv.push_back(ts);\\n                    continue;\\n                }\\n                vector<string> hv = helper(k+1, dp, vdp);\\n                for(int x = 0; x<hv.size(); x++)\\n                {\\n                    tv.push_back(ts+\" \"+hv[x]);\\n                }\\n            }\\n        }\\n        dp[i] = tv;\\n        vdp[i] = 1;\\n        return tv;\\n    }\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        n = s.length();\\n        str = s;\\n        for(int i =0; i<wordDict.size(); i++)\\n        {\\n            dict.insert(wordDict[i]);\\n        }\\n        vector<vector<string>> dp(n);\\n        bool vdp[n];\\n        memset(vdp,0,sizeof(vdp));\\n        return helper(0,dp,vdp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780244,
                "title": "top-down-very-clean-memo-code-java",
                "content": "```\\nclass Solution { //TOP DOWN, VERY CLEAN MEMO CODE\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution { //TOP DOWN, VERY CLEAN MEMO CODE\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769290,
                "title": "go-0-ms-dp-solution-beats-100-time",
                "content": "```\\nfunc wordBreak(s string, wordDict []string) []string {\\n    dp := make(map[string][]string)    \\n    set := make(map[string]bool)\\n    for _, v := range wordDict {\\n        set[v] = true\\n    }\\n    return generate(s, dp, set)\\n}\\n\\nfunc generate(s string, dp map[string][]string, set map[string]bool) []string{\\n    \\n    if val , ok := dp[s]; ok {\\n        return val\\n    }\\n    \\n    var output []string\\n    \\n    if len(s) == 0 {\\n        output = append(output, \"\")\\n        return output\\n    }\\n    \\n    var prefix string\\n    \\n    for i := 0; i < len(s); i++ {\\n        prefix += string(s[i])\\n        \\n        if _, ok := set[prefix]; ok {        \\n            var smallOutput []string = generate(s[i + 1 : ], dp, set)\\n            for _, val := range smallOutput {\\n                if len(val) > 0 {\\n                    output = append(output, prefix + \" \" + val)   \\n                }else {\\n                    output = append(output, prefix)\\n                }\\n            }\\n        }\\n    }\\n    \\n    dp[s] = output\\n    return output\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc wordBreak(s string, wordDict []string) []string {\\n    dp := make(map[string][]string)    \\n    set := make(map[string]bool)\\n    for _, v := range wordDict {\\n        set[v] = true\\n    }\\n    return generate(s, dp, set)\\n}\\n\\nfunc generate(s string, dp map[string][]string, set map[string]bool) []string{\\n    \\n    if val , ok := dp[s]; ok {\\n        return val\\n    }\\n    \\n    var output []string\\n    \\n    if len(s) == 0 {\\n        output = append(output, \"\")\\n        return output\\n    }\\n    \\n    var prefix string\\n    \\n    for i := 0; i < len(s); i++ {\\n        prefix += string(s[i])\\n        \\n        if _, ok := set[prefix]; ok {        \\n            var smallOutput []string = generate(s[i + 1 : ], dp, set)\\n            for _, val := range smallOutput {\\n                if len(val) > 0 {\\n                    output = append(output, prefix + \" \" + val)   \\n                }else {\\n                    output = append(output, prefix)\\n                }\\n            }\\n        }\\n    }\\n    \\n    dp[s] = output\\n    return output\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764419,
                "title": "java-recursive-memoized-solution-w-video-explanation",
                "content": "https://www.youtube.com/watch?v=9-grHHGUVls\\n```\\nclass Solution {\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, List<String>> memo = new HashMap<>();\\n    \\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        if (memo.containsKey(s)) return memo.get(s);\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String word : wordDict) {\\n            if (s.startsWith(word)) {\\n                if (s.length() == word.length())\\n                    res.add(word);\\n                else {\\n                    List<String> sub = wordBreak(s.substring(word.length()), wordDict);\\n                    for (String w : sub)\\n                        res.add(word + \" \" + w);\\n                }\\n            }\\n        }\\n        \\n        memo.put(s, res);\\n        return memo.get(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764113,
                "title": "kotlin-concise-solution",
                "content": "```\\nclass Solution {\\n\\n    fun wordBreak(s: String, wordDict: List<String>): List<String> {\\n        return buildWord(s, wordDict, hashMapOf())\\n    }\\n\\n    private fun buildWord(\\n        text: String,\\n        wordDict: List<String>,\\n        map: HashMap<String, LinkedList<String>>\\n    ): List<String> {\\n        if (map.containsKey(text)) return map[text]!!\\n\\n        val result = LinkedList<String>()\\n        if (text.isEmpty()) return result.apply { add(\"\") }\\n\\n        for (word in wordDict) {\\n            if (text.startsWith(word)) {\\n                buildWord(text.substring(word.length), wordDict, map)\\n                    .forEach { subWord -> result.add(\"$word${if (subWord.isEmpty()) \"\" else \" \"}$subWord\") }\\n            }\\n        }\\n\\n        map[text] = result\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    fun wordBreak(s: String, wordDict: List<String>): List<String> {\\n        return buildWord(s, wordDict, hashMapOf())\\n    }\\n\\n    private fun buildWord(\\n        text: String,\\n        wordDict: List<String>,\\n        map: HashMap<String, LinkedList<String>>\\n    ): List<String> {\\n        if (map.containsKey(text)) return map[text]!!\\n\\n        val result = LinkedList<String>()\\n        if (text.isEmpty()) return result.apply { add(\"\") }\\n\\n        for (word in wordDict) {\\n            if (text.startsWith(word)) {\\n                buildWord(text.substring(word.length), wordDict, map)\\n                    .forEach { subWord -> result.add(\"$word${if (subWord.isEmpty()) \"\" else \" \"}$subWord\") }\\n            }\\n        }\\n\\n        map[text] = result\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763711,
                "title": "java-backtrackig-memoization",
                "content": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n    \\n        Set<String> dict = new HashSet<>(wordDict);\\n        Map<String,List<String>> memo = new HashMap<>();\\n          \\n       return helper(dict, s , memo);\\n    }\\n    \\n    \\n    private List<String> helper(Set<String> dict , String s , Map<String,List<String>> memo){\\n        \\n        if(memo.containsKey(s))\\n            return memo.get(s);\\n         \\n        List<String> ans = new ArrayList<>();\\n        \\n        if(s == null || s.isEmpty()){\\n            return ans;\\n          }\\n  \\n        int N = s.length();    \\n      \\n        for(String word : dict){\\n         \\n            if(!s.startsWith(word)){\\n               continue;\\n            } \\n            int len = word.length();\\n           if(N == len){\\n               ans.add(word);\\n           }else{\\n               List<String> res = helper(dict , s.substring(len),memo );\\n               for(String str : res){\\n                   ans.add( word + \" \" + str);\\n               }\\n           }\\n        }\\n        memo.put(s,ans);\\n      return ans;  \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n    \\n        Set<String> dict = new HashSet<>(wordDict);\\n        Map<String,List<String>> memo = new HashMap<>();\\n          \\n       return helper(dict, s , memo);\\n    }\\n    \\n    \\n    private List<String> helper(Set<String> dict , String s , Map<String,List<String>> memo){\\n        \\n        if(memo.containsKey(s))\\n            return memo.get(s);\\n         \\n        List<String> ans = new ArrayList<>();\\n        \\n        if(s == null || s.isEmpty()){\\n            return ans;\\n          }\\n  \\n        int N = s.length();    \\n      \\n        for(String word : dict){\\n         \\n            if(!s.startsWith(word)){\\n               continue;\\n            } \\n            int len = word.length();\\n           if(N == len){\\n               ans.add(word);\\n           }else{\\n               List<String> res = helper(dict , s.substring(len),memo );\\n               for(String str : res){\\n                   ans.add( word + \" \" + str);\\n               }\\n           }\\n        }\\n        memo.put(s,ans);\\n      return ans;  \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763410,
                "title": "java-80-fast-explained-code",
                "content": "If you found the solution helpful, kindly like and upvote. :)\\n\\n**MAIN IDEA**\\n1. Take the words from the dictionary, and check if the target String starts with that.\\n2. If it does, we will generate all the valid substrings, and simply add that to our result.\\n\\n```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return wordHelper(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n\\n\\tprivate List<String> wordHelper(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n\\t\\tif(cache.containsKey(s))\\n\\t\\t\\treturn cache.get(s);\\n\\t\\tList<String> res= new ArrayList<String>();\\n\\t\\tif(s.length()==0) \\n\\t\\t{\\n\\t\\t\\tres.add(\"\");\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tfor(String word:wordDict)\\n\\t\\t{\\n\\t\\t\\t//Check if the word starts with the dictionary word\\n\\t\\t\\tif(s.startsWith(word))\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Now we need to find all the subsets of in the String from the dict\\n\\t\\t\\t\\t//and add them to a List\\n\\t\\t\\t\\tList<String> subStr= wordHelper(s.substring(word.length()), wordDict, cache);\\n\\t\\t\\t\\t//Now we have all the subsets, we will now start making our results\\n\\t\\t\\t\\tfor(String subs: subStr)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString space= subs.isEmpty()? \"\":\" \";\\n\\t\\t\\t\\t\\tres.add(word+space+subs);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcache.put(s, res);\\n\\t\\treturn res;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> wordBreak(String s, List<String> wordDict) {\\n        return wordHelper(s, wordDict, new HashMap<String, List<String>>());\\n    }\\n\\n\\tprivate List<String> wordHelper(String s, List<String> wordDict, Map<String, List<String>> cache) {\\n\\t\\tif(cache.containsKey(s))\\n\\t\\t\\treturn cache.get(s);\\n\\t\\tList<String> res= new ArrayList<String>();\\n\\t\\tif(s.length()==0) \\n\\t\\t{\\n\\t\\t\\tres.add(\"\");\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\tfor(String word:wordDict)\\n\\t\\t{\\n\\t\\t\\t//Check if the word starts with the dictionary word\\n\\t\\t\\tif(s.startsWith(word))\\n\\t\\t\\t{\\n\\t\\t\\t\\t//Now we need to find all the subsets of in the String from the dict\\n\\t\\t\\t\\t//and add them to a List\\n\\t\\t\\t\\tList<String> subStr= wordHelper(s.substring(word.length()), wordDict, cache);\\n\\t\\t\\t\\t//Now we have all the subsets, we will now start making our results\\n\\t\\t\\t\\tfor(String subs: subStr)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tString space= subs.isEmpty()? \"\":\" \";\\n\\t\\t\\t\\t\\tres.add(word+space+subs);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcache.put(s, res);\\n\\t\\treturn res;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763317,
                "title": "word-break-2-c-solution-with-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<string>> word_map;\\n    vector<vector<string>> dp;\\n    vector<bool> visited;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n = s.length();\\n        word_map = vector<vector<string>> (n);\\n        dp = vector<vector<string>>(n);\\n        visited = vector<bool>(n, false);\\n        \\n        populate_word_map(s, wordDict);\\n        create_sentences(0);\\n        \\n        return dp[0];\\n    }\\n    \\n    void populate_word_map(const string& s, vector<string>& wordDict) {\\n        int pos, l;\\n        for (auto& word : wordDict) {\\n            pos = 0;\\n            l = word.length();\\n            while ((pos = s.find(word, pos)) != string::npos) {\\n                word_map[pos].push_back(word);\\n                pos ++;\\n            }\\n        }\\n    }\\n    \\n    void create_sentences(int pos) {\\n        for (auto& word : word_map[pos]) {\\n            int new_pos = pos + word.length();\\n            \\n            if (new_pos == n) {\\n                dp[pos].push_back(word);\\n            } else {\\n                if (!visited[new_pos])\\n                    create_sentences(new_pos);\\n                for (auto& sentence : dp[new_pos])\\n                    dp[pos].push_back(word + \" \" + sentence);\\n            }\\n        }\\n        \\n        visited[pos] = true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<string>> word_map;\\n    vector<vector<string>> dp;\\n    vector<bool> visited;\\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        n = s.length();\\n        word_map = vector<vector<string>> (n);\\n        dp = vector<vector<string>>(n);\\n        visited = vector<bool>(n, false);\\n        \\n        populate_word_map(s, wordDict);\\n        create_sentences(0);\\n        \\n        return dp[0];\\n    }\\n    \\n    void populate_word_map(const string& s, vector<string>& wordDict) {\\n        int pos, l;\\n        for (auto& word : wordDict) {\\n            pos = 0;\\n            l = word.length();\\n            while ((pos = s.find(word, pos)) != string::npos) {\\n                word_map[pos].push_back(word);\\n                pos ++;\\n            }\\n        }\\n    }\\n    \\n    void create_sentences(int pos) {\\n        for (auto& word : word_map[pos]) {\\n            int new_pos = pos + word.length();\\n            \\n            if (new_pos == n) {\\n                dp[pos].push_back(word);\\n            } else {\\n                if (!visited[new_pos])\\n                    create_sentences(new_pos);\\n                for (auto& sentence : dp[new_pos])\\n                    dp[pos].push_back(word + \" \" + sentence);\\n            }\\n        }\\n        \\n        visited[pos] = true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763276,
                "title": "c-dfs-with-cache",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       \\tunordered_set<string> dict;\\n       \\tfor (auto w : wordDict) {\\n       \\t\\tdict.insert(w);\\n       \\t}\\n\\n       \\tvector<string> sentences;\\n       \\tunordered_map<int, vector<string>> cache;\\n       \\tdfs(s, 0, dict, sentences, cache);\\n       \\treturn sentences;\\n    }\\n\\n    void dfs(string &s, int idx, unordered_set<string> &dict, vector<string> &sentences, unordered_map<int, vector<string>> &cache) {\\n    \\tint n = s.length();\\n    \\tif (n == idx) {\\n    \\t\\tsentences.push_back(\"\");\\n    \\t\\treturn;\\n    \\t}\\n\\n    \\tstring word;\\n    \\tfor (int i = idx; i < n; ++i) {\\n    \\t\\tword.push_back(s[i]);\\n    \\t\\tif (dict.count(word)) {\\n    \\t\\t\\tvector<string> sents;\\n                if (cache.count(i + 1)) {\\n                    sents = cache[i + 1];\\n                } else {\\n    \\t\\t\\t    dfs(s, i + 1, dict, sents, cache);\\n                    cache[i + 1] = sents;\\n                }\\n    \\t\\t\\tfor (auto s : sents) {\\n    \\t\\t\\t\\tsentences.push_back(word);\\n    \\t\\t\\t\\tif (!s.empty()) {\\n    \\t\\t\\t\\t\\tsentences.back() += \" \" + s;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n       \\tunordered_set<string> dict;\\n       \\tfor (auto w : wordDict) {\\n       \\t\\tdict.insert(w);\\n       \\t}\\n\\n       \\tvector<string> sentences;\\n       \\tunordered_map<int, vector<string>> cache;\\n       \\tdfs(s, 0, dict, sentences, cache);\\n       \\treturn sentences;\\n    }\\n\\n    void dfs(string &s, int idx, unordered_set<string> &dict, vector<string> &sentences, unordered_map<int, vector<string>> &cache) {\\n    \\tint n = s.length();\\n    \\tif (n == idx) {\\n    \\t\\tsentences.push_back(\"\");\\n    \\t\\treturn;\\n    \\t}\\n\\n    \\tstring word;\\n    \\tfor (int i = idx; i < n; ++i) {\\n    \\t\\tword.push_back(s[i]);\\n    \\t\\tif (dict.count(word)) {\\n    \\t\\t\\tvector<string> sents;\\n                if (cache.count(i + 1)) {\\n                    sents = cache[i + 1];\\n                } else {\\n    \\t\\t\\t    dfs(s, i + 1, dict, sents, cache);\\n                    cache[i + 1] = sents;\\n                }\\n    \\t\\t\\tfor (auto s : sents) {\\n    \\t\\t\\t\\tsentences.push_back(word);\\n    \\t\\t\\t\\tif (!s.empty()) {\\n    \\t\\t\\t\\t\\tsentences.back() += \" \" + s;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706993,
                "title": "python3-top-down-dp",
                "content": "Algo: \\nDefine `fn(i)` to be the sentences formed by `s[i:]`. Then, the recursion satisfies \\n\\n`fn(i) = [[word] + x for x in fn(i + len(word)] for word in wordDict if s[i:].startswith(word)` \\n\\n(56ms, 38.79%)\\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        wordDict = set(wordDict) #edit: better performance \\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences of s[i:]\"\"\"\\n            if i == len(s): return [[]]\\n            ans = []\\n            for ii in range(i+1, len(s)+1):\\n                if s[i:ii] in wordDict: \\n                    ans.extend([s[i:ii]] + x for x in fn(ii))\\n            return ans \\n        \\n        return [\" \".join(x) for x in fn(0)]\\n```\\n\\nAlternatively one could go forward path (40ms, 84.72%) like below \\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences from s[:i]\"\"\"\\n            if i == 0: return [[]] #boundary condition \\n            ans = []\\n            for word in wordDict: \\n                if s[i-len(word):i] == word:\\n                    ans.extend([x + [word] for x in fn(i-len(word))])\\n            return ans \\n            \\n        return [\" \".join(x) for x in fn(len(s))]\\n```\\n\\nThe bottom-up implementation is very easy to go TLE. The reason is that it doesn\\'t a lot of unnecessary calculations while top-down only does what\\'s required.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        wordDict = set(wordDict) #edit: better performance \\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences of s[i:]\"\"\"\\n            if i == len(s): return [[]]\\n            ans = []\\n            for ii in range(i+1, len(s)+1):\\n                if s[i:ii] in wordDict: \\n                    ans.extend([s[i:ii]] + x for x in fn(ii))\\n            return ans \\n        \\n        return [\" \".join(x) for x in fn(0)]\\n```\n```\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return sentences from s[:i]\"\"\"\\n            if i == 0: return [[]] #boundary condition \\n            ans = []\\n            for word in wordDict: \\n                if s[i-len(word):i] == word:\\n                    ans.extend([x + [word] for x in fn(i-len(word))])\\n            return ans \\n            \\n        return [\" \".join(x) for x in fn(len(s))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670116,
                "title": "java-backtrack-solusion-with-detail-comments-and-thoughts-step-by-step",
                "content": "This is kind of  a String-Problem. So the idea first come up to my mind is BackTrack!!\\nBackTrack is an useful method to traverse all the combinations of string-like brute force. \\nAlso the solusion is really easy to come up with!\\n\\n```\\n public List<String> wordBreak1(String s, List<String> wordDict) {     \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n        if(n<=0) return res; \\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        backTrack1(res,\"\",s,dic,0);\\n        \\n        return res;\\n    }\\n    //TLE \\n    void backTrack1(List<String> res, String path, String s, Set<String> dic, int idx ){\\n        if(idx==s.length()){\\n            res.add(path);\\n            return;\\n        }\\n        for(int i=idx;i<s.length();i++){\\n            String cur=s.substring(idx,i+1);\\n            if(dic.contains(cur)){\\n                if(idx==0)  backTrack1(res, cur,s,dic,i+1);\\n                else backTrack1(res, path+\" \"+ cur,s,dic,i+1);\\n            }\\n        }   \\n    }\\n```\\nThis solusion works correctly! But, in some extremely conditions, it will TLE. \\nWe know the Time Complexity of BackTrack algorithm is **expotional**( O(N^M) N is the longth of string).\\n\\nNext step is to improve our solution. \\nLets see the parameters of the method, everytime we use a string to concatenate with other string.\\nSo we can use StringBuilder to replace it. However, only change this, still TLE.\\n\\nNext, we thought to use some extra memory to improve the running time. It not difficult to come up with the strategy-- **Space exchange Time**!\\n\\nThat is why I thought to use a HashMap to store all the sub-problem results. Each time we get the sub-result only use O(1) time.  Here is the code!\\n\\n```\\n  public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n\\t\\t//This is the conner case\\n        if(n<=0) return res;\\n        \\n\\t\\t//change the List to the Set, becasue we always want to check with it.\\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        res =backTrack(s,dic);\\n        \\n        return res;\\n    }\\n\\t\\n    //Using hashMap to store the sub-problem results\\n    HashMap<String,List<String>> map = new HashMap<>();\\n    \\n    List<String> backTrack(String s, Set<String> dic){\\n       \\n        List<String> res  = new ArrayList<>();\\n\\t\\t//this is the conner case\\n        if(s.length()<=0){\\n            res.add(\"\");\\n            return res;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\t//we get cur split string\\n            String cur=s.substring(0,i+1);\\n            \\n            if(dic.contains(cur)){  \\n                \\n                String next=s.substring(i+1);\\n                List<String> subans =new ArrayList<>();\\n\\t\\t\\t\\t//here our map used\\n                if(map.containsKey(next)){\\n                    subans=map.get(next);\\n                }else{\\n                    subans = backTrack(next,dic);\\n                } \\n\\t\\t\\t\\t//combine the total answer\\n                for(String str:subans){            \\n                    if(str.equals(\"\")) res.add(cur);\\n                    else res.add(cur+\" \"+str);\\n                }\\n            }\\n        }\\n\\t\\t//add this level result to the map\\n        map.put(s,res);\\n        return res;  \\n   }\\n```\\nIf you like my idea, please vote it!!",
                "solutionTags": [],
                "code": "```\\n public List<String> wordBreak1(String s, List<String> wordDict) {     \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n        if(n<=0) return res; \\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        backTrack1(res,\"\",s,dic,0);\\n        \\n        return res;\\n    }\\n    //TLE \\n    void backTrack1(List<String> res, String path, String s, Set<String> dic, int idx ){\\n        if(idx==s.length()){\\n            res.add(path);\\n            return;\\n        }\\n        for(int i=idx;i<s.length();i++){\\n            String cur=s.substring(idx,i+1);\\n            if(dic.contains(cur)){\\n                if(idx==0)  backTrack1(res, cur,s,dic,i+1);\\n                else backTrack1(res, path+\" \"+ cur,s,dic,i+1);\\n            }\\n        }   \\n    }\\n```\n```\\n  public List<String> wordBreak(String s, List<String> wordDict) {\\n        \\n        List<String> res = new ArrayList<>();\\n        int n=s.length();\\n\\t\\t//This is the conner case\\n        if(n<=0) return res;\\n        \\n\\t\\t//change the List to the Set, becasue we always want to check with it.\\n        Set<String> dic = new HashSet<>(wordDict);\\n        \\n        res =backTrack(s,dic);\\n        \\n        return res;\\n    }\\n\\t\\n    //Using hashMap to store the sub-problem results\\n    HashMap<String,List<String>> map = new HashMap<>();\\n    \\n    List<String> backTrack(String s, Set<String> dic){\\n       \\n        List<String> res  = new ArrayList<>();\\n\\t\\t//this is the conner case\\n        if(s.length()<=0){\\n            res.add(\"\");\\n            return res;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n\\t\\t\\t//we get cur split string\\n            String cur=s.substring(0,i+1);\\n            \\n            if(dic.contains(cur)){  \\n                \\n                String next=s.substring(i+1);\\n                List<String> subans =new ArrayList<>();\\n\\t\\t\\t\\t//here our map used\\n                if(map.containsKey(next)){\\n                    subans=map.get(next);\\n                }else{\\n                    subans = backTrack(next,dic);\\n                } \\n\\t\\t\\t\\t//combine the total answer\\n                for(String str:subans){            \\n                    if(str.equals(\"\")) res.add(cur);\\n                    else res.add(cur+\" \"+str);\\n                }\\n            }\\n        }\\n\\t\\t//add this level result to the map\\n        map.put(s,res);\\n        return res;  \\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627264,
                "title": "simple-c-solution-dp-and-dfs",
                "content": "Base On Word Break I , I will use  vector<vector<string>> dp to keep the possible candidates\\n\\n```\\nvector<string> wordBreak(string s, vector<string>& dict) {\\n        vector<string> res;\\n        if (dict.size() == 0) return res;\\n        int n = s.size();\\n        vector<vector<string>> dp(n+1, vector<string>());\\n        dp[0] = {\" \"};\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >=0; --j) {\\n                if (!dp[j].empty()) {\\n                    string word = s.substr(j, i-j);\\n                    if (find(dict.begin(), dict.end(), word) != dict.end()) {\\n                        dp[i].push_back(word);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        dfs(n, dp, \"\", res);\\n        \\n        return res;\\n    }\\n    \\n    void dfs(int loc, vector<vector<string>> dp, string word, vector<string> &res) {\\n        if (loc == 0) {\\n            res.push_back(word);\\n            return;\\n        }\\n        \\n        for (auto subword : dp[loc]) {\\n            int len = subword.size();\\n            string updateword = subword + (word.empty() ? \"\" : \" \")  + word;\\n            dfs(loc - len, dp, updateword, res);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> wordBreak(string s, vector<string>& dict) {\\n        vector<string> res;\\n        if (dict.size() == 0) return res;\\n        int n = s.size();\\n        vector<vector<string>> dp(n+1, vector<string>());\\n        dp[0] = {\" \"};\\n        for (int i = 1; i <= n; ++i) {\\n            for (int j = i - 1; j >=0; --j) {\\n                if (!dp[j].empty()) {\\n                    string word = s.substr(j, i-j);\\n                    if (find(dict.begin(), dict.end(), word) != dict.end()) {\\n                        dp[i].push_back(word);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        dfs(n, dp, \"\", res);\\n        \\n        return res;\\n    }\\n    \\n    void dfs(int loc, vector<vector<string>> dp, string word, vector<string> &res) {\\n        if (loc == 0) {\\n            res.push_back(word);\\n            return;\\n        }\\n        \\n        for (auto subword : dp[loc]) {\\n            int len = subword.size();\\n            string updateword = subword + (word.empty() ? \"\" : \" \")  + word;\\n            dfs(loc - len, dp, updateword, res);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 627065,
                "title": "java-6-ms-faster-than-92-33-trie-based-dfs-approach",
                "content": "I implemented a Trie based DP approach to generate all combinations of words from the dictionary of words using the input String.\\n```\\npublic List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if(s.isEmpty())\\n            return res;\\n        \\n        Trie root = new Trie();\\n        buildTrie(wordDict, root);\\n        Map<String, List<String>> map = new HashMap<>();\\n        buildWord(s, root, map);\\n        \\n        return map.get(s);\\n    }\\n    \\n    List<String> buildWord(String s, Trie root, Map<String, List<String>> map){\\n        if(map.containsKey(s)){\\n            return map.get(s);\\n        }\\n        \\n       List<String> res = new ArrayList<>();\\n        if(s.isEmpty()){\\n            res.add(\"\");\\n        }else{\\n            Trie node = root;\\n            for(int i=0;i<s.length();i++){\\n                \\n                char c = s.charAt(i);    \\n                if(node.next.containsKey(c)){\\n                    node = node.next.get(c);\\n                    \\n                    if(node.word != null){\\n                        String str = i == s.length() ? \"\" : s.substring(i+1);\\n                        List<String> data = buildWord(str, root, map );\\n                        \\n                        for(String s1: data){\\n                            res.add(node.word + (s1.isEmpty() ? \"\" : \" \" + s1));\\n                        }\\n                    }\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        map.put(s, res);\\n        return res;  \\n    }\\n    \\n    void buildTrie(List<String> wordDict, Trie root){ \\n        for(String w: wordDict){\\n            Trie node = root;   \\n            for(char c: w.toCharArray()){\\n                Trie n = null;\\n                if(!node.next.containsKey(c)){\\n                    n = new Trie();\\n                    node.next.put(c, n);\\n                }else{\\n                    n = node.next.get(c);\\n                }\\n                \\n                node = n; \\n            }\\n            node.word = w;\\n        }\\n    }\\n    \\n    class Trie{\\n        Map<Character, Trie> next = new HashMap<>();\\n        String word;\\n    }",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "I implemented a Trie based DP approach to generate all combinations of words from the dictionary of words using the input String.\\n```\\npublic List<String> wordBreak(String s, List<String> wordDict) {\\n        List<String> res = new ArrayList<>();\\n        \\n        if(s.isEmpty())\\n            return res;\\n        \\n        Trie root = new Trie();\\n        buildTrie(wordDict, root);\\n        Map<String, List<String>> map = new HashMap<>();\\n        buildWord(s, root, map);\\n        \\n        return map.get(s);\\n    }\\n    \\n    List<String> buildWord(String s, Trie root, Map<String, List<String>> map){\\n        if(map.containsKey(s)){\\n            return map.get(s);\\n        }\\n        \\n       List<String> res = new ArrayList<>();\\n        if(s.isEmpty()){\\n            res.add(\"\");\\n        }else{\\n            Trie node = root;\\n            for(int i=0;i<s.length();i++){\\n                \\n                char c = s.charAt(i);    \\n                if(node.next.containsKey(c)){\\n                    node = node.next.get(c);\\n                    \\n                    if(node.word != null){\\n                        String str = i == s.length() ? \"\" : s.substring(i+1);\\n                        List<String> data = buildWord(str, root, map );\\n                        \\n                        for(String s1: data){\\n                            res.add(node.word + (s1.isEmpty() ? \"\" : \" \" + s1));\\n                        }\\n                    }\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        map.put(s, res);\\n        return res;  \\n    }\\n    \\n    void buildTrie(List<String> wordDict, Trie root){ \\n        for(String w: wordDict){\\n            Trie node = root;   \\n            for(char c: w.toCharArray()){\\n                Trie n = null;\\n                if(!node.next.containsKey(c)){\\n                    n = new Trie();\\n                    node.next.put(c, n);\\n                }else{\\n                    n = node.next.get(c);\\n                }\\n                \\n                node = n; \\n            }\\n            node.word = w;\\n        }\\n    }\\n    \\n    class Trie{\\n        Map<Character, Trie> next = new HashMap<>();\\n        String word;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 609287,
                "title": "c-dp-memoisation-20-lines-61-on-time-70-on-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string& s, int idx, unordered_set<string>& words, unordered_map<int, vector<string>>& dp) {\\n        if (dp.count(idx) == 0) {\\n            for (int i = idx-1; i >= 0; i--) {\\n                string tail = s.substr(i, idx-i);\\n                if (words.count(tail) == 0) continue;\\n                for (string sol : wordBreak(s, i, words, dp)) {\\n                    dp[idx].push_back(sol.append(tail).append(\" \"));\\n                }\\n            }\\n        }\\n        \\n        return dp[idx];\\n    }\\n    \\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.cbegin(), wordDict.cend());\\n        unordered_map<int, vector<string>> dp;\\n        dp[0] = {\"\"};\\n\\n        vector<string> result = wordBreak(s, s.length(), words, dp);\\n        for (string& sentence : result) sentence.pop_back();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string& s, int idx, unordered_set<string>& words, unordered_map<int, vector<string>>& dp) {\\n        if (dp.count(idx) == 0) {\\n            for (int i = idx-1; i >= 0; i--) {\\n                string tail = s.substr(i, idx-i);\\n                if (words.count(tail) == 0) continue;\\n                for (string sol : wordBreak(s, i, words, dp)) {\\n                    dp[idx].push_back(sol.append(tail).append(\" \"));\\n                }\\n            }\\n        }\\n        \\n        return dp[idx];\\n    }\\n    \\n    \\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_set<string> words(wordDict.cbegin(), wordDict.cend());\\n        unordered_map<int, vector<string>> dp;\\n        dp[0] = {\"\"};\\n\\n        vector<string> result = wordBreak(s, s.length(), words, dp);\\n        for (string& sentence : result) sentence.pop_back();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606894,
                "title": "python-solution-and-thought-process",
                "content": "**Step 1: Identify Subproblems:**\\n```\\ndp[i] = all possible sentences in s[i:]\\ndp[i] =\\n    res = []\\n    for word in wordDict:\\n        if word != s[i:i+len(word)]:\\n            continue\\n        elif len(word) == len(s)-i:\\n            res.append(word)\\n        else:\\n            for sentence in dp[i+len(word)]:\\n                res.append(word + \\' \\' + sentence)\\n    return res\\n```\\n\\n**2. Analyze options for implementation**\\nTop down recursive solution time complexity:\\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(N*N^S*S/M) = O(NN^2S/M)\\n```\\n**Note:** I\\'m not 100% sure if the top down time complexity analysis I did was correct when taking memoization into account. If someone could chime in here?\\n\\nBottom up iterative solution time complexity:\\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(S*N*N^S) = O(NN^2S)\\n```\\n\\nChoose top down recursive solution to avoid TLE.\\n\\n**3. Python Code**\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        @lru_cache(maxsize=None)\\n        def dp(i):\\n            res = []\\n            for word in wordDict:\\n                if word != s[i:i+len(word)]:\\n                    continue\\n                elif len(word) == len(s)-i:\\n                    res.append(word)\\n                else:\\n                    for sentence in dp(i+len(word)):\\n                        res.append(word + \\' \\' + sentence)        \\n            return res\\n        \\n        return dp(0)\\n```\\n\\nNote:\\n* Code is based on https://leetcode.com/problems/word-break-ii/discuss/44311/Python-easy-to-understand-solution",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndp[i] = all possible sentences in s[i:]\\ndp[i] =\\n    res = []\\n    for word in wordDict:\\n        if word != s[i:i+len(word)]:\\n            continue\\n        elif len(word) == len(s)-i:\\n            res.append(word)\\n        else:\\n            for sentence in dp[i+len(word)]:\\n                res.append(word + \\' \\' + sentence)\\n    return res\\n```\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(N*N^S*S/M) = O(NN^2S/M)\\n```\n```\\nN = len(wordDict)\\nM = min([len(word) for word in wordDict])\\nS = len(sentence)\\nO(S*N*N^S) = O(NN^2S)\\n```\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\\n        @lru_cache(maxsize=None)\\n        def dp(i):\\n            res = []\\n            for word in wordDict:\\n                if word != s[i:i+len(word)]:\\n                    continue\\n                elif len(word) == len(s)-i:\\n                    res.append(word)\\n                else:\\n                    for sentence in dp(i+len(word)):\\n                        res.append(word + \\' \\' + sentence)        \\n            return res\\n        \\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533512,
                "title": "javascript-dfs-memo",
                "content": "```\\nvar wordBreak = function(s, wordDict) {\\n    \\n    const dictSet = new Set(wordDict);\\n    const memo = {};\\n\\n    function dfs(start) {\\n        \\n        if(start > s.length-1) { \\n            return [[]];\\n        }\\n        \\n        if(memo[start] !== undefined) {\\n            return memo[start];\\n        }\\n        \\n        const out = [];\\n        \\n        for(let i = start; i < s.length; i++) {\\n            const substr = s.substring(start, i+1);\\n            if(dictSet.has(substr)) {\\n                let next = dfs(i+1); \\n                for(let n of next) {\\n                    out.push([substr, ...n]);\\n                }\\n            }\\n        }  \\n        return memo[start] = out;\\n        \\n    }\\n    \\n    const res = dfs(0)\\n\\n    return res.filter(a => a.join(\\'\\') === s).map(a => a.join(\\' \\'));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar wordBreak = function(s, wordDict) {\\n    \\n    const dictSet = new Set(wordDict);\\n    const memo = {};\\n\\n    function dfs(start) {\\n        \\n        if(start > s.length-1) { \\n            return [[]];\\n        }\\n        \\n        if(memo[start] !== undefined) {\\n            return memo[start];\\n        }\\n        \\n        const out = [];\\n        \\n        for(let i = start; i < s.length; i++) {\\n            const substr = s.substring(start, i+1);\\n            if(dictSet.has(substr)) {\\n                let next = dfs(i+1); \\n                for(let n of next) {\\n                    out.push([substr, ...n]);\\n                }\\n            }\\n        }  \\n        return memo[start] = out;\\n        \\n    }\\n    \\n    const res = dfs(0)\\n\\n    return res.filter(a => a.join(\\'\\') === s).map(a => a.join(\\' \\'));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508994,
                "title": "c-straightforward-dfs-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string, vector<string>> memo;\\n        return dfs(s, memo, wordDict);\\n    }\\n    \\n    vector<string> dfs(string s, unordered_map<string, vector<string>>& memo, vector<string>& wordDict) {\\n        if (memo.find(s) != memo.end()) {\\n            return memo[s];\\n        }\\n        \\n        vector<string> results;\\n        if (s.size() == 0) {\\n            return {\"\"};\\n        }\\n        \\n        for (string word : wordDict) {\\n            int len = word.size();\\n            if (len <= s.size()) {\\n                if (s.substr(0, len) != word) continue;\\n                string suffix = s.substr(len);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//build results from suffix partition results - solve based on subproblems\\n                vector<string> segs = dfs(suffix, memo, wordDict);\\n                for (string seg : segs) {\\n                    results.push_back(seg.empty() ? word + seg : word + \" \" + seg);\\n                }\\n            }\\n        }\\n        \\n        memo[s] = results; //memoization\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        unordered_map<string, vector<string>> memo;\\n        return dfs(s, memo, wordDict);\\n    }\\n    \\n    vector<string> dfs(string s, unordered_map<string, vector<string>>& memo, vector<string>& wordDict) {\\n        if (memo.find(s) != memo.end()) {\\n            return memo[s];\\n        }\\n        \\n        vector<string> results;\\n        if (s.size() == 0) {\\n            return {\"\"};\\n        }\\n        \\n        for (string word : wordDict) {\\n            int len = word.size();\\n            if (len <= s.size()) {\\n                if (s.substr(0, len) != word) continue;\\n                string suffix = s.substr(len);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//build results from suffix partition results - solve based on subproblems\\n                vector<string> segs = dfs(suffix, memo, wordDict);\\n                for (string seg : segs) {\\n                    results.push_back(seg.empty() ? word + seg : word + \" \" + seg);\\n                }\\n            }\\n        }\\n        \\n        memo[s] = results; //memoization\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469507,
                "title": "c-dp-dfs-solution-95",
                "content": "We first construct a dp array for the original string. If `s[:k]` is breakable (i.e. can be broken into valid words), there must be a position `l`, where `s[:k-l]` is also breakable and `s[k-l:]` is a valid word. There can be multiple valid `l` for a given `k`. \\n\\nTo implement dp, we store all possible `k-l` positions as a set in `dp[k]`. For a given `k` we scan all possible word length `l` in the dictionary, and insert `k-l` into `dp[k]` if `l == k` or `dp[k-l]` is non-empty.\\n\\nAfter consturcting `dp` array, we use DFS to reconstruct result vector and return.\\n\\nTo increase the performance, we preprocess `dictWords` to get all possible word lengths in the dictionary.\\n\\n```\\nclass Solution {\\nprivate:\\n    void dfs(const vector<unordered_set<int>>& dp, int k, vector<string>& rst, string& s) {\\n\\t\\t// function to reconstruct result string vector from dp array\\n        if (k < s.size()) {\\n             s.insert(k, 1, \\' \\');\\n        }\\n        for (int knext : dp[k]) {\\n            if (knext == 0) {\\n                rst.push_back(s);\\n            }\\n            else {\\n                dfs(dp, knext, rst, s);   \\n            }\\n        }\\n        if (k < s.size()) {\\n            s.erase(k, 1);\\n        }\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        // preprocess wordDict, generate hash table for possible lengths and words\\n        unordered_set<int> lens;\\n        unordered_set<string> dict;\\n           for (int i(0); i < wordDict.size(); ++i) {\\n            lens.insert(wordDict[i].size());\\n            dict.insert(wordDict[i]);\\n        }\\n        // DP: dp[k] stores all possible last space positions for substring s[:k]\\n        //  i.e. if l is in dp[k], it means s[:l] can be broken into valid words and s[l:k] is a valid word\\n        const int N = s.size();\\n        vector<unordered_set<int>> dp(N+1, unordered_set<int>());\\n        for (int k(1); k <= N; ++k) {\\n            for (int l : lens) {\\n               if (l <= k) {\\n                   const string seg(s.begin() + k-l, s.begin() + k);\\n                   if (dict.count(seg)) {\\n                       if (l == k or !dp[k-l].empty()) {\\n                           dp[k].insert(k-l);\\n                       }\\n                   }\\n               }\\n            }\\n        }\\n        // generate recult with DFS\\n        vector<string> rst;\\n        dfs(dp, N, rst, s);\\n        return rst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(const vector<unordered_set<int>>& dp, int k, vector<string>& rst, string& s) {\\n\\t\\t// function to reconstruct result string vector from dp array\\n        if (k < s.size()) {\\n             s.insert(k, 1, \\' \\');\\n        }\\n        for (int knext : dp[k]) {\\n            if (knext == 0) {\\n                rst.push_back(s);\\n            }\\n            else {\\n                dfs(dp, knext, rst, s);   \\n            }\\n        }\\n        if (k < s.size()) {\\n            s.erase(k, 1);\\n        }\\n    }\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        // preprocess wordDict, generate hash table for possible lengths and words\\n        unordered_set<int> lens;\\n        unordered_set<string> dict;\\n           for (int i(0); i < wordDict.size(); ++i) {\\n            lens.insert(wordDict[i].size());\\n            dict.insert(wordDict[i]);\\n        }\\n        // DP: dp[k] stores all possible last space positions for substring s[:k]\\n        //  i.e. if l is in dp[k], it means s[:l] can be broken into valid words and s[l:k] is a valid word\\n        const int N = s.size();\\n        vector<unordered_set<int>> dp(N+1, unordered_set<int>());\\n        for (int k(1); k <= N; ++k) {\\n            for (int l : lens) {\\n               if (l <= k) {\\n                   const string seg(s.begin() + k-l, s.begin() + k);\\n                   if (dict.count(seg)) {\\n                       if (l == k or !dp[k-l].empty()) {\\n                           dp[k].insert(k-l);\\n                       }\\n                   }\\n               }\\n            }\\n        }\\n        // generate recult with DFS\\n        vector<string> rst;\\n        dfs(dp, N, rst, s);\\n        return rst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564947,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564626,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564923,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566021,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566968,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566945,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567520,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1568130,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566752,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567887,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564947,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564626,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1564923,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566021,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566968,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566945,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567520,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1568130,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1566752,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1567887,
                "content": [
                    {
                        "username": "CodingGod",
                        "content": "firstly I used DP from head of the string to  traverse the dp-map: and then got a \\u201cTime Limit Exceeded\\u201d Error with the unpassed case \"aaaaaaaaa....ab\", but this method can pass such case like \"baaaaaa....a\"\\n\\nsecondly I found the answer on internet with the dp-strategy, and saw  the dp-method  from tail of the string to  traverse the dp-map, then got an \"Accepted\" ,but i tested the case like \"baaaaaa....a\" on my own computer ,finally the result is \\u201cTime Limit Exceeded\\u201d\\n\\nabove all, i think the two strategies are the same ; and the OJ's test cases may have some infulence on different methods!"
                    },
                    {
                        "username": "golden_teeth",
                        "content": "if you are getting TLE despite the correct DP or DFS solution, it might be because the largest test input is like this\\n\\n    \\n\\n> [\"aa..(lots of 'a').b\", \"a\",\"aaaaa\"...so on]\\n\\nAs you can see this test case should return empty  as last character in input string is **b**, which is not in the dictionary. So all the work in DP/DFS is a waste\\n\\nTo escape from TLE, just put a check first whether the input string **s** is breakable or not..if breakable then try to break it using your algo"
                    },
                    {
                        "username": "clue",
                        "content": "The topic has been well discussed in many posts such as [here](https://oj.leetcode.com/discuss/12936/accepted-solution-backtracking-difference-front-tracking) and [here](https://oj.leetcode.com/discuss/8830/two-different-strategies-about-dp-get-different-results). Because the existence of test case `'aaaaa...aaaab', ['a', 'aa', 'aaa', ... 'aaa...aa']`, the forward DP solution will cause MLE while the backward DP is just fine, apparently the test case `'baaaaaaaa...aaaa', ['a', 'aa', 'aaa', ..., 'aaa...aa']` should also be included."
                    },
                    {
                        "username": "darwinlo",
                        "content": "The official solution gives the time complexity as O(pow(N, 2) + pow(2, N) + W). I claim that the pow(N, 2) term is redundant. Furthermore, the term pow(2, N) should be min(W, N)\\\\*pow(2, N); as it stands, this time complexity undercounts.\\n\\nFirst, some background. In a given string, every pair of adjacent characters is an opportunity to insert a break. In a string of size L, there L - 1 insertion points. Given that there are L - 1 decision points and that there are two possible choices at each decision point, there are pow(2, L - 1) possible ways to break up a string. Each way maps to a sequence of fragments, some of which are valid word sequences.\\n\\nNow onto the problem. The suffixes of the input string have lengths 1, \\u2026, N - 1. Per the preceding discussion, a suffix of length i may have up to pow(2, i - 1) possible word sequences. Each suffix corresponds to a sub-problem, and each sub-problem may be part of min(W, N) super-problems, each of which prepends a word to each of the word sequences. So the work associated with a sub-problem is min(W, N)\\\\*pow(2, i-1). If we add up the work for all sub-problems, we get min(W, N)\\\\*pow(2, N) -- rather than pow(2, N).\\n\\nAs for the O(N^2) term, it is true as the official solutions says that there are O(N^2) edges and that each edge must be visited. In my analysis, these visits are counted when processing the word sequences of a sub-problem.\\n\\nOverall, this was a particularly difficult analysis, and the error aside, the official solution gives a great visualization without which I would have found it difficult to complete my analysis. So thanks to LeetCode.\\n\\n### Side Note\\nFor those who haven\\'t yet encountered geometric series and are wondering why adding up all the work gets us a closed-form expression:\\n\\nS = pow(2, 1) + pow(2, 2) + ... pow(2, N - 1)\\n2\\\\*S = pow(2, 2) + ... + pow(2, N - 1) + pow(2, N)\\nS = 2\\\\*S - S = pow(2, N) - 2"
                    },
                    {
                        "username": "binarybelle",
                        "content": "Maybe this question is too broad, but I\\'m going to ask it anyway.  \\n\\n**When you look at a problem, how do you decide which way to to solve it?  **\\n\\nI wasn\\'t a CS major, but I have been in tech for a long time, doing web development and database work.  I\\'m getting CS questions in interviews, so here I am, learning.  Often, though, it seems to me like there\\'s some guideline many others know about, that I don\\'t.  Is this just experience in this area?  Are there courses to connect those dots?\\n\\nI do break the problem down into smaller pieces.  I do write the pattern out on a white board.  And once I know a type of solution to use, I can code it just fine.  It\\'s figuring out what to look for and which type of solution to use, that\\'s a struggle.\\n\\nFor example, yesterday\\'s word break ii problem...I wrote out the pattern on my whiteboard.  I even \"walked through\" the whole pattern on my grid paper.  I watched several videos, looked at a bunch of tutorials...read comments....etc.  I DID figure out how to implement the solutions.  But until I did all that, I just wasn\\'t getting what to do.  And I still have several \"why this way\" questions.\\n\\nNow, today\\'s Word Break II.  I got as far as having a dictionary with tuples that had each word\\'s start and end slot in the sentence: \\n\\n`[(\\'cat\\', (0, 3)), (\\'cats\\', (0, 4)), (\\'sand\\', (3, 7)), (\\'and\\', (4, 7)), (\\'dog\\', (7, 10)), (\\'cat\\', (10, 13)), (\\'cats\\', (10, 14))]`\\n\\nThen I got stuck on how to reassemble it without doing a bunch of odd gyrations.  So I researched to see how others were solving this. What did I find?  Well, nothing like mine.  LOL.  Instead, I found memoization solutions, DFS solutions, recursive solutions. \\n\\nI did read a lot of the comments in the recent popular post about getting better at problem solving.  They\\'re super helpful...but I\\'m still unsure about how to figure out what type of solution goes with what type of problem.\\n\\nAlso, I\\'m fairly new to Leetcode, so if there are other helpful posts, or any other kind of resource that would be helpful, please share...don\\'t assume I know about it.  LOL. \\n\\nThank you!"
                    },
                    {
                        "username": "ahcode",
                        "content": "The solution suggests than an `n^3` time complexity is possible, given a string of length `n`.  However, consider this counterexample: s = \"aaaaaaaaaaaaaaaaa\" and the vocabulary contains every substring of `s`.  Then it\\'s possible to insert a space anywhere. If there are `n` a\\'s, we can insert a space between any one of them, or not insert such a space, and so there are `2 ^ (N-1)` allowed outputs.  \\n\\nGiven even the output has exponential size, any solution that directly calculates these outputs must have exponential time complexity.  \\n\\nIf we concisely encode the solution without fully generating it, e.g., as a Cartesian product, a faster solution may be possible.  But the existing solution is **definitely** wrong."
                    },
                    {
                        "username": "spjparmar",
                        "content": "I implemented top down dp solution for this problem but finding it hard to understand the time complexity of my own solution. Also read many posts in discussion but could not understand the time complexity for this problem.\\n\\nFor me, Since we are considering all possible words in the dictionary at each position of the string , it seems the time complexity is ***m^n*** without memoization. (m - no of words, n - string size)\\n\\nWith memoization since we are storing all possible strings in map so the max number of string in map can be ***N*** and for each string we are consideting all possible substring so the complexity in this case is ***N^2***\\n\\nPlease comment your thoughts."
                    },
                    {
                        "username": "shubpate",
                        "content": "Can someone clarify what order is expected out of result here, seeing the first and second example provided it is not clear."
                    },
                    {
                        "username": "charonme",
                        "content": "[@user0327pw](/user0327pw) you have a redundant space at the end of your sentences"
                    },
                    {
                        "username": "user0327pw",
                        "content": "it says any order, but I\\'m getting the wrong answer even though they are equal:\\n\\n[\"cat sand dog \",\"cats and dog \"]\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nboth have strings, \"cats and dog\" and \"cat sand dog\""
                    },
                    {
                        "username": "jeremyan",
                        "content": "The test cases of \"aaaaa...b\" and \"baaaa...a\" combined with the time limitation criteria is questionable.  I believe most people saw time limit hit on their first try.  I was using DP which is supposed to be very efficient  but unfortunately hit the time limit.\\n\\nIt's actually very simple to work around the 2 extreme test cases: just call the Word Break I function to filter out the error cases, then call my DP function for Word Break II again (which previously failed because of time limit).  Calling 2 functions is much desired than calling only 1 in this case, but I don't think this represents the typical use case in the real world."
                    },
                    {
                        "username": "HaiZhung",
                        "content": "Like many others, I wrote a DP solution with front-tracking and got it handed back to me with a TLE on the test case\\n``aaa...ab``. I was confused at first, because it was not clear to me how to solve it faster. I can see that the number of strings returned is 0, since there is no word in the dictionary that contains a ``b``. \\n\\nHowever, it strikes me as odd to just arbitrarily filter some cases out via pre-processing. Like, if I check the most upvoted solutions in the comments, I can usually simply design a test case whose solution is 0 or 1, but the voted algorithms will get a TLE. For instance, https://leetcode.com/discuss/27464/my-concise-answer can be broken by a test case ``aaa...aba``with dictionary ``[\"a\",\"aa\",...]``. The answer is still 0, but the algorithm would get an exponential blowup.\\n\\nSo I guess my question is, what exactly is expected in these questions? Should we catch arbitrary cases posed by the test cases?"
                    }
                ]
            },
            {
                "id": 1570691,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1569464,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1567212,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1766491,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1576594,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1575746,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1571304,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1571305,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 1571306,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 2027607,
                "content": [
                    {
                        "username": "gaurav__pareek",
                        "content": "![image](https://assets.leetcode.com/users/images/9e972ecc-71ed-49fb-a84a-92e7c24d8db3_1638349268.1982768.png)\\n"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "* Seems like a Trie is unecessary here since we\\'re only going over the word Dict once. It\\'s probably still better, but just barely.\\n\\n* For a problem like https://leetcode.com/problems/word-search-ii/, since we\\'re going over the boggle board multiple times, then it makes sense to use a Trie."
                    },
                    {
                        "username": "Decision",
                        "content": "The output scope can be up to n power of n,  so I don't think there would be a solution running in polynomial time for any worse case."
                    },
                    {
                        "username": "parikshitgupta2001",
                        "content": "I submitted it here in Leetcode, the non DP solution and it worked\\nI was asked the same question in an interview, I wrote the solution but it was giving TLE in interview\\nGot that DP should be used, but as I was implementing the DP solution the time got over, it was of 1 hour\\nI was not selected in the interview\\nMoveworks.ai asked me this in the interview"
                    },
                    {
                        "username": "lakshya_mathur",
                        "content": "This question reminds me of the song pen pineapple apple pen : )\\n"
                    },
                    {
                        "username": "user7576X",
                        "content": "I earlier tried to submit my backtraking solution but it was failing due TLE on following test case\\n\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n[\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\",\"aaaaaaaaa\",\"aaaaaaaaaa\"]\\n\\nbut today same solution got accepted the mentioned test case is now being errored out citing \"expected \\'s\\' to have 1 <= size <= 20 but got 151\"\\nwhich is now valid as per the constraints probably they have reduce the size or earlier the constraint was not I do not remember what were the constraints at that time\\ndoes anyone solve this before the changes were made or Is the change actualy made in test case can anyone please confirm ?"
                    },
                    {
                        "username": "warmbear",
                        "content": "If the description of this problem changed a little bit.\\nFor example, we only need to find one possible breaking method. \\nThat's to say, the program returns as soon as one valid breaking method is found. \\nWhat is the run time complexity in this case?\\nStill exponential?"
                    },
                    {
                        "username": "GhostInMatrix",
                        "content": "If given the example s=\"aaaaaa\",and the dict=[\"a\",\"aa\",\"aaa\"],then does the result [\"a a a a a a\"] should be\\none of the total results?\\nInfact, when I produced the result containing this, it told me \"wrong answer\"."
                    },
                    {
                        "username": "orgpark",
                        "content": "Here I have my Java solution, which uses recursion."
                    },
                    {
                        "username": "ayushmall06",
                        "content": "Firstly I wrote the recursive solution, and then tried to submit the solution.... I solution got accepted AC.  I haven\\'t memoized it but still the solution got accepted."
                    }
                ]
            },
            {
                "id": 2018427,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 2001030,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1999468,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1999390,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1977737,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1975487,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1926529,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1919580,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1911042,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            },
            {
                "id": 1812430,
                "content": [
                    {
                        "username": "shait9760",
                        "content": "Got a wrong test case, but i cant figure out why, any feedback? Here the info:\\n\\ns = \"catsandog\"\\nwordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\\noutput = [\"cats and\",\"cat sand\"]\\nexpected = []"
                    },
                    {
                        "username": "khushi3",
                        "content": "How are y\\'all getting TLE. I submitted brute backtracking approach and got it under 96% , 1ms solution."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Coming from word break 1, this seemed easier to me somehow. Here is how I approached the problem:\n1. Create a HashSet out of wordDict so that lookup times of valid words can be faster.\n2. Use a recursive function that builds our spaced sentence by going over s, adding the char at s[ind] to a StringBuilder object, and asking if the string is in our wordSet. If it is, we call the function again with our current sentence concatenated with a \" \" and the string we were assembling.\n\n        while (ind != sLen){\n            sb.Append(s[ind]);\n            ind++;\n            if (wordSet.Contains(sb.ToString())){\n                getWords(s, curr + \" \" + sb.ToString(), ind);\n            }\n        }\n\nSomething like the above, though I left out a little bit to still keep it interesting. Cheers!\n\nEdit: In theory the time complexity of this approach could be n factorial, if every single letter you add results in a new call to the recursive function. So this might not be a good approach for test cases where s has a high length."
                    },
                    {
                        "username": "C_230",
                        "content": "\"Algorithm\"\\nIf the memory array is not used for optimization to reduce repeated calculations, then the recursive method is no different from brute force, and it will not pass OJ with a high probability. So we have to avoid duplicated counting.\\n\\nTo cache this intermediate result, since we must save s and all of its split strings at the same time, a HashMap can be used to establish the mapping between the two, then in the recursive function, we first detect the current s and whether there is a mapping, if so, return directly.\\n\\nIf s is empty, an empty string is returned."
                    },
                    {
                        "username": "loloksEth",
                        "content": "why its hard? medium i think,or i lucky to found fast solution"
                    },
                    {
                        "username": "Vialor",
                        "content": "Feels like a middle-difficulty DFS at most to me."
                    },
                    {
                        "username": "AbhayDutt",
                        "content": " in the question it is clearly stated, \"Return all such possible sentences in any order\".\\nbut when i run my code the output is \\n[\"cat sand dog \",\"cats and dog \"]\\n\\n\\n and the expected output is\\n[\"cats and dog\",\"cat sand dog\"]\\n\\nmeaning they want the Strings in the correct order in the ans list.\\n\\nam i wrong or is the description incorrect???\\n"
                    },
                    {
                        "username": "kevintancs",
                        "content": "Can someone please explain why this is a Hard problem? I used a standard backtracking DFS approach, wrote the solution in 10 minutes with only 11-12 lines, and beats 70%. "
                    },
                    {
                        "username": "steeewtOverflow",
                        "content": "How do we differentiate which question requires memoization and which one can run in simple recursive solution? Is there a way to find out? I remember the first part of this problem gave TLE with recursive solution but this doesn\\'t"
                    },
                    {
                        "username": "deadman317",
                        "content": "LeetCode team you guys should fix the console\\nwhen I submit a solution it fails a test case : s =\"a\", wordDict = [\"b\"],  output [\"a\"], expected [].\\nbut when I take the test case as input it give correct output as expected. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Search a 2D Matrix II",
        "question_content": "<p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p>\n\n<ul>\n\t<li>Integers in each row are sorted in ascending from left to right.</li>\n\t<li>Integers in each column are sorted in ascending from top to bottom.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg\" style=\"width: 300px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == matrix.length</code></li>\n\t<li><code>n == matrix[i].length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 300</code></li>\n\t<li><code>-10<sup>9</sup> &lt;= matrix[i][j] &lt;= 10<sup>9</sup></code></li>\n\t<li>All the integers in each row are <strong>sorted</strong> in ascending order.</li>\n\t<li>All the integers in each column are <strong>sorted</strong> in ascending order.</li>\n\t<li><code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 66140,
                "title": "my-concise-o-m-n-java-solution",
                "content": "We start search the matrix from top right corner, initialize the current position to top right corner, if the target is greater than the value in current position, then the target can not be in entire row of current position because the row is sorted, if the target is less than the value in current position, then the target can not in the entire column because the column is sorted too. We can rule out one row or one column each time, so the time complexity is O(m+n).\\n\\n    public class Solution {\\n        public boolean searchMatrix(int[][] matrix, int target) {\\n            if(matrix == null || matrix.length < 1 || matrix[0].length <1) {\\n                return false;\\n            }\\n            int col = matrix[0].length-1;\\n            int row = 0;\\n            while(col >= 0 && row <= matrix.length-1) {\\n                if(target == matrix[row][col]) {\\n                    return true;\\n                } else if(target < matrix[row][col]) {\\n                    col--;\\n                } else if(target > matrix[row][col]) {\\n                    row++;\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean searchMatrix(int[][] matrix, int target) {\\n            if(matrix == null || matrix.length < 1 || matrix[0].length <1) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 66139,
                "title": "c-search-from-top-right",
                "content": "Search from the **top-right** element and reduce the search space by one row or column at each time.\\n\\n```\\n[[ 1,  4,  7, 11, 15],\\n [ 2,  5,  8, 12, 19], \\n [ 3,  6,  9, 16, 22],\\n [10, 13, 14, 17, 24],\\n [18, 21, 23, 26, 30]]\\n```\\n\\nSuppose we want to search for `12` in the above matrix. compare `12` with the top-right element `nums[0][4] = 15`. Since `12 < 15`, `12` cannot appear in the column of `15` since all elements in that column are greater than or equal to `15`. Now we reduce the search space by one column (the last column).\\n\\nWe further compare `12` with the top-right element of the remaining matrix, which is `nums[0][3] = 11`. Since `12 > 11`, `12` cannot appear in the row of `11` since all elements in this row are less than or equal to `11` (the last column has been discarded). Now we reduce the search space by one row (the first row).\\n\\nWe move on to compare `12` with the top-right element of the remaining matrix, which is `nums[1][3] = 12`. Since it is equal to `12`, we return `true`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, r = 0, c = n - 1;\\n        while (r < m && c >= 0) {\\n            if (matrix[r][c] == target) {\\n                return true;\\n            }\\n            matrix[r][c] > target ? c-- : r++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\n[[ 1,  4,  7, 11, 15],\\n [ 2,  5,  8, 12, 19], \\n [ 3,  6,  9, 16, 22],\\n [10, 13, 14, 17, 24],\\n [18, 21, 23, 26, 30]]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, r = 0, c = n - 1;\\n        while (r < m && c >= 0) {\\n            if (matrix[r][c] == target) {\\n                return true;\\n            }\\n            matrix[r][c] > target ? c-- : r++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66142,
                "title": "c-with-o-m-n-complexity",
                "content": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        if (m == 0) return false;\\n        int n = matrix[0].size();\\n\\n        int i = 0, j = n - 1;\\n        while (i < m && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target) {\\n                j--;\\n            } else \\n                i++;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        if (m == 0) return false;\\n        int n = matrix[0].size();\\n\\n        int i = 0, j = n - 1;\\n        while (i < m && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target) {\\n                j--;\\n            } else \\n                i++;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66147,
                "title": "java-an-easy-to-understand-divide-and-conquer-method",
                "content": "The coding seems to be much more complex than those smart methods such as [this one][1], but the idea behind is actually quite straightforward. `Unfortunately, it is not as fast as the smart ones.`\\n\\nFirst, we divide the matrix into four quarters as shown below:\\n\\n      zone 1      zone 2\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    -----------------------\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n      zone 3      zone 4\\n\\nWe then compare the element in the center of the matrix with the target. There are three possibilities:\\n\\n\\n - center < target. In this case, we discard zone 1 because all elements in zone 1 are less than target.\\n\\n - center > target. In this case, we discard zone 4.\\n\\n - center == target. return true.\\n\\nFor time complexity, if the matrix is a square matrix of size `nxn`, then for the worst case, \\n\\n    T(nxn) = 3T(n/2 x n/2)\\n\\nwhich makes \\n  \\n    T(nxn) = O(n^log3)\\n\\nCode in Java:\\n\\n     public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        if(m<1) return false;\\n        int n = matrix[0].length;\\n        \\n        return searchMatrix(matrix, new int[]{0,0}, new int[]{m-1, n-1}, target);\\n    }\\n    \\n    private boolean searchMatrix(int[][] matrix, int[] upperLeft, int[] lowerRight, int target) {\\n    \\tif(upperLeft[0]>lowerRight[0] || upperLeft[1]>lowerRight[1]\\n    \\t\\t\\t|| lowerRight[0]>=matrix.length || lowerRight[1]>=matrix[0].length) \\n    \\t\\treturn false;\\n    \\tif(lowerRight[0]-upperLeft[0]==0 && lowerRight[1]-upperLeft[1]==0)\\n    \\t\\treturn matrix[upperLeft[0]][upperLeft[1]] == target;\\n    \\tint rowMid = (upperLeft[0] + lowerRight[0]) >> 1;\\n    \\tint colMid = (upperLeft[1] + lowerRight[1]) >> 1;\\n    \\tint diff = matrix[rowMid][colMid] - target;\\n    \\tif(diff > 0) {\\n    \\t\\treturn searchMatrix(matrix, upperLeft, new int[]{rowMid, colMid}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{upperLeft[0],colMid+1}, new int[]{rowMid, lowerRight[1]}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1,upperLeft[1]}, new int[]{lowerRight[0], colMid}, target);\\n    \\t}\\n    \\telse if(diff < 0) {\\n     \\t\\treturn searchMatrix(matrix, new int[]{upperLeft[0], colMid+1}, new int[]{rowMid, lowerRight[1]}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1, upperLeft[1]}, new int[]{lowerRight[0], colMid}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1, colMid+1}, lowerRight, target);\\n    \\t}\\n    \\telse return true;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/48852/my-concise-o-m-n-java-solution",
                "solutionTags": [],
                "code": "The coding seems to be much more complex than those smart methods such as [this one][1], but the idea behind is actually quite straightforward. `Unfortunately, it is not as fast as the smart ones.`\\n\\nFirst, we divide the matrix into four quarters as shown below:\\n\\n      zone 1      zone 2\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    -----------------------\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n    *  *  *  * | *  *  *  *\\n      zone 3      zone 4\\n\\nWe then compare the element in the center of the matrix with the target. There are three possibilities:\\n\\n\\n - center < target. In this case, we discard zone 1 because all elements in zone 1 are less than target.\\n\\n - center > target. In this case, we discard zone 4.\\n\\n - center == target. return true.\\n\\nFor time complexity, if the matrix is a square matrix of size `nxn`, then for the worst case, \\n\\n    T(nxn) = 3T(n/2 x n/2)\\n\\nwhich makes \\n  \\n    T(nxn) = O(n^log3)\\n\\nCode in Java:\\n\\n     public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        if(m<1) return false;\\n        int n = matrix[0].length;\\n        \\n        return searchMatrix(matrix, new int[]{0,0}, new int[]{m-1, n-1}, target);\\n    }\\n    \\n    private boolean searchMatrix(int[][] matrix, int[] upperLeft, int[] lowerRight, int target) {\\n    \\tif(upperLeft[0]>lowerRight[0] || upperLeft[1]>lowerRight[1]\\n    \\t\\t\\t|| lowerRight[0]>=matrix.length || lowerRight[1]>=matrix[0].length) \\n    \\t\\treturn false;\\n    \\tif(lowerRight[0]-upperLeft[0]==0 && lowerRight[1]-upperLeft[1]==0)\\n    \\t\\treturn matrix[upperLeft[0]][upperLeft[1]] == target;\\n    \\tint rowMid = (upperLeft[0] + lowerRight[0]) >> 1;\\n    \\tint colMid = (upperLeft[1] + lowerRight[1]) >> 1;\\n    \\tint diff = matrix[rowMid][colMid] - target;\\n    \\tif(diff > 0) {\\n    \\t\\treturn searchMatrix(matrix, upperLeft, new int[]{rowMid, colMid}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{upperLeft[0],colMid+1}, new int[]{rowMid, lowerRight[1]}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1,upperLeft[1]}, new int[]{lowerRight[0], colMid}, target);\\n    \\t}\\n    \\telse if(diff < 0) {\\n     \\t\\treturn searchMatrix(matrix, new int[]{upperLeft[0], colMid+1}, new int[]{rowMid, lowerRight[1]}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1, upperLeft[1]}, new int[]{lowerRight[0], colMid}, target)\\n    \\t\\t\\t\\t|| searchMatrix(matrix, new int[]{rowMid+1, colMid+1}, lowerRight, target);\\n    \\t}\\n    \\telse return true;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/48852/my-concise-o-m-n-java-solution",
                "codeTag": "Unknown"
            },
            {
                "id": 66160,
                "title": "ac-clean-java-solution",
                "content": "If we stand on the top-right corner of the matrix and look diagonally, it's kind of like a BST, we can go through this matrix to find the target like how we traverse the BST.\\n\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return false;\\n\\n        int n = matrix.length, m = matrix[0].length;\\n        int i = 0, j = m - 1;\\n        \\n        while (i < n && j >= 0) {\\n            int num = matrix[i][j];\\n            \\n            if (num == target)\\n                return true;\\n            else if (num > target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "If we stand on the top-right corner of the matrix and look diagonally, it's kind of like a BST, we can go through this matrix to find the target like how we traverse the BST.\\n\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\\n            return false;\\n\\n        int n = matrix.length, m = matrix[0].length;\\n        int i = 0, j = m - 1;\\n        \\n        while (i < n && j >= 0) {\\n            int num = matrix[i][j];\\n            \\n            if (num == target)\\n                return true;\\n            else if (num > target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 332356,
                "title": "python-o-m-n-linear-search-from-top-right-corner",
                "content": "Starting from Top-Right corner:\\nIf current grid ```M[r][c]``` is smaller than target ```x```, there is no need to consider ```M[r][ :c] ``` since all the grids on the left must be smaller as well. So, ```x``` must be in the rows below and we can safely make ``` r += 1```.\\nWe keep moving ```M[r][c]``` downwards until it\\'s larger ```x```, then we can safely move leftwards and make ```c -= 1``` since all the grids in ```M[ :r][c ]``` would be larger than ```x```.\\nDuring the search, if ```x``` is found, we return ```True```. Otherwise, we can either move downwards or leftwards safely.\\nIf we reach left-bottom corner without hitting ```x```, then target is not in the matrix.\\n```\\ndef searchMatrix(matrix, target):\\n\\tm, n = len(matrix), len(matrix) and len(matrix[0])\\n\\tr, c = 0, n-1\\n\\twhile r < m and c >= 0:\\n\\t\\tif target > matrix[r][c]:\\n\\t\\t\\tr += 1\\n\\t\\telif target < matrix[r][c]:\\n\\t\\t\\tc -= 1\\n\\t\\telse: return True\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```M[r][c]```\n```x```\n```M[r][ :c] ```\n```x```\n``` r += 1```\n```M[r][c]```\n```x```\n```c -= 1```\n```M[ :r][c ]```\n```x```\n```x```\n```True```\n```x```\n```\\ndef searchMatrix(matrix, target):\\n\\tm, n = len(matrix), len(matrix) and len(matrix[0])\\n\\tr, c = 0, n-1\\n\\twhile r < m and c >= 0:\\n\\t\\tif target > matrix[r][c]:\\n\\t\\t\\tr += 1\\n\\t\\telif target < matrix[r][c]:\\n\\t\\t\\tc -= 1\\n\\t\\telse: return True\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2324616,
                "title": "java-c-full-visuall-explanation",
                "content": "Hello, **Ladies-N-Gentlemen** today we are going to solve a another easy-peasy question.\\n\\nI hope so, that questions is clear what it is all are talking about. Because, question statement is very clear!!\\n\\n```\\n# Brute Force Approach\\n```\\nSo, let\\'s talk about what will be **`Brute Force approach` to solve this problem.**\\n\\nThe very brute-force approach is, we will traverse it\\'s every row & column of the matrix.\\n\\n**Let\\'s understand it visually,**\\n\\n![image](https://assets.leetcode.com/users/images/01f6dc7a-0662-47d6-ab59-a9c196f332a8_1658635775.4245615.gif)\\n\\n\\n**JAVA**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                if(matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nANALYSIS :-\\nAs, you are seeing we are traversing it\\'s all row and column therefore the **Time Complexity** will be **`O(N^2)`** And the **Space Complexity** will be **`O(1)`**\\n\\n```\\n# Better Approach\\n```\\nLet\\'s take an example to understand this approach,\\n\\n![image](https://assets.leetcode.com/users/images/17612fa0-eaeb-4e73-bf78-e65c2c87bf09_1658633211.0689182.png)\\n\\nSo, what we gonna do is we will start traversing from **`top-right corner`** or you can even start from **`bottom-left corner`**. Now you\\'ll ask why not from **top-left OR bottom-right?** Well, there\\'s a reason why not from there, we\\'ll come to this point later on.\\n\\n**`Now, let\\'s start traversing and understand it\\'s visaully`**\\n\\n**`Note :-`** \\n\\n![image](https://assets.leetcode.com/users/images/b6e5483e-07e9-4200-9a5e-9a3d38307ae1_1658634345.6110325.png)\\n\\n![image](https://assets.leetcode.com/users/images/2a424696-79ea-47f1-82fe-836a00afa034_1658634181.3804603.gif)\\n\\n\\nSo, what we are doing you got the idea,\\n* If value is **`>`** then target, then move to **left i.e. j--**\\n\\n\\n* If value is **`<`** then target, then move **down i.e. i++** \\n* If value is **`==`** to target, **return true**\\n* Else **return false**\\n\\nNow, let\\'s code it up:-\\n**Java**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].length - 1;\\n        \\n        while(i >= 0 && i < matrix.length && j >= 0 && j < matrix[0].length){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else if(matrix[i][j] < target) i++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].size() - 1;\\n        \\n        while(i >= 0 && i < matrix.size() && j >= 0 && j < matrix[0].size()){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else if(matrix[i][j] < target) i++;\\n        }\\n        return false;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** It will be **`O(row + column)`** because we are traversing every row & column only once\\n\\n* **Space Complexity :-** It will be **`O(1)`** as we are not using any extra memory OR space",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n# Brute Force Approach\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i = 0; i < matrix.size(); i++){\\n            for(int j = 0; j < matrix[0].size(); j++){\\n                if(matrix[i][j] == target) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n# Better Approach\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].length - 1;\\n        \\n        while(i >= 0 && i < matrix.length && j >= 0 && j < matrix[0].length){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else if(matrix[i][j] < target) i++;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].size() - 1;\\n        \\n        while(i >= 0 && i < matrix.size() && j >= 0 && j < matrix[0].size()){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else if(matrix[i][j] < target) i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079154,
                "title": "python-o-m-n-solution-explained",
                "content": "Let us consider the following example and discuss the algorithm.\\n\\n| 1  | 4  | 7  | 11 | 15 |\\n|----|----|----|----|----|\\n| **2**  | **5**  | **8**  | **12** | **19** |\\n| **3**  | **6**  | **9**  | **16** | **22** |\\n| **10** | **13** | **14** | **17** | **24** |\\n| **18** | **21** | **23** | **26** | **30** |\\n\\nLet us start with element on the top right corner and on each step we decide where we can go.\\n\\n1. Current number is equal to **15**, and `target = 5`, where can we go? All numbers above `15` is more than `15`, so we can eliminate last column and go to the left.\\n2. Current number is equal to **11** and again it is bigger than `target = 5`, so we eliminate column and go to the left\\n3. Current number is equal to **7**, go to the left.\\n4. Current number is **4**, now it is smaller than target, so we can eliminate first row: elements to the left is smaller than `4` and elements to the right already eliminated in columns.\\n5. Current number is **5** and we found our target.\\n\\nIt also can happen, that we do not found number, in this case we need to terminate, when we can not move anymore.\\n\\n**Complexity**: time complexity is `O(m + n)`, where `m, n` are number of columns and rows: on each step we eliminate either row or column. Space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        x, y = len(matrix[0]) - 1, 0\\n        while x >= 0 and y < len(matrix):\\n            if matrix[y][x] > target:\\n                x -= 1\\n            elif matrix[y][x] < target:\\n                y += 1\\n            else:\\n                return True\\n        return False\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        x, y = len(matrix[0]) - 1, 0\\n        while x >= 0 and y < len(matrix):\\n            if matrix[y][x] > target:\\n                x -= 1\\n            elif matrix[y][x] < target:\\n                y += 1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66168,
                "title": "4-lines-c-6-lines-ruby-7-lines-python-1-liners",
                "content": "Same O(m+n) method as most, just a bit different style/languages.\\n\\n---\\n\\n**C**\\n\\nCheck the top-right corner. If it's not the target, then remove the top row or rightmost column.\\n\\n    bool searchMatrix(int** A, int m, int n, int target) {\\n        int x = ~target;\\n        while (m && n && (x = A[0][n-1]) != target)\\n            x < target ? A++, m-- : n--;\\n        return x == target;\\n    }\\n\\n**Ruby**\\n\\n    def search_matrix(matrix, target)\\n        j = -1\\n        matrix.each { |row|\\n            j -= 1 while row[j] && row[j] > target\\n            return true if row[j] == target\\n        }\\n        false\\n    end\\n\\n**Python**\\n\\n    def searchMatrix(self, matrix, target):\\n        j = -1\\n        for row in matrix:\\n            while j + len(row) and row[j] > target:\\n                j -= 1\\n            if row[j] == target:\\n                return True\\n        return False\\n\\n**1-liners**\\n\\nRelax, I know they're O(mn). This is just for fun (although they did get accepted):\\n\\nPython (204 ms):\\n\\n    def searchMatrix(self, matrix, target):\\n        return any(target in row for row in matrix)\\n\\nRuby (828 ms):\\n\\n    def search_matrix(matrix, target)\\n        matrix.any? { |row| row.include? target }\\n    end",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "Same O(m+n) method as most, just a bit different style/languages.\\n\\n---\\n\\n**C**\\n\\nCheck the top-right corner. If it's not the target, then remove the top row or rightmost column.\\n\\n    bool searchMatrix(int** A, int m, int n, int target) {\\n        int x = ~target;\\n        while (m && n && (x = A[0][n-1]) != target)\\n            x < target ? A++, m-- : n--;\\n        return x == target;\\n    }\\n\\n**Ruby**\\n\\n    def search_matrix(matrix, target)\\n        j = -1\\n        matrix.each { |row|\\n            j -= 1 while row[j] && row[j] > target\\n            return true if row[j] == target\\n        }\\n        false\\n    end\\n\\n**Python**\\n\\n    def searchMatrix(self, matrix, target):\\n        j = -1\\n        for row in matrix:\\n            while j + len(row) and row[j] > target:\\n                j -= 1\\n            if row[j] == target:\\n                return True\\n        return False\\n\\n**1-liners**\\n\\nRelax, I know they're O(mn). This is just for fun (although they did get accepted):\\n\\nPython (204 ms):\\n\\n    def searchMatrix(self, matrix, target):\\n        return any(target in row for row in matrix)\\n\\nRuby (828 ms):\\n\\n    def search_matrix(matrix, target)\\n        matrix.any? { |row| row.include? target }\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 2324351,
                "title": "python-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**EFFICIENT APPROACH -> O ( M + N )**\\n\\nAs the rows are sorted **->** ```matrix[i][j] < matrix[i][j+1]```\\nAs the columns are sorted **->** ```matrix[i][j] >matrix[i-1][j]```\\n\\nHence it can be said that :\\n* any element right to ```matrix[i][j]``` will be greater than it.\\n* any element to the top of ```matrix[i][j]``` will be less than it.\\n\\nSo we start searching from **BOTTOM_LEFT**:\\n* if element found -> return **TRUE**\\n* if ```matrix[i][j] > target``` -> move **UP**.\\n* if ```matrix[i][j] < target``` -> move **RIGHT**.\\n\\n![image](https://assets.leetcode.com/users/images/ffcde87b-6220-4e61-a2ec-498abc7fd28d_1658626864.8423152.png)\\n\\n**UPVOTE IF HELPFuuL**\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        i=m-1\\n        j=0\\n        \\n        while i>=0 and j<n:\\n            if mat[i][j]==target:\\n                return True\\n            elif mat[i][j]<target:\\n                j+=1\\n            else:\\n                i-=1\\n                \\n        return False\\n```\\n\\n**EFFICIENT APPROACH -> O ( M LOG N )**\\nAs all the rows are sorted , an element can be clearly searched using *BINARY-SEARCH* for each row.\\n\\nFor each row -> O ( M )\\nBinary search -> O ( LOG N )\\n\\n**UPVOTE IF HELPFuuL**\\n\\n**BINARY SEARCH SOLUTION**\\n```\\nclass Solution:\\n    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        for i in range(m):\\n            if mat[i][0]<=target and mat[i][-1]>=target:\\n                lo=0\\n                hi=n\\n                while (lo<hi):\\n                    mid=(lo+hi)//2\\n                    \\n                    if mat[i][mid]==target:\\n                        return True\\n                    elif mat[i][mid]<target:\\n                        lo = mid + 1\\n                    else:\\n                        hi = mid\\n                        \\n        return False\\n```\\n![image](https://assets.leetcode.com/users/images/ae27af7f-fbb5-4d4a-be95-2faab90e51b9_1658629526.2394886.webp)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```matrix[i][j] < matrix[i][j+1]```\n```matrix[i][j] >matrix[i-1][j]```\n```matrix[i][j]```\n```matrix[i][j]```\n```matrix[i][j] > target```\n```matrix[i][j] < target```\n```\\nclass Solution:\\n    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        i=m-1\\n        j=0\\n        \\n        while i>=0 and j<n:\\n            if mat[i][j]==target:\\n                return True\\n            elif mat[i][j]<target:\\n                j+=1\\n            else:\\n                i-=1\\n                \\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, mat: List[List[int]], target: int) -> bool:\\n        \\n        m=len(mat)\\n        n=len(mat[0])\\n        \\n        for i in range(m):\\n            if mat[i][0]<=target and mat[i][-1]>=target:\\n                lo=0\\n                hi=n\\n                while (lo<hi):\\n                    mid=(lo+hi)//2\\n                    \\n                    if mat[i][mid]==target:\\n                        return True\\n                    elif mat[i][mid]<target:\\n                        lo = mid + 1\\n                    else:\\n                        hi = mid\\n                        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66247,
                "title": "java-short-code-o-m-n",
                "content": "    public class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m=matrix.length, n=matrix[0].length, i=0, j=n-1;\\n        while (i<m && j>=0) {\\n            if (matrix[i][j]==target) return true;\\n            else if (matrix[i][j]<target) i++;\\n            else j--;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m=matrix.length, n=matrix[0].length, i=0, j=n-1;\\n        while (i<m && j>=0) {\\n            if (matrix[i][j]==target) return true;\\n            else if (matrix[i][j]<target) i++;\\n            else j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 66163,
                "title": "c-two-solutions-o-m-n-o-mlogn",
                "content": "1. O(m+n) solution\\n\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].size() - 1;\\n        \\n        while(i < matrix.size() && j >= 0) {\\n            if(matrix[i][j] == target)\\n                return true;\\n            \\n            if(matrix[i][j] < target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        \\n        return false;\\n        }\\n\\n\\n\\n\\n2. O(mlogn) solution\\n\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\t\\treturn searchMatrix(matrix, target, 0, matrix.size() - 1);\\n\\t    }\\n\\n\\t    bool searchMatrix(vector<vector<int>>& matrix, int target, int top, int bottom) {\\n\\t\\tif (top > bottom)\\n\\t\\t\\treturn false;\\n\\n\\t\\tint mid = top + (bottom - top) / 2;\\n\\t\\tif (matrix[mid].front() <= target && target <= matrix[mid].back())\\n\\t\\t\\tif (searchVector(matrix[mid], target)) return true;\\n\\n\\t\\tif (searchMatrix(matrix, target, top, mid - 1)) return true;\\n\\t\\tif (searchMatrix(matrix, target, mid + 1, bottom)) return true;\\n\\n\\t\\treturn false;\\n\\t    }\\n\\n\\t    bool searchVector(vector<int>& v, int target) {\\n\\t\\tint left = 0, right = v.size() - 1;\\n\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tint mid = left + (right - left) / 2;\\n\\t\\t\\tif (v[mid] == target)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif (v[mid] < target)\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t    }",
                "solutionTags": [],
                "code": "1. O(m+n) solution\\n\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n        int j = matrix[0].size() - 1;\\n        \\n        while(i < matrix.size() && j >= 0) {\\n            if(matrix[i][j] == target)\\n                return true;\\n            \\n            if(matrix[i][j] < target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        \\n        return false;\\n        }\\n\\n\\n\\n\\n2. O(mlogn) solution\\n\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\t\\treturn searchMatrix(matrix, target, 0, matrix.size() - 1);\\n\\t    }\\n\\n\\t    bool searchMatrix(vector<vector<int>>& matrix, int target, int top, int bottom) {\\n\\t\\tif (top > bottom)\\n\\t\\t\\treturn false;\\n\\n\\t\\tint mid = top + (bottom - top) / 2;\\n\\t\\tif (matrix[mid].front() <= target && target <= matrix[mid].back())\\n\\t\\t\\tif (searchVector(matrix[mid], target)) return true;\\n\\n\\t\\tif (searchMatrix(matrix, target, top, mid - 1)) return true;\\n\\t\\tif (searchMatrix(matrix, target, mid + 1, bottom)) return true;\\n\\n\\t\\treturn false;\\n\\t    }\\n\\n\\t    bool searchVector(vector<int>& v, int target) {\\n\\t\\tint left = 0, right = v.size() - 1;\\n\\n\\t\\twhile (left <= right) {\\n\\t\\t\\tint mid = left + (right - left) / 2;\\n\\t\\t\\tif (v[mid] == target)\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif (v[mid] < target)\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tright = mid - 1;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1079514,
                "title": "c-binary-search-2-variations-o-m-n-explanation-with-example-diagram",
                "content": "**EXPLANATION**\\nConsider the below diagram.\\n\\n![image](https://assets.leetcode.com/users/images/9d344366-1ff3-4fbe-930d-3aaff907f204_1614093877.1058805.png)\\n\\n**Target** : Green (13), **Starting point** : Yellow (15).\\n **Traversal Path** : Orange (15 -> 11, 12, 16, 9, 14 ->13).\\n\\n- Start iterating the `matrix` from **top right corner** of the `matrix`, that is `matrix[0][size of column -1]`.\\n- If `matrix[i][j]==target`, return **true**.\\n- If the `target` is less than `matrix[i][j]`, then move **leftwards** (*decrease the column*), that is `--j`.\\n- If the `target` is greater than `matrix[i][j]`, then move **downwards** (*increase the row*), that is `++i`.\\n\\n- If the `target` element is *not found* then after *exiting* the above loop, return **false**.\\n\\n**CODE IMPLEMENTATION (Variation 1)**\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [first row, last column] element\\n        int i=0;\\n        int j=m-1;\\n        while(i<n && j>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller, go leftwards\\n                --j; // decrease the column index\\n            else // target is larger, go downwards\\n                ++i; // increase the row index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```\\n\\nConsidering, *m* = length of column and *n* =  length of row.\\n\\n**TIME COMPLEXITY: O(m+n)**\\nFor any case, the path traversed will be the shortest path from the top right corner to the target element. Say target element is at `[ti, tj]` and top right corner (*starting index*) is `[0,m - 1]`, so the total path traversed will be `[ti - 0, (m - 1) - tj]`, so the time taken is `O(ti + m - 1 - tj)`. Now, according to the constraints given in question, the worst case will be when `ti = n-1` and `tj = 0`, that is target element is at `matrix[n-1, 0]`. So, the worst-case time complexity will be `O(n - 1 + m  - 1 - 0)`, that is `O(n + m)` (asymptotically).\\n\\n**SPACE COMPLEXITY: O(1)**\\nNo extra space is used.\\n\\n\\n**CODE IMPLEMENTATION (Variation 2)**\\nAs suggested by [@Niks291](https://leetcode.com/Niks291), we can also start from the **bottom left corner** of the `matrix`, that is from `matrix[size of row - 1][0]` along with changing some conditions within the loop.\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [last row, first column] element\\n        int i=n-1;\\n        int j=0;\\n        while(j<m && i>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller go upwards\\n                --i; // decrease the row index\\n            else // target is larger go rightwards\\n                ++j; // increase the column index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [first row, last column] element\\n        int i=0;\\n        int j=m-1;\\n        while(i<n && j>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller, go leftwards\\n                --j; // decrease the column index\\n            else // target is larger, go downwards\\n                ++i; // increase the row index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [last row, first column] element\\n        int i=n-1;\\n        int j=0;\\n        while(j<m && i>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller go upwards\\n                --i; // decrease the row index\\n            else // target is larger go rightwards\\n                ++j; // increase the column index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66207,
                "title": "my-c-soluation-using-binary-search-tree-model-beats-100",
                "content": "at first i use binary search method, but i found it's hard to pruning Redundant situation,and i just found we can treat the left bottom as a root of a BST so we only need o(m+N) to find the target.\\n\\n    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int row = matrix.size();\\n            int col = matrix[0].size();\\n            int i = row-1,j =0;\\n            while(i>=0&&j<=col-1)\\n            {\\n                if(target>matrix[i][j])\\n                {\\n                    j++;\\n                }\\n                else if(target<matrix[i][j])\\n                {\\n                    i--;\\n                }\\n                else\\n                {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int row = matrix.size();\\n            int col = matrix[0].size();\\n            int i = row-1,j =0;\\n            while(i>=0&&j<=col-1)\\n            {\\n                if(target>matrix[i][j])\\n                {\\n                    j++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 148444,
                "title": "java-solution-using-binary-search-with-comments-96",
                "content": "```\\nclass Solution {\\n    int[][] matrix;\\n    int target;\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        this.matrix = matrix;\\n        this.target = target;\\n        if(matrix.length==0)\\n            return false;\\n        return helper(0, 0, matrix.length-1, matrix[0].length-1);\\n    }\\n    /**\\n    * @param x1, row coordinate of top left element of the matrix\\n    * @param y1, column coordinate of top left elemeent of the matrix\\n    * @param x2, row coordinate of bottom right element of the matrix\\n    * @param y2, column coordinate of bottom right element of the matrix\\n    */\\n    private boolean helper(int x1, int y1, int x2, int y2){\\n        if(x2<x1 || y2<y1 || x1>=matrix.length || y1>=matrix[0].length || x2<0 || y2<0)\\n            return false;\\n        int mx = (x2-x1)/2+x1;\\n        int my = (y2-y1)/2+y1;\\n        // Check the middle element of the matrix, if not found, \\n        // recursively call on sub matrices where\\n        // the value could still exist. \\n        // You will realize that the resultant possible places will\\n        // form a L shape on the original matrix.\\n        // This L shape can be broken down into 2 matrices.\\n        // If number found in any of the 2 matrices, we return true.\\n        if(matrix[mx][my]==target)\\n            return true;\\n        else if(matrix[mx][my]<target){\\n            return helper(x1,my+1,x2,y2) || helper(mx+1,y1,x2,my);\\n        }else if(matrix[mx][my]>target){\\n            return helper(x1,y1,x2,my-1) || helper(x1,my,mx-1,y2);\\n        }else\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] matrix;\\n    int target;\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        this.matrix = matrix;\\n        this.target = target;\\n        if(matrix.length==0)\\n            return false;\\n        return helper(0, 0, matrix.length-1, matrix[0].length-1);\\n    }\\n    /**\\n    * @param x1, row coordinate of top left element of the matrix\\n    * @param y1, column coordinate of top left elemeent of the matrix\\n    * @param x2, row coordinate of bottom right element of the matrix\\n    * @param y2, column coordinate of bottom right element of the matrix\\n    */\\n    private boolean helper(int x1, int y1, int x2, int y2){\\n        if(x2<x1 || y2<y1 || x1>=matrix.length || y1>=matrix[0].length || x2<0 || y2<0)\\n            return false;\\n        int mx = (x2-x1)/2+x1;\\n        int my = (y2-y1)/2+y1;\\n        // Check the middle element of the matrix, if not found, \\n        // recursively call on sub matrices where\\n        // the value could still exist. \\n        // You will realize that the resultant possible places will\\n        // form a L shape on the original matrix.\\n        // This L shape can be broken down into 2 matrices.\\n        // If number found in any of the 2 matrices, we return true.\\n        if(matrix[mx][my]==target)\\n            return true;\\n        else if(matrix[mx][my]<target){\\n            return helper(x1,my+1,x2,y2) || helper(mx+1,y1,x2,my);\\n        }else if(matrix[mx][my]>target){\\n            return helper(x1,y1,x2,my-1) || helper(x1,my,mx-1,y2);\\n        }else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66194,
                "title": "python-o-m-n-with-clear-search-strategy",
                "content": "\\n\\n    class Solution:\\n        # @param {integer[][]} matrix\\n        # @param {integer} target\\n        # @return {boolean}\\n        def searchMatrix(self, matrix, target):\\n            if matrix:\\n                row,col,width=len(matrix)-1,0,len(matrix[0])\\n                while row>=0 and col<width:\\n                    if matrix[row][col]==target:\\n                        return True\\n                    elif matrix[row][col]>target:\\n                        row=row-1\\n                    else:\\n                        col=col+1\\n                return False",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[][]}",
                "codeTag": "Java"
            },
            {
                "id": 2324496,
                "title": "java-simple-and-easy-solution",
                "content": "PLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length, m=matrix[0].length;\\n        int i=0, j=m-1;\\n        while(i<n&&j>=0){\\n            if(target==matrix[i][j])\\n                return true;\\n            if(target>matrix[i][j])\\n                i+=1;\\n            else\\n                j-=1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n=matrix.length, m=matrix[0].length;\\n        int i=0, j=m-1;\\n        while(i<n&&j>=0){\\n            if(target==matrix[i][j])\\n                return true;\\n            if(target>matrix[i][j])\\n                i+=1;\\n            else\\n                j-=1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526439,
                "title": "c-simple-solution-100-faster",
                "content": "**C++ :**\\n\\n```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\tint row = 0;\\n\\tint col = matrix[0].size() - 1;\\n\\n\\twhile(row < matrix.size() && col >= 0)\\n\\t{\\n\\t\\tif(matrix[row][col] == target)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif(matrix[row][col] < target)\\n\\t\\t\\t++row;\\n\\n\\t\\telse\\n\\t\\t\\t--col;\\n\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\tint row = 0;\\n\\tint col = matrix[0].size() - 1;\\n\\n\\twhile(row < matrix.size() && col >= 0)\\n\\t{\\n\\t\\tif(matrix[row][col] == target)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif(matrix[row][col] < target)\\n\\t\\t\\t++row;\\n\\n\\t\\telse\\n\\t\\t\\t--col;\\n\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934056,
                "title": "binary-search-in-a-2d-matrix-with-explanation",
                "content": "Hello!\\n\\nI\\'ve just looked through a bunch of solutions and most of them were brute force. \\nSo I\\'ve decided post a solution with the binary search approach with explantion.\\n\\n```\\nvar searchMatrix = function(matrix, target) {\\n     if(!matrix || !matrix.length) return false;\\n    \\n    const rows = matrix.length;\\n    const cols = matrix[0].length;\\n    \\n    function hasTarget(startRow, endRow, startCol, endCol) {\\n\\t\\t// recursion base case\\n        if(startRow > endRow || startCol > endCol) return false;\\n        \\n\\t\\t// find middle of the matrix\\n        const middleRow = Math.floor((endRow - startRow) / 2) + startRow;\\n        const middleCol = Math.floor((endCol - startCol) / 2) + startCol;\\n        \\n\\t\\t// if we found the target we solve the problem, so return true  \\n        if(matrix[middleRow][middleCol] === target) return true;\\n        \\n\\t\\t// it is the \"devide\" step, basically, we define the recurrence relation for the recursion function.\\n        if (matrix[middleRow][middleCol] < target) {\\n\\t\\t\\t// let m - is our middle point.\\n\\t\\t\\t// if m less than the target than all points before m also less tha target (marked by x)\\n\\t\\t\\t// so we only need look through cells marked by 1 and 2\\n\\t\\t\\t// x x x 2 2\\n\\t\\t\\t// x x x 2 2\\n\\t\\t\\t// x x m 2 2\\n\\t\\t\\t// 1 1 1 1 1\\n\\t\\t\\t// 1 1 1 1 1\\n            return hasTarget(middleRow + 1, endRow, startCol, endCol) ||\\n                   hasTarget(startRow, middleRow, middleCol + 1, endCol);\\n        } else {\\n\\t\\t\\t// let m - is our middle point.\\n\\t\\t\\t// if m more than the target than all points after m also bigger than the target (marked by x)\\n\\t\\t\\t// so we only need look through cells marked by 1 and 2\\n\\t\\t\\t// 1 1 2 2 2\\n\\t\\t\\t// 1 1 2 2 2\\n\\t\\t\\t// 1 1 m x x\\n\\t\\t\\t// 1 1 x x x\\n\\t\\t\\t// 1 1 x x x\\n            return hasTarget(startRow, endRow, startCol, middleCol - 1) ||\\n                   hasTarget(startRow, middleRow - 1, middleCol, endCol);\\n        }\\n    }\\n    \\n    return hasTarget(0, rows - 1, 0, cols - 1);\\n}\\n```\\n\\nHappy coding!\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nvar searchMatrix = function(matrix, target) {\\n     if(!matrix || !matrix.length) return false;\\n    \\n    const rows = matrix.length;\\n    const cols = matrix[0].length;\\n    \\n    function hasTarget(startRow, endRow, startCol, endCol) {\\n\\t\\t// recursion base case\\n        if(startRow > endRow || startCol > endCol) return false;\\n        \\n\\t\\t// find middle of the matrix\\n        const middleRow = Math.floor((endRow - startRow) / 2) + startRow;\\n        const middleCol = Math.floor((endCol - startCol) / 2) + startCol;\\n        \\n\\t\\t// if we found the target we solve the problem, so return true  \\n        if(matrix[middleRow][middleCol] === target) return true;\\n        \\n\\t\\t// it is the \"devide\" step, basically, we define the recurrence relation for the recursion function.\\n        if (matrix[middleRow][middleCol] < target) {\\n\\t\\t\\t// let m - is our middle point.\\n\\t\\t\\t// if m less than the target than all points before m also less tha target (marked by x)\\n\\t\\t\\t// so we only need look through cells marked by 1 and 2\\n\\t\\t\\t// x x x 2 2\\n\\t\\t\\t// x x x 2 2\\n\\t\\t\\t// x x m 2 2\\n\\t\\t\\t// 1 1 1 1 1\\n\\t\\t\\t// 1 1 1 1 1\\n            return hasTarget(middleRow + 1, endRow, startCol, endCol) ||\\n                   hasTarget(startRow, middleRow, middleCol + 1, endCol);\\n        } else {\\n\\t\\t\\t// let m - is our middle point.\\n\\t\\t\\t// if m more than the target than all points after m also bigger than the target (marked by x)\\n\\t\\t\\t// so we only need look through cells marked by 1 and 2\\n\\t\\t\\t// 1 1 2 2 2\\n\\t\\t\\t// 1 1 2 2 2\\n\\t\\t\\t// 1 1 m x x\\n\\t\\t\\t// 1 1 x x x\\n\\t\\t\\t// 1 1 x x x\\n            return hasTarget(startRow, endRow, startCol, middleCol - 1) ||\\n                   hasTarget(startRow, middleRow - 1, middleCol, endCol);\\n        }\\n    }\\n    \\n    return hasTarget(0, rows - 1, 0, cols - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1079051,
                "title": "c-super-simple-and-easy-concise-6-lines-o-n-m-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0, col = matrix[0].size()-1;\\n        \\n        while (row < matrix.size() && col >= 0) {\\n            \\n            if (target == matrix[row][col])\\n                return true;\\n            \\n            target > matrix[row][col] ? row++ : col--;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0, col = matrix[0].size()-1;\\n        \\n        while (row < matrix.size() && col >= 0) {\\n            \\n            if (target == matrix[row][col])\\n                return true;\\n            \\n            target > matrix[row][col] ? row++ : col--;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513112,
                "title": "java-tc-o-r-c-sc-o-1-optimal-solution-using-elimination-strategy",
                "content": "```java\\n/**\\n * Search from Top left corner.\\n *\\n * If target is less than top left corner, then we can safely reduce the column\\n * index as all the below values in column will be greater than the target.\\n *\\n * Similarly if the target is more than the top left corner, then we can safely\\n * increase the row index as all the left values in the row will be smaller than\\n * the target.\\n *\\n * Time Complexity: O(R + C)\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n\\n        int row = 0;\\n        int col = matrix[0].length - 1;\\n\\n        while (row < matrix.length && col >= 0) {\\n            if (matrix[row][col] == target) {\\n                return true;\\n            }\\n            if (target < matrix[row][col]) {\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Search a 2D Matrix question on LeetCode:\\n- [74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/discuss/1511703/Java-or-TC:-O(log(R*C))-or-SC:-O(1)-or-Optimized-binary-search-solution)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Search from Top left corner.\\n *\\n * If target is less than top left corner, then we can safely reduce the column\\n * index as all the below values in column will be greater than the target.\\n *\\n * Similarly if the target is more than the top left corner, then we can safely\\n * increase the row index as all the left values in the row will be smaller than\\n * the target.\\n *\\n * Time Complexity: O(R + C)\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n\\n        int row = 0;\\n        int col = matrix[0].length - 1;\\n\\n        while (row < matrix.length && col >= 0) {\\n            if (matrix[row][col] == target) {\\n                return true;\\n            }\\n            if (target < matrix[row][col]) {\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552311,
                "title": "binary-search-the-easiest-to-understand-approach",
                "content": "We are given that the rows of the matrix are sorted  and so are the columns. We make use of this.\\n\\ne.g. \\n\\t\\t\\t\\n\\t\\t   1  3  5  7\\n\\t\\t   10 11 16 20\\n\\t\\t   23 30 34 60\\n\\t\\t   \\nThis means, we can start searching from the top rightmost element in this matrix, which currently is = 7.\\n\\nWhy top rightmost only? Because if you see carefully, all elements on the bottom of it are bigger than it. And all elements to the left of it are smaller than it. We can use this property and apply Binary Search.\\n\\nLets say our target element is  = 11\\n\\nWe are at element = 7. We see that 11 is > 7 so that means we can discard all the cells that are on left of 7 because we will never find 11 on that side. So we will move to bottom i.e, we go to next row. \\n\\nNow we are at 20. Here we see that 11 is less than 20. This means we can discard all the cells on the bottom side as the elements on the bottom of 20 are greater than 20 and hence greater than 11. We we move to left side i.e., go to previous column.\\n\\nNow we are at 16. Again, since 16 > 11, we have to move to left. So we come to previous column.\\n\\nNow we reach 11. And this is our target value so we return True since we found 11.\\n\\nSuppose we had to find 40. It is not present in this matrix.  SO first, we start from 7, since 7 < 40, we move to bottom side. Since 20 < 40 we again move to bottom. Since 60 > 40, we move to left. Since 34 < 40, we should move to bottom again. But wait! We are already at the last row and so we cannot move to bottom anymore\\n\\n\\nThis will be one of the conditions for our Binary Search. If the row number exceeds the maximum possible row number in the matrix, then we have to come out of our loop.\\n\\nNow take another example - Lets say we want to search 4.\\n\\nThe sequences will be like this - \\n\\nWe start from 7, since 7 > 4, we move to left of 7. \\nWe reach 5. Since 5 > 4, we move to left of 5.\\nWe reach 3. Since 3 < 4, we move to bottom side.\\nWe reach 11. Since 11 > 4, we move to left side\\nWe reach 10. Since 10 > 4, we move to left.\\n\\nBut wait! Our column became -1 because we were already at 0th column when we were at 10. So that means, if our column index becomes less than 0, then we have to stop.\\n\\nAnd well, that\\'s it. \\n\\n# **CODE**\\n\\n```\\ndef searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        \\n        #We start from the top right corner of the matrix.\\n        row = 0\\n        col = len(matrix[0])-1\\n        \\n        # In this way, on the bottom side, all elements are bigger than current element\\n        # At left side, all elements are smaller than the current element\\n        \\n        while(row < n and col >= 0):\\n            mid = matrix[row][col]\\n            \\n            #If the element at this position is the target element we return True\\n            if(mid == target): return True\\n            \\n            # If the element is smaller than this position that means, we need to go to left side of current element\\n            if(mid > target): col -= 1\\n            #Otherwise we need to move to bottom side\\n            else: row += 1\\n        \\n        return False\\n```\\n\\nThis same approach also works for the \"Search a 2D Matrix\" problem because while in that problem it is not explicitly mentioned that columns are sorted, they are sorted because each row is sorted and the first element of each row is greater than last element of previous row. Here is the problem - https://leetcode.com/problems/search-a-2d-matrix/\\n\\n## **GOING ONE STEP FURTHER**\\n\\nJust like how we can start searching from top rightmost element, we can start searching from bottom leftmost element too. Because in case of bottom left most element, all elements above it are smaller than it and all elements on the right of it are bigger than it.\\n\\nBut what if we combine both these approaches?\\n\\n```\\ndef searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n\\t\\t\\n        #Top rightmost corner\\n        row1 = 0\\n        col1 = m-1\\n        \\n        #Bottom leftmost corner\\n        row2 = n - 1\\n        col2 = 0\\n        \\n        #The last condition is to avoid again going to the rows and columns that are already covered\\n        while(row1 < n and col1 >= 0 and row2 >= 0 and col2 < m and (col2 <= col1 and row2 >= row1)):\\n            mid1 = matrix[row1][col1]\\n            mid2 = matrix[row2][col2]\\n            \\n            # If the element is smaller than mid1 that means we need to move to left side\\n            if(mid1 > target): col1 -= 1\\n            #Otherwise we need to move to bottom side\\n            elif (mid1 < target): row1 += 1\\n            \\n            # If the element is smaller than mid2 that means we need to move to top side\\n            elif(mid2 > target): row2 -= 1\\n            #Otherwise we need to move to right side\\n            elif(mid2 < target): col2 += 1\\n            \\n            else: return True\\n                \\n        \\n        return False\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        \\n        #We start from the top right corner of the matrix.\\n        row = 0\\n        col = len(matrix[0])-1\\n        \\n        # In this way, on the bottom side, all elements are bigger than current element\\n        # At left side, all elements are smaller than the current element\\n        \\n        while(row < n and col >= 0):\\n            mid = matrix[row][col]\\n            \\n            #If the element at this position is the target element we return True\\n            if(mid == target): return True\\n            \\n            # If the element is smaller than this position that means, we need to go to left side of current element\\n            if(mid > target): col -= 1\\n            #Otherwise we need to move to bottom side\\n            else: row += 1\\n        \\n        return False\\n```\n```\\ndef searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n\\t\\t\\n        #Top rightmost corner\\n        row1 = 0\\n        col1 = m-1\\n        \\n        #Bottom leftmost corner\\n        row2 = n - 1\\n        col2 = 0\\n        \\n        #The last condition is to avoid again going to the rows and columns that are already covered\\n        while(row1 < n and col1 >= 0 and row2 >= 0 and col2 < m and (col2 <= col1 and row2 >= row1)):\\n            mid1 = matrix[row1][col1]\\n            mid2 = matrix[row2][col2]\\n            \\n            # If the element is smaller than mid1 that means we need to move to left side\\n            if(mid1 > target): col1 -= 1\\n            #Otherwise we need to move to bottom side\\n            elif (mid1 < target): row1 += 1\\n            \\n            # If the element is smaller than mid2 that means we need to move to top side\\n            elif(mid2 > target): row2 -= 1\\n            #Otherwise we need to move to right side\\n            elif(mid2 < target): col2 += 1\\n            \\n            else: return True\\n                \\n        \\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2324412,
                "title": "python3-9-lines-w-explanation-t-m-84-82",
                "content": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #   \\u2022 We start in the bottom-left corner, which is \\n                        #     matrix[-1][0]. Obviously, the target cell cannot\\n                        #     be either below or to the left of this corner cell\\n                        #  \\n                        #   \\u2022 We move incrementally from the corner such that we \\n                        #     do not pass to right of the target\\'s column or above\\n                        #     its row; we can ensure this by exploiting the sorted \\n                        #     rows and columns. For example (below), the target \\n                        #     is 8 and and the corner is 18. So:\\n                        #               -- 18 > 8 =>  move up    to 10,\\n                        #               -- 10 > 8 =>  move up    to  3,\\n                        #               --  3 < 8 =>  move right to  6,\\n                        #               --  6 < 8 =>  move right to  9,\\n                        #               --  9 > 8 =>  move up    to  8.\\n```\\n![image](https://assets.leetcode.com/users/images/9e8737fd-576b-47a6-8f22-026b209f0181_1658626054.8534317.jpeg)\\n\\n```\\n\\n\\n        def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\\n        \\n            row, col =   len(matrix)-1, 0        # <-- start at corner\\n\\n            while row >=0 and col <= len(matrix[0])-1:  \\n                cell = matrix[row][col]\\n\\n                if cell > target:               # <-- go up \\n                    row-= 1\\n                elif cell < target:             # <-- go right\\n                    col+= 1\\n                else: return True               # <-- target found\\n\\n            return  False\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #   \\u2022 We start in the bottom-left corner, which is \\n                        #     matrix[-1][0]. Obviously, the target cell cannot\\n                        #     be either below or to the left of this corner cell\\n                        #  \\n                        #   \\u2022 We move incrementally from the corner such that we \\n                        #     do not pass to right of the target\\'s column or above\\n                        #     its row; we can ensure this by exploiting the sorted \\n                        #     rows and columns. For example (below), the target \\n                        #     is 8 and and the corner is 18. So:\\n                        #               -- 18 > 8 =>  move up    to 10,\\n                        #               -- 10 > 8 =>  move up    to  3,\\n                        #               --  3 < 8 =>  move right to  6,\\n                        #               --  6 < 8 =>  move right to  9,\\n                        #               --  9 > 8 =>  move up    to  8.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204059,
                "title": "python-solution",
                "content": "Starting with the bottom left corner of the matrix, if the current element `curr` equals `target`, we return `True`. If `curr` is larger than `target`, than since any element to the right of `curr` (in the same row) is larger than `curr`, we don\\'t need to consider them, so we deduct the row index by 1 (move up by 1 row). By the same token, if `curr` is smaller than `target`, we increase the column index by 1 (move right by 1 column). Repeat the above steps until we find `target` in which case we return `True` or move out of `matrix` in which case we return `False`.\\n\\nTime complexity: O(m+n), space complexity: O(1).\\n```\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        m = len(matrix)\\n        if m == 0:\\n            return False\\n        n = len(matrix[0])\\n        if n == 0:\\n            return False\\n        y = m-1\\n        x = 0\\n        while x < n and y >= 0:\\n            if matrix[y][x] == target:\\n                return True\\n            elif matrix[y][x] < target:\\n                x += 1\\n            else:\\n                y -= 1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        m = len(matrix)\\n        if m == 0:\\n            return False\\n        n = len(matrix[0])\\n        if n == 0:\\n            return False\\n        y = m-1\\n        x = 0\\n        while x < n and y >= 0:\\n            if matrix[y][x] == target:\\n                return True\\n            elif matrix[y][x] < target:\\n                x += 1\\n            else:\\n                y -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66277,
                "title": "so-clear-solve-for-c",
                "content": "    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            if(matrix.size() == 0)return false;\\n            return searchMatrix(matrix, 0, matrix[0].size() - 1, target);\\n        }\\n        bool searchMatrix(vector<vector<int>>& matrix, int x, int y, int target) {\\n            if(x >= matrix.size() || y < 0)return false;\\n            if(matrix[x][y] == target)return true;\\n            else if(matrix[x][y] < target) return searchMatrix(matrix, x + 1, y, target);\\n            else if(matrix[x][y] > target) return searchMatrix(matrix, x, y - 1, target);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            if(matrix.size() == 0)return false;\\n            return searchMatrix(matrix, 0, matrix[0].size() - 1, target);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 693908,
                "title": "python-explained-simple-solution-100-faster",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        ## Similar to Leetcode: 74. Search A 2D Matrix ##\\n        \\n        # 1. First, we initialize a (row, col) pointer to the bottom-left of the matrix.\\n        # 2. If the currently-pointed-to value is larger than target we can move one row \"up\". \\n        # 3. Otherwise, if the currently-pointed-to value is smaller than target, we can move one column \"right\".\\n        \\n\\t\\t## TIME COMPLEXITY : O(N + M) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n                \\n        i, j = len(matrix) - 1, 0\\n        while(i >= 0 and i < len(matrix) and j >=0 and j < len(matrix[0])):\\n            if(matrix[i][j] == target): return True\\n            if(matrix[i][j] > target):  i -= 1\\n            if(matrix[i][j] < target):  j += 1              \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        ## Similar to Leetcode: 74. Search A 2D Matrix ##\\n        \\n        # 1. First, we initialize a (row, col) pointer to the bottom-left of the matrix.\\n        # 2. If the currently-pointed-to value is larger than target we can move one row \"up\". \\n        # 3. Otherwise, if the currently-pointed-to value is smaller than target, we can move one column \"right\".\\n        \\n\\t\\t## TIME COMPLEXITY : O(N + M) ##\\n\\t\\t## SPACE COMPLEXITY : O(1) ##\\n                \\n        i, j = len(matrix) - 1, 0\\n        while(i >= 0 and i < len(matrix) and j >=0 and j < len(matrix[0])):\\n            if(matrix[i][j] == target): return True\\n            if(matrix[i][j] > target):  i -= 1\\n            if(matrix[i][j] < target):  j += 1              \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321439,
                "title": "awesome-logic-with-time-complexity-o-n",
                "content": "\\n\\n# Normal Approach---->O(N)\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row,col=len(matrix),len(matrix[0])\\n        r,c=0,col-1\\n        while r<row and c>=0:\\n            if matrix[r][c]==target:\\n                return True\\n            if matrix[r][c]>target:\\n                c-=1\\n            else:\\n                r+=1\\n        return False\\n    //please upvote me it would encourage me alot\\n\\n```\\n# Binary Search Approach--->O(NLogN)\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows,col=len(matrix),len(matrix[0])\\n        for row in matrix:\\n            left,right=0,len(row)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if row[mid]==target:\\n                    return True\\n                if row[mid]>target:\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n        return False\\n    //please upvote me it would encourage me alot\\n\\n\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row,col=len(matrix),len(matrix[0])\\n        r,c=0,col-1\\n        while r<row and c>=0:\\n            if matrix[r][c]==target:\\n                return True\\n            if matrix[r][c]>target:\\n                c-=1\\n            else:\\n                r+=1\\n        return False\\n    //please upvote me it would encourage me alot\\n\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows,col=len(matrix),len(matrix[0])\\n        for row in matrix:\\n            left,right=0,len(row)-1\\n            while left<=right:\\n                mid=(left+right)//2\\n                if row[mid]==target:\\n                    return True\\n                if row[mid]>target:\\n                    right=mid-1\\n                else:\\n                    left=mid+1\\n        return False\\n    //please upvote me it would encourage me alot\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760056,
                "title": "binary-search-time-complexity-space-complexity-explanation",
                "content": "Another version of this problem: https://leetcode.com/problems/search-a-2d-matrix/\\nSolution: https://leetcode.com/problems/search-a-2d-matrix/discuss/2760040/Binary-Search-Time-Complexity-%2B-Space-Complexity-%2B-Explanation\\n\\nTime Complexity - At most, we can traverse the length of 0 to row and col to 0. Thus time taken is O(row + col).\\nSpace Complexity - Space taken is O(1).\\nExplanation - We start at the top right corner of the matrix, and move left/right according to whether the current value is greater or lesser than target. This uses the property of each row and column being sorted.\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), col = matrix[0].size(), i = 0, j = col - 1;\\n        while(i < row && j >= 0){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nKindly upvote if you found the solution helpful :)\\n**For more such explanations of LeetCode problems along with their C++ solutions:**\\nhttps://github.com/Arya-Gupta/LeetCode",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), col = matrix[0].size(), i = 0, j = col - 1;\\n        while(i < row && j >= 0){\\n            if(matrix[i][j] == target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326445,
                "title": "240-search-a-2d-matrix-ii-c-three-approach-best-and-concise",
                "content": "**240. Search a 2D Matrix II**\\n\\n![image](https://assets.leetcode.com/users/images/5282d569-2c24-4068-9179-fa4fdd7617be_1658655205.7487211.jpeg)\\n![image](https://assets.leetcode.com/users/images/37279826-90a1-40f7-82bf-1e520ef617e2_1658655283.2490494.jpeg)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target)\\n    {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        // start from the [last row, first column] element\\n        int i = n - 1;\\n        //set j to \\'0\\' initially\\n        int j = 0;\\n        while (j < m && i >= 0)\\n        {\\n            //if target is found\\n            if (matrix[i][j] == target)\\n            {\\n                return true;\\n            }\\n            //in else if we checj that target is less than matrix value\\n            else if (matrix[i][j] > target)\\n            {\\n                --i;\\n                // decrease the row index\\n            }\\n            else\\n            {\\n                ++j;\\n                // increase the column index\\n            }\\n        }\\n        return false;\\n        // target not found\\n        // return false\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target)\\n    {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        // start from the [last row, first column] element\\n        int i = n - 1;\\n        //set j to \\'0\\' initially\\n        int j = 0;\\n        while (j < m && i >= 0)\\n        {\\n            //if target is found\\n            if (matrix[i][j] == target)\\n            {\\n                return true;\\n            }\\n            //in else if we checj that target is less than matrix value\\n            else if (matrix[i][j] > target)\\n            {\\n                --i;\\n                // decrease the row index\\n            }\\n            else\\n            {\\n                ++j;\\n                // increase the column index\\n            }\\n        }\\n        return false;\\n        // target not found\\n        // return false\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383965,
                "title": "javascript-concise-solution-64ms",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n    if(matrix.length === 0){\\n        return false;\\n    }\\n    //start with top-right element\\n    var i = 0;\\n    var j = matrix[0].length - 1;\\n    \\n    //loop till row and column number are within bounds\\n    while(i <= matrix.length - 1 && j >= 0){\\n        \\n        if(matrix[i][j] > target){\\n            //current element is greater than target\\n            //means this row might have the target element\\n            //change column\\n            j--;\\n        }else if(matrix[i][j] === target){\\n            //element found\\n            return true;\\n        }else if(matrix[i][j] < target){\\n            //current element is lesser than target\\n            //means this column might have the target element\\n            //change rows\\n            i++;\\n        }\\n    }\\n    return false;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n    if(matrix.length === 0){\\n        return false;\\n    }\\n    //start with top-right element\\n    var i = 0;\\n    var j = matrix[0].length - 1;\\n    \\n    //loop till row and column number are within bounds\\n    while(i <= matrix.length - 1 && j >= 0){\\n        \\n        if(matrix[i][j] > target){\\n            //current element is greater than target\\n            //means this row might have the target element\\n            //change column\\n            j--;\\n        }else if(matrix[i][j] === target){\\n            //element found\\n            return true;\\n        }else if(matrix[i][j] < target){\\n            //current element is lesser than target\\n            //means this column might have the target element\\n            //change rows\\n            i++;\\n        }\\n    }\\n    return false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 66246,
                "title": "java-solution-worst-case-o-m-n",
                "content": "    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix==null ||matrix.length==0 ||matrix[0].length==0)\\n            return false;\\n        int i=0,j=matrix[0].length-1;\\n        while(i<matrix.length && j>=0){\\n            if(matrix[i][j] == target)\\n                return true;\\n            else if(matrix[i][j] < target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix==null ||matrix.length==0 ||matrix[0].length==0)\\n            return false;\\n        int i=0,j=matrix[0].length-1;\\n        while(i<matrix.length && j>=0){\\n            if(matrix[i][j] == target)\\n                return true;\\n            else if(matrix[i][j] < target)\\n                i++;\\n            else\\n                j--;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3231791,
                "title": "240-time-91-4-and-space-98-52-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem can be solved using a divide and conquer approach. We start from the top right corner and move towards the bottom left corner of the matrix. At each position, we check if the current element is equal to the target value. If it is equal, we return True. If it is less than the target value, we move down one row because all the elements in the current row are smaller than the current element. If it is greater than the target value, we move left one column because all the elements in the current column are greater than the current element.\\n\\nThe time complexity of this algorithm is O(m+n) because in the worst case scenario we traverse all rows and columns. The space complexity is O(1) because we are not using any extra data structure.\\n\\n# Complexity\\n- Time complexity:\\n91.4%\\n\\n- Space complexity:\\n98.52%\\n\\n# Code\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        # set initial position to top right corner\\n        row, col = 0, len(matrix[0])-1\\n        \\n        while row < len(matrix) and col >= 0:\\n            if matrix[row][col] == target:\\n                # target found\\n                return True\\n            elif matrix[row][col] < target:\\n                # current element is smaller than target, move down one row\\n                row += 1\\n            else:\\n                # current element is greater than target, move left one column\\n                col -= 1\\n                \\n        # target not found\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        # set initial position to top right corner\\n        row, col = 0, len(matrix[0])-1\\n        \\n        while row < len(matrix) and col >= 0:\\n            if matrix[row][col] == target:\\n                # target found\\n                return True\\n            elif matrix[row][col] < target:\\n                # current element is smaller than target, move down one row\\n                row += 1\\n            else:\\n                # current element is greater than target, move left one column\\n                col -= 1\\n                \\n        # target not found\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079178,
                "title": "python-super-simple-o-m-n-faster-than-93-65",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row, col, num_row = 0, len(matrix[0]) - 1, len(matrix)\\n        while col >= 0 and row < num_row:\\n            if matrix[row][col] > target:\\n                col -= 1\\n            elif matrix[row][col] < target:\\n                row += 1\\n            else:\\n                return True\\n        return False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row, col, num_row = 0, len(matrix[0]) - 1, len(matrix)\\n        while col >= 0 and row < num_row:\\n            if matrix[row][col] > target:\\n                col -= 1\\n            elif matrix[row][col] < target:\\n                row += 1\\n            else:\\n                return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 768488,
                "title": "java-o-n-m",
                "content": "We can take advantage of the fact that our given input input grid is sorted. So if we are at a particular element we are guranteed that all the element to it\\'s right and to it\\'s bottom will be larger that the current element.\\nAnd we also know that all the element to it\\'s left and to it\\'s top will be less than the current element;\\n\\nSo this potentially allow us to eliminte :\\n\\tEither all the element below and to the right if our target is less that the current elemet `target < grid[i][j]`\\n\\tOr we can eliminate all the elements to the left and top if our target is greater that the current     element `target > grid[i][j]`\\n\\nLet\\'s say out target is 6, then: \\n![image](https://assets.leetcode.com/users/images/b8b8731d-9862-4d9a-a9fd-5edc47a1a269_1629074320.0377576.png)\\n\\n\\nWe start at first row\\'s last index because thats the max possible number that we can get in that row and the least possible element in the last colums. We keep on traversing until we reach the bottom left index and at that point if we have not yet found the taget val we simply return false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n\\n\\tclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0) return false;\\n        \\n        int col = matrix[0].length -1;\\n        \\n        int row = 0;\\n        \\n        \\n        while( row < matrix.length && col >=0){\\n            \\n            int num = matrix[row][col];\\n            \\n            if(num == target) return true;\\n            \\n            else if( num > target){\\n                col--;\\n            }\\n            else row++;\\n        }\\n        \\n        \\n        return false;\\n        \\n        \\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n        if(matrix.length == 0 || matrix[0].length == 0) return false;\\n        \\n        int col = matrix[0].length -1;\\n        \\n        int row = 0;\\n        \\n        \\n        while( row < matrix.length && col >=0){\\n            \\n            int num = matrix[row][col];\\n            \\n            if(num == target) return true;\\n            \\n            else if( num > target){\\n                col--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 66235,
                "title": "2-clean-c-implementation-with-detailed-complexity-analysis",
                "content": " Here is the O(M+N) solution, It is important to make it clear we choose the position\\n\\n         right-up-corner-position : can help us to exclude a column or a row\\n\\nSo by judging the right-up-corner-value, we can exclude a column or a row one loop, so the loop is \\nO(M+N) time complexity.\\n\\n    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int m=matrix.size();\\n            if(m==0)  return false;\\n            int n=matrix[0].size();\\n            /*** start from the right-up-position ***/\\n            int i=0, j=n-1;\\n            while(i<m && j>=0){\\n                if(matrix[i][j]==target)  return true;\\n                /*** the element-of-column-j >= matrix[i][j] > target ***/\\n                else if(matrix[i][j]>target)  j--;\\n                /*** the element-of-row-i <= matrix[i][j] < target ***/\\n                else   i++;\\n            }\\n            return false;\\n        }\\n    };\\n\\n\\nHere is a recursion-version-implementation, by analyzing the time complexity \\n\\n      T(N)=3*(T(N/4)) + O(1)\\n\\nBased the master theory, \\n\\n     f(n) = O(1) = O(log(4, 3-e))    with e=2   \\n\\nSo\\n\\n     T(n) = O(N ^ log(4, 3) )    <  O(N)\\n\\nhere is the C++ implementation:\\n\\n\\n       class Solution {\\n        public:\\n            bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n                if(matrix.size()==0) return false;\\n                int row=matrix.size(), col=matrix[0].size();\\n                return help(matrix, 0, row-1, 0, col-1, target);\\n            }\\n            \\n            bool help(vector<vector<int>>& matrix, int row_start, int row_end, int col_start, int col_end, int target) {\\n                if(row_start>row_end || col_start>col_end)  return false;\\n                int row_mid=(row_start+row_end)/2, col_mid=(col_start+col_end)/2;\\n                if(matrix[row_mid][col_mid]==target)    return true;\\n                else if(matrix[row_mid][col_mid]>target){\\n                    /*** left-up || left-down || right-up ***/\\n                    return help(matrix, row_start, row_mid-1, col_start, col_mid-1, target) ||\\n                        help(matrix, row_mid, row_end, col_start, col_mid-1, target) ||\\n                        help(matrix, row_start, row_mid-1, col_mid, col_end, target);\\n                }\\n                else{\\n                    /*** right-down || left-down || right-up ***/\\n                    return help(matrix, row_mid+1, row_end, col_mid+1, col_end, target) ||\\n                        help(matrix, row_mid+1, row_end, col_start, col_mid, target) ||\\n                        help(matrix, row_start, row_mid, col_mid+1, col_end, target);\\n                }\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int m=matrix.size();\\n            if(m==0)  return false;\\n            int n=matrix[0].size();\\n            /*** start from the right-up-position ***/\\n            int i=0, j=n-1;\\n            while(i<m && j>=0){\\n                if(matrix[i][j]==target)  return true;\\n                /*** the element-of-column-j >= matrix[i][j] > target ***/\\n                else if(matrix[i][j]>target)  j--;\\n                /*** the element-of-row-i <= matrix[i][j] < target ***/\\n                else   i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1080050,
                "title": "js-python-java-c-binary-search-solution-w-visual-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nThe naive approach here would be to check every cell at a **time complexity** of **O(m * n)**. The obvious improvement on this would be to use a **binary search** on each row to shorten this to **O(m * log n)**. But since the matrix (**M**) is sorted both by row and by column, we can actually think of each **cell** (**M[i][j]**) as being a midpoint in a longer \"row\", including all the cells to the left as well as below the current cell.\\n\\nIf we start from the top right corner of **M** and treat this like a modified binary search, we can eliminate an entire row or an entire column each time we check a **cell**:\\n\\n![Visual 1](https://i.imgur.com/HG6ZPns.png)\\n\\nWe\\'ll then just need to adjust our **i** or **j** value to move to the top right corner \"midpoint\" of the remaining matrix each time to narrow in on our target (**T**):\\n\\n![Visual 2](https://i.imgur.com/b1gvHg0.png)\\n\\nThis will drop the time complexity to **O(m + n)**.\\n\\n(*Note: This works just as well when starting from the bottom left corner.*)\\n\\n---\\n\\n#### ***Implementation:***\\n\\nFor all except Java we can use the **bitwise NOT** operator (**~**) to check for boundary condition of **j** because it will return a falsy value (**0**) only when **j** is **-1**.\\n\\n(*Note: Some people are achieving \"faster\" results by exploiting a design flaw in the testing suite. It appears that the test includes one or more loops of the same matrix input and people have had the idea to clear the matrix before returning the answer, which will make the rest of said loop easier to process, as the mutated matrix will be used in subsequent iterations of the test.*)\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **280ms / 41.8MB** (beats 98% / 78%).\\n```javascript\\nvar searchMatrix = function(M, T) {\\n    let y = M.length, i = 0, j = M[0].length - 1\\n    while (i < y && ~j) {\\n        let cell = M[i][j]\\n        if (cell === T) return true\\n        else if (cell > T) j--\\n        else i++\\n    }\\n    return false\\n};\\n\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **148ms / 20.4MB** (beats 99% / 98%).\\n```python\\nclass Solution:\\n    def searchMatrix(self, M: List[List[int]], T: int) -> bool:\\n        y, i, j = len(M), 0, len(M[0]) - 1\\n        while i < y and ~j:\\n            cell = M[i][j]\\n            if cell == T: return True\\n            elif cell > T: j -= 1\\n            else: i += 1\\n        return False\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **4ms / 44.2MB** (beats 100% / 96%).\\n```java\\nclass Solution {\\n    public boolean searchMatrix(int[][] M, int T) {\\n        int y = M.length, i = 0, j = M[0].length - 1;\\n        while (i < y && j >= 0) {\\n            int cell = M[i][j];\\n            if (cell == T) return true;\\n            else if (cell > T) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **60ms / 14.6MB** (beats 96% / 92%).\\n```c++\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& M, int T) {\\n        int y = M.size(), i = 0, j = M[0].size() - 1;\\n        while (i < y && ~j) {\\n            int cell = M[i][j];\\n            if (cell == T) return true;\\n            else if (cell > T) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar searchMatrix = function(M, T) {\\n    let y = M.length, i = 0, j = M[0].length - 1\\n    while (i < y && ~j) {\\n        let cell = M[i][j]\\n        if (cell === T) return true\\n        else if (cell > T) j--\\n        else i++\\n    }\\n    return false\\n};\\n\\n```\n```python\\nclass Solution:\\n    def searchMatrix(self, M: List[List[int]], T: int) -> bool:\\n        y, i, j = len(M), 0, len(M[0]) - 1\\n        while i < y and ~j:\\n            cell = M[i][j]\\n            if cell == T: return True\\n            elif cell > T: j -= 1\\n            else: i += 1\\n        return False\\n```\n```java\\nclass Solution {\\n    public boolean searchMatrix(int[][] M, int T) {\\n        int y = M.length, i = 0, j = M[0].length - 1;\\n        while (i < y && j >= 0) {\\n            int cell = M[i][j];\\n            if (cell == T) return true;\\n            else if (cell > T) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& M, int T) {\\n        int y = M.size(), i = 0, j = M[0].size() - 1;\\n        while (i < y && ~j) {\\n            int cell = M[i][j];\\n            if (cell == T) return true;\\n            else if (cell > T) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697281,
                "title": "python3-o-n-m-with-explanation-proof",
                "content": "Consider the submatrix whose upper right corner is index i, j (row, column) and whose bottom left corner is the bottom left of the original matrix.  Suppose we know that the element we are searching for is either in this submatrix, or it is not in the matrix at all.  If the target is greater than matrix[i][j] then we know the target is not in row i and we can now consider the submatrix whose upper right corner is i - 1, j .  If the target is less than matrix[i][j] then we know that the target is not in column j and we can now consider the submatrix whose upper right corner is i, j-1.  Initially we know that the element we are searching for is either in the matrix or it is not.  In other words, we initially know that the element we are searching for is either in the submatrix whose upper right corner is at 0, m - 1 (where m is the number of columns) or it is not in the matrix at all.  The idea of the algorithm is to maintain with each iteration the condition that the target is in the submatrix whose upper right corner is index i, j.\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        if matrix == None or len(matrix) == 0 or len(matrix[0]) == 0: \\n            return False\\n        n, m = len(matrix), len(matrix[0])\\n        i, j = 0, m - 1\\n        while i < n and j >= 0:\\n            if matrix[i][j] == target:\\n                return True\\n            elif matrix[i][j] < target:\\n                i += 1\\n            else:\\n                j -= 1\\n        return False\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        if matrix == None or len(matrix) == 0 or len(matrix[0]) == 0: \\n            return False\\n        n, m = len(matrix), len(matrix[0])\\n        i, j = 0, m - 1\\n        while i < n and j >= 0:\\n            if matrix[i][j] == target:\\n                return True\\n            elif matrix[i][j] < target:\\n                i += 1\\n            else:\\n                j -= 1\\n        return False\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 133253,
                "title": "javascript-solution",
                "content": "Search from top right corner\\n\\n```js\\n// Time O(m + n), rule out one row or one column each time\\n// Space O(1)\\n\\nconst searchMatrix = (matrix, target) => {\\n  if (matrix == null || matrix.length === 0) return false;\\n  const h = matrix.length;\\n  const w = matrix[0].length;\\n\\n  let i = 0;\\n  let j = w - 1;\\n  while (j >= 0 && i < h) {\\n    if (target === matrix[i][j]) return true;\\n    else if (target < matrix[i][j]) j--;\\n    else i++;\\n  }\\n  return false;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```js\\n// Time O(m + n), rule out one row or one column each time\\n// Space O(1)\\n\\nconst searchMatrix = (matrix, target) => {\\n  if (matrix == null || matrix.length === 0) return false;\\n  const h = matrix.length;\\n  const w = matrix[0].length;\\n\\n  let i = 0;\\n  let j = w - 1;\\n  while (j >= 0 && i < h) {\\n    if (target === matrix[i][j]) return true;\\n    else if (target < matrix[i][j]) j--;\\n    else i++;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66296,
                "title": "clear-c-solution-illustrating-how-to-use-binary-search-accordingly",
                "content": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), col = row ? matrix[0].size() : 0;\\n        int start = 0, end = row, mid, endRow, startRow;\\n        // first we determine the first row the target might occurs.\\n        // notice that here we implement the lower_bound binary search.\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (matrix[mid][col-1] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        startRow = start;\\n        //then we caclulate the end row (not included) the target might occurs\\n        // here is for upper_bound binary search.\\n        start = 0, end = row;\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (matrix[mid][0] > target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        endRow = start;\\n        //finally, iterate through each row until we find the target\\n        // and here is also lower_bound binary search.\\n        for (int i = startRow;i < endRow;++i) {\\n            start = 0, end = col;\\n            while (start < end) {\\n                mid = (start + end) / 2;\\n                if (matrix[i][mid] >= target) {\\n                    end = mid;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            }\\n            if (start < col && matrix[i][start] == target)\\n                return true;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), col = row ? matrix[0].size() : 0;\\n        int start = 0, end = row, mid, endRow, startRow;\\n        // first we determine the first row the target might occurs.\\n        // notice that here we implement the lower_bound binary search.\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (matrix[mid][col-1] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        startRow = start;\\n        //then we caclulate the end row (not included) the target might occurs\\n        // here is for upper_bound binary search.\\n        start = 0, end = row;\\n        while (start < end) {\\n            mid = (start + end) / 2;\\n            if (matrix[mid][0] > target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        endRow = start;\\n        //finally, iterate through each row until we find the target\\n        // and here is also lower_bound binary search.\\n        for (int i = startRow;i < endRow;++i) {\\n            start = 0, end = col;\\n            while (start < end) {\\n                mid = (start + end) / 2;\\n                if (matrix[i][mid] >= target) {\\n                    end = mid;\\n                } else {\\n                    start = mid + 1;\\n                }\\n            }\\n            if (start < col && matrix[i][start] == target)\\n                return true;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2057102,
                "title": "c-100-faster-solution-with-explanation-binary-search-easy",
                "content": "**Approach:**\\n1. We will start iterate from m[0][m] or m[n][0]   where m = no. of colums and n =no. of rows.\\n2. then we have have left element is always smaller and down element is bigger then current in whole matrix (Given rows are sorted).\\n3. Then we will loop from` (r < row && r >=0)` and ` (c < col && c >= 0)` this prevent overflow.\\n4. Then if current element is smaller then will we go down ( `r++;` ).\\n5. Then if current element is bigger then will we go left ( `c--;` ).\\n6. If element found we will return true else false.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int c = col-1;\\n        int r =0;\\n        while((r < row && r >=0)  && (c < col && c >= 0)){\\n            \\n            int element = matrix[r][c];\\n            \\n            if(element == target){\\n                return true;\\n            }\\n             else if(element > target){\\n                  c--;\\n            }else{\\n                 r++;\\n             }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\\n\\n**UPVOTE IF UNDERSTAND**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int c = col-1;\\n        int r =0;\\n        while((r < row && r >=0)  && (c < col && c >= 0)){\\n            \\n            int element = matrix[r][c];\\n            \\n            if(element == target){\\n                return true;\\n            }\\n             else if(element > target){\\n                  c--;\\n            }else{\\n                 r++;\\n             }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222060,
                "title": "c-fast-and-easy-approach-binary-search",
                "content": "class Solution {\\npublic:\\n    **We will start from top right corner of the matrix.\\n    If target is greater then index element then we shift index to bottom.\\n    But If target is smaller then index element we shift index to left.\\n    If target is not present in matrix then we will go bound.**\\n    \\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i=0,j=col-1;\\n        while(matrix[i][j]!=target){\\n            if(i<0 or j<0 or i>row-1 or j>col-1) //if out of bond then return false\\n                return false;\\n            if(matrix[i][j]<target){\\n                i=i+1;\\n                if(i>row-1)\\n                    return false;\\n            }\\n            else{\\n                j=j-1;\\n                if(j<0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\t**Upvote if you find useful**\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    **We will start from top right corner of the matrix.\\n    If target is greater then index element then we shift index to bottom.\\n    But If target is smaller then index element we shift index to left.\\n    If target is not present in matrix then we will go bound.**\\n    \\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i=0,j=col-1;\\n        while(matrix[i][j]!=target){\\n            if(i<0 or j<0 or i>row-1 or j>col-1) //if out of bond then return false\\n                return false;\\n            if(matrix[i][j]<target){\\n                i=i+1;\\n                if(i>row-1)\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1079974,
                "title": "java-all-approach-regular-and-modified-binary-search-comment-explained",
                "content": "**Regular Binary Search - O(m * logn)**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        for (int i=0;i<matrix.length;i++){\\n                int left  = 0;\\n                int right = matrix[i].length-1;\\n                while (left <= right){\\n                        int cMid = left + (right - left) / 2; // find mid\\n                        if (matrix[i][cMid] == target) return true; // if target matches then return true\\n                        else if (matrix[i][cMid] < target) left = cMid+1; // if the value is less than target then increment the left pointer\\n                        else right = cMid-1; // otherwise decrement the right pointer\\n                } \\n        }\\n        return false;\\n    }\\n}\\n```\\n**Modified Binary Search - O(m + n)**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        \\n        int i = 0;\\n        int j = col-1;\\n        while (i < row && j >= 0){\\n            if (matrix[i][j] == target) return true;\\n            else if (matrix[i][j] < target) i++; //everything in the previous row will be lesser so increment row pointer\\n            else j--;    //everything from the column will be greater so decrement the column pointer\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        for (int i=0;i<matrix.length;i++){\\n                int left  = 0;\\n                int right = matrix[i].length-1;\\n                while (left <= right){\\n                        int cMid = left + (right - left) / 2; // find mid\\n                        if (matrix[i][cMid] == target) return true; // if target matches then return true\\n                        else if (matrix[i][cMid] < target) left = cMid+1; // if the value is less than target then increment the left pointer\\n                        else right = cMid-1; // otherwise decrement the right pointer\\n                } \\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        \\n        int i = 0;\\n        int j = col-1;\\n        while (i < row && j >= 0){\\n            if (matrix[i][j] == target) return true;\\n            else if (matrix[i][j] < target) i++; //everything in the previous row will be lesser so increment row pointer\\n            else j--;    //everything from the column will be greater so decrement the column pointer\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 240184,
                "title": "java-divide-and-conquer-approach",
                "content": "Find the middle element in matrix. Divide matrix to 4 parts:\\n\\nPart 1 | Part 2\\n.........O..........\\nPart 3 | Part4\\n\\nO - is the middle element.\\n\\nIf target is more than O - then we ignore Part1 otherwise we ignore Part 3 - and continue recursively to search in parts, to simplify code and speed up execution time - I merge neighbor parts.\\n\\n```\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        final int m = matrix.length;\\n        if (m == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n        final int n = matrix[0].length;\\n\\n        return searchMatrix(matrix, target, 0, m - 1, 0, n - 1);\\n    }\\n\\n    public boolean searchMatrix(int[][] matrix, int target, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int rowMiddle = rowStart + (rowEnd - rowStart) / 2;\\n        int colMiddle = colStart + (colEnd - colStart) / 2;\\n        if (rowStart > rowEnd || colStart > colEnd) {\\n            return false;\\n        }\\n        int valMiddle = matrix[rowMiddle][colMiddle];\\n        if (target == valMiddle) {\\n            return true;\\n        }\\n        if (target < valMiddle) {\\n            return searchMatrix(matrix, target, rowStart, rowEnd, colStart, colMiddle - 1)\\n                    || searchMatrix(matrix, target, rowStart, rowMiddle - 1, colMiddle, colEnd);\\n        } else {\\n            return searchMatrix(matrix, target, rowStart, rowEnd, colMiddle + 1, colEnd)\\n                    || searchMatrix(matrix, target, rowMiddle + 1, rowEnd, colStart, colMiddle);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        final int m = matrix.length;\\n        if (m == 0 || matrix[0].length == 0) {\\n            return false;\\n        }\\n        final int n = matrix[0].length;\\n\\n        return searchMatrix(matrix, target, 0, m - 1, 0, n - 1);\\n    }\\n\\n    public boolean searchMatrix(int[][] matrix, int target, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int rowMiddle = rowStart + (rowEnd - rowStart) / 2;\\n        int colMiddle = colStart + (colEnd - colStart) / 2;\\n        if (rowStart > rowEnd || colStart > colEnd) {\\n            return false;\\n        }\\n        int valMiddle = matrix[rowMiddle][colMiddle];\\n        if (target == valMiddle) {\\n            return true;\\n        }\\n        if (target < valMiddle) {\\n            return searchMatrix(matrix, target, rowStart, rowEnd, colStart, colMiddle - 1)\\n                    || searchMatrix(matrix, target, rowStart, rowMiddle - 1, colMiddle, colEnd);\\n        } else {\\n            return searchMatrix(matrix, target, rowStart, rowEnd, colMiddle + 1, colEnd)\\n                    || searchMatrix(matrix, target, rowMiddle + 1, rowEnd, colStart, colMiddle);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66173,
                "title": "c-solution",
                "content": "```\\n        public bool SearchMatrix(int[,] matrix, int target)\\n        {\\n            int currentRow = 0, currentCol = matrix.GetLength(1) - 1;\\n\\n            while(currentRow <= matrix.GetLength(0) - 1 && currentCol >= 0)\\n                if (matrix[currentRow, currentCol] == target)\\n                    return true;\\n                else if (matrix[currentRow, currentCol] < target)\\n                    currentRow++;\\n                else if (matrix[currentRow, currentCol] > target)\\n                    currentCol--;\\n\\n            return false;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public bool SearchMatrix(int[,] matrix, int target)\\n        {\\n            int currentRow = 0, currentCol = matrix.GetLength(1) - 1;\\n\\n            while(currentRow <= matrix.GetLength(0) - 1 && currentCol >= 0)\\n                if (matrix[currentRow, currentCol] == target)\\n                    return true;\\n                else if (matrix[currentRow, currentCol] < target)\\n                    currentRow++;\\n                else if (matrix[currentRow, currentCol] > target)\\n                    currentCol--;\\n\\n            return false;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 66232,
                "title": "share-my-c-o-m-n-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int row = matrix.size();\\n            if (row == 0)\\n                return false;\\n            int col = matrix[0].size();\\n            if (col == 0)\\n                return false;\\n            if (target < matrix[0][0] || target > matrix[row-1][col-1])\\n                return false;\\n            \\n            int i = 0, j = col - 1;\\n            while (i < row && j >=0)\\n            {\\n                if (target == matrix[i][j])\\n                    return true;\\n                //if target > matrix[i][j],then target must not appear in row-i\\n                else if (target > matrix[i][j])\\n                    ++i;\\n                //if target < matrix[i][j],then target must not appear in column-j\\n                else\\n                    --j;\\n            }\\n            \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            int row = matrix.size();\\n            if (row == 0)\\n                return false;\\n            int col = matrix[0].size();\\n            if (col == 0)\\n                return false;\\n            if (target < matrix[0][0] || target > matrix[row-1][col-1])\\n                return false;\\n            \\n            int i = 0, j = col - 1;\\n            while (i < row && j >=0)\\n            {\\n                if (target == matrix[i][j])\\n                    return true;\\n                //if target > matrix[i][j],then target must not appear in row-i\\n                else if (target > matrix[i][j])\\n                    ++i;\\n                //if target < matrix[i][j],then target must not appear in column-j\\n                else\\n                    --j;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 66322,
                "title": "o-m-n-c-solution",
                "content": "O(M+N) C++ solution for M*N matrix;\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       if(matrix.size() == 0) return false;\\n        int n = matrix[0].size()-1;\\n        int m = 0;\\n        while(m < matrix.size() && n >= 0) {\\n            if (matrix[m][n] == target) return true;\\n            else if (matrix[m][n] < target) ++m;\\n            else --n;\\n        }\\n        return false;\\n    }\\n\\nThe idea is: \\nstart from the upper right corner: \\n\\n - if the element is equal to target, return true;\\n - if the element is greater than target, that means the whole column is greater than target, we can delete a whole column\\n - else, we can delete a whole row",
                "solutionTags": [],
                "code": "O(M+N) C++ solution for M*N matrix;\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       if(matrix.size() == 0) return false;\\n        int n = matrix[0].size()-1;\\n        int m = 0;\\n        while(m < matrix.size() && n >= 0) {\\n            if (matrix[m][n] == target) return true;\\n            else if (matrix[m][n] < target) ++m;\\n            else --n;\\n        }\\n        return false;\\n    }\\n\\nThe idea is: \\nstart from the upper right corner: \\n\\n - if the element is equal to target, return true;\\n - if the element is greater than target, that means the whole column is greater than target, we can delete a whole column\\n - else, we can delete a whole row",
                "codeTag": "Unknown"
            },
            {
                "id": 3858488,
                "title": "space-optimized-solution",
                "content": "# **PLS UPVOTE MY SOLUTION IF YOU LIKE IT AND COMMENT FOR ANY DOUBTS **\\n# Approach\\nInitialize startrow to 0, representing the first row of the matrix.\\nInitialize startcol to m-1, representing the last column of the matrix. m is the number of columns in the matrix.\\nStart a while loop that continues until startrow is less than the number of rows (n) and startcol is greater than or equal to 0.\\nInside the loop, retrieve the element at the current position in the matrix using matrix[startrow][startcol] and store it in the variable ele.\\nCompare ele with the target value. If they are equal, the target is found, and the function returns true (1).\\nIf ele is less than the target, it means the target can only be present in a row below the current one (since the matrix is sorted in non-decreasing order). So, we increment startrow to move to the next row.\\nIf ele is greater than the target, it means the target can only be present in a column to the left of the current one. So, we decrement startcol to move to the previous column.\\nIf the target is not found after the while loop, the function returns false (0).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(m+n) WORST CASE\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int startrow=0;\\n        int startcol= m-1;\\n        while(startrow < n && startcol >= 0)\\n        {\\n            int ele = matrix[startrow][startcol];\\n            if(ele==target)\\n            {\\n                return 1;\\n            }\\n            else if(ele<target)\\n            {\\n                startrow++;\\n            }\\n            else\\n            {\\n                startcol--;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int startrow=0;\\n        int startcol= m-1;\\n        while(startrow < n && startcol >= 0)\\n        {\\n            int ele = matrix[startrow][startcol];\\n            if(ele==target)\\n            {\\n                return 1;\\n            }\\n            else if(ele<target)\\n            {\\n                startrow++;\\n            }\\n            else\\n            {\\n                startcol--;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209331,
                "title": "c-easy-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       int n=matrix.size();\\n       int m=matrix[0].size();\\n       int i=0,j=m-1;\\n       while(i<n && j>=0){\\n           if(matrix[i][j]==target) return true;\\n           else if(matrix[i][j]<target)i++;\\n           else j--;\\n       }\\n       return false;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/3a830886-b93d-44bb-921f-c385552a3db0_1676886905.778097.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       int n=matrix.size();\\n       int m=matrix[0].size();\\n       int i=0,j=m-1;\\n       while(i<n && j>=0){\\n           if(matrix[i][j]==target) return true;\\n           else if(matrix[i][j]<target)i++;\\n           else j--;\\n       }\\n       return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326182,
                "title": "c-easy-to-understand",
                "content": "```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\t\\tint R = matrix.size();         //number of rows.\\n        int C = matrix[0].size();     //number of columns.\\n        int i = 0 , j = C - 1;           //choosing iterator i & j to search the target.\\n        while(i < R && j >= 0)\\n        {\\n            if(matrix[i][j] == target)   //if we find the target we return true.\\n                return true;\\n            else if(matrix[i][j] < target)     //if the value at position i & j is smaller than target then we move downward to next column. \\n                i ++;\\n            else                   // else if value at i & j is greater than target then we go leftward in same row.\\n                j --;\\n        }\\n        return false;       // if the target element is not present in the matrix then return false.\\n    }\\n```\\nif you find this helpful upvote please.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n\\t\\tint R = matrix.size();         //number of rows.\\n        int C = matrix[0].size();     //number of columns.\\n        int i = 0 , j = C - 1;           //choosing iterator i & j to search the target.\\n        while(i < R && j >= 0)\\n        {\\n            if(matrix[i][j] == target)   //if we find the target we return true.\\n                return true;\\n            else if(matrix[i][j] < target)     //if the value at position i & j is smaller than target then we move downward to next column. \\n                i ++;\\n            else                   // else if value at i & j is greater than target then we go leftward in same row.\\n                j --;\\n        }\\n        return false;       // if the target element is not present in the matrix then return false.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1891722,
                "title": "c-6-line-simple-code-easy-to-understand-tc-o-n-m-sc-o-1",
                "content": "#### *Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(), m=matrix[0].size();\\n        int row=0,col=m-1;\\n        while(row<n && col>=0){\\n            if(matrix[row][col]==target) return 1;\\n            else if(matrix[row][col]>target) col--;\\n            else row++;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size(), m=matrix[0].size();\\n        int row=0,col=m-1;\\n        while(row<n && col>=0){\\n            if(matrix[row][col]==target) return 1;\\n            else if(matrix[row][col]>target) col--;\\n            else row++;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 775465,
                "title": "4-different-solutions-in-c-with-different-time-complexities",
                "content": "Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\\n\\n    Integers in each row are sorted in ascending from left to right.\\n    Integers in each column are sorted in ascending from top to bottom.\\n\\nExample:\\n\\nConsider the following matrix:\\n\\n[\\n  [1,   4,  7, 11, 15],\\n  [2,   5,  8, 12, 19],\\n  [3,   6,  9, 16, 22],\\n  [10, 13, 14, 17, 24],\\n  [18, 21, 23, 26, 30]\\n]\\n\\nGiven target = 5, return true.\\n\\nGiven target = 20, return false.\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nDIVIDE AND CONQUER APPROACH: O(nlogn)\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n```\\nclass Solution {\\npublic:\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0) return false;\\n        if(matrix[0].size()==0) return false;\\n        return searchRect(matrix,target,0,0,matrix.size()-1,matrix[0].size()-1);\\n    }\\n\\n    bool searchRect(vector<vector<int>>& matrix, int target, \\n                               int top, int left, int bottom, int right) {\\n        \\n        if(top>bottom || left>right)\\n            return false;\\n        \\n        int x = (top+bottom)/2;\\n        int y = (left+right)/2;\\n        int center = matrix[x][y];\\n        \\n        if(center > target){\\n            return\\n                searchRect(matrix,target,top,left,x-1,right) ||\\n                searchRect(matrix,target,x,left,bottom,y-1);\\n        }\\n        else if(center < target){\\n            return\\n                searchRect(matrix,target,x+1,left,bottom,right) ||\\n                searchRect(matrix,target,top,y+1,x,right);\\n        }\\n        else\\n            return true;\\n    }\\n};\\n```\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nGREEDY SOLUTION: O(n)\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, r = 0, c = n - 1;\\n        while (r < m && c >= 0) {\\n            if (matrix[r][c] == target) {\\n                return true;\\n            }\\n            matrix[r][c] > target ? c-- : r++;\\n        }\\n        return false;\\n    }\\n};\\n```\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nBINARY SEARCH SOLUTION: O(nlogn)\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        if(m==0) return false;\\n        int n=matrix[0].size();\\n        if(n==0) return false;\\n        for(int i=0;i<m;i++){\\n            if(target<=matrix[i][n-1] and target>=matrix[i][0]){\\n                int left=0;\\n                int right=n-1;\\n                while(left<=right){\\n                    int mid=left +(right-left)/2;\\n                    if(matrix[i][mid]==target){\\n                        return true;\\n                    }\\n                    else if(target<matrix[i][mid]){\\n                        right=mid-1;\\n                    }\\n                    else left=mid+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nBRUTE FORCE SOLUTION: (This method will get you a TLE, but the implementation is correct and is passing all the base cases). O(n^2)\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                if(matrix[i][j]==target)\\n                {\\n                      return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```\\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0) return false;\\n        if(matrix[0].size()==0) return false;\\n        return searchRect(matrix,target,0,0,matrix.size()-1,matrix[0].size()-1);\\n    }\\n\\n    bool searchRect(vector<vector<int>>& matrix, int target, \\n                               int top, int left, int bottom, int right) {\\n        \\n        if(top>bottom || left>right)\\n            return false;\\n        \\n        int x = (top+bottom)/2;\\n        int y = (left+right)/2;\\n        int center = matrix[x][y];\\n        \\n        if(center > target){\\n            return\\n                searchRect(matrix,target,top,left,x-1,right) ||\\n                searchRect(matrix,target,x,left,bottom,y-1);\\n        }\\n        else if(center < target){\\n            return\\n                searchRect(matrix,target,x+1,left,bottom,right) ||\\n                searchRect(matrix,target,top,y+1,x,right);\\n        }\\n        else\\n            return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = m ? matrix[0].size() : 0, r = 0, c = n - 1;\\n        while (r < m && c >= 0) {\\n            if (matrix[r][c] == target) {\\n                return true;\\n            }\\n            matrix[r][c] > target ? c-- : r++;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        if(m==0) return false;\\n        int n=matrix[0].size();\\n        if(n==0) return false;\\n        for(int i=0;i<m;i++){\\n            if(target<=matrix[i][n-1] and target>=matrix[i][0]){\\n                int left=0;\\n                int right=n-1;\\n                while(left<=right){\\n                    int mid=left +(right-left)/2;\\n                    if(matrix[i][mid]==target){\\n                        return true;\\n                    }\\n                    else if(target<matrix[i][mid]){\\n                        right=mid-1;\\n                    }\\n                    else left=mid+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[i].size();j++)\\n            {\\n                if(matrix[i][j]==target)\\n                {\\n                      return true;\\n                }\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66229,
                "title": "clean-easy-solution-in-java",
                "content": "    public boolean searchMatrix(int[][] matrix, int target) {\\n\\t\\tint line=0;\\n\\t\\tint len=matrix.length;\\n\\t\\tint col=matrix[0].length;\\n\\t\\twhile (line<len && col>0){\\n\\t\\t\\tint num= matrix[line][col-1];\\n\\t\\t\\tif (num>target) col--;\\n\\t\\t\\tif (num<target) line++;\\n\\t\\t\\tif (num==target) return true;}\\n\\t\\t\\n        return false;\\n    }\\n\\nThe main idea of this solution is to compare the target with the number in the top-right corner and decrease the row number or the col number one by one. It's simple and efficient.",
                "solutionTags": [],
                "code": "    public boolean searchMatrix(int[][] matrix, int target) {\\n\\t\\tint line=0;\\n\\t\\tint len=matrix.length;\\n\\t\\tint col=matrix[0].length;\\n\\t\\twhile (line<len && col>0){\\n\\t\\t\\tint num= matrix[line][col-1];\\n\\t\\t\\tif (num>target) col--;\\n\\t\\t\\tif (num<target) line++;\\n\\t\\t\\tif (num==target) return true;}\\n\\t\\t\\n        return false;\\n    }\\n\\nThe main idea of this solution is to compare the target with the number in the top-right corner and decrease the row number or the col number one by one. It's simple and efficient.",
                "codeTag": "Unknown"
            },
            {
                "id": 66272,
                "title": "o-m-n-java-solution",
                "content": "        public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int x = 0;\\n        int y = n - 1;\\n        while (x < m && y >= 0) {\\n            if (target == matrix[x][y]) {\\n                return true;\\n            } else if (target > matrix[x][y]) {\\n                x++;\\n            } else {\\n                y--;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "        public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int x = 0;\\n        int y = n - 1;\\n        while (x < m && y >= 0) {\\n            if (target == matrix[x][y]) {\\n                return true;\\n            } else if (target > matrix[x][y]) {\\n                x++;\\n            } else {\\n                y--;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 66285,
                "title": "c-c-divide-and-conquer-solution",
                "content": "C++ version\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // check bad input\\n        int m = matrix.size();\\n        if(m == 0)\\n            return false;\\n        int n = matrix[0].size();\\n        if(n == 0)\\n            return false;\\n        return binarySearch(matrix, target, 0, m-1, 0, n-1);\\n    }\\n    \\n    bool binarySearch(vector<vector<int>>& matrix, int target, \\n    int min_i, int max_i, \\n    int min_j, int max_j){\\n        if(min_i > max_i)\\n            return false;\\n        if(min_j > max_j)\\n            return false;\\n        int i = (min_i + max_i)/2;\\n        int j = (min_j + max_j)/2;\\n        \\n        int value = matrix[i][j];\\n        if(value == target)\\n            return true;\\n        else if(value < target)\\n        {\\n            return binarySearch(matrix, target, min_i, max_i, j+1, max_j)\\n            || binarySearch(matrix, target, i+1, max_i, min_j, j);\\n        }\\n        else\\n        {\\n            return binarySearch(matrix, target, min_i, max_i, min_j, j-1)\\n            || binarySearch(matrix, target, min_i, i-1, j, max_j);            \\n        }\\n    }\\n\\nC# version\\n\\n    public bool SearchMatrix(int[,] matrix, int target) {\\n        if(matrix == null)\\n            return false;\\n        int m = matrix.GetLength(0);\\n        int n = matrix.GetLength(1);\\n        if(n == 0 && m == 0)\\n            return false;\\n        return BinarySearch(matrix, target, 0, m-1, 0, n-1);\\n    }\\n    \\n    bool BinarySearch(int[,] matrix, int target, \\n    int min_i, int max_i, \\n    int min_j, int max_j){\\n        if(min_i > max_i)\\n            return false;\\n        if(min_j > max_j)\\n            return false;\\n        int i = (min_i + max_i)/2;\\n        int j = (min_j + max_j)/2;\\n        \\n        int value = matrix[i,j];\\n        if(value == target)\\n            return true;\\n        else if(value < target)\\n        {\\n            return BinarySearch(matrix, target, min_i, max_i, j+1, max_j)\\n            || BinarySearch(matrix, target, i+1, max_i, min_j, j);\\n        }\\n        else\\n        {\\n            return BinarySearch(matrix, target, min_i, max_i, min_j, j-1)\\n            || BinarySearch(matrix, target, min_i, i-1, j, max_j);            \\n        }\\n    }",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "C++ version\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // check bad input\\n        int m = matrix.size();\\n        if(m == 0)\\n            return false;\\n        int n = matrix[0].size();\\n        if(n == 0)\\n            return false;\\n        return binarySearch(matrix, target, 0, m-1, 0, n-1);\\n    }\\n    \\n    bool binarySearch(vector<vector<int>>& matrix, int target, \\n    int min_i, int max_i, \\n    int min_j, int max_j){\\n        if(min_i > max_i)\\n            return false;\\n        if(min_j > max_j)\\n            return false;\\n        int i = (min_i + max_i)/2;\\n        int j = (min_j + max_j)/2;\\n        \\n        int value = matrix[i][j];\\n        if(value == target)\\n            return true;\\n        else if(value < target)\\n        {\\n            return binarySearch(matrix, target, min_i, max_i, j+1, max_j)\\n            || binarySearch(matrix, target, i+1, max_i, min_j, j);\\n        }\\n        else\\n        {\\n            return binarySearch(matrix, target, min_i, max_i, min_j, j-1)\\n            || binarySearch(matrix, target, min_i, i-1, j, max_j);            \\n        }\\n    }\\n\\nC# version\\n\\n    public bool SearchMatrix(int[,] matrix, int target) {\\n        if(matrix == null)\\n            return false;\\n        int m = matrix.GetLength(0);\\n        int n = matrix.GetLength(1);\\n        if(n == 0 && m == 0)\\n            return false;\\n        return BinarySearch(matrix, target, 0, m-1, 0, n-1);\\n    }\\n    \\n    bool BinarySearch(int[,] matrix, int target, \\n    int min_i, int max_i, \\n    int min_j, int max_j){\\n        if(min_i > max_i)\\n            return false;\\n        if(min_j > max_j)\\n            return false;\\n        int i = (min_i + max_i)/2;\\n        int j = (min_j + max_j)/2;\\n        \\n        int value = matrix[i,j];\\n        if(value == target)\\n            return true;\\n        else if(value < target)\\n        {\\n            return BinarySearch(matrix, target, min_i, max_i, j+1, max_j)\\n            || BinarySearch(matrix, target, i+1, max_i, min_j, j);\\n        }\\n        else\\n        {\\n            return BinarySearch(matrix, target, min_i, max_i, min_j, j-1)\\n            || BinarySearch(matrix, target, min_i, i-1, j, max_j);            \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3205428,
                "title": "a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical",
                "content": "# Intuition\\nAFAIK, people posted 2 types of solution:\\n- mostly people are reposting the same clever trick in O(m+n) (starting from top-right or bottom-left corner and moving accordingly)\\n- a suboptimal divide and conquer approach\\n\\nBoth methods leave me unsatisfied: you could easily miss the trick in an interview if your mind just doesn\\'t wander the right way. It feels too random to rely on a trick, and I prefer to have at least one more methodical approach available.\\nThe divide and conquer is the most methodical and you could more easily come up with it, eespecially by analogy with other problems you have solved before. However it is suboptimal\\n\\nHere, we explore an O(m+n) divide and conquer approach that you can methodically come up with if you know the binary search\\nIt is essentially a **2D binary search**\\nN.B: feel free to correct me if I got the complexity wrong, I am not 100% certain. \\n\\n\\n\\n# Approach\\nThe idea is the following:\\nTake your current matrix and select the middle row. In the middle row, look for the target with a binary search. If you find it, you\\'re done. If not, take note of the position of the last element smaller than the target and the first larger (represented by the < and > below)\\n```\\n|                                   |\\n|                                   |\\n|                                   |\\n|----------<>-----------------------| (binary search on middle row)\\n|                                   |\\n|                                   |\\n|                                   |\\n```\\nThis element, that we will call the pivot point yields precious information, because we know that we can discard all the elements in the top-left quadrant will be smaller, and all the elements in the bottom right quadrant will be larger than target by definition of the ordering of the matrix:\\n```\\n|          |                        |\\n|ELIMINATED|                        |\\n|          |                        |\\n|----------<>-----------------------|\\n|           |                       |\\n|           |      ELIMINATED!      |\\n|           |                       |\\n```\\nWe can the explore the 2 remaining matrices recursively.  This goes on until you\\'ve divided the submatrices into single rows, after which you can move on to the next submatrix in the recursive stack call. Here is what the search space might look like after the next iteration.\\n```\\n|          |    ELIM       |        |\\n|ELIMINATED|---------------<>-------|\\n|          |                | ELIM  |\\n|----------<>-----------------------|\\n|           |                       |\\n|           |      ELIMINATED!      |\\n|           |                       |\\n```\\nAs we see, the philosophy of this algorithm just builds on from the simple binary search. It basically uses a bin search in both dimensions of the matrix to divide it into submatrices and eliminating half of them each time, until only a single row remains\\n\\n# Complexity\\n- Time complexity:\\n**O(m+n)**\\n\\nOkay here is the tricky part. Calculating the complexity of this recursion is a bit complicated and if you think I did it wrong, please let me know.\\n\\nThis is a recursive algorithm. Let\\'s call $N=m*n$ the total number of elements in a submatrix. At each step of the recursion, we cut the size of the submatrix in half. More accurately, we divide it into four quadrants, and we only explore two of the quadrants, one with K elements and the other with L elements so that $K+L=N/2$. This subdivision is done in O(log(n)) thanks to a binary search\\nSo the master equation for this recursion could be written as:\\n\\n$$T(N)=T(K)+T(L)+O(log(n))$$, where $$K+L=N/2$$\\n\\n[The Akra-Bazzi theorem](https://en.wikipedia.org/wiki/Akra%E2%80%93Bazzi_method) tells us that we need to find the integer $p$ so that: \\n$$K^p+L^p=N^p$$\\nBad news, we can\\'t. It depends on how exactly the submatrix is split between K and L. **But we can get an upper bound for p**. Because the square root function is concave, we can write:\\n$$\\\\frac{\\\\sqrt K + \\\\sqrt L}{2}<\\\\sqrt{\\\\frac {K + L}{2}}$$\\n$$\\\\frac{\\\\sqrt K + \\\\sqrt L}{2}<\\\\sqrt{\\\\frac {N}{4}}$$\\n$$\\\\sqrt K + \\\\sqrt L< \\\\sqrt N$$\\n**therefore, 1/2 is an upper bound for p** (only smaller values of p could satisfy the equality)\\n\\nTherefore, the Akra Bazzi theorem tells us that our complexity will be bounded by:\\n$$T(N)< \\\\Theta \\\\left(\\\\sqrt N\\\\left(1+\\\\int _{1}^{N}{\\\\frac  {g(u)}{u^{{3/2}}}}du\\\\right)\\\\right)$$\\nWe can show with an integration by part that the integral is actually just O(1), so **our complexity is bounded by $O(\\\\sqrt N)$**\\n\\nWe note that, according to the [inequality of arithmetic and geometric means](https://en.wikipedia.org/wiki/Inequality_of_arithmetic_and_geometric_means),\\n$$\\\\sqrt N=\\\\sqrt{m*n}<=\\\\frac{m+n}{2}$$\\nSo $$T(N)<O(m+n)$$\\n\\n**Our complexity is at worst O(m+n). It is on-par with the \"trick\" solution in terms of time complexity**\\n\\n- Space complexity:\\nO(1) \\n\\n# Code\\n\\nThe code is probably ugly and could be written better but I tried to make it clear with comments. This is not the main point anyway, I mostly wanted to share the different approach, not so much the details of the implementation\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n       \\n        # helper function for binary search\\n        # inputs:   -row of the matrix that we are exploring\\n        #           -starting index of the row (based on the current submatrix)\\n        #           -final index of the row\\n        # returns True if target is found, otherwise, returns the largest value that is < target\\n        def bsearch(row,cstart,cend):\\n            left=cstart\\n            right=cend\\n            while left<=right:\\n                mid=(left+right)//2\\n                if matrix[row][mid]==target:\\n                    return True\\n                elif matrix[row][mid]<target:\\n                    if mid+1>cend or matrix[row][mid+1]>target: return mid\\n                    left=mid+1\\n                else:\\n                    if mid-1<cstart or matrix[row][mid-1]<target: return mid-1\\n                    right=mid-1\\n\\n\\n        # main function that does the matrix splitting based on the pivot point\\n        # input:    -rstart,rend : starting row and final row of current submatrix\\n        #           -cstart,cend : starting column and final column\\n        def dichotomy2D(rstart,rend,cstart,cend):\\n            # checking if we have reached some kind of stupid index that indicates end of search\\n            if cstart>cend or rstart<0 or rend >= len(matrix) or rstart>rend:\\n                return False\\n            #we select the middle row of the current submatrix\\n            row=(rstart+rend)//2\\n            #we perform the binary search on the middle row and retrun True if target is found\\n            split=bsearch(row,cstart,cend)\\n            if split is True:\\n                return True\\n            #otherwise, we subdivise the array into bottom left (from [row+1,cstart] to [rend,split]) and top right(from[row-1,split+1] to [rstart,cend]), and we check those recursively\\n            return dichotomy2D(max(row+1,rstart),rend,cstart,split) or dichotomy2D(rstart,min(row-1,rend),res+1,cend)\\n\\n        return dichotomy2D(0,len(matrix)-1,0,len(matrix[0])-1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Divide and Conquer",
                    "Matrix"
                ],
                "code": "```\\n|                                   |\\n|                                   |\\n|                                   |\\n|----------<>-----------------------| (binary search on middle row)\\n|                                   |\\n|                                   |\\n|                                   |\\n```\n```\\n|          |                        |\\n|ELIMINATED|                        |\\n|          |                        |\\n|----------<>-----------------------|\\n|           |                       |\\n|           |      ELIMINATED!      |\\n|           |                       |\\n```\n```\\n|          |    ELIM       |        |\\n|ELIMINATED|---------------<>-------|\\n|          |                | ELIM  |\\n|----------<>-----------------------|\\n|           |                       |\\n|           |      ELIMINATED!      |\\n|           |                       |\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n       \\n        # helper function for binary search\\n        # inputs:   -row of the matrix that we are exploring\\n        #           -starting index of the row (based on the current submatrix)\\n        #           -final index of the row\\n        # returns True if target is found, otherwise, returns the largest value that is < target\\n        def bsearch(row,cstart,cend):\\n            left=cstart\\n            right=cend\\n            while left<=right:\\n                mid=(left+right)//2\\n                if matrix[row][mid]==target:\\n                    return True\\n                elif matrix[row][mid]<target:\\n                    if mid+1>cend or matrix[row][mid+1]>target: return mid\\n                    left=mid+1\\n                else:\\n                    if mid-1<cstart or matrix[row][mid-1]<target: return mid-1\\n                    right=mid-1\\n\\n\\n        # main function that does the matrix splitting based on the pivot point\\n        # input:    -rstart,rend : starting row and final row of current submatrix\\n        #           -cstart,cend : starting column and final column\\n        def dichotomy2D(rstart,rend,cstart,cend):\\n            # checking if we have reached some kind of stupid index that indicates end of search\\n            if cstart>cend or rstart<0 or rend >= len(matrix) or rstart>rend:\\n                return False\\n            #we select the middle row of the current submatrix\\n            row=(rstart+rend)//2\\n            #we perform the binary search on the middle row and retrun True if target is found\\n            split=bsearch(row,cstart,cend)\\n            if split is True:\\n                return True\\n            #otherwise, we subdivise the array into bottom left (from [row+1,cstart] to [rend,split]) and top right(from[row-1,split+1] to [rstart,cend]), and we check those recursively\\n            return dichotomy2D(max(row+1,rstart),rend,cstart,split) or dichotomy2D(rstart,min(row-1,rend),res+1,cend)\\n\\n        return dichotomy2D(0,len(matrix)-1,0,len(matrix[0])-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325154,
                "title": "python-easy-o-n-m-two-pointer-apporach",
                "content": "**UPVOTE PLS :-)**\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        i=0\\n        j=len(matrix[0])-1\\n        while(i<len(matrix) and j>=0):\\n            if target<matrix[i][j]:\\n                j-=1\\n            elif target>matrix[i][j]:\\n                i+=1\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        i=0\\n        j=len(matrix[0])-1\\n        while(i<len(matrix) and j>=0):\\n            if target<matrix[i][j]:\\n                j-=1\\n            elif target>matrix[i][j]:\\n                i+=1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010646,
                "title": "c-binary-search-best-optimized-approach",
                "content": "****upvote if it you find helpfull -> thanks****\\n\\n\\t\\tint rowstart = 0;\\n        int rowend = matrix.size();\\n        int colend = matrix[0].size()-1;\\n        while(rowstart<rowend && colend>=0)\\n        {\\n            int element = matrix[rowstart][colend];\\n            if(element == target) return true;\\n            else if(target < element){\\n                colend--;\\n            }\\n            else if(target > element)rowstart++;\\n        }\\n        return false;",
                "solutionTags": [
                    "C",
                    "Array",
                    "Binary Tree"
                ],
                "code": "****upvote if it you find helpfull -> thanks****\\n\\n\\t\\tint rowstart = 0;\\n        int rowend = matrix.size();\\n        int colend = matrix[0].size()-1;\\n        while(rowstart<rowend && colend>=0)\\n        {\\n            int element = matrix[rowstart][colend];\\n            if(element == target) return true;\\n            else if(target < element){\\n                colend--;\\n            }\\n            else if(target > element)rowstart++;\\n        }\\n        return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 1397287,
                "title": "c-two-pointer-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n\\t    int j = matrix[0].size()-1;\\n\\t    while(i<matrix.size() && j>=0){\\n\\t        if(matrix[i][j]==target) return true;\\n\\t        else if(matrix[i][j]<target)  i++;\\n\\t        else  j--;\\n\\t    }\\n\\t    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i = 0;\\n\\t    int j = matrix[0].size()-1;\\n\\t    while(i<matrix.size() && j>=0){\\n\\t        if(matrix[i][j]==target) return true;\\n\\t        else if(matrix[i][j]<target)  i++;\\n\\t        else  j--;\\n\\t    }\\n\\t    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227998,
                "title": "java-binary-search-solution-with-illustration-and-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/b889c8d3-22ec-4074-b9ef-70059424c92d_1621867186.9592545.png)\\n\\nGiven a (sub)matrix enclosed by `(lox, loy)` and `(hix, hiy)`, just recursively search any 3 of 4 quadrants (excluding the impossible one) after comparing the `target` value with the value of the middle point `(i, j)`.\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        return search(matrix, target, 0, 0, m-1, n-1);\\n    }\\n    \\n    private boolean search (\\n        int[][] mat,\\n        int t,\\n        int lox,\\n        int loy,\\n        int hix,\\n        int hiy\\n    ) {\\n        if (lox > hix || loy > hiy) return false;\\n        int i = lox + (hix - lox) / 2;\\n        int j = loy + (hiy - loy) / 2;\\n        if (mat[i][j] < t) {\\n            return search(mat, t, lox, j+1, i, hiy)    // q1\\n                || search(mat, t, i+1, loy, hix, j)    // q3\\n                || search(mat, t, i+1, j+1, hix, hiy); // q4\\n        } else if (mat[i][j] > t) {\\n            return search(mat, t, lox, j, i-1, hiy)    // q1\\n                || search(mat, t, i, loy, hix, j-1)    // q3\\n                || search(mat, t, lox, loy, i-1, j-1); // q2\\n        } else {\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        return search(matrix, target, 0, 0, m-1, n-1);\\n    }\\n    \\n    private boolean search (\\n        int[][] mat,\\n        int t,\\n        int lox,\\n        int loy,\\n        int hix,\\n        int hiy\\n    ) {\\n        if (lox > hix || loy > hiy) return false;\\n        int i = lox + (hix - lox) / 2;\\n        int j = loy + (hiy - loy) / 2;\\n        if (mat[i][j] < t) {\\n            return search(mat, t, lox, j+1, i, hiy)    // q1\\n                || search(mat, t, i+1, loy, hix, j)    // q3\\n                || search(mat, t, i+1, j+1, hix, hiy); // q4\\n        } else if (mat[i][j] > t) {\\n            return search(mat, t, lox, j, i-1, hiy)    // q1\\n                || search(mat, t, i, loy, hix, j-1)    // q3\\n                || search(mat, t, lox, loy, i-1, j-1); // q2\\n        } else {\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079113,
                "title": "rust-o-m-n-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let (mut i, mut j) = (0, matrix[0].len() - 1);\\n        while i < matrix.len() {\\n            match matrix[i][j].cmp(&target) {\\n                std::cmp::Ordering::Less => i += 1,\\n                std::cmp::Ordering::Equal => return true,\\n                std::cmp::Ordering::Greater if j > 0 => j -= 1,\\n                std::cmp::Ordering::Greater => break,\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn search_matrix(matrix: Vec<Vec<i32>>, target: i32) -> bool {\\n        let (mut i, mut j) = (0, matrix[0].len() - 1);\\n        while i < matrix.len() {\\n            match matrix[i][j].cmp(&target) {\\n                std::cmp::Ordering::Less => i += 1,\\n                std::cmp::Ordering::Equal => return true,\\n                std::cmp::Ordering::Greater if j > 0 => j -= 1,\\n                std::cmp::Ordering::Greater => break,\\n            }\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1079082,
                "title": "python-c-o-m-n-explained-just-walk-from-top-right-corner",
                "content": "# Algorithm:\\nHere we do not want to be smart heads, because binary search is not very much faster and not easy to understand. Fastest one is **O(min(N, M) * log(max(N, M) / min(N, M)))**, which you can find here\\nhttp://twistedoakstudios.com/blog/Post5365_searching-a-sorted-matrix-faster\\n\\nWe going to solve it by **O(N + M)** complexity. \\nIdea is that if we go down, all number above and on the left are smaller, while if we go left all number under and on the right are larger, so we basically need to _go down_ if we need number _larger_ and _go left_ if we need _smaller_. Last question os where to start? If we will only go _down_ and _left_, we need to start _at most up and right_ spot, so we don\\'t miss enything. Here illustration how we will do that:\\n\\n# Illustrations:\\n### For target `5`:\\n![image](https://assets.leetcode.com/users/images/dfc2f727-bfb6-4098-8630-b7e7b8bb86e9_1614070035.582655.png)\\n\\n### For target 20:\\n![image](https://assets.leetcode.com/users/images/10a7c6a7-9f44-41c0-9e61-316f67273a54_1614070050.6790533.png)\\n\\n## Python code:\\n```\\nclass Solution:\\n  def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n    i, j = 0, len(matrix[0]) - 1\\n    while i < len(matrix) and j >= 0:\\n      if matrix[i][j] < target:\\n        i += 1\\n      elif matrix[i][j] > target:\\n        j -= 1\\n      else:\\n        return True\\n    return False\\n```\\n\\n## C++ Code:\\n```\\nclass Solution {\\n  public:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n    int i = 0, j = matrix[0].size() - 1;\\n    while (i < matrix.size() && j >= 0){\\n      if (matrix[i][j] < target){\\n        ++i; \\n      } else if (matrix[i][j] > target){\\n        --j;\\n      } else {\\n        return true;\\n      } \\n    }\\n    return false;\\n    }\\n};\\n```\\n\\n### Further reading:\\nIf you wonder how **O(min(N, M) * log(max(N, M) / min(N, M)))** looks like: \\n![image](https://i.imgur.com/USX7Qrl.gif)\\nMore details here: http://twistedoakstudios.com/blog/Post5365_searching-a-sorted-matrix-faster",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n  def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n    i, j = 0, len(matrix[0]) - 1\\n    while i < len(matrix) and j >= 0:\\n      if matrix[i][j] < target:\\n        i += 1\\n      elif matrix[i][j] > target:\\n        j -= 1\\n      else:\\n        return True\\n    return False\\n```\n```\\nclass Solution {\\n  public:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n    int i = 0, j = matrix[0].size() - 1;\\n    while (i < matrix.size() && j >= 0){\\n      if (matrix[i][j] < target){\\n        ++i; \\n      } else if (matrix[i][j] > target){\\n        --j;\\n      } else {\\n        return true;\\n      } \\n    }\\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642522,
                "title": "java-solution-with-explaination-faster-than-100",
                "content": "Two condition provided is \\n1. rows are sorted in ascending order\\n2. cols are sorted in ascending order\\n\\n*  We first start with first row and last column element in 2D matrix.\\n*  Idea here is we maintain two pointer\\'s.\\n    i) for row\\n   ii) for col\\njust like any 2D matrix problems\\n\\n* now we compare current Element pointed by rowIndex and colIndex with target, if it matches then return true.\\n* if it does not match then, two possibility, we can go down(rowIndex++) or go left(colIndex--)\\n* we compare if current Element is smaller than the target\\n   i) if it\\'s smaller, then we go down as all the elemnts on the left side of the current element is smaller(rows in ascending order).\\nii) if not, then we go left, as our solution doesnot lie in current column(because col is sorted in ascending, so all the elements below in current col are greater than current element.)\\n\\nTime Complexity:\\nassuming, \\nnum of rows = m\\nnum of cols = n\\n\\ncomplexity : O(m+n)\\n\\nSpace complexity: O(1)\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix.length == 0) return false;\\n       \\n        int rowIndex = 0;\\n        int colIndex = matrix[0].length - 1;\\n        \\n        while(rowIndex < matrix.length && colIndex >= 0) {\\n            if (matrix[rowIndex][colIndex] == target)\\n                return true;\\n            \\n            if(matrix[rowIndex][colIndex] < target)\\n                rowIndex++;\\n            else\\n                colIndex--;\\n        }\\n        \\n        return false;\\n    }    \\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix.length == 0) return false;\\n       \\n        int rowIndex = 0;\\n        int colIndex = matrix[0].length - 1;\\n        \\n        while(rowIndex < matrix.length && colIndex >= 0) {\\n            if (matrix[rowIndex][colIndex] == target)\\n                return true;\\n            \\n            if(matrix[rowIndex][colIndex] < target)\\n                rowIndex++;\\n            else\\n                colIndex--;\\n        }\\n        \\n        return false;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440400,
                "title": "all-four-approaches-in-c",
                "content": "The following are all the four approaches mentioned in the solution in C++,\\n\\n**1. Brute-Force:**\\n\\n```\\n//Vinayak Kukreja\\n//Time Complexity --> n x m matrix --> O(nm)\\n//Space Complexity --> O(1) if we do not consider input provided in the complexity\\n\\n//Approach #1 --> Brute Force\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size(); \\n        if(rowLength == 0)  //Checking if there are no rows, then false\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        //Iterating through every value and checking against the target\\n        for(int i = 0; i < rowLength; i++)\\n            for(int j = 0; j < colLength; j++)\\n                if(matrix[i][j] == target)\\n                    return true;    //Target Found\\n        \\n        return false;   //Target Not Found\\n    }\\n};\\n```\\n\\n**2. Binary-Search:**\\n\\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(lg(n!))\\n//Space Complexity --> O(1)\\n\\n//Approach #2 --> Via Binary Search\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size();\\n        if(rowLength == 0)  //If the number of rows are zero, then returning false\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        int shorterDimension = min(rowLength, colLength);   //Getting the shorter length between column and row size, it is necessary we take the shorter one or else index out of bound might occur\\n        \\n        for(int startPos = 0; startPos < shorterDimension; startPos++){\\n            //Searching first column slice and then row slice\\n            if(binarySearch(matrix, target, startPos, true) || binarySearch(matrix, target, startPos, false))\\n                return true;    //Target found\\n        }\\n        return false;   //Target not found\\n    }\\n    \\n    //Applying binary search to column or row slice of 2D matrix and searching for target\\n    bool binarySearch(vector<vector<int>>& matrix, int target, int startingPos, bool rowOrCol){\\n        int low = startingPos;  //This position changes via for loop implemented before\\n        //Therefore we go in an rotated L-shape kind of flow from left top to right bottom as the start\\n        //position increases\\n        //  |--------\\n        //  | |------\\n        //  | | |----\\n        int high = rowOrCol ? matrix[0].size()-1 : matrix.size()-1;     //Selecting high value based on searching column or row slice currently, if true then column, if not then row\\n              \\n        //The following is similar to how binary search works\\n        while(low <= high){\\n            int mid = (low + high) / 2;     //Calculating middle\\n            if(rowOrCol){\\n                //If searching columns\\n                if(matrix[startingPos][mid] > target)\\n                    high = mid - 1;\\n                else if(matrix[startingPos][mid] < target)\\n                    low = mid + 1;\\n                else\\n                    return true;\\n            }\\n            else{\\n                //If searching rows\\n                if(matrix[mid][startingPos] > target)\\n                    high = mid - 1;\\n                else if(matrix[mid][startingPos] < target)\\n                    low = mid + 1;\\n                else\\n                    return true;\\n            }\\n        }\\n        return false;   //When target now found in this iteration\\n    }\\n};\\n```\\n\\n**3. Divide and Conquer:**\\n\\n*I am unable to solve memory limit error in this. I think the solution should be working in each case and if someone finds the problem with the following, please do let me know, I would update the code. Sorry for the inconvenience,*\\n\\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(nlgn)\\n//Space Complexity --> O(lgn)\\n\\n//Approach #3 --> Divide And Conquer\\n//Version --> 1.0\\n\\nclass Solution {\\nprivate:\\n    vector<vector<int>> matrixLoc;\\n    int targLoc;\\n\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        //Transfering to local variables for less variables to pass during recursion\\n        matrixLoc = matrix;     \\n        targLoc = target;\\n        \\n        if(matrixLoc.size() == 0)   //Checking if no rows present, then returning false\\n            return false;\\n        \\n        //Starting search from top leftmost index to rightmost bottom index\\n        return recursiveSearch(0, 0, matrix.size()-1, matrix[0].size()-1);\\n    }\\n    \\n    bool recursiveSearch(int rowLow, int colLow, int rowHigh, int colHigh){\\n        \\n        //Checking if the matrix is having no height or width\\n        if(colLow > colHigh || rowLow > rowHigh)\\n            return false;\\n        \\n        //Checking if the values at extreme ends of given matrix are either bigger or smaller than target, then target would not be present in the matrix\\n        else if(matrixLoc[rowLow][colLow] > targLoc || matrixLoc[rowHigh][colHigh] < targLoc)\\n            return false;\\n        \\n        else{\\n            int colMid = colLow + (colHigh-colLow)/2;\\n        \\n            //To find such a row where,\\n            //matrixLoc[row-1][colMid] < targetLoc < matrixLoc[row][colMid]\\n            int row = rowLow;\\n            while(row <=  rowHigh && matrixLoc[row][colMid] <= targLoc){\\n                //checking middle column elements against target value\\n                if(matrixLoc[row][colMid] == targLoc)   \\n                    return true;\\n                \\n                ++row;\\n            }\\n            \\n            //Recursively now checking the bottom left and top right sub matrices formed\\n            return recursiveSearch(row, colLow, rowHigh, colMid-1) || recursiveSearch(rowLow, colMid+1, row-1, colHigh);\\n        }\\n    }\\n};\\n```\\n\\n**4. Search Space Reduction:**\\n\\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(m+n)\\n//Space Complexity --> O(1)\\n\\n//Approach #4 --> Search Space Reduction\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size();\\n        //Checking if there are no rows and hence returning false \\n        if(rowLength == 0)\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        int i = 0, j = colLength - 1;   //Starting from the top-right of the matrix\\n        //Moving left if the target is less than the value since column values below would be greater\\n        //Moving down if the target is greater than the value because all the values on the left would be smaller\\n        while( i < rowLength && j >= 0)\\n        {\\n            if(matrix[i][j] == target){\\n                return true;\\n            }\\n            else if(matrix[i][j] > target){     //If the current value is greater, then it means the values below this i.e. inside this column would be greater, therefore moving to the left\\n                j--;\\n            }\\n            else{   //Moving down, because all the values would be smaller on the left\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Vinayak Kukreja\\n//Time Complexity --> n x m matrix --> O(nm)\\n//Space Complexity --> O(1) if we do not consider input provided in the complexity\\n\\n//Approach #1 --> Brute Force\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size(); \\n        if(rowLength == 0)  //Checking if there are no rows, then false\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        //Iterating through every value and checking against the target\\n        for(int i = 0; i < rowLength; i++)\\n            for(int j = 0; j < colLength; j++)\\n                if(matrix[i][j] == target)\\n                    return true;    //Target Found\\n        \\n        return false;   //Target Not Found\\n    }\\n};\\n```\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(lg(n!))\\n//Space Complexity --> O(1)\\n\\n//Approach #2 --> Via Binary Search\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size();\\n        if(rowLength == 0)  //If the number of rows are zero, then returning false\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        int shorterDimension = min(rowLength, colLength);   //Getting the shorter length between column and row size, it is necessary we take the shorter one or else index out of bound might occur\\n        \\n        for(int startPos = 0; startPos < shorterDimension; startPos++){\\n            //Searching first column slice and then row slice\\n            if(binarySearch(matrix, target, startPos, true) || binarySearch(matrix, target, startPos, false))\\n                return true;    //Target found\\n        }\\n        return false;   //Target not found\\n    }\\n    \\n    //Applying binary search to column or row slice of 2D matrix and searching for target\\n    bool binarySearch(vector<vector<int>>& matrix, int target, int startingPos, bool rowOrCol){\\n        int low = startingPos;  //This position changes via for loop implemented before\\n        //Therefore we go in an rotated L-shape kind of flow from left top to right bottom as the start\\n        //position increases\\n        //  |--------\\n        //  | |------\\n        //  | | |----\\n        int high = rowOrCol ? matrix[0].size()-1 : matrix.size()-1;     //Selecting high value based on searching column or row slice currently, if true then column, if not then row\\n              \\n        //The following is similar to how binary search works\\n        while(low <= high){\\n            int mid = (low + high) / 2;     //Calculating middle\\n            if(rowOrCol){\\n                //If searching columns\\n                if(matrix[startingPos][mid] > target)\\n                    high = mid - 1;\\n                else if(matrix[startingPos][mid] < target)\\n                    low = mid + 1;\\n                else\\n                    return true;\\n            }\\n            else{\\n                //If searching rows\\n                if(matrix[mid][startingPos] > target)\\n                    high = mid - 1;\\n                else if(matrix[mid][startingPos] < target)\\n                    low = mid + 1;\\n                else\\n                    return true;\\n            }\\n        }\\n        return false;   //When target now found in this iteration\\n    }\\n};\\n```\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(nlgn)\\n//Space Complexity --> O(lgn)\\n\\n//Approach #3 --> Divide And Conquer\\n//Version --> 1.0\\n\\nclass Solution {\\nprivate:\\n    vector<vector<int>> matrixLoc;\\n    int targLoc;\\n\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        //Transfering to local variables for less variables to pass during recursion\\n        matrixLoc = matrix;     \\n        targLoc = target;\\n        \\n        if(matrixLoc.size() == 0)   //Checking if no rows present, then returning false\\n            return false;\\n        \\n        //Starting search from top leftmost index to rightmost bottom index\\n        return recursiveSearch(0, 0, matrix.size()-1, matrix[0].size()-1);\\n    }\\n    \\n    bool recursiveSearch(int rowLow, int colLow, int rowHigh, int colHigh){\\n        \\n        //Checking if the matrix is having no height or width\\n        if(colLow > colHigh || rowLow > rowHigh)\\n            return false;\\n        \\n        //Checking if the values at extreme ends of given matrix are either bigger or smaller than target, then target would not be present in the matrix\\n        else if(matrixLoc[rowLow][colLow] > targLoc || matrixLoc[rowHigh][colHigh] < targLoc)\\n            return false;\\n        \\n        else{\\n            int colMid = colLow + (colHigh-colLow)/2;\\n        \\n            //To find such a row where,\\n            //matrixLoc[row-1][colMid] < targetLoc < matrixLoc[row][colMid]\\n            int row = rowLow;\\n            while(row <=  rowHigh && matrixLoc[row][colMid] <= targLoc){\\n                //checking middle column elements against target value\\n                if(matrixLoc[row][colMid] == targLoc)   \\n                    return true;\\n                \\n                ++row;\\n            }\\n            \\n            //Recursively now checking the bottom left and top right sub matrices formed\\n            return recursiveSearch(row, colLow, rowHigh, colMid-1) || recursiveSearch(rowLow, colMid+1, row-1, colHigh);\\n        }\\n    }\\n};\\n```\n```\\n//Vinayak Kukreja\\n//Time Complexity --> O(m+n)\\n//Space Complexity --> O(1)\\n\\n//Approach #4 --> Search Space Reduction\\n//Version --> 1.0\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rowLength = matrix.size();\\n        //Checking if there are no rows and hence returning false \\n        if(rowLength == 0)\\n            return false;\\n        int colLength = matrix[0].size();\\n        \\n        int i = 0, j = colLength - 1;   //Starting from the top-right of the matrix\\n        //Moving left if the target is less than the value since column values below would be greater\\n        //Moving down if the target is greater than the value because all the values on the left would be smaller\\n        while( i < rowLength && j >= 0)\\n        {\\n            if(matrix[i][j] == target){\\n                return true;\\n            }\\n            else if(matrix[i][j] > target){     //If the current value is greater, then it means the values below this i.e. inside this column would be greater, therefore moving to the left\\n                j--;\\n            }\\n            else{   //Moving down, because all the values would be smaller on the left\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344435,
                "title": "python3-search-a-2d-matrix-o-m-n",
                "content": "\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(matrix) == 0: return False\\n        # we initialize the pointer at the bottom-left of the matrix\\n        r,c = len(matrix)-1,0\\n        while r >=0 and c <len(matrix[0]):\\n            if matrix[r][c] == target:\\n                return True\\n            else:\\n                if matrix[r][c] < target:\\n                    c += 1\\n                else:\\n                    r -= 1\\n        return False\\n```\\n* Time complexity: O(m+n)\\n\\tm is the number of rows, and n is the number of columns.\\n    The worst-case here is that the algorithm needs to finish scan one row and one column.\\n* Space complexity: O(1)\\n    The algorithm only needs four integers : row, col, height, width, so the space complexity is constant.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if len(matrix) == 0: return False\\n        # we initialize the pointer at the bottom-left of the matrix\\n        r,c = len(matrix)-1,0\\n        while r >=0 and c <len(matrix[0]):\\n            if matrix[r][c] == target:\\n                return True\\n            else:\\n                if matrix[r][c] < target:\\n                    c += 1\\n                else:\\n                    r -= 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307132,
                "title": "o-log-m-log-n-double-directional-binary-search-in-java",
                "content": "**Idea:**\\n- Search from top-right corner of the matrix;\\n- If the current number is smaller than `target`, binary search row from `row + 1` to `rows - 1` given the current `col`;\\n- Else if the current number is greater than `target`, binary search col from `0` to `cols - 1` given the current `row`.\\n\\n**Code:**\\n```java\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rows, cols;\\n        // Input check\\n        if (matrix == null || (rows = matrix.length) == 0 || (cols = matrix[0].length) == 0) {\\n            return false;\\n        }\\n        \\n        for (int row = 0, col = cols - 1; row >= 0 && row < rows && col >= 0 && col < cols;) {\\n            if (matrix[row][col] == target) {\\n                // Found target\\n                return true;\\n            }\\n            if (matrix[row][col] < target) {\\n                // Target is greater than current number, binary search row in [row + 1, rows - 1] in current column\\n                row = binarySearchInCol(matrix, target, rows, cols, col, row + 1, rows - 1);\\n            } else {\\n                // Target is smaller than current number, binary search col in [0, col - 1] in current row\\n                col = binarySearchInRow(matrix, target, rows, cols, row, 0, col - 1);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int binarySearchInRow(int[][] matrix, int target, int rows, int cols, int row, int low, int high) {\\n        if (low > high) {\\n            return cols;\\n        }\\n        while (low < high) {\\n            int mid = low + ((high - low) >> 1);\\n            if (matrix[row][mid] >= target) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    private int binarySearchInCol(int[][] matrix, int target, int rows, int cols, int col, int low, int high) {\\n        if (low > high) {\\n            return rows;\\n        }\\n        while (low < high) {\\n            int mid = low + ((high - low) >> 1);\\n            if (matrix[mid][col] >= target) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int rows, cols;\\n        // Input check\\n        if (matrix == null || (rows = matrix.length) == 0 || (cols = matrix[0].length) == 0) {\\n            return false;\\n        }\\n        \\n        for (int row = 0, col = cols - 1; row >= 0 && row < rows && col >= 0 && col < cols;) {\\n            if (matrix[row][col] == target) {\\n                // Found target\\n                return true;\\n            }\\n            if (matrix[row][col] < target) {\\n                // Target is greater than current number, binary search row in [row + 1, rows - 1] in current column\\n                row = binarySearchInCol(matrix, target, rows, cols, col, row + 1, rows - 1);\\n            } else {\\n                // Target is smaller than current number, binary search col in [0, col - 1] in current row\\n                col = binarySearchInRow(matrix, target, rows, cols, row, 0, col - 1);\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private int binarySearchInRow(int[][] matrix, int target, int rows, int cols, int row, int low, int high) {\\n        if (low > high) {\\n            return cols;\\n        }\\n        while (low < high) {\\n            int mid = low + ((high - low) >> 1);\\n            if (matrix[row][mid] >= target) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    private int binarySearchInCol(int[][] matrix, int target, int rows, int cols, int col, int low, int high) {\\n        if (low > high) {\\n            return rows;\\n        }\\n        while (low < high) {\\n            int mid = low + ((high - low) >> 1);\\n            if (matrix[mid][col] >= target) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 173902,
                "title": "simple-easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix:\\n            return False\\n        i, j = 0, len(matrix[0]) - 1\\n        while 0 <= i < len(matrix) and 0 <= j < len(matrix[0]):\\n            if target < matrix[i][j]:\\n                j -= 1\\n            elif target > matrix[i][j]:\\n                i += 1\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix:\\n            return False\\n        i, j = 0, len(matrix[0]) - 1\\n        while 0 <= i < len(matrix) and 0 <= j < len(matrix[0]):\\n            if target < matrix[i][j]:\\n                j -= 1\\n            elif target > matrix[i][j]:\\n                i += 1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 66259,
                "title": "an-easy-understanding-solution",
                "content": "     // any comments are welcome\\n     bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0, j = n - 1;\\n        \\n        // search target from up-right side to down-left side\\n        while (i <= m-1 && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target)\\n                --j;\\n            else // matrix[i][j] < target\\n                ++i;\\n        }\\n        \\n        return false;\\n    }",
                "solutionTags": [],
                "code": "     // any comments are welcome\\n     bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0, j = n - 1;\\n        \\n        // search target from up-right side to down-left side\\n        while (i <= m-1 && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target)\\n                --j;\\n            else // matrix[i][j] < target\\n                ++i;\\n        }\\n        \\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3949622,
                "title": "best-o-m-n-solution",
                "content": "# Approach\\nTwo Pointer\\n\\n# Complexity\\n- Time complexity:\\n$$O(m+n)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0, j = n - 1;\\n        while (i < m && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target)\\n                j--;\\n            else\\n                i++;        \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size();\\n        int i = 0, j = n - 1;\\n        while (i < m && j >= 0) {\\n            if (matrix[i][j] == target)\\n                return true;\\n            else if (matrix[i][j] > target)\\n                j--;\\n            else\\n                i++;        \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922848,
                "title": "most-optimal-solution-with-explanation-eliminating-the-rows-and-cols-concept-of-binary-search",
                "content": "\\n\\n# Approach\\n1. Start from the top-right corner of the matrix (row = 0, col = m-1), where n is the number of rows and m is the number of columns in the matrix.\\n2. Compare the element at the current position (matrix[row][col]) with the target value:\\n    - If the element is equal to the target, return true.\\n    - If the element is less than the target, move to the next row (row++) to explore larger elements.\\n    - If the element is greater than the target, move to the previous column (col--) to explore smaller elements.\\n3. Continue the process until either the target is found, or the search goes out of bounds (row >= n or col < 0).\\n4. If the target is not found in the matrix, return false.\\n\\n# Complexity\\n- Time complexity:\\nO(m+n)\\n\\n- Space complexity:\\nO(1)\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int row = 0, col = m-1;\\n        while(row < n && col >= 0) {\\n            if (matrix[row][col] == target) return true;\\n            else if (matrix[row][col] < target) row++;\\n            else col--;\\n        }\\n        return false;\\n    }\\n};\\n```\\n```JAVA []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int row = 0, col = m - 1;\\n        \\n        while (row < n && col >= 0) {\\n            if (matrix[row][col] == target) {\\n                return true;\\n            } else if (matrix[row][col] < target) {\\n                row++;\\n            } else {\\n                col--;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        row, col = 0, m - 1\\n        \\n        while row < n and col >= 0:\\n            if matrix[row][col] == target:\\n                return True\\n            elif matrix[row][col] < target:\\n                row += 1\\n            else:\\n                col -= 1\\n        \\n        return False\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Divide and Conquer",
                    "Matrix"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int row = 0, col = m-1;\\n        while(row < n && col >= 0) {\\n            if (matrix[row][col] == target) return true;\\n            else if (matrix[row][col] < target) row++;\\n            else col--;\\n        }\\n        return false;\\n    }\\n};\\n```\n```JAVA []\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int row = 0, col = m - 1;\\n        \\n        while (row < n && col >= 0) {\\n            if (matrix[row][col] == target) {\\n                return true;\\n            } else if (matrix[row][col] < target) {\\n                row++;\\n            } else {\\n                col--;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        row, col = 0, m - 1\\n        \\n        while row < n and col >= 0:\\n            if matrix[row][col] == target:\\n                return True\\n            elif matrix[row][col] < target:\\n                row += 1\\n            else:\\n                col -= 1\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916490,
                "title": "c-binary-search-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].size()-1;\\n\\n        while(i<matrix.size() && j>=0){\\n            if(matrix[i][j]==target)return true;\\n            else if(matrix[i][j]<target)i++;\\n            else j--;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].size()-1;\\n\\n        while(i<matrix.size() && j>=0){\\n            if(matrix[i][j]==target)return true;\\n            else if(matrix[i][j]<target)i++;\\n            else j--;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767522,
                "title": "java-easy-solution-with-comments",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        while(row<matrix.length && col>=0){\\n            if(matrix[row][col]==target) return true;\\n            else if(matrix[row][col]<target) row++; //if that element is lesser than target it mean that whole row is useless\\n            else col--; //if that element is greater than target it mean that column is useless \\n        }\\n        return false;\\n    }\\n}\\n\\n//In given example 1, it will start with 15, now 15>5 so all elements of last column will be greater than 5\\n//therefore col--;\\n//Now it will check 11... This way when 4 will come, 4<5 so all elements in that row will be smaller than 4\\n//so row++; \\n```\\n![upvoteCat.png](https://assets.leetcode.com/users/images/56e36cbe-69ab-4de9-a348-7f3e59bd6171_1689406643.5026598.png)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        while(row<matrix.length && col>=0){\\n            if(matrix[row][col]==target) return true;\\n            else if(matrix[row][col]<target) row++; //if that element is lesser than target it mean that whole row is useless\\n            else col--; //if that element is greater than target it mean that column is useless \\n        }\\n        return false;\\n    }\\n}\\n\\n//In given example 1, it will start with 15, now 15>5 so all elements of last column will be greater than 5\\n//therefore col--;\\n//Now it will check 11... This way when 4 will come, 4<5 so all elements in that row will be smaller than 4\\n//so row++; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553736,
                "title": "o-m-n-easy-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two points from where we can start searching i.e - \\n1) From top right corner\\n2) From bottom left corner\\nIn this approach, I have explained throung top right corner, take a Starting position to top right corner value of matrix and compare if(position == target) return true, \\nor if(position < target) then jump to the position to next row of same column because the values below our position can caontains target vcalue;\\nor if(position > target) then jump to previous column of same row as only the values to the left of position can contains target value.\\nRepeat until you reach last row or first column.\\n\\n![Screenshot (501).png](https://assets.leetcode.com/users/images/4ce363ab-c62f-4597-8104-bd640c8d09dc_1684795370.9902685.png)\\n\\n# Complexity\\n- Time complexity: <b>O(n+m)</b>\\n- Auxillary Space complexity: <b>O(1)</b>\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int row = 0;\\n        int col = m-1;\\n        while(row < n && col >= 0)\\n        {\\n            if(matrix[row][col] == target) return true;\\n            else if(matrix[row][col] < target) row++;\\n            else    col--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Divide and Conquer",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        int row = 0;\\n        int col = m-1;\\n        while(row < n && col >= 0)\\n        {\\n            if(matrix[row][col] == target) return true;\\n            else if(matrix[row][col] < target) row++;\\n            else    col--;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932829,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int r=0,c=n-1;\\n        while(r<m && c>=0)\\n        {\\n            if(matrix[r][c]==target)\\n                return target;\\n            else if(matrix[r][c]>target)\\n                c--;\\n            else\\n                r++;\\n        }\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int r=0,c=n-1;\\n        while(r<m && c>=0)\\n        {\\n            if(matrix[r][c]==target)\\n                return target;\\n            else if(matrix[r][c]>target)\\n                c--;\\n            else\\n                r++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778034,
                "title": "240-search-a-2d-matrix-i",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolve it by using binary search on each row\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversing each row from bottom and check if the target lies in the range of the first and last element of ith row.If the target lies in the range then search for target using binary search.If found then return true.If not,then continue the traversing.If the last element of any row is found to be less than the target then break the loop and return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <iostream>\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    bool searchMatrix(vector<vector<int>> &matrix, int target)\\n    {\\n        int row = matrix.size(), col = matrix[0].size();\\n        for (int i = row - 1; i >= 0; i--)\\n        {\\n            if (matrix[i][0] <= target && target <= matrix[i][col - 1])\\n            {\\n                int r = col - 1, l = 0, mid;\\n                while (l <= r)\\n                {\\n                    mid = (l + r) / 2;\\n                    if (matrix[i][mid] == target)\\n                    {\\n                        return true;\\n                    }\\n                    else if (matrix[i][mid] < target)\\n                    {\\n                        l = mid + 1;\\n                    }\\n                    else\\n                        r = mid - 1;\\n                    ;\\n                }\\n            }\\n            else if (target > matrix[i][col - 1])\\n            {\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <iostream>\\n#include <bits/stdc++.h>\\nusing namespace std;\\nclass Solution\\n{\\npublic:\\n    bool searchMatrix(vector<vector<int>> &matrix, int target)\\n    {\\n        int row = matrix.size(), col = matrix[0].size();\\n        for (int i = row - 1; i >= 0; i--)\\n        {\\n            if (matrix[i][0] <= target && target <= matrix[i][col - 1])\\n            {\\n                int r = col - 1, l = 0, mid;\\n                while (l <= r)\\n                {\\n                    mid = (l + r) / 2;\\n                    if (matrix[i][mid] == target)\\n                    {\\n                        return true;\\n                    }\\n                    else if (matrix[i][mid] < target)\\n                    {\\n                        l = mid + 1;\\n                    }\\n                    else\\n                        r = mid - 1;\\n                    ;\\n                }\\n            }\\n            else if (target > matrix[i][col - 1])\\n            {\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2554392,
                "title": "search-in-a-2d-matrix-using-binary-search",
                "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n         int row= matrix.length;\\n        int column= matrix[0].length;\\n        \\n        int rowindex=0;\\n        int columnindex=column-1;\\n        \\n        while(rowindex<row && columnindex>=0){\\n            \\n            int element= matrix[rowindex][columnindex];\\n            \\n            if(element==target){\\n                return true;\\n            }\\n            else if(element<target){\\n                rowindex++;\\n                \\n            }\\n            else{\\n                columnindex--;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        \\n         int row= matrix.length;\\n        int column= matrix[0].length;\\n        \\n        int rowindex=0;\\n        int columnindex=column-1;\\n        \\n        while(rowindex<row && columnindex>=0){\\n            \\n            int element= matrix[rowindex][columnindex];\\n            \\n            if(element==target){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2327323,
                "title": "golang-true-binary-search-two-pointers",
                "content": "\\n\\n**1.Diagonal binary search. Complexity O(ln(n) + ln(m))**\\n\\n```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\n\\tn, m := len(matrix), len(matrix[0])\\n\\n\\tmin := func(i1 int, i2 int) int {\\n\\t\\tif i1 < i2 {\\n\\t\\t\\treturn i1\\n\\t\\t}\\n\\t\\treturn i2\\n\\t}\\n\\t\\n\\tvar binarysearch func(x1 int, x2 int, y1 int, y2 int) bool\\n\\tbinarysearch = func(x1 int, x2 int, y1 int, y2 int) bool {\\n\\t\\tif x1 > x2 || y1 > y2 {\\n\\t\\t\\treturn false\\n\\t\\t}\\t\\n\\t\\tdelta := min(x2 - x1,  y2 - y1);\\n\\t\\tlo1, lo2, hi1, hi2 := x1, y1, x1 + delta, y1 + delta\\n\\n\\t\\tfor lo1 <= hi1 && lo2 <= hi2 {\\n\\t\\t\\tm1 := lo1 + (hi1 - lo1) / 2\\n\\t\\t\\tm2 := lo2 + (hi2 - lo2) / 2\\n\\t\\t\\tv := matrix[m1][m2]\\n\\t\\t\\tif v == target {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t} else if matrix[m1][m2] > target {\\n\\t\\t\\t\\thi1 = m1 - 1\\n\\t\\t\\t\\thi2 = m2 - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlo1 = m1 + 1\\n\\t\\t\\t\\tlo2 = m2 + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn binarysearch(lo1, x2, y1, hi2) || binarysearch(x1, hi1, lo2, y2)\\t\\n\\t}\\n\\n\\treturn binarysearch(0, n-1, 0, m-1)\\n}\\n```\\n\\n**2. Two pointer approach. Complexity O(n + m)**\\n```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\n\\tn, m := len(matrix), len(matrix[0])\\n\\ti, j := 0, m-1\\n\\t\\n\\tfor i < n && j >= 0 {\\n\\t\\tv := matrix[i][j]\\n\\t\\tif v == target {\\n\\t\\t\\treturn true\\n\\t\\t} else if v > target {\\n\\t\\t\\tj -= 1\\n\\t\\t} else { \\n\\t\\t\\ti += 1\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\n\\tn, m := len(matrix), len(matrix[0])\\n\\n\\tmin := func(i1 int, i2 int) int {\\n\\t\\tif i1 < i2 {\\n\\t\\t\\treturn i1\\n\\t\\t}\\n\\t\\treturn i2\\n\\t}\\n\\t\\n\\tvar binarysearch func(x1 int, x2 int, y1 int, y2 int) bool\\n\\tbinarysearch = func(x1 int, x2 int, y1 int, y2 int) bool {\\n\\t\\tif x1 > x2 || y1 > y2 {\\n\\t\\t\\treturn false\\n\\t\\t}\\t\\n\\t\\tdelta := min(x2 - x1,  y2 - y1);\\n\\t\\tlo1, lo2, hi1, hi2 := x1, y1, x1 + delta, y1 + delta\\n\\n\\t\\tfor lo1 <= hi1 && lo2 <= hi2 {\\n\\t\\t\\tm1 := lo1 + (hi1 - lo1) / 2\\n\\t\\t\\tm2 := lo2 + (hi2 - lo2) / 2\\n\\t\\t\\tv := matrix[m1][m2]\\n\\t\\t\\tif v == target {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t} else if matrix[m1][m2] > target {\\n\\t\\t\\t\\thi1 = m1 - 1\\n\\t\\t\\t\\thi2 = m2 - 1\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlo1 = m1 + 1\\n\\t\\t\\t\\tlo2 = m2 + 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn binarysearch(lo1, x2, y1, hi2) || binarysearch(x1, hi1, lo2, y2)\\t\\n\\t}\\n\\n\\treturn binarysearch(0, n-1, 0, m-1)\\n}\\n```\n```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\n\\tn, m := len(matrix), len(matrix[0])\\n\\ti, j := 0, m-1\\n\\t\\n\\tfor i < n && j >= 0 {\\n\\t\\tv := matrix[i][j]\\n\\t\\tif v == target {\\n\\t\\t\\treturn true\\n\\t\\t} else if v > target {\\n\\t\\t\\tj -= 1\\n\\t\\t} else { \\n\\t\\t\\ti += 1\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2325012,
                "title": "using-two-pointer-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n         int n=matrix.size();\\n        int m=matrix[0].size()-1;\\n        int i=0;\\n        int j=m;\\n        while(i<n&&j>=0)\\n        {\\n            if(matrix[i][j]==target) // RETURN TRUE IF TARGET GOT FOUND\\n            return true;\\n            else if(matrix[i][j]>target)\\n            {\\n                j--;\\n            }\\n            else \\n            {\\n                i++;\\n            }\\n        }\\n        \\n        return false; // TARGET IS NOT PRESENT.SO RETURN FALSE\\n    }\\n};\\n```\\n**TIME COMPLEXITY;-O(M+N)**\\n**SPACE COMPLEXITY:-O(1)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n         int n=matrix.size();\\n        int m=matrix[0].size()-1;\\n        int i=0;\\n        int j=m;\\n        while(i<n&&j>=0)\\n        {\\n            if(matrix[i][j]==target) // RETURN TRUE IF TARGET GOT FOUND\\n            return true;\\n            else if(matrix[i][j]>target)\\n            {\\n                j--;\\n            }\\n            else \\n            {\\n                i++;\\n            }\\n        }\\n        \\n        return false; // TARGET IS NOT PRESENT.SO RETURN FALSE\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2324229,
                "title": "daily-leetcoding-challenge-july-day-24",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Binary Search\n\n  \n**Approach 3:** Divide and Conquer\n\n  \n**Approach 4:** Search Space Reduction\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/search-a-2d-matrix-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1897489,
                "title": "c-short-and-fast-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int rows=matrix.size();\\n        \\n        int i=0;      //1st row\\n        int j=matrix[0].size()-1;  //last column\\n        \\n        if(matrix[0][0]==target)\\n            return true;\\n        \\n        while(j>=0 and i<rows) {\\n            if(matrix[i][j]==target)\\n                    return true;\\n                \\n            target<matrix[i][j] ? j-- : i++;\\n        }\\n        return false;\\n    }\\n};\\n\\nif(foundHelpful)\\n\\tupVote();",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int rows=matrix.size();\\n        \\n        int i=0;      //1st row\\n        int j=matrix[0].size()-1;  //last column\\n        \\n        if(matrix[0][0]==target)\\n            return true;\\n        \\n        while(j>=0 and i<rows) {\\n            if(matrix[i][j]==target)\\n                    return true;\\n                \\n            target<matrix[i][j] ? j-- : i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1079103,
                "title": "c-easy-works",
                "content": "```\\npublic class Solution {\\n    public bool SearchMatrix(int[][] matrix, int target) {\\n        \\n        int row = 0;\\n        int col = matrix[0].Length-1;\\n        \\n        while(row < matrix.Length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            } else if(target < matrix[row][col]){\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool SearchMatrix(int[][] matrix, int target) {\\n        \\n        int row = 0;\\n        int col = matrix[0].Length-1;\\n        \\n        while(row < matrix.Length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            } else if(target < matrix[row][col]){\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079067,
                "title": "search-a-2d-matrix-ii-c-easy-implementation",
                "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n       long int n=matrix[0].size();\\n      bool f=0;\\n            for(long int i=0,j=n-1;j>=0 && i<matrix.size();)\\n            {\\n                if(matrix[i][j]==target)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(matrix[i][j]>target)j--;\\n                else i++;\\n            }\\n        \\n       if(f)return true;\\n        else return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n       long int n=matrix[0].size();\\n      bool f=0;\\n            for(long int i=0,j=n-1;j>=0 && i<matrix.size();)\\n            {\\n                if(matrix[i][j]==target)\\n                {\\n                    f=1;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 701264,
                "title": "short-c-o-m-n-well-explained",
                "content": "```\\n/*\\n\\tThe idea is simple start from the top right corner of the matrix \\n\\t1. if the target is smaller than the present element at (i,j)\\n\\t\\t then it is also smaller than all the elements in the column j (because matrix is sorted coulmn wise also)\\n\\t\\t therefore we change the coulumn i.e j--;\\n\\t\\n\\t2. else if the target is greater than the present element at (i,j)\\n\\t\\t then it is also greater than all the elements in the row i (because matrix is sorted row wise also)\\n\\t\\t therefore we change the row i.e i++;\\n\\t\\n\\t3. else return true because we have found the element\\n\\t4. otherwise return false because target is not present\\n\\nBELOW is the implementation of this illustration.\\n\\n*/\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int m=mat.size(); if(m==0) return false;\\n        int n=mat[0].size(),i=0,j=n-1;\\n        while(i<m and j>=0)\\n        {\\n            if(target < mat[i][j]) j--;\\n            else if(target > mat[i][j]) i++;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\tThe idea is simple start from the top right corner of the matrix \\n\\t1. if the target is smaller than the present element at (i,j)\\n\\t\\t then it is also smaller than all the elements in the column j (because matrix is sorted coulmn wise also)\\n\\t\\t therefore we change the coulumn i.e j--;\\n\\t\\n\\t2. else if the target is greater than the present element at (i,j)\\n\\t\\t then it is also greater than all the elements in the row i (because matrix is sorted row wise also)\\n\\t\\t therefore we change the row i.e i++;\\n\\t\\n\\t3. else return true because we have found the element\\n\\t4. otherwise return false because target is not present\\n\\nBELOW is the implementation of this illustration.\\n\\n*/\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int m=mat.size(); if(m==0) return false;\\n        int n=mat[0].size(),i=0,j=n-1;\\n        while(i<m and j>=0)\\n        {\\n            if(target < mat[i][j]) j--;\\n            else if(target > mat[i][j]) i++;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567573,
                "title": "simple-python-o-m-n-and-o-mlg-n-solution",
                "content": "**O(mlog(n))**\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        m = len(matrix)\\n        if m < 1:\\n            return False\\n        n = len(matrix[0])\\n        if n < 1:\\n            return False\\n        i = 0\\n        while i < m and target >= matrix[i][0]:\\n            low, high = 0, n\\n            while low < high:\\n                mid = (low+high)//2\\n                if target > matrix[i][mid]:\\n                    low = mid + 1\\n                elif target < matrix[i][mid]:\\n                    high = mid\\n                else:\\n                    return True\\n            i += 1\\n        return False\\n```\\n**O(m+n)**\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        m = len(matrix)\\n        if m < 1:\\n            return False\\n        n = len(matrix[0])\\n        if n < 1:\\n            return False\\n        row, col = 0, n - 1\\n        while row < m and col >= 0:\\n            curr = matrix[row][col]\\n            if target > curr:\\n                row += 1\\n            elif target < curr:\\n                col -= 1\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        m = len(matrix)\\n        if m < 1:\\n            return False\\n        n = len(matrix[0])\\n        if n < 1:\\n            return False\\n        i = 0\\n        while i < m and target >= matrix[i][0]:\\n            low, high = 0, n\\n            while low < high:\\n                mid = (low+high)//2\\n                if target > matrix[i][mid]:\\n                    low = mid + 1\\n                elif target < matrix[i][mid]:\\n                    high = mid\\n                else:\\n                    return True\\n            i += 1\\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        m = len(matrix)\\n        if m < 1:\\n            return False\\n        n = len(matrix[0])\\n        if n < 1:\\n            return False\\n        row, col = 0, n - 1\\n        while row < m and col >= 0:\\n            curr = matrix[row][col]\\n            if target > curr:\\n                row += 1\\n            elif target < curr:\\n                col -= 1\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151818,
                "title": "start-from-bottom-left-top-right-time-o-m-n",
                "content": "The Brute Force solution takes time O(m * n).\\n\\nTo optimize,  let\\'s observe how we can take advantage of the matrix\\'s property.\\n```\\n1. if there is only one row, if curDigit \\n                >  target, we check digits to its left\\n                <  target, we check digits to its right\\n2. if there is only one col, if curDigit \\n                >  target, we check digits on its top\\n                <  target, we check digits on its bottom\\n3. if a curDigit is at the cross of a row and a col,\\n\\t    if curDigit \\n                >  target, we check digits to its left AND on its top\\n                <  target, we check digits to its right AND on its bottom\\n\\t\\t\\t\\t\\n        BUT if we traverse the matrix from the bottom-left corner, then we only have to move top / right, since other digits have been invalidated already, that is,\\n\\t    if curDigit\\n                >  target, we check digits to its top\\n                <  target, we check digits on its right\\n\\t\\t\\t\\t\\n        OR if we traverse the matrix from the top-right corner, then we only have to move bottom / left, since other digits have been invalidated already, that is,\\n\\t    if curDigit\\n                >  target, we check digits to its left\\n                <  target, we check digits on its bottom\\n```\\nThis approach takes time O(m + n).\\n\\n****\\n**Bottom-left**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) { \\n        int rows = matrix.length, cols = matrix[0].length; \\n        \\n        int i = rows - 1, j = 0; // Starts at bottom-left\\n        \\n        while (i >= 0 && j < cols) {\\n            if (matrix[i][j] == target) {\\n                return true;\\n            } else if (matrix[i][j] > target) {\\n                i--;\\n            } else {\\n                j++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n**Top-right**\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) { \\n        int rows = matrix.length, cols = matrix[0].length; \\n        \\n        int i = 0, j = cols - 1; // Starts at top-right\\n        \\n        while (j >= 0 && i < rows) {\\n            if (matrix[i][j] == target) {\\n                return true;\\n            } else if (matrix[i][j] > target) {\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n1. if there is only one row, if curDigit \\n                >  target, we check digits to its left\\n                <  target, we check digits to its right\\n2. if there is only one col, if curDigit \\n                >  target, we check digits on its top\\n                <  target, we check digits on its bottom\\n3. if a curDigit is at the cross of a row and a col,\\n\\t    if curDigit \\n                >  target, we check digits to its left AND on its top\\n                <  target, we check digits to its right AND on its bottom\\n\\t\\t\\t\\t\\n        BUT if we traverse the matrix from the bottom-left corner, then we only have to move top / right, since other digits have been invalidated already, that is,\\n\\t    if curDigit\\n                >  target, we check digits to its top\\n                <  target, we check digits on its right\\n\\t\\t\\t\\t\\n        OR if we traverse the matrix from the top-right corner, then we only have to move bottom / left, since other digits have been invalidated already, that is,\\n\\t    if curDigit\\n                >  target, we check digits to its left\\n                <  target, we check digits on its bottom\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) { \\n        int rows = matrix.length, cols = matrix[0].length; \\n        \\n        int i = rows - 1, j = 0; // Starts at bottom-left\\n        \\n        while (i >= 0 && j < cols) {\\n            if (matrix[i][j] == target) {\\n                return true;\\n            } else if (matrix[i][j] > target) {\\n                i--;\\n            } else {\\n                j++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) { \\n        int rows = matrix.length, cols = matrix[0].length; \\n        \\n        int i = 0, j = cols - 1; // Starts at top-right\\n        \\n        while (j >= 0 && i < rows) {\\n            if (matrix[i][j] == target) {\\n                return true;\\n            } else if (matrix[i][j] > target) {\\n                j--;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145663,
                "title": "python-solution-using-divide-and-conquer",
                "content": "O(n^1.58), the formula is T(n) = 3T(n/2) + c.\\n```\\n\\tdef helper(matrix, rowStart, rowEnd, colStart, colEnd, target):\\n            if(rowStart > rowEnd) | (colStart > colEnd):\\n                return False\\n            rowMid = (rowStart + rowEnd) // 2\\n            colMid = (colStart + colEnd) // 2\\n            if(matrix[rowMid][colMid] == target):\\n                return True\\n            elif (matrix[rowMid][colMid] > target):\\n                return helper(matrix, rowStart, rowMid - 1, colStart, colMid - 1, target) | helper(matrix, rowMid, rowEnd, colStart, colMid - 1, target) | helper(matrix, rowStart, rowMid - 1, colMid - 1, colEnd, target)\\n            else:\\n                return helper(matrix, rowMid + 1, rowEnd, colMid + 1, colEnd, target) | helper(matrix, rowMid + 1, rowEnd, colStart, colMid, target)| helper(matrix, rowStart, rowMid, colMid + 1, colEnd, target)\\n\\n        if not matrix or len(matrix) < 1 or len(matrix[0]) < 1:\\n            return False\\n\\trow, col = len(matrix), len(matrix[0])\\n        return helper(matrix, 0, row - 1, 0, col - 1, target)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef helper(matrix, rowStart, rowEnd, colStart, colEnd, target):\\n            if(rowStart > rowEnd) | (colStart > colEnd):\\n                return False\\n            rowMid = (rowStart + rowEnd) // 2\\n            colMid = (colStart + colEnd) // 2\\n            if(matrix[rowMid][colMid] == target):\\n                return True\\n            elif (matrix[rowMid][colMid] > target):\\n                return helper(matrix, rowStart, rowMid - 1, colStart, colMid - 1, target) | helper(matrix, rowMid, rowEnd, colStart, colMid - 1, target) | helper(matrix, rowStart, rowMid - 1, colMid - 1, colEnd, target)\\n            else:\\n                return helper(matrix, rowMid + 1, rowEnd, colMid + 1, colEnd, target) | helper(matrix, rowMid + 1, rowEnd, colStart, colMid, target)| helper(matrix, rowStart, rowMid, colMid + 1, colEnd, target)\\n\\n        if not matrix or len(matrix) < 1 or len(matrix[0]) < 1:\\n            return False\\n\\trow, col = len(matrix), len(matrix[0])\\n        return helper(matrix, 0, row - 1, 0, col - 1, target)\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3820594,
                "title": "2-c-solutions-binary-search-approach-o-m-n-and-o-mlogn-time-complexity",
                "content": "# Code\\n```\\n// Solution 1 - O(m+n) TC\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size(), r = 0, c = n - 1;\\n        while (r < m && c >= 0){\\n            if (matrix[r][c] == target)\\n                return true;\\n            // matrix[r][c] > target ? c-- : r++;\\n            else if(matrix[r][c] > target)\\n                c--;\\n            else\\n                r++;\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 2 - O(mlogn) TC\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n    if (matrix.size()==0) \\n        return false;\\n    for(int i=0; i<matrix.size(); i++){\\n        if( searchVector(matrix[i], target) ) \\n            return true;\\n    }\\n    return false;\\n }\\n\\nbool searchVector(vector<int>& v, int target){\\n    int left = 0, right = v.size() - 1;\\n\\n    while (left <= right) {\\n\\tint mid = left + (right - left) / 2;\\n\\tif (v[mid] == target)\\n\\t\\treturn true;\\n\\tif (v[mid] < target)\\n\\t\\tleft = mid + 1;\\n\\telse\\n\\t\\tright = mid - 1;\\n    }\\n\\n    return false;\\n }\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\n// Solution 1 - O(m+n) TC\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size(), n = matrix[0].size(), r = 0, c = n - 1;\\n        while (r < m && c >= 0){\\n            if (matrix[r][c] == target)\\n                return true;\\n            // matrix[r][c] > target ? c-- : r++;\\n            else if(matrix[r][c] > target)\\n                c--;\\n            else\\n                r++;\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 2 - O(mlogn) TC\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n    if (matrix.size()==0) \\n        return false;\\n    for(int i=0; i<matrix.size(); i++){\\n        if( searchVector(matrix[i], target) ) \\n            return true;\\n    }\\n    return false;\\n }\\n\\nbool searchVector(vector<int>& v, int target){\\n    int left = 0, right = v.size() - 1;\\n\\n    while (left <= right) {\\n\\tint mid = left + (right - left) / 2;\\n\\tif (v[mid] == target)\\n\\t\\treturn true;\\n\\tif (v[mid] < target)\\n\\t\\tleft = mid + 1;\\n\\telse\\n\\t\\tright = mid - 1;\\n    }\\n\\n    return false;\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237751,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n        \\n        int rows = matrix.size();\\n        int cols = matrix[0].size(); \\n\\n        int rowIndex = 0;\\n        int colIndex = cols - 1; \\n        \\n        int mid = 0;\\n\\n        while(rowIndex < rows && colIndex >= 0)\\n        {\\n            \\n            mid = matrix[rowIndex][colIndex];\\n            \\n            if(mid == target)\\n                return true;\\n            else if(mid > target)\\n                colIndex--;\\n            else\\n                rowIndex++;\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) \\n    {\\n        \\n        int rows = matrix.size();\\n        int cols = matrix[0].size(); \\n\\n        int rowIndex = 0;\\n        int colIndex = cols - 1; \\n        \\n        int mid = 0;\\n\\n        while(rowIndex < rows && colIndex >= 0)\\n        {\\n            \\n            mid = matrix[rowIndex][colIndex];\\n            \\n            if(mid == target)\\n                return true;\\n            else if(mid > target)\\n                colIndex--;\\n            else\\n                rowIndex++;\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594270,
                "title": "binary-search-c-solution-easy-to-understand-check-out",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int rowIdx = 0;\\n        int colIdx = col-1;\\n        while(rowIdx < row && colIdx >=0){\\n            int e = matrix[rowIdx][colIdx];\\n            if(e==target){\\n                return true;\\n            }\\n            if(e<target){\\n                rowIdx++;\\n            }\\n            else{\\n                colIdx--;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int rowIdx = 0;\\n        int colIdx = col-1;\\n        while(rowIdx < row && colIdx >=0){\\n            int e = matrix[rowIdx][colIdx];\\n            if(e==target){\\n                return true;\\n            }\\n            if(e<target){\\n                rowIdx++;\\n            }\\n            else{\\n                colIdx--;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452328,
                "title": "python-very-clear-explanation-with-drawing-o-m-n",
                "content": "Hello,\\n\\n**Time complexity: O(m+n), where m is the number of rows, n is the number of columns.\\nSpace complexity: O(1).**\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        rows, cols = len(matrix), len(matrix[0])\\n        \\n        top = 0\\n        right = cols-1\\n        \\n        bottom = rows-1\\n        left = 0\\n\\n        while bottom >= top and left <= right:\\n            if matrix[bottom][left] == target:\\n                return True\\n            if matrix[bottom][left] > target:\\n                bottom -= 1\\n            elif matrix[bottom][left] < target:\\n                left += 1\\n        return False\\n```\\n\\nThe idea is to start from **Bottom Left** and then go up or right depending on the current **Bottom Left**  value.\\n\\nIf the current **Bottom Left** value == target then return True.\\n\\nIf the current **Bottom Left** value is > target then go up by 1 (to ignore the whole row since this value is also samller than all the numbers on the right of it).\\n\\nIf the current **Bottom Left** value is < target then go right by 1 (because the value might still be in this row so we **do not** ignore it).\\n\\nThe current **Bottom Left** value changes everytime we go up or right.\\n\\nWe go up by doing **bottom-1**.\\nWe go right by doing **left+1**.\\n\\nBreak the loop when the **left is > right** (which is **cols-1**)\\nor\\nBreak the loop when the **bottom is < top** (which is **0**).\\n\\n**Examples with drawing:**\\n1. **matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5**\\n![image](https://assets.leetcode.com/users/images/8429db28-a5d5-4d31-ae66-8c8da6fca8cc_1660979929.5496066.jpeg)\\n\\n2. **matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20**\\n![dc25cd0e-b2ba-4f4d-8814-4383cf61e61b_1660981277.3080633.jpeg](https://assets.leetcode.com/users/images/7681ca72-0427-429e-8509-1bc61e1cc415_1665947254.116068.jpeg)\\n\\n\\n\\n3. **An example of the worst case which is O(m+n) (m: number of rows, n: number of columns)**\\n![image](https://assets.leetcode.com/users/images/5220ec80-ac24-4226-b744-9a92d4bd481c_1660981040.4934547.jpeg)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        rows, cols = len(matrix), len(matrix[0])\\n        \\n        top = 0\\n        right = cols-1\\n        \\n        bottom = rows-1\\n        left = 0\\n\\n        while bottom >= top and left <= right:\\n            if matrix[bottom][left] == target:\\n                return True\\n            if matrix[bottom][left] > target:\\n                bottom -= 1\\n            elif matrix[bottom][left] < target:\\n                left += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327142,
                "title": "c-two-easy-approach",
                "content": "# First Approach\\n**Time Comlexity: O(nlogm), where n is number of row and m is number of column **\\n```\\nclass Solution {\\npublic:\\n    bool binary_search(vector<int> &v1,int target){\\n        \\n        int low  = 0;\\n        int high = v1.size()-1;\\n       \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(v1[mid]<target){\\n                low = mid+1;\\n            }\\n            else if(v1[mid]>target){\\n                high = mid-1;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n\\t\\tint row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        for(int i=0;i<row;i++){\\n\\t\\t    // check if first element of each row is less than or equal to target or not..\\n            if(matrix[i][0]<=target){\\n               // do a binary search in this sorted array matrix[i]...\\n                if(binary_search(matrix[i],target)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n# Second Approach\\n**Time Comlexity: O(n+m), where n is number of row and m is number of column**\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int i=0,j=col-1;\\n        \\n        while(i<row && j>=0){\\n            if(matrix[i][j]==target){\\n                return true;\\n            }\\n\\t\\t\\telse if(matrix[i][j]>target){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool binary_search(vector<int> &v1,int target){\\n        \\n        int low  = 0;\\n        int high = v1.size()-1;\\n       \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            if(v1[mid]<target){\\n                low = mid+1;\\n            }\\n            else if(v1[mid]>target){\\n                high = mid-1;\\n            }\\n            else{\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n\\t\\tint row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        for(int i=0;i<row;i++){\\n\\t\\t    // check if first element of each row is less than or equal to target or not..\\n            if(matrix[i][0]<=target){\\n               // do a binary search in this sorted array matrix[i]...\\n                if(binary_search(matrix[i],target)){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int i=0,j=col-1;\\n        \\n        while(i<row && j>=0){\\n            if(matrix[i][j]==target){\\n                return true;\\n            }\\n\\t\\t\\telse if(matrix[i][j]>target){\\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325029,
                "title": "4-line-code-c-fast-simple",
                "content": "class Solution {\\n```\\npublic:\\n    bool searchMatrix(vector<vector<int>>& m, int t) {\\n        for(int i=0, j=m[0].size()-1; i<m.size() && j>=0; ){\\n            if(m[i][j] < t)i++;\\n            else if(m[i][j] > t)j--;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    bool searchMatrix(vector<vector<int>>& m, int t) {\\n        for(int i=0, j=m[0].size()-1; i<m.size() && j>=0; ){\\n            if(m[i][j] < t)i++;\\n            else if(m[i][j] > t)j--;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2282164,
                "title": "c-binary-search-bottom-left-top-right-approach",
                "content": "```\\n//Method -1 Apply Binary Search on every row\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int>&vec,int i,int j,int target)\\n    {\\n        if(i>j)return false;\\n        int mid=(i+j)/2;\\n        if(vec[mid]==target)return true;\\n        else if(vec[mid]>target)return binarySearch(vec,i,mid-1,target);\\n        else return binarySearch(vec,mid+1,j,target);\\n    }\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            if(binarySearch(matrix[i],0,matrix[i].size()-1,target))return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```\\n//Method 2 start with bottom left and top right and update the pointers as per target\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int up=0;\\n        int left=0;\\n        int down=matrix.size()-1;\\n        int right=matrix[0].size()-1;        \\n        while(up<=down&&left<=right)\\n        {\\n            if(matrix[up][right]==target||matrix[down][left]==target)return true;\\n            if(matrix[up][right]<target){\\n                up++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n            if(matrix[down][left]<target){\\n                left++;\\n            }\\n            else\\n            {\\n                down--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```\\n//Method-3 Just use top right or bottom left\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int up=0;\\n        int left=0;\\n        int down=matrix.size()-1;\\n        int right=matrix[0].size()-1;        \\n        while(up<=down&&left<=right)\\n        {\\n            if(matrix[up][right]==target)return true;\\n            if(matrix[up][right]<target){\\n                up++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```\\n//Method -1 Apply Binary Search on every row\\nclass Solution {\\npublic:\\n    bool binarySearch(vector<int>&vec,int i,int j,int target)\\n    {\\n        if(i>j)return false;\\n        int mid=(i+j)/2;\\n        if(vec[mid]==target)return true;\\n        else if(vec[mid]>target)return binarySearch(vec,i,mid-1,target);\\n        else return binarySearch(vec,mid+1,j,target);\\n    }\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            if(binarySearch(matrix[i],0,matrix[i].size()-1,target))return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n//Method 2 start with bottom left and top right and update the pointers as per target\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int up=0;\\n        int left=0;\\n        int down=matrix.size()-1;\\n        int right=matrix[0].size()-1;        \\n        while(up<=down&&left<=right)\\n        {\\n            if(matrix[up][right]==target||matrix[down][left]==target)return true;\\n            if(matrix[up][right]<target){\\n                up++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n            if(matrix[down][left]<target){\\n                left++;\\n            }\\n            else\\n            {\\n                down--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n//Method-3 Just use top right or bottom left\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int up=0;\\n        int left=0;\\n        int down=matrix.size()-1;\\n        int right=matrix[0].size()-1;        \\n        while(up<=down&&left<=right)\\n        {\\n            if(matrix[up][right]==target)return true;\\n            if(matrix[up][right]<target){\\n                up++;\\n            }\\n            else\\n            {\\n                right--;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243976,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int t) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n        int i=0,j=col-1;\\n        while(i>=0 && i<row && j>=0 && j<col){\\n            if(matrix[i][j]==t){\\n                return true;\\n            }\\n            else if(matrix[i][j]>t){\\n                j--;\\n            }else if(matrix[i][j]<t){\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/*class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            \\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                \\n                if(matrix[i][j]==target)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}*/\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int t) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n        int i=0,j=col-1;\\n        while(i>=0 && i<row && j>=0 && j<col){\\n            if(matrix[i][j]==t){\\n                return true;\\n            }\\n            else if(matrix[i][j]>t){\\n                j--;\\n            }else if(matrix[i][j]<t){\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n/*class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n\\n        for(int i=0;i<matrix.length;i++)\\n        {\\n            \\n            for(int j=0;j<matrix.length;j++)\\n            {\\n                \\n                if(matrix[i][j]==target)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917568,
                "title": "java-efficient-o-row-col-binary-search",
                "content": "We will go in a Binary search kind of pattern i.e \\nif the elem **is** target we return it \\nelse if the elem is **less** than target we inc the row i.e go down\\nelse if the elem is **greater** we go left i.e dec the col\\n\\nand Bamm we are done \\nall the **hungryCoders** out there if it fulfilled your hunger hit the **UPVOTE** Button will take only 3secs \\u2764\\uD83D\\uDE1C\\n\\n```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\nint col = matrix[0].length-1;\\n\\tint row=0;\\n\\twhile(row<matrix.length && col>=0){\\n\\t\\tif(matrix[row][col]==target)return true;\\n\\t\\telse if(matrix[row][col]>target)col--;\\n\\t\\telse if(matrix[row][col]<target)row++;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\nint col = matrix[0].length-1;\\n\\tint row=0;\\n\\twhile(row<matrix.length && col>=0){\\n\\t\\tif(matrix[row][col]==target)return true;\\n\\t\\telse if(matrix[row][col]>target)col--;\\n\\t\\telse if(matrix[row][col]<target)row++;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1723456,
                "title": "search-a-2d-matrix-ii-java-100-faster-and-simple-solution-using-binary-search",
                "content": "Please Upvote if you understood and like the solution\\nvery simple program nothing is hard...all the best ...keep going\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        while(row<matrix.length && col>=0)\\n        {\\n\\t\\t//check if matrix[row][col]==target\\n            if(matrix[row][col]==target)\\n            {\\n                return true;\\n            }\\n\\t\\t//if element is less than target we can eleminate whole row and check in next row but keeping column unchanged\\n            if(matrix[row][col]<target)\\n            {\\n                row++;\\n                continue;\\n            }\\n\\t//if element is greater than target we can eleminate whole column and check in previous column but keeping row unchanged\\n            if(matrix[row][col]>target)\\n            {\\n                col--;\\n                continue;\\n            }\\n        }\\n\\t//if element is not found in 2D array return false\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        while(row<matrix.length && col>=0)\\n        {\\n\\t\\t//check if matrix[row][col]==target\\n            if(matrix[row][col]==target)\\n            {\\n                return true;\\n            }\\n\\t\\t//if element is less than target we can eleminate whole row and check in next row but keeping column unchanged\\n            if(matrix[row][col]<target)\\n            {\\n                row++;\\n                continue;\\n            }\\n\\t//if element is greater than target we can eleminate whole column and check in previous column but keeping row unchanged\\n            if(matrix[row][col]>target)\\n            {\\n                col--;\\n                continue;\\n            }\\n        }\\n\\t//if element is not found in 2D array return false\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554706,
                "title": "simple-c-solution-with-o-m-n-complexity",
                "content": "```\\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    int x = 0, y = *matrixColSize - 1;\\n    while(x < matrixSize && y >= 0)\\n        if(matrix[x][y] < target)\\n            x++;\\n        else if(matrix[x][y] > target)\\n            y--;\\n        else\\n            return true;\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    int x = 0, y = *matrixColSize - 1;\\n    while(x < matrixSize && y >= 0)\\n        if(matrix[x][y] < target)\\n            x++;\\n        else if(matrix[x][y] > target)\\n            y--;\\n        else\\n            return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260261,
                "title": "zig-zag-search-recursive-approach-o-n-m-with-binary-search-logic",
                "content": "### Explanation\\n1. Starting from the top-right element of the array, \\n2. Since the array is sorted in both column-wise and row-wise, we are searching starting from 15(Discarding the column since all other elements are larger, moving column wise)---> 11(same as previous)---> 7(same as previous) ---> 4(element is samller than given element now we will move row wise)---> Discarding row(1,4) and going down----> **5 is found**\\nSame for other usecase..\\n\\n![image](https://assets.leetcode.com/users/images/b28a2582-48b5-4ade-838a-e9331c9edfa7_1623211370.8593428.jpeg)\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       return search(matrix,target,0,matrix[0].size()-1);        \\n    }\\n    bool search(vector<vector<int>>& matrix, int target, int i, int j){\\n         if(j<0 || i>matrix.size()-1)\\n             return false;\\n         if(matrix[i][j]==target)\\n            return true;\\n         else if(matrix[i][j]>target)\\n             return search(matrix,target,i,j-1);\\n         else\\n             return search(matrix,target,i+1,j);\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       return search(matrix,target,0,matrix[0].size()-1);        \\n    }\\n    bool search(vector<vector<int>>& matrix, int target, int i, int j){\\n         if(j<0 || i>matrix.size()-1)\\n             return false;\\n         if(matrix[i][j]==target)\\n            return true;\\n         else if(matrix[i][j]>target)\\n             return search(matrix,target,i,j-1);\\n         else\\n             return search(matrix,target,i+1,j);\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081298,
                "title": "python-3-6-solutions-1-line-o-n-log-m-n-140ms",
                "content": "# Linear search, 156ms\\n- Naive approach is to check all elements in `matrix`.\\n- Time complexity is `O(n*m)`. Space compexity is `O(1)`.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        return any(target in row for row in matrix)\\n```\\nIt is bored. Let us improve it.\\n# Row binary search, 160 ms\\n- Since every row is sorted in ascending we can use binary search to find `target`.\\n- Iteratively check all rows.\\n- Time complexity is `O(n*log(m)) = O(n*log(n*t))`. Space compexity is `O(1)`.\\n- Since time complexity is assymetric we need transpose `matrix` if m < n.\\n- Since all columns are sorted in ascending we can reduce right end of the next row.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n, m = len(matrix), len(matrix[0])\\n        if m < n: m, n = n, m; matrix = zip(*matrix)\\n        \\n        i = m\\n        for row in matrix:\\n            i = bisect_left(row, target, hi=i)\\n            if i < m and row[i] == target: return True\\n            \\n        return False\\n```\\nWhy not to implement 2D binary search? Let\\'s try.\\n# Divide and conquer, 176 ms\\n- Since both rows and columns are sorted in ascending we can find middle point in `matrix`, compare it with target and eliminate one (top left or bottom right) quadrant. \\n- Recursively divide remaining 3 quadrants.\\n- According to the third case of the Master theorem (`T(n) = 3*T(n/4) + 1`) time complexity is `O((n*m)**log4(3)) \\u2248 O((n*m)**0.79)`. Space compexity is `O(log(n) + log(m))`. \\n- We can combine 2 adjacent quadrants and make 2 recursive calls (`T(n) = T(n/2) + T(n/4) + 1`) but it gives a similar time complexity (and Master theorem is not applicable here).\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        \\n        def dq(loX, loY, hiX, hiY):\\n            if loX > hiX or loY > hiY: return False\\n            \\n            mX, mY = (loX+hiX) >> 1, (loY+hiY) >> 1\\n            \\n            if target < matrix[mX][mY]:\\n                return dq(loX, loY, mX-1, mY-1) or dq(loX, mY, mX-1, hiY) or dq(mX, loY, hiX, mY-1)\\n            elif target > matrix[mX][mY]:\\n                return dq(mX+1, mY+1, hiX, hiY) or dq(loX, mY+1, mX, hiY) or dq(mX+1, loY, hiX, mY)\\n            else:\\n                return True\\n        \\n        return dq(0, 0, len(matrix)-1, len(matrix[0])-1)\\n```\\nOops, time complexity is not what was expected (not log()). So let\\'s do search with linear approach.\\n# Saddleback linear search, 160ms\\n- Since both rows and columns are sorted in ascending then main and offset diagonals are sorted too, but we have no assumption for secondary and offset diagonals. Which means we can only use linear search in this direction.\\n- Imagine `matrix` contains mountain heights. Let\\'s start from far end of middle height (last element of first row). Climp up (go to next row) if current position is less than `target`. Climp down (go to previous column) if current position is greater than `target`. \\n- So we go through all the columns and rows along the saddleback path and check all potential elements.\\n- Time complexity is `O(n + m) = O(n*t)`. Space complexity is `O(1)`.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        i = len(matrix[0]) - 1\\n        for row in matrix:\\n            while row[i] > target: \\n                i -= 1\\n                if i < 0: return False\\n            if row[i] == target: return True\\n            \\n        return False\\n```\\nIt is good for near quadratic `matrix`. But for long rectangle `n < m / (log(m) - 1)` Row binary search approach is better. \\n# Hybrid linear + binary search, 172ms\\n- Saddleback linear search is optimal if matrix is quadratic `n = m`. Let\\'s do `n` steps along greater axis `m`. So our step should be `t = m//n`.\\n- Use binary search inside found step to find element.\\n- Time complexity is `O(n*log(m/n)) = O(n*log(t))`. Space complexity is `O(1)`.\\n- Since time complexity is assymetric we need transpose `matrix` if m < n.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n, m = len(matrix), len(matrix[0])\\n        if m < n: m,n = n,m; matrix = zip(*matrix)\\n        \\n        hi = m; t = m//n\\n        for row in matrix:\\n            for lo in range(hi-t, 0, -t):\\n                if row[lo] < target: break\\n                hi = lo\\n            else:\\n                lo = 0\\n                if row[lo] > target: break\\n                    \\n            hi = bisect_left(row, target, lo=lo, hi=hi)\\n            if hi < m and row[hi] == target: return True\\n            \\n        return False\\n```\\nPopular wrong estimation `O(log(n*m)) = O(log(n) + log(m))` is possible if all elements in `matrix` are sorted in ascending row by row (or column by column). To apply it in this task we need sort all elements because they are only partially sorted.\\n# Timsort, 140ms\\n- Brutal approach is to sort all elements and use binary search to find `target`.\\n- It could seem time complexity is `O(n*m*log(n*m))`. But Timsort (python\\'s standard sort) is optimized for partially sorted list, so I think time complexity for this task data is `O(n*m)`. Space complexity is `O(n*m)`.\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        vector = sorted(chain.from_iterable(matrix))\\n        i = bisect_left(vector, target)\\n        \\n        return i < len(vector) and vector[i] == target\\n```\\nDue to weak tests we cannot admire best time complexity alghorithms. The worst one takes lowest runtime. \\\\<sadness>\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        return any(target in row for row in matrix)\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n, m = len(matrix), len(matrix[0])\\n        if m < n: m, n = n, m; matrix = zip(*matrix)\\n        \\n        i = m\\n        for row in matrix:\\n            i = bisect_left(row, target, hi=i)\\n            if i < m and row[i] == target: return True\\n            \\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        \\n        def dq(loX, loY, hiX, hiY):\\n            if loX > hiX or loY > hiY: return False\\n            \\n            mX, mY = (loX+hiX) >> 1, (loY+hiY) >> 1\\n            \\n            if target < matrix[mX][mY]:\\n                return dq(loX, loY, mX-1, mY-1) or dq(loX, mY, mX-1, hiY) or dq(mX, loY, hiX, mY-1)\\n            elif target > matrix[mX][mY]:\\n                return dq(mX+1, mY+1, hiX, hiY) or dq(loX, mY+1, mX, hiY) or dq(mX+1, loY, hiX, mY)\\n            else:\\n                return True\\n        \\n        return dq(0, 0, len(matrix)-1, len(matrix[0])-1)\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        i = len(matrix[0]) - 1\\n        for row in matrix:\\n            while row[i] > target: \\n                i -= 1\\n                if i < 0: return False\\n            if row[i] == target: return True\\n            \\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        n, m = len(matrix), len(matrix[0])\\n        if m < n: m,n = n,m; matrix = zip(*matrix)\\n        \\n        hi = m; t = m//n\\n        for row in matrix:\\n            for lo in range(hi-t, 0, -t):\\n                if row[lo] < target: break\\n                hi = lo\\n            else:\\n                lo = 0\\n                if row[lo] > target: break\\n                    \\n            hi = bisect_left(row, target, lo=lo, hi=hi)\\n            if hi < m and row[hi] == target: return True\\n            \\n        return False\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        vector = sorted(chain.from_iterable(matrix))\\n        i = bisect_left(vector, target)\\n        \\n        return i < len(vector) and vector[i] == target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079030,
                "title": "c-python-so-simple",
                "content": "c++\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size()-1;\\n        int col = 0;\\n\\n        while (row >= 0 && col < matrix[0].size()) {\\n            if (matrix[row][col] > target) {\\n                row--;\\n            } else if (matrix[row][col] < target) {\\n                col++;\\n            } else { \\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row = 0\\n        col = len(matrix[0]) - 1\\n        while row < len(matrix) and col >= 0:\\n          if matrix[row][col] > target:\\n            col -= 1\\n          elif matrix[row][col] < target:\\n            row += 1\\n          else:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size()-1;\\n        int col = 0;\\n\\n        while (row >= 0 && col < matrix[0].size()) {\\n            if (matrix[row][col] > target) {\\n                row--;\\n            } else if (matrix[row][col] < target) {\\n                col++;\\n            } else { \\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        row = 0\\n        col = len(matrix[0]) - 1\\n        while row < len(matrix) and col >= 0:\\n          if matrix[row][col] > target:\\n            col -= 1\\n          elif matrix[row][col] < target:\\n            row += 1\\n          else:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1021789,
                "title": "python-simple-divide-conquer-more-readable",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if ((len(matrix) == 1 and len(matrix[0]) == 1 and matrix[0][0] != target) or  # single element with number != target\\n            len(matrix) == 0 or                                                       # empty matrix\\n            matrix.count([]) == len(matrix)):                                         # [[],[],[]]\\n            return False\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        pivot_i = m // 2 \\n        pivot_j = n // 2\\n                \\n        top_left     = [x[0:pivot_j] for x in matrix[0:pivot_i]]\\n        top_right    = [x[pivot_j:]  for x in matrix[0:pivot_i]]\\n        bottom_left  = [x[0:pivot_j] for x in matrix[pivot_i:]]\\n        bottom_right = [x[pivot_j:]  for x in matrix[pivot_i:]]\\n\\n\\n        if matrix[pivot_i][pivot_j] == target:\\n            return True\\n        elif matrix[pivot_i][pivot_j] < target:\\n            return (\\n                self.searchMatrix(top_right, target) or\\n                self.searchMatrix(bottom_left, target) or\\n                self.searchMatrix(bottom_right, target))\\n        else:\\n            return (\\n                self.searchMatrix(top_left, target) or\\n                self.searchMatrix(top_right, target) or\\n                self.searchMatrix(bottom_left, target))\\n\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        if ((len(matrix) == 1 and len(matrix[0]) == 1 and matrix[0][0] != target) or  # single element with number != target\\n            len(matrix) == 0 or                                                       # empty matrix\\n            matrix.count([]) == len(matrix)):                                         # [[],[],[]]\\n            return False\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        pivot_i = m // 2 \\n        pivot_j = n // 2\\n                \\n        top_left     = [x[0:pivot_j] for x in matrix[0:pivot_i]]\\n        top_right    = [x[pivot_j:]  for x in matrix[0:pivot_i]]\\n        bottom_left  = [x[0:pivot_j] for x in matrix[pivot_i:]]\\n        bottom_right = [x[pivot_j:]  for x in matrix[pivot_i:]]\\n\\n\\n        if matrix[pivot_i][pivot_j] == target:\\n            return True\\n        elif matrix[pivot_i][pivot_j] < target:\\n            return (\\n                self.searchMatrix(top_right, target) or\\n                self.searchMatrix(bottom_left, target) or\\n                self.searchMatrix(bottom_right, target))\\n        else:\\n            return (\\n                self.searchMatrix(top_left, target) or\\n                self.searchMatrix(top_right, target) or\\n                self.searchMatrix(bottom_left, target))\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1001740,
                "title": "java-o-m-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        \\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            } else if(target < matrix[row][col]){\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].length-1;\\n        \\n        while(row < matrix.length && col >= 0){\\n            if(matrix[row][col] == target){\\n                return true;\\n            } else if(target < matrix[row][col]){\\n                col--;\\n            } else {\\n                row++;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991518,
                "title": "javascript-o-m-n-solution",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nconst searchMatrix = (matrix, target) => {\\n    if(!matrix || matrix.length === 0 || matrix[0].length === 0) {\\n        return false;\\n    }    \\n    const rows = matrix.length;\\n    const cols = matrix[0].length;\\n    let row = 0, col = matrix[0].length - 1;\\n    while(row < rows && col >= 0) {\\n        if(matrix[row][col] === target) {\\n            return true;\\n        }\\n        if(matrix[row][col] < target) {\\n            row++;\\n        }else {\\n            col--;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nconst searchMatrix = (matrix, target) => {\\n    if(!matrix || matrix.length === 0 || matrix[0].length === 0) {\\n        return false;\\n    }    \\n    const rows = matrix.length;\\n    const cols = matrix[0].length;\\n    let row = 0, col = matrix[0].length - 1;\\n    while(row < rows && col >= 0) {\\n        if(matrix[row][col] === target) {\\n            return true;\\n        }\\n        if(matrix[row][col] < target) {\\n            row++;\\n        }else {\\n            col--;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846343,
                "title": "c-solution-o-n-m-with-comment",
                "content": "start from top right\\nif the value equals target return 1\\nif value less than target, increase i(index of row) by 1\\nif value is greater than target, decrease j(index of column) by 1\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0)\\n            return 0;\\n        int i=0,j=matrix[0].size()-1;\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        while(i<n&&j>=0)\\n        {\\n            if(matrix[i][j]==target)\\n                return 1;\\n            else if(matrix[i][j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0)\\n            return 0;\\n        int i=0,j=matrix[0].size()-1;\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        while(i<n&&j>=0)\\n        {\\n            if(matrix[i][j]==target)\\n                return 1;\\n            else if(matrix[i][j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423453,
                "title": "c-beats-100-so-simple-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // Start our at a location where we have reduced search space. How do we know our search space\\n        // is reduced at the bottom left? Because at that location we can either go right, finding greater\\n        // numbers, or up, finding lower numbers. If we started at the bottom right, regardless of \\n        // where we go, (up or left), we are finding lower numbers, the computer would be confused\\n        // as to which direcction it should take, given that both directions lead to lower numbers.\\n        // Starting at the bottom left we force the computer to either go to a lower number or higher number.\\n        int x = matrix.size() - 1;\\n        int y = 0;\\n        while (x >= 0 && y >=0 && x != matrix.size() && y != matrix[0].size()) { // Don\\'t go off the grid\\n            if (matrix[x][y] == target) {\\n                return true;\\n            } else if (matrix[x][y] > target) { // If too big, we need to go down.\\n                x--;\\n            } else { // Too small? Go right.\\n                y++;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        // Start our at a location where we have reduced search space. How do we know our search space\\n        // is reduced at the bottom left? Because at that location we can either go right, finding greater\\n        // numbers, or up, finding lower numbers. If we started at the bottom right, regardless of \\n        // where we go, (up or left), we are finding lower numbers, the computer would be confused\\n        // as to which direcction it should take, given that both directions lead to lower numbers.\\n        // Starting at the bottom left we force the computer to either go to a lower number or higher number.\\n        int x = matrix.size() - 1;\\n        int y = 0;\\n        while (x >= 0 && y >=0 && x != matrix.size() && y != matrix[0].size()) { // Don\\'t go off the grid\\n            if (matrix[x][y] == target) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 403521,
                "title": "javascript-solution-beats-90",
                "content": "Runtime: 75 ms, faster than 90.21% of JavaScript online submissions for Search a 2D Matrix II.\\nMemory Usage: 37.1 MB, less than 88.89% of JavaScript online submissions for Search a 2D Matrix II.\\n\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n  if (matrix.length === 0) return false\\n  let i = 0, j = matrix[i].length - 1\\n  while (i < matrix.length && j >= 0) {\\n    if (matrix[i][j] === target) { \\n        return true \\n    } else if (matrix[i][j] > target) {\\n        j--\\n    } else { \\n        i++ \\n    }\\n  }\\n  return false\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function(matrix, target) {\\n  if (matrix.length === 0) return false\\n  let i = 0, j = matrix[i].length - 1\\n  while (i < matrix.length && j >= 0) {\\n    if (matrix[i][j] === target) { \\n        return true \\n    } else if (matrix[i][j] > target) {\\n        j--\\n    } else { \\n        i++ \\n    }\\n  }\\n  return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401206,
                "title": "python-geeksforgeeks-link",
                "content": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        if len(matrix) == 0: return False\\n        row, col = 0, len(matrix[0])-1\\n        \\n        while col >= 0 and row < len(matrix):\\n            if target < matrix[row][col]: col -= 1\\n            elif target > matrix[row][col]: row +=1\\n            else: return True\\n        \\n        return False\\n```\\n\\n* [**Simple to Understand Explanation Here**](https://www.geeksforgeeks.org/search-in-row-wise-and-column-wise-sorted-matrix/)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix, target):\\n        if len(matrix) == 0: return False\\n        row, col = 0, len(matrix[0])-1\\n        \\n        while col >= 0 and row < len(matrix):\\n            if target < matrix[row][col]: col -= 1\\n            elif target > matrix[row][col]: row +=1\\n            else: return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365141,
                "title": "go-o-n-m-iterative-solution",
                "content": "```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\tif matrix == nil || len(matrix) == 0 || len(matrix[0]) == 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\trow, col := 0, len(matrix[0])-1\\n\\tfor row < len(matrix) && col >= 0 {\\n\\t\\tval :=  matrix[row][col]\\n\\t\\t if val > target {\\n\\t\\t\\tcol--\\n\\t\\t} else if val < target {\\n\\t\\t\\trow++\\n\\t\\t} else {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc searchMatrix(matrix [][]int, target int) bool {\\n\\tif matrix == nil || len(matrix) == 0 || len(matrix[0]) == 0 {\\n\\t\\treturn false\\n\\t}\\n\\n\\trow, col := 0, len(matrix[0])-1\\n\\tfor row < len(matrix) && col >= 0 {\\n\\t\\tval :=  matrix[row][col]\\n\\t\\t if val > target {\\n\\t\\t\\tcol--\\n\\t\\t} else if val < target {\\n\\t\\t\\trow++\\n\\t\\t} else {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222657,
                "title": "c-36ms-99-7-o-m-n-solution",
                "content": "The idea is to start from the bottom left corner, and then search up the rows until the row starts with element less than or equal to target. This is required since the row is sorted low to high, so if it is too high there is no point searching. Once we find the first row, we will go right, until either we find element, or the current element becomes too high again. If it becomes too high, we know that it can\\'t be in this row, so we move 1 row up, and then repeat. This is guaranteed to work, because each column is also sorted low to high, so from any element, we are guaranteed a lower element if we go up the rows. \\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.empty()) return false;\\n        int R = matrix.size()-1, C = matrix[0].size()-1, i = R, j = 0;\\n        while(i >= 0 && j <= C) {\\n            if(matrix[i][j] < target) ++j;\\n            else if(matrix[i][j] > target) --i;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.empty()) return false;\\n        int R = matrix.size()-1, C = matrix[0].size()-1, i = R, j = 0;\\n        while(i >= 0 && j <= C) {\\n            if(matrix[i][j] < target) ++j;\\n            else if(matrix[i][j] > target) --i;\\n            else return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 66237,
                "title": "o-m-n-solution-in-java-with-explanation",
                "content": "Basic idea is to start from the rightmost column of 0 row and gradually increase the row and decrease the column value to match with the target. As the matrix is sorted both in row and column, so if the target is smaller than matrix[0][0] or greater than matrix[row][column], then we will return false.\\n\\nNow we will start from matrix[0][column] and will compare the value with target. If target is greater than matrix[0][column], we can assume that the target is in same column but greater row. so we will increase row value by 1. Otherwise if the target is smaller than matrix[0][column] we can assume that the target is in same row but smaller column. So we will decrease the column. We will keep doing this unless we hit max row and min column. If we find the target, we will return true. \\n\\nFinally we will return false from outside the loop, as we didn't find the target in the matrix. My java implementation is given below:\\n\\n\\n    \\n        if(matrix == null || matrix.length == 0 || matrix[0] == 0)\\n            return false;\\n        int row = matrix.length;\\n        int column = matrix[0].length;\\n        \\n        if(target < matrix[0][0] || target > matrix[row - 1][column - 1])\\n            return false;\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = column - 1; j >= 0; j--){\\n                if(target == matrix[i][j])\\n                    return true;\\n                //else if(target < matrix[i][j]);\\n                    //do nothing, decrease column number\\n                else if(target > matrix[i][j])\\n                    break;\\n            }\\n        }\\n        \\n        return false;",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "Basic idea is to start from the rightmost column of 0 row and gradually increase the row and decrease the column value to match with the target. As the matrix is sorted both in row and column, so if the target is smaller than matrix[0][0] or greater than matrix[row][column], then we will return false.\\n\\nNow we will start from matrix[0][column] and will compare the value with target. If target is greater than matrix[0][column], we can assume that the target is in same column but greater row. so we will increase row value by 1. Otherwise if the target is smaller than matrix[0][column] we can assume that the target is in same row but smaller column. So we will decrease the column. We will keep doing this unless we hit max row and min column. If we find the target, we will return true. \\n\\nFinally we will return false from outside the loop, as we didn't find the target in the matrix. My java implementation is given below:\\n\\n\\n    \\n        if(matrix == null || matrix.length == 0 || matrix[0] == 0)\\n            return false;\\n        int row = matrix.length;\\n        int column = matrix[0].length;\\n        \\n        if(target < matrix[0][0] || target > matrix[row - 1][column - 1])\\n            return false;\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = column - 1; j >= 0; j--){\\n                if(target == matrix[i][j])\\n                    return true;\\n                //else if(target < matrix[i][j]);\\n                    //do nothing, decrease column number\\n                else if(target > matrix[i][j])\\n                    break;\\n            }\\n        }\\n        \\n        return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 66294,
                "title": "a-divide-and-conquer-solution",
                "content": "just like searching a sorted an array; find the middle element and recursively search the rest 3/4 matrix; a decrease (devide) and conquer solution; \\n\\nThe time complexity is T(m*n) = T(1/4 m*n) + T(1/2 m*n) + 1\\n\\n\\npublic class Solution {\\n    \\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        return(searchMatrixHelper(matrix, 0, 0, matrix.length-1, matrix[0].length-1, target));\\n    }\\n    \\n    private boolean searchMatrixHelper (int[][] matrix, int i, int j, int i_, int j_, int target){\\n        if(i > i_ || j> j_){\\n            return false;\\n        }\\n        int midRow= (i+i_)/2; int midCol=(j+j_)/2;\\n        if(matrix[midRow][midCol] == target){\\n            return true;\\n        }else if(matrix[midRow][midCol] > target){\\n            return (searchMatrixHelper(matrix, i ,j, i_, midCol-1, target) || searchMatrixHelper(matrix, i, midCol, midRow-1, j_, target));\\n        }else{\\n            return (searchMatrixHelper(matrix, midRow+1 ,j, i_, j_, target) || searchMatrixHelper(matrix, i, midCol+1, midRow, j_, target));\\n        }\\n    }\\n    \\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        return(searchMatrixHelper(matrix, 0, 0, matrix.length-1, matrix[0].length-1, target));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 66306,
                "title": "c-divide-and-conquer-solution",
                "content": "    class Solution {\\n    public:\\n    \\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            return searchRect(matrix,target,0,0,matrix.size()-1,matrix[0].size()-1);\\n        }\\n    \\n        bool searchRect(vector<vector<int>>& matrix, int target, \\n                                   int top, int left, int bottom, int right) {\\n            //search if the target is inside the rectangular matrix[top:bottom][left:right]\\n            //each time we discard 1/4 of all elements\\n            //time complexity O( log(mn)/log(4/3) ) = O(logm + logn)\\n            \\n            if(top>bottom || left>right)\\n                return false;\\n            \\n            int x = (top+bottom)/2;\\n            int y = (left+right)/2;\\n            int center = matrix[x][y];\\n            \\n            if(center > target){\\n                return\\n                    searchRect(matrix,target,top,left,x-1,right) ||\\n                    searchRect(matrix,target,x,left,bottom,y-1);\\n            }\\n            else if(center < target){\\n                return\\n                    searchRect(matrix,target,x+1,left,bottom,right) ||\\n                    searchRect(matrix,target,top,y+1,x,right);\\n            }\\n            else\\n                return true;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n    public:\\n    \\n        bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n            return searchRect(matrix,target,0,0,matrix.size()-1,matrix[0].size()-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 66253,
                "title": "what-is-the-complexity-of-this-java-solution",
                "content": "The idea is to recursively compare target with the element in the middle of the matrix and eliminate the quarter of the matrix that can't contain the target. After the quarter is eliminated do searches in the remaining matrix elements. At first it seemed to me that the complexity is O(log N*M), but it looks like I'm wrong. Can anyone show how to calculate complexity of this algorithm?\\n\\n    public class Solution {\\n        public boolean searchMatrix(int[][] matrix, int target) {\\n            if (matrix.length == 0) return false;\\n            return search(matrix, target, 0, matrix.length-1, 0, matrix[0].length-1);\\n        }\\n        private boolean search(int[][]matrix, int target, int minRow, int maxRow, int minCol, int maxCol) {\\n            if (minRow>maxRow || minCol>maxCol) return false;\\n            int midRow = (minRow + maxRow) /2;\\n            int midCol = (minCol + maxCol) /2;\\n            int val = matrix[midRow][midCol];\\n            if (val == target) return true;\\n            if (target<val) {\\n                return search(matrix, target, minRow, maxRow, minCol, midCol - 1) || \\n                        search(matrix, target, minRow, midRow - 1, midCol, maxCol);\\n            } else {\\n                return search(matrix, target, midRow+1, maxRow, minCol, maxCol) ||\\n                        search(matrix, target, minRow, midRow, midCol+1, maxCol);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean searchMatrix(int[][] matrix, int target) {\\n            if (matrix.length == 0) return false;\\n            return search(matrix, target, 0, matrix.length-1, 0, matrix[0].length-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 66324,
                "title": "c-solutions-308ms",
                "content": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if (matrix.empty())\\n        {\\n            return false;\\n        }\\n        int siz0 = matrix.size();\\n        int siz1 = matrix[0].size();\\n        int x = siz0 - 1, y = 0;\\n        while (true)\\n        {\\n            if (matrix[x][y] > target)\\n            {\\n                x--;\\n            }\\n            else if (matrix[x][y] < target){\\n                y++;\\n            }\\n            else {\\n                return true;\\n            }\\n            if (x < 0 || y >= siz1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if (matrix.empty())\\n        {\\n            return false;\\n        }\\n        int siz0 = matrix.size();\\n        int siz1 = matrix[0].size();\\n        int x = siz0 - 1, y = 0;\\n        while (true)\\n        {\\n            if (matrix[x][y] > target)\\n            {\\n                x--;\\n            }\\n            else if (matrix[x][y] < target){\\n                y++;\\n            }\\n            else {\\n                return true;\\n            }\\n            if (x < 0 || y >= siz1)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3732451,
                "title": "easy-to-understand-c-solution-o-n-m",
                "content": "# Intuition & Approach\\nStart your pointer pointer from first row and last column.Every time compare with the target if target is equals to the pointer value then return true and if target is less than the matrix value then (column--) and if target is greater than the matrix value then (row++) .\\n\\n\\n# Complexity\\n- Time complexity:O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int column=matrix[0].size()-1;\\n        int row=0;\\n        while(row<matrix.size() && column>=0)\\n        {\\n            if(matrix[row][column]==target)\\n            return true;\\n\\n            else if(matrix[row][column]>target)\\n            {\\n                --column;\\n            }\\n            else\\n            row++;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int column=matrix[0].size()-1;\\n        int row=0;\\n        while(row<matrix.size() && column>=0)\\n        {\\n            if(matrix[row][column]==target)\\n            return true;\\n\\n            else if(matrix[row][column]>target)\\n            {\\n                --column;\\n            }\\n            else\\n            row++;\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565715,
                "title": "binary-search-easy-soln",
                "content": "# Intuition\\nSince it is given that array is sorted in non-increasing order both row-wise and column-wise, we wil start the traversal from the last row\\'s first element.\\n3 cases can occur:\\nCase 1: when the current element is greater than the target,then the whole row will be of greater numbers than target since its the smaleest in the row, so discard the row\\n\\nCase 2 :\\nwhen the current element is smaller than the target then move to the next column since it is column wise sorted the target might lie in the next column\\n\\nCase 3: When the current elemets is equal to the target,return true\\n# Approach\\n\\n# Complexity\\n- Time complexity:O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\nPlease Upvote :)\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        int r=matrix.length-1,c=0;\\n        while(r<matrix.length && c<matrix[0].length)\\n        {\\n            if(matrix[r][c]==target)\\n                 return true;//match found\\n            else if(r!=0 && matrix[r][c]>target)\\n                 r--; //discard row\\n            else\\n               c++;  //moving to the next column\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) \\n    {\\n        int r=matrix.length-1,c=0;\\n        while(r<matrix.length && c<matrix[0].length)\\n        {\\n            if(matrix[r][c]==target)\\n                 return true;//match found\\n            else if(r!=0 && matrix[r][c]>target)\\n                 r--; //discard row\\n            else\\n               c++;  //moving to the next column\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464126,
                "title": "java-solution-for-search-2d-matrix-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a Java code for the \"Search a 2D Matrix II\" problem, where given an m x n matrix sorted in non-decreasing order, we need to check if a given integer target is present in the matrix\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this code is to start from the bottom left corner of the matrix and compare the target with the element at this position. If the target is smaller, we move one row up; if it is larger, we move one column right; and if it is equal, we return true. We repeat this process until we find the target or reach the top right corner of the matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m+n), since we traverse at most m rows and n columns of the matrix. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), since we use only a constant amount of extra space.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m=matrix.length-1;\\n        int n=matrix[0].length-1;\\n        int i=m;\\n        int j=0;\\n        while(i>=0 && j<=n)\\n        {\\n            if(target < matrix[i][j])\\n            {\\n                i--;\\n            }\\n            else if(target > matrix[i][j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int m=matrix.length-1;\\n        int n=matrix[0].length-1;\\n        int i=m;\\n        int j=0;\\n        while(i>=0 && j<=n)\\n        {\\n            if(target < matrix[i][j])\\n            {\\n                i--;\\n            }\\n            else if(target > matrix[i][j])\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449918,
                "title": "c-best-explanation-with-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem asks to find whether an element is present in a matrix or not. Since the matrix is sorted, we can use binary search to solve this problem. To perform binary search, we can search each row of the matrix using binary search. If we find the target element in any row, we return true, otherwise, we return false.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe iterate over each row of the matrix using a for loop\\n\\nFor each row, we perform binary search by initializing two pointers l and r with the start and end indices of the row, respectively.\\n\\nWe repeat the following until l<=r:\\n\\na. We calculate the middle index of the row by using the formula mid=l+(r-l)/2.\\nb. If the element at the middle index is equal to the target element, we return true.\\nc. If the element at the middle index is less than the target element, we update l to mid+1.\\nd. If the element at the middle index is greater than the target element, we update r to mid-1.\\n\\nIf we do not find the target element in any row, we return false.\\n# Complexity\\n- Time complexity: $$O(mlog(n))$$, where m is the number of rows and n is the number of columns of the matrix. For each row, we perform binary search which takes log(n) time, so the total time complexity is O(mlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$, as we are using constant extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n     \\n        for(int i=0; i<m ; i++)\\n        {\\n        int l=0;\\n        int r=n-1;\\n        while(l<=r)\\n           {\\n                int mid=l + (r-l)/2;\\n                if (matrix[i][mid] == target) return true;\\n                if (matrix[i][mid] < target)\\n                {\\n                    l=mid+1;\\n                }\\n                else \\n                {\\n                    r=mid-1; \\n                }\\n            }\\n\\n        }\\n         return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n     \\n        for(int i=0; i<m ; i++)\\n        {\\n        int l=0;\\n        int r=n-1;\\n        while(l<=r)\\n           {\\n                int mid=l + (r-l)/2;\\n                if (matrix[i][mid] == target) return true;\\n                if (matrix[i][mid] < target)\\n                {\\n                    l=mid+1;\\n                }\\n                else \\n                {\\n                    r=mid-1; \\n                }\\n            }\\n\\n        }\\n         return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440654,
                "title": "c-simplified-solution-with-explanation-binary-search",
                "content": "**Intuition**\\nAt first i simply ran two loops and searched for the target and it gave tle with 3 failed cases. So to optimise this code ,it had to be solved at O(log m + n). This means that we need to apply binary search on each row or column respectively.\\n\\n*Approach*\\nIn this code, we are traversing through each element of the row through for loop,one by one.For each row we will apply binary search.  Applying algorithm we obtain a mid element through (int mid=low+(high-low)/2), till [ while(low<=high)] condition is satisfied for the respective row. \\n\\n [if(matrix[i][mid]==target) return true;] this condition means that the middle element is your target. \\n\\n[ else if(matrix[i][mid]>target)] this conditions means that element in the middle of row is greater than the target so obviously target has to lie between matrix[i][0] and matrix[i][mid-1], since middle element is not the target. so fix your high pointer before mid and loop with work accordingly.\\n \\nelse condition is just opposite to else if condition that is works on this loop. in this if target is greater than mid then obv it will be on the right of mid so your low will be mid+1.\\n\\nsame will be applied to all rows of the matrix or you can apply the same using columns\\n\\n\\n\\n **Complexity**\\n- Time complexity:\\nnlogn\\n\\n- Space complexity:\\nconstant\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n         bool flag=true;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n           int low=0;\\n           int high=matrix[0].size()-1;\\n           while(low<=high) \\n           {\\n               int mid=low+(high-low)/2;\\n               if(matrix[i][mid]==target) return true;\\n               else if(matrix[i][mid]>target)\\n               {\\n                   high=mid-1;\\n               }\\n               else\\n               {\\n                   low=mid+1;\\n               }\\n           }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n         bool flag=true;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n           int low=0;\\n           int high=matrix[0].size()-1;\\n           while(low<=high) \\n           {\\n               int mid=low+(high-low)/2;\\n               if(matrix[i][mid]==target) return true;\\n               else if(matrix[i][mid]>target)\\n               {\\n                   high=mid-1;\\n               }\\n               else\\n               {\\n                   low=mid+1;\\n               }\\n           }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314783,
                "title": "easy-java-solution",
                "content": "#BInarysearch in 2d arrays....\\n\\n# java Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n      int rows=matrix.length;\\n      int cols=matrix[0].length;\\n      int r=0;\\n      int c=cols-1;\\n      while(r<rows && c>=0){\\n          if(matrix[r][c]==target){\\n              return true;\\n          }\\n          else if(matrix[r][c]<target){\\n              r++;\\n          }\\n          else{\\n              c--;\\n          }\\n      } \\n      return false;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n      int rows=matrix.length;\\n      int cols=matrix[0].length;\\n      int r=0;\\n      int c=cols-1;\\n      while(r<rows && c>=0){\\n          if(matrix[r][c]==target){\\n              return true;\\n          }\\n          else if(matrix[r][c]<target){\\n              r++;\\n          }\\n          else{\\n              c--;\\n          }\\n      } \\n      return false;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302721,
                "title": "easy-solution-beats-100-o-n-m-java",
                "content": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] mat, int t) {\\n        int r=0;\\n        int c=mat[0].length-1;\\n\\n        while(c>=0 && r<mat.length){\\n            if(mat[r][c]==t)return true;\\n            \\n            if(mat[r][c]<t)r++;\\n            else c--;\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] mat, int t) {\\n        int r=0;\\n        int c=mat[0].length-1;\\n\\n        while(c>=0 && r<mat.length){\\n            if(mat[r][c]==t)return true;\\n            \\n            if(mat[r][c]<t)r++;\\n            else c--;\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190066,
                "title": "faang-apporach-self-explanatory-code-well-commented",
                "content": "\\n# Code\\n```\\nclass Solution {\\n//Do Upvote if you like the Approach !!\\n\\n//NOW WE WILL START FROM THE TOP RIGHT CORNER OF THE MATRIX;\\n//IF THE VALUE IS SMALL THEN TARGET THEN WE WILL LEFT IN THE MATRIX\\n//AND IF HTE VALUE IS LARGET THEN TARGET THEN WE WILL MOVE RIGHT IN THE MATRIX\\n//AND THIS IS HOW WE WILL DO AND EFFICENT SEARCH IN THE MATRIX\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i=0;\\n        int j=col-1;\\n        while(i<row and j>=0){\\n          if(matrix[i][j]==target){\\n              return true;\\n          }\\n          else if(matrix[i][j]>target){\\n                j--;\\n          }\\n          else{\\n              i++;\\n          }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n//Do Upvote if you like the Approach !!\\n\\n//NOW WE WILL START FROM THE TOP RIGHT CORNER OF THE MATRIX;\\n//IF THE VALUE IS SMALL THEN TARGET THEN WE WILL LEFT IN THE MATRIX\\n//AND IF HTE VALUE IS LARGET THEN TARGET THEN WE WILL MOVE RIGHT IN THE MATRIX\\n//AND THIS IS HOW WE WILL DO AND EFFICENT SEARCH IN THE MATRIX\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int i=0;\\n        int j=col-1;\\n        while(i<row and j>=0){\\n          if(matrix[i][j]==target){\\n              return true;\\n          }\\n          else if(matrix[i][j]>target){\\n                j--;\\n          }\\n          else{\\n              i++;\\n          }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023106,
                "title": "1ms-java-most-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int i=0,j=col-1;\\n        while(i<row && j>=0){\\n\\n            if(matrix[i][j]==target){\\n                return true;\\n            }\\n\\n            else if(matrix[i][j]>target){\\n                \\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int i=0,j=col-1;\\n        while(i<row && j>=0){\\n\\n            if(matrix[i][j]==target){\\n                return true;\\n            }\\n\\n            else if(matrix[i][j]>target){\\n                \\n                j--;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006536,
                "title": "240-search-a-2d-matrix-ii-c-solution-100-all-test-case-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Binary Searching Approach**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Binary Searching Approach**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(nlogn)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(1)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        \\n        //indexis..\\n        int rowIndx=0;\\n        int colIndx=col-1;\\n\\n        while(rowIndx < row and colIndx >= 0){\\n             int element=matrix[rowIndx][colIndx];\\n             if(element==target)\\n             return true;\\n             else if(element < target)\\n               rowIndx++;\\n               else\\n               colIndx--;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        \\n        //indexis..\\n        int rowIndx=0;\\n        int colIndx=col-1;\\n\\n        while(rowIndx < row and colIndx >= 0){\\n             int element=matrix[rowIndx][colIndx];\\n             if(element==target)\\n             return true;\\n             else if(element < target)\\n               rowIndx++;\\n               else\\n               colIndx--;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779767,
                "title": "java-binary-search",
                "content": "\\n# Approach\\nBinary Search in every row until the element is found or we reach at the end of the matrix.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(m)) \\nwhere n is number of rows in matrix and m is number of column in matrix\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        for(int i = 0; i < matrix.length; i++){\\n            int low = 0;\\n            int high = matrix[0].length - 1;\\n\\n            while(low <= high){\\n                int mid = (low+high)/2;\\n                if(matrix[i][mid] == target)\\n                    return true;\\n                if(matrix[i][mid] > target)\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n# *** UP-VOTE IF HELPFUL ***",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n\\n        for(int i = 0; i < matrix.length; i++){\\n            int low = 0;\\n            int high = matrix[0].length - 1;\\n\\n            while(low <= high){\\n                int mid = (low+high)/2;\\n                if(matrix[i][mid] == target)\\n                    return true;\\n                if(matrix[i][mid] > target)\\n                    high = mid - 1;\\n                else\\n                    low = mid + 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776665,
                "title": "easy-c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n          int rows = matrix.size(),\\n\\t\\t\\tcols = matrix[0].size(),\\n            currow = 0, curcol = cols - 1;\\n\\t\\t\\t\\n        while (currow < rows && curcol >=0) {\\n            int cur = matrix[currow][curcol];\\n            if (target == cur) return true;\\n            else if (target > cur) currow++;\\n            else if (target < cur) curcol--;\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n          int rows = matrix.size(),\\n\\t\\t\\tcols = matrix[0].size(),\\n            currow = 0, curcol = cols - 1;\\n\\t\\t\\t\\n        while (currow < rows && curcol >=0) {\\n            int cur = matrix[currow][curcol];\\n            if (target == cur) return true;\\n            else if (target > cur) currow++;\\n            else if (target < cur) curcol--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2769913,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [first row, last column] element\\n        int i=0;\\n        int j=m-1;\\n        while(i<n && j>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller, go leftwards\\n                --j; // decrease the column index\\n            else // target is larger, go downwards\\n                ++i; // increase the row index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        // start from the [first row, last column] element\\n        int i=0;\\n        int j=m-1;\\n        while(i<n && j>=0){\\n            if(matrix[i][j]==target) // target found\\n                return true;\\n            else if(matrix[i][j]>target) //target is smaller, go leftwards\\n                --j; // decrease the column index\\n            else // target is larger, go downwards\\n                ++i; // increase the row index\\n        }\\n        return false; // target not found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328059,
                "title": "java-solution-with-solution-steps-in-image-o-n-m-time-o-1-space",
                "content": "Hey everyone,\\nSo, when I first saw this problem, it was obvious that it should be something like Binary Search or some kind of traversal of the matrix (matrix, sorted, you know..), but how to implement it, thats the real trick. \\n\\nThe brute force will work (although it will be TLE), so I started by thinking of BS of each row and column (vertical / horizontal) but again, time complexity will be high, and then I finally got the trick.\\n\\nWe were able to perform BS on our matrix, due to the fact its sorted, and that fact - we need to use when we iterating 2D matrix. So I played a little with the matrix in my iPad with 2D matrix in the size of `5x5` and `target=8`.\\n\\n#### So, the steps were: \\n\\n1. If I will start from bottom to up, with initiate state of `row = 4, col = 0`, I will know for sure that the `target` is bigger or lower than the current element, and if it equal to, return `True` (otherwise, `False`).\\n2. In each step I check, if the `first element` (and later on, the the `col` element) of row is bigger/lower than the `target`.\\n2.1. If `matrix[row][col]` is bigger, decrease `row`.\\nThe target will probably be in lower row index.\\n2.2. If `matrix[row][col]` is lower, increase `col`.\\nThe target will probably be in higher column index.\\n3. If none was found (loop constraints), so it will return `False`.\\nOtherwise the `matrix[row][col]` is equal to the target and return `True`.\\n4. With that matrix traversal, we increasing/decreasing the row/col index due to the constraints of the matrix and we will get O(n) + O(m) operations O(n+m), each operations is O(1) and we are not using additional space, so space complexity will be O(1).\\n\\nIn the image below, you can see how it possible to ignore all the unrelevant elements in the matrix.\\n\\n![image](https://assets.leetcode.com/users/images/7c93da94-a54c-42b4-a5a1-98885e020ab8_1658678638.0849197.png)\\n\\n#### The Solution\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] array, int target) {\\n        int row = array.length - 1;\\n        int col = 0;\\n        \\n        // o(n + m) operations + o(1) space\\n        while(row >= 0 && col < array[0].length) {\\n            int element = array[row][col];\\n            if(element > target) {\\n                row--;\\n            } else if(element < target) {\\n                col++;\\n            } else {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nHope it was helpful to you all!",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] array, int target) {\\n        int row = array.length - 1;\\n        int col = 0;\\n        \\n        // o(n + m) operations + o(1) space\\n        while(row >= 0 && col < array[0].length) {\\n            int element = array[row][col];\\n            if(element > target) {\\n                row--;\\n            } else if(element < target) {\\n                col++;\\n            } else {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327423,
                "title": "c-explained-faster-than-93",
                "content": "We start in the bottom-left corner, which is \\nmatrix[-1][0]. Obviously, the target cell cannot\\nbe either below or to the left of this corner cell\\n\\n\\u2022 We move incrementally from the corner such that we \\ndo not pass to right of the target\\'s column or above\\nits row; we can ensure this by exploiting the sorted \\nrows and columns. For example (below), the target \\nis 8 and and the corner is 18. So:\\n      -- 18 > 8 =>  move up    to 10,\\n      -- 10 > 8 =>  move up    to  3,\\n      --  3 < 8 =>  move right to  6,\\n      --  6 < 8 =>  move right to  9,\\n      --  9 > 8 =>  move up    to  8.\\n![image](https://assets.leetcode.com/users/images/dbdbb746-a46b-4d37-a6c5-8d6a03991830_1658670733.7791224.png)\\n\\n```\\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    \\n    int row = matrixSize - 1;\\n    int col = 0;\\n    \\n    while (row >= 0 && col < *matrixColSize){\\n        if (matrix[row][col] > target) row--;\\n        else if (matrix[row][col] < target) col++;\\n        else return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target){\\n    \\n    int row = matrixSize - 1;\\n    int col = 0;\\n    \\n    while (row >= 0 && col < *matrixColSize){\\n        if (matrix[row][col] > target) row--;\\n        else if (matrix[row][col] < target) col++;\\n        else return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2326388,
                "title": "c-solution-and-explanation-with-diagram-o-m-n",
                "content": "***Intuition*** :\\nIt is given that all rows and columns are sorted i.e.\\n1. Along any row if we move right we\\'ll get bigger numbers and if we move left we\\'ll get smaller numbers.\\n2. Along any column if we move down we\\'ll get bigger numbers and if we move up we\\'ll get smaller numbers.\\n\\nSo we\\'ll start from TOP-RIGHT corner and cancel out a row or a column each time.\\n\\n***Example***\\n![image](https://assets.leetcode.com/users/images/0f5dfd7e-ce47-400b-9755-df832b71590c_1658652769.3947866.png)\\nWe are given this matrix and we need to find 5 i.e. **target = 5**\\nm = 5  and n = 5 \\nm is number of rows and n is number of columns\\n\\n***STEP 1***\\nStarting from TOP-RIGHT corner \\n***row = 0  and col = 4*** (Using 0 based indexing)\\n![image](https://assets.leetcode.com/users/images/3ab61e82-5ed8-4604-a9c5-1366ad41da7a_1658653179.2200706.png)\\nwe get 15 and ***15 > 5 (target)***\\nSo there is no chnace that we\\'ll get 5 if we go down in this column we neglect this column ***col--*** \\n\\n***STEP 2***\\n***row = 0  and col = 3***\\n![image](https://assets.leetcode.com/users/images/b8de2f87-e18b-4e03-aa52-758e942f96ea_1658653459.2397456.png)\\nwe get 11 and ***11 > 5 (target)***\\nAgain there is no chnace that we\\'ll get 5 if we go down in this column we neglect this column ***col--***\\n\\n***STEP 3***\\n***row = 0  and col = 2***\\n![image](https://assets.leetcode.com/users/images/5d032b08-a980-43b6-8875-e6e030b600a4_1658653626.3564353.png)\\nwe get 7 and ***7 > 5 (target)***\\nAgain there is no chnace that we\\'ll get 5 if we go down in this column we neglect this column ***col--***\\n\\n***STEP 4***\\n***row = 0  and col = 1***\\n![image](https://assets.leetcode.com/users/images/b5bb49b7-059e-447a-a487-6c8be552ef12_1658653713.5749893.png)\\nwe get 4 and ***4 < 5 (target)***\\nNow the current element is **smaller** than the target and we have already checked the right portion of this row so we have one possibality now i.e. go down along the column hence we neglect this row.  **row++**.\\n\\n***STEP 5***\\n***row = 1  and col = 1***\\n![image](https://assets.leetcode.com/users/images/210d4e7c-a2ed-4f55-9809-b3920731b590_1658654085.0564797.png)\\nWe get 5 now so we return true ans answer.\\n\\nNOT-FOUND cases\\n1. If col < 0\\n2. If row > totalRows - 1   (Using 0 based indexing)\\n\\n**C++ CODE**\\n```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        if(n < 1 || m < 1)\\n            return false;\\n        // Starting from TOP-RIGHT corner\\n        int row = 0;\\n        int col = n - 1;\\n        while((col >= 0) && (row < m)) {\\n            if(matrix[row][col] == target)\\n                return true;\\n            else if(matrix[row][col] > target)\\n                col--;\\n            else\\n                row++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        if(n < 1 || m < 1)\\n            return false;\\n        // Starting from TOP-RIGHT corner\\n        int row = 0;\\n        int col = n - 1;\\n        while((col >= 0) && (row < m)) {\\n            if(matrix[row][col] == target)\\n                return true;\\n            else if(matrix[row][col] > target)\\n                col--;\\n            else\\n                row++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325209,
                "title": "search-a-element-in-matrix-time-complexity-o-r-c",
                "content": "bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       int r=matrix.size();\\n        int i=0; \\n        int c=matrix[0].size();\\n        int j=c-1;\\n        while(i<r && j>=0){\\n            if(matrix[i][j]==target){\\n                return true ;\\n            }\\n           else if(matrix[i][j]>target){\\n               j--;\\n           }\\n            else{\\n                i++;\\n            }\\n        }\\n       return false; \\n    }",
                "solutionTags": [],
                "code": "bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n       int r=matrix.size();\\n        int i=0; \\n        int c=matrix[0].size();\\n        int j=c-1;\\n        while(i<r && j>=0){\\n            if(matrix[i][j]==target){\\n                return true ;\\n            }\\n           else if(matrix[i][j]>target){\\n               j--;\\n           }\\n            else{\\n                i++;\\n            }\\n        }\\n       return false; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2127098,
                "title": "c-easy-3-line-code",
                "content": "```\\n\\n//if target>pivot -->r++;\\n//target<pivot-->c--;\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int n=mat.size(),m=mat[0].size();\\n        int i=0,j=m-1;\\n        while(i<n && j>=0)\\n        {\\n            if(mat[i][j]==target) return true;\\n            else if(mat[i][j]>target) j--;  \\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n//if target>pivot -->r++;\\n//target<pivot-->c--;\\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& mat, int target) {\\n        int n=mat.size(),m=mat[0].size();\\n        int i=0,j=m-1;\\n        while(i<n && j>=0)\\n        {\\n            if(mat[i][j]==target) return true;\\n            else if(mat[i][j]>target) j--;  \\n            else i++;\\n        }\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107892,
                "title": "faster-than-others-easy-solution-o-m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].size()-1;\\n        while(i<matrix.size() && j>=0){\\n            if(matrix[i][j]<target)i++;\\n            else if(matrix[i][j]>target)j--;\\n            else \\n                return true;\\n        }\\n        return false; \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].size()-1;\\n        while(i<matrix.size() && j>=0){\\n            if(matrix[i][j]<target)i++;\\n            else if(matrix[i][j]>target)j--;\\n            else \\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2087703,
                "title": "easy-cpp-solution",
                "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=matrix[0].size()-1,j=0;\\n        while(i>=0 && j<matrix.size()){\\n            if(matrix[j][i]==target) \\n                return true;\\n            else if(matrix[j][i]<target) \\n                j++;\\n            else \\n                i--;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int i=matrix[0].size()-1,j=0;\\n        while(i>=0 && j<matrix.size()){\\n            if(matrix[j][i]==target) \\n                return true;\\n            else if(matrix[j][i]<target) \\n                j++;\\n            else \\n                i--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1898816,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].size()-1;\\n        \\n        while(col>=0 && row<matrix.size())\\n        {\\n            if(matrix[row][col]==target)\\n            {\\n                return true;\\n                break;\\n            }\\n            else if(matrix[row][col]<target)\\n            {\\n                row++;\\n            }\\n            else\\n            {\\n                col--;\\n            }\\n        }\\n        return false;\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].size()-1;\\n        \\n        while(col>=0 && row<matrix.size())\\n        {\\n            if(matrix[row][col]==target)\\n            {\\n                return true;\\n                break;\\n            }\\n            else if(matrix[row][col]<target)\\n            {\\n                row++;\\n            }\\n            else\\n            {\\n                col--;\\n            }\\n        }\\n        return false;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724015,
                "title": "python-search-space-pruning-o-m-n",
                "content": "I would not call this binary search, more like 2 pointers.\\n\\n```\\nclass Solution:\\n    \"\"\"\\n    \\n    Localize to the correct value by using the value of a cell\\n    starting at the top right.\\n    \\n    Either the top right (the maximum column, minmum row) and bottom left (maximum\\n    row, minimum column) can be used to minimize the search space.\\n    \\n    In our case we started from the top right. Because it is the max column, \\n    if the value at matrix[row][col] is > target, we shrink the column since \\n    the target must be to the left.\\n    \\n    Since we started in the min row, if the value at matrix[row][col] is < target,\\n    we expand the row, since the target must be at least in the next row.\\n    \\n    \\n    \\n    Time complexity: O(m + n). we need max m shrinks and n expands.\\n    \\n\\n    \"\"\"\\n    \\n    \\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        \\n        # start at top right\\n        row = 0\\n        col = cols - 1\\n        \\n        #print (col, cols)\\n        while row >= 0 and col >= 0 and row < rows and col < cols:\\n            #print(row, rows, col, cols)\\n            if matrix[row][col] > target:\\n                col = col - 1\\n            elif matrix[row][col] < target:\\n                row = row + 1\\n            else:\\n                return True\\n            \\n        return False```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    \\n    Localize to the correct value by using the value of a cell\\n    starting at the top right.\\n    \\n    Either the top right (the maximum column, minmum row) and bottom left (maximum\\n    row, minimum column) can be used to minimize the search space.\\n    \\n    In our case we started from the top right. Because it is the max column, \\n    if the value at matrix[row][col] is > target, we shrink the column since \\n    the target must be to the left.\\n    \\n    Since we started in the min row, if the value at matrix[row][col] is < target,\\n    we expand the row, since the target must be at least in the next row.\\n    \\n    \\n    \\n    Time complexity: O(m + n). we need max m shrinks and n expands.\\n    \\n\\n    \"\"\"\\n    \\n    \\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        rows = len(matrix)\\n        cols = len(matrix[0])\\n        \\n        # start at top right\\n        row = 0\\n        col = cols - 1\\n        \\n        #print (col, cols)\\n        while row >= 0 and col >= 0 and row < rows and col < cols:\\n            #print(row, rows, col, cols)\\n            if matrix[row][col] > target:\\n                col = col - 1\\n            elif matrix[row][col] < target:\\n                row = row + 1\\n            else:\\n                return True\\n            \\n        return False```",
                "codeTag": "Java"
            },
            {
                "id": 1707567,
                "title": "top-right-corner-explained",
                "content": "Check the top right corner element, \\n1. if it is less than target, target is not present in that row because top right corner is the greatest element in that row.\\n2. if it is greater than target, target is not present in that column because top right corner is the least element in that column.\\n\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int i = 0, j = m-1;\\n        while(i < n  and j > -1){\\n            if (matrix[i][j] == target){\\n                return true;\\n            }\\n            else if (target < matrix[i][j]){\\n                j--;\\n            }\\n            else if (target > matrix[i][j]){\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int i = 0, j = m-1;\\n        while(i < n  and j > -1){\\n            if (matrix[i][j] == target){\\n                return true;\\n            }\\n            else if (target < matrix[i][j]){\\n                j--;\\n            }\\n            else if (target > matrix[i][j]){\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668132,
                "title": "c-solution-optimized-using-row-wise-and-column-wise-sorted-method",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int i=0;\\n        int j=m-1;\\n        while(i<n and j>=0)\\n        {\\n            if(matrix[i][j]==target)\\n                return true;\\n            else if(matrix[i][j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int i=0;\\n        int j=m-1;\\n        while(i<n and j>=0)\\n        {\\n            if(matrix[i][j]==target)\\n                return true;\\n            else if(matrix[i][j]>target)\\n                j--;\\n            else\\n                i++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610574,
                "title": "search-in-2d-matrix-ii-o-n-m",
                "content": "We\\'re just moving from top-right to bottom-left element in matrix, we can also do vice versa.\\n```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), i = 0, j = matrix[0].size() - 1;\\n        while (i < row && j >= 0) //i++ can exceed row & j-- can be < 0\\n        {\\n            if (matrix[i][j] == target) return true;\\n            else if (matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size(), i = 0, j = matrix[0].size() - 1;\\n        while (i < row && j >= 0) //i++ can exceed row & j-- can be < 0\\n        {\\n            if (matrix[i][j] == target) return true;\\n            else if (matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1591346,
                "title": "c-2-solutions",
                "content": "Solution 1:\\nO(m+n)\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int i = 0, j = m-1;\\n        while(j>=0 && i<n){\\n            if(matrix[i][j] == target)  return true;\\n            else if(matrix[i][j] > target){//delete a col\\n                j--;\\n            }  \\n            else{ //delete a row\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```\\n\\nSolution 2:\\nO(n*log(m))\\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i <n; i++){\\n            if (target < matrix[i][0] || target > matrix[i][m-1]) continue;\\n            if(binary_search(matrix[i].begin(), matrix[i].end(), target))   return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        int i = 0, j = m-1;\\n        while(j>=0 && i<n){\\n            if(matrix[i][j] == target)  return true;\\n            else if(matrix[i][j] > target){//delete a col\\n                j--;\\n            }  \\n            else{ //delete a row\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i <n; i++){\\n            if (target < matrix[i][0] || target > matrix[i][m-1]) continue;\\n            if(binary_search(matrix[i].begin(), matrix[i].end(), target))   return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529976,
                "title": "all-possible-solutions-by-ashay-nayak-best-solution-o-n-m",
                "content": "Please **upvote** if you find it helpful. Thank You.\\nPurpose - Practice of thinking of all possible solution which help you in **interviews**.\\nFeel free to comment below if you don\\'t get anything. I will surely reply back **within 12 hours.**\\n**3rd solution is best solution**\\npossible solutions...\\n\\n1.) Two For loops - TC - O(n^2) and SC - O(1) - please try to think by yourself and if you don\\'t get it then comment below.\\n\\n2.) Binary Search - TC - O(mlogn) and SC - O(1) - Iterate through each row and apply binary search to find the target. In worst case you will find the target in last row. See code below:\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length==0) return false;\\n        int rows=matrix.length, cols=matrix[0].length;\\n        for(int r=0; r<rows; r++){\\n            int lo=0, hi=cols-1;\\n            while(lo <= hi){\\n                int mid = (lo + hi)/2;\\n                if(matrix[r][mid] == target) return true;\\n                if(target <= matrix[r][mid]){\\n                    hi = mid-1;\\n                }else lo = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n3.) Start from top right - TC - O(n+m) and SC - O(1) - **best solution** - remember this - as mentioned in question that given 2d array is sorted in ascending order from left to right and top to bottom. Now, imagine you are standing at top right corner initially. Now you will check 3 conditions: (1) if target==value then you have found the target and return true. (2) if target<value, just think for a minute that what will you do? From you position either you can move towards bottom or towards left. As it is sorted in ascending order, if you move towards bottom then we will move towards increasing values and if we move towrads left then we will move towards decreasing values. As your target<value, we will move towards left to find the target. (3) if target>value, we will move towards bottom to find the target. See code below:\\n\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        \\n        int i=0,j=col-1;\\n        \\n        while(i<row&&j>=0){\\n            if(matrix[i][j]==target)return true;\\n            else if(target<matrix[i][j])j--;\\n            else i++;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if(matrix == null || matrix.length == 0 || matrix[0].length==0) return false;\\n        int rows=matrix.length, cols=matrix[0].length;\\n        for(int r=0; r<rows; r++){\\n            int lo=0, hi=cols-1;\\n            while(lo <= hi){\\n                int mid = (lo + hi)/2;\\n                if(matrix[r][mid] == target) return true;\\n                if(target <= matrix[r][mid]){\\n                    hi = mid-1;\\n                }else lo = mid+1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        \\n        int i=0,j=col-1;\\n        \\n        while(i<row&&j>=0){\\n            if(matrix[i][j]==target)return true;\\n            else if(target<matrix[i][j])j--;\\n            else i++;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463365,
                "title": "c-single-traversal-solution-with-explanation",
                "content": "**If you like the approach please upvote as it motivates me to create such post!!!**\\n```\\nclass Solution {\\npublic:\\n    //since we know that the matrix is sorted row-wise as well as column-wise.. we will take advantage of it\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        // if we consider the upper right corner .. from that position if we see the values below it are increasing while values left to it are decresing .. so we use this to find our solution..\\n        int i=0;\\n        int j = col-1;\\n        while(i<row && j>=0){\\n            //first case is if we found the element we wanted to search then simply we will return true\\n            if(matrix[i][j] == target){\\n                return true;\\n            }else if(matrix[i][j] > target){ // second case if the value at that cell is greater than the value we want so in that case we will go left.. as left side values are smaller\\n                j--;\\n            }else{ //and now the last case is that if the value we want is greater than the value in the cell then we will move to bottom as bottom values are more than the value present in that particular cell..\\n                i++;\\n            }\\n        }\\n        return false; // if we traverse whole matrix and could not found the value then we simply return false as value is not present in the matrix.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //since we know that the matrix is sorted row-wise as well as column-wise.. we will take advantage of it\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        // if we consider the upper right corner .. from that position if we see the values below it are increasing while values left to it are decresing .. so we use this to find our solution..\\n        int i=0;\\n        int j = col-1;\\n        while(i<row && j>=0){\\n            //first case is if we found the element we wanted to search then simply we will return true\\n            if(matrix[i][j] == target){\\n                return true;\\n            }else if(matrix[i][j] > target){ // second case if the value at that cell is greater than the value we want so in that case we will go left.. as left side values are smaller\\n                j--;\\n            }else{ //and now the last case is that if the value we want is greater than the value in the cell then we will move to bottom as bottom values are more than the value present in that particular cell..\\n                i++;\\n            }\\n        }\\n        return false; // if we traverse whole matrix and could not found the value then we simply return false as value is not present in the matrix.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419121,
                "title": "easy-python-solution-faster-than-98-memory-93",
                "content": "#  Easy Python Solution | Faster than 98%, Memory < 93%\\n\\n**Runtime: 152 ms, faster than 98% of Python3 online submissions for Search a 2D Matrix II.\\nMemory Usage: 20 MB, less than 93% of Python3 online submissions for Search a 2D Matrix II.**\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for r in matrix:\\n            if r[0] <= target and r[-1] >= target:\\n                l, h = 0, len(r)-1\\n                while l <= h:\\n                    m = (l+h)//2\\n                    if r[m] > target:\\n                        h = m - 1\\n                    elif r[m] < target:\\n                        l = m + 1\\n                    else:\\n                        return True\\n            else:\\n                continue\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        for r in matrix:\\n            if r[0] <= target and r[-1] >= target:\\n                l, h = 0, len(r)-1\\n                while l <= h:\\n                    m = (l+h)//2\\n                    if r[m] > target:\\n                        h = m - 1\\n                    elif r[m] < target:\\n                        l = m + 1\\n                    else:\\n                        return True\\n            else:\\n                continue\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321994,
                "title": "c-saddleback-search-o-m-n-explained",
                "content": "##### **Saddleback Search**\\n\\n**Algorithm**\\nStart from top right element\\n1. If the element if equal to target, return true\\n2. If the element is greater than target, move down *(increment row)*\\n3. If the element is less than target, move left *(decrement col)*\\n\\nTime complexity: O(m + n)\\n\\n\\n**C++ Code**\\n```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].size() - 1;\\n\\n        while(row < matrix.size() && col >= 0){\\n            \\n            if(matrix[row][col] == target) return true;\\n            (matrix[row][col] > target) ? col-- : row++;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = 0;\\n        int col = matrix[0].size() - 1;\\n\\n        while(row < matrix.size() && col >= 0){\\n            \\n            if(matrix[row][col] == target) return true;\\n            (matrix[row][col] > target) ? col-- : row++;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1265170,
                "title": "easy-java-beats-100-4-lines-of-code-very-simple",
                "content": "```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].length-1; //starting at the last column is the key point here\\n        \\n        while(i <matrix.length && j>=0){\\n            if(matrix[i][j]== target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n\\t\\n\\tIf you find it easy please upvote!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic boolean searchMatrix(int[][] matrix, int target) {\\n        int i=0;\\n        int j=matrix[0].length-1; //starting at the last column is the key point here\\n        \\n        while(i <matrix.length && j>=0){\\n            if(matrix[i][j]== target) return true;\\n            else if(matrix[i][j] > target) j--;\\n            else i++;\\n        }\\n        return false;\\n    }\\n\\t\\n\\tIf you find it easy please upvote!",
                "codeTag": "Unknown"
            },
            {
                "id": 1240641,
                "title": "blazzing-fast-short-clean-concise-binary-search-o-r-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        int i = 0;\\n        int j = cols - 1;\\n        \\n        while(i >= 0 && i < rows and j >= 0 && j < cols)\\n        {\\n            if(target == matrix[i][j]) return true;\\n            else if(target < matrix[i][j]) j--;\\n            else i++;\\n        }\\n    return false;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n        int i = 0;\\n        int j = cols - 1;\\n        \\n        while(i >= 0 && i < rows and j >= 0 && j < cols)\\n        {\\n            if(target == matrix[i][j]) return true;\\n            else if(target < matrix[i][j]) j--;\\n            else i++;\\n        }\\n    return false;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1080114,
                "title": "search-a-2d-matrix-ii-python-beats-90",
                "content": "Every step trying to narrow down search area to smaller matrix.\\n\\n```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        L1, L2 = len(matrix)-1, len(matrix[0]) -1\\n        i1, i2 = 0, L1\\n        j1, j2 = 0, L2\\n        \\n        while 0 <=i1 <= i2 <= L1 and 0 <=j1 <= j2 <= L2:\\n            if target == matrix[i2][j1] or target == matrix[i1][j2]: return True\\n            if matrix[i1][j2] < target: i1+=1\\n            elif matrix[i2][j1] < target: j1+=1 \\n            elif matrix[i2][j1] > target: j2-=1\\n            elif matrix[i2][j2] > target: i2-=1 \\n            \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\\n        L1, L2 = len(matrix)-1, len(matrix[0]) -1\\n        i1, i2 = 0, L1\\n        j1, j2 = 0, L2\\n        \\n        while 0 <=i1 <= i2 <= L1 and 0 <=j1 <= j2 <= L2:\\n            if target == matrix[i2][j1] or target == matrix[i1][j2]: return True\\n            if matrix[i1][j2] < target: i1+=1\\n            elif matrix[i2][j1] < target: j1+=1 \\n            elif matrix[i2][j1] > target: j2-=1\\n            elif matrix[i2][j2] > target: i2-=1 \\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061937,
                "title": "o-log-m-log-n-java-solution",
                "content": "Runtime is 6 ms.\\nI know this can be improved a little bit, but it should be sufficient from Interview point of view. Technically, this solution is equivalent to solving 3 different problems. Look at the comments for understanding.\\n\\nI think worst case could happen when all the elements in the row or column for the given indexes are duplicates, which will cause the **binary search** to run for each element in the corresponding row or column. This might make the current solution O(m + n), but I think, this can also be avoided by doing some extra checks on start and end indexes.\\n```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null) {\\n            return false;\\n        }\\n\\n        int m = matrix.length;\\n        if (m == 0) {\\n            return false;\\n        }\\n\\n        int n = matrix[0].length;\\n\\n        int row = 0;\\n        int col = n-1;\\n        // Start from Top right entry in the matrix.\\n        // If target is less than the entry, we do binary search on the row.\\n        // Else, we do binary search on the column\\n        while (row < m && col >= 0) {\\n\\t\\t    // Target is found\\n            if (matrix[row][col] == target) {\\n                return true;\\n            }\\n\\n            if (matrix[row][col] > target) {\\n\\t\\t\\t\\t// If target is less than the current item, we do a binary search on the current row to find the appropriate column\\n                col = searchRow(matrix, row, col-1, target);\\n            } else {\\n\\t\\t\\t\\t// If target is greater than the current item, we do a binary search on the current column to find the appropriate row\\n                row = searchCol(matrix, col, row+1, target);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    // Binary search on the row and return index of column for the possible entry\\n    // Technically, this is finding the first index of repeated target element in a sorted array, if the target exists.\\n    // Otherwise, it is just returning the index where target should have been in that particular row.\\n    private int searchRow(int[][] matrix, int rowIdx, int colEndIdx, int target) {\\n        int mid;\\n        int start = 0;\\n        int end = colEndIdx;\\n\\n        while (start < end) {\\n            mid = start + ((end-start)/2);\\n\\n            if (matrix[rowIdx][mid] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return end;\\n    }\\n\\n    // Binary search on the column and return index of row for the possible entry\\n    // Technically, this is finding the last index of repeated target element in a sorted array, if the target exists.\\n    // Otherwise, it is just returning the index where target should have been in that particular column.\\n    private int searchCol(int[][] matrix, int colIdx, int rowStartIdx, int target) {\\n        int mid;\\n        int start = rowStartIdx;\\n        int end = matrix.length;\\n\\n        while (start < end) {\\n            mid = start + ((end-start)/2);\\n\\n            if (matrix[mid][colIdx] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return end;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        if (matrix == null) {\\n            return false;\\n        }\\n\\n        int m = matrix.length;\\n        if (m == 0) {\\n            return false;\\n        }\\n\\n        int n = matrix[0].length;\\n\\n        int row = 0;\\n        int col = n-1;\\n        // Start from Top right entry in the matrix.\\n        // If target is less than the entry, we do binary search on the row.\\n        // Else, we do binary search on the column\\n        while (row < m && col >= 0) {\\n\\t\\t    // Target is found\\n            if (matrix[row][col] == target) {\\n                return true;\\n            }\\n\\n            if (matrix[row][col] > target) {\\n\\t\\t\\t\\t// If target is less than the current item, we do a binary search on the current row to find the appropriate column\\n                col = searchRow(matrix, row, col-1, target);\\n            } else {\\n\\t\\t\\t\\t// If target is greater than the current item, we do a binary search on the current column to find the appropriate row\\n                row = searchCol(matrix, col, row+1, target);\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    // Binary search on the row and return index of column for the possible entry\\n    // Technically, this is finding the first index of repeated target element in a sorted array, if the target exists.\\n    // Otherwise, it is just returning the index where target should have been in that particular row.\\n    private int searchRow(int[][] matrix, int rowIdx, int colEndIdx, int target) {\\n        int mid;\\n        int start = 0;\\n        int end = colEndIdx;\\n\\n        while (start < end) {\\n            mid = start + ((end-start)/2);\\n\\n            if (matrix[rowIdx][mid] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return end;\\n    }\\n\\n    // Binary search on the column and return index of row for the possible entry\\n    // Technically, this is finding the last index of repeated target element in a sorted array, if the target exists.\\n    // Otherwise, it is just returning the index where target should have been in that particular column.\\n    private int searchCol(int[][] matrix, int colIdx, int rowStartIdx, int target) {\\n        int mid;\\n        int start = rowStartIdx;\\n        int end = matrix.length;\\n\\n        while (start < end) {\\n            mid = start + ((end-start)/2);\\n\\n            if (matrix[mid][colIdx] >= target) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836104,
                "title": "python-d-c-recursion",
                "content": "Divide and Conquer approach using recursion. With 4 areas and optimized with 3 areas.\\n\\nhttps://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/\\n\\nAs I undestand the optimized solution is O(log n) because in every recurscive step we work with 3/4 (0.75%) of the matrix thus T(n) = log_(4/3) n\\n\\n```\\nclass Solution:\\n    def searchMatrix_optimized(self, matrix, target):\\n        \"\"\"\\n\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return False\\n        if len(matrix) == 1 and len(matrix[0]) == 1:\\n            if matrix[0][0] == target:\\n                return True\\n            else:\\n                return False\\n\\n        pivot_x, pivot_y = len(matrix) // 2, len(matrix[0]) // 2\\n\\n        if matrix[pivot_x][pivot_y] > target:\\n            tl = self.searchMatrix([row[:pivot_y] for row in matrix[:pivot_x]], target)\\n            bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n            tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n            return tl or tr or bl\\n        elif matrix[pivot_x][pivot_y] < target:\\n            br = self.searchMatrix([row[pivot_y:] for row in matrix[pivot_x:]], target)\\n            bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n            tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n            return tr or bl or br\\n        else:\\n            return True\\n\\n\\n    def searchMatrix_bf(self, matrix, target):\\n        \"\"\"\\n\\n        Naive O(n ^ 2)\\n\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return False\\n        if len(matrix) == 1 and len(matrix[0]) == 1:\\n            if matrix[0][0] == target:\\n                return True\\n            else:\\n                return False\\n\\n        pivot_x, pivot_y = len(matrix) // 2, len(matrix[0]) // 2\\n\\n        tl = self.searchMatrix([row[:pivot_y] for row in matrix[:pivot_x]], target)\\n        br = self.searchMatrix([row[pivot_y:] for row in matrix[pivot_x:]], target)\\n        bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n        tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n\\n        return tl or tr or bl or br\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def searchMatrix_optimized(self, matrix, target):\\n        \"\"\"\\n\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return False\\n        if len(matrix) == 1 and len(matrix[0]) == 1:\\n            if matrix[0][0] == target:\\n                return True\\n            else:\\n                return False\\n\\n        pivot_x, pivot_y = len(matrix) // 2, len(matrix[0]) // 2\\n\\n        if matrix[pivot_x][pivot_y] > target:\\n            tl = self.searchMatrix([row[:pivot_y] for row in matrix[:pivot_x]], target)\\n            bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n            tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n            return tl or tr or bl\\n        elif matrix[pivot_x][pivot_y] < target:\\n            br = self.searchMatrix([row[pivot_y:] for row in matrix[pivot_x:]], target)\\n            bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n            tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n            return tr or bl or br\\n        else:\\n            return True\\n\\n\\n    def searchMatrix_bf(self, matrix, target):\\n        \"\"\"\\n\\n        Naive O(n ^ 2)\\n\\n        :type matrix: List[List[int]]\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return False\\n        if len(matrix) == 1 and len(matrix[0]) == 1:\\n            if matrix[0][0] == target:\\n                return True\\n            else:\\n                return False\\n\\n        pivot_x, pivot_y = len(matrix) // 2, len(matrix[0]) // 2\\n\\n        tl = self.searchMatrix([row[:pivot_y] for row in matrix[:pivot_x]], target)\\n        br = self.searchMatrix([row[pivot_y:] for row in matrix[pivot_x:]], target)\\n        bl = self.searchMatrix([row[pivot_y:] for row in matrix[:pivot_x]], target)\\n        tr = self.searchMatrix([row[:pivot_y] for row in matrix[pivot_x:]], target)\\n\\n        return tl or tr or bl or br\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810393,
                "title": "c-easy-to-understand-and-optimised-solution-with-explanation",
                "content": "**Plese upvote my solution if you like it**\\n\\none thing to understand in this question is that the element below the current element is always greater than the current element.And the element on the left of the current element is always less than the current element.\\n\\nSo my solution is totaly based on this observation \\n1. Start form Top most Row and right most column.\\n2. check if the current element is target or not.\\n3. After that if current element is not a target element then and the current element is greater then the target element then we have to move left(IN simple words column-=1).\\n4. Else move down(means row+=1)\\n5. if out of bound occure return false\\n\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0)return 0;\\n        int row=0,column=matrix[0].size()-1;//topmost row and rightmost column\\n        while(row<matrix.size() && column>=0) //checking for out of bound condition\\n        {\\n            if(matrix[row][column]==target)//checking if current element is target or not \\n                return 1;\\n            if(matrix[row][column]>target)//if current element is greater then target then move left or decrement column\\n                column--;\\n            else //else increment row or move down \\n                row++;\\n        }\\n        return 0;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        if(matrix.size()==0)return 0;\\n        int row=0,column=matrix[0].size()-1;//topmost row and rightmost column\\n        while(row<matrix.size() && column>=0) //checking for out of bound condition\\n        {\\n            if(matrix[row][column]==target)//checking if current element is target or not \\n                return 1;\\n            if(matrix[row][column]>target)//if current element is greater then target then move left or decrement column\\n                column--;\\n            else //else increment row or move down \\n                row++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 762355,
                "title": "python-double-binary-search-better-than-90",
                "content": "The idea is the following:\\nWe start at ```row 0 and col 0```\\nWe perform a binary search on the row and a binary search on the column. If we didn\\'t find our target we proceed to perform a binary search from\\n```row 1 and col 1```, this way we eliminate checking already visited cells.\\n\\nCode is very readable.\\n\\n```\\nclass Solution:\\n    def row_binary_search(self, row, lo, hi):\\n        if lo >= hi:\\n            return self.matrix[row][hi] == self.target\\n        \\n        mid = (lo + hi) // 2\\n        cell = self.matrix[row][mid]\\n        \\n        if cell == self.target:\\n            return True\\n        elif cell < self.target:\\n            return self.row_binary_search(row, mid + 1, hi)\\n        else:\\n            return self.row_binary_search(row, lo, mid - 1)\\n    \\n    def col_binary_search(self, col, lo, hi):\\n        if lo >= hi:\\n            return self.matrix[hi][col] == self.target\\n        \\n        mid = (lo + hi) // 2\\n        cell = self.matrix[mid][col]\\n        \\n        if cell == self.target:\\n            return True\\n        elif cell < self.target:\\n            return self.col_binary_search(col, mid + 1, hi)\\n        else:\\n            return self.col_binary_search(col, lo, mid - 1)\\n    \\n    def searchMatrix(self, matrix, target):\\n        # The idea is to binary search the row and binary search the column and move 1 row and 1 col in\\n        if not matrix or not matrix[0]: return False\\n        \\n        self.matrix, self.target = matrix,  target\\n        n, m = len(matrix), len(matrix[0])\\n        row, col = 0, 0\\n        \\n        while row < n and col < m:\\n            if self.row_binary_search(row, col, m - 1):\\n                return True\\n            if self.col_binary_search(col, row, n - 1):\\n                return True\\n            row += 1\\n            col += 1\\n        \\n        # We can have col or row left over\\n        if col < m:\\n            return self.row_binary_search(row - 1, col, m - 1)\\n        else:\\n            # row < n\\n            return self.col_binary_search(col - 1, row, n - 1)\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```row 0 and col 0```\n```row 1 and col 1```\n```\\nclass Solution:\\n    def row_binary_search(self, row, lo, hi):\\n        if lo >= hi:\\n            return self.matrix[row][hi] == self.target\\n        \\n        mid = (lo + hi) // 2\\n        cell = self.matrix[row][mid]\\n        \\n        if cell == self.target:\\n            return True\\n        elif cell < self.target:\\n            return self.row_binary_search(row, mid + 1, hi)\\n        else:\\n            return self.row_binary_search(row, lo, mid - 1)\\n    \\n    def col_binary_search(self, col, lo, hi):\\n        if lo >= hi:\\n            return self.matrix[hi][col] == self.target\\n        \\n        mid = (lo + hi) // 2\\n        cell = self.matrix[mid][col]\\n        \\n        if cell == self.target:\\n            return True\\n        elif cell < self.target:\\n            return self.col_binary_search(col, mid + 1, hi)\\n        else:\\n            return self.col_binary_search(col, lo, mid - 1)\\n    \\n    def searchMatrix(self, matrix, target):\\n        # The idea is to binary search the row and binary search the column and move 1 row and 1 col in\\n        if not matrix or not matrix[0]: return False\\n        \\n        self.matrix, self.target = matrix,  target\\n        n, m = len(matrix), len(matrix[0])\\n        row, col = 0, 0\\n        \\n        while row < n and col < m:\\n            if self.row_binary_search(row, col, m - 1):\\n                return True\\n            if self.col_binary_search(col, row, n - 1):\\n                return True\\n            row += 1\\n            col += 1\\n        \\n        # We can have col or row left over\\n        if col < m:\\n            return self.row_binary_search(row - 1, col, m - 1)\\n        else:\\n            # row < n\\n            return self.col_binary_search(col - 1, row, n - 1)\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565039,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1568502,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1804251,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1567929,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1570311,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1568164,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1574245,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1576195,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 2006099,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 2004196,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1565039,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1568502,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1804251,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1567929,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1570311,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1568164,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1574245,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1576195,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 2006099,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 2004196,
                "content": [
                    {
                        "username": "autekwing",
                        "content": "Is there's a O(log(m)+log(n)) solution?"
                    },
                    {
                        "username": "shishir-22",
                        "content": "I was able to do O(m * log(n)) and O(m+n) but not O(log(m)+log(n))"
                    },
                    {
                        "username": "Bodhisattva",
                        "content": "Intuition behind the problem:\\n1. It is given that rows and columns are sorted. So the optimal way should involved binary search / complexity can be optimized to logarithmic.\\n2. In any search problem, the basic motive is to reduce the decision space progressively. The more aggressively the search space is reduced, the more efficient the algorithm. \\nTo reduce decision space means to eliminate certain portion completely from search in future. Here, due to the property of rows & columns being sorted, we can verify that we can utilise the given properties to reduce search space only if we begin at bottom left corner or top right corner. This is because at only those two starting positions, we would be able to exercise decisions to reduce our decision/search space in both directions i.e.\\ni. if we start at bottom left corner => we can go right to get elements in increasing order & top to get elements in decreasing order.\\nii. if we start at top right corner => we can go left to get elements in decreasing order & bottom to get elements in increasing order.\\nWe can\\'t have both choices if we start at top left or bottom right indices."
                    },
                    {
                        "username": "chetan_singh_2002",
                        "content": "Thanks a lot :)"
                    },
                    {
                        "username": "Batraaaaaa",
                        "content": "O(m+n) Approach:\n\n1. Start at the top-right corner of the matrix (i.e., the element in the first row and last column). We will call this element current.\n2. Compare current with the target value target. If current is equal to target, return true since we have found the target in the matrix.\n3. If current is greater than target, we can eliminate the entire last column (i.e., all elements in the last column are greater than current and therefore greater than target). Move one column to the left to consider the next element in that row. We will call this new element current.\n4. If current is less than target, we can eliminate the entire first row (i.e., all elements in the first row are less than current and therefore less than target). Move one row down to consider the next element in that column. We will call this new element current.\n5. Repeat steps 2-4 until current is equal to target or we reach the end of the matrix.\n6. If we reach the end of the matrix without finding the target, return false.\n\nThe idea behind this algorithm is to take advantage of the sorted property of the matrix to eliminate entire rows or columns at once, and narrow down the search space for the target value. Since we start at the top-right corner, we can eliminate rows or columns as we move left or down, respectively.\n\nThe time complexity of this algorithm is O(m + n) since we move at most m + n steps in the matrix. This is much more efficient than a naive approach of iterating over every element in the matrix, which would take O(m x n) time.\n\nKindly Upvote "
                    },
                    {
                        "username": "ategale",
                        "content": "Nice"
                    },
                    {
                        "username": "chatterjeesabyasachi11",
                        "content": "Thank you so much for this explanation. It matched with my thought process."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "good explanation\\n"
                    },
                    {
                        "username": "nobugplease",
                        "content": "brute force: O(mn) \\n\\nbinary search: O(mlogn) or O(nlogm)\\n\\nsearch from upper right to lower left: O(m+n)\\n\\nSo any hints on using \"divide and conquer\" to solve this problem?\\n\\nThanks"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@cartesPerforees](/cartesPerforees) Way more complicated than needed imo "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake: \n"
                    },
                    {
                        "username": "Stephen4166",
                        "content": "I found this awesome explaination from StackExchange https://cs.stackexchange.com/questions/98575/proving-correctness-of-search-algorithms and wanna share with you: \\n\\nThe idea of the algorithm is to maintain the following invariant:\\n\\nIf x is in the matrix, then it is in the submatrix whose top right corner is e.\\n\\nThe invariant clearly holds in the beginning, since e is the top right corner of the original matrix.\\n\\nIf e>x then all elements below e are also larger than x, and so x cannot be contained in that column. Therefore the invariant continues to hold with e replaced with its left neighbor (if e has no left neightbor, we can deduce that x is not found in the matrix).\\n\\nIf e<x then all elements to the left of e are also smaller than x, and so x cannot be contained in that row. Therefore the invariant continues to hold with e replaced with its neighbor below (if any).\\n\\nOn an n\\xD7m matrix, this process terminates in at most n+m steps, either finding x or determining that it does not appear in the matrix."
                    },
                    {
                        "username": "liuyuhong",
                        "content": "Even my code is empty...."
                    },
                    {
                        "username": "notwilliamng",
                        "content": "Is the Matrix Sorter? No, so first we have to sort the matrix. \\nCan we split the matrix in half and search through using the Binary Search algorithm?  Yes. so that\\'s a possible solution. "
                    },
                    {
                        "username": "Jitendrayt",
                        "content": "I just solved **Search a 2D Matrix** and then LC suggested me **Search a 2D Matrix ll** and it looked very similar to previous one so i copy pasted my solution and guess what it worked . just wondering if there\\'s even any difference between the 2 problems.\\n\\nlink for Search a 2D Matrix  is - https://leetcode.com/problems/search-a-2d-matrix/"
                    },
                    {
                        "username": "NitishBharat",
                        "content": "The first integer of each row is greater than the last integer of the previous row.\\nthis extra condition given in previous problem made the code easier to approach but in  Search a 2D Matrix ll  this condition is not given that is why both question differ "
                    },
                    {
                        "username": "ganesh227",
                        "content": "The[ article](https://medium.com/interviewnoodle/search-a-sorted-matrix-both-rows-and-columns-are-sorted-coding-interview-searching-6ba2cea8ed61) contains code, explanation and animations to simplify the approach."
                    },
                    {
                        "username": "hussainafroz903",
                        "content": "what makes part 2 problem different from part 1 search 2d matrix?"
                    },
                    {
                        "username": "Mohitchand04",
                        "content": "yeah i also have the same ques?"
                    },
                    {
                        "username": "sonivinayak716",
                        "content": " At first we got confidence to run both the cases,whe submitted......RUntime error ,upvote if can relate ;)\\n"
                    }
                ]
            },
            {
                "id": 1574529,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1571482,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 2073107,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 2005365,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 2004476,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 2003997,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1971292,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1955047,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1913771,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1889669,
                "content": [
                    {
                        "username": "ShaliniNegi111",
                        "content": "Leetcode have 2 question in the  series and both have  the same algrithm to solve them.\\nWhere does they differ, Can Someone help me? \\n\\n[https://leetcode.com/problems/search-a-2d-matrix/](http://)\\n[https://leetcode.com/problems/search-a-2d-matrix-ii/](http://)\\n\\n\\n"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Bro the 1st Q. can be solved in O(log(n*m))\n2nd one cannot...\nEdit: I realized this comment is 2 and half years old. You probably don't wanna know now"
                    },
                    {
                        "username": "Elvenblade",
                        "content": "constraints check karo, alag hai "
                    },
                    {
                        "username": "swordx",
                        "content": "Has anyone ACed this new problem in python?\\nOJ tells me I got\\n\\n> \\nLine 27: SyntaxError: invalid syntax\\n> \\n\\nBut my code only has 16 lines. Doesn't make sense to me."
                    },
                    {
                        "username": "Aravind0495",
                        "content": "Why Can\\'t we use flattened approach of making the 2D grid into Single array matrix and work on the regular Binary search way of doing this ? \\n\\nI am getting error in 115 Test case where the values are [[1,4],[2,5]] and target value is 2 \\n\\nAnyone have approached this solution way "
                    },
                    {
                        "username": "b0968760387",
                        "content": "If you are coming from No. 74, I suggest that you avoid being fixated on using the binary search method to solve it :)"
                    },
                    {
                        "username": "Deep_down",
                        "content": "i got memeory limit exceeds for the test case 127 but when i use it as a test case it works correctly what\\'s going wrong wiht my program.?\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Same Solution as <a href=\"https://www.example.com\">74. Search a 2D Matrix\n</a>**If you are not using binary search here.**\n\n\n\n"
                    },
                    {
                        "username": "wtfcoder",
                        "content": " Checking each and every element gives TLE , but binary search on every row works \\uD83D\\uDC4D"
                    },
                    {
                        "username": "mochiball",
                        "content": "Thats brute force method. O(m * n) for searching all elements \n\nBinary search every row : O(m * log n) \n\nOptimal approach : O(n + m) "
                    },
                    {
                        "username": "rajparmar7102000",
                        "content": "use two pointer\\n"
                    },
                    {
                        "username": "wangzhangwu",
                        "content": "Here is an idea to solve the problem in `O(n + m)`\\nPlease note that due to the definition of the matrix, there are only two permissible directions in which a \"linear search\" can be performed: from the upper-right corner to the lower-left corner or vice versa. This restriction arises from the requirement of obtaining contrasting effects while traversing in both directions. Without such contrasting effects, it would be impossible to deduce the extent of the searching space.\\n\\nIn the present scenario, we are conducting a trace from the upper-right corner to the lower-left corner. This choice is based on the observation that moving downwards increases the value, while moving towards the left decreases the value. Consequently, each individual movement within the search reduces the size of the search space by at most m or n cells."
                    },
                    {
                        "username": "miha4406",
                        "content": "BS all possible rows."
                    }
                ]
            },
            {
                "id": 1888625,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1886032,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1876249,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1854719,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1854155,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1833607,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1810852,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1806977,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1799746,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1795582,
                "content": [
                    {
                        "username": "ZzaizZ",
                        "content": "Hi guys! Can anyone help me, why my solution is not good enough? My main idea is to check numbers on the main diagonal from the bottom right corner. If the current number on the diagonal is greater than the target and the next number on the diagonal is less than target -> search in current row and column.\\nAnd if the next number on the diagonal still greater than target -> go on through the diagonal till matrix boundaries or condition described above.\\n\\nI assume that this solution should work as O(m + n): we go through the diagonal and only once check row and column. But in practice it has the worst time (even slower than bute force O(m*n)). Where I am wrong?"
                    },
                    {
                        "username": "guptashivam48616",
                        "content": "start from bottom-left. if target is less then go up, else go right. I also tried above but it offered O(log( m! * n! )) solution for me. If o=you start from top-right or bottom-left, you can reduce search space by one row or column at a time. But if start from other two corners, the above said property does not hold and then we need to do extra log(m) binary search for each. Hence O(log( m! * n! )) time complexity"
                    },
                    {
                        "username": "Sudipta_1999",
                        "content": "        Java Solution\\n         int row=matrix.length;\\n        int col=matrix[0].length;\\n\\n        int rowIndex=0;\\n        int colIndex=col-1;\\n\\n        while(rowIndex<row && colIndex>=0){\\n\\n            int element=matrix[rowIndex][colIndex];\\n\\n            if(element==target)\\n                    return true;\\n\\n            else if(element<target){\\n              rowIndex++;\\n            }\\n            else   colIndex--;        \\n        }\\n\\n        return false;"
                    },
                    {
                        "username": "abhi9001",
                        "content": "class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int r =0,c=n-1;\\n\\n        while (r<m && c>=0){\\n            if(matrix[r][c]==target){\\n                return true;\\n            }\\n            else if(matrix[r][c]>target){\\n                c--;\\n            }else{\\n                r++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\nwhat is wrong in this ????????"
                    },
                    {
                        "username": "kant413",
                        "content": "[leetcode](https://leetcode.com)[leetcode](https://leetcode.com)"
                    },
                    {
                        "username": "psionl0",
                        "content": "My initial solution was to do a binary search on each row until I hit the target or ran out of rows. This would have a O(m log n) run time. Then I discovered in this discussion the idea of traversing from the TR corner until I hit the target or went off the edge of the matrix. This has a O(m + n) run time. BRILLIANT!"
                    },
                    {
                        "username": "ToxicMango",
                        "content": "the output fails for case 1, can someone please explain why?class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        def search(i, j):\n            if i >= len(matrix) or j < 0:\n                return False\n            if matrix[i][j] == target:\n                return True\n            elif target < matrix[i][j]:\n                return search(i,j-1)\n            else:\n                return search(i+1,j)\n        search(0,len(matrix)-1)    "
                    },
                    {
                        "username": "singhsunitak47101",
                        "content": " Because here all rows and columns are sorted, we can apply binary sort on each row and try to find that element."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have posted an optimized O(m+n) version of the divide and conquer approach [here](https://leetcode.com/problems/search-a-2d-matrix-ii/solutions/3205428/a-different-o-m-n-solution-2d-binary-search-no-trickery-involved-methodical/)! You can have a look and let me know if I made any mistake"
                    },
                    {
                        "username": "pr1524",
                        "content": "Can be solved using reducing space search concept\\nhere is the code that beats 99% \\n\\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int rowIndex = 0;\\n        int colIndex = col-1;\\n\\n        while(rowIndex < row && colIndex >= 0)\\n        {\\n            int element = matrix[rowIndex][colIndex];\\n\\n            if(element == target)\\n                return 1;\\n\\n            if(element < target)\\n                rowIndex++;\\n\\n            else\\n                colIndex--;\\n        }\\n        return 0;\\n    }"
                    },
                    {
                        "username": "CGK2002",
                        "content": "I just tried using two for loops (brute force) and it got accepted. I\\'m sure that\\'s not efficient but how is leetcode accepts that type of code?"
                    }
                ]
            },
            {
                "id": 1793194,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1785043,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1757552,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1748799,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1733557,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1730095,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1723180,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1716644,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1692492,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            },
            {
                "id": 1688442,
                "content": [
                    {
                        "username": "das28",
                        "content": "I am Getting Wrong output for the following :-\\nCan someone guide where the mistake is ?\\n\\nclass Solution:\\n    def searchMatrix(self, A: List[List[int]], target: int) -> bool:\\n        left = 0\\n        right = len(A)*len(A[0])-1\\n\\n        while(left<=right):\\n            mid = (left+right)//2\\n\\n            row = mid // len(A[0])\\n            col = mid % len(A[0])\\n\\n            if A[row][col] == target:\\n                return True\\n            elif A[row][col] < target:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n        return False\\n            "
                    },
                    {
                        "username": "rafiul29",
                        "content": "\\n# Js Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @param {number} target\\n * @return {boolean}\\n */\\nvar searchMatrix = function (matrix, target) {\\n  let result=false;\\n  for(let i=0;i<matrix.length;i++){\\n        for(let j=0; j<matrix[i].length;j++){\\n            if(matrix[i][j]==target){\\n                result=true\\n                break;\\n            }\\n        }\\n    }\\n    return result\\n};\\n```"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "https://www.youtube.com/watch?v=1CdolnvxLs0&list=PLDzeHZWIZsTryvtXdMr6rPh4IDexB5NIA&index=28 \\n\\nthis might help you guys"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "heckervarun",
                        "content": " 130/130 passed but time limit exceeded :("
                    },
                    {
                        "username": "mdarif77630",
                        "content": "SEARCH A 2D MATRIX \\n\\nclass Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n\\n        int start = 0;\\n        int end = col - 1;\\n\\n        while(start < row && end >= 0){\\n            int element = matrix[start][end];\\n\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element < target){\\n                start ++;\\n            }\\n            else{ // (element > target)\\n                end--;\\n            }\\n        }\\n        return 0;\\n    }\\n};"
                    },
                    {
                        "username": "Sherlock_Holmes_786",
                        "content": "class Solution {\\n    public boolean searchMatrix(int[][] matrix, int target) {\\n        int lo = 0;\\n        if(matrix.length == 0) return false;\\n        int n = matrix.length; \\n        int m = matrix[0].length; \\n        int hi = (n * m) - 1;\\n        \\n        while(lo <= hi) {\\n            int mid = (lo + (hi - lo) / 2);\\n            if(matrix[mid/m][mid % m] == target) {\\n                return true;\\n            }\\n            if(matrix[mid/m][mid % m] < target) {\\n                lo = mid + 1;\\n            }\\n            else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n}\\n\\n\\nwhy my code doesn\\'t pass all test cases??\\n"
                    },
                    {
                        "username": "notive",
                        "content": "The clever searching from top right is not a binary search solution. It makes use of 2D matrix properties."
                    },
                    {
                        "username": "olekssy",
                        "content": "I struggle to solve this problem with D&C approach. Any suggestions would be appreciated.\n\nI was following the [D&C template](https://leetcode.com/explore/learn/card/recursion-ii/470/divide-and-conquer/2869/) solution for this problem. The code works for the \"base case\", when `target` exists somewhere in the middle of the `m x n` matrix. The implementation fails when target is close to the edge of the matrix.\n\nUPD: problem found. The part of i-th row to the right from j-th pivot requires an explicit check for target, as it falls into the blind zone of the D&C.\n\n```\nclass Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        if not matrix or not matrix[0]:\n            return False\n\n        # pivots\n        dim_i, dim_j = len(matrix), len(matrix[0])\n        j = len(matrix[0]) // 2\n        i = 0\n        while i < dim_i - 1 and matrix[i][j] < target:\n            i += 1\n\n        # excape case\n        if matrix[i][j] == target:\n            return True\n\n        # divide\n        left = [row[:j] for row in matrix[i:]]\n        right = [row[j:] for row in matrix[:i]]\n\n        # Note: including pivot row, col does not help\n        # left = [row[:min(j+1, dim_j)] for row in matrix[i:]]\n        # right = [row[j:] for row in matrix[:min(i+1, dim_i)]]\n        \n        # conquer\n        return self.searchMatrix(left, target) or self.searchMatrix(right, target)\n\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Substring with At Most K Distinct Characters",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1569089,
                "content": [
                    {
                        "username": "kislayabhi",
                        "content": "I developed some intuition by solving a few problems of Dynamic Programming ... that the Longest Common subsequence (and some similar problems) can be handled nicely using Dynamic Programming. (Also LCS is discussed in great detail in Intro to Algo book [Cormen et. al])\\n\\nGiven you face this in an interview, how to *think* that it is not DP and that another linear time algorithm is possible. Right now I was able to do it since I couldn't come up with a proper recurrence (but to convince myself there is no DP recurrence possible, I had to spend a lot of time!!)\\n\\nWhat is your take on this?"
                    },
                    {
                        "username": "n0000b",
                        "content": "DP can be used pretty much for any problem you may come across, but it\\'s going to be a lot more complex and worst at time complexity, hence we\\'ve other techniques that we could use to reason about.\\n\\nFor example, this question is asking for a longest substring from a given string. A substring a sequence of strings and \"not\" the subsequence. Subsequence is not continuous, hence your intuition of deploying LCS based approach would result in lot more complex solution with an awful time complexity.\\n\\nFor the most part whenever you\\'re asked for \"continuous\" to work with, the sliding window or a two pointer approach is the way to go."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Something to remember is a hashmap itself has a size, and can serve in place of just using a list when you want to track an extra piece of information."
                    },
                    {
                        "username": "jooseong",
                        "content": "Here\\'s my code:\\nhttps://leetcode.com/playground/2cePRrEv\\n\\nFor testcase \"eceba\" / 2, the expected answer is 3:\\nBut if I submit this, the output is 2.\\n\\nStrange thing is that, in my eclipse and even in leetcode\\'s \"playground debug\", the code outputs 3, a right answer.\\nWhy this happens?"
                    },
                    {
                        "username": "tvue",
                        "content": "at most  k(3) distinct chars. How is \"ece\" atmost 3 distinct chars? 2 is correct unless I'm missing something here"
                    },
                    {
                        "username": "jbiesnecker",
                        "content": "Whenever I\\'m asked for the longest subsequence of something, my first thought it always some sort of sliding window. In this case it\\'s pretty easy and linear, because each letter is either 1) already in the window; 2) new but not causing the unique characters to overflow; or 3) new but causing the unique characters to overflow. Based on which case the new letter causes we can figure out how to move the left side of the window."
                    }
                ]
            },
            {
                "id": 1965017,
                "content": [
                    {
                        "username": "kislayabhi",
                        "content": "I developed some intuition by solving a few problems of Dynamic Programming ... that the Longest Common subsequence (and some similar problems) can be handled nicely using Dynamic Programming. (Also LCS is discussed in great detail in Intro to Algo book [Cormen et. al])\\n\\nGiven you face this in an interview, how to *think* that it is not DP and that another linear time algorithm is possible. Right now I was able to do it since I couldn't come up with a proper recurrence (but to convince myself there is no DP recurrence possible, I had to spend a lot of time!!)\\n\\nWhat is your take on this?"
                    },
                    {
                        "username": "n0000b",
                        "content": "DP can be used pretty much for any problem you may come across, but it\\'s going to be a lot more complex and worst at time complexity, hence we\\'ve other techniques that we could use to reason about.\\n\\nFor example, this question is asking for a longest substring from a given string. A substring a sequence of strings and \"not\" the subsequence. Subsequence is not continuous, hence your intuition of deploying LCS based approach would result in lot more complex solution with an awful time complexity.\\n\\nFor the most part whenever you\\'re asked for \"continuous\" to work with, the sliding window or a two pointer approach is the way to go."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Something to remember is a hashmap itself has a size, and can serve in place of just using a list when you want to track an extra piece of information."
                    },
                    {
                        "username": "jooseong",
                        "content": "Here\\'s my code:\\nhttps://leetcode.com/playground/2cePRrEv\\n\\nFor testcase \"eceba\" / 2, the expected answer is 3:\\nBut if I submit this, the output is 2.\\n\\nStrange thing is that, in my eclipse and even in leetcode\\'s \"playground debug\", the code outputs 3, a right answer.\\nWhy this happens?"
                    },
                    {
                        "username": "tvue",
                        "content": "at most  k(3) distinct chars. How is \"ece\" atmost 3 distinct chars? 2 is correct unless I'm missing something here"
                    },
                    {
                        "username": "jbiesnecker",
                        "content": "Whenever I\\'m asked for the longest subsequence of something, my first thought it always some sort of sliding window. In this case it\\'s pretty easy and linear, because each letter is either 1) already in the window; 2) new but not causing the unique characters to overflow; or 3) new but causing the unique characters to overflow. Based on which case the new letter causes we can figure out how to move the left side of the window."
                    }
                ]
            },
            {
                "id": 1572508,
                "content": [
                    {
                        "username": "kislayabhi",
                        "content": "I developed some intuition by solving a few problems of Dynamic Programming ... that the Longest Common subsequence (and some similar problems) can be handled nicely using Dynamic Programming. (Also LCS is discussed in great detail in Intro to Algo book [Cormen et. al])\\n\\nGiven you face this in an interview, how to *think* that it is not DP and that another linear time algorithm is possible. Right now I was able to do it since I couldn't come up with a proper recurrence (but to convince myself there is no DP recurrence possible, I had to spend a lot of time!!)\\n\\nWhat is your take on this?"
                    },
                    {
                        "username": "n0000b",
                        "content": "DP can be used pretty much for any problem you may come across, but it\\'s going to be a lot more complex and worst at time complexity, hence we\\'ve other techniques that we could use to reason about.\\n\\nFor example, this question is asking for a longest substring from a given string. A substring a sequence of strings and \"not\" the subsequence. Subsequence is not continuous, hence your intuition of deploying LCS based approach would result in lot more complex solution with an awful time complexity.\\n\\nFor the most part whenever you\\'re asked for \"continuous\" to work with, the sliding window or a two pointer approach is the way to go."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Something to remember is a hashmap itself has a size, and can serve in place of just using a list when you want to track an extra piece of information."
                    },
                    {
                        "username": "jooseong",
                        "content": "Here\\'s my code:\\nhttps://leetcode.com/playground/2cePRrEv\\n\\nFor testcase \"eceba\" / 2, the expected answer is 3:\\nBut if I submit this, the output is 2.\\n\\nStrange thing is that, in my eclipse and even in leetcode\\'s \"playground debug\", the code outputs 3, a right answer.\\nWhy this happens?"
                    },
                    {
                        "username": "tvue",
                        "content": "at most  k(3) distinct chars. How is \"ece\" atmost 3 distinct chars? 2 is correct unless I'm missing something here"
                    },
                    {
                        "username": "jbiesnecker",
                        "content": "Whenever I\\'m asked for the longest subsequence of something, my first thought it always some sort of sliding window. In this case it\\'s pretty easy and linear, because each letter is either 1) already in the window; 2) new but not causing the unique characters to overflow; or 3) new but causing the unique characters to overflow. Based on which case the new letter causes we can figure out how to move the left side of the window."
                    }
                ]
            },
            {
                "id": 1678583,
                "content": [
                    {
                        "username": "kislayabhi",
                        "content": "I developed some intuition by solving a few problems of Dynamic Programming ... that the Longest Common subsequence (and some similar problems) can be handled nicely using Dynamic Programming. (Also LCS is discussed in great detail in Intro to Algo book [Cormen et. al])\\n\\nGiven you face this in an interview, how to *think* that it is not DP and that another linear time algorithm is possible. Right now I was able to do it since I couldn't come up with a proper recurrence (but to convince myself there is no DP recurrence possible, I had to spend a lot of time!!)\\n\\nWhat is your take on this?"
                    },
                    {
                        "username": "n0000b",
                        "content": "DP can be used pretty much for any problem you may come across, but it\\'s going to be a lot more complex and worst at time complexity, hence we\\'ve other techniques that we could use to reason about.\\n\\nFor example, this question is asking for a longest substring from a given string. A substring a sequence of strings and \"not\" the subsequence. Subsequence is not continuous, hence your intuition of deploying LCS based approach would result in lot more complex solution with an awful time complexity.\\n\\nFor the most part whenever you\\'re asked for \"continuous\" to work with, the sliding window or a two pointer approach is the way to go."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Something to remember is a hashmap itself has a size, and can serve in place of just using a list when you want to track an extra piece of information."
                    },
                    {
                        "username": "jooseong",
                        "content": "Here\\'s my code:\\nhttps://leetcode.com/playground/2cePRrEv\\n\\nFor testcase \"eceba\" / 2, the expected answer is 3:\\nBut if I submit this, the output is 2.\\n\\nStrange thing is that, in my eclipse and even in leetcode\\'s \"playground debug\", the code outputs 3, a right answer.\\nWhy this happens?"
                    },
                    {
                        "username": "tvue",
                        "content": "at most  k(3) distinct chars. How is \"ece\" atmost 3 distinct chars? 2 is correct unless I'm missing something here"
                    },
                    {
                        "username": "jbiesnecker",
                        "content": "Whenever I\\'m asked for the longest subsequence of something, my first thought it always some sort of sliding window. In this case it\\'s pretty easy and linear, because each letter is either 1) already in the window; 2) new but not causing the unique characters to overflow; or 3) new but causing the unique characters to overflow. Based on which case the new letter causes we can figure out how to move the left side of the window."
                    }
                ]
            }
        ]
    }
]