[
    {
        "title": "Longest Cycle in a Graph",
        "question_content": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.\n&nbsp;\nExample 1:\n\nInput: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.\n\nExample 2:\n\nInput: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph.\n\n&nbsp;\nConstraints:\n\n\tn == edges.length\n\t2 <= n <= 105\n\t-1 <= edges[i] < n\n\tedges[i] != i",
        "solutions": [
            {
                "id": 2357750,
                "title": "simple-dfs-traversal-easy-explanation-c",
                "content": "This problem can be done by a simple traversal .We can store the path we are traversing in a vector , as soon as we find a previously visited node again , we will check the occurence of this node in our path till now . Like if we have visited  0 -> 1 -> 2 -> 3 -> and then again if we come at 1 , we can check our path  vector and say that the cycle formed is of length 3.\\n\\n\\n**Time Complexity : O(n)\\nSpace Complexity : O(n)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxLength = -1;\\n    \\n    void getcycle(vector<int> &edges,int si,vector<bool>& visit,vector<int>& store){\\n        if(si == -1)return ;\\n        if(visit[si]){\\n            int count = -1;\\n            for(int i =0;i<store.size();i++){\\n                if(store[i]==si){\\n                    count = i;\\n                    break;\\n                } }\\n            \\n            if(count==-1)return;\\n            int size = (store.size()-count);\\n            maxLength = max(maxLength,size);\\n            return ;\\n        }\\n        \\n        visit[si] = true;\\n        store.push_back(si);\\n        getcycle(edges,edges[si],visit,store);\\n        \\n        \\n        return ;\\n        \\n    }\\n    \\n    \\n    \\n    int longestCycle(vector<int>& edges) {\\n        \\n        vector<bool> visit(edges.size(),0);\\n        \\n        for(int i =0;i<edges.size();i++){\\n            \\n            if(visit[i])continue;\\n            vector<int> store;\\n            getcycle(edges,i,visit,store);\\n     \\n        }\\n        \\n        return maxLength;\\n        \\n    }\\n};\\n```\\n\\n***Please upvote if it helped : )***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxLength = -1;\\n    \\n    void getcycle(vector<int> &edges,int si,vector<bool>& visit,vector<int>& store){\\n        if(si == -1)return ;\\n        if(visit[si]){\\n            int count = -1;\\n            for(int i =0;i<store.size();i++){\\n                if(store[i]==si){\\n                    count = i;\\n                    break;\\n                } }\\n            \\n            if(count==-1)return;\\n            int size = (store.size()-count);\\n            maxLength = max(maxLength,size);\\n            return ;\\n        }\\n        \\n        visit[si] = true;\\n        store.push_back(si);\\n        getcycle(edges,edges[si],visit,store);\\n        \\n        \\n        return ;\\n        \\n    }\\n    \\n    \\n    \\n    int longestCycle(vector<int>& edges) {\\n        \\n        vector<bool> visit(edges.size(),0);\\n        \\n        for(int i =0;i<edges.size();i++){\\n            \\n            if(visit[i])continue;\\n            vector<int> store;\\n            getcycle(edges,i,visit,store);\\n     \\n        }\\n        \\n        return maxLength;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357631,
                "title": "dfs",
                "content": "We can build on the previous problem ([2359. Find Closest Node to Given Two Nodes](https://leetcode.com/problems/find-closest-node-to-given-two-nodes/discuss/2357694/Two-DFS)).\\n    \\nWe run DFS from a node, memoising the distance to each node we reach.\\n    \\nIf we encounter a node with distance, we find a cycle. The length of that cycle is the current distance minus the distance to that node.\\n\\nWe also need to track whether we reached the node during the current DFS cycle. For that, we track the starting node (`i`) when we encountered the node for the first time.\\n    \\n**C++**\\n```cpp\\nint longestCycle(vector<int>& e) {\\n    int res = -1;\\n    vector<pair<int, int>> memo(e.size(), {-1, -1});\\n    for (int i = 0; i < e.size(); ++i)\\n        for (int j = i, dist = 0; j != -1; j = e[j]) {\\n            auto [dist_i, from_i] = memo[j];\\n            if (dist_i == -1)\\n                memo[j] = {dist++, i};\\n            else {\\n                if (from_i == i)\\n                    res = max(res, dist - dist_i);\\n                break;\\n            }\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint longestCycle(vector<int>& e) {\\n    int res = -1;\\n    vector<pair<int, int>> memo(e.size(), {-1, -1});\\n    for (int i = 0; i < e.size(); ++i)\\n        for (int j = i, dist = 0; j != -1; j = e[j]) {\\n            auto [dist_i, from_i] = memo[j];\\n            if (dist_i == -1)\\n                memo[j] = {dist++, i};\\n            else {\\n                if (from_i == i)\\n                    res = max(res, dist - dist_i);\\n                break;\\n            }\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342721,
                "title": "image-explanation-complete-intuition-dfs-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`)\\n\\n`Longest Cycle in a Graph` by `Aryan Mittal`\\n![apple3.png](https://assets.leetcode.com/users/images/447095a5-f869-4e75-ada8-ce0067e12530_1679818304.3134897.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/c591a18b-760e-400a-a4a0-ff176113cbbd_1679815584.4759831.png)\\n![image.png](https://assets.leetcode.com/users/images/6424ae9f-c977-452e-9260-136ca117bb7d_1679815593.6359584.png)\\n![image.png](https://assets.leetcode.com/users/images/5e0d69ce-f64d-4b8d-8a26-524c4e077fc1_1679815602.066836.png)\\n![image.png](https://assets.leetcode.com/users/images/14e5f51c-b54c-4f7e-9b19-68eedd28290a_1679815612.158006.png)\\n![image.png](https://assets.leetcode.com/users/images/c27b66c4-d02c-4cb4-b3ec-96b37450c4bb_1679815621.4223695.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int answer = -1;\\n    void dfs(int node, vector<int>& edges, unordered_map<int, int>& dist, vector<bool>& visit) {\\n        visit[node] = true;\\n        int neighbor = edges[node];\\n\\n        if (neighbor != -1 && !visit[neighbor]) {\\n            dist[neighbor] = dist[node] + 1;\\n            dfs(neighbor, edges, dist, visit);\\n        } else if (neighbor != -1 && dist.count(neighbor)) {\\n            answer = max(answer, dist[node] - dist[neighbor] + 1);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<bool> visit(n);\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!visit[i]) {\\n                unordered_map<int, int> dist;\\n                dist[i] = 1;\\n                dfs(i, edges, dist, visit);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int answer = -1;\\n\\n    public void dfs(int node, int[] edges, Map<Integer, Integer> dist, boolean[] visit) {\\n        visit[node] = true;\\n        int neighbor = edges[node];\\n\\n        if (neighbor != -1 && !visit[neighbor]) {\\n            dist.put(neighbor, dist.get(node) + 1);\\n            dfs(neighbor, edges, dist, visit);\\n        } else if (neighbor != -1 && dist.containsKey(neighbor)) {\\n            answer = Math.max(answer, dist.get(node) - dist.get(neighbor) + 1);\\n        }\\n    }\\n\\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        boolean[] visit = new boolean[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!visit[i]) {\\n                Map<Integer, Integer> dist = new HashMap<>();\\n                dist.put(i, 1);\\n                dfs(i, edges, dist, visit);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n```Python3 []\\nfrom typing import List, Dict\\n\\nclass Solution:\\n    answer = -1\\n\\n    def dfs(self, node: int, edges: List[int], dist: Dict[int, int], visit: List[bool]):\\n        visit[node] = True\\n        neighbor = edges[node]\\n\\n        if neighbor != -1 and not visit[neighbor]:\\n            dist[neighbor] = dist[node] + 1\\n            self.dfs(neighbor, edges, dist, visit)\\n        elif neighbor != -1 and neighbor in dist:\\n            self.answer = max(self.answer, dist[node] - dist[neighbor] + 1)\\n\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        visit = [False] * n\\n\\n        for i in range(n):\\n            if not visit[i]:\\n                dist = {i: 1}\\n                self.dfs(i, edges, dist, visit)\\n\\n        return self.answer\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int answer = -1;\\n    void dfs(int node, vector<int>& edges, unordered_map<int, int>& dist, vector<bool>& visit) {\\n        visit[node] = true;\\n        int neighbor = edges[node];\\n\\n        if (neighbor != -1 && !visit[neighbor]) {\\n            dist[neighbor] = dist[node] + 1;\\n            dfs(neighbor, edges, dist, visit);\\n        } else if (neighbor != -1 && dist.count(neighbor)) {\\n            answer = max(answer, dist[node] - dist[neighbor] + 1);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<bool> visit(n);\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!visit[i]) {\\n                unordered_map<int, int> dist;\\n                dist[i] = 1;\\n                dfs(i, edges, dist, visit);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int answer = -1;\\n\\n    public void dfs(int node, int[] edges, Map<Integer, Integer> dist, boolean[] visit) {\\n        visit[node] = true;\\n        int neighbor = edges[node];\\n\\n        if (neighbor != -1 && !visit[neighbor]) {\\n            dist.put(neighbor, dist.get(node) + 1);\\n            dfs(neighbor, edges, dist, visit);\\n        } else if (neighbor != -1 && dist.containsKey(neighbor)) {\\n            answer = Math.max(answer, dist.get(node) - dist.get(neighbor) + 1);\\n        }\\n    }\\n\\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        boolean[] visit = new boolean[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!visit[i]) {\\n                Map<Integer, Integer> dist = new HashMap<>();\\n                dist.put(i, 1);\\n                dfs(i, edges, dist, visit);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\n```Python3 []\\nfrom typing import List, Dict\\n\\nclass Solution:\\n    answer = -1\\n\\n    def dfs(self, node: int, edges: List[int], dist: Dict[int, int], visit: List[bool]):\\n        visit[node] = True\\n        neighbor = edges[node]\\n\\n        if neighbor != -1 and not visit[neighbor]:\\n            dist[neighbor] = dist[node] + 1\\n            self.dfs(neighbor, edges, dist, visit)\\n        elif neighbor != -1 and neighbor in dist:\\n            self.answer = max(self.answer, dist[node] - dist[neighbor] + 1)\\n\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        visit = [False] * n\\n\\n        for i in range(n):\\n            if not visit[i]:\\n                dist = {i: 1}\\n                self.dfs(i, edges, dist, visit)\\n\\n        return self.answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358092,
                "title": "simple-short-iterative-c-o-n",
                "content": "Borrow the idea of indexing nodes from Tarjan\\'s algorithm. Obviously each node can have at most one \"next\" node, so a recursion is not needed. Simply track the path and label each node with an increamenting index until we meet one that already has an index. We then check if the index is in our current path and update the answer.\\n```\\nint longestCycle(vector<int>& edges) {\\n    int n = edges.size(), ans = -1;\\n    vector<int> idx(n);\\n    for (int i = 0, k = 1; i < n; i++) {\\n        int j = i, curk = k;\\n        while (j != -1 && !idx[j]) {\\n            idx[j] = k++;\\n            j = edges[j];\\n        }\\n        if (j != -1 && idx[j] >= curk)\\n            ans = max(ans, k - idx[j]);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint longestCycle(vector<int>& edges) {\\n    int n = edges.size(), ans = -1;\\n    vector<int> idx(n);\\n    for (int i = 0, k = 1; i < n; i++) {\\n        int j = i, curk = k;\\n        while (j != -1 && !idx[j]) {\\n            idx[j] = k++;\\n            j = edges[j];\\n        }\\n        if (j != -1 && idx[j] >= curk)\\n            ans = max(ans, k - idx[j]);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2357650,
                "title": "java-dfs-hashmap",
                "content": "**Code:**\\n\\n    public int longestCycle(int[] edges) {\\n        int res = -1;\\n        boolean[] vis = new boolean[edges.length]; // global visisted\\n\\n        for(int i=0; i<edges.length; i++){\\n            if(vis[i]) continue;\\n            HashMap<Integer, Integer> x = new HashMap<>();  // local visited\\n            for (int idx=i, dist=0; idx!=-1; idx=edges[idx]){\\n                if(x.containsKey(idx)){\\n                    res = Math.max(res, dist-x.get(idx));\\n                    break;\\n                }\\n                if(vis[idx]) break;\\n                vis[idx] = true;\\n                x.put(idx, dist++);\\n            } \\n        }\\n        return res;\\n    }\\n\\t\\n\\t\\n**Logic:**\\nfor every node during our local dfs traversal, we can store the distance from our starting node.\\nif we find a node that we have aleady visited (we use a map x to check that), there exists a cycle\\nthe length of the cycle would be dist-x.get(idx)\\n\\nnow we don\\'t need to check if a cycle exists for any of the nodes that we visited during our traversal.\\nwhy? because since there only exists one directed edge from each node, we\\'re sure that we\\'ve already visited any cycle from that node (if it exists).\\nso we can just ignore that node if we ever see it again.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "**Code:**\\n\\n    public int longestCycle(int[] edges) {\\n        int res = -1;\\n        boolean[] vis = new boolean[edges.length]; // global visisted\\n\\n        for(int i=0; i<edges.length; i++){\\n            if(vis[i]) continue;\\n            HashMap<Integer, Integer> x = new HashMap<>();  // local visited\\n            for (int idx=i, dist=0; idx!=-1; idx=edges[idx]){\\n                if(x.containsKey(idx)){\\n                    res = Math.max(res, dist-x.get(idx));\\n                    break;\\n                }\\n                if(vis[idx]) break;\\n                vis[idx] = true;\\n                x.put(idx, dist++);\\n            } \\n        }\\n        return res;\\n    }\\n\\t\\n\\t\\n**Logic:**\\nfor every node during our local dfs traversal, we can store the distance from our starting node.\\nif we find a node that we have aleady visited (we use a map x to check that), there exists a cycle\\nthe length of the cycle would be dist-x.get(idx)\\n\\nnow we don\\'t need to check if a cycle exists for any of the nodes that we visited during our traversal.\\nwhy? because since there only exists one directed edge from each node, we\\'re sure that we\\'ve already visited any cycle from that node (if it exists).\\nso we can just ignore that node if we ever see it again.",
                "codeTag": "Unknown"
            },
            {
                "id": 2357790,
                "title": "python-linear-dfs-with-clean-thought-process-when-being-asked-during-interviews",
                "content": "### DFS\\nLet\\'s simplify the problem first.\\nWhat if we are asking to find out if there is a cycle starting with node `i`? We can run DFS to detect the cycle, where we maintain a hash set to track all of nodes we are visiting and detect the cycle when the next node exists in the set. \\nHow can we know the length of cycle? we can quickly get it by tracking the order of each visiting node by chaning hash set to map and using array to track the order.\\n\\nSo far, it looks simple. But does it mean we have run the DFS for each node which deducts to *O(N^2)*?\\n\\nLet\\'s observe the property that each node has at most one out-going edge. This is the key to solve this problem, because it means it\\'s not possible for one node `i` to be joint point for multiple cycles. In another word, if one node `i` belongs to one cycle, then it must belong to that cycle only. You can think about why by drawing some examples.\\n\\nWith this observation, we can skip those nodes that have been visited since they will never be the starting point of the new cycle, which reduce the time complexity to linear.\\n\\nSo let\\'s put it all together.\\n1. Use `visiting` to track the index of nodes in the `stack` which traces the order of nodes we are visiting.\\n2. Use `seen` to mark nodes that have been visited.\\n3. Run DFS for each node to detect cycles.\\n4. When find a cycle, update the `max_length` with the `visiting` and `stack`.\\n5. Mark the node visited in `seen`\\n6. return `max_length` if it is valid, else `-1`.\\n\\n```python\\ndef longestCycle(self, edges: List[int]) -> int:\\n    n = len(edges)\\n    self.max_length = float(\\'-inf\\')\\n    seen = [False] * n\\n    visiting = {}\\n    stack = []\\n        \\n    def dfs(node):\\n        if not seen[node]:\\n            if node in visiting:\\n                self.max_length = max(self.max_length, len(stack) - visiting[node])\\n            elif edges[node] != -1: \\n                visiting[node] = len(stack) \\n                stack.append(node)\\n                dfs(edges[node])\\n                stack.pop()\\n                visiting.pop(node)\\n            seen[node] = True\\n  \\n    for i in range(n):            \\n        dfs(i)\\n    return self.max_length if self.max_length > 0 else -1    \\n```\\n\\n*Time Complexity* = *O(N)*\\n*Space Complexity* = *O(N)*",
                "solutionTags": [],
                "code": "```python\\ndef longestCycle(self, edges: List[int]) -> int:\\n    n = len(edges)\\n    self.max_length = float(\\'-inf\\')\\n    seen = [False] * n\\n    visiting = {}\\n    stack = []\\n        \\n    def dfs(node):\\n        if not seen[node]:\\n            if node in visiting:\\n                self.max_length = max(self.max_length, len(stack) - visiting[node])\\n            elif edges[node] != -1: \\n                visiting[node] = len(stack) \\n                stack.append(node)\\n                dfs(edges[node])\\n                stack.pop()\\n                visiting.pop(node)\\n            seen[node] = True\\n  \\n    for i in range(n):            \\n        dfs(i)\\n    return self.max_length if self.max_length > 0 else -1    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3341780,
                "title": "clean-codes-full-explanation-d-f-s-c-java-python3",
                "content": "# Intuition :\\n- Return the length of the longest cycle in the graph. If no cycle exists, return `-1`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Depth First Search\\n- Here we are using a modified depth-first search algorithm to visit each node in the graph. \\n- We keep track of the time at which each node is visited and store it in an array called `timeVisited`. \\n- If a node is visited again, we skip it because it has already been processed.\\n- If the current node is visited again, and the time at which it was first visited is greater than or equal to the start time of the current traversal, it means that there is a cycle in the graph that includes the current node. \\n- The length of the cycle is the difference between the current time and the time at which the node was first visited. \\n- We also keep track of the maximum cycle length found so far and return it as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] : With Comments\\n```Java []\\nclass Solution {\\n  public int longestCycle(int[] edges) {\\n    int ans = -1; // Initialize the answer to -1\\n    int time = 1; // Initialize the current time step to 1\\n    int[] timeVisited = new int[edges.length]; // Initialize an array to store the time at which each node was first visited\\n\\n    // Iterate through each node in the graph\\n    for (int i = 0; i < edges.length; ++i) {\\n      if (timeVisited[i] > 0) // If the node has already been visited, skip it\\n        continue;\\n      final int startTime = time; // Record the start time of the current traversal\\n      int u = i; // Initialize the current node to the ith node\\n      // Traverse the graph until the end of the path is reached or a visited node is encountered\\n      while (u != -1 && timeVisited[u] == 0) {\\n        timeVisited[u] = time++; // Record the current time step and increment time\\n        u = edges[u]; // Move to the next node in the path\\n      }\\n      // If a cycle is found that includes the current node, update the answer\\n      if (u != -1 && timeVisited[u] >= startTime)\\n        ans = Math.max(ans, time - timeVisited[u]);\\n    }\\n\\n    return ans; // Return the length of the longest cycle found\\n  }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\n public:\\n  int longestCycle(vector<int>& edges) {\\n    int ans = -1; // Initialize the answer to -1\\n    int time = 1; // Initialize the current time step to 1\\n    vector<int> timeVisited(edges.size()); // Initialize a vector to store the time at which each node was first visited\\n\\n    // Iterate through each node in the graph\\n    for (int i = 0; i < edges.size(); ++i) {\\n      if (timeVisited[i]) // If the node has already been visited, skip it\\n        continue;\\n      const int startTime = time; // Record the start time of the current traversal\\n      int u = i; // Initialize the current node to the ith node\\n      // Traverse the graph until the end of the path is reached or a visited node is encountered\\n      while (u != -1 && !timeVisited[u]) {\\n        timeVisited[u] = time++; // Record the current time step and increment time\\n        u = edges[u]; // Move to the next node in the path\\n      }\\n      // If a cycle is found that includes the current node, update the answer\\n      if (u != -1 && timeVisited[u] >= startTime)\\n        ans = max(ans, time - timeVisited[u]);\\n    }\\n\\n    return ans; // Return the length of the longest cycle found\\n  }\\n};\\n\\n```\\n```Python []\\nclass Solution:\\n  def longestCycle(self, edges: List[int]) -> int:\\n    ans = -1  # Initialize the answer to -1\\n    time = 1  # Initialize the current time step to 1\\n    timeVisited = [0] * len(edges)  # Initialize a list to store the time at which each node was first visited\\n\\n    # Iterate through each node in the graph\\n    for i, edge in enumerate(edges):\\n      if timeVisited[i]:  # If the node has already been visited, skip it\\n        continue\\n      startTime = time  # Record the start time of the current traversal\\n      u = i  # Initialize the current node to the ith node\\n      # Traverse the graph until the end of the path is reached or a visited node is encountered\\n      while u != -1 and not timeVisited[u]:\\n        timeVisited[u] = time  # Record the current time step\\n        time += 1  # Increment time\\n        u = edges[u]  # Move to the next node in the path\\n      # If a cycle is found that includes the current node, update the answer\\n      if u != -1 and timeVisited[u] >= startTime:\\n        ans = max(ans, time - timeVisited[u])\\n\\n    return ans  # Return the length of the longest cycle found\\n\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/1de35c8d-2ffc-4544-bb01-4aa8aad4ba97_1679796559.8463354.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```Java []\\nclass Solution {\\n  public int longestCycle(int[] edges) {\\n    int ans = -1; // Initialize the answer to -1\\n    int time = 1; // Initialize the current time step to 1\\n    int[] timeVisited = new int[edges.length]; // Initialize an array to store the time at which each node was first visited\\n\\n    // Iterate through each node in the graph\\n    for (int i = 0; i < edges.length; ++i) {\\n      if (timeVisited[i] > 0) // If the node has already been visited, skip it\\n        continue;\\n      final int startTime = time; // Record the start time of the current traversal\\n      int u = i; // Initialize the current node to the ith node\\n      // Traverse the graph until the end of the path is reached or a visited node is encountered\\n      while (u != -1 && timeVisited[u] == 0) {\\n        timeVisited[u] = time++; // Record the current time step and increment time\\n        u = edges[u]; // Move to the next node in the path\\n      }\\n      // If a cycle is found that includes the current node, update the answer\\n      if (u != -1 && timeVisited[u] >= startTime)\\n        ans = Math.max(ans, time - timeVisited[u]);\\n    }\\n\\n    return ans; // Return the length of the longest cycle found\\n  }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\n public:\\n  int longestCycle(vector<int>& edges) {\\n    int ans = -1; // Initialize the answer to -1\\n    int time = 1; // Initialize the current time step to 1\\n    vector<int> timeVisited(edges.size()); // Initialize a vector to store the time at which each node was first visited\\n\\n    // Iterate through each node in the graph\\n    for (int i = 0; i < edges.size(); ++i) {\\n      if (timeVisited[i]) // If the node has already been visited, skip it\\n        continue;\\n      const int startTime = time; // Record the start time of the current traversal\\n      int u = i; // Initialize the current node to the ith node\\n      // Traverse the graph until the end of the path is reached or a visited node is encountered\\n      while (u != -1 && !timeVisited[u]) {\\n        timeVisited[u] = time++; // Record the current time step and increment time\\n        u = edges[u]; // Move to the next node in the path\\n      }\\n      // If a cycle is found that includes the current node, update the answer\\n      if (u != -1 && timeVisited[u] >= startTime)\\n        ans = max(ans, time - timeVisited[u]);\\n    }\\n\\n    return ans; // Return the length of the longest cycle found\\n  }\\n};\\n\\n```\n```Python []\\nclass Solution:\\n  def longestCycle(self, edges: List[int]) -> int:\\n    ans = -1  # Initialize the answer to -1\\n    time = 1  # Initialize the current time step to 1\\n    timeVisited = [0] * len(edges)  # Initialize a list to store the time at which each node was first visited\\n\\n    # Iterate through each node in the graph\\n    for i, edge in enumerate(edges):\\n      if timeVisited[i]:  # If the node has already been visited, skip it\\n        continue\\n      startTime = time  # Record the start time of the current traversal\\n      u = i  # Initialize the current node to the ith node\\n      # Traverse the graph until the end of the path is reached or a visited node is encountered\\n      while u != -1 and not timeVisited[u]:\\n        timeVisited[u] = time  # Record the current time step\\n        time += 1  # Increment time\\n        u = edges[u]  # Move to the next node in the path\\n      # If a cycle is found that includes the current node, update the answer\\n      if u != -1 and timeVisited[u] >= startTime:\\n        ans = max(ans, time - timeVisited[u])\\n\\n    return ans  # Return the length of the longest cycle found\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342409,
                "title": "python3-beats-91-90-short-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/32aa55a9-332b-46f6-a6ba-0936acd42ead_1679810850.9233634.png)\\n# Please UPVOTE\\uD83D\\uDE0A\\n\\n## Python3\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        bl=[0]*n\\n        mp=defaultdict(int)\\n        mx=-1\\n        for i in range(n):\\n            if(bl[i]==0):\\n                x=i\\n                l=0\\n                st=set()\\n                while x>-1 and bl[x]==0:\\n                    bl[x]=1\\n                    mp[x]=l\\n                    l+=1\\n                    st.add(x)\\n                    x=edges[x]\\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\\n        return mx\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        bl=[0]*n\\n        mp=defaultdict(int)\\n        mx=-1\\n        for i in range(n):\\n            if(bl[i]==0):\\n                x=i\\n                l=0\\n                st=set()\\n                while x>-1 and bl[x]==0:\\n                    bl[x]=1\\n                    mp[x]=l\\n                    l+=1\\n                    st.add(x)\\n                    x=edges[x]\\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358073,
                "title": "simple-dfs-solution-c",
                "content": "Time Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int mx;\\n    void dfs(int node, vector<int> &edges, vector<int> &distance_from_start_node, vector<int> &visited, int current_len)\\n    {\\n        if (!visited[node]) {\\n            // adding the current node to the path form start node\\n            visited[node] = 1;\\n            distance_from_start_node[node] = current_len;\\n\\n            if (edges[node] != -1) {\\n                dfs(edges[node], edges, distance_from_start_node, visited, current_len + 1);\\n            }\\n            \\n            // backtracking step - removing the current node from the path\\n            distance_from_start_node[node] = -1;\\n        }\\n        else {\\n            // checking if the current node makes a cycle or not\\n            if (distance_from_start_node[node] != -1) {\\n                // if it makes a cycle, then consider the number of nodes in the cycle\\n                mx = max(current_len - distance_from_start_node[node], mx);\\n            }\\n        }\\n    }\\n    int longestCycle(vector<int> &edges)\\n    {\\n        mx = -1;\\n        vector<int> visited(edges.size(), 0), length(edges.size(), -1);\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (!visited[i]) {\\n                dfs(i, edges, length, visited, 0);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/85c856d9-ffe3-499f-bff5-fb983387a0c2_1659242246.2496102.png)",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int mx;\\n    void dfs(int node, vector<int> &edges, vector<int> &distance_from_start_node, vector<int> &visited, int current_len)\\n    {\\n        if (!visited[node]) {\\n            // adding the current node to the path form start node\\n            visited[node] = 1;\\n            distance_from_start_node[node] = current_len;\\n\\n            if (edges[node] != -1) {\\n                dfs(edges[node], edges, distance_from_start_node, visited, current_len + 1);\\n            }\\n            \\n            // backtracking step - removing the current node from the path\\n            distance_from_start_node[node] = -1;\\n        }\\n        else {\\n            // checking if the current node makes a cycle or not\\n            if (distance_from_start_node[node] != -1) {\\n                // if it makes a cycle, then consider the number of nodes in the cycle\\n                mx = max(current_len - distance_from_start_node[node], mx);\\n            }\\n        }\\n    }\\n    int longestCycle(vector<int> &edges)\\n    {\\n        mx = -1;\\n        vector<int> visited(edges.size(), 0), length(edges.size(), -1);\\n        for (int i = 0; i < edges.size(); ++i) {\\n            if (!visited[i]) {\\n                dfs(i, edges, length, visited, 0);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358961,
                "title": "dfs-cycle-detect-simple-soln",
                "content": "\\n    class Solution {\\n    int c=0;\\n    boolean flag=false;\\n    int max=0;\\n    public int longestCycle(int[] edges) {\\n        int n=edges.length;\\n        //creating the adjacency list\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            if(edges[i]!=-1){\\n                adj.get(i).add(edges[i]);\\n            }\\n        }\\n        //one for normal nodevisit\\n        int vis[]=new int[n];\\n        //check for cycle\\n        int dfsvis[]=new int[n];\\n        //for counting length of cycle\\n        int count[]=new int[n];\\n        flag=false;max=0;\\n        for(int i=0;i<n;i++){\\n           \\n            if(vis[i]==0){\\n                c=0;            \\n                dfs(i,vis,count,adj,dfsvis);\\n            }\\n        }\\n      //flag=false means no cycle exists\\n        return flag==false?-1:max;\\n    }\\n    public void dfs(int node,int vis[],int count[],List<List<Integer>> adj,int dfsvis[]){\\n        //we mark both vis and dfsvis as true\\n        vis[node]=1;\\n        dfsvis[node]=1;\\n        //traversing the adj list\\n        for(int it:adj.get(node)){\\n            //when node is not visited we increment the count by one and store it in count array\\n            if(vis[it]==0){\\n                c++;\\n                count[it]=c;\\n                //recursive call for other nodes\\n                dfs(it,vis,count,adj,dfsvis);\\n            }\\n            //when dfsvis is true cycle is detected we store the length of cycle and store it in  max and mark flag as true as cycle exists and break the loop\\n            \\n            else if(dfsvis[it]==1){\\n                c++;\\n                count[it]=c-count[it];\\n                max=Math.max(max,count[it]);\\n                flag=true;\\n                break;\\n            }\\n        }\\n        //when we come out of loop we mark again dfsvis as 0\\n        dfsvis[node]=0;\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int c=0;\\n    boolean flag=false;\\n    int max=0;\\n    public int longestCycle(int[] edges) {\\n        int n=edges.length;\\n        //creating the adjacency list\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2357799,
                "title": "python-short-cycle-detection-code-learned-from-problem-1192",
                "content": "\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n,visit=len(edges),set()\\n        \\n        ranks=[float(\\'inf\\')]*n\\n        \\n        def t(i,rank):\\n            if i in visit or edges[i]==-1:   return -1\\n\\n            if ranks[i]<rank: return rank-ranks[i]\\n\\n            ranks[i]=rank \\n            \\n            val=t(edges[i],rank+1)\\n            \\n            visit.add(i)\\n            \\n            return val\\n\\n        return max(t(i,0) for i in range(n))",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n,visit=len(edges),set()\\n        \\n        ranks=[float(\\'inf\\')]*n\\n        \\n        def t(i,rank):\\n            if i in visit or edges[i]==-1:   return -1\\n\\n            if ranks[i]<rank: return rank-ranks[i]\\n\\n            ranks[i]=rank \\n            \\n            val=t(edges[i],rank+1)\\n            \\n            visit.add(i)\\n            \\n            return val\\n\\n        return max(t(i,0) for i in range(n))",
                "codeTag": "Python3"
            },
            {
                "id": 2359735,
                "title": "c-dfs-clean-code-100-runtime-o-n",
                "content": "**DFS Solution**\\n```cpp\\nvector<vector<int>> graph;\\nvector<int> visited;\\nint ans = -1;\\n\\nvoid dfs(int node, int d, unordered_map<int, int>& mp){        \\n    visited[node] = 1;\\n    mp[node] = d;\\n\\n    for(int child: graph[node]){\\n        if(visited[child] == 0){\\n            dfs(child, d+1, mp);\\n        }else if(mp.count(child)){\\n\\t\\t\\t// a -> b -> c -> d and if cycle if from d -> b, we reduce the distance of a\\n            ans = max(ans, d - mp[child] + 1);\\n        }\\n    }\\n}\\n\\nint longestCycle(vector<int>& edges) {\\n    int n = edges.size();\\n    graph.resize(n);\\n    visited.resize(n, 0);\\n\\n\\t//build graph\\n    for(int i=0; i<n; i++){\\n        if(edges[i] != -1) graph[i].push_back(edges[i]);\\n    }\\n\\n    for(int i=0; i<n; i++){\\n        unordered_map<int, int> mp; //keeps track of distance\\n        dfs(i, 0, mp);\\n    }\\n\\n    return ans;\\n}\\n```\\n\\n**Upvote and let\\'s learn from each others!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> graph;\\nvector<int> visited;\\nint ans = -1;\\n\\nvoid dfs(int node, int d, unordered_map<int, int>& mp){        \\n    visited[node] = 1;\\n    mp[node] = d;\\n\\n    for(int child: graph[node]){\\n        if(visited[child] == 0){\\n            dfs(child, d+1, mp);\\n        }else if(mp.count(child)){\\n\\t\\t\\t// a -> b -> c -> d and if cycle if from d -> b, we reduce the distance of a\\n            ans = max(ans, d - mp[child] + 1);\\n        }\\n    }\\n}\\n\\nint longestCycle(vector<int>& edges) {\\n    int n = edges.size();\\n    graph.resize(n);\\n    visited.resize(n, 0);\\n\\n\\t//build graph\\n    for(int i=0; i<n; i++){\\n        if(edges[i] != -1) graph[i].push_back(edges[i]);\\n    }\\n\\n    for(int i=0; i<n; i++){\\n        unordered_map<int, int> mp; //keeps track of distance\\n        dfs(i, 0, mp);\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342428,
                "title": "c-dfs",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n```\\nif you wish , like it!!\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mx=-1;\\n    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j){\\n        if(pvis[i]){\\n            mx = max(mx , j - pvis[i]);\\n            return;\\n        }\\n        if(!vis[i]){\\n            pvis[i] =j; j++; vis[i]=1;\\n            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);\\n        }\\n        pvis[i] = 0;\\n        return;\\n    }\\n\\n    int longestCycle(vector<int>& ed) {\\n        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);\\n        mx = -1;\\n        for(int i=0;i<ed.size();i++){\\n            if(!vis[i]) dfs(ed,pvis,vis,i,1);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif you wish , like it!!\\n```\n```\\nclass Solution {\\npublic:\\n    int mx=-1;\\n    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j){\\n        if(pvis[i]){\\n            mx = max(mx , j - pvis[i]);\\n            return;\\n        }\\n        if(!vis[i]){\\n            pvis[i] =j; j++; vis[i]=1;\\n            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);\\n        }\\n        pvis[i] = 0;\\n        return;\\n    }\\n\\n    int longestCycle(vector<int>& ed) {\\n        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);\\n        mx = -1;\\n        for(int i=0;i<ed.size();i++){\\n            if(!vis[i]) dfs(ed,pvis,vis,i,1);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358451,
                "title": "c-simple-solution-o-n-beats-100-use-of-kahn-s-algo",
                "content": "![image](https://assets.leetcode.com/users/images/26011633-6bfe-44cc-99c9-3635fd7885c3_1659248389.1799803.png)\\n\\n\\nIn this solution we will first use Kahn\\'s algorithm to remove those nodes, who will potentially not be in a cycle. \\n* Use a visited array to mark visited nodes.\\n* Add nodes in queue having indegree 0.\\n* At the end nodes having indegree as 1 will only be unvisited as they can be the part of the longest cycle in graph.\\n\\n-->From the second image we can see that node 2,3,4 are unvisited and have indegree as 1, rest have 0 indegree and are visited. Potentially from 2,3,4 nodes only we will get the longest cycle. Not necessarily, all the nodes with indegree 1, will contribute in one big cycle. We will have to calculate the longest cycle, but we are sure here that the longest cycle will contain nodes left with only indegree 1.\\n\\nNext intialize our answer with -1 (Will be -1 if no cycle is present).\\nThe next pass will be to calculate the longest cycle among the potential nodes.\\n* Iterate through all the nodes and perform a traversal to find cycle length if the current node is unvisited.\\n* Store the current node in a variable, in our case \"start\".\\n* Intialise a variable with the adjacent node of our current node, in our case \"curr\".\\n* We will loop through, increasing the length of the path, until we reach back to start, that means we have found a cycle.\\n* Then simply update our answer, if the length of the cycle we just found is greater.\\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int>indeg(n);\\n        vector<int>vis(n);\\n        // count indegree of each node\\n        for(int i=0; i<n; i++){\\n            if(edges[i] != -1) indeg[edges[i]]++;\\n        }\\n        // Kahn\\'s algorithm\\n        queue<int>q;\\n        for(int i=0; i<n; i++){\\n            if(indeg[i] == 0) q.push(i);\\n        }\\n        while(!q.empty()){\\n            int top = q.front();\\n            vis[top] = 1;\\n            q.pop();\\n            if(edges[top] != -1){\\n                indeg[edges[top]]--;\\n                if(indeg[edges[top]] == 0) q.push(edges[top]);\\n            }\\n        }\\n        int ans = -1;\\n        for(int i=0; i<n; i++){\\n            // If all our visited, that means we dont have a cycle\\n            if(!vis[i]){\\n                int start = i;\\n                int curr = edges[i];\\n                vis[i] = 1;\\n                int c = 0;\\n                // find cycle length\\n                while(curr != start){\\n                    if(indeg[curr] == 0) break;\\n                    curr = edges[curr];\\n                    vis[curr] = 1;\\n                    c++;\\n                }\\n                ans = max(ans,c+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int>indeg(n);\\n        vector<int>vis(n);\\n        // count indegree of each node\\n        for(int i=0; i<n; i++){\\n            if(edges[i] != -1) indeg[edges[i]]++;\\n        }\\n        // Kahn\\'s algorithm\\n        queue<int>q;\\n        for(int i=0; i<n; i++){\\n            if(indeg[i] == 0) q.push(i);\\n        }\\n        while(!q.empty()){\\n            int top = q.front();\\n            vis[top] = 1;\\n            q.pop();\\n            if(edges[top] != -1){\\n                indeg[edges[top]]--;\\n                if(indeg[edges[top]] == 0) q.push(edges[top]);\\n            }\\n        }\\n        int ans = -1;\\n        for(int i=0; i<n; i++){\\n            // If all our visited, that means we dont have a cycle\\n            if(!vis[i]){\\n                int start = i;\\n                int curr = edges[i];\\n                vis[i] = 1;\\n                int c = 0;\\n                // find cycle length\\n                while(curr != start){\\n                    if(indeg[curr] == 0) break;\\n                    curr = edges[curr];\\n                    vis[curr] = 1;\\n                    c++;\\n                }\\n                ans = max(ans,c+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357834,
                "title": "java-clean-simple-dfs-beat-100-time-and-memory",
                "content": "```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int[] map = new int[edges.length];\\n        int result = -1;\\n\\n        for (int i = 0; i < edges.length; i++)\\n            result = Math.max(result, helper(i, 1, edges, map));\\n\\n        return result;\\n    }\\n\\n    int helper(int index, int total, int[] edges, int[] map) {\\n        if (index == -1 || map[index] == -1)\\n            return -1;\\n\\n        if (map[index] != 0)\\n            return total - map[index];\\n\\n        map[index] = total;\\n        int result = helper(edges[index], total + 1, edges, map);\\n        map[index] = -1;\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int[] map = new int[edges.length];\\n        int result = -1;\\n\\n        for (int i = 0; i < edges.length; i++)\\n            result = Math.max(result, helper(i, 1, edges, map));\\n\\n        return result;\\n    }\\n\\n    int helper(int index, int total, int[] edges, int[] map) {\\n        if (index == -1 || map[index] == -1)\\n            return -1;\\n\\n        if (map[index] != 0)\\n            return total - map[index];\\n\\n        map[index] = total;\\n        int result = helper(edges[index], total + 1, edges, map);\\n        map[index] = -1;\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357652,
                "title": "easy-to-understand-dfs-preorder",
                "content": "**Approach**\\n\\nDo a simple dfs in all point, maintaining a preorder of every node.\\n\\nif the preorder number of any next node is greater then the preorder of the begining of the dfs, then there must be a cycle and ans = max(ans, current cycle)\\n\\n**Time Complexity**\\nO(n)\\n\\n**Space Complexity**\\nO(n)\\n\\n**C++**\\n```\\nclass Solution {\\n    void dfs(int i, int &len, vector<int>& edges, vector<int> &preorder, int &ans, int st) {\\n        preorder[i] = len++;\\n        \\n        if (edges[i] == -1)\\n            return;\\n        else if (preorder[edges[i]] == -1)\\n            dfs(edges[i], len, edges, preorder, ans, st);\\n        else if (preorder[edges[i]] >= st)\\n            ans = max(ans, preorder[i] - preorder[edges[i]] + 1);\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> preorder(edges.size(), -1);\\n        int ans = -1;\\n        int len = 0;\\n        \\n        for (int i = 0; i < edges.size(); i++)\\n            if (preorder[i] == -1 && edges[i] != -1)\\n                dfs(i, len, edges, preorder, ans, len);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        preorder = [-1 for _ in range(len(edges))]\\n        self.ans = -1\\n        self.pre = 0\\n        \\n        def dfs(self, i: int, st: int) -> None:\\n            preorder[i] = self.pre\\n            self.pre += 1\\n            \\n            if edges[i] == -1:\\n                return\\n            elif preorder[edges[i]] == -1:\\n                dfs(self, edges[i], st)\\n                return\\n            elif preorder[edges[i]] >= st:\\n                self.ans = max(self.ans, preorder[i] - preorder[edges[i]] + 1)\\n                return\\n        \\n        for i in range(len(edges)):\\n            if preorder[i] == -1 and edges[i] != -1:\\n                dfs(self, i, self.pre)\\n        \\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int i, int &len, vector<int>& edges, vector<int> &preorder, int &ans, int st) {\\n        preorder[i] = len++;\\n        \\n        if (edges[i] == -1)\\n            return;\\n        else if (preorder[edges[i]] == -1)\\n            dfs(edges[i], len, edges, preorder, ans, st);\\n        else if (preorder[edges[i]] >= st)\\n            ans = max(ans, preorder[i] - preorder[edges[i]] + 1);\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> preorder(edges.size(), -1);\\n        int ans = -1;\\n        int len = 0;\\n        \\n        for (int i = 0; i < edges.size(); i++)\\n            if (preorder[i] == -1 && edges[i] != -1)\\n                dfs(i, len, edges, preorder, ans, len);\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        preorder = [-1 for _ in range(len(edges))]\\n        self.ans = -1\\n        self.pre = 0\\n        \\n        def dfs(self, i: int, st: int) -> None:\\n            preorder[i] = self.pre\\n            self.pre += 1\\n            \\n            if edges[i] == -1:\\n                return\\n            elif preorder[edges[i]] == -1:\\n                dfs(self, edges[i], st)\\n                return\\n            elif preorder[edges[i]] >= st:\\n                self.ans = max(self.ans, preorder[i] - preorder[edges[i]] + 1)\\n                return\\n        \\n        for i in range(len(edges)):\\n            if preorder[i] == -1 and edges[i] != -1:\\n                dfs(self, i, self.pre)\\n        \\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341779,
                "title": "java-easy-solution-hashmap-90-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int[] cycleLength = new int[edges.length];\\n        Arrays.fill(cycleLength, -1);\\n        boolean[] visited = new boolean[edges.length];\\n        int max = -1;\\n        for (int i = 0; i < edges.length; i++) {\\n            if (!visited[i]) {\\n                visited[i] = true;\\n                int destination = edges[i];\\n                int length = 1;\\n                HashMap<Integer, Integer> nodeToDistance = new HashMap<>();\\n                nodeToDistance.put(i, 0);\\n                while (destination != -1 && !visited[destination]) {\\n                    nodeToDistance.put(destination, length);\\n                    visited[destination] = true;\\n                    destination = edges[destination];\\n                    length++;\\n                }\\n                if (destination != -1 && nodeToDistance.containsKey(destination)) {\\n                    System.out.println(nodeToDistance);\\n                    cycleLength[destination] = length - nodeToDistance.get(destination);\\n                    max = Math.max(length - nodeToDistance.get(destination), max);\\n                }\\n            } \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int[] cycleLength = new int[edges.length];\\n        Arrays.fill(cycleLength, -1);\\n        boolean[] visited = new boolean[edges.length];\\n        int max = -1;\\n        for (int i = 0; i < edges.length; i++) {\\n            if (!visited[i]) {\\n                visited[i] = true;\\n                int destination = edges[i];\\n                int length = 1;\\n                HashMap<Integer, Integer> nodeToDistance = new HashMap<>();\\n                nodeToDistance.put(i, 0);\\n                while (destination != -1 && !visited[destination]) {\\n                    nodeToDistance.put(destination, length);\\n                    visited[destination] = true;\\n                    destination = edges[destination];\\n                    length++;\\n                }\\n                if (destination != -1 && nodeToDistance.containsKey(destination)) {\\n                    System.out.println(nodeToDistance);\\n                    cycleLength[destination] = length - nodeToDistance.get(destination);\\n                    max = Math.max(length - nodeToDistance.get(destination), max);\\n                }\\n            } \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343552,
                "title": "easy-solutions-with-exaplanation-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n1. We are given a directed graph where each node has at most one outgoing edge. \\u2022\\n2. We need to find the length of the longest cycle in the graph. \\u2022\\n3. If no cycle exists, we need to return -1. \\u2022\\n4. We can use a modified version of the depth-first search (DFS) algorithm to solve this problem.\\n\\n\\n\\n# Approach\\n1. We will start from each unvisited node and perform a DFS on it.\\n2. During the DFS, we will keep track of the time at which we visit each node.\\n3. We will also mark each visited node.\\n4. If we encounter a visited node during the DFS, we have found a cycle.\\n5. The length of the cycle is the difference between the current time and the time at which we first visited the node.\\n6. We will keep track of the maximum cycle length seen so far.\\nIf no cycle is found, we will return -1.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of nodes in the graph. We visit each node at most once, and perform constant-time operations on each node.\\n\\n- Space complexity: O(n), where n is the number of nodes in the graph. We use an array of size n to keep track of the time at which we visit each node.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int longestCycleLen = -1;  // initialize longest cycle length to -1\\n        int timeStep = 1;  // initialize time step to 1\\n        int[] nodeVisitedAtTime = new int[edges.length];  // initialize visited time of each node to 0\\n        \\n        // traverse the graph from each node\\n        for (int currentNode = 0; currentNode < edges.length; ++currentNode) {\\n            // skip nodes that have already been visited\\n            if (nodeVisitedAtTime[currentNode] > 0)\\n                continue;\\n            final int startTime = timeStep;  // record the start time\\n            int u = currentNode;\\n            // follow the edges until we reach a visited node or a node with no outgoing edges\\n            while (u != -1 && nodeVisitedAtTime[u] == 0) {\\n                nodeVisitedAtTime[u] = timeStep++;  // mark the current node as visited and increment the time step\\n                u = edges[u];  // follow the edge to the next node\\n            }\\n            // check if we\\'ve found a cycle and update longest cycle length if the current cycle is longer\\n            if (u != -1 && nodeVisitedAtTime[u] >= startTime)\\n                longestCycleLen = Math.max(longestCycleLen, timeStep - nodeVisitedAtTime[u]);\\n        }\\n\\n        return longestCycleLen;  // return the length of the longest cycle found\\n    }\\n}\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int longestCycleLen = -1;\\n        int timeStep = 1;\\n        vector<int> nodeVisitedAtTime(edges.size(), 0);\\n\\n        for (int currentNode = 0; currentNode < edges.size(); ++currentNode) {\\n            if (nodeVisitedAtTime[currentNode] > 0)\\n                continue;\\n            const int startTime = timeStep;\\n            int u = currentNode;\\n            while (u != -1 && nodeVisitedAtTime[u] == 0) {\\n                nodeVisitedAtTime[u] = timeStep++;\\n                u = edges[u];\\n            }\\n            if (u != -1 && nodeVisitedAtTime[u] >= startTime)\\n                longestCycleLen = max(longestCycleLen, timeStep - nodeVisitedAtTime[u]);\\n        }\\n\\n        return longestCycleLen;\\n    }\\n};\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def longestCycle(self, edges):\\n        longestCycleLen = -1\\n        timeStep = 1\\n        nodeVisitedAtTime = [0] * len(edges)\\n\\n        for currentNode in range(len(edges)):\\n            if nodeVisitedAtTime[currentNode] > 0:\\n                continue\\n            startTime = timeStep\\n            u = currentNode\\n            while u != -1 and nodeVisitedAtTime[u] == 0:\\n                nodeVisitedAtTime[u] = timeStep\\n                timeStep += 1\\n                u = edges[u]\\n            if u != -1 and nodeVisitedAtTime[u] >= startTime:\\n                longestCycleLen = max(longestCycleLen, timeStep - nodeVisitedAtTime[u])\\n\\n        return longestCycleLen\\n\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int longestCycleLen = -1;  // initialize longest cycle length to -1\\n        int timeStep = 1;  // initialize time step to 1\\n        int[] nodeVisitedAtTime = new int[edges.length];  // initialize visited time of each node to 0\\n        \\n        // traverse the graph from each node\\n        for (int currentNode = 0; currentNode < edges.length; ++currentNode) {\\n            // skip nodes that have already been visited\\n            if (nodeVisitedAtTime[currentNode] > 0)\\n                continue;\\n            final int startTime = timeStep;  // record the start time\\n            int u = currentNode;\\n            // follow the edges until we reach a visited node or a node with no outgoing edges\\n            while (u != -1 && nodeVisitedAtTime[u] == 0) {\\n                nodeVisitedAtTime[u] = timeStep++;  // mark the current node as visited and increment the time step\\n                u = edges[u];  // follow the edge to the next node\\n            }\\n            // check if we\\'ve found a cycle and update longest cycle length if the current cycle is longer\\n            if (u != -1 && nodeVisitedAtTime[u] >= startTime)\\n                longestCycleLen = Math.max(longestCycleLen, timeStep - nodeVisitedAtTime[u]);\\n        }\\n\\n        return longestCycleLen;  // return the length of the longest cycle found\\n    }\\n}\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int longestCycleLen = -1;\\n        int timeStep = 1;\\n        vector<int> nodeVisitedAtTime(edges.size(), 0);\\n\\n        for (int currentNode = 0; currentNode < edges.size(); ++currentNode) {\\n            if (nodeVisitedAtTime[currentNode] > 0)\\n                continue;\\n            const int startTime = timeStep;\\n            int u = currentNode;\\n            while (u != -1 && nodeVisitedAtTime[u] == 0) {\\n                nodeVisitedAtTime[u] = timeStep++;\\n                u = edges[u];\\n            }\\n            if (u != -1 && nodeVisitedAtTime[u] >= startTime)\\n                longestCycleLen = max(longestCycleLen, timeStep - nodeVisitedAtTime[u]);\\n        }\\n\\n        return longestCycleLen;\\n    }\\n};\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def longestCycle(self, edges):\\n        longestCycleLen = -1\\n        timeStep = 1\\n        nodeVisitedAtTime = [0] * len(edges)\\n\\n        for currentNode in range(len(edges)):\\n            if nodeVisitedAtTime[currentNode] > 0:\\n                continue\\n            startTime = timeStep\\n            u = currentNode\\n            while u != -1 and nodeVisitedAtTime[u] == 0:\\n                nodeVisitedAtTime[u] = timeStep\\n                timeStep += 1\\n                u = edges[u]\\n            if u != -1 and nodeVisitedAtTime[u] >= startTime:\\n                longestCycleLen = max(longestCycleLen, timeStep - nodeVisitedAtTime[u])\\n\\n        return longestCycleLen\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342013,
                "title": "beginner-friendly-solution-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing DFS\\n\\n# Approach\\n - we take 3 vectors visited(vis),extra,dist(to store prev node at which cycle start)\\n- take a loop from 0 to edges\\n- if vis[i] is false use dfs\\n- if vis[node] is false then convert it true and also extra[node]=true\\n- store distance in dist[node]\\n- then again recall dfs node as edges[node] and increase distance by 1\\n- if vis[node] is true and extra also true we take max of ans and distance and dist[node]\\n- and then make extra[node] to be false\\n\\n\\n---\\n\\nNote- We take another vector extra to suppose there is no cycle but the visited vector is already true it detects a cycle but there is no cycle. So for the cycle, both the vectors to be true at the node. \\n\\n# Please Upvote\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int>&edges,vector<bool>&vis,vector<bool>&extra,vector<int>&dist,int &ans,int distance){\\n        if(node!=-1){\\n            if(!vis[node]){\\n                vis[node]=true;\\n                extra[node]=true;\\n                dist[node]=distance;\\n                dfs(edges[node],edges,vis,extra,dist,ans,distance+1);\\n            }\\n            else if(extra[node]){\\n                ans=max(ans,distance-dist[node]);\\n            }\\n            extra[node]=false;\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<bool>vis(edges.size(),false);\\n        vector<bool>extra(edges.size(),false);\\n        vector<int>dist(edges.size(),0);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!vis[i]){\\n                dfs(i,edges,vis,extra,dist,ans,0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int>&edges,vector<bool>&vis,vector<bool>&extra,vector<int>&dist,int &ans,int distance){\\n        if(node!=-1){\\n            if(!vis[node]){\\n                vis[node]=true;\\n                extra[node]=true;\\n                dist[node]=distance;\\n                dfs(edges[node],edges,vis,extra,dist,ans,distance+1);\\n            }\\n            else if(extra[node]){\\n                ans=max(ans,distance-dist[node]);\\n            }\\n            extra[node]=false;\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<bool>vis(edges.size(),false);\\n        vector<bool>extra(edges.size(),false);\\n        vector<int>dist(edges.size(),0);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!vis[i]){\\n                dfs(i,edges,vis,extra,dist,ans,0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343308,
                "title": "easy-solutions-with-explanation-in-java-dfs-kahn-s",
                "content": "# Intuition and Approach\\nWe apply modified DFS or Kahn\\'s alogrithm(topological sort) with additional changes.\\n\\n### DFS\\n1) The approach here is to go through all the nodes mark them visited and maintain a distance map with entry being key node, value distance. Distance gets incremented as we move to another node via DFS\\n\\n2) Since we are marking visited we will never visit the same node again.\\n\\n3) While travesing if we reach a visited node we know that via visited array we then check map for the distance value. The current disatnce - distance of repeated node from map + 1 is the cycle length.\\n\\n4) We keep on calling DFS for remaining non visited node and maintain a global anser which contains largest\\n\\n\\n---\\n\\n\\n### Kahn\\'s Alogrithm\\n\\n1) This alogrithm is used to find cycles in acyclic graph (DAG)\\n2) If you are new to Kahn\\'s. Below are classic questions to understand the concept\\n    - [LC 207 - Course Schedule](https://leetcode.com/problems/course-schedule/)\\n    - [LC 210 - Course Schedule II](https://leetcode.com/problems/course-schedule-ii/description/)\\n\\n3) The catch here is that Kahn\\'s alogrithmn helps us to isolate cycles in graph, but we still need to find largest cycle.\\n\\n4) After kahn\\'s is applied we only have those nodes unvisited who have indegree non zero due to them being part of cycle. (Cycle doesn\\'t allow nodes which are part of to have indegree to be zero, just draw a example)\\n\\n5) Last step is to just iterate over the unvisited nodes and maintain a counter, if cycle is their we would end up from where we started, that is the start of the cycle(keep marking visited so that we never repeat).\\n\\n\\n---\\n\\n\\n- Time complexity:\\nO(n) as we are visitin all the node only once.\\n\\n\\n# DFS Code\\n```\\nclass Solution {\\n    int answer = -1;\\n\\n    public void dfs(int node, int[] edges, Map<Integer, Integer> dist, boolean[] visit) {\\n        visit[node] = true;\\n        int neighbor = edges[node];\\n\\n        if (neighbor != -1 && !visit[neighbor]) {\\n            dist.put(neighbor, dist.get(node) + 1);\\n            dfs(neighbor, edges, dist, visit);\\n        } else if (neighbor != -1 && dist.containsKey(neighbor)) {\\n            answer = Math.max(answer, dist.get(node) - dist.get(neighbor) + 1);\\n        }\\n    }\\n\\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        boolean[] visit = new boolean[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!visit[i]) {\\n                Map<Integer, Integer> dist = new HashMap<>();\\n                dist.put(i, 1);\\n                dfs(i, edges, dist, visit);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\\n## Kahn\\'s Code\\n```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        boolean[] visit = new boolean[n];\\n        int[] indegree = new int[n];\\n\\n        // Count indegree of each node.\\n        for (int edge : edges) {\\n            if (edge != -1) {\\n                indegree[edge]++;\\n            }\\n        }\\n\\n        // Kahn\\'s algorithm starts.\\n        //Adding all the nodes to queue which have indegree == 0\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indegree[i] == 0) {\\n                q.offer(i);\\n            }\\n        }\\n\\n        //Only those element come to queue and will be marked visited whoes indegree becomes zero\\n        while (!q.isEmpty()) {\\n            int node = q.poll();\\n            visit[node] = true;\\n            int neighbor = edges[node];\\n            if (neighbor != -1) {\\n                indegree[neighbor]--;\\n                if (indegree[neighbor] == 0) {\\n                    q.offer(neighbor);\\n                }\\n            }\\n        }\\n        // Kahn\\'s algorithm ends.\\n\\n        int answer = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (!visit[i]) {\\n                int neighbor = edges[i];\\n                int count = 1;\\n                visit[i] = true;\\n                // Iterate in the cycle.\\n                while (neighbor != i) {\\n                    visit[neighbor] = true;\\n                    count++;\\n                    neighbor = edges[neighbor];\\n                }\\n                answer = Math.max(answer, count);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging.\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/f016b4d0-6ab3-45c8-9e7a-fcd25e393d88_1679825264.030089.png)\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    int answer = -1;\\n\\n    public void dfs(int node, int[] edges, Map<Integer, Integer> dist, boolean[] visit) {\\n        visit[node] = true;\\n        int neighbor = edges[node];\\n\\n        if (neighbor != -1 && !visit[neighbor]) {\\n            dist.put(neighbor, dist.get(node) + 1);\\n            dfs(neighbor, edges, dist, visit);\\n        } else if (neighbor != -1 && dist.containsKey(neighbor)) {\\n            answer = Math.max(answer, dist.get(node) - dist.get(neighbor) + 1);\\n        }\\n    }\\n\\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        boolean[] visit = new boolean[n];\\n\\n        for (int i = 0; i < n; i++) {\\n            if (!visit[i]) {\\n                Map<Integer, Integer> dist = new HashMap<>();\\n                dist.put(i, 1);\\n                dfs(i, edges, dist, visit);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        boolean[] visit = new boolean[n];\\n        int[] indegree = new int[n];\\n\\n        // Count indegree of each node.\\n        for (int edge : edges) {\\n            if (edge != -1) {\\n                indegree[edge]++;\\n            }\\n        }\\n\\n        // Kahn\\'s algorithm starts.\\n        //Adding all the nodes to queue which have indegree == 0\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (indegree[i] == 0) {\\n                q.offer(i);\\n            }\\n        }\\n\\n        //Only those element come to queue and will be marked visited whoes indegree becomes zero\\n        while (!q.isEmpty()) {\\n            int node = q.poll();\\n            visit[node] = true;\\n            int neighbor = edges[node];\\n            if (neighbor != -1) {\\n                indegree[neighbor]--;\\n                if (indegree[neighbor] == 0) {\\n                    q.offer(neighbor);\\n                }\\n            }\\n        }\\n        // Kahn\\'s algorithm ends.\\n\\n        int answer = -1;\\n        for (int i = 0; i < n; i++) {\\n            if (!visit[i]) {\\n                int neighbor = edges[i];\\n                int count = 1;\\n                visit[i] = true;\\n                // Iterate in the cycle.\\n                while (neighbor != i) {\\n                    visit[neighbor] = true;\\n                    count++;\\n                    neighbor = edges[neighbor];\\n                }\\n                answer = Math.max(answer, count);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342930,
                "title": "12-lines-simple-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        ans = -1\\n        for i in range(len(edges)): \\n            curr = i\\n            path = []\\n            while edges[curr] >= 0:  # follow path until end or visited node\\n                path.append(curr)\\n                next = edges[curr]\\n                edges[curr] = -1   # mark as visited\\n                curr = next\\n            if curr in path:  # cycle found\\n                ans = max(ans, len(path)-path.index(curr)) # cycle length is path length minus nodes not in cycle\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        ans = -1\\n        for i in range(len(edges)): \\n            curr = i\\n            path = []\\n            while edges[curr] >= 0:  # follow path until end or visited node\\n                path.append(curr)\\n                next = edges[curr]\\n                edges[curr] = -1   # mark as visited\\n                curr = next\\n            if curr in path:  # cycle found\\n                ans = max(ans, len(path)-path.index(curr)) # cycle length is path length minus nodes not in cycle\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341838,
                "title": "c-dfs-bfs-faster-easy-to-understand",
                "content": "* ***Using BFS && DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // dfs function for finding the length of cycle\\n    \\n    void dfs(vector<int>& edges, int u, vector<bool>& vis, int &count)\\n    {\\n        vis[u] = true;\\n        \\n        count++;\\n        \\n        if(edges[u] != -1 && vis[edges[u]] == false)\\n        {\\n            dfs(edges, edges[u], vis, count);\\n        }\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        \\n        // use kahn\\'s algorithm\\n        \\n        vector<int> indegree(n, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int v = edges[i];\\n            \\n            if(v != -1)\\n            {\\n                indegree[v]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int u = q.front();\\n            \\n            q.pop();\\n            \\n            if(edges[u] != -1)\\n            {\\n                indegree[edges[u]]--;\\n                \\n                if(indegree[edges[u]] == 0)\\n                {\\n                    q.push(edges[u]);\\n                }\\n            }\\n        }\\n        \\n        // declare a vis array\\n        \\n        vector<bool> vis(n, false);\\n        \\n        int maxi = INT_MIN;\\n        \\n        // run a dfs for every node with indegree > 0\\n        \\n        // find the length of cycle and update maxi\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            \\n            if(indegree[i] > 0 && vis[i] == false)\\n            {\\n                dfs(edges, i, vis, count);\\n            }\\n            \\n            maxi = max(maxi, count);\\n        }\\n        \\n        // if there is no cycle in graph, return -1\\n        \\n        if(maxi == 0)\\n            return -1;\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // dfs function for finding the length of cycle\\n    \\n    void dfs(vector<int>& edges, int u, vector<bool>& vis, int &count)\\n    {\\n        vis[u] = true;\\n        \\n        count++;\\n        \\n        if(edges[u] != -1 && vis[edges[u]] == false)\\n        {\\n            dfs(edges, edges[u], vis, count);\\n        }\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        \\n        // use kahn\\'s algorithm\\n        \\n        vector<int> indegree(n, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int v = edges[i];\\n            \\n            if(v != -1)\\n            {\\n                indegree[v]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int u = q.front();\\n            \\n            q.pop();\\n            \\n            if(edges[u] != -1)\\n            {\\n                indegree[edges[u]]--;\\n                \\n                if(indegree[edges[u]] == 0)\\n                {\\n                    q.push(edges[u]);\\n                }\\n            }\\n        }\\n        \\n        // declare a vis array\\n        \\n        vector<bool> vis(n, false);\\n        \\n        int maxi = INT_MIN;\\n        \\n        // run a dfs for every node with indegree > 0\\n        \\n        // find the length of cycle and update maxi\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            \\n            if(indegree[i] > 0 && vis[i] == false)\\n            {\\n                dfs(edges, i, vis, count);\\n            }\\n            \\n            maxi = max(maxi, count);\\n        }\\n        \\n        // if there is no cycle in graph, return -1\\n        \\n        if(maxi == 0)\\n            return -1;\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357714,
                "title": "explanation-why-dp-used",
                "content": "So getting solution in the contest was not tough for me but finding that dp will be used here, that was tricky.\\nLet\\'s see why dp used \\n\\nif there is a path from a->b in the graph which is cycle. So all the nodes which is inside the circle and the nodes which is coming inside the circle from outside will make cycle path. So we can store it so that for each node we don\\'t have to explore it.\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/35307df6-ba29-49a7-99a8-905b3d226102_1659240591.9347072.png)\\n\\nFrom above image all the nodes [a,b,c,d,e] will make the cycle of length 4. You can\\'t get more than that because if there will be cycle with more than 4 length it would have included.\\n\\n**Note :**\\nIn the above example (Image) E has D and F edges which isn\\'t possible in this problem, because i to edge[i] is one to one.\\n\\n# Approach Explanation :\\n* Try to find out max possible cycle path from each node.\\n* And store it to avoid repetition.\\n\\n```\\nclass Solution {\\n    private int []dp;\\n    private int solve(int []nums, int u, Map<Integer, Integer> map, int cnt) {\\n        if(nums[u] == -1) {\\n            return Integer.MIN_VALUE;\\n        }\\n        if(dp[u]!=-1) return dp[u];\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\tYou might confused that there must be another path which will make max cycle?\\n\\t\\t\\te.g. b->c->e->g->d->b, if there is a path in the above image\\n\\t\\t\\tBut it\\'s not possible in this question because for given edges can contains atmost one element at a time for edges[i].\\n\\t\\t*/\\n\\t\\t\\n        if(map.containsKey(u)) {\\n            return cnt-map.get(u);\\n        }\\n        map.put(u, cnt);\\n        return solve(nums, nums[u], map, cnt+1);\\n    }\\n    \\n    public int longestCycle(int[] edges) {\\n        int res = -1;\\n        dp = new int[edges.length+1];\\n        Arrays.fill(dp,-1);\\n        for(int i=0;i<edges.length;i++) {\\n            if(dp[i]!=-1) continue;\\n            Map<Integer, Integer> map = new HashMap<>();\\n            dp[i] = solve(edges,i,new HashMap<>(), 1);\\n            map.forEach((k,v)->{\\n                dp[k]=v;\\n            });\\n            res = Math.max(res, dp[i]);\\n        }\\n        return res;\\n    }\\n}\\n```\\n# Time Complexity :\\nSince each node will be visited only once. So it\\'s linear time complexity i.e. O(N).\\n* Since *solve* function never allow redundant calls.\\n* And we wouldn\\'t call *solve* function for the node which has been visited.\\n\\n# Space Complexity :\\nWe\\'re using a dp array of size of N also our solve function\\'s stack can have max size of N(When graph become linkedList). So space complexity will be O(N).\\n\\n\\n**Please upvote if it helps.**\\n**Happy Coding!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int []dp;\\n    private int solve(int []nums, int u, Map<Integer, Integer> map, int cnt) {\\n        if(nums[u] == -1) {\\n            return Integer.MIN_VALUE;\\n        }\\n        if(dp[u]!=-1) return dp[u];\\n\\t\\t\\n\\t\\t/*\\n\\t\\t\\tYou might confused that there must be another path which will make max cycle?\\n\\t\\t\\te.g. b->c->e->g->d->b, if there is a path in the above image\\n\\t\\t\\tBut it\\'s not possible in this question because for given edges can contains atmost one element at a time for edges[i].\\n\\t\\t*/\\n\\t\\t\\n        if(map.containsKey(u)) {\\n            return cnt-map.get(u);\\n        }\\n        map.put(u, cnt);\\n        return solve(nums, nums[u], map, cnt+1);\\n    }\\n    \\n    public int longestCycle(int[] edges) {\\n        int res = -1;\\n        dp = new int[edges.length+1];\\n        Arrays.fill(dp,-1);\\n        for(int i=0;i<edges.length;i++) {\\n            if(dp[i]!=-1) continue;\\n            Map<Integer, Integer> map = new HashMap<>();\\n            dp[i] = solve(edges,i,new HashMap<>(), 1);\\n            map.forEach((k,v)->{\\n                dp[k]=v;\\n            });\\n            res = Math.max(res, dp[i]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345324,
                "title": "c-image-explanation-simple-solution-dfs-memoization-clean-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic DFS and Memoization to avoid re-traversal of same cycle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe basically traverse the edges from $$0$$ to $$n-1$$ and check a cycle from each node using DFS. If a cycle is found, we store its length in a $$dp$$ array to avoid re-traversal of the same cycle and return it. We initialize `answer = -1` and take the maximum of all the values.\\n**(Refer image for visualization)**\\nIn the $$dfs()$$ function we keep track of the length using a variable, say $$c$$ and increment it in each call. We assign this value to the $$visited$$ array if the value at that node is $$0$$.\\nThis helps in calculating the length of the cycle as the value of c at repeating node can be greater than that of cycle\\'s length. If a node recurs then we simply calculate the length of this occurance from previous. We now store this in the dp array for easier access in case of recurrence while traversing from other node (**For example, in this case from node 1, we reach 3 and the length of cycle for node 3 is already caluclated during traversal from node 0**).\\n\\n![image.png](https://assets.leetcode.com/users/images/f77f969a-d2bc-45a9-9571-0fa22e8be660_1679859931.1116314.png)\\nIn case we encounter -1, we simply return it. As the answer is maximum of all values the answer will either be -1 or the length of the cycle. (**As seen in example case 2**)\\n\\n![image.png](https://assets.leetcode.com/users/images/45d8041e-5b77-4c69-b488-7ebb48da8568_1679860318.0051472.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>& edges, int curr, int c, vector<int>& vis, vector<int>& dp){\\n        if(curr==-1) return -1;\\n        if(dp[curr]) return dp[curr];\\n        if(vis[curr]) { dp[curr]=c-vis[curr]+1; return dp[curr]; }\\n        c++;\\n        vis[curr]=c;\\n        int k=dfs(edges, edges[curr], c, vis, dp);\\n        dp[curr]=k;\\n        return k;\\n    } \\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> dp(n);\\n        int ans=-1;\\n        vector<int> vis(n);\\n        for(int i=0;i<n;i++){\\n            ans=max(ans, dfs(edges, i, 0, vis, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b830d516-9c15-468d-9089-bd8e42c6a0b4_1679860582.2895665.png)\\n# Please UPVOTE \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>& edges, int curr, int c, vector<int>& vis, vector<int>& dp){\\n        if(curr==-1) return -1;\\n        if(dp[curr]) return dp[curr];\\n        if(vis[curr]) { dp[curr]=c-vis[curr]+1; return dp[curr]; }\\n        c++;\\n        vis[curr]=c;\\n        int k=dfs(edges, edges[curr], c, vis, dp);\\n        dp[curr]=k;\\n        return k;\\n    } \\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> dp(n);\\n        int ans=-1;\\n        vector<int> vis(n);\\n        for(int i=0;i<n;i++){\\n            ans=max(ans, dfs(edges, i, 0, vis, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343139,
                "title": "python-beats-95-95-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse DFS to find `nodes` which belong to a loop.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a `visited` list to store visited nodes. The value of `visited[node]` is the value of the current `root` node.\\n\\n# Complexity\\n- Time complexity: $$O(V)$$ for $$V$$ is the numer of nodes.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        def find_loop(root, visited):\\n            \"\"\"Return the first node which belongs to a loop. Otherwise, return -1\"\"\"\\n            if visited[root] >= 0:\\n                return -1\\n            visited[root] = root\\n            next = edges[root]\\n   \\n            while next != -1 and visited[next] < 0:\\n                visited[next] = root\\n                next = edges[next]\\n\\n            if next != -1 and visited[next] == root:\\n                return next\\n            return -1\\n\\n        def count_loop(node):\\n            \"\"\"Count the size of a loop\"\"\" \\n            next_node = edges[node]\\n            count = 1\\n            while next_node != node:\\n                count += 1\\n                next_node = edges[next_node]\\n            return count\\n\\n        n = len(edges)\\n        visited = [-1] * n\\n        loop_nodes = []\\n        for i in range(n):\\n            node = find_loop(i, visited)\\n            if node > -1:\\n                loop_nodes.append(node)\\n\\n        return max([count_loop(node) for node in loop_nodes], default=-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        def find_loop(root, visited):\\n            \"\"\"Return the first node which belongs to a loop. Otherwise, return -1\"\"\"\\n            if visited[root] >= 0:\\n                return -1\\n            visited[root] = root\\n            next = edges[root]\\n   \\n            while next != -1 and visited[next] < 0:\\n                visited[next] = root\\n                next = edges[next]\\n\\n            if next != -1 and visited[next] == root:\\n                return next\\n            return -1\\n\\n        def count_loop(node):\\n            \"\"\"Count the size of a loop\"\"\" \\n            next_node = edges[node]\\n            count = 1\\n            while next_node != node:\\n                count += 1\\n                next_node = edges[next_node]\\n            return count\\n\\n        n = len(edges)\\n        visited = [-1] * n\\n        loop_nodes = []\\n        for i in range(n):\\n            node = find_loop(i, visited)\\n            if node > -1:\\n                loop_nodes.append(node)\\n\\n        return max([count_loop(node) for node in loop_nodes], default=-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341740,
                "title": "c-single-pass-in-place-flagging-100-time-119ms-100-space-85-9mb",
                "content": "This problem can be solved in multiple ways and ideally we want to reduce the amount of times we parse a given node, so we will flag the already visited ones.\\n\\nEven better if we can do it in-place.\\n\\nFantastic if we can also store information about when we passed through a certain node.\\n\\nLuckily, turns out we can achieve all of this with a bit of math magic.\\n\\nWe know that in `edges` an element flagged as `-1` is a dead-end, so we would stop there and that is a good start: what if we make all the visited elements negative, so that we know there is no point in going further?\\n\\nWith that in mind, we can start each possible cycle replacing each visited cell with a very large negative number that we will further decrease at each step, until we reach a cell that is already a negative number, meaning it is either a dead end or an already explored cell.\\n\\nTo help our exploration we will use the two pointers `prev` and `curr` to keep track of the indexed we were before and the current one, with `prev` being constantly updated to be `curr` while `curr` advances to `edges[curr]`.\\n\\nFor example, imagine having `edges == {4, 2, 0, 1, 1}`.\\n\\nWe assuming that we start marking visitd cells with `-2000000000`, we will have:\\n\\n```cpp\\nprev == 0, curr == 4, marker = -200000000\\n            4           2           0           0           1 // step 0\\n// prev = curr, curr = edges[curr], marker--\\nprev == 4, curr == 1, marker = -200000001\\n   -200000000           2           0           0           1 // step 1\\n// prev = curr, curr = edges[curr], marker--\\nprev == 1, curr == 2, marker = -200000002\\n   -200000000           0           0           0  -200000001 // step 2\\n// prev = curr, curr = edges[curr], marker--\\nprev == 2, curr == 0, marker = -200000003\\n   -200000000  -200000002           0           0  -200000001 // step 3\\n// prev = curr, curr = edges[curr], marker--\\nprev == 0, curr == -200000000, marker = -200000004\\n   -200000000  -200000002           0           0  -200000001 // step 4\\n```\\n\\nNow that we reached a negative value of `curr` which is not `-1`, we know we reached another explored cell, and we can derive the length of our cycle by doing `curr - marker`, since `marker` gives a numerical value matching *now* and `curr` informs us of how many steps ago we encountered that cell.\\n\\nIn our case, it is indeed `-200000000 - -200000003 == 3` steps ago.\\n\\nWe have some extra complications because we do not want to count cells we explored before and being part of another path (be it a cycle or not), we at each new cycle, we will increase our `marker` a bit, so that that way `curr - marker` will always be a negative number (because the absolute value of `marker` will be lower).\\n\\nNow, to code our solution, we will start as usual with a support variable, `res`, initialised to `-1` (the value of when no cycle is found).\\n\\nWe will then loop through each position in `edges` with the pointer `i` and, with an initial value of our marker `k` set to `-2000000000`, we will:\\n* set `prev` to be initially `i`;\\n* set `curr` to be initially `edges[i]`;\\n* `continu` if `curr` is negative, as discussed above (ie: it means we are either at a dead end or on an already explored cell);\\n* initialise `j`, our marker for the current cycle, to be `k`;\\n* loop `while` we did reach either a dead end or an already explored cell (ie: `curr < 0`) and:\\n    * mark the previous cell `edges[prev]` with `j`;\\n    * decrease `j` by `1`;\\n    * update `prev` to be `curr` for the next loop;\\n    * advance `curr` to be `edges[curr]` for the next loop;\\n* check if we ended up on an already visited cell (ie: `curr != -1`) and, if so:\\n    * compute the length of the cycle as `curr - j`;\\n    * update `res` to be the maximum between its current value and the just computed length of the current cycle;\\n* increase `k` by an arbitraty big number (I picked `10000` and it was good enough) to make sure future cycles will not give us a positive length.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int> &edges) {\\n        // support variables\\n        int res = -1;\\n        for (int i = 0, len = edges.size(), j, k = -2000000000, curr, prev; i < len; i++) {\\n            prev = i, curr = edges[i];\\n            // n is either a dead end or already visited\\n            if (curr < 0) continue;\\n            j = k;\\n            while (curr >= 0) {\\n                // marking the source cell as visited\\n                edges[prev] = j--;\\n                // updating curr and prev\\n                prev = curr;\\n                curr = edges[curr];\\n            }\\n            // updating res if we did not reach a dead-end\\n            if (curr != -1) res = max(res, curr - j);\\n            k += 10000;\\n        }\\n        return res;\\n    }\\n};\\n```\\nThe brag:\\n![image.png](https://assets.leetcode.com/users/images/d047bf7e-bdde-45d1-bfc6-a83f146af636_1679792946.8960652.png)\\n",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```cpp\\nprev == 0, curr == 4, marker = -200000000\\n            4           2           0           0           1 // step 0\\n// prev = curr, curr = edges[curr], marker--\\nprev == 4, curr == 1, marker = -200000001\\n   -200000000           2           0           0           1 // step 1\\n// prev = curr, curr = edges[curr], marker--\\nprev == 1, curr == 2, marker = -200000002\\n   -200000000           0           0           0  -200000001 // step 2\\n// prev = curr, curr = edges[curr], marker--\\nprev == 2, curr == 0, marker = -200000003\\n   -200000000  -200000002           0           0  -200000001 // step 3\\n// prev = curr, curr = edges[curr], marker--\\nprev == 0, curr == -200000000, marker = -200000004\\n   -200000000  -200000002           0           0  -200000001 // step 4\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int> &edges) {\\n        // support variables\\n        int res = -1;\\n        for (int i = 0, len = edges.size(), j, k = -2000000000, curr, prev; i < len; i++) {\\n            prev = i, curr = edges[i];\\n            // n is either a dead end or already visited\\n            if (curr < 0) continue;\\n            j = k;\\n            while (curr >= 0) {\\n                // marking the source cell as visited\\n                edges[prev] = j--;\\n                // updating curr and prev\\n                prev = curr;\\n                curr = edges[curr];\\n            }\\n            // updating res if we did not reach a dead-end\\n            if (curr != -1) res = max(res, curr - j);\\n            k += 10000;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357772,
                "title": "python3-one-pass-dfs",
                "content": "If a node is in a cycle, then it should have in-degree and out-degree. We denote the set of these nodes **potential**. And then we use dfs for the nodes in potential.\\nSince the out-degree for every node in potential is 1, it could not be in 2 cycles. Therefore, we use **visited** to record the nodes we have already visited in dfs.  **dfs(node, curr, v)** is to consider node with **curr** length of path, where **v** denotes the nodes in path.\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        in_d = set()\\n        out_d = set()\\n        for i, j in enumerate(edges):\\n            if j != -1:\\n                in_d.add(j)\\n                out_d.add(i)\\n        potential = in_d & out_d\\n        visited = set()\\n        self.ans = -1\\n        def dfs(node, curr, v):\\n            visited.add(node)\\n            v[node] = curr\\n            nei = edges[node]\\n            if nei in v:\\n                self.ans = max(self.ans, curr - v[nei] + 1)\\n                visited.add(nei)\\n                return\\n            if nei not in visited and nei in potential:\\n                dfs(nei, curr + 1, v)\\n        for node in potential:\\n            dfs(node, 1, {})\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        in_d = set()\\n        out_d = set()\\n        for i, j in enumerate(edges):\\n            if j != -1:\\n                in_d.add(j)\\n                out_d.add(i)\\n        potential = in_d & out_d\\n        visited = set()\\n        self.ans = -1\\n        def dfs(node, curr, v):\\n            visited.add(node)\\n            v[node] = curr\\n            nei = edges[node]\\n            if nei in v:\\n                self.ans = max(self.ans, curr - v[nei] + 1)\\n                visited.add(nei)\\n                return\\n            if nei not in visited and nei in potential:\\n                dfs(nei, curr + 1, v)\\n        for node in potential:\\n            dfs(node, 1, {})\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352408,
                "title": "day-85-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Initialize variable n with the size of the input vector edges.\\n2. Initialize variable longest with -1 to store the length of the longest cycle found.\\n3. Initialize boolean vector visited of size n to keep track of visited nodes.\\n4. Initialize integer vector memo of size n to memoize previously computed cycle lengths.\\n5. For each start node in the range 0 to n-1, do the following:\\n    - If the start node has not been visited yet, then\\n        - i. Set variables slow and fast to the start node index.\\n        - ii. While the current node fast is not a dead end (-1) and the next node after fast is also not a dead end:\\n            - Set slow to the next node.\\n            - Set fast to the node two steps ahead of fast.\\n            - If slow and fast are equal, a cycle has been found:\\n                - Set cycleLen to 1.\\n                - Set slow to the next node.\\n                - While slow is not equal to fast, increment cycleLen and set slow to the next node.\\n                - If cycleLen is greater than longest, set longest to cycleLen.\\n                - Set memo[start] to cycleLen to memoize the cycle length for future use.\\n                - Mark start as visited by setting visited[start] to true.\\n                - Break out of the while loop.\\n            - If the memo value for slow is not zero, a cycle length has been previously computed:\\n                - Set memo[start] to the previously computed cycle length for slow.\\n                - Mark start as visited by setting visited[start] to true.\\n                - Break out of the while loop.\\n1. Return longest as the length of the longest cycle found.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        int longest = -1;\\n        vector<bool> visited(n, false); // keep track of nodes visited\\n        vector<int> memo(n, 0); // memoization array to store previously computed cycle lengths\\n        for (int start = 0; start < n; start++) {\\n            if (!visited[start]) { // if node hasn\\'t been visited yet\\n                int slow = start, fast = start;\\n                while (edges[fast] != -1 && edges[edges[fast]] != -1) { // loop until a cycle is found or a dead end is reached\\n                    slow = edges[slow];\\n                    fast = edges[edges[fast]];\\n                    if (slow == fast) { // if a cycle is found\\n                        int cycleLen = 1;\\n                        slow = edges[slow];\\n                        while (slow != fast) { // compute the length of the cycle\\n                            cycleLen++;\\n                            slow = edges[slow];\\n                        }\\n                        longest = max(longest, cycleLen); // update longest cycle length if necessary\\n                        memo[start] = cycleLen; // memoize cycle length for future use\\n                        visited[start] = true; // mark node as visited\\n                        break;\\n                    }\\n                    if (memo[slow] != 0) { // if we\\'ve already computed the cycle length for this node\\n                        memo[start] = memo[slow]; // memoize previously computed cycle length\\n                        visited[start] = true; // mark node as visited\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return longest;            \\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        int longest = -1;\\n        boolean[] visited = new boolean[n];\\n        int[] memo = new int[n];\\n        Arrays.fill(memo, 0);\\n        for (int start = 0; start < n; start++) {\\n            if (!visited[start]) {\\n                int slow = start, fast = start;\\n                while (edges[fast] != -1 && edges[edges[fast]] != -1) {\\n                    slow = edges[slow];\\n                    fast = edges[edges[fast]];\\n                    if (slow == fast) {\\n                        int cycleLen = 1;\\n                        slow = edges[slow];\\n                        while (slow != fast) {\\n                            cycleLen++;\\n                            slow = edges[slow];\\n                        }\\n                        longest = Math.max(longest, cycleLen);\\n                        memo[start] = cycleLen;\\n                        visited[start] = true;\\n                        break;\\n                    }\\n                    if (memo[slow] != 0) {\\n                        memo[start] = memo[slow];\\n                        visited[start] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return longest;            \\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        longest = -1\\n        visited = [False] * n # keep track of nodes visited\\n        memo = [0] * n # memoization array to store previously computed cycle lengths\\n        for start in range(n):\\n            if not visited[start]: # if node hasn\\'t been visited yet\\n                slow = start\\n                fast = start\\n                while edges[fast] != -1 and edges[edges[fast]] != -1: # loop until a cycle is found or a dead end is reached\\n                    slow = edges[slow]\\n                    fast = edges[edges[fast]]\\n                    if slow == fast: # if a cycle is found\\n                        cycleLen = 1\\n                        slow = edges[slow]\\n                        while slow != fast: # compute the length of the cycle\\n                            cycleLen += 1\\n                            slow = edges[slow]\\n                        longest = max(longest, cycleLen) # update longest cycle length if necessary\\n                        memo[start] = cycleLen # memoize cycle length for future use\\n                        visited[start] = True # mark node as visited\\n                        break\\n                    if memo[slow] != 0: # if we\\'ve already computed the cycle length for this node\\n                        memo[start] = memo[slow] # memoize previously computed cycle length\\n                        visited[start] = True # mark node as visited\\n                        break\\n        return longest\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(n)**\\n\\nThe algorithm visits each node in the graph only once.\\n\\nIn the worst case, for each node it loops through a cycle before reaching a dead end.\\n\\nTherefore, **the time complexity is O(n), where n is the number of nodes in the graph.**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(n)**\\n\\nThe algorithm uses two arrays, visited and memo, both of size n.\\n\\nTherefore, **the space complexity is O(n), where n is the number of nodes in the graph.**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        int longest = -1;\\n        vector<bool> visited(n, false); // keep track of nodes visited\\n        vector<int> memo(n, 0); // memoization array to store previously computed cycle lengths\\n        for (int start = 0; start < n; start++) {\\n            if (!visited[start]) { // if node hasn\\'t been visited yet\\n                int slow = start, fast = start;\\n                while (edges[fast] != -1 && edges[edges[fast]] != -1) { // loop until a cycle is found or a dead end is reached\\n                    slow = edges[slow];\\n                    fast = edges[edges[fast]];\\n                    if (slow == fast) { // if a cycle is found\\n                        int cycleLen = 1;\\n                        slow = edges[slow];\\n                        while (slow != fast) { // compute the length of the cycle\\n                            cycleLen++;\\n                            slow = edges[slow];\\n                        }\\n                        longest = max(longest, cycleLen); // update longest cycle length if necessary\\n                        memo[start] = cycleLen; // memoize cycle length for future use\\n                        visited[start] = true; // mark node as visited\\n                        break;\\n                    }\\n                    if (memo[slow] != 0) { // if we\\'ve already computed the cycle length for this node\\n                        memo[start] = memo[slow]; // memoize previously computed cycle length\\n                        visited[start] = true; // mark node as visited\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return longest;            \\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        int longest = -1;\\n        boolean[] visited = new boolean[n];\\n        int[] memo = new int[n];\\n        Arrays.fill(memo, 0);\\n        for (int start = 0; start < n; start++) {\\n            if (!visited[start]) {\\n                int slow = start, fast = start;\\n                while (edges[fast] != -1 && edges[edges[fast]] != -1) {\\n                    slow = edges[slow];\\n                    fast = edges[edges[fast]];\\n                    if (slow == fast) {\\n                        int cycleLen = 1;\\n                        slow = edges[slow];\\n                        while (slow != fast) {\\n                            cycleLen++;\\n                            slow = edges[slow];\\n                        }\\n                        longest = Math.max(longest, cycleLen);\\n                        memo[start] = cycleLen;\\n                        visited[start] = true;\\n                        break;\\n                    }\\n                    if (memo[slow] != 0) {\\n                        memo[start] = memo[slow];\\n                        visited[start] = true;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return longest;            \\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        longest = -1\\n        visited = [False] * n # keep track of nodes visited\\n        memo = [0] * n # memoization array to store previously computed cycle lengths\\n        for start in range(n):\\n            if not visited[start]: # if node hasn\\'t been visited yet\\n                slow = start\\n                fast = start\\n                while edges[fast] != -1 and edges[edges[fast]] != -1: # loop until a cycle is found or a dead end is reached\\n                    slow = edges[slow]\\n                    fast = edges[edges[fast]]\\n                    if slow == fast: # if a cycle is found\\n                        cycleLen = 1\\n                        slow = edges[slow]\\n                        while slow != fast: # compute the length of the cycle\\n                            cycleLen += 1\\n                            slow = edges[slow]\\n                        longest = max(longest, cycleLen) # update longest cycle length if necessary\\n                        memo[start] = cycleLen # memoize cycle length for future use\\n                        visited[start] = True # mark node as visited\\n                        break\\n                    if memo[slow] != 0: # if we\\'ve already computed the cycle length for this node\\n                        memo[start] = memo[slow] # memoize previously computed cycle length\\n                        visited[start] = True # mark node as visited\\n                        break\\n        return longest\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344171,
                "title": "2360-longest-cycle-in-a-graph",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int Len = -1;\\n        int time = 1;\\n        vector<int> node(edges.size(), 0);\\n\\n        for (int current = 0; current < edges.size(); ++current) {\\n            if (node[current] > 0)\\n                continue;\\n            const int start = time;\\n            int u = current;\\n            while (u != -1 && node[u] == 0) {\\n                node[u] = time++;\\n                u = edges[u];\\n            }\\n            if (u != -1 && node[u] >= start)\\n                Len = max(Len, time - node[u]);\\n        }\\n        return Len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int Len = -1;\\n        int time = 1;\\n        vector<int> node(edges.size(), 0);\\n\\n        for (int current = 0; current < edges.size(); ++current) {\\n            if (node[current] > 0)\\n                continue;\\n            const int start = time;\\n            int u = current;\\n            while (u != -1 && node[u] == 0) {\\n                node[u] = time++;\\n                u = edges[u];\\n            }\\n            if (u != -1 && node[u] >= start)\\n                Len = max(Len, time - node[u]);\\n        }\\n        return Len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342846,
                "title": "dfs-simple-approach-c",
                "content": "**C++ Code**\\n```\\nclass Solution {\\npublic:\\nint mx=INT_MIN;\\nint count=0;\\nvoid dfs(int node,vector<int>& edges,int pathvis[],int vis[],int siz[]){\\n    int nd=edges[node];\\n    vis[node]=1;\\n    pathvis[node]=1;\\n    if(nd==-1){\\n        pathvis[node]=0;\\n        siz[node]=0;\\n        return ;\\n    }\\n    count++;\\n    siz[node]=count;\\n    if(vis[nd]==0 ){\\n        dfs(nd,edges,pathvis,vis,siz);\\n    }\\n    else if(pathvis[nd]!=0){\\n        mx=max(mx,count-siz[nd]+1);\\n        return ;\\n    }\\n    pathvis[node]=0;\\n    return ;\\n}\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        int vis[n];\\n        int pathvis[n];\\n        int siz[n];\\n        for(int i=0;i<n;i++){\\n            vis[i]=0;\\n            pathvis[i]=0;\\n            siz[i]=0;\\n        }\\n        for(int i=0;i<n;i++){\\n            count=0;\\n            if(vis[i]==0){\\n                dfs(i,edges,pathvis,vis,siz);\\n            }\\n        }\\n        if(mx==INT_MIN){\\n            return -1;\\n        }\\n        else{\\n            return mx;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint mx=INT_MIN;\\nint count=0;\\nvoid dfs(int node,vector<int>& edges,int pathvis[],int vis[],int siz[]){\\n    int nd=edges[node];\\n    vis[node]=1;\\n    pathvis[node]=1;\\n    if(nd==-1){\\n        pathvis[node]=0;\\n        siz[node]=0;\\n        return ;\\n    }\\n    count++;\\n    siz[node]=count;\\n    if(vis[nd]==0 ){\\n        dfs(nd,edges,pathvis,vis,siz);\\n    }\\n    else if(pathvis[nd]!=0){\\n        mx=max(mx,count-siz[nd]+1);\\n        return ;\\n    }\\n    pathvis[node]=0;\\n    return ;\\n}\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        int vis[n];\\n        int pathvis[n];\\n        int siz[n];\\n        for(int i=0;i<n;i++){\\n            vis[i]=0;\\n            pathvis[i]=0;\\n            siz[i]=0;\\n        }\\n        for(int i=0;i<n;i++){\\n            count=0;\\n            if(vis[i]==0){\\n                dfs(i,edges,pathvis,vis,siz);\\n            }\\n        }\\n        if(mx==INT_MIN){\\n            return -1;\\n        }\\n        else{\\n            return mx;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342563,
                "title": "python-3-kahn-s-algorithm",
                "content": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        indeg = Counter(edges)\\n\\n        stack = [node for node in range(n) if indeg[node] == 0]\\n        inCycle = {node for node in range(n)}\\n\\n        while stack:\\n            cur = stack.pop()\\n            inCycle.remove(cur)\\n\\n            nei = edges[cur]\\n            if nei == -1:\\n                continue\\n            indeg[nei] -= 1\\n            if indeg[nei] == 0:\\n                stack.append(nei)\\n\\n        def dfs(s):\\n            stack = [s]\\n            seen.add(s)\\n            res = 0\\n\\n            while stack:\\n                res += 1\\n                cur = stack.pop()\\n\\n                nei = edges[cur]\\n                if nei not in seen:\\n                    seen.add(nei)\\n                    stack.append(nei)\\n\\n            return res\\n\\n        seen = set()\\n        res = 0\\n\\n        for i in inCycle:\\n            if i not in seen:\\n                res = max(res, dfs(i))\\n\\n        return res if res else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        indeg = Counter(edges)\\n\\n        stack = [node for node in range(n) if indeg[node] == 0]\\n        inCycle = {node for node in range(n)}\\n\\n        while stack:\\n            cur = stack.pop()\\n            inCycle.remove(cur)\\n\\n            nei = edges[cur]\\n            if nei == -1:\\n                continue\\n            indeg[nei] -= 1\\n            if indeg[nei] == 0:\\n                stack.append(nei)\\n\\n        def dfs(s):\\n            stack = [s]\\n            seen.add(s)\\n            res = 0\\n\\n            while stack:\\n                res += 1\\n                cur = stack.pop()\\n\\n                nei = edges[cur]\\n                if nei not in seen:\\n                    seen.add(nei)\\n                    stack.append(nei)\\n\\n            return res\\n\\n        seen = set()\\n        res = 0\\n\\n        for i in inCycle:\\n            if i not in seen:\\n                res = max(res, dfs(i))\\n\\n        return res if res else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341772,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        def traverse(node, dist, nodes):\\n            if node in nodes:\\n                return dist - nodes[node]\\n            \\n            if seen[node]:\\n                return -1\\n            \\n            seen[node] = True\\n            if edges[node] != -1:\\n                nodes[node] = dist\\n                return traverse(edges[node], dist + 1, nodes)\\n            else:\\n                return -1\\n        \\n        seen = [False] * len(edges)\\n        result = -1\\n        for node in range(len(edges)):\\n            if not seen[node]:\\n                result = max(result, traverse(node, 0, {}))\\n                \\n        return result\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        def traverse(node, dist, nodes):\\n            if node in nodes:\\n                return dist - nodes[node]\\n            \\n            if seen[node]:\\n                return -1\\n            \\n            seen[node] = True\\n            if edges[node] != -1:\\n                nodes[node] = dist\\n                return traverse(edges[node], dist + 1, nodes)\\n            else:\\n                return -1\\n        \\n        seen = [False] * len(edges)\\n        result = -1\\n        for node in range(len(edges)):\\n            if not seen[node]:\\n                result = max(result, traverse(node, 0, {}))\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070407,
                "title": "c-dfs-solution-easy-to-understand",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    \\n    void dfs(int node, int &st, vector<int>adj[], vector<int> &visited, vector<int> &nodes, unordered_map<int,int> &whovisited){\\n        \\n        // Setting visited of node 1 as current node is visited...\\n        visited[node] = 1;\\n        \\n        // Mapping current node with the initial node through which we were able to reach here...\\n        whovisited[node] = st;\\n        \\n        for(auto it : adj[node]){\\n            if(!visited[it]){\\n                dfs(it,st,adj,visited,nodes,whovisited);\\n            }\\n            \\n            // If we have reached same node which is connected to the node from which we started our journey then it definitly forms a cycle therefore store it in nodes array...\\n            else if(whovisited[it] == st){\\n                nodes.push_back(it);\\n            }\\n        }\\n    }\\n    \\n    \\n    void countcycle(int node, vector<int>adj[], vector<int> &visited, int cnt, int &maxi){\\n        visited[node] = 1;\\n        \\n        \\n        for(auto it : adj[node]){\\n            if(!visited[it]){\\n                countcycle(it,adj,visited,cnt + 1, maxi);\\n            }\\n            else {\\n                maxi = max(cnt,maxi);\\n            }\\n        }\\n    }\\n    \\n    \\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        \\n        vector<int> adj[n];\\n        \\n        // Creating the adjacency list...\\n        \\n        for(int i  = 0 ; i < n ; i++){\\n            if(edges[i] >= 0)\\n                adj[i].push_back(edges[i]);\\n        }\\n        \\n        vector<int> nodes;\\n        \\n        unordered_map<int,int> whovisited;\\n        \\n        vector<int> visited(n,0);\\n        \\n        \\n        // Simple dfs to find each node with cycle...\\n        for(int i = 0 ; i < n ; i++){\\n            if(!visited[i]){\\n                dfs(i,i,adj,visited,nodes,whovisited);\\n            }\\n        }\\n        \\n        // Initializing answer variable with -1...\\n        int ans = -1;\\n        \\n        // checking the lengths of cycle...\\n        for(int i = 0 ; i < nodes.size(); i++){\\n            visited.assign(n,0);\\n            \\n            int cnt = -1;\\n            \\n            countcycle(nodes[i],adj,visited,1,cnt);\\n            \\n            ans = max(ans,cnt);\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(int node, int &st, vector<int>adj[], vector<int> &visited, vector<int> &nodes, unordered_map<int,int> &whovisited){\\n        \\n        // Setting visited of node 1 as current node is visited...\\n        visited[node] = 1;\\n        \\n        // Mapping current node with the initial node through which we were able to reach here...\\n        whovisited[node] = st;\\n        \\n        for(auto it : adj[node]){\\n            if(!visited[it]){\\n                dfs(it,st,adj,visited,nodes,whovisited);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2398819,
                "title": "c-strongly-connected-components-kosaraju-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        \\n        int n = edges.size(), mx = 0;\\n        vector<vector<int>> graph(n), reverse_graph(n);\\n        \\n        for(int i = 0; i < n; i++)\\n            if(edges[i] >= 0)\\n                graph[i].push_back(edges[i]), reverse_graph[edges[i]].push_back(i);   \\n\\n        stack<int> st;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < n; i++)\\n            if(!visited[i])\\n                dfs1(graph, st, i, visited);   \\n        \\n        for(int i = 0; i < n; i++)\\n            visited[i] = false;\\n              \\n        while(!st.empty())\\n        {\\n            int tmp = 0;\\n            if(!visited[st.top()])\\n                dfs2(reverse_graph, st.top(), visited, tmp), mx = max(mx, tmp);    \\n        \\n            st.pop();\\n        }\\n        \\n        return mx <= 1 ? -1 : mx;\\n    }\\n    \\n    void dfs1(vector<vector<int>> &graph, stack<int> &st, int i, vector<bool> &visited)\\n    {        \\n        visited[i] = true;\\n        for(auto &j : graph[i])\\n            if(!visited[j])\\n                dfs1(graph, st, j, visited);\\n        \\n        st.push(i);\\n    }\\n    \\n    void dfs2(vector<vector<int>> &graph, int i, vector<bool> &visited, int &tmp)\\n    {\\n        visited[i] = true, tmp++;\\n        for(auto &j : graph[i])\\n            if(!visited[j])\\n                dfs2(graph, j, visited, tmp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        \\n        int n = edges.size(), mx = 0;\\n        vector<vector<int>> graph(n), reverse_graph(n);\\n        \\n        for(int i = 0; i < n; i++)\\n            if(edges[i] >= 0)\\n                graph[i].push_back(edges[i]), reverse_graph[edges[i]].push_back(i);   \\n\\n        stack<int> st;\\n        vector<bool> visited(n, false);\\n        for(int i = 0; i < n; i++)\\n            if(!visited[i])\\n                dfs1(graph, st, i, visited);   \\n        \\n        for(int i = 0; i < n; i++)\\n            visited[i] = false;\\n              \\n        while(!st.empty())\\n        {\\n            int tmp = 0;\\n            if(!visited[st.top()])\\n                dfs2(reverse_graph, st.top(), visited, tmp), mx = max(mx, tmp);    \\n        \\n            st.pop();\\n        }\\n        \\n        return mx <= 1 ? -1 : mx;\\n    }\\n    \\n    void dfs1(vector<vector<int>> &graph, stack<int> &st, int i, vector<bool> &visited)\\n    {        \\n        visited[i] = true;\\n        for(auto &j : graph[i])\\n            if(!visited[j])\\n                dfs1(graph, st, j, visited);\\n        \\n        st.push(i);\\n    }\\n    \\n    void dfs2(vector<vector<int>> &graph, int i, vector<bool> &visited, int &tmp)\\n    {\\n        visited[i] = true, tmp++;\\n        for(auto &j : graph[i])\\n            if(!visited[j])\\n                dfs2(graph, j, visited, tmp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360164,
                "title": "c-solution-3-solution-dfs-and-topological-sort",
                "content": "**first solution using vis vector**\\n```\\nclass Solution {\\npublic:\\n    int yes;\\n    int n;\\n    vector<vector<int>>dp;\\n    vector<int>depth;\\n    vector<int>vis;\\n    int ans;\\n    void find(int x,int d)\\n    {\\n        depth[x]=d;\\n        vis[x]=1;\\n        for(auto &it:dp[x])\\n        {\\n            if(vis[it]==0)\\n            {\\n\\t\\t\\t//forward egde\\n                find(it,d+1);\\n            }\\n            else if(vis[it]==1)\\n            {\\n\\t\\t\\t// back edge\\n                yes=1;\\n                ans=max(ans,depth[x]-depth[it]+1);\\n            }\\n        }\\n\\t\\t// visited this path\\n        vis[x]=2; \\n    }\\n    int longestCycle(vector<int>&nums) \\n    {\\n        yes=0;\\n        n=nums.size();\\n        dp=vector<vector<int>>(n+1);\\n        depth=vector<int>(n+1,-1);\\n        vis=vector<int>(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=-1)\\n            {\\n                dp[i].push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                find(i,0);\\n            }\\n        }\\n        if(yes)\\n        {\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**second solution without vis vector**\\n*depth -1 showing not visited*\\n*0 path visited*\\n*1 to ... showing depth of the node*\\n```\\nclass Solution {\\npublic:\\n    int yes;\\n    int n;\\n    vector<int>dp[100005];\\n    vector<int>depth;\\n    int ans;\\n    void find(int x,int d)\\n    {\\n        if(depth[x]>0)\\n        {\\n            yes=1;\\n            ans=max(ans,d-depth[x]);\\n            return ;\\n        }\\n        if(depth[x]!=-1)\\n        {\\n            return ;\\n        }\\n        depth[x]=d;\\n        for(auto &it:dp[x])\\n        {\\n            find(it,d+1);\\n        }\\n        depth[x]=0;\\n    }\\n    int longestCycle(vector<int>&nums) \\n    {\\n        yes=0;\\n        n=nums.size();\\n        depth=vector<int>(n+1,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=-1)\\n            {\\n                dp[i].push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(depth[i]==-1)\\n            {\\n                find(i,1);\\n            }\\n        }\\n        if(yes)\\n        {\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**third solution topological sort** \\n```\\nclass Solution\\n{\\n    public:\\n        int longestCycle(vector<int> &nums)\\n        {\\n            int n = nums.size();\\n            int ind[n], vis[n];\\n            memset(ind, 0, sizeof(ind));\\n            memset(vis, 0, sizeof(vis));\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (nums[i] == -1)\\n                    continue;\\n                ind[nums[i]]++;\\n            }\\n            queue<int> q;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (ind[i] == 0)\\n                {\\n                    q.push(i);\\n                }\\n            }\\n            while (q.size())\\n            {\\n                auto temp = q.front();\\n                q.pop();\\n                vis[temp] = 1;\\n                int child = nums[temp];\\n                if (child == -1)\\n                {\\n                    continue;\\n                }\\n                if (--ind[child] == 0)\\n                {\\n                    q.push(child);\\n                }\\n            }\\n            int yes = 0;\\n            int ans = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (vis[i])\\n                {\\n                    continue;\\n                }\\n                int count = 0;\\n                int now = i;\\n                while (vis[now] == 0)\\n                {\\n                    yes = 1;\\n                    count++;\\n                    vis[now] = 1;\\n                    now = nums[now];\\n                }\\n                ans = max(ans, count);\\n            }\\n            if (yes == 0)\\n            {\\n                return -1;\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int yes;\\n    int n;\\n    vector<vector<int>>dp;\\n    vector<int>depth;\\n    vector<int>vis;\\n    int ans;\\n    void find(int x,int d)\\n    {\\n        depth[x]=d;\\n        vis[x]=1;\\n        for(auto &it:dp[x])\\n        {\\n            if(vis[it]==0)\\n            {\\n\\t\\t\\t//forward egde\\n                find(it,d+1);\\n            }\\n            else if(vis[it]==1)\\n            {\\n\\t\\t\\t// back edge\\n                yes=1;\\n                ans=max(ans,depth[x]-depth[it]+1);\\n            }\\n        }\\n\\t\\t// visited this path\\n        vis[x]=2; \\n    }\\n    int longestCycle(vector<int>&nums) \\n    {\\n        yes=0;\\n        n=nums.size();\\n        dp=vector<vector<int>>(n+1);\\n        depth=vector<int>(n+1,-1);\\n        vis=vector<int>(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=-1)\\n            {\\n                dp[i].push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                find(i,0);\\n            }\\n        }\\n        if(yes)\\n        {\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int yes;\\n    int n;\\n    vector<int>dp[100005];\\n    vector<int>depth;\\n    int ans;\\n    void find(int x,int d)\\n    {\\n        if(depth[x]>0)\\n        {\\n            yes=1;\\n            ans=max(ans,d-depth[x]);\\n            return ;\\n        }\\n        if(depth[x]!=-1)\\n        {\\n            return ;\\n        }\\n        depth[x]=d;\\n        for(auto &it:dp[x])\\n        {\\n            find(it,d+1);\\n        }\\n        depth[x]=0;\\n    }\\n    int longestCycle(vector<int>&nums) \\n    {\\n        yes=0;\\n        n=nums.size();\\n        depth=vector<int>(n+1,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=-1)\\n            {\\n                dp[i].push_back(nums[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(depth[i]==-1)\\n            {\\n                find(i,1);\\n            }\\n        }\\n        if(yes)\\n        {\\n            return ans;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    public:\\n        int longestCycle(vector<int> &nums)\\n        {\\n            int n = nums.size();\\n            int ind[n], vis[n];\\n            memset(ind, 0, sizeof(ind));\\n            memset(vis, 0, sizeof(vis));\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (nums[i] == -1)\\n                    continue;\\n                ind[nums[i]]++;\\n            }\\n            queue<int> q;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (ind[i] == 0)\\n                {\\n                    q.push(i);\\n                }\\n            }\\n            while (q.size())\\n            {\\n                auto temp = q.front();\\n                q.pop();\\n                vis[temp] = 1;\\n                int child = nums[temp];\\n                if (child == -1)\\n                {\\n                    continue;\\n                }\\n                if (--ind[child] == 0)\\n                {\\n                    q.push(child);\\n                }\\n            }\\n            int yes = 0;\\n            int ans = 0;\\n            for (int i = 0; i < n; i++)\\n            {\\n                if (vis[i])\\n                {\\n                    continue;\\n                }\\n                int count = 0;\\n                int now = i;\\n                while (vis[now] == 0)\\n                {\\n                    yes = 1;\\n                    count++;\\n                    vis[now] = 1;\\n                    now = nums[now];\\n                }\\n                ans = max(ans, count);\\n            }\\n            if (yes == 0)\\n            {\\n                return -1;\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358901,
                "title": "no-need-to-store-the-current-stack-of-edges",
                "content": "This idea is borrowed from CLRS (tree edge, back edge etc). We don\\'t need to check every node against the current node. All we need is to keep a global time counter, that is incremented every time a node is visited. For cycle check, we also need to remember the \"starting node\\'s time\". For every node, we encounter a node whose timestamp is not -1 , then we check if it\\'s less than the start_node\\'s timestamp , in that case we know it\\'s not part of the stack. Otherwise, we just subtract the difference in timestamps. I\\'ll try to draw some pictures if this explanation is not clear. \\n```\\nclass Solution {\\n    // Global time counter.\\n    int tm = 0;\\n    int res = -1;\\n    vector<int> vis;\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int len = edges.size();\\n        vis = vector<int>(len, -1);\\n        for (int i = 0; i < len;++i) {\\n            if (vis[i] == -1) dfs(i, tm, edges);\\n        }\\n        return res;\\n    }\\n    void dfs(int n, int start_time, const vector<int>& edges) {\\n        vis[n] = tm++;\\n        if (edges[n] == -1) return;\\n        int nei_time = vis[edges[n]];\\n        if (nei_time != -1) {\\n            if (nei_time < start_time) return;\\n            res = max(res, tm - nei_time);\\n        } else {\\n            dfs(edges[n], start_time, edges);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Global time counter.\\n    int tm = 0;\\n    int res = -1;\\n    vector<int> vis;\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int len = edges.size();\\n        vis = vector<int>(len, -1);\\n        for (int i = 0; i < len;++i) {\\n            if (vis[i] == -1) dfs(i, tm, edges);\\n        }\\n        return res;\\n    }\\n    void dfs(int n, int start_time, const vector<int>& edges) {\\n        vis[n] = tm++;\\n        if (edges[n] == -1) return;\\n        int nei_time = vis[edges[n]];\\n        if (nei_time != -1) {\\n            if (nei_time < start_time) return;\\n            res = max(res, tm - nei_time);\\n        } else {\\n            dfs(edges[n], start_time, edges);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414535,
                "title": "simple-kosaraju-s-algorithm-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDetect strongly connected component with size greater than 1 .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int> adj[],vector<int> &vis,stack<int> &st)\\n    {\\n        vis[node]=1;\\n        for(auto it:adj[node])\\n        {\\n            if(!vis[it])\\n            dfs(it,adj,vis,st);\\n        }\\n        st.push(node);\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        \\n        int v=edges.size();\\n        vector<int> adj[v];\\n        for(int i=0;i<v;i++)\\n        {\\n            if(edges[i]!=-1)\\n            adj[i].push_back(edges[i]);\\n        }\\n        // sort \\n        vector<int> vis(v,0);\\n        stack<int> st;\\n        for(int i=0;i<v;i++)\\n        {\\n          if(!vis[i])\\n          dfs(i,adj,vis,st);\\n        }\\n        // reverse\\n        vector<int> revadj[v];\\n        for(int i=0;i<v;i++)\\n        {   vis[i]=0;\\n            for(auto it:adj[i])\\n            revadj[it].push_back(i);\\n        }\\n        // dfs\\n        int cnt=0;\\n        \\n        while(!st.empty())\\n        {\\n            int node=st.top();\\n            st.pop();\\n            if(!vis[node])\\n            {   stack<int> s;\\n                dfs(node,revadj,vis,s);\\n                cnt=max(cnt,(int)s.size());\\n            }\\n        }\\n        if(cnt==1)\\n        return -1;\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int> adj[],vector<int> &vis,stack<int> &st)\\n    {\\n        vis[node]=1;\\n        for(auto it:adj[node])\\n        {\\n            if(!vis[it])\\n            dfs(it,adj,vis,st);\\n        }\\n        st.push(node);\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        \\n        int v=edges.size();\\n        vector<int> adj[v];\\n        for(int i=0;i<v;i++)\\n        {\\n            if(edges[i]!=-1)\\n            adj[i].push_back(edges[i]);\\n        }\\n        // sort \\n        vector<int> vis(v,0);\\n        stack<int> st;\\n        for(int i=0;i<v;i++)\\n        {\\n          if(!vis[i])\\n          dfs(i,adj,vis,st);\\n        }\\n        // reverse\\n        vector<int> revadj[v];\\n        for(int i=0;i<v;i++)\\n        {   vis[i]=0;\\n            for(auto it:adj[i])\\n            revadj[it].push_back(i);\\n        }\\n        // dfs\\n        int cnt=0;\\n        \\n        while(!st.empty())\\n        {\\n            int node=st.top();\\n            st.pop();\\n            if(!vis[node])\\n            {   stack<int> s;\\n                dfs(node,revadj,vis,s);\\n                cnt=max(cnt,(int)s.size());\\n            }\\n        }\\n        if(cnt==1)\\n        return -1;\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344711,
                "title": "day-361-detailed-explanation-space-optimized-100-0ms-dry-run-proof-o-1",
                "content": "![image.png](https://assets.leetcode.com/users/images/6b8c36c4-b344-4cb9-97d5-ce2399af8376_1679850164.7882621.png)\\nHello everyone, I wanted to share a detailed solution I came up with a solution for this problem on LeetCode. It took me a lot of time and effort to work through this problem, and I\\'m proud of what I\\'ve accomplished. However, I\\'m feeling a bit discouraged and would appreciate some encouragement to help me keep going.\\n# please upvote \\nI\\'ve included detailed explanations and code snippets in my solution, and I hope it can be helpful to others who are working on this problem. If you have any feedback or suggestions, I would love to hear them.\\n\\nThank you for taking the time to read my solution and for your support. It means a lot to me!\\n\\n# Here\\'s a detailed explanation of the code:\\n\\n##### \\u2022\\tInitialize variables: ans to -1: This variable will keep track of the length of the longest cycle found.\\n\\n##### \\u2022\\ttime to 1: This variable will be used to keep track of the time at which each node is visited.\\n\\n##### \\u2022\\ttimeVisited array to 0: This array will be used to keep track of the time at which each node is visited.\\n\\n##### \\u2022\\tFor each node i in the graph, check if it has been visited before. If it has, continue to the next node. Otherwise, set startTime to time and set u to i.\\n\\n##### \\u2022\\tWhile u is not equal to -1 (indicating that we have not reached the end of the cycle) and timeVisited[u] is equal to 0 (indicating that we have not visited this node before), do the following:\\n\\n##### \\u2022\\tSet timeVisited[u] to time, indicating that we have visited this node at time time.\\n\\n##### \\u2022\\tIncrement time.\\n\\n##### \\u2022\\tSet u to edges[u], indicating that we move to the next node in the cycle.\\n\\n##### \\u2022\\tIf u is not equal to -1 (indicating that we have found a cycle) and timeVisited[u] is greater than or equal to startTime (indicating that we have visited this node at or after the start time of the cycle), do the following:\\n\\n##### \\u2022\\tCalculate the length of the cycle as time - timeVisited[u].\\n\\n##### \\u2022\\tUpdate ans to the maximum of ans and the length of the cycle.\\n\\n##### \\u2022\\tRepeat steps 2-4 until all nodes have been visited.\\n\\n##### \\u2022\\tReturn the length of the longest cycle found (ans).\\n\\n##### \\u2022\\tOverall, this algorithm is based on the idea of using a time stamp to keep track of the time at which each node is visited. We iterate over each node in the graph and use the time stamp to detect cycles in the graph. The time complexity of this algorithm is O(N), where N is the number of nodes in the graph.\\n\\n\\n\\n\\n# Code\\n```java []\\npublic int longestCycle(int[] edges) {\\n    int maxCycleLength = -1;\\n    int currentTime = 1;\\n    int[] timeVisited = new int[edges.length];\\n\\n    for (int startNode = 0; startNode < edges.length; startNode++) {\\n        // Skip nodes that have already been visited\\n        if (timeVisited[startNode] > 0) {\\n            continue;\\n        }\\n        final int startTime = currentTime;\\n        int currentNode = startNode;\\n        // Perform a depth-first search to find a cycle\\n        while (currentNode != -1 && timeVisited[currentNode] == 0) {\\n            timeVisited[currentNode] = currentTime++;\\n            currentNode = edges[currentNode]; // Move to next node\\n        }\\n        // Check if a cycle has been found and if it\\'s longer than the current max cycle\\n        if (currentNode != -1 && timeVisited[currentNode] >= startTime) {\\n            int cycleLength = currentTime - timeVisited[currentNode];\\n            maxCycleLength = Math.max(maxCycleLength, cycleLength);\\n        }\\n    }\\n    return maxCycleLength;\\n}\\n```\\n```cpp []\\nint longestCycle(vector<int>& edges) { \\n    int maxCycleLength = -1;\\n    int currentTime = 1;\\n    vector<int> timeVisited(edges.size(), 0);\\n\\n    for (int startNode = 0; startNode < edges.size(); startNode++) {\\n        // Skip nodes that have already been visited\\n        if (timeVisited[startNode] > 0) {\\n            continue;\\n        }\\n        const int startTime = currentTime;\\n        int currentNode = startNode;\\n        // Perform a depth-first search to find a cycle\\n        while (currentNode != -1 && timeVisited[currentNode] == 0) {\\n            timeVisited[currentNode] = currentTime++;\\n            currentNode = edges[currentNode]; // Move to next node\\n        }\\n        // Check if a cycle has been found and if it\\'s longer than the current max cycle\\n        if (currentNode != -1 && timeVisited[currentNode] >= startTime) {\\n            int cycleLength = currentTime - timeVisited[currentNode];\\n            maxCycleLength = max(maxCycleLength, cycleLength);\\n        }\\n    }\\n    return maxCycleLength;\\n}\\n```\\n```python []\\ndef longestCycle(self, edges):\\n    maxCycleLength = -1\\n    currentTime = 1\\n    timeVisited = [0] * len(edges)\\n\\n    for startNode in range(len(edges)):\\n        # Skip nodes that have already been visited\\n        if timeVisited[startNode] > 0:\\n            continue\\n        startTime = currentTime\\n        currentNode = startNode\\n        # Perform a depth-first search to find a cycle\\n        while currentNode != -1 and timeVisited[currentNode] == 0:\\n            timeVisited[currentNode] = currentTime\\n            currentTime += 1\\n            currentNode = edges[currentNode] # Move to next node\\n        # Check if a cycle has been found and if it\\'s longer than the current max cycle\\n        if currentNode != -1 and timeVisited[currentNode] >= startTime:\\n            cycleLength = currentTime - timeVisited[currentNode]\\n            maxCycleLength = max(maxCycleLength, cycleLength)\\n\\n    return maxCycleLength\\n```\\n# Complexity\\n\\n##### \\u2022\\tThe time complexity of this algorithm is O(n), where n is the number of nodes in the graph. This is because the algorithm performs a depth-first search starting from each node in the graph, and each node is visited at most once.\\n##### \\u2022\\tThe space complexity of this algorithm is O(n), where n is the number of nodes in the graph. This is because the algorithm uses an array timeVisited  to keep track of the time when each node is visited, and the size of this array is equal to the number of nodes in the graph.\\n\\n\\n\\n# let\\'s dry run the given example:\\n\\nedges = [3, 3, 4, 2, 3]\\nInitialize variables:\\n\\nans = -1\\ntime = 1\\ntimeVisited = [0, 0, 0, 0, 0]\\nFor each node i in the graph, check if it has been visited before. If it has, continue to the next node. Otherwise, set startTime to time and set u to i.\\n\\ni = 0: timeVisited[0] = 0, so set startTime to time (= 1) and u to 0.\\ni = 1: timeVisited[1] = 0, so set startTime to time (= 2) and u to 1.\\ni = 2: timeVisited[2] = 0, so set startTime to time (= 3) and u to 2.\\ni = 3: timeVisited[3] = 0, so set startTime to time (= 4) and u to 3.\\ni = 4: timeVisited[4] = 0, so set startTime to time (= 5) and u to 4.\\nWhile u is not equal to -1 (indicating that we have not reached the end of the cycle) and timeVisited[u] is equal to 0 (indicating that we have not visited this node before), do the following:\\n\\nFor each node in the cycle, set timeVisited[u] to time, indicating that we have visited this node at time time. Increment time and set u to edges[u].\\n\\nu = 0: timeVisited[0] = 1, time = 2, u = 3.\\nu = 3: timeVisited[3] = 2, time = 3, u = 2.\\nu = 2: timeVisited[2] = 3, time = 4, u = 4.\\nu = 4: timeVisited[4] = 4, time = 5, u = 3.\\nIf u is not equal to -1\\n\\n# here\\'s a detailed dry run of the given code with the input edges = [3, 3, 4, 2, 3]:\\n\\nInitialize variables:\\n\\nans = -1\\ntime = 1\\ntimeVisited = [0, 0, 0, 0, 0]\\nFor each node i in the graph, check if it has been visited before. If it has, continue to the next node. Otherwise, set startTime to time and set u to i.\\n\\ni = 0: timeVisited[0] = 0, so set startTime to time (= 1) and u to 0.\\ni = 1: timeVisited[1] = 0, so set startTime to time (= 2) and u to 1.\\ni = 2: timeVisited[2] = 0, so set startTime to time (= 3) and u to 2.\\ni = 3: timeVisited[3] = 0, so set startTime to time (= 4) and u to 3.\\ni = 4: timeVisited[4] = 0, so set startTime to time (= 5) and u to 4.\\nWhile u is not equal to -1 (indicating that we have not reached the end of the cycle) and timeVisited[u] is equal to 0 (indicating that we have not visited this node before), do the following:\\n\\nFor each node in the cycle, set timeVisited[u] to time, indicating that we have visited this node at time time. Increment time and set u to edges[u].\\n\\nu = 0: timeVisited[0] = 1, time = 2, u = 3.\\nu = 3: `timeVisited\\nsolution here https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344711/detailed-explanation-100-0ms-dry-run-proof-meme-most-upvoted/?orderBy=most_votes\\n\\n# 2nd way space optimized o(1)\\n\\n# here is a step-by-step explanation of the code:\\n\\n##### \\u2022\\tInitialize variables max and steps to -1 and 2, respectively. max will keep track of the length of the longest cycle found so far, and steps will keep track of the number of steps in the path.\\n\\n##### \\u2022\\tIterate over each node in the graph using a for loop. For each node i, do the following:\\n\\n##### \\u2022\\tInitialize variables index, previousIndex, and startingSteps to i, i, and steps, respectively. index will keep track of the current node being visited, previousIndex will keep track of the previous node, and startingSteps will keep track of the number of steps at the start of the path.\\n\\n##### \\u2022\\tPerform a depth-first search to find a cycle. While the current node index has not been visited (i.e., edges[index] >= 0), do the following:\\n\\n##### \\u2022\\tUpdate previousIndex to index.\\n\\n##### \\u2022\\tUpdate index to the next node in the path using edges[index].\\n\\n##### \\u2022\\tMark previousIndex as visited by setting edges[previousIndex] to -steps.\\n\\n##### \\u2022\\tIncrement steps by 1.\\n\\n##### \\u2022\\tIf a cycle is found, check if the length of the cycle is longer than the current longest cycle max. If so, update max to the length of the cycle using the formula edges[index] - edges[previousIndex] + 1.\\n\\n##### \\u2022\\tReturn max as the length of the longest cycle found in the graph.\\n\\n##### \\u2022\\tThe idea behind the algorithm is to perform a depth-first search on each node in the graph to find a cycle, and then calculate the length of the cycle using the number of steps in the path. The negative values in the edges array are used to mark visited nodes and count the number of steps in the path. The algorithm runs in O(n) time, where n is the number of nodes in the graph.\\n\\n```java []\\npublic int longestCycle(int[] edges) {\\n    int maxCycleLength = -1;\\n    int steps = 2;\\n    for (int startNode = 0; startNode < edges.length; startNode++) {\\n        int currentIndex = startNode;\\n        int previousIndex = currentIndex;\\n        int startSteps = steps;\\n        // Perform a depth-first search to find a cycle\\n        while (edges[currentIndex] >= 0) {            \\n            previousIndex = currentIndex;\\n            currentIndex = edges[currentIndex]; \\n            edges[previousIndex] = -steps;                \\n            steps++;   \\n        }\\n        // Check if a cycle has been found and if it\\'s longer than the current max cycle\\n        if (edges[currentIndex] != -1 && startSteps <= -edges[currentIndex]) {\\n            int cycleLength = edges[currentIndex] - edges[previousIndex] + 1;\\n            maxCycleLength = Math.max(maxCycleLength, cycleLength);        \\n        }   \\n    }  \\n    return maxCycleLength;\\n}\\n```\\n```c++ []\\nint longestCycle(vector<int>& edges) {\\n    int maxCycleLength = -1;\\n    int steps = 2;\\n    for (int startNode = 0; startNode < edges.size(); startNode++) {\\n        int currentIndex = startNode;\\n        int previousIndex = currentIndex;\\n        int startSteps = steps;\\n        // Perform a depth-first search to find a cycle\\n        while (edges[currentIndex] >= 0) {            \\n            previousIndex = currentIndex;\\n            currentIndex = edges[currentIndex]; \\n            edges[previousIndex] = -steps;                \\n            steps++;   \\n        }\\n        // Check if a cycle has been found and if it\\'s longer than the current max cycle\\n        if (edges[currentIndex] != -1 && startSteps <= -edges[currentIndex]) {\\n            int cycleLength = edges[currentIndex] - edges[previousIndex] + 1;\\n            maxCycleLength = std::max(maxCycleLength, cycleLength);        \\n        }   \\n    }  \\n    return maxCycleLength;\\n}\\n```\\n```python []\\ndef longest_cycle(edges):\\n    max_cycle_length = -1\\n    steps = 2\\n    for start_node in range(len(edges)):\\n        current_node = start_node\\n        previous_node = current_node\\n        start_steps = steps\\n        while edges[current_node] >= 0:\\n            previous_node = current_node\\n            current_node = edges[current_node]\\n            edges[previous_node] = -steps\\n            steps += 1\\n        # Check if a cycle has been found\\n        if edges[current_node] != -1 and start_steps <= -edges[current_node]:\\n            cycle_length = edges[current_node] - edges[previous_node] + 1\\n            max_cycle_length = max(max_cycle_length, cycle_length)\\n    return max_cycle_length\\n```\\n# here\\'s a dry run of the algorithm using the input edges = [3, 3, 4, 2, 3]:\\n\\nInitialize max to -1 and steps to 2.\\n\\nIterate over each node in the graph using a for loop. For i = 0, do the following:\\n\\na. Initialize index, previousIndex, and startingSteps to 0, 0, and 2, respectively.\\n\\nb. Perform a depth-first search to find a cycle. Since edges[0] = 3, edges[3] = 2, edges[2] = 4, and edges[4] = 3, the path is 0 -> 3 -> 2 -> 4 -> 3, which forms a cycle.\\n\\ni. Update previousIndex to index (i.e., previousIndex = 0).\\n\\nii. Update index to the next node in the path using edges[index] (i.e., index = 3).\\n\\niii. Mark previousIndex as visited by setting edges[previousIndex] to -steps (i.e., edges[0] = -2).\\n\\niv. Increment steps by 1 (i.e., steps = 3).\\n\\ni. Update previousIndex to index (i.e., previousIndex = 3).\\n\\nii. Update index to the next node in the path using edges[index] (i.e., index = 2).\\n\\niii. Mark previousIndex as visited by setting edges[previousIndex] to -steps (i.e., edges[3] = -3).\\n\\niv. Increment steps by 1 (i.e., steps = 4).\\n\\ni. Update previousIndex to index (i.e., previousIndex = 2).\\n\\nii. Update index to the next node in the path using edges[index] (i.e., index = 4).\\n\\niii. Mark previousIndex as visited by setting edges[previousIndex] to -steps (i.e., edges[2] = -4).\\n\\niv. Increment steps by 1 (i.e., steps = 5).\\n\\ni. Update previousIndex to index (i.e., previousIndex = 4).\\n\\nii. Update index to the next node in the path using edges[index] (i.e., index = 3).\\n\\niii. Mark previousIndex as visited by setting edges[previousIndex] to -steps (i.e., edges[4] = -5).\\n\\niv. Increment steps by 1 (i.e., steps = 6).\\n\\nc. Since a cycle is found, check if the length of the cycle\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![meme2.png](https://assets.leetcode.com/users/images/bd7be3ad-512e-4cb7-88d1-e093329ae59d_1679849869.253788.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java []\\npublic int longestCycle(int[] edges) {\\n    int maxCycleLength = -1;\\n    int currentTime = 1;\\n    int[] timeVisited = new int[edges.length];\\n\\n    for (int startNode = 0; startNode < edges.length; startNode++) {\\n        // Skip nodes that have already been visited\\n        if (timeVisited[startNode] > 0) {\\n            continue;\\n        }\\n        final int startTime = currentTime;\\n        int currentNode = startNode;\\n        // Perform a depth-first search to find a cycle\\n        while (currentNode != -1 && timeVisited[currentNode] == 0) {\\n            timeVisited[currentNode] = currentTime++;\\n            currentNode = edges[currentNode]; // Move to next node\\n        }\\n        // Check if a cycle has been found and if it\\'s longer than the current max cycle\\n        if (currentNode != -1 && timeVisited[currentNode] >= startTime) {\\n            int cycleLength = currentTime - timeVisited[currentNode];\\n            maxCycleLength = Math.max(maxCycleLength, cycleLength);\\n        }\\n    }\\n    return maxCycleLength;\\n}\\n```\n```cpp []\\nint longestCycle(vector<int>& edges) { \\n    int maxCycleLength = -1;\\n    int currentTime = 1;\\n    vector<int> timeVisited(edges.size(), 0);\\n\\n    for (int startNode = 0; startNode < edges.size(); startNode++) {\\n        // Skip nodes that have already been visited\\n        if (timeVisited[startNode] > 0) {\\n            continue;\\n        }\\n        const int startTime = currentTime;\\n        int currentNode = startNode;\\n        // Perform a depth-first search to find a cycle\\n        while (currentNode != -1 && timeVisited[currentNode] == 0) {\\n            timeVisited[currentNode] = currentTime++;\\n            currentNode = edges[currentNode]; // Move to next node\\n        }\\n        // Check if a cycle has been found and if it\\'s longer than the current max cycle\\n        if (currentNode != -1 && timeVisited[currentNode] >= startTime) {\\n            int cycleLength = currentTime - timeVisited[currentNode];\\n            maxCycleLength = max(maxCycleLength, cycleLength);\\n        }\\n    }\\n    return maxCycleLength;\\n}\\n```\n```python []\\ndef longestCycle(self, edges):\\n    maxCycleLength = -1\\n    currentTime = 1\\n    timeVisited = [0] * len(edges)\\n\\n    for startNode in range(len(edges)):\\n        # Skip nodes that have already been visited\\n        if timeVisited[startNode] > 0:\\n            continue\\n        startTime = currentTime\\n        currentNode = startNode\\n        # Perform a depth-first search to find a cycle\\n        while currentNode != -1 and timeVisited[currentNode] == 0:\\n            timeVisited[currentNode] = currentTime\\n            currentTime += 1\\n            currentNode = edges[currentNode] # Move to next node\\n        # Check if a cycle has been found and if it\\'s longer than the current max cycle\\n        if currentNode != -1 and timeVisited[currentNode] >= startTime:\\n            cycleLength = currentTime - timeVisited[currentNode]\\n            maxCycleLength = max(maxCycleLength, cycleLength)\\n\\n    return maxCycleLength\\n```\n```java []\\npublic int longestCycle(int[] edges) {\\n    int maxCycleLength = -1;\\n    int steps = 2;\\n    for (int startNode = 0; startNode < edges.length; startNode++) {\\n        int currentIndex = startNode;\\n        int previousIndex = currentIndex;\\n        int startSteps = steps;\\n        // Perform a depth-first search to find a cycle\\n        while (edges[currentIndex] >= 0) {            \\n            previousIndex = currentIndex;\\n            currentIndex = edges[currentIndex]; \\n            edges[previousIndex] = -steps;                \\n            steps++;   \\n        }\\n        // Check if a cycle has been found and if it\\'s longer than the current max cycle\\n        if (edges[currentIndex] != -1 && startSteps <= -edges[currentIndex]) {\\n            int cycleLength = edges[currentIndex] - edges[previousIndex] + 1;\\n            maxCycleLength = Math.max(maxCycleLength, cycleLength);        \\n        }   \\n    }  \\n    return maxCycleLength;\\n}\\n```\n```c++ []\\nint longestCycle(vector<int>& edges) {\\n    int maxCycleLength = -1;\\n    int steps = 2;\\n    for (int startNode = 0; startNode < edges.size(); startNode++) {\\n        int currentIndex = startNode;\\n        int previousIndex = currentIndex;\\n        int startSteps = steps;\\n        // Perform a depth-first search to find a cycle\\n        while (edges[currentIndex] >= 0) {            \\n            previousIndex = currentIndex;\\n            currentIndex = edges[currentIndex]; \\n            edges[previousIndex] = -steps;                \\n            steps++;   \\n        }\\n        // Check if a cycle has been found and if it\\'s longer than the current max cycle\\n        if (edges[currentIndex] != -1 && startSteps <= -edges[currentIndex]) {\\n            int cycleLength = edges[currentIndex] - edges[previousIndex] + 1;\\n            maxCycleLength = std::max(maxCycleLength, cycleLength);        \\n        }   \\n    }  \\n    return maxCycleLength;\\n}\\n```\n```python []\\ndef longest_cycle(edges):\\n    max_cycle_length = -1\\n    steps = 2\\n    for start_node in range(len(edges)):\\n        current_node = start_node\\n        previous_node = current_node\\n        start_steps = steps\\n        while edges[current_node] >= 0:\\n            previous_node = current_node\\n            current_node = edges[current_node]\\n            edges[previous_node] = -steps\\n            steps += 1\\n        # Check if a cycle has been found\\n        if edges[current_node] != -1 and start_steps <= -edges[current_node]:\\n            cycle_length = edges[current_node] - edges[previous_node] + 1\\n            max_cycle_length = max(max_cycle_length, cycle_length)\\n    return max_cycle_length\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3344160,
                "title": "c-easiest-way-solved-solution-well-explained-approach-inution-tc-sc-gauravthinks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The calculation works by navigating the diagram and keeping a record of the time at which every hub is first visited during the crossing. Assuming that a cycle is found that incorporates the ongoing hub, we can compute its length utilizing the time at which the hub was first visited during the crossing.\\n- The moment we encounter a already touched node, we calculate the distance by simply subtracting the distances of current and the node which we are about revisit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The issue expects us to find the length of the longest cycle in a given coordinated chart addressed as a rundown of edges. We can take care of this issue utilizing a changed profundity first hunt (DFS) calculation.\\n- We start by emphasizing through every hub in the chart. For each unvisited hub, we play out a DFS to navigate the chart and recognize any cycles that incorporate the ongoing hub. We keep an exhibit to store the time at which every hub was first visited during the DFS crossing. Assuming a cycle is found that incorporates the ongoing hub, we compute its length as the distinction between the ongoing time step and the time step at which the hub was first visited during the crossing.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nEvery node is visited only once througout thus,\\n#  O(N) time is taken \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n here*** I used adjacency list which could have been avoided thus total space complexity comes to be: \\n#  O(N)+O(N) ~ O(N) space is taken\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nvoid dfs(vector<int> adj[], vector<int> &vis, int &node, int &res, unordered_map<int, int> &naksha){\\nvis[node]= true;\\nfor(auto it: adj[node]){\\n    if(it!=-1 and vis[it]==0){\\n    naksha[it]= naksha[node]+1; // incrementing the distance after reaching the next node\\n    dfs(adj, vis, it, res, naksha);\\n    }\\n    else if(it!=-1 and naksha.count(it) ){\\n        res= max(res, naksha[node]- naksha[it]+1);\\n    }\\n}\\n}\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n= edges.size();\\n        // directed graph adjacency list\\n        vector<int> adj[n];\\n        for( int i=0; i<n; i++){\\n            adj[i].push_back(edges[i]);\\n        }\\n        vector<int> vis(n, false);\\n        int res=-1;\\n        for(int i=0;i<n; i++){\\n            if(!vis[i]){\\n                unordered_map<int, int> naksha;\\n                naksha[i]= 1; // storing the distance of first node as 1\\n                dfs(adj, vis, i, res, naksha);\\n            }\\n        }\\n       \\n       return res;\\n    }\\n};\\n```\\nIf you liked the solution and explanation, then do Upvote the solution and subscribe to our YouTube Channel down below.\\n\\n# @GauravThinks <----- youtube channel",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nvoid dfs(vector<int> adj[], vector<int> &vis, int &node, int &res, unordered_map<int, int> &naksha){\\nvis[node]= true;\\nfor(auto it: adj[node]){\\n    if(it!=-1 and vis[it]==0){\\n    naksha[it]= naksha[node]+1; // incrementing the distance after reaching the next node\\n    dfs(adj, vis, it, res, naksha);\\n    }\\n    else if(it!=-1 and naksha.count(it) ){\\n        res= max(res, naksha[node]- naksha[it]+1);\\n    }\\n}\\n}\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n= edges.size();\\n        // directed graph adjacency list\\n        vector<int> adj[n];\\n        for( int i=0; i<n; i++){\\n            adj[i].push_back(edges[i]);\\n        }\\n        vector<int> vis(n, false);\\n        int res=-1;\\n        for(int i=0;i<n; i++){\\n            if(!vis[i]){\\n                unordered_map<int, int> naksha;\\n                naksha[i]= 1; // storing the distance of first node as 1\\n                dfs(adj, vis, i, res, naksha);\\n            }\\n        }\\n       \\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341773,
                "title": "c-topological-sort-bfs-and-cycle-detection-technique-dfs-easy-explanation",
                "content": "# Intuition\\nWe just need to detect all cycles and store the maximum size of the cycle detected among all. \\n\\n# Approach\\nWe will use Topological Sort using Kahn\\'s Algorithm (BFS) . In this we start from Nodes which have Indegree equals to zero and traverse along the next node from present Node if Indegree of Next Node becomes 0.\\n\\nWhen we come out of the loop we will be left with nodes which do not have Indegree 0 and all these nodes will be part of Cycles . Now we will just detect the cycle and count its size and store the desired result .\\n\\nI hope you liked my explanation and code . Ypur Upvote will be appreciated .\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    vector<bool> vis, dfsvis;\\n    int n , ans = -1;\\n\\n    void dfs(int node , vector<int> &edges){\\n        //Mark visited current Node \\n        vis[node] = 1;\\n        //Mark path/dfs visited current Node \\n        dfsvis[node] = 1;\\n\\n        //Next Node\\n        int next = edges[node];\\n        if(next == -1 )\\n        dfsvis[node] = 0;\\n        else if(!vis[next])\\n        dfs(next, edges);\\n        else if(dfsvis[node])\\n        {\\n            int cnt = 0;\\n\\n            for(int i = 0 ; i<n ; i++)\\n            if(dfsvis[i]) cnt++;\\n\\n            ans = max(ans, cnt);\\n        }\\n\\n        dfsvis[node] = 0;\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        // Number Of Nodes\\n        n = edges.size();\\n        vis = vector<bool> (n, 0); \\n        dfsvis = vector<bool> (n, 0); \\n        vector<int> inDegree(n, 0);\\n\\n        //Calculate Indegree of Each Node \\n        for(int i = 0 ; i<n ; i++)\\n        if(edges[i] != -1) inDegree[edges[i]]++;\\n        \\n        queue<int> q;\\n\\n        // Push the Nodes into q having Indegree as 0 and mark them visited\\n        for(int i = 0 ; i<n ; i++){\\n        if(inDegree[i] == 0) {\\n            q.push(i) ; \\n            vis[i] = 1;\\n            }\\n        }\\n\\n        // Topological Sort Using Kahn\\'s Algo \\n        while(!q.empty())\\n        {\\n            // Current Node\\n            int node = q.front();\\n            q.pop();\\n            // Next Node\\n            int next = edges[node];\\n            \\n            if(next != -1)\\n            {\\n              // Check If Next Node Indegree became 0 or not \\n              // If yes Then Go to Next Node i.e. Mark it Visited \\n                if(--inDegree[next] == 0)\\n                {\\n                    q.push(next) ; \\n                     vis[next] = 1;\\n                }\\n            }\\n        }\\n\\n        // Cycle Detection Technique\\n       for(int i = 0; i <n  ; i++)\\n       {\\n           if(!vis[i] )\\n              dfs(i, edges);\\n       }\\n       \\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    vector<bool> vis, dfsvis;\\n    int n , ans = -1;\\n\\n    void dfs(int node , vector<int> &edges){\\n        //Mark visited current Node \\n        vis[node] = 1;\\n        //Mark path/dfs visited current Node \\n        dfsvis[node] = 1;\\n\\n        //Next Node\\n        int next = edges[node];\\n        if(next == -1 )\\n        dfsvis[node] = 0;\\n        else if(!vis[next])\\n        dfs(next, edges);\\n        else if(dfsvis[node])\\n        {\\n            int cnt = 0;\\n\\n            for(int i = 0 ; i<n ; i++)\\n            if(dfsvis[i]) cnt++;\\n\\n            ans = max(ans, cnt);\\n        }\\n\\n        dfsvis[node] = 0;\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        // Number Of Nodes\\n        n = edges.size();\\n        vis = vector<bool> (n, 0); \\n        dfsvis = vector<bool> (n, 0); \\n        vector<int> inDegree(n, 0);\\n\\n        //Calculate Indegree of Each Node \\n        for(int i = 0 ; i<n ; i++)\\n        if(edges[i] != -1) inDegree[edges[i]]++;\\n        \\n        queue<int> q;\\n\\n        // Push the Nodes into q having Indegree as 0 and mark them visited\\n        for(int i = 0 ; i<n ; i++){\\n        if(inDegree[i] == 0) {\\n            q.push(i) ; \\n            vis[i] = 1;\\n            }\\n        }\\n\\n        // Topological Sort Using Kahn\\'s Algo \\n        while(!q.empty())\\n        {\\n            // Current Node\\n            int node = q.front();\\n            q.pop();\\n            // Next Node\\n            int next = edges[node];\\n            \\n            if(next != -1)\\n            {\\n              // Check If Next Node Indegree became 0 or not \\n              // If yes Then Go to Next Node i.e. Mark it Visited \\n                if(--inDegree[next] == 0)\\n                {\\n                    q.push(next) ; \\n                     vis[next] = 1;\\n                }\\n            }\\n        }\\n\\n        // Cycle Detection Technique\\n       for(int i = 0; i <n  ; i++)\\n       {\\n           if(!vis[i] )\\n              dfs(i, edges);\\n       }\\n       \\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096872,
                "title": "c-simple-dfs-algorithm-detailed-explanation-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe graph given to us is a directed graph with the constraint that there is atmost one outgoing edge. This automatically proves that in one component atmost one cycle can be present.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The array hsh is used to find the length of the cycle if it exists. It tells us about the number of nodes that exist in between the two nodes.\\n2. The array vis is used to find whether the node has been previously visited.\\n3. The array pathvis is used to find out that if the node has been visited previously then was it visited in the same path or was it visited during a different traversal.\\n\\nIf the node has been visited previously,\\n1. If it lies in the same path then it implies that a cycle exists and then the cycle length is maximised. \\n2. On the contrary if the node was not visited in the same path then it implies that the traversal on the node before this must have yielded the answer if it existed hence we need not traverse it again.\\n\\n# Complexity\\n- Time complexity:O(n)\\n- All the nodes are visited at max once, hence the complexity acheived is O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Including the input 4 arrays of size n have been used.\\n- So the space complexity is O(4n) which is equivalent to O(n);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        int vis[n],hsh[n],ans=-1,pathvis[n];\\n        for(int i = 0; i < n; i++)\\n            hsh[i]=vis[i]=pathvis[i]=0;\\n        for(int k = 0;k<n;k++)\\n        {\\n            if(!vis[k])\\n            {\\n                int ct = 1,j=-1,i=k;\\n                while(edges[i]!=-1 && !vis[i])\\n                {\\n                    pathvis[i]=k+1;\\n                    hsh[i]=ct;\\n                    ++ct;\\n                    vis[i]=1;\\n                    j=i;\\n                    i=edges[i];\\n                }\\n                if(edges[i]!=-1)\\n                {\\n                    if(pathvis[i]==pathvis[j])\\n                    {\\n                        int y = abs(hsh[j]-hsh[i])+1;\\n                        ans=max(ans,y);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        int vis[n],hsh[n],ans=-1,pathvis[n];\\n        for(int i = 0; i < n; i++)\\n            hsh[i]=vis[i]=pathvis[i]=0;\\n        for(int k = 0;k<n;k++)\\n        {\\n            if(!vis[k])\\n            {\\n                int ct = 1,j=-1,i=k;\\n                while(edges[i]!=-1 && !vis[i])\\n                {\\n                    pathvis[i]=k+1;\\n                    hsh[i]=ct;\\n                    ++ct;\\n                    vis[i]=1;\\n                    j=i;\\n                    i=edges[i];\\n                }\\n                if(edges[i]!=-1)\\n                {\\n                    if(pathvis[i]==pathvis[j])\\n                    {\\n                        int y = abs(hsh[j]-hsh[i])+1;\\n                        ans=max(ans,y);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919141,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> parent, g[100005];\\n    int ans, color[100005];\\n    void dfs(int u) {\\n        color[u] = 1;\\n        for(auto v: g[u]) {\\n            if(color[v] == 0) {\\n                parent.push_back(v);\\n                dfs(v);\\n                parent.pop_back();\\n            }\\n            else if(color[v] == 1) {\\n                int fl = 0, cnt = 0;\\n                for(auto x: parent) {\\n                    if(x == v) fl = 1;\\n                    if(fl) cnt++; \\n                }\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        color[u] = 2;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        for(int i=0; i<edges.size(); i++) {\\n            if(edges[i] != -1) g[i].push_back(edges[i]);\\n        }\\n        ans = -1;\\n        for(int u=0; u < edges.size(); u++) {\\n            if(color[u] == 0) {\\n                parent.push_back(u);\\n                dfs(u);\\n                parent.pop_back();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent, g[100005];\\n    int ans, color[100005];\\n    void dfs(int u) {\\n        color[u] = 1;\\n        for(auto v: g[u]) {\\n            if(color[v] == 0) {\\n                parent.push_back(v);\\n                dfs(v);\\n                parent.pop_back();\\n            }\\n            else if(color[v] == 1) {\\n                int fl = 0, cnt = 0;\\n                for(auto x: parent) {\\n                    if(x == v) fl = 1;\\n                    if(fl) cnt++; \\n                }\\n                ans = max(ans, cnt);\\n            }\\n        }\\n        color[u] = 2;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        for(int i=0; i<edges.size(); i++) {\\n            if(edges[i] != -1) g[i].push_back(edges[i]);\\n        }\\n        ans = -1;\\n        for(int u=0; u < edges.size(); u++) {\\n            if(color[u] == 0) {\\n                parent.push_back(u);\\n                dfs(u);\\n                parent.pop_back();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853116,
                "title": "simple-iterative-solution-short-c",
                "content": "# Intuition\\nThe key idea is that there is only one outgoing edge from each node. So, once we start on a path from a starting node, we\\'ll either terminate with a node pointing to -1 or enter a cycle. We can calculate length of each cycle and just return the maximum later.\\n\\n# Approach\\nWhen we find a node that we have already seen, we need to consider two things:\\n1. Did we see this node on `this` traversal or some older traversal?\\n2. If we saw this node earlier on `this` traversal, how many nodes did we see before this?\\n\\nEncountering this node only counts as a cycle if we indeed saw it earlier on the same traversal. Cycle length can be obtained by keeping track of how many nodes we saw earlier on this path. \\n\\n$$CycleLength = LengthSoFar - LengthAtRepeatedNode$$\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        // Pair(Traversal, Length)\\n        vector<pair<int, int>> took(edges.size());\\n        int ans = -1;\\n        for (int node = 0; node < edges.size(); ++node) {\\n            int len = 1, cur = node;\\n            while (cur != -1 && took[cur].second == 0) {\\n                took[cur] = make_pair(node, len++);\\n                cur = edges[cur];\\n            } \\n            if (cur != -1 && took[cur].first == node) {\\n                ans = max(ans, len - took[cur].second);\\n            }\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        // Pair(Traversal, Length)\\n        vector<pair<int, int>> took(edges.size());\\n        int ans = -1;\\n        for (int node = 0; node < edges.size(); ++node) {\\n            int len = 1, cur = node;\\n            while (cur != -1 && took[cur].second == 0) {\\n                took[cur] = make_pair(node, len++);\\n                cur = edges[cur];\\n            } \\n            if (cur != -1 && took[cur].first == node) {\\n                ans = max(ans, len - took[cur].second);\\n            }\\n        }\\n        return ans;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358046,
                "title": "dfs-map-c",
                "content": "The key thing to notice is that there is atmost one outgoing edge. Hence, a node can contribute to atmost one cycle.\\n\\nAfter that the implementation is quite simple, we just dfs over unvisited nodes storing the distances. When an already traversed node is encountered in this partiular dfs, a cycle is present and we update our cycle length if it exceeds the present answer.\\n\\n\\'\\'\\'\\n    \\n    int ans = -1;\\n    void dfs(vector<vector<int>> &graph, vector<int> &v, int crt, int dd, map<int,int> &mp){\\n        v[crt] = 1;\\n        mp[crt] = dd;\\n        for(auto x:graph[crt]){\\n            if(!v[x])dfs(graph, v, x, dd+1, mp);\\n            else if(mp.count(x)) ans = max(ans, dd-mp[x]+1);\\n        }\\n    }\\n    \\n    int longestCycle(vector<int>& e) {\\n        vector<vector<int>> graph(e.size());\\n        for(int i = 0; i<e.size(); i++){\\n            if(e[i]!=-1){\\n                graph[i].push_back(e[i]);\\n            }\\n        }\\n        vector<int> visited(e.size(),0);\\n        for(int i = 0; i<e.size(); i++){\\n            if(!visited[i]){\\n                map<int,int> mp;\\n                dfs(graph, visited, i, 0, mp);\\n            }\\n        }\\n        return ans;\\n\\t\\t}\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "The key thing to notice is that there is atmost one outgoing edge. Hence, a node can contribute to atmost one cycle.\\n\\nAfter that the implementation is quite simple, we just dfs over unvisited nodes storing the distances. When an already traversed node is encountered in this partiular dfs, a cycle is present and we update our cycle length if it exceeds the present answer.\\n\\n\\'\\'\\'\\n    \\n    int ans = -1;\\n    void dfs(vector<vector<int>> &graph, vector<int> &v, int crt, int dd, map<int,int> &mp){\\n        v[crt] = 1;\\n        mp[crt] = dd;\\n        for(auto x:graph[crt]){\\n            if(!v[x])dfs(graph, v, x, dd+1, mp);\\n            else if(mp.count(x)) ans = max(ans, dd-mp[x]+1);\\n        }\\n    }\\n    \\n    int longestCycle(vector<int>& e) {\\n        vector<vector<int>> graph(e.size());\\n        for(int i = 0; i<e.size(); i++){\\n            if(e[i]!=-1){\\n                graph[i].push_back(e[i]);\\n            }\\n        }\\n        vector<int> visited(e.size(),0);\\n        for(int i = 0; i<e.size(); i++){\\n            if(!visited[i]){\\n                map<int,int> mp;\\n                dfs(graph, visited, i, 0, mp);\\n            }\\n        }\\n        return ans;\\n\\t\\t}\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 3344447,
                "title": "simple-toposort-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& edges, vector<bool>& dfsvis, int &count){        \\n        dfsvis[node] = true;\\n        count++;\\n        if(!dfsvis[edges[node]]){\\n            dfs(edges[node],edges,dfsvis,count); \\n        }\\n        return;\\n    }\\n    void getindegree(vector<int> &in,vector<int> &edges){\\n        for(int i = 0; i < edges.size(); i++){\\n            if(edges[i] != -1){\\n                in[edges[i]]++;\\n            }\\n        }\\n    }\\n    void toposort(queue<int> &qu,vector<int> &edges,vector<bool> &vis,vector<int> &in){\\n        while(!qu.empty()){\\n            int node = qu.front(); \\n            qu.pop();\\n            vis[node] = true;\\n            if(edges[node] != -1){\\n                if(--in[edges[node]] == 0) \\n                    qu.push(edges[node]);\\n            }\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> indegree(n);\\n        getindegree(indegree,edges);        \\n        queue<int> qu;\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0) qu.push(i);\\n        }\\n        vector<bool> vis(n,false);\\n        toposort(qu,edges,vis,indegree);\\n        bool flag = false;\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == false) {\\n                flag = true; \\n                break;\\n            }\\n        }\\n        //if flag is still false, that\\'s mean there is no cycle\\n        if(flag == false) return -1;        \\n        vector<bool> dfsvis(n,false);\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            //if vis then that node is not a part of cycle\\n            if(vis[i]) continue;\\n            int count = 0;\\n            dfs(i,edges,dfsvis,count);\\n            ans = max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& edges, vector<bool>& dfsvis, int &count){        \\n        dfsvis[node] = true;\\n        count++;\\n        if(!dfsvis[edges[node]]){\\n            dfs(edges[node],edges,dfsvis,count); \\n        }\\n        return;\\n    }\\n    void getindegree(vector<int> &in,vector<int> &edges){\\n        for(int i = 0; i < edges.size(); i++){\\n            if(edges[i] != -1){\\n                in[edges[i]]++;\\n            }\\n        }\\n    }\\n    void toposort(queue<int> &qu,vector<int> &edges,vector<bool> &vis,vector<int> &in){\\n        while(!qu.empty()){\\n            int node = qu.front(); \\n            qu.pop();\\n            vis[node] = true;\\n            if(edges[node] != -1){\\n                if(--in[edges[node]] == 0) \\n                    qu.push(edges[node]);\\n            }\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> indegree(n);\\n        getindegree(indegree,edges);        \\n        queue<int> qu;\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0) qu.push(i);\\n        }\\n        vector<bool> vis(n,false);\\n        toposort(qu,edges,vis,indegree);\\n        bool flag = false;\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == false) {\\n                flag = true; \\n                break;\\n            }\\n        }\\n        //if flag is still false, that\\'s mean there is no cycle\\n        if(flag == false) return -1;        \\n        vector<bool> dfsvis(n,false);\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            //if vis then that node is not a part of cycle\\n            if(vis[i]) continue;\\n            int count = 0;\\n            dfs(i,edges,dfsvis,count);\\n            ans = max(ans,count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344162,
                "title": "c-simple-dfs-cycle-detection-code-simplest-code-of-all-time",
                "content": "# Intuition\\n*Just slight extention of detect cycle in directed graph with dfsvis and vis vector.*\\n\\n*We saved dfsvis every time with 1 but this time we will save with index from 1*\\n\\n*like for example ->*\\n\\n![graph4drawio-5.png](https://assets.leetcode.com/users/images/1fb21edb-f93e-4517-98fe-f8f65180d0bd_1679839529.2482247.png)\\n\\n*We will start from (0)--> so vis[0]=1 and dfsvis[0]=1 next (3)-->vis[3]=1 and dfsvis[3]=2 then (2)--> vis[2]=1 and dfsvis[2]=3*\\n\\n\\n*The value of dfsvis of a node indicates its index in stack ...\\nif in future we get back to the node again then we will get the size by (new dfsvis value-old dfsvis value) . Then we will calculate the max* \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int ans=-1;\\n    void dfs(int node,vector<int>& edges,vector<int>& vis,vector<int>& dfsvis,int i)\\n    {\\n        vis[node]=1;\\n        dfsvis[node]=i;\\n        int next=edges[node];\\n        if(next!=-1)\\n        {\\n\\n            if(vis[next]==0)\\n            {\\n                dfs(next,edges,vis,dfsvis,i+1);\\n            }\\n            else if(dfsvis[next]!=0)\\n            {\\n                ans=max(ans,i+1-dfsvis[next]);\\n            }\\n        }\\n\\n        dfsvis[node]=0;\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> vis(n,0);\\n        vector<int> dfsvis(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n           if(vis[i]==0)\\n           {\\n                dfs(i,edges,vis,dfsvis,1);\\n           }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int ans=-1;\\n    void dfs(int node,vector<int>& edges,vector<int>& vis,vector<int>& dfsvis,int i)\\n    {\\n        vis[node]=1;\\n        dfsvis[node]=i;\\n        int next=edges[node];\\n        if(next!=-1)\\n        {\\n\\n            if(vis[next]==0)\\n            {\\n                dfs(next,edges,vis,dfsvis,i+1);\\n            }\\n            else if(dfsvis[next]!=0)\\n            {\\n                ans=max(ans,i+1-dfsvis[next]);\\n            }\\n        }\\n\\n        dfsvis[node]=0;\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> vis(n,0);\\n        vector<int> dfsvis(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n           if(vis[i]==0)\\n           {\\n                dfs(i,edges,vis,dfsvis,1);\\n           }\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343820,
                "title": "java-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     \\n    public int longestCycle(int[] edges) {\\n        return new CycleFinder(edges).maxCycle();\\n    }\\n}\\n\\nclass CycleFinder {\\n\\n    private final boolean[] marked, onStack;\\n    private final int[] edges, dist;\\n    private int maxCycle = -1;\\n\\n    CycleFinder(int[] edges) {\\n        this.edges = edges;\\n        this.marked = new boolean[edges.length];\\n        this.onStack = new boolean[edges.length];\\n        this.dist = new int[edges.length];\\n\\n        // start from each unmarked vertex\\n        for (int v = 0; v < edges.length; ++v) {\\n            if (!marked[v]) {\\n                dist[v] = 1;\\n                dfs(v);\\n            }\\n        }\\n    }\\n    \\n    private void dfs(int v) {\\n        marked[v] = true;\\n        \\n        if (edges[v] == -1) \\n            return;\\n\\n        onStack[v] = true;\\n\\n        if (!marked[edges[v]]) {\\n            dist[edges[v]] = dist[v] + 1;\\n            dfs(edges[v]);\\n        } else if (onStack[edges[v]]) {\\n            maxCycle = Integer.max((dist[v] - dist[edges[v]] + 1), maxCycle);\\n        }\\n        \\n        onStack[v] = false;\\n    }\\n\\n    public int maxCycle() {\\n        return maxCycle;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     \\n    public int longestCycle(int[] edges) {\\n        return new CycleFinder(edges).maxCycle();\\n    }\\n}\\n\\nclass CycleFinder {\\n\\n    private final boolean[] marked, onStack;\\n    private final int[] edges, dist;\\n    private int maxCycle = -1;\\n\\n    CycleFinder(int[] edges) {\\n        this.edges = edges;\\n        this.marked = new boolean[edges.length];\\n        this.onStack = new boolean[edges.length];\\n        this.dist = new int[edges.length];\\n\\n        // start from each unmarked vertex\\n        for (int v = 0; v < edges.length; ++v) {\\n            if (!marked[v]) {\\n                dist[v] = 1;\\n                dfs(v);\\n            }\\n        }\\n    }\\n    \\n    private void dfs(int v) {\\n        marked[v] = true;\\n        \\n        if (edges[v] == -1) \\n            return;\\n\\n        onStack[v] = true;\\n\\n        if (!marked[edges[v]]) {\\n            dist[edges[v]] = dist[v] + 1;\\n            dfs(edges[v]);\\n        } else if (onStack[edges[v]]) {\\n            maxCycle = Integer.max((dist[v] - dist[edges[v]] + 1), maxCycle);\\n        }\\n        \\n        onStack[v] = false;\\n    }\\n\\n    public int maxCycle() {\\n        return maxCycle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343689,
                "title": "simple-topological-sort-and-bfs-based-solution-in-python-logic-made-code-easy",
                "content": "# Intuition\\nTo return the length of the longest cycle in the graph.\\n**(note - The graph may be disconnected)**\\n# Approach\\n**step1** Trim the tree with 0 indegree iteratively(topological sort)\\n(now the graph will become collection of cycles)\\n**step2** Find the longest cycle in the disconnected graph using bfs\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n![images.jpg](https://assets.leetcode.com/users/images/2239d77c-dcef-49fc-acbb-92741d6ad563_1679831695.6123643.jpeg)\\n# Code\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        ans = -1\\n\\n        indegree = [0 for _ in range(n)]\\n\\n        #store indegree of all nodes\\n        for u in range(len(edges)):\\n            if edges[u] == -1:\\n                continue\\n            indegree[edges[u]] += 1\\n        \\n        #trime nodes with 0 indegree (topological sort)\\n        for u in range(n):\\n            while indegree[u] == 0 and edges[u] != -1:\\n                v = edges[u]\\n                edges[u] = -1\\n                indegree[v] -= 1\\n                u = v\\n\\n        visited = set()\\n\\n        #find the longest cycle amoung all cycles\\n        for u in range(n):\\n            if indegree[u] == 0 or u in visited:\\n                continue\\n            dis = 1\\n            visited.add(u)\\n\\n            # bfs to find length\\n            while edges[u] not in visited:\\n                v = edges[u]\\n                dis += 1\\n                u = v\\n\\n            ans = max(ans, dis)\\n        return ans\\n\\n            \\n\\n        \\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        ans = -1\\n\\n        indegree = [0 for _ in range(n)]\\n\\n        #store indegree of all nodes\\n        for u in range(len(edges)):\\n            if edges[u] == -1:\\n                continue\\n            indegree[edges[u]] += 1\\n        \\n        #trime nodes with 0 indegree (topological sort)\\n        for u in range(n):\\n            while indegree[u] == 0 and edges[u] != -1:\\n                v = edges[u]\\n                edges[u] = -1\\n                indegree[v] -= 1\\n                u = v\\n\\n        visited = set()\\n\\n        #find the longest cycle amoung all cycles\\n        for u in range(n):\\n            if indegree[u] == 0 or u in visited:\\n                continue\\n            dis = 1\\n            visited.add(u)\\n\\n            # bfs to find length\\n            while edges[u] not in visited:\\n                v = edges[u]\\n                dis += 1\\n                u = v\\n\\n            ans = max(ans, dis)\\n        return ans\\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342107,
                "title": "easy-to-understand-solution-floyd-s-cycle-finding-algo",
                "content": "```\\npublic int longestCycle(int[] edges) {\\n    int n = edges.length;\\n    int longest = -1;\\n    boolean[] visited = new boolean[n]; // keep track of nodes visited\\n    int[] memo = new int[n]; // memoization array to store previously computed cycle lengths\\n    \\n    for (int start = 0; start < n; start++) {\\n        if (!visited[start]) { // if node hasn\\'t been visited yet\\n            int slow = start, fast = start;\\n            while (edges[fast] != -1 && edges[edges[fast]] != -1) { // loop until a cycle is found or a dead end is reached\\n                slow = edges[slow];\\n                fast = edges[edges[fast]];\\n                if (slow == fast) { // if a cycle is found\\n                    int cycleLen = 1;\\n                    slow = edges[slow];\\n                    while (slow != fast) { // compute the length of the cycle\\n                        cycleLen++;\\n                        slow = edges[slow];\\n                    }\\n                    longest = Math.max(longest, cycleLen); // update longest cycle length if necessary\\n                    memo[start] = cycleLen; // memoize cycle length for future use\\n                    visited[start] = true; // mark node as visited\\n                    break;\\n                }\\n                if (memo[slow] != 0) { // if we\\'ve already computed the cycle length for this node\\n                    memo[start] = memo[slow]; // memoize previously computed cycle length\\n                    visited[start] = true; // mark node as visited\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return longest;\\n}\\n\\n```\\n# UpVoting is Much Appreciated",
                "solutionTags": [
                    "Java",
                    "Memoization"
                ],
                "code": "```\\npublic int longestCycle(int[] edges) {\\n    int n = edges.length;\\n    int longest = -1;\\n    boolean[] visited = new boolean[n]; // keep track of nodes visited\\n    int[] memo = new int[n]; // memoization array to store previously computed cycle lengths\\n    \\n    for (int start = 0; start < n; start++) {\\n        if (!visited[start]) { // if node hasn\\'t been visited yet\\n            int slow = start, fast = start;\\n            while (edges[fast] != -1 && edges[edges[fast]] != -1) { // loop until a cycle is found or a dead end is reached\\n                slow = edges[slow];\\n                fast = edges[edges[fast]];\\n                if (slow == fast) { // if a cycle is found\\n                    int cycleLen = 1;\\n                    slow = edges[slow];\\n                    while (slow != fast) { // compute the length of the cycle\\n                        cycleLen++;\\n                        slow = edges[slow];\\n                    }\\n                    longest = Math.max(longest, cycleLen); // update longest cycle length if necessary\\n                    memo[start] = cycleLen; // memoize cycle length for future use\\n                    visited[start] = true; // mark node as visited\\n                    break;\\n                }\\n                if (memo[slow] != 0) { // if we\\'ve already computed the cycle length for this node\\n                    memo[start] = memo[slow]; // memoize previously computed cycle length\\n                    visited[start] = true; // mark node as visited\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return longest;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341786,
                "title": "java-dfs-using-iteration-beats-62-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int longestCycle(int[] edges) {\\n    var n = edges.length;\\n    var seen = new boolean[n];\\n    var ans = -1;\\n\\n    for (var i=0; i<n; i++) {\\n      if (!seen[i]) {\\n        var j = i;\\n        var k = 0;\\n        var map = new HashMap<Integer, Integer>();\\n\\n        for (; j != -1 && !seen[j]; j = edges[j]) {\\n          seen[j] = true;\\n          map.put(j, k++);\\n        }\\n        if (map.containsKey(j))\\n          ans = Math.max(ans, k - map.get(j));\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n  public int longestCycle(int[] edges) {\\n    var n = edges.length;\\n    var seen = new boolean[n];\\n    var ans = -1;\\n\\n    for (var i=0; i<n; i++) {\\n      if (!seen[i]) {\\n        var j = i;\\n        var k = 0;\\n        var map = new HashMap<Integer, Integer>();\\n\\n        for (; j != -1 && !seen[j]; j = edges[j]) {\\n          seen[j] = true;\\n          map.put(j, k++);\\n        }\\n        if (map.containsKey(j))\\n          ans = Math.max(ans, k - map.get(j));\\n      }\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341712,
                "title": "c-dfs-with-memoization",
                "content": "# Approach\\nFrom each node use DFS to calculate distance to each node we reach.\\nIf we found a node with distance `!= -1` - we find a cycle. The length of that cycle is the current distance minus the distance to that node.\\nTo check if we reached the node during the current DFS cycle, we strore the starting node (`startIndex`) and compare current node (`i`) with it.\\nUse memoization to avoid calculting distances multiple times.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int LongestCycle(int[] edges)\\n    {\\n        var result = -1;\\n        var memo = new List<(int, int)>(Enumerable.Repeat((-1, -1), edges.Length));\\n\\n        for (var i = 0; i < edges.Length; ++i)\\n        {\\n            var currentDistance = 0;\\n            \\n            for (var j = i; j != -1; j = edges[j])\\n            {\\n                var (distance, startIndex) = memo[j];\\n                if (distance == -1)\\n                {\\n                    memo[j] = (currentDistance++, i);\\n                }\\n                else\\n                {\\n                    if (startIndex == i)\\n                    {\\n                        // Found cycle => record the result\\n                        result = Math.Max(result, currentDistance - distance);\\n                    }\\n\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int LongestCycle(int[] edges)\\n    {\\n        var result = -1;\\n        var memo = new List<(int, int)>(Enumerable.Repeat((-1, -1), edges.Length));\\n\\n        for (var i = 0; i < edges.Length; ++i)\\n        {\\n            var currentDistance = 0;\\n            \\n            for (var j = i; j != -1; j = edges[j])\\n            {\\n                var (distance, startIndex) = memo[j];\\n                if (distance == -1)\\n                {\\n                    memo[j] = (currentDistance++, i);\\n                }\\n                else\\n                {\\n                    if (startIndex == i)\\n                    {\\n                        // Found cycle => record the result\\n                        result = Math.Max(result, currentDistance - distance);\\n                    }\\n\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399858,
                "title": "c-o-n-time-and-space-topological-sorting-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int m = edges.size();\\n        vector<int> visited(m, 0);\\n        vector<int> indegree(m, 0);\\n        \\n        // find out indegree for nodes\\n        for(int i=0;i<m;i++)\\n        {\\n            int node = edges[i];\\n            if(node != -1) indegree[node]++;\\n        }\\n        \\n        // remove \"linked list\" starting from 0-indegree nodes\\n        // using topological sort\\n        queue<int> q;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            \\n            if(visited[node]) continue;\\n            visited[node] = 1;\\n            \\n            int nei = edges[node];\\n            if(nei != -1)\\n            {\\n                indegree[nei]--;\\n                if(indegree[nei] == 0)\\n                    q.push(nei);\\n            }\\n        }\\n        \\n        // if after topological sort\\n        // no node left then no cycle exist\\n        int count = 0;\\n        for(int i=0;i<m;i++)\\n            if(visited[i]) count++;\\n        \\n        if(count == m) return -1;\\n        \\n        // Otherwise, all left over nodes are in cycles\\n        // find the longest one.\\n        int ans = INT_MIN;\\n        for(int i=0;i<m;i++)\\n        {\\n            int len = 0;\\n            if(!visited[i])\\n            {\\n                len++;\\n                visited[i] = 1;\\n                int nei = edges[i];\\n                while(nei != -1 && !visited[nei])\\n                {\\n                    len++;\\n                    visited[nei] = 1;\\n                    nei = edges[nei];\\n                }\\n            }\\n            ans = max(ans, len);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int m = edges.size();\\n        vector<int> visited(m, 0);\\n        vector<int> indegree(m, 0);\\n        \\n        // find out indegree for nodes\\n        for(int i=0;i<m;i++)\\n        {\\n            int node = edges[i];\\n            if(node != -1) indegree[node]++;\\n        }\\n        \\n        // remove \"linked list\" starting from 0-indegree nodes\\n        // using topological sort\\n        queue<int> q;\\n        for(int i=0;i<m;i++)\\n        {\\n            if(indegree[i] == 0)\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int node = q.front();\\n            q.pop();\\n            \\n            if(visited[node]) continue;\\n            visited[node] = 1;\\n            \\n            int nei = edges[node];\\n            if(nei != -1)\\n            {\\n                indegree[nei]--;\\n                if(indegree[nei] == 0)\\n                    q.push(nei);\\n            }\\n        }\\n        \\n        // if after topological sort\\n        // no node left then no cycle exist\\n        int count = 0;\\n        for(int i=0;i<m;i++)\\n            if(visited[i]) count++;\\n        \\n        if(count == m) return -1;\\n        \\n        // Otherwise, all left over nodes are in cycles\\n        // find the longest one.\\n        int ans = INT_MIN;\\n        for(int i=0;i<m;i++)\\n        {\\n            int len = 0;\\n            if(!visited[i])\\n            {\\n                len++;\\n                visited[i] = 1;\\n                int nei = edges[i];\\n                while(nei != -1 && !visited[nei])\\n                {\\n                    len++;\\n                    visited[nei] = 1;\\n                    nei = edges[nei];\\n                }\\n            }\\n            ans = max(ans, len);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360079,
                "title": "o-n-python-solution-beats-100",
                "content": "Intuition:\\nThere will always be the same cycle when encountering a node, the cycle won\\'t change no matter from which node in the cycle you enter from.\\nSo we could just have a hashset that contains all the nodes we encountered and when the nodes we encounter are in the hashset we could just stop the loop early.\\n\\nHow I coded it:\\nWhen encountering an element, store it in a hashmap with the value being the distance travelled when you first encountered it, when you encounter than node again, set the result to be the distance between them if such distance is more than max.\\nStore all the nodes seen before in a hashset whilst traversing. \\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        res, seenSet = -1, set()\\n        for element in range(len(edges)): #traverses all possible nodes\\n            count, currNode = 0, element\\n            cycleMap = dict() #tabulates all distances\\n            while currNode not in seenSet and currNode != -1:\\n                count += 1\\n                seenSet.add(currNode); cycleMap[currNode] = count #adds nodes to the hashmap and the hashset\\n                currNode = edges[currNode] #moves on to the next node\\n            res = max(res, count + 1 - cycleMap.get(currNode, 200000)) #gets the max distance \\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/4796842e-f5a9-4574-95e8-08e5a91972bf_1659272024.346057.jpeg)\\n",
                "solutionTags": [
                    "Python3",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        res, seenSet = -1, set()\\n        for element in range(len(edges)): #traverses all possible nodes\\n            count, currNode = 0, element\\n            cycleMap = dict() #tabulates all distances\\n            while currNode not in seenSet and currNode != -1:\\n                count += 1\\n                seenSet.add(currNode); cycleMap[currNode] = count #adds nodes to the hashmap and the hashset\\n                currNode = edges[currNode] #moves on to the next node\\n            res = max(res, count + 1 - cycleMap.get(currNode, 200000)) #gets the max distance \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360056,
                "title": "python-3-recursion-memomization",
                "content": "Please upvote if you liked it.\\n**Intitution**\\n1. We have used the technique for detecting cycle in directed graph by keeping a stack . If we find a cyle we store that length in our DP array so that we dont count that cyle again.\\n2. Also we have stored the nodes in Seen dictionory along with distance as keys , so that if we find once again that node , we can easily find length of Cycle.\\n\\n\\n```\\nclass Solution:\\n    \\n    def recursive(self,i,edges,seen,count,ans,stack,dp):\\n        if dp[i] != -1:\\n            return dp[i]\\n        if edges[i]== -1:\\n            \\n            return\\n        if edges[i] in seen.keys() and edges[i] in stack.keys():\\n            dp[i] = count+1-seen[edges[i]]\\n            if ans[0]<count+1-seen[edges[i]]:\\n                \\n                ans[0] = count+1-seen[edges[i]]\\n            return\\n        \\n        seen[i] = count\\n        stack[i] = True\\n        dp[i] = self.recursive(edges[i],edges,seen,count+1,ans,stack,dp)\\n        stack.popitem()\\n    \\n    \\n    def longestCycle(self, edges: List[int]) -> int:\\n        ans = [-1]\\n        seen = {}\\n        stack = {}\\n        dp = [-1 for i in range(len(edges))]\\n        for i in range(len(edges)):\\n            if i not in seen.keys():\\n                self.recursive(i,edges,seen,0,ans,stack,dp)\\n        \\n        \\n        print(dp)\\n        if ans[0]==0:\\n            return -1\\n        return ans[0]      \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def recursive(self,i,edges,seen,count,ans,stack,dp):\\n        if dp[i] != -1:\\n            return dp[i]\\n        if edges[i]== -1:\\n            \\n            return\\n        if edges[i] in seen.keys() and edges[i] in stack.keys():\\n            dp[i] = count+1-seen[edges[i]]\\n            if ans[0]<count+1-seen[edges[i]]:\\n                \\n                ans[0] = count+1-seen[edges[i]]\\n            return\\n        \\n        seen[i] = count\\n        stack[i] = True\\n        dp[i] = self.recursive(edges[i],edges,seen,count+1,ans,stack,dp)\\n        stack.popitem()\\n    \\n    \\n    def longestCycle(self, edges: List[int]) -> int:\\n        ans = [-1]\\n        seen = {}\\n        stack = {}\\n        dp = [-1 for i in range(len(edges))]\\n        for i in range(len(edges)):\\n            if i not in seen.keys():\\n                self.recursive(i,edges,seen,0,ans,stack,dp)\\n        \\n        \\n        print(dp)\\n        if ans[0]==0:\\n            return -1\\n        return ans[0]      \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360026,
                "title": "python-backedge-check-dfs",
                "content": "We will perform a DFS and have a set of `visited` and `ancestors`.\\n\\n`Ancestors` will help us to check if there is a backedge. \\n\\nWhenever we find a neighbor that is in the `ancestors` hashmap, we know it\\'s a cycle.\\n\\nWe will also save an `incrementing id` to know the distance we traveled to get to that cycle. The difference between the current id and the ancestors[neighbor] id is the cycle length.\\n\\n```\\nclass Solution:\\n    ans = float(\\'-inf\\')\\n    \\n    def longestCycle(self, edges: List[int]) -> int:\\n        ancestors = {}\\n        visited = set()\\n    \\n        def dfs(node, increasing_id):\\n            neighbor = edges[node]\\n            if neighbor == -1:\\n                return\\n            \\n            if neighbor in ancestors:\\n                self.ans = max(self.ans, increasing_id - ancestors[neighbor])\\n            \\n            if neighbor in visited:\\n                return\\n            \\n            visited.add(neighbor)\\n            \\n            ancestors[neighbor] = increasing_id\\n            dfs(neighbor, increasing_id + 1)\\n            ancestors.pop(neighbor)\\n            \\n        n = len(edges)\\n        for node in range(n):\\n            if node == -1: continue\\n            if node in visited: continue\\n            \\n            visited.add(node)\\n            ancestors[node] = 0 \\n            dfs(node, 1)\\n            ancestors.pop(node)\\n            \\n        return self.ans if self.ans != float(\\'-inf\\') else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    ans = float(\\'-inf\\')\\n    \\n    def longestCycle(self, edges: List[int]) -> int:\\n        ancestors = {}\\n        visited = set()\\n    \\n        def dfs(node, increasing_id):\\n            neighbor = edges[node]\\n            if neighbor == -1:\\n                return\\n            \\n            if neighbor in ancestors:\\n                self.ans = max(self.ans, increasing_id - ancestors[neighbor])\\n            \\n            if neighbor in visited:\\n                return\\n            \\n            visited.add(neighbor)\\n            \\n            ancestors[neighbor] = increasing_id\\n            dfs(neighbor, increasing_id + 1)\\n            ancestors.pop(neighbor)\\n            \\n        n = len(edges)\\n        for node in range(n):\\n            if node == -1: continue\\n            if node in visited: continue\\n            \\n            visited.add(node)\\n            ancestors[node] = 0 \\n            dfs(node, 1)\\n            ancestors.pop(node)\\n            \\n        return self.ans if self.ans != float(\\'-inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360022,
                "title": "longest-cycle-in-a-graph",
                "content": "```\\nclass Solution {\\n    int max=-1;\\n    public int longestCycle(int[] edges) {\\n        boolean vis[]=new boolean[edges.length];\\n       \\n        for(int i:edges)\\n        {  if(i==-1||vis[i]) continue;\\n           HashMap<Integer,Integer> map=new HashMap<>();\\n           dfs(i,0,vis,map,edges);\\n        }\\n        return max;\\n    }\\n    public void dfs(int node,int dis,boolean[]vis, HashMap<Integer,Integer> map,int []edges)\\n    {\\n        if(node==-1) return ;\\n        if(vis[node])\\n        {   \\n            if(!map.containsKey(node)) return ;\\n            max=Math.max(dis-map.get(node),max);\\n            //System.out.println(max);\\n            return ;\\n        }\\n        vis[node]=true;\\n        map.put(node,dis);\\n        dfs(edges[node],dis+1,vis,map,edges);\\n        return ;\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int max=-1;\\n    public int longestCycle(int[] edges) {\\n        boolean vis[]=new boolean[edges.length];\\n       \\n        for(int i:edges)\\n        {  if(i==-1||vis[i]) continue;\\n           HashMap<Integer,Integer> map=new HashMap<>();\\n           dfs(i,0,vis,map,edges);\\n        }\\n        return max;\\n    }\\n    public void dfs(int node,int dis,boolean[]vis, HashMap<Integer,Integer> map,int []edges)\\n    {\\n        if(node==-1) return ;\\n        if(vis[node])\\n        {   \\n            if(!map.containsKey(node)) return ;\\n            max=Math.max(dis-map.get(node),max);\\n            //System.out.println(max);\\n            return ;\\n        }\\n        vis[node]=true;\\n        map.put(node,dis);\\n        dfs(edges[node],dis+1,vis,map,edges);\\n        return ;\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358241,
                "title": "simple-dfs-traversal-track-order-of-node-in-cycle",
                "content": "This question would have been tougher in case they have not given the condition : \"every node can have atmost 1 outgoing edge\"\\n\\nOur aim is to find longest cycle length. \\n\\nIt is quite intuitive that we will definitely use DFS for anything related to cycle-finding. But now the question is how to find length of cycle.\\n\\nTo find length of cycle (also in 1 single iteration of all nodes), we will have to keep track of traversed nodes in order --> For this we will use number[] array to store order of each traversed node. \\n\\nEverything else is just cycle finding algorithm using DFS in directed graph.\\nWe have used 3 arrays here: visited[] --> to store already traversed nodes | dfsVisit[] --> to store nodes that get traversed in current traversal | number[] --> to store count of node in current traversal\\n\\nclass Solution {\\npublic:\\n    \\n    int maxCount = -1;\\n    int count = 0;\\n    \\n    int DFS(vector<vector<int>>& adj, vector<int>& visited, vector<int>& dfsVisit, int cur, int parent, vector<int>& number)\\n    {\\n        visited[cur] = 1;\\n        dfsVisit[cur] = 1;\\n        count++;\\n        number[cur] = count;\\n        \\n        for(int x : adj[cur])\\n        {\\n            if(!visited[x])\\n            {\\n                int value = DFS(adj, visited, dfsVisit, x, cur, number);\\n                dfsVisit[cur] = 0;\\n                return value;\\n            }\\n                \\n            else if(dfsVisit[x])\\n            {\\n\\t\\t\\t\\t// cycle is detected --> get the length of cycle\\n                dfsVisit[x] = 0;\\n                return number[cur] - number[x] + 1;    \\n            }\\n                \\n        }\\n        \\n        dfsVisit[cur] = 0;\\n        return 0;\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n\\t\\t// convert into \"adjcency list\" graph format for my ease :)\\n        vector<vector<int>> adj(n);\\n        vector<int> visited(n, 0);\\n        vector<int> dfsVisit(n, 0);\\n        vector<int> number(n, 0);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(edges[i] != -1)\\n                adj[i].push_back(edges[i]);\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(!visited[i])\\n            {\\n                maxCount = max(maxCount, DFS(adj, visited, dfsVisit, i, -1, number));\\n\\t\\t\\t\\t// reseting count variable for next iteration of unvisited node\\n\\t\\t\\t\\tcount = 0;\\n            }\\n        }\\n        \\n        return (maxCount == 0) ? -1 : maxCount;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int maxCount = -1;\\n    int count = 0;\\n    \\n    int DFS(vector<vector<int>>& adj, vector<int>& visited, vector<int>& dfsVisit, int cur, int parent, vector<int>& number)\\n    {\\n        visited[cur] = 1;\\n        dfsVisit[cur] = 1;\\n        count++;\\n        number[cur] = count;\\n        \\n        for(int x : adj[cur])\\n        {\\n            if(!visited[x])\\n            {\\n                int value = DFS(adj, visited, dfsVisit, x, cur, number);\\n                dfsVisit[cur] = 0;\\n                return value;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2357726,
                "title": "c-o-n-topological-sort-find-longest-cycle",
                "content": "1. Do topological sort - to remove \"tails\". After it is done - we\\'ll have only \"cycles\" in our graph.\\n2. For each node (which belongs to some cycle, and which wasn\\'t visited yet) find the length of its cycle. Mark visited nodes. If the node is already visited - skip it, because this cycle was already handled.\\n\\nTime complexity: `O(N)` - we visit every node once in topological sort + once when counting cycle length\\nSpace complexity: `O(N)` - we use auxilary arrays of size N\\n\\n```cpp\\n    int longestCycle(vector<int>& edges) {\\n        const int n = edges.size();\\n        vector<int> inCount(n);\\n        vector<int> outgoing(n, -1);\\n        for (int i = 0; i < n; ++i) {\\n            outgoing[i] = edges[i];\\n            if (edges[i] != -1) {\\n                ++inCount[edges[i]];\\n            }\\n        }\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            if (inCount[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int cur = q.front();\\n            q.pop();\\n            if (outgoing[cur] != -1) {\\n                int v = outgoing[cur];\\n                --inCount[v];\\n                if (inCount[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        \\n        vector<bool> visited(n);\\n        int result = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (inCount[i] == 0 || visited[i]) continue;\\n            \\n            visited[i] = true;\\n            \\n            int cur = outgoing[i];\\n            int cycleLength = 1;\\n            while (cur != i) {\\n                visited[cur] = true;\\n                cur = outgoing[cur];\\n                ++cycleLength;\\n            }\\n            result = max(result, cycleLength);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```cpp\\n    int longestCycle(vector<int>& edges) {\\n        const int n = edges.size();\\n        vector<int> inCount(n);\\n        vector<int> outgoing(n, -1);\\n        for (int i = 0; i < n; ++i) {\\n            outgoing[i] = edges[i];\\n            if (edges[i] != -1) {\\n                ++inCount[edges[i]];\\n            }\\n        }\\n        queue<int> q;\\n        for (int i = 0; i < n; ++i) {\\n            if (inCount[i] == 0) {\\n                q.push(i);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int cur = q.front();\\n            q.pop();\\n            if (outgoing[cur] != -1) {\\n                int v = outgoing[cur];\\n                --inCount[v];\\n                if (inCount[v] == 0) {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        \\n        vector<bool> visited(n);\\n        int result = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (inCount[i] == 0 || visited[i]) continue;\\n            \\n            visited[i] = true;\\n            \\n            int cur = outgoing[i];\\n            int cycleLength = 1;\\n            while (cur != i) {\\n                visited[cur] = true;\\n                cur = outgoing[cur];\\n                ++cycleLength;\\n            }\\n            result = max(result, cycleLength);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3344952,
                "title": "simple-c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nImp points:\\n\\nWe use cycle detection algorithm and counted the nodes in the cycle using their discovery times.\\n\\nAlso we did recStack[adjNode]==0 while backtracking to reuse the same array for multiple calls.\\n\\n# Complexity\\n- Time complexity:\\n O(V+E) ,we did dfs\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool detectCycle(vector<int> &edges,vector<int>&vis,vector<int>&recStack,int src,\\n       int& counter,int &timer){\\n       if(edges[src]==-1) return false;\\n        vis[src]=1;\\n        recStack[src]=timer;\\n        timer++;\\n        int adjNode=edges[src];\\n            if(!vis[adjNode] && detectCycle(edges,vis,recStack,adjNode,counter\\n            ,timer)==true){\\n                recStack[adjNode]=0;\\n                return true;\\n            }\\n\\n               else if(recStack[adjNode]!=0){\\n                   counter=timer-recStack[adjNode];\\n                   recStack[adjNode]=0;\\n                   return true;\\n               }\\n\\n        recStack[src]=0;\\n        return false;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int nodes=edges.size(),res=-1;\\n        vector<int>recStack(nodes,0);\\n        vector<int> vis(nodes,0);\\n\\n        for(int i=0;i<nodes;i++){\\n            if(vis[i]==0) {\\n                int counter=-1;\\n                int timer=1;\\n                bool isCycle=detectCycle(edges,vis,recStack,i,counter,timer);\\n                if(isCycle==true)\\n                res=max(res,counter);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool detectCycle(vector<int> &edges,vector<int>&vis,vector<int>&recStack,int src,\\n       int& counter,int &timer){\\n       if(edges[src]==-1) return false;\\n        vis[src]=1;\\n        recStack[src]=timer;\\n        timer++;\\n        int adjNode=edges[src];\\n            if(!vis[adjNode] && detectCycle(edges,vis,recStack,adjNode,counter\\n            ,timer)==true){\\n                recStack[adjNode]=0;\\n                return true;\\n            }\\n\\n               else if(recStack[adjNode]!=0){\\n                   counter=timer-recStack[adjNode];\\n                   recStack[adjNode]=0;\\n                   return true;\\n               }\\n\\n        recStack[src]=0;\\n        return false;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int nodes=edges.size(),res=-1;\\n        vector<int>recStack(nodes,0);\\n        vector<int> vis(nodes,0);\\n\\n        for(int i=0;i<nodes;i++){\\n            if(vis[i]==0) {\\n                int counter=-1;\\n                int timer=1;\\n                bool isCycle=detectCycle(edges,vis,recStack,i,counter,timer);\\n                if(isCycle==true)\\n                res=max(res,counter);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344291,
                "title": "java-dfs-discovery-time-100-fast-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to keep track of the discovery time of visited node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to keep track of the discovery time of visited node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\n    int result = -1;\\n\\tvoid getCycle(int node, int graph[], int[] discover, int time, int[] vis) {\\n        vis[node] = 1;\\n        if(graph[node] != -1 && discover[graph[node]] != 0){\\n            int prev = discover[graph[node]];\\n            int diff = time - prev + 1;\\n            if(diff > result)\\n                result = diff;\\n        } else {\\n            if(graph[node] != -1 && vis[graph[node]] == 0) {\\n                discover[node] = time;\\n                getCycle(graph[node], graph, discover, time+1, vis);\\n                discover[node] = 0;\\n            }\\n        }\\n\\t\\t\\t\\t\\t  \\n    }\\n    public int longestCycle(int[] edges) {\\n        int len = edges.length;\\n        int[] vis = new int[len];\\n        int disc[] = new int[len];\\n        result = -1;\\n        for(int i = 0; i < len; i++) {\\n            if(vis[i] == 0){\\n                getCycle(i, edges, disc, 1, vis);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int result = -1;\\n\\tvoid getCycle(int node, int graph[], int[] discover, int time, int[] vis) {\\n        vis[node] = 1;\\n        if(graph[node] != -1 && discover[graph[node]] != 0){\\n            int prev = discover[graph[node]];\\n            int diff = time - prev + 1;\\n            if(diff > result)\\n                result = diff;\\n        } else {\\n            if(graph[node] != -1 && vis[graph[node]] == 0) {\\n                discover[node] = time;\\n                getCycle(graph[node], graph, discover, time+1, vis);\\n                discover[node] = 0;\\n            }\\n        }\\n\\t\\t\\t\\t\\t  \\n    }\\n    public int longestCycle(int[] edges) {\\n        int len = edges.length;\\n        int[] vis = new int[len];\\n        int disc[] = new int[len];\\n        result = -1;\\n        for(int i = 0; i < len; i++) {\\n            if(vis[i] == 0){\\n                getCycle(i, edges, disc, 1, vis);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344212,
                "title": "dfs-approach",
                "content": "# Intuition\\nCheck if we are back on start node for each node\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse map to store count, otherwise it might sometime will count itself twice\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    void dfs(int node, unordered_map<int,int>&mp, int cnt, vector<int>adj[], vector<int>&vis, vector<int>&pathVis, int&ans,int st)\\n    {\\n        vis[node]=1;\\n\\n        pathVis[node]=st;\\n      mp[node]= cnt;\\n    cnt++;\\n        for(auto it: adj[node])\\n        {\\n            if(!vis[it]){\\n                //cnt++;\\n                dfs(it, mp, cnt, adj, vis, pathVis, ans,st);\\n            }\\n            else if(pathVis[it]==st){\\n                \\n                //cout<<it<<endl;\\n                //cout<<mp[it]<<\" \"<<endl;\\n                ans= max(ans, cnt-mp[it] );\\n               \\n            }\\n        }\\n       // pathVis[node]=0;\\n    }\\n\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n= edges.size();\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            int u= i, v= edges[i];\\n            if(v==-1) continue;\\n            adj[u].push_back(v);\\n        }\\n\\n        vector<int> vis(n+1, 0);\\n        vector<int> pathVis(n+1, 0);\\n        int ans=-1;\\n        for(int i=0; i<n; i++)\\n        {\\n            unordered_map<int,int> mp;\\n            int cnt=0;\\n            if(!vis[i]){\\n                int st=i;\\n                dfs(i, mp, cnt, adj, vis, pathVis, ans,st);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n\\n    void dfs(int node, unordered_map<int,int>&mp, int cnt, vector<int>adj[], vector<int>&vis, vector<int>&pathVis, int&ans,int st)\\n    {\\n        vis[node]=1;\\n\\n        pathVis[node]=st;\\n      mp[node]= cnt;\\n    cnt++;\\n        for(auto it: adj[node])\\n        {\\n            if(!vis[it]){\\n                //cnt++;\\n                dfs(it, mp, cnt, adj, vis, pathVis, ans,st);\\n            }\\n            else if(pathVis[it]==st){\\n                \\n                //cout<<it<<endl;\\n                //cout<<mp[it]<<\" \"<<endl;\\n                ans= max(ans, cnt-mp[it] );\\n               \\n            }\\n        }\\n       // pathVis[node]=0;\\n    }\\n\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n= edges.size();\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            int u= i, v= edges[i];\\n            if(v==-1) continue;\\n            adj[u].push_back(v);\\n        }\\n\\n        vector<int> vis(n+1, 0);\\n        vector<int> pathVis(n+1, 0);\\n        int ans=-1;\\n        for(int i=0; i<n; i++)\\n        {\\n            unordered_map<int,int> mp;\\n            int cnt=0;\\n            if(!vis[i]){\\n                int st=i;\\n                dfs(i, mp, cnt, adj, vis, pathVis, ans,st);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3344079,
                "title": "simple-solution-using-arival-time",
                "content": "\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        v=[0]*len(edges)\\n        ans=-1\\n        for i in range(len(edges)):\\n            t=1\\n            c=i\\n            while c>=0:\\n                if v[c]!=0:\\n                    if v[c][0]==i:\\n                        ans=max(ans,t-v[c][1])\\n                    break\\n                else:\\n                    v[c]=[i,t]\\n                    t+=1\\n                    c=edges[c]\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Biconnected Component"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        v=[0]*len(edges)\\n        ans=-1\\n        for i in range(len(edges)):\\n            t=1\\n            c=i\\n            while c>=0:\\n                if v[c]!=0:\\n                    if v[c][0]==i:\\n                        ans=max(ans,t-v[c][1])\\n                    break\\n                else:\\n                    v[c]=[i,t]\\n                    t+=1\\n                    c=edges[c]\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343935,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mx=-1;\\n    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)\\n    {\\n        if(pvis[i])\\n        {\\n            mx = max(mx , j - pvis[i]);\\n            return;\\n        }\\n        if(!vis[i])\\n        {\\n            pvis[i] =j; j++; vis[i]=1;\\n            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);\\n        }\\n        pvis[i] = 0;\\n        return;\\n    }\\n    int longestCycle(vector<int>& ed)\\n     {\\n        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);\\n        mx = -1;\\n        for(int i=0;i<ed.size();i++)\\n        {\\n            if(!vis[i]) dfs(ed,pvis,vis,i,1);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx=-1;\\n    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)\\n    {\\n        if(pvis[i])\\n        {\\n            mx = max(mx , j - pvis[i]);\\n            return;\\n        }\\n        if(!vis[i])\\n        {\\n            pvis[i] =j; j++; vis[i]=1;\\n            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);\\n        }\\n        pvis[i] = 0;\\n        return;\\n    }\\n    int longestCycle(vector<int>& ed)\\n     {\\n        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);\\n        mx = -1;\\n        for(int i=0;i<ed.size();i++)\\n        {\\n            if(!vis[i]) dfs(ed,pvis,vis,i,1);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343890,
                "title": "with-only-one-visited-matrix-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int> &vis,vector<int> &edges,vector<int> &dist,int dis,int &ans){\\n        if(node!=-1){\\n            \\n            if(vis[node]==0){\\n                vis[node]=2;\\n                dist[node]=dis;\\n                dfs(edges[node],vis,edges,dist,dis+1,ans);\\n            }\\n            else if(vis[node]==2){\\n                ans=max(ans,dis-dist[node]);\\n            }\\n            \\n            vis[node]=1;\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> vis(n,0);\\n        \\n        vector<int> dist(n,0);\\n        int ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                dfs(i,vis,edges,dist,0,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node,vector<int> &vis,vector<int> &edges,vector<int> &dist,int dis,int &ans){\\n        if(node!=-1){\\n            \\n            if(vis[node]==0){\\n                vis[node]=2;\\n                dist[node]=dis;\\n                dfs(edges[node],vis,edges,dist,dis+1,ans);\\n            }\\n            else if(vis[node]==2){\\n                ans=max(ans,dis-dist[node]);\\n            }\\n            \\n            vis[node]=1;\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> vis(n,0);\\n        \\n        vector<int> dist(n,0);\\n        int ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                dfs(i,vis,edges,dist,0,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343220,
                "title": "easy-cycle-detection-with-dfs",
                "content": "# Intuition\\nUse same cycle detection method with one temp variable distance from node. when cycle is detected update maximum cycle count\\n\\n# Approach\\nuse Dfs with visit array and path visit array. And Do backtracking on path visit. \\n\\n```\\n    if (!visit[child]){\\n        dfs(child,dis+1);\\n    }else if(pathvisit[child]!=-1){\\n        maxCycle=max(maxCycle,dis)\\n    }\\n```\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCycle=-1;\\n    void iscycle(int root,vector<int> adj[], vector<int> &visit, vector<int> &pathvisit,int dis){\\n        visit[root]=1;\\n        pathvisit[root]=1;\\n\\n        for(auto i:adj[root]){\\n            if(!visit[i]){\\n                iscycle(i,adj,visit,pathvisit,dis+1);\\n            }else if(pathvisit[i]!=-1){\\n                maxCycle=max(maxCycle,dis);\\n            }\\n        }\\n        pathvisit[root]=-1;\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> adj[n+1];\\n\\n        for(int i=0;i<n;++i){\\n            if(edges[i]!=-1){\\n                adj[edges[i]].push_back(i);\\n            }\\n        }\\n    \\n        vector<int> visit(n+1,0);\\n        vector<int> pathvisit(n+1,-1);\\n        for(int i=0;i<n;++i){\\n            if(!visit[i]) iscycle(i,adj,visit,pathvisit,1);\\n        }\\n\\n        return maxCycle;\\n    }\\n};\\n```\\nPLEASE DO UPVOTE IF IT HELPS.",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n    if (!visit[child]){\\n        dfs(child,dis+1);\\n    }else if(pathvisit[child]!=-1){\\n        maxCycle=max(maxCycle,dis)\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCycle=-1;\\n    void iscycle(int root,vector<int> adj[], vector<int> &visit, vector<int> &pathvisit,int dis){\\n        visit[root]=1;\\n        pathvisit[root]=1;\\n\\n        for(auto i:adj[root]){\\n            if(!visit[i]){\\n                iscycle(i,adj,visit,pathvisit,dis+1);\\n            }else if(pathvisit[i]!=-1){\\n                maxCycle=max(maxCycle,dis);\\n            }\\n        }\\n        pathvisit[root]=-1;\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> adj[n+1];\\n\\n        for(int i=0;i<n;++i){\\n            if(edges[i]!=-1){\\n                adj[edges[i]].push_back(i);\\n            }\\n        }\\n    \\n        vector<int> visit(n+1,0);\\n        vector<int> pathvisit(n+1,-1);\\n        for(int i=0;i<n;++i){\\n            if(!visit[i]) iscycle(i,adj,visit,pathvisit,1);\\n        }\\n\\n        return maxCycle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342884,
                "title": "rust-fastest-100-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKey of this problem, is that each vertex can have at most one outgoing edge. As such, an easy way to detect cycles is to dfs through the graph, and if you reach a node that you previously reached in this iteration of the dfs, you got yourself a cycle. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn order for the dfs to work, I keep some information: the current ```level``` or depth of dfs, the depths for all the other nodes (in ```levels```). \\n\\nMeanings of different level values for each node:\\n- ```levels[node] == -1```: Previously explored, terminate early.\\n- ```levels[node] == 0```: First time encountering it, save the current depth of dfs. \\n- ```levels[node] > 0```: The depth of dfs when I previously encountered it. The length of the cycle is ```levels[node] - level```\\n\\nWhen returning through the dfs stack, remember to set each level to -1, since you explored it once. \\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n)$ go through each node once, or terminate early since it was previsouly visited. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for keeping the data length of the longest cycle. \\n# Code\\n```\\nimpl Solution {\\n    pub fn longest_cycle(edges: Vec<i32>) -> i32 {\\n\\n        let mut levels = vec![0; edges.len()];\\n        let mut res = -1;\\n        for i in 0..(edges.len() as i32){\\n            res = res.max(Solution::dfs(&edges, &mut levels, 1, i));\\n        }\\n        return res;\\n    }\\n\\n    pub fn dfs(edges: &Vec<i32>, levels: &mut Vec<i32>, level: i32, node: i32) -> i32 {\\n        if node < 0 {\\n            return -1;\\n        }\\n        let node = node as usize;\\n        return if edges[node] == -1 || levels[node] == -1 {\\n            -1\\n        } else if levels[node] > 0 {\\n            let old_level = levels[node];\\n            levels[node] = -1;\\n            level - old_level\\n        } else {\\n            levels[node] = level;\\n            let res = Solution::dfs(edges, levels, level + 1, edges[node]);\\n            levels[node] = -1;\\n            res\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```level```\n```levels```\n```levels[node] == -1```\n```levels[node] == 0```\n```levels[node] > 0```\n```levels[node] - level```\n```\\nimpl Solution {\\n    pub fn longest_cycle(edges: Vec<i32>) -> i32 {\\n\\n        let mut levels = vec![0; edges.len()];\\n        let mut res = -1;\\n        for i in 0..(edges.len() as i32){\\n            res = res.max(Solution::dfs(&edges, &mut levels, 1, i));\\n        }\\n        return res;\\n    }\\n\\n    pub fn dfs(edges: &Vec<i32>, levels: &mut Vec<i32>, level: i32, node: i32) -> i32 {\\n        if node < 0 {\\n            return -1;\\n        }\\n        let node = node as usize;\\n        return if edges[node] == -1 || levels[node] == -1 {\\n            -1\\n        } else if levels[node] > 0 {\\n            let old_level = levels[node];\\n            levels[node] = -1;\\n            level - old_level\\n        } else {\\n            levels[node] = level;\\n            let res = Solution::dfs(edges, levels, level + 1, edges[node]);\\n            levels[node] = -1;\\n            res\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342848,
                "title": "c-dfs",
                "content": "```\\n\\tprivate HashSet<int> visited = new HashSet<int>();\\n    private int res = -1;\\n    \\n    public int LongestCycle(int[] edges) {\\n        for (int i = 0; i < edges.Length; i++) {\\n            if (visited.Contains(i)) continue;\\n            DFS(edges, i, new HashSet<int>(), new Dictionary<int, int>());\\n        }\\n        return res;\\n    }\\n\\n    public void DFS(int[] edges, int cur, HashSet<int> path, Dictionary<int, int> indexes) {\\n        if (cur == -1) return;\\n        path.Add(cur);\\n        if (!visited.Add(cur)) {\\n            if (indexes.ContainsKey(cur))\\n                res = Math.Max(res, path.Count - indexes[cur] + 1);\\n            return;\\n        }\\n        indexes[cur] = path.Count;\\n        DFS(edges, edges[cur], path, indexes);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tprivate HashSet<int> visited = new HashSet<int>();\\n    private int res = -1;\\n    \\n    public int LongestCycle(int[] edges) {\\n        for (int i = 0; i < edges.Length; i++) {\\n            if (visited.Contains(i)) continue;\\n            DFS(edges, i, new HashSet<int>(), new Dictionary<int, int>());\\n        }\\n        return res;\\n    }\\n\\n    public void DFS(int[] edges, int cur, HashSet<int> path, Dictionary<int, int> indexes) {\\n        if (cur == -1) return;\\n        path.Add(cur);\\n        if (!visited.Add(cur)) {\\n            if (indexes.ContainsKey(cur))\\n                res = Math.Max(res, path.Count - indexes[cur] + 1);\\n            return;\\n        }\\n        indexes[cur] = path.Count;\\n        DFS(edges, edges[cur], path, indexes);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342604,
                "title": "95-faster-dfs-short-sweet-code-simple-c",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    void solve(int s,vector<bool> &vis,vector<bool> &stv,vector<int> &dis,int &ans,vector<int> &g,int k){\\n        if(s != -1){\\n            if(!vis[s]){//if node previously visitited than ignore it\\n                vis[s] = true;\\n                stv[s] = true;\\n                dis[s] = k;\\n                solve(g[s],vis,stv,dis,ans,g,k+1);\\n            }else if(stv[s]){//if i is not visited & sametimevisited[s] is visited than there is cycle\\n                ans = max(ans,k-dis[s]);\\n            }\\n            stv[s] = false;\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<bool> vis(n,false),sametimevis(n,false);\\n        vector<int> dis(n,-1);\\n        int ans = -1;\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                solve(i,vis,sametimevis,dis,ans,edges,0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    void solve(int s,vector<bool> &vis,vector<bool> &stv,vector<int> &dis,int &ans,vector<int> &g,int k){\\n        if(s != -1){\\n            if(!vis[s]){//if node previously visitited than ignore it\\n                vis[s] = true;\\n                stv[s] = true;\\n                dis[s] = k;\\n                solve(g[s],vis,stv,dis,ans,g,k+1);\\n            }else if(stv[s]){//if i is not visited & sametimevisited[s] is visited than there is cycle\\n                ans = max(ans,k-dis[s]);\\n            }\\n            stv[s] = false;\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<bool> vis(n,false),sametimevis(n,false);\\n        vector<int> dis(n,-1);\\n        int ans = -1;\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]){\\n                solve(i,vis,sametimevis,dis,ans,edges,0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342548,
                "title": "clean-swift-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func longestCycle(_ edges: [Int]) -> Int {\\n        var answer = -1\\n\\n        var visited = Array(repeating: false, count: edges.count)\\n\\n        for i in 0..<edges.count {\\n            guard !visited[i] else { continue }\\n\\n            var currentNode = i\\n            var path = [i]\\n            while !visited[currentNode] {\\n                visited[currentNode] = true\\n\\n                let nextNode = edges[currentNode]\\n                guard nextNode != -1 else { break }\\n                path.append(nextNode)\\n\\n                currentNode = nextNode\\n            }\\n\\n            let cyclePath = path.suffix(from: path.firstIndex(of: currentNode)!)\\n            if cyclePath.count > 1 {\\n                answer = max(answer, cyclePath.count - 1)\\n            }\\n        }\\n\\n        return answer\\n    }\\n}\\n```\\n---\\n\\nIf my LeetCode solution was helpful, kindly upvote it to support my contributions and aid others in their coding journey! \\uD83D\\uDE0A\\uD83D\\uDC4D",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestCycle(_ edges: [Int]) -> Int {\\n        var answer = -1\\n\\n        var visited = Array(repeating: false, count: edges.count)\\n\\n        for i in 0..<edges.count {\\n            guard !visited[i] else { continue }\\n\\n            var currentNode = i\\n            var path = [i]\\n            while !visited[currentNode] {\\n                visited[currentNode] = true\\n\\n                let nextNode = edges[currentNode]\\n                guard nextNode != -1 else { break }\\n                path.append(nextNode)\\n\\n                currentNode = nextNode\\n            }\\n\\n            let cyclePath = path.suffix(from: path.firstIndex(of: currentNode)!)\\n            if cyclePath.count > 1 {\\n                answer = max(answer, cyclePath.count - 1)\\n            }\\n        }\\n\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342384,
                "title": "c-solution-using-dictionary",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public int LongestCycle(int[] edges) {\\n      int max = -1;\\n      bool[] visited = new bool[edges.Length];\\n      for(int i=0;i<edges.Length;i++){\\n        if(visited[i]){continue;}\\n        Dictionary<int,int> d = new Dictionary<int,int>();\\n        for(int j=i,distance=0;j!=-1;j=edges[j]){\\n          if(d.ContainsKey(j)){\\n            max = Math.Max(max,distance-d[j]);\\n          }\\n          if(visited[j]){break;}\\n          visited[j] = true;\\n          d[j] = distance;\\n          distance++;\\n        }\\n      }\\n      return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestCycle(int[] edges) {\\n      int max = -1;\\n      bool[] visited = new bool[edges.Length];\\n      for(int i=0;i<edges.Length;i++){\\n        if(visited[i]){continue;}\\n        Dictionary<int,int> d = new Dictionary<int,int>();\\n        for(int j=i,distance=0;j!=-1;j=edges[j]){\\n          if(d.ContainsKey(j)){\\n            max = Math.Max(max,distance-d[j]);\\n          }\\n          if(visited[j]){break;}\\n          visited[j] = true;\\n          d[j] = distance;\\n          distance++;\\n        }\\n      }\\n      return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108704,
                "title": "c-dfs-solution-with-explanation",
                "content": "# Intuition\\nThe primary observation to be made before solving the problem is that a particular node can be a part of at most one cycle. This can be ascertained from the fact that each node can have outmost one outgoing edge, it it were multiple edges then a node could be a part of multiple cycles\\n\\n# Approach\\nWe can initialize a \\'time\\' array to keep track of the time instant when we visit a node. This can be useful since a cycle is detected iff a node is visited twice while following the cycle of nodes. Hence the length of the cycle can be determined by the difference in the times when the node was visited.\\n\\nIf we encouter a dead end OR if a node is already a part of a cycle (determined if time[node] != -1), we cannot continue further. Hence we backtrack from the current path while marking the nodes not a part of a cylce as unvisited i.e, time[node] = -1.\\n\\nThe variable \\'ans\\' (initialized to a negative number) stores the maximum length of the cycle obtained. Also, if a node is visited twice in a cycle, after we determine the cycle size, we update the time value of the node. \\n\\nFinally we determine if the variable \\'ans\\' is negative or not. If it is, then no cycle exists in the graph and therefore we return -1, else we return \\'ans\\', the length of the cycle\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(int node, vector <int> &edges, int &ans, vector <int> &time, int t) {\\n\\n        int next = edges[node];\\n\\n        if(time[node] != -1) {\\n            ans = max(ans, t - time[node]);\\n            time[node] = INT_MAX;\\n            return true;\\n        }\\n        \\n        time[node] = t;\\n\\n        if(next != -1) {\\n            bool stat = solve(next, edges, ans, time, t + 1);    \\n            if(!stat) // cycle could not be formed\\n                time[node] = -1;\\n            else { // cycle is formed\\n                time[node] = INT_MAX;\\n                return true;\\n            }\\n        }\\n\\n        else // dead end\\n            time[node] = -1;\\n\\n        return false;\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n\\n        int n = edges.size(), ans = INT_MIN;\\n        vector <int> time(n, -1);\\n\\n        for(int i = 0; i < n; i++) {\\n            if(time[i] == -1)\\n                solve(i, edges, ans, time, 0);\\n        }\\n\\n        return (ans == INT_MIN) ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool solve(int node, vector <int> &edges, int &ans, vector <int> &time, int t) {\\n\\n        int next = edges[node];\\n\\n        if(time[node] != -1) {\\n            ans = max(ans, t - time[node]);\\n            time[node] = INT_MAX;\\n            return true;\\n        }\\n        \\n        time[node] = t;\\n\\n        if(next != -1) {\\n            bool stat = solve(next, edges, ans, time, t + 1);    \\n            if(!stat) // cycle could not be formed\\n                time[node] = -1;\\n            else { // cycle is formed\\n                time[node] = INT_MAX;\\n                return true;\\n            }\\n        }\\n\\n        else // dead end\\n            time[node] = -1;\\n\\n        return false;\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n\\n        int n = edges.size(), ans = INT_MIN;\\n        vector <int> time(n, -1);\\n\\n        for(int i = 0; i < n; i++) {\\n            if(time[i] == -1)\\n                solve(i, edges, ans, time, 0);\\n        }\\n\\n        return (ans == INT_MIN) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069709,
                "title": "kosaraju-s-algorithm-tc-o-v-e",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n```\\nWe are using Kosaraju\\'s Algorithm which is used to find\\nStrongly Connected Components(SCC)\\nSCC\\'s are Cyclic as it is assured in SCC that,\\nwe can travel to any vertex from any other vertext.\\nFirst we are running random order DFS and adding vertices\\nto stack while doing backtrack.\\nThen we are constructing A Graph with reversed Edges to avoid\\nproblem created by edge connecting two Strongly Connected Components.\\nIn last we are simply popping elements from stack \\nand running Dfs and simultaneously checking size of Cycle \\nin each Strongly Connected Component.\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean[] visited;\\n    int count;\\n    public int longestCycle(int[] edges) {\\n        int len = edges.length;\\n        Stack<Integer> stack = new Stack();\\n        visited = new boolean[len];\\n// Run random order Dfs and add vertices to stack while backtracking\\n        for(int i = 0; i < len; i++) {\\n            if(edges[i] != -1 && !visited[i])\\n                dfs(edges, i, stack);\\n        }\\n// Construct a graph with Reversed edges\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList();\\n        for(int i = 0; i < len; i++)\\n            graph.add(new ArrayList());\\n        for(int i = 0; i < len; i++) {\\n            if(edges[i] != -1)\\n                graph.get(edges[i]).add(i);\\n        }\\n\\n        visited = new boolean[len];\\n        int maxCycle = 0;\\n// Run stack wise Dfs to mark Strongly Connected Components\\n        while(!stack.isEmpty()) {\\n            int top = stack.pop();\\n            if(visited[top])\\n                continue;\\n            count = 0;\\n            specialDfs(graph, top);\\n            maxCycle = Math.max(maxCycle, count);    \\n        }\\n        return maxCycle > 1 ? maxCycle : -1;\\n    }\\n\\n    public void dfs(int[] edges, int source, Stack<Integer> stack) {\\n        visited[source] = true;\\n        int child = edges[source];\\n        if(child != -1 && !visited[child])\\n            dfs(edges, child, stack);\\n        stack.push(source); \\n    }\\n\\n    public void specialDfs(ArrayList<ArrayList<Integer>> graph, int source) {\\n        visited[source] = true;\\n// Count number of elements in each Strongly Connected Component\\n        count++;\\n        for(int child : graph.get(source)) {\\n            if(!visited[child]) \\n                specialDfs(graph, child);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nWe are using Kosaraju\\'s Algorithm which is used to find\\nStrongly Connected Components(SCC)\\nSCC\\'s are Cyclic as it is assured in SCC that,\\nwe can travel to any vertex from any other vertext.\\nFirst we are running random order DFS and adding vertices\\nto stack while doing backtrack.\\nThen we are constructing A Graph with reversed Edges to avoid\\nproblem created by edge connecting two Strongly Connected Components.\\nIn last we are simply popping elements from stack \\nand running Dfs and simultaneously checking size of Cycle \\nin each Strongly Connected Component.\\n```\n```\\nclass Solution {\\n    boolean[] visited;\\n    int count;\\n    public int longestCycle(int[] edges) {\\n        int len = edges.length;\\n        Stack<Integer> stack = new Stack();\\n        visited = new boolean[len];\\n// Run random order Dfs and add vertices to stack while backtracking\\n        for(int i = 0; i < len; i++) {\\n            if(edges[i] != -1 && !visited[i])\\n                dfs(edges, i, stack);\\n        }\\n// Construct a graph with Reversed edges\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList();\\n        for(int i = 0; i < len; i++)\\n            graph.add(new ArrayList());\\n        for(int i = 0; i < len; i++) {\\n            if(edges[i] != -1)\\n                graph.get(edges[i]).add(i);\\n        }\\n\\n        visited = new boolean[len];\\n        int maxCycle = 0;\\n// Run stack wise Dfs to mark Strongly Connected Components\\n        while(!stack.isEmpty()) {\\n            int top = stack.pop();\\n            if(visited[top])\\n                continue;\\n            count = 0;\\n            specialDfs(graph, top);\\n            maxCycle = Math.max(maxCycle, count);    \\n        }\\n        return maxCycle > 1 ? maxCycle : -1;\\n    }\\n\\n    public void dfs(int[] edges, int source, Stack<Integer> stack) {\\n        visited[source] = true;\\n        int child = edges[source];\\n        if(child != -1 && !visited[child])\\n            dfs(edges, child, stack);\\n        stack.push(source); \\n    }\\n\\n    public void specialDfs(ArrayList<ArrayList<Integer>> graph, int source) {\\n        visited[source] = true;\\n// Count number of elements in each Strongly Connected Component\\n        count++;\\n        for(int child : graph.get(source)) {\\n            if(!visited[child]) \\n                specialDfs(graph, child);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967753,
                "title": "dfs-considering-all-options-from-a-node-from-its-parents",
                "content": "# Intuition\\nConsidering how can many cycles can be there is one connected component.\\n\\n# Approach\\nbasically starting from a  node and then exploring its parents (somewhat like bfs) and keeping count as a variable and if any adjacent node is parent again which means there is cycle in that component so we will update the ans variable as well.\\n\\n# Complexity\\n- Time complexity:\\nn\\n- Space complexity:\\nn\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n  void fun(vector<int>& visited,vector<vector<int>>& adj,int count,int& ans,int i,int parent){\\n\\n    visited[i]=1;\\n    count++;\\n    for(int j=0;j<adj[i].size();j++){\\n          if(visited[adj[i][j]]==0){\\n              fun(visited,adj,count,ans,adj[i][j],parent);\\n          }\\n          else if(visited[adj[i][j]]==1){\\n              if(adj[i][j]==parent){\\n                  ans=max(ans,count-1);\\n              }\\n          }\\n    }\\n    return;\\n\\n  }\\n    int longestCycle(vector<int>& edges) {\\n       int i;\\n       int n=edges.size();\\n       vector<vector<int> > adj(n);\\n\\n       for(i=0;i<n;i++){\\n           if(edges[i]!=-1){\\n         adj[edges[i]].push_back(i);\\n           }\\n\\n       }\\n       int count=1;\\n       int ans=-1;\\n       vector<int> visited(n);\\n       for(i=0;i<n;i++){\\n           visited[i]=0;\\n       }\\n       for(i=0;i<n;i++){\\n           if(visited[i]==0){\\n               fun(visited,adj,count,ans,i,i);\\n           }\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  void fun(vector<int>& visited,vector<vector<int>>& adj,int count,int& ans,int i,int parent){\\n\\n    visited[i]=1;\\n    count++;\\n    for(int j=0;j<adj[i].size();j++){\\n          if(visited[adj[i][j]]==0){\\n              fun(visited,adj,count,ans,adj[i][j],parent);\\n          }\\n          else if(visited[adj[i][j]]==1){\\n              if(adj[i][j]==parent){\\n                  ans=max(ans,count-1);\\n              }\\n          }\\n    }\\n    return;\\n\\n  }\\n    int longestCycle(vector<int>& edges) {\\n       int i;\\n       int n=edges.size();\\n       vector<vector<int> > adj(n);\\n\\n       for(i=0;i<n;i++){\\n           if(edges[i]!=-1){\\n         adj[edges[i]].push_back(i);\\n           }\\n\\n       }\\n       int count=1;\\n       int ans=-1;\\n       vector<int> visited(n);\\n       for(i=0;i<n;i++){\\n           visited[i]=0;\\n       }\\n       for(i=0;i<n;i++){\\n           if(visited[i]==0){\\n               fun(visited,adj,count,ans,i,i);\\n           }\\n       }\\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537463,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using BFS + DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // dfs function for finding the length of cycle\\n    \\n    void dfs(vector<int>& edges, int u, vector<bool>& vis, int &count)\\n    {\\n        vis[u] = true;\\n        \\n        count++;\\n        \\n        if(edges[u] != -1 && vis[edges[u]] == false)\\n        {\\n            dfs(edges, edges[u], vis, count);\\n        }\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        \\n        // use kahn\\'s algorithm\\n        \\n        vector<int> indegree(n, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int v = edges[i];\\n            \\n            if(v != -1)\\n            {\\n                indegree[v]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int u = q.front();\\n            \\n            q.pop();\\n            \\n            if(edges[u] != -1)\\n            {\\n                indegree[edges[u]]--;\\n                \\n                if(indegree[edges[u]] == 0)\\n                {\\n                    q.push(edges[u]);\\n                }\\n            }\\n        }\\n        \\n        // declare a vis array\\n        \\n        vector<bool> vis(n, false);\\n        \\n        int maxi = INT_MIN;\\n        \\n        // run a dfs for every node with indegree > 0\\n        \\n        // find the length of cycle and update maxi\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            \\n            if(indegree[i] > 0 && vis[i] == false)\\n            {\\n                dfs(edges, i, vis, count);\\n            }\\n            \\n            maxi = max(maxi, count);\\n        }\\n        \\n        // if there is no cycle in graph, return -1\\n        \\n        if(maxi == 0)\\n            return -1;\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // dfs function for finding the length of cycle\\n    \\n    void dfs(vector<int>& edges, int u, vector<bool>& vis, int &count)\\n    {\\n        vis[u] = true;\\n        \\n        count++;\\n        \\n        if(edges[u] != -1 && vis[edges[u]] == false)\\n        {\\n            dfs(edges, edges[u], vis, count);\\n        }\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        \\n        int n = edges.size();\\n        \\n        // use kahn\\'s algorithm\\n        \\n        vector<int> indegree(n, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int v = edges[i];\\n            \\n            if(v != -1)\\n            {\\n                indegree[v]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int u = q.front();\\n            \\n            q.pop();\\n            \\n            if(edges[u] != -1)\\n            {\\n                indegree[edges[u]]--;\\n                \\n                if(indegree[edges[u]] == 0)\\n                {\\n                    q.push(edges[u]);\\n                }\\n            }\\n        }\\n        \\n        // declare a vis array\\n        \\n        vector<bool> vis(n, false);\\n        \\n        int maxi = INT_MIN;\\n        \\n        // run a dfs for every node with indegree > 0\\n        \\n        // find the length of cycle and update maxi\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;\\n            \\n            if(indegree[i] > 0 && vis[i] == false)\\n            {\\n                dfs(edges, i, vis, count);\\n            }\\n            \\n            maxi = max(maxi, count);\\n        }\\n        \\n        // if there is no cycle in graph, return -1\\n        \\n        if(maxi == 0)\\n            return -1;\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439909,
                "title": "rust-three-solutions-cycle-detection-topological-sorting-strongly-connected-komponents",
                "content": "### Using a cycle detection algorithm\\n\\nBecause each node can participate in at most one cycle (because it has at most\\none outgoing edge) we can use a simple cycle detection algorithm:\\n\\n```rust\\n#[derive(Copy, Clone, Eq, PartialEq)]\\nenum State {\\n    Unvisited,\\n    Safe,\\n    Cycle,\\n    Undecided(i32),\\n}\\n\\npub fn longest_cycle(edges: Vec<i32>) -> i32 {\\n    let mut state = vec![State::Unvisited; edges.len()];\\n    let mut cycle = -1;\\n\\n    for idx in 0..edges.len() {\\n        if state[idx] == State::Unvisited {\\n            leads_to_cycle(&edges, &mut state, &mut cycle, idx, 0);\\n        }\\n    }\\n\\n    cycle\\n}\\n\\nfn leads_to_cycle(\\n    edges: &[i32],\\n    state: &mut [State],\\n    cycle: &mut i32,\\n    current: usize,\\n    depth: i32,\\n) -> bool {\\n    if edges[current] < 0 {\\n        state[current] = State::Safe;\\n        return false;\\n    }\\n\\n    match state[current] {\\n        State::Unvisited => { /*do nothing - process the case below*/ }\\n        State::Safe => return false,\\n        State::Cycle => return true,\\n        State::Undecided(d) => {\\n            *cycle = (*cycle).max(depth - d);\\n            return true;\\n        }\\n    }\\n\\n    state[current] = State::Undecided(depth);\\n    if leads_to_cycle(edges, state, cycle, edges[current] as usize, depth + 1) {\\n        state[current] = State::Cycle;\\n        return true;\\n    }\\n\\n    state[current] = State::Safe;\\n    false\\n}\\n```\\n\\n### Topological sorting (Kahn\\'s algorithm)\\n\\n```rust\\npub fn longest_cycle(mut edges: Vec<i32>) -> i32 {\\n    let mut indegree = vec![0; edges.len()];\\n    for edge in edges.iter().copied() {\\n        if edge >= 0 {\\n            indegree[edge as usize] += 1;\\n        }\\n    }\\n\\n    // Seed the queue with the nodes that have NO incoming edges\\n    let mut queue = vec![];\\n    for (node, &degree) in indegree.iter().enumerate() {\\n        if degree == 0 {\\n            queue.push(node);\\n        }\\n    }\\n\\n    while let Some(node) = queue.pop() {\\n        if edges[node] >= 0 {\\n            let next = edges[node] as usize;\\n\\n            indegree[next] -= 1;\\n            if indegree[next] == 0 {\\n                queue.push(next);\\n            }\\n        }\\n\\n        // delete the node, because it does not participate in a cycle\\n        // (in the original Kahn\\'s algorithm we would have pushed the node\\n        // to vector/stack instead)\\n        edges[node] = -1;\\n    }\\n\\n    // If there are any nodes left with outgoing connections,\\n    // then they participate in a cycle.\\n    let mut answer = -1;\\n    for idx in 0..edges.len() {\\n        // Nodes with negative edges do not participate in cycles\\n        if edges[idx] < 0 {\\n            continue;\\n        }\\n\\n        let mut len = 0;\\n        let mut node = idx;\\n\\n        // Follow the edges until we reach an already visited node\\n        // We mark visited nodes with \\'-1` because each node can be part of at\\n        // most one cycle, so it\\'s safe to \"delete\" them once visited\\n        while edges[node] >= 0 {\\n            // safe the current node idx in order to \"delete\" it later\\n            let prev = node;\\n\\n            // follow the edge\\n            node = edges[node] as usize;\\n\\n            // delete the edge that we just visited\\n            edges[prev] = -1;\\n\\n            // increase the cycle length\\n            len += 1;\\n        }\\n\\n        // remember the longest length\\n        answer = answer.max(len);\\n    }\\n\\n    answer\\n}\\n```\\n\\n### Strongly connected components #1 (Kosaraju\\'s algorithm)\\n\\n```rust\\npub fn longest_cycle(edges: Vec<i32>) -> i32 {\\n    // Build the reversed graph:\\n    // * `idx` points to the \"src\" node in the original graph\\n    // * `edge` points to the \"dst\" node in the original graph\\n    let mut reversed = vec![vec![]; edges.len()];\\n    for (idx, &edge) in edges.iter().enumerate() {\\n        if edge >= 0 {\\n            reversed[edge as usize].push(idx);\\n        }\\n    }\\n\\n    let mut stack = vec![];\\n    let mut visited = vec![false; edges.len()];\\n\\n    // Perform the DFS on the original graph\\n    for node in 0..edges.len() {\\n        if !visited[node] {\\n            dfs_1(&edges, &mut visited, &mut stack, node);\\n        }\\n    }\\n\\n    // The SCC array will contain the strongly connected components after each iteration\\n    let mut scc = vec![];\\n\\n    // Perform the DFS on the reversed graph\\n    let mut len = 0;\\n    visited.fill(false);\\n\\n    while let Some(node) = stack.pop() {\\n        if !visited[node] {\\n            // clear the previously found SCC\\n            scc.clear();\\n\\n            // For this problem we can just increment a counter instead of\\n            // pushing the nodes in a vector, but I\\'ve done it this way\\n            // just to show how to find the actual components, so that this\\n            // document can act as a tutorial for Kosaraju\\'s algorithm\\n            dfs_2(&reversed, &mut visited, &mut scc, node);\\n\\n            // Remember the size of the largest SCC\\n            len = len.max(scc.len());\\n\\n            // Do something with the SCC...\\n            //println!(\"{:?}\", scc);\\n        }\\n    }\\n\\n    if len <= 1 {\\n        return -1;\\n    }\\n\\n    len as i32\\n}\\n\\nfn dfs_1(edges: &[i32], visited: &mut [bool], stack: &mut Vec<usize>, current: usize) {\\n    if visited[current] {\\n        return;\\n    }\\n    visited[current] = true;\\n\\n    if edges[current] >= 0 {\\n        dfs_1(edges, visited, stack, edges[current] as usize)\\n    }\\n\\n    stack.push(current)\\n}\\n\\nfn dfs_2(edges: &[Vec<usize>], visited: &mut [bool], scc: &mut Vec<usize>, current: usize) {\\n    if visited[current] {\\n        return;\\n    }\\n    visited[current] = true;\\n\\n    // For this problem we could have just incremented a counter\\n    // instead of collecting the actual nodes of the SCC\\n    scc.push(current);\\n\\n    for &edge in &edges[current] {\\n        dfs_2(edges, visited, scc, edge);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Topological Sort"
                ],
                "code": "```rust\\n#[derive(Copy, Clone, Eq, PartialEq)]\\nenum State {\\n    Unvisited,\\n    Safe,\\n    Cycle,\\n    Undecided(i32),\\n}\\n\\npub fn longest_cycle(edges: Vec<i32>) -> i32 {\\n    let mut state = vec![State::Unvisited; edges.len()];\\n    let mut cycle = -1;\\n\\n    for idx in 0..edges.len() {\\n        if state[idx] == State::Unvisited {\\n            leads_to_cycle(&edges, &mut state, &mut cycle, idx, 0);\\n        }\\n    }\\n\\n    cycle\\n}\\n\\nfn leads_to_cycle(\\n    edges: &[i32],\\n    state: &mut [State],\\n    cycle: &mut i32,\\n    current: usize,\\n    depth: i32,\\n) -> bool {\\n    if edges[current] < 0 {\\n        state[current] = State::Safe;\\n        return false;\\n    }\\n\\n    match state[current] {\\n        State::Unvisited => { /*do nothing - process the case below*/ }\\n        State::Safe => return false,\\n        State::Cycle => return true,\\n        State::Undecided(d) => {\\n            *cycle = (*cycle).max(depth - d);\\n            return true;\\n        }\\n    }\\n\\n    state[current] = State::Undecided(depth);\\n    if leads_to_cycle(edges, state, cycle, edges[current] as usize, depth + 1) {\\n        state[current] = State::Cycle;\\n        return true;\\n    }\\n\\n    state[current] = State::Safe;\\n    false\\n}\\n```\n```rust\\npub fn longest_cycle(mut edges: Vec<i32>) -> i32 {\\n    let mut indegree = vec![0; edges.len()];\\n    for edge in edges.iter().copied() {\\n        if edge >= 0 {\\n            indegree[edge as usize] += 1;\\n        }\\n    }\\n\\n    // Seed the queue with the nodes that have NO incoming edges\\n    let mut queue = vec![];\\n    for (node, &degree) in indegree.iter().enumerate() {\\n        if degree == 0 {\\n            queue.push(node);\\n        }\\n    }\\n\\n    while let Some(node) = queue.pop() {\\n        if edges[node] >= 0 {\\n            let next = edges[node] as usize;\\n\\n            indegree[next] -= 1;\\n            if indegree[next] == 0 {\\n                queue.push(next);\\n            }\\n        }\\n\\n        // delete the node, because it does not participate in a cycle\\n        // (in the original Kahn\\'s algorithm we would have pushed the node\\n        // to vector/stack instead)\\n        edges[node] = -1;\\n    }\\n\\n    // If there are any nodes left with outgoing connections,\\n    // then they participate in a cycle.\\n    let mut answer = -1;\\n    for idx in 0..edges.len() {\\n        // Nodes with negative edges do not participate in cycles\\n        if edges[idx] < 0 {\\n            continue;\\n        }\\n\\n        let mut len = 0;\\n        let mut node = idx;\\n\\n        // Follow the edges until we reach an already visited node\\n        // We mark visited nodes with \\'-1` because each node can be part of at\\n        // most one cycle, so it\\'s safe to \"delete\" them once visited\\n        while edges[node] >= 0 {\\n            // safe the current node idx in order to \"delete\" it later\\n            let prev = node;\\n\\n            // follow the edge\\n            node = edges[node] as usize;\\n\\n            // delete the edge that we just visited\\n            edges[prev] = -1;\\n\\n            // increase the cycle length\\n            len += 1;\\n        }\\n\\n        // remember the longest length\\n        answer = answer.max(len);\\n    }\\n\\n    answer\\n}\\n```\n```rust\\npub fn longest_cycle(edges: Vec<i32>) -> i32 {\\n    // Build the reversed graph:\\n    // * `idx` points to the \"src\" node in the original graph\\n    // * `edge` points to the \"dst\" node in the original graph\\n    let mut reversed = vec![vec![]; edges.len()];\\n    for (idx, &edge) in edges.iter().enumerate() {\\n        if edge >= 0 {\\n            reversed[edge as usize].push(idx);\\n        }\\n    }\\n\\n    let mut stack = vec![];\\n    let mut visited = vec![false; edges.len()];\\n\\n    // Perform the DFS on the original graph\\n    for node in 0..edges.len() {\\n        if !visited[node] {\\n            dfs_1(&edges, &mut visited, &mut stack, node);\\n        }\\n    }\\n\\n    // The SCC array will contain the strongly connected components after each iteration\\n    let mut scc = vec![];\\n\\n    // Perform the DFS on the reversed graph\\n    let mut len = 0;\\n    visited.fill(false);\\n\\n    while let Some(node) = stack.pop() {\\n        if !visited[node] {\\n            // clear the previously found SCC\\n            scc.clear();\\n\\n            // For this problem we can just increment a counter instead of\\n            // pushing the nodes in a vector, but I\\'ve done it this way\\n            // just to show how to find the actual components, so that this\\n            // document can act as a tutorial for Kosaraju\\'s algorithm\\n            dfs_2(&reversed, &mut visited, &mut scc, node);\\n\\n            // Remember the size of the largest SCC\\n            len = len.max(scc.len());\\n\\n            // Do something with the SCC...\\n            //println!(\"{:?}\", scc);\\n        }\\n    }\\n\\n    if len <= 1 {\\n        return -1;\\n    }\\n\\n    len as i32\\n}\\n\\nfn dfs_1(edges: &[i32], visited: &mut [bool], stack: &mut Vec<usize>, current: usize) {\\n    if visited[current] {\\n        return;\\n    }\\n    visited[current] = true;\\n\\n    if edges[current] >= 0 {\\n        dfs_1(edges, visited, stack, edges[current] as usize)\\n    }\\n\\n    stack.push(current)\\n}\\n\\nfn dfs_2(edges: &[Vec<usize>], visited: &mut [bool], scc: &mut Vec<usize>, current: usize) {\\n    if visited[current] {\\n        return;\\n    }\\n    visited[current] = true;\\n\\n    // For this problem we could have just incremented a counter\\n    // instead of collecting the actual nodes of the SCC\\n    scc.push(current);\\n\\n    for &edge in &edges[current] {\\n        dfs_2(edges, visited, scc, edge);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2385651,
                "title": "c-dfs-hash-map-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    void dfs(vector<int>& edges,vector<int>& vis,int i,int& cnt,int temp,int req){\\n        if(i==-1){\\n             return ;\\n        }\\n       if(vis[i]){\\n         if(mp.find(i)!=mp.end())  cnt=max(cnt,temp-mp[i]);\\n           return;\\n       }\\n        mp[i]=temp;\\n       vis[i]=1;\\n        dfs(edges,vis,edges[i],cnt,temp+1,req);\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        \\n        int cnt=INT_MIN;\\n        \\n          vector<int> vis(edges.size(),0);\\n        \\n      for(int i=0;i<edges.size();i++){\\n          mp.clear();\\n            if(!vis[i]) dfs(edges,vis,i,cnt,0,i);\\n      }\\n        if(cnt==INT_MIN) return -1;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    void dfs(vector<int>& edges,vector<int>& vis,int i,int& cnt,int temp,int req){\\n        if(i==-1){\\n             return ;\\n        }\\n       if(vis[i]){\\n         if(mp.find(i)!=mp.end())  cnt=max(cnt,temp-mp[i]);\\n           return;\\n       }\\n        mp[i]=temp;\\n       vis[i]=1;\\n        dfs(edges,vis,edges[i],cnt,temp+1,req);\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        \\n        int cnt=INT_MIN;\\n        \\n          vector<int> vis(edges.size(),0);\\n        \\n      for(int i=0;i<edges.size();i++){\\n          mp.clear();\\n            if(!vis[i]) dfs(edges,vis,i,cnt,0,i);\\n      }\\n        if(cnt==INT_MIN) return -1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373639,
                "title": "c-simple-dsf-o-n-time-o-2n-space",
                "content": "approch is to maitain a vector of time and a integer current time(ct) \\nthe time array will determine at what time the  node is visited in current dsf\\nand\\n**if we get a cycle maximise the ans with ct-time[i]**\\n```\\nclass Solution {\\npublic:\\n    void dsf(int i,vector<int>& e,vector<int>& vis,vector<int>& time,int &ans,int ct){\\n        vis[i]++;\\n        time[i]=ct++;\\n        int j=e[i];\\n        if(j==-1){ time[i]=0;return;}\\n        if(!vis[j]) dsf(j,e,vis,time,ans,ct);\\n        else if(time[j]) {\\n            ans=max(ans,ct-time[j]);\\n            time[j]=0;\\n            return;\\n        }\\n        time[i]=0;\\n        return;\\n    }\\n    int longestCycle(vector<int>& e) {\\n     vector<int> vis(1e5+1,0);\\n     vector<int> time(1e5+1,0);\\n        int ct=1;\\n        int ans=-1;\\n        for(int i=0;i<e.size();i++){\\n            if(!vis[i]){\\n                dsf(i,e,vis,time,ans,ct);\\n            }\\n            \\n        }\\n        if(ans==-1) return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dsf(int i,vector<int>& e,vector<int>& vis,vector<int>& time,int &ans,int ct){\\n        vis[i]++;\\n        time[i]=ct++;\\n        int j=e[i];\\n        if(j==-1){ time[i]=0;return;}\\n        if(!vis[j]) dsf(j,e,vis,time,ans,ct);\\n        else if(time[j]) {\\n            ans=max(ans,ct-time[j]);\\n            time[j]=0;\\n            return;\\n        }\\n        time[i]=0;\\n        return;\\n    }\\n    int longestCycle(vector<int>& e) {\\n     vector<int> vis(1e5+1,0);\\n     vector<int> time(1e5+1,0);\\n        int ct=1;\\n        int ans=-1;\\n        for(int i=0;i<e.size();i++){\\n            if(!vis[i]){\\n                dsf(i,e,vis,time,ans,ct);\\n            }\\n            \\n        }\\n        if(ans==-1) return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372051,
                "title": "c-solution",
                "content": "```\\nvoid check(int* edges, int* used, int start, int* count, int k, int* max){\\n    if (k == -1){\\n        return;\\n    }\\n    if (used[k] != 0){\\n        if (used[k] >= start){\\n            if (*count - used[k] > *max){\\n                *max = *count - used[k];\\n            }\\n        }\\n        return;\\n    }\\n    used[k] = *count;\\n    *count += 1;\\n    check(edges, used, start, count, edges[k], max);\\n}\\n\\nint longestCycle(int* edges, int edgesSize){\\n    int* used = calloc(edgesSize,sizeof(int));\\n    int max = -1;\\n    int start = 1;\\n    int count = 1;\\n    for (int i = 0 ; i < edgesSize ; i++){\\n        if (used[i] == 0){\\n            used[i] = count;\\n            start = count;\\n            count++;\\n            check(edges, used, start, &count, edges[i], &max);\\n        }\\n    }\\n    free(used);\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid check(int* edges, int* used, int start, int* count, int k, int* max){\\n    if (k == -1){\\n        return;\\n    }\\n    if (used[k] != 0){\\n        if (used[k] >= start){\\n            if (*count - used[k] > *max){\\n                *max = *count - used[k];\\n            }\\n        }\\n        return;\\n    }\\n    used[k] = *count;\\n    *count += 1;\\n    check(edges, used, start, count, edges[k], max);\\n}\\n\\nint longestCycle(int* edges, int edgesSize){\\n    int* used = calloc(edgesSize,sizeof(int));\\n    int max = -1;\\n    int start = 1;\\n    int count = 1;\\n    for (int i = 0 ; i < edgesSize ; i++){\\n        if (used[i] == 0){\\n            used[i] = count;\\n            start = count;\\n            count++;\\n            check(edges, used, start, &count, edges[i], &max);\\n        }\\n    }\\n    free(used);\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2364851,
                "title": "c-toposort-approach-explained",
                "content": "Edit : \\nWrote this solution back in August 2022 and solved this problem again today. Obviously Topo did not strike me first, did with simple dfs. Went through previous submissions and found out the toposort approach. Back then I only posted the code so lets add an explanation today. \\n\\nWhat is toposort ? \\nSimply speaking toposort is a linear ordering of vertices. The special idea behind the ordering is that vertex u will come before vertex v if there is a direct edge from u to v.\\n\\nNow the major question that arises is Why toposort and how ? \\nFirst we are not using topo in its original form its, modified for the problem. The problem has a special assumption of having atmost one outgoing edge for every node and I think that is the reason why toposort works here. Correct me if I am wrong. \\n\\nWe are using topo sort to break edges and after complete iteration, you will be left with only components having cycles. Amazing right !!\\n\\nThe reason of its working is hidden in the algo itself. So we first put all nodes having inDegree 0 in a queue that is they have no incoming edges. \\nThen for every node in queue we go to is child and decrement it s degree by 1 depicting the removal of edge. If the childs indegree becomes 0 then we push it in the queue as well.\\nNow the crucial observation here is that every node in queue has indegree 0. \\n\\n\\nAnd here comes the magic, for every node occuring in a cycle they will never go under this process, that is none on the node in cycle will be put inside queue. \\nBecause indegree of any node in cycle won\\'t come down to 0.\\n\\nThis a bit intuitive. You can try out with different graph and see that at last you will only have components with cycle in it. \\n\\nThis is because of the inherit nature of graph cycles and their recursive dependency. \\n\\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size(); \\n        vector<int>graph[n]; \\n        vector<int>deg(n,0);\\n        for(int i = 0 ; i < n ; i++){\\n            if(edges[i] == -1) continue ; \\n            graph[i].push_back(edges[i]);\\n            deg[edges[i]]++ ;\\n        }\\n        \\n        queue<int>q; \\n        for(int i = 0 ; i < n ; i++){\\n            if(!deg[i])\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int f = q.front(); \\n            q.pop(); \\n            \\n            for(auto x : graph[f]){\\n                deg[x]-- ; \\n                if(!deg[x])\\n                    q.push(x);\\n            }\\n        }\\n        \\n        int ans = -1 ;\\n        vector<int>vis(n,0); \\n        for(int i = 0 ; i < n ; i++){\\n            if(vis[i]) continue ; \\n            if(!deg[i]) continue ; \\n            int cur = 1 ; \\n            int crawl = graph[i][0] ;\\n            while(crawl != i){\\n                cur++ ; \\n                crawl = graph[crawl][0] ;\\n                vis[crawl] = 1 ;\\n            }\\n            ans = max(ans,cur); \\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size(); \\n        vector<int>graph[n]; \\n        vector<int>deg(n,0);\\n        for(int i = 0 ; i < n ; i++){\\n            if(edges[i] == -1) continue ; \\n            graph[i].push_back(edges[i]);\\n            deg[edges[i]]++ ;\\n        }\\n        \\n        queue<int>q; \\n        for(int i = 0 ; i < n ; i++){\\n            if(!deg[i])\\n                q.push(i);\\n        }\\n        \\n        while(!q.empty()){\\n            int f = q.front(); \\n            q.pop(); \\n            \\n            for(auto x : graph[f]){\\n                deg[x]-- ; \\n                if(!deg[x])\\n                    q.push(x);\\n            }\\n        }\\n        \\n        int ans = -1 ;\\n        vector<int>vis(n,0); \\n        for(int i = 0 ; i < n ; i++){\\n            if(vis[i]) continue ; \\n            if(!deg[i]) continue ; \\n            int cur = 1 ; \\n            int crawl = graph[i][0] ;\\n            while(crawl != i){\\n                cur++ ; \\n                crawl = graph[crawl][0] ;\\n                vis[crawl] = 1 ;\\n            }\\n            ans = max(ans,cur); \\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363611,
                "title": "c-simple-iterative-dfs-beat-100-00-time-and-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int res = -1, count = -2;\\n        for (int i = 0; i < edges.size(); ++i) {\\n\\t\\t\\t// skip if dead end or visited\\n            if (edges[i] < 0) continue;\\n            \\n            int cur = i, prev = i;\\n            int og_count = count;\\n\\t\\t\\t// until dead end or visited\\n            while (edges[cur] >= 0) {\\n                prev = cur;\\n                cur = edges[cur];\\n                edges[prev] = count--;\\n            }\\n            \\n\\t\\t\\t// check if is loop\\n            if (edges[cur] <= og_count) {\\n                res = max(res, edges[cur] - edges[prev] + 1);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int res = -1, count = -2;\\n        for (int i = 0; i < edges.size(); ++i) {\\n\\t\\t\\t// skip if dead end or visited\\n            if (edges[i] < 0) continue;\\n            \\n            int cur = i, prev = i;\\n            int og_count = count;\\n\\t\\t\\t// until dead end or visited\\n            while (edges[cur] >= 0) {\\n                prev = cur;\\n                cur = edges[cur];\\n                edges[prev] = count--;\\n            }\\n            \\n\\t\\t\\t// check if is loop\\n            if (edges[cur] <= og_count) {\\n                res = max(res, edges[cur] - edges[prev] + 1);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362801,
                "title": "c-dfs-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    void dfs(int src, vector<int>& vis, vector<int>& at, vector<int> adj[], int& maxi, int& time)\\n    {\\n        for(auto it : adj[src])\\n        {\\n            if(!vis[it])\\n            {\\n                vis[it]=1;\\n                at[it]=time++;\\n                dfs(it, vis, at, adj, maxi, time);\\n                vis[it]=2;\\n            }\\n            else if(vis[it]==1)\\n                maxi=max(maxi, time-at[it]);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) \\n    {\\n        int n=edges.size();\\n        vector<int> adj[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            if(edges[i]!=-1)\\n                adj[i].push_back(edges[i]);\\n        }\\n        vector<int> vis(n,0), at(n,0);\\n        int time=0, maxi=-1;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {   vis[i]=1;\\n                at[i]=time++;\\n                dfs(i, vis, at, adj, maxi, time);\\n                vis[i]=2;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void dfs(int src, vector<int>& vis, vector<int>& at, vector<int> adj[], int& maxi, int& time)\\n    {\\n        for(auto it : adj[src])\\n        {\\n            if(!vis[it])\\n            {\\n                vis[it]=1;\\n                at[it]=time++;\\n                dfs(it, vis, at, adj, maxi, time);\\n                vis[it]=2;\\n            }\\n            else if(vis[it]==1)\\n                maxi=max(maxi, time-at[it]);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) \\n    {\\n        int n=edges.size();\\n        vector<int> adj[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            if(edges[i]!=-1)\\n                adj[i].push_back(edges[i]);\\n        }\\n        vector<int> vis(n,0), at(n,0);\\n        int time=0, maxi=-1;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(!vis[i])\\n            {   vis[i]=1;\\n                at[i]=time++;\\n                dfs(i, vis, at, adj, maxi, time);\\n                vis[i]=2;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359551,
                "title": "c-solution-time-o-n-memory-o-n-recursive-dfs",
                "content": "```C#\\npublic class Solution {\\n    public int LongestCycle(int[] edges) {\\n        var gd = new Dictionary<int, int>();\\n        var d = new Dictionary<int, int>();\\n\\n        int ans = 0;\\n        for (int i = 0; i < edges.Length; i++)\\n        {\\n            if (!gd.ContainsKey(i))\\n            {\\n                d.Clear();\\n                ans = Math.Max(ans, Solve(i, 0));\\n            }\\n        }\\n\\n        if (ans == 0) return -1;\\n        return ans;\\n        int Solve(int position, int depth)\\n        {\\n            if (position == -1) return 0;\\n            if (gd.ContainsKey(position)) return gd[position];\\n            if (d.ContainsKey(position)) return depth - d[position];\\n\\n            d[position] = depth;\\n\\n            var res = Solve(edges[position], depth + 1);\\n            gd[position] = res;\\n\\n            return res;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int LongestCycle(int[] edges) {\\n        var gd = new Dictionary<int, int>();\\n        var d = new Dictionary<int, int>();\\n\\n        int ans = 0;\\n        for (int i = 0; i < edges.Length; i++)\\n        {\\n            if (!gd.ContainsKey(i))\\n            {\\n                d.Clear();\\n                ans = Math.Max(ans, Solve(i, 0));\\n            }\\n        }\\n\\n        if (ans == 0) return -1;\\n        return ans;\\n        int Solve(int position, int depth)\\n        {\\n            if (position == -1) return 0;\\n            if (gd.ContainsKey(position)) return gd[position];\\n            if (d.ContainsKey(position)) return depth - d[position];\\n\\n            d[position] = depth;\\n\\n            var res = Solve(edges[position], depth + 1);\\n            gd[position] = res;\\n\\n            return res;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359457,
                "title": "bfs-topological-sort-to-find-cycle-google-asked-questions-c-easy-solution",
                "content": "\\tint longestCycle(vector<int>& e) {\\n        int n = e.size();\\n        \\n        vector<int> adj[n];\\n        vector<int> indeg(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(e[i]!=-1)\\n            {\\n                adj[i].push_back(e[i]);\\n                indeg[e[i]]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        vector<int> visi(n);\\n        \\n        while(q.size())\\n        {\\n            int top = q.front();\\n            q.pop();\\n            visi[top] = 1;\\n            for(auto it:adj[top])\\n            {\\n                if(!visi[it])\\n                {\\n                    indeg[it]--;\\n                    if(indeg[it]==0)\\n                    {\\n                        visi[it] = 1;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        }\\n        int len = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(!visi[i])\\n            {\\n                queue<int> q;\\n                q.push(i);\\n                int count = 0;\\n                while(q.size())\\n                {\\n                    int top = q.front();\\n                    q.pop();\\n                    count++;\\n                    visi[top] = 1;\\n                    for(auto it:adj[top])\\n                    {\\n                        if(!visi[it])\\n                        {\\n                            q.push(it);\\n                            visi[it] = 1;\\n                        }\\n                    }\\n                }\\n                len = max(len,count);\\n            }\\n        }\\n        return len==INT_MIN?-1:len;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "\\tint longestCycle(vector<int>& e) {\\n        int n = e.size();\\n        \\n        vector<int> adj[n];\\n        vector<int> indeg(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(e[i]!=-1)\\n            {\\n                adj[i].push_back(e[i]);\\n                indeg[e[i]]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(indeg[i]==0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n        vector<int> visi(n);\\n        \\n        while(q.size())\\n        {\\n            int top = q.front();\\n            q.pop();\\n            visi[top] = 1;\\n            for(auto it:adj[top])\\n            {\\n                if(!visi[it])\\n                {\\n                    indeg[it]--;\\n                    if(indeg[it]==0)\\n                    {\\n                        visi[it] = 1;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        }\\n        int len = INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(!visi[i])\\n            {\\n                queue<int> q;\\n                q.push(i);\\n                int count = 0;\\n                while(q.size())\\n                {\\n                    int top = q.front();\\n                    q.pop();\\n                    count++;\\n                    visi[top] = 1;\\n                    for(auto it:adj[top])\\n                    {\\n                        if(!visi[it])\\n                        {\\n                            q.push(it);\\n                            visi[it] = 1;\\n                        }\\n                    }\\n                }\\n                len = max(len,count);\\n            }\\n        }\\n        return len==INT_MIN?-1:len;",
                "codeTag": "Unknown"
            },
            {
                "id": 2359451,
                "title": "javascript-dfs-100-runtime-memory",
                "content": "```\\n/**\\n * @param {number[]} edges\\n * @return {number}\\n */\\nvar longestCycle = function(edges) {\\n  let visited = new Set();\\n  let longest = -1;\\n  for(let i = 0; i < edges.length; i++) {\\n    let session = new Map();\\n    \\n    let curCycleLen = isCyclic(edges, visited, session, i, 0);\\n    if(curCycleLen > longest) longest = curCycleLen;\\n  }\\n  return longest;\\n};\\n\\n// if cyclic, return length of cycle, else return -1\\nfunction isCyclic(edges, visited, session, key, len) {\\n  // total length - length of non cyclic part\\n  if(session.has(key)) return len-session.get(key);\\n  if(visited.has(key)) return -1;\\n  \\n  session.set(key, len);\\n  visited.add(key);\\n  \\n  if(edges[key] >= 0) return isCyclic(edges, visited, session, edges[key], len+1);\\n  \\n  session.delete(key);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} edges\\n * @return {number}\\n */\\nvar longestCycle = function(edges) {\\n  let visited = new Set();\\n  let longest = -1;\\n  for(let i = 0; i < edges.length; i++) {\\n    let session = new Map();\\n    \\n    let curCycleLen = isCyclic(edges, visited, session, i, 0);\\n    if(curCycleLen > longest) longest = curCycleLen;\\n  }\\n  return longest;\\n};\\n\\n// if cyclic, return length of cycle, else return -1\\nfunction isCyclic(edges, visited, session, key, len) {\\n  // total length - length of non cyclic part\\n  if(session.has(key)) return len-session.get(key);\\n  if(visited.has(key)) return -1;\\n  \\n  session.set(key, len);\\n  visited.add(key);\\n  \\n  if(edges[key] >= 0) return isCyclic(edges, visited, session, edges[key], len+1);\\n  \\n  session.delete(key);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2358561,
                "title": "c-kosaraju-algorithm-dfs",
                "content": "Main idea : source component of original graph will become sink component in reverse graph\\nfor more info : https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm\\n```\\nclass Solution {\\npublic:\\n    \\n    stack<int> s; // to store topological order\\n    \\n    vector<bool> visited;\\n    \\n    int cnt = 0;\\n    \\n    void dfs( int vertex, vector<int> g[]){\\n        cnt++;\\n        visited[vertex] = true;\\n        for(int nbr:g[vertex]){\\n            if(visited[nbr]==false){\\n                dfs( nbr, g );\\n            }\\n        }\\n        s.push(vertex); // storing topological order\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {    \\n\\t\\n        visited.resize(100001,false);\\n\\t\\t\\n        int n = (int) edges.size();\\n\\t\\t\\n\\t\\t// creating given graph and its reverse graph\\n        vector<int> g[n],rg[n];\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n\\t\\t{\\n            if(edges[i]!=-1)\\n\\t\\t\\t{\\n                g[i].push_back(edges[i]);\\n                rg[edges[i]].push_back(i);\\n            }\\n        }\\n        \\n\\t\\t// dfs on given graph to find topological order\\n        for(int i=0;i<n;i++)\\n\\t\\t{\\n            if(visited[i]==false){\\n                dfs(i,g);\\n            }\\n        }\\n\\t\\t\\n        visited.clear();\\n        visited.resize(100001,false); // for next dfs\\n\\t\\t\\n        int ans = 0;\\n\\t\\t\\n        while(s.size())\\n\\t\\t{\\n            int ele = s.top(); s.pop();\\n\\t\\t\\t\\n            if(visited[ele]) continue; \\n\\t\\t\\t\\n\\t\\t\\t// finding the number of nodes in strongly connected component\\n\\t\\t\\t\\n            cnt = 0;\\n\\t\\t\\t\\n            dfs(ele,rg);\\n\\t\\t\\t\\n            ans = max(ans,cnt);\\n\\t\\t\\t\\n        }\\n\\t\\t\\n\\t\\t// minimum number of nodes in any strongly connected component is 1 but it will not form a cycle\\n        if(ans==1) ans=-1;\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    stack<int> s; // to store topological order\\n    \\n    vector<bool> visited;\\n    \\n    int cnt = 0;\\n    \\n    void dfs( int vertex, vector<int> g[]){\\n        cnt++;\\n        visited[vertex] = true;\\n        for(int nbr:g[vertex]){\\n            if(visited[nbr]==false){\\n                dfs( nbr, g );\\n            }\\n        }\\n        s.push(vertex); // storing topological order\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {    \\n\\t\\n        visited.resize(100001,false);\\n\\t\\t\\n        int n = (int) edges.size();\\n\\t\\t\\n\\t\\t// creating given graph and its reverse graph\\n        vector<int> g[n],rg[n];\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n\\t\\t{\\n            if(edges[i]!=-1)\\n\\t\\t\\t{\\n                g[i].push_back(edges[i]);\\n                rg[edges[i]].push_back(i);\\n            }\\n        }\\n        \\n\\t\\t// dfs on given graph to find topological order\\n        for(int i=0;i<n;i++)\\n\\t\\t{\\n            if(visited[i]==false){\\n                dfs(i,g);\\n            }\\n        }\\n\\t\\t\\n        visited.clear();\\n        visited.resize(100001,false); // for next dfs\\n\\t\\t\\n        int ans = 0;\\n\\t\\t\\n        while(s.size())\\n\\t\\t{\\n            int ele = s.top(); s.pop();\\n\\t\\t\\t\\n            if(visited[ele]) continue; \\n\\t\\t\\t\\n\\t\\t\\t// finding the number of nodes in strongly connected component\\n\\t\\t\\t\\n            cnt = 0;\\n\\t\\t\\t\\n            dfs(ele,rg);\\n\\t\\t\\t\\n            ans = max(ans,cnt);\\n\\t\\t\\t\\n        }\\n\\t\\t\\n\\t\\t// minimum number of nodes in any strongly connected component is 1 but it will not form a cycle\\n        if(ans==1) ans=-1;\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358450,
                "title": "java-dfs-using-two-visited-tracker",
                "content": "Usually we use a List<>[] to store each Vertex\\'s neighbors. however, since in this problem, each node has at** most one outgoing edge**, we can skip this step.\\n\\nPseudocode:\\nWe are using a boolean[]` visited` to store global visit status : \\n1. Iterate the node from 0 to n-1\\n2. if the node didn\\'t visited yet, launch the dfs\\n3. compare the res and dfs output, keep the biggest one\\n\\n##### DFS Part\\nWe are using a HashMap` loopIdx` to store local visit status : \\nKey[node number]: Value[its position start from the beginning node]\\n1. if we can found `n` in ` loopIdx` --> loop founded! `return count - position of n`\\n2. if `n == -1` --> we meet the end, no loop founded. `return -1`\\n3. if n is true in global node visited --> Either there is a loop or not, we have visited and recorded already, break the dfs;\\n\\n```\\nclass Solution {\\n    private static boolean[] visited;\\n    \\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        int res = -1;\\n        visited = new boolean[n];\\n        for (int i = 0; i < n; i++){\\n            if (visited[i]) continue;\\n            res = Math.max(res, dfs(edges, i, 0, new HashMap<Integer, Integer>()));\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(int[] e, int n, int count, HashMap<Integer, Integer> loopIdx) {\\n        if (loopIdx.containsKey(n)) {\\n            return count - loopIdx.get(n);\\n        } \\n        if (n == -1) return -1;\\n        if (visited[n]) return -1;\\n        \\n        visited[n] = true;\\n        loopIdx.put(n, count);\\n        return dfs(e, e[n], count+1, loopIdx);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private static boolean[] visited;\\n    \\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        int res = -1;\\n        visited = new boolean[n];\\n        for (int i = 0; i < n; i++){\\n            if (visited[i]) continue;\\n            res = Math.max(res, dfs(edges, i, 0, new HashMap<Integer, Integer>()));\\n        }\\n        return res;\\n    }\\n    \\n    private int dfs(int[] e, int n, int count, HashMap<Integer, Integer> loopIdx) {\\n        if (loopIdx.containsKey(n)) {\\n            return count - loopIdx.get(n);\\n        } \\n        if (n == -1) return -1;\\n        if (visited[n]) return -1;\\n        \\n        visited[n] = true;\\n        loopIdx.put(n, count);\\n        return dfs(e, e[n], count+1, loopIdx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358373,
                "title": "dfs-100-faster",
                "content": "```\\nclass Solution\\n{\\npublic:\\n  int ans = -1;\\n  int ACTIVENODE = 1;\\n  int PASSIVENODE = 2;\\n  void dfs(int node, int depth, vector<int> &dis, vector<int> &vis, vector<vector<int>> &graph)\\n  {\\n    if (vis[node] == ACTIVENODE)\\n    {\\n      ans = max(ans, depth - dis[node]);\\n      return;\\n    }\\n\\n    if (vis[node] == PASSIVENODE) // no point of going deep into this\\n      return;\\n\\n    //     Going into graph mark as active node\\n    vis[node] = ACTIVENODE;\\n    dis[node] = depth;\\n    for (auto child : graph[node])\\n    {\\n      dfs(child, depth + 1, dis, vis, graph);\\n    }\\n    //     Backtracking mark as 2 for all the nodes\\n    vis[node] = 2;\\n  }\\n  int longestCycle(vector<int> &edges)\\n  {\\n    int n = edges.size();\\n    vector<vector<int>> graph(n);\\n    vector<int> dis(n, 0);\\n    vector<int> vis(n, 0);\\n    for (int i = 0; i < n; i++)\\n    {\\n      if (edges[i] != -1)\\n      {\\n        graph[i].push_back(edges[i]);\\n      }\\n    }\\n    for (int i = 0; i < n; i++)\\n    {\\n      dfs(i, 0, dis, vis, graph);\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int ans = -1;\\n  int ACTIVENODE = 1;\\n  int PASSIVENODE = 2;\\n  void dfs(int node, int depth, vector<int> &dis, vector<int> &vis, vector<vector<int>> &graph)\\n  {\\n    if (vis[node] == ACTIVENODE)\\n    {\\n      ans = max(ans, depth - dis[node]);\\n      return;\\n    }\\n\\n    if (vis[node] == PASSIVENODE) // no point of going deep into this\\n      return;\\n\\n    //     Going into graph mark as active node\\n    vis[node] = ACTIVENODE;\\n    dis[node] = depth;\\n    for (auto child : graph[node])\\n    {\\n      dfs(child, depth + 1, dis, vis, graph);\\n    }\\n    //     Backtracking mark as 2 for all the nodes\\n    vis[node] = 2;\\n  }\\n  int longestCycle(vector<int> &edges)\\n  {\\n    int n = edges.size();\\n    vector<vector<int>> graph(n);\\n    vector<int> dis(n, 0);\\n    vector<int> vis(n, 0);\\n    for (int i = 0; i < n; i++)\\n    {\\n      if (edges[i] != -1)\\n      {\\n        graph[i].push_back(edges[i]);\\n      }\\n    }\\n    for (int i = 0; i < n; i++)\\n    {\\n      dfs(i, 0, dis, vis, graph);\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358347,
                "title": "c-dfs-faster-than-100-solutions-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// Node stores the index which we have already seen in the cycle\\n    int cycle = 0, ans = INT_MIN, node;\\n\\t\\n    bool DFS(int i, vector<bool> &visited, vector<bool> &currVisited, vector<vector<int>> &graph){\\n        visited[i] = true;\\n        currVisited[i] = true;\\n\\t\\t\\n\\t\\t// Traversing through the adjacent vertices\\n        for(auto adj: graph[i]){\\n\\t\\t\\t// Not visited\\n            if(!visited[adj]){\\n\\t\\t\\t\\t// Cycle found in its adjacent vertices\\n                if(DFS(adj, visited, currVisited, graph) && node != i){\\n                    cycle++;\\n\\t\\t\\t\\t\\tcurrVisited[i] = false;\\n                    return true;\\n                }\\n\\t\\t\\t\\t// Last node in the cycle\\n                else{\\n\\t\\t\\t\\t\\tcurrVisited[i] = false;\\n                    return false;\\n                }\\n            }\\n            // Cycle found\\n            else if(visited[adj] && currVisited[adj]){\\n                cycle++;\\n                node = adj;\\n\\t\\t\\t\\tcurrVisited[i] = false;\\n                return true;\\n            }\\n        }\\n        currVisited[i] = false;\\n        return false;\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n\\t\\t// Create adjacency list from the given edges\\n        vector<vector<int>> graph(edges.size());\\n        for(int i=0; i<edges.size(); i++){\\n            if(edges[i] == -1){\\n                continue;\\n            }\\n            graph[i].push_back(edges[i]);\\n        }\\n        \\n        vector<bool> visited(edges.size(), false);\\n        vector<bool> currVisited(edges.size(), false);\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            if(!visited[i]){\\n                DFS(i, visited, currVisited, graph);\\n\\t\\t\\t\\t// Cycle found\\n                if(cycle != 0){\\n                    ans = max(ans, cycle+1);\\n                    cycle = 0;\\n                }\\n            }\\n        }\\n        \\n        return ans == INT_MIN ? -1 : ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// Node stores the index which we have already seen in the cycle\\n    int cycle = 0, ans = INT_MIN, node;\\n\\t\\n    bool DFS(int i, vector<bool> &visited, vector<bool> &currVisited, vector<vector<int>> &graph){\\n        visited[i] = true;\\n        currVisited[i] = true;\\n\\t\\t\\n\\t\\t// Traversing through the adjacent vertices\\n        for(auto adj: graph[i]){\\n\\t\\t\\t// Not visited\\n            if(!visited[adj]){\\n\\t\\t\\t\\t// Cycle found in its adjacent vertices\\n                if(DFS(adj, visited, currVisited, graph) && node != i){\\n                    cycle++;\\n\\t\\t\\t\\t\\tcurrVisited[i] = false;\\n                    return true;\\n                }\\n\\t\\t\\t\\t// Last node in the cycle\\n                else{\\n\\t\\t\\t\\t\\tcurrVisited[i] = false;\\n                    return false;\\n                }\\n            }\\n            // Cycle found\\n            else if(visited[adj] && currVisited[adj]){\\n                cycle++;\\n                node = adj;\\n\\t\\t\\t\\tcurrVisited[i] = false;\\n                return true;\\n            }\\n        }\\n        currVisited[i] = false;\\n        return false;\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n\\t\\t// Create adjacency list from the given edges\\n        vector<vector<int>> graph(edges.size());\\n        for(int i=0; i<edges.size(); i++){\\n            if(edges[i] == -1){\\n                continue;\\n            }\\n            graph[i].push_back(edges[i]);\\n        }\\n        \\n        vector<bool> visited(edges.size(), false);\\n        vector<bool> currVisited(edges.size(), false);\\n        \\n        for(int i=0; i<edges.size(); i++){\\n            if(!visited[i]){\\n                DFS(i, visited, currVisited, graph);\\n\\t\\t\\t\\t// Cycle found\\n                if(cycle != 0){\\n                    ans = max(ans, cycle+1);\\n                    cycle = 0;\\n                }\\n            }\\n        }\\n        \\n        return ans == INT_MIN ? -1 : ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2357782,
                "title": "simple-dfs-java-solution",
                "content": "\\n\\n`\\nclass Solution {\\n    \\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        int ans = -1;\\n        boolean[] visited = new boolean[n];\\n        for(int i = 0 ; i < n ; i++){\\n            if(visited[i])continue;\\n            HashMap<Integer , Integer> d = new HashMap<>();\\n            // visited[i] = true;\\n            // d.put(i , 0);\\n            int x = dfs(edges , i , 0 , visited ,i , d);\\n            if(x != -1)ans = Math.max(ans , x);\\n        }\\n        return ans;\\n    }\\n    public int dfs(int[] edges , int node , int dis , boolean[] visited , int start ,HashMap<Integer , Integer> d ){\\n        if(node == -1)return -1;\\n        // if(node == start)return dis;\\n        if(visited[node] ){\\n            if(!d.containsKey(node))return -1;\\n            return dis - d.get(node);\\n        }\\n        visited[node] = true;\\n        d.put(node , dis);\\n        return dfs(edges , edges[node] , dis+1 , visited ,start ,d);\\n        \\n    }\\n}`",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    \\n    public int longestCycle(int[] edges) {\\n        int n = edges.length;\\n        int ans = -1;\\n        boolean[] visited = new boolean[n];\\n        for(int i = 0 ; i < n ; i++){\\n            if(visited[i])continue;\\n            HashMap<Integer , Integer> d = new HashMap<>();\\n            // visited[i] = true;\\n            // d.put(i , 0);\\n            int x = dfs(edges , i , 0 , visited ,i , d);\\n            if(x != -1)ans = Math.max(ans , x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2357718,
                "title": "c-tri-color-coding",
                "content": "**Intuition**\\nThis is a typical cycle problem in digraph. We can find it via dfs. \\nWe color the node in 3 ways\\n1) Those that haven\\'t been seen are -1; \\n2) Those that have been seen are 0; \\n3) Those that are being seen in the current check are positive numbers. \\n\\nIf the same node are seen again in the current check, the difference of the current number and its seen number is a candidate for the cycle size. Find the largest of such difference. \\n\\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int ans = -1, n = edges.size(); \\n        vector<int> dist(n, -1); \\n        \\n        function<void(int, int)> dfs = [&](int u, int val) {\\n            if (u != -1) {\\n                if (dist[u] == -1) {\\n                    dist[u] = val; \\n                    dfs(edges[u], val+1); \\n                } else if (dist[u] > 0) \\n                    ans = max(ans, val-dist[u]); // cycle found\\n                dist[u] = 0; \\n            }\\n        }; \\n        \\n        for (int i = 0; i < n; ++i) dfs(i, 1); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int ans = -1, n = edges.size(); \\n        vector<int> dist(n, -1); \\n        \\n        function<void(int, int)> dfs = [&](int u, int val) {\\n            if (u != -1) {\\n                if (dist[u] == -1) {\\n                    dist[u] = val; \\n                    dfs(edges[u], val+1); \\n                } else if (dist[u] > 0) \\n                    ans = max(ans, val-dist[u]); // cycle found\\n                dist[u] = 0; \\n            }\\n        }; \\n        \\n        for (int i = 0; i < n; ++i) dfs(i, 1); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862459,
                "title": "easy-topo-sort-dfs-c",
                "content": "# Intuition\\nas we know that using kahn\\'s algo for topo sort gives only those nodes which are not a part of cycle so the remaining nodes are a part of cycle it means so we can run a dfs on all the rest nodes and more thing since one node can have atmost one outgoing edge it means it can be a part of max one cycle so we can just call dfs and store the lenght for each node and update the ans\\n\\n# Approach\\nfirst find the toposort after that run a dfs on all remaining and unvisited nodes and update the ans\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   // for counting the size of the cycle \\n   bool dfs(int node,vector<int> &vis, vector<int> adj[],int &count){\\n       vis[node]=1;\\n       count++;\\n       for(int child:adj[node]){\\n           if(!vis[child]){\\n               if(dfs(child,vis,adj,count)){\\n                   return true;\\n               }\\n           }\\n           else{\\n              if(vis[node]==1){\\n                  return true;\\n              }\\n           }\\n       }\\n       vis[node]=2;\\n       return false;   \\n   }\\n\\n\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for(int i=0; i<n; i++){\\n            int x=edges[i];\\n            if(x!=-1){\\n                adj[i].push_back(x);\\n                indegree[x]++;\\n            }\\n        }\\n// finding the toposort \\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        vector<int> v;\\n        while(!q.empty()){\\n            int node=q.front();\\n            v.push_back(node);\\n            q.pop();\\n            for(int child:adj[node]){\\n                indegree[child]--;\\n                if(indegree[child]==0){\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        if(v.size()==n){\\n            return -1;\\n        }\\n// marking the nodes which are not part of cycle \\n        map<int,int> m;\\n        for(auto it:v){\\n            m[it]++;\\n        }\\n        vector<int> vis(n,0);\\n// updating the ans\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            if(m.count(i)<1 && !vis[i]){\\n                int count=0;\\n                dfs(i,vis,adj,count);\\n                ans=max(ans,count);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   // for counting the size of the cycle \\n   bool dfs(int node,vector<int> &vis, vector<int> adj[],int &count){\\n       vis[node]=1;\\n       count++;\\n       for(int child:adj[node]){\\n           if(!vis[child]){\\n               if(dfs(child,vis,adj,count)){\\n                   return true;\\n               }\\n           }\\n           else{\\n              if(vis[node]==1){\\n                  return true;\\n              }\\n           }\\n       }\\n       vis[node]=2;\\n       return false;   \\n   }\\n\\n\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> adj[n];\\n        vector<int> indegree(n,0);\\n        for(int i=0; i<n; i++){\\n            int x=edges[i];\\n            if(x!=-1){\\n                adj[i].push_back(x);\\n                indegree[x]++;\\n            }\\n        }\\n// finding the toposort \\n        queue<int> q;\\n        for(int i=0; i<n; i++){\\n            if(indegree[i]==0){\\n                q.push(i);\\n            }\\n        }\\n        vector<int> v;\\n        while(!q.empty()){\\n            int node=q.front();\\n            v.push_back(node);\\n            q.pop();\\n            for(int child:adj[node]){\\n                indegree[child]--;\\n                if(indegree[child]==0){\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        if(v.size()==n){\\n            return -1;\\n        }\\n// marking the nodes which are not part of cycle \\n        map<int,int> m;\\n        for(auto it:v){\\n            m[it]++;\\n        }\\n        vector<int> vis(n,0);\\n// updating the ans\\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            if(m.count(i)<1 && !vis[i]){\\n                int count=0;\\n                dfs(i,vis,adj,count);\\n                ans=max(ans,count);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749546,
                "title": "c-kosaraju-s-algortihm-detailed-explanation-of-algorithm-and-code-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will find all the loops present in the graph, and then loop with the maximum number of components will give the answer, to do so we will use **Kosraju\\'s algorithm**. Kosaraju\\'s algorithm is used to find **strongly connected components**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo implement kosaraju\\'s algorithm we will have to follow three steps:\\n1. **Sort all nodes according to their finishing time**(just like topological sort, but here loops are present in the graph). To do so we will use one stack and we will push nodes in it evertime its dfs gets completed. \\n2. **Reverse all the edges in the graph.** Make a new matrix with reversed edges.\\n3. **Perfom dfs on node according to nodes present in the stack.** dfs will also return number of nodes it traversed, giving number of nodes in that particular loop.We will have one ans variable which will give the maximum number of nodes in the loop.\\n\\n**Please Upvote, it keeps me motivated**\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs2(int index,vector<vector<int>>&edges,vector<int>&visited){\\n        visited[index]=1;\\n        int ans=1;\\n        for(auto val: edges[index]){\\n            if(!visited[val]){\\n                ans+=dfs2(val,edges,visited);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    void dfs(int index, vector<int>&edges, vector<int>&visited, stack<int>&s){\\n        visited[index]=1;\\n        if(edges[index]!=-1 && visited[edges[index]]==0){\\n        dfs(edges[index],edges,visited,s);\\n        }\\n        s.push(index);\\n    }\\n\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int>visited(n,0);\\n        stack<int>s;\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfs(i,edges,visited,s);\\n            }\\n        }\\n\\n\\n        vector<vector<int>>reversed(n);\\n        for(int i=0;i<n;i++){\\n            visited[i]=0;\\n            if(edges[i]!=-1){\\n            reversed[edges[i]].push_back(i);\\n            }\\n        }\\n\\n        int ans=0;\\n        while(!s.empty()){\\n            int curr=s.top();\\n            s.pop();\\n            if(!visited[curr]){\\n                ans=max(ans,dfs2(curr,reversed,visited));\\n            }\\n\\n        }\\n\\n        return ans==1?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs2(int index,vector<vector<int>>&edges,vector<int>&visited){\\n        visited[index]=1;\\n        int ans=1;\\n        for(auto val: edges[index]){\\n            if(!visited[val]){\\n                ans+=dfs2(val,edges,visited);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    void dfs(int index, vector<int>&edges, vector<int>&visited, stack<int>&s){\\n        visited[index]=1;\\n        if(edges[index]!=-1 && visited[edges[index]]==0){\\n        dfs(edges[index],edges,visited,s);\\n        }\\n        s.push(index);\\n    }\\n\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int>visited(n,0);\\n        stack<int>s;\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                dfs(i,edges,visited,s);\\n            }\\n        }\\n\\n\\n        vector<vector<int>>reversed(n);\\n        for(int i=0;i<n;i++){\\n            visited[i]=0;\\n            if(edges[i]!=-1){\\n            reversed[edges[i]].push_back(i);\\n            }\\n        }\\n\\n        int ans=0;\\n        while(!s.empty()){\\n            int curr=s.top();\\n            s.pop();\\n            if(!visited[curr]){\\n                ans=max(ans,dfs2(curr,reversed,visited));\\n            }\\n\\n        }\\n\\n        return ans==1?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505837,
                "title": "c-easiest-way-solved-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(V+E)\\n\\n- Space complexity:\\nO(V);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>&adj,vector<int> &dfsv,int node,int dis,vector<bool>&vis){\\n        dfsv[node] = dis; \\n        vis[node] = 1;\\n        int ans = 0;\\n        int ans2 = 0;\\n        for(auto x:adj[node]){\\n            if(!vis[x]){\\n               ans = max(ans,solve(adj,dfsv,x,dis+1,vis));\\n            }\\n            else if(dfsv[x] != -1){\\n                ans2 = max(ans2,dis - dfsv[x]+1);\\n                // return ans2;\\n\\n            }\\n            \\n        }\\n        dfsv[node] = -1;\\n        return max(ans,ans2);\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<vector<int>>adj(n);\\n        for(int i = 0;i < n;i++){\\n            if(edges[i] != -1)\\n            adj[i].push_back(edges[i]);\\n        }\\n        int ans = 0;\\n        vector<int>dfsv(n);\\n        for(int i= 0;i < n;i++){\\n            dfsv[i] = -1;\\n        }\\n        vector<bool>vis(n,0);\\n        for(int i = 0;i < n;i++){\\n            if(!vis[i]){\\n                ans = max(ans,solve(adj,dfsv,i,0,vis));\\n            }\\n        }\\n        if(ans == 0)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<vector<int>>&adj,vector<int> &dfsv,int node,int dis,vector<bool>&vis){\\n        dfsv[node] = dis; \\n        vis[node] = 1;\\n        int ans = 0;\\n        int ans2 = 0;\\n        for(auto x:adj[node]){\\n            if(!vis[x]){\\n               ans = max(ans,solve(adj,dfsv,x,dis+1,vis));\\n            }\\n            else if(dfsv[x] != -1){\\n                ans2 = max(ans2,dis - dfsv[x]+1);\\n                // return ans2;\\n\\n            }\\n            \\n        }\\n        dfsv[node] = -1;\\n        return max(ans,ans2);\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<vector<int>>adj(n);\\n        for(int i = 0;i < n;i++){\\n            if(edges[i] != -1)\\n            adj[i].push_back(edges[i]);\\n        }\\n        int ans = 0;\\n        vector<int>dfsv(n);\\n        for(int i= 0;i < n;i++){\\n            dfsv[i] = -1;\\n        }\\n        vector<bool>vis(n,0);\\n        for(int i = 0;i < n;i++){\\n            if(!vis[i]){\\n                ans = max(ans,solve(adj,dfsv,i,0,vis));\\n            }\\n        }\\n        if(ans == 0)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349739,
                "title": "python3-really-fast-easy-to-understand-untraditional-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        visited=[0 for i in range(n)]\\n        visit=0\\n        maxlen=-1\\n        for i in range(n):\\n            if visited[i]==1:\\n                continue\\n            cycle=[i]\\n            while visited[cycle[-1]]!=1:\\n                visited[cycle[-1]]=1\\n                cycle.append(edges[cycle[-1]])\\n                visit+=1\\n                if cycle[-1]==-1:\\n                    break\\n            if cycle[-1]==-1:\\n                continue\\n            end = cycle[-1]\\n            m=len(cycle)\\n            #print(cycle)\\n            #print(visited,visit)\\n            for i in cycle:\\n                m-=1\\n                if i==end:\\n                    if m==0:\\n                        break\\n                    maxlen=max(maxlen,m)\\n                    break\\n        return maxlen\\n\\n            \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        visited=[0 for i in range(n)]\\n        visit=0\\n        maxlen=-1\\n        for i in range(n):\\n            if visited[i]==1:\\n                continue\\n            cycle=[i]\\n            while visited[cycle[-1]]!=1:\\n                visited[cycle[-1]]=1\\n                cycle.append(edges[cycle[-1]])\\n                visit+=1\\n                if cycle[-1]==-1:\\n                    break\\n            if cycle[-1]==-1:\\n                continue\\n            end = cycle[-1]\\n            m=len(cycle)\\n            #print(cycle)\\n            #print(visited,visit)\\n            for i in cycle:\\n                m-=1\\n                if i==end:\\n                    if m==0:\\n                        break\\n                    maxlen=max(maxlen,m)\\n                    break\\n        return maxlen\\n\\n            \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345875,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    vector<int> nodes;\\npublic:\\n    void dfs(vector<int>& edges, int src, vector<int>& vis, int& count, vector<int>& dfsVis) {\\n        \\n        if(dfsVis[src]) {\\n            \\n            res = max(res,count-nodes[src]+1);\\n            return;\\n        }\\n        \\n        if(vis[src])return;\\n        \\n        dfsVis[src] = 1;\\n        vis[src] = 1;\\n        \\n        count++;\\n        nodes[src] += count;\\n        \\n        if(edges[src] != -1)dfs(edges,edges[src],vis,count,dfsVis);\\n        \\n        dfsVis[src] = 0;\\n        \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        \\n        int n = size(edges);\\n        nodes.resize(n);\\n        \\n        vector<int> vis(n),dfsVis(n);\\n        \\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(vis[i] == 0)dfs(edges,i,vis,count,dfsVis);\\n        }\\n        \\n        return res == 0 ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    vector<int> nodes;\\npublic:\\n    void dfs(vector<int>& edges, int src, vector<int>& vis, int& count, vector<int>& dfsVis) {\\n        \\n        if(dfsVis[src]) {\\n            \\n            res = max(res,count-nodes[src]+1);\\n            return;\\n        }\\n        \\n        if(vis[src])return;\\n        \\n        dfsVis[src] = 1;\\n        vis[src] = 1;\\n        \\n        count++;\\n        nodes[src] += count;\\n        \\n        if(edges[src] != -1)dfs(edges,edges[src],vis,count,dfsVis);\\n        \\n        dfsVis[src] = 0;\\n        \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        \\n        int n = size(edges);\\n        nodes.resize(n);\\n        \\n        vector<int> vis(n),dfsVis(n);\\n        \\n        for(int i = 0; i < n; i++) {\\n            int count = 0;\\n            if(vis[i] == 0)dfs(edges,i,vis,count,dfsVis);\\n        }\\n        \\n        return res == 0 ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345619,
                "title": "python-simple-linked-list-walk",
                "content": "\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        def walk(cur_node):\\n            steps = 0\\n            seen = {} \\n            while True:\\n                if cur_node in seen:\\n                    return steps - seen[cur_node]    \\n\\n                if edges[cur_node] == -1:\\n                    return -1\\n\\n                seen[cur_node] = steps\\n                next_node = edges[cur_node]\\n                edges[cur_node], cur_node = -1, edges[cur_node]\\n                steps +=1\\n        \\n        return max(map(walk, range(len(edges))))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        def walk(cur_node):\\n            steps = 0\\n            seen = {} \\n            while True:\\n                if cur_node in seen:\\n                    return steps - seen[cur_node]    \\n\\n                if edges[cur_node] == -1:\\n                    return -1\\n\\n                seen[cur_node] = steps\\n                next_node = edges[cur_node]\\n                edges[cur_node], cur_node = -1, edges[cur_node]\\n                steps +=1\\n        \\n        return max(map(walk, range(len(edges))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345540,
                "title": "java-c-find-time-of-entering-well-explained",
                "content": "# Upvote if you liked my Solution\\uD83E\\uDD17\\uD83E\\uDD17\\n\\n# Intuition or Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI took some examples, and found that as each node has **at most one** outgoing edge. So, there will be atmost one cycle present in any connected component.\\n\\nSo, I gave a number `tin` ( time of enter) to each visiting node. If we went to some node and found that this node is visited in the current path. Then we calculate length of cycle as -\\n\\nLets\\' suppose parent node has `tin` as `parTin` and current node have `tin` as `x`, then length of cycle will be `parTin - x + 1`. \\nAnd take maximum each time. \\n\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n\\tint maxi = -1;\\n\\n\\tpublic int longestCycle(int[] edges) {\\n        // vis[i] = 0 / -1 / tin\\n        //  -1 -> not visited \\n        //   0 -> visited earlier but not present in current path \\n        // tin -> a +ve no, which indicates his entering time  \\n        \\n\\t\\tint n = edges.length, vis[] = new int[n];\\n\\t\\tArrays.fill(vis, -1);\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tif (vis[i] == -1)\\n\\t\\t\\t\\tdfs(i, vis, 1, edges);\\n\\t\\treturn maxi;\\n\\t}\\n\\n\\tprivate void dfs(int node, int vis[], int parTin, int edges[]) {\\n\\t\\tif (vis[node] >= 0) {\\n\\t\\t\\tif (vis[node] > 0) maxi = Math.max(maxi, parTin - vis[node] + 1);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvis[node] = parTin + 1;\\n\\t\\tif (edges[node] != -1) dfs(edges[node], vis, parTin + 1, edges);\\n\\t\\tvis[node] = 0;\\n\\t}\\n}\\n```\\n---\\n\\n# C++ Code\\n```\\nclass Solution {\\n    int maxi = -1;\\n\\n    void dfs(int node, vector<int>& vis, int parTin, vector<int>& edges) {\\n        if (vis[node] >= 0) {\\n            if (vis[node] > 0) maxi = max(maxi, parTin - vis[node] + 1);\\n            return;\\n        }\\n        vis[node] = parTin + 1;\\n        if (edges[node] != -1) dfs(edges[node], vis, parTin + 1, edges);\\n        vis[node] = 0;\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        // vis[i] = 0 / -1 / tin\\n        //  -1 -> not visited \\n        //   0 -> visited earlier but not present in current path \\n        // tin -> a +ve no, which indicates his entering time  \\n\\n        int n = edges.size();\\n        vector<int> vis(n, -1);\\n        for (int i = 0; i < n; i++) if (vis[i] == -1) dfs(i, vis, 1, edges);\\n        return maxi;\\n    }\\n};\\n\\n```\\n\\n![upvote-img.jpg](https://assets.leetcode.com/users/images/2af17fc0-43af-4923-86e4-af1b5adc1d92_1679868685.2934465.jpeg)\\n\\n# Dont\\' forget to Upvote if you liked my Solution\\uD83E\\uDD17\\uD83E\\uDD17\\n## Feel free to ask any query, Thanks !\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\n\\tint maxi = -1;\\n\\n\\tpublic int longestCycle(int[] edges) {\\n        // vis[i] = 0 / -1 / tin\\n        //  -1 -> not visited \\n        //   0 -> visited earlier but not present in current path \\n        // tin -> a +ve no, which indicates his entering time  \\n        \\n\\t\\tint n = edges.length, vis[] = new int[n];\\n\\t\\tArrays.fill(vis, -1);\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tif (vis[i] == -1)\\n\\t\\t\\t\\tdfs(i, vis, 1, edges);\\n\\t\\treturn maxi;\\n\\t}\\n\\n\\tprivate void dfs(int node, int vis[], int parTin, int edges[]) {\\n\\t\\tif (vis[node] >= 0) {\\n\\t\\t\\tif (vis[node] > 0) maxi = Math.max(maxi, parTin - vis[node] + 1);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvis[node] = parTin + 1;\\n\\t\\tif (edges[node] != -1) dfs(edges[node], vis, parTin + 1, edges);\\n\\t\\tvis[node] = 0;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n    int maxi = -1;\\n\\n    void dfs(int node, vector<int>& vis, int parTin, vector<int>& edges) {\\n        if (vis[node] >= 0) {\\n            if (vis[node] > 0) maxi = max(maxi, parTin - vis[node] + 1);\\n            return;\\n        }\\n        vis[node] = parTin + 1;\\n        if (edges[node] != -1) dfs(edges[node], vis, parTin + 1, edges);\\n        vis[node] = 0;\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        // vis[i] = 0 / -1 / tin\\n        //  -1 -> not visited \\n        //   0 -> visited earlier but not present in current path \\n        // tin -> a +ve no, which indicates his entering time  \\n\\n        int n = edges.size();\\n        vector<int> vis(n, -1);\\n        for (int i = 0; i < n; i++) if (vis[i] == -1) dfs(i, vis, 1, edges);\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345351,
                "title": "ruby-3-liner",
                "content": "```\\ndef longest_cycle(a) = (s=a.size.times.to_set).map{|i| h={}\\n  i=a[i] while s.delete? i and h[i]=h.size\\n  h[i] ? h.size - h[i] : -1 }.max\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef longest_cycle(a) = (s=a.size.times.to_set).map{|i| h={}\\n  i=a[i] while s.delete? i and h[i]=h.size\\n  h[i] ? h.size - h[i] : -1 }.max\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3345234,
                "title": "easiest-java-solution-ever",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        boolean[] vis = new boolean[edges.length];\\n        int ans= -1;\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            if(!vis[i]){\\n                vis[i] = true;\\n                ans = Math.max(ans, findLength(i, edges, vis));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    public int findLength(int ind, int[] edges, boolean[] vis){\\n        int len = 0;\\n        int temp = ind;\\n        while(len < edges.length){\\n            len++;\\n            if(temp == -1 || !vis[temp])\\n                return -1;\\n            if(edges[temp] == ind)\\n                return len;\\n\\n            temp = edges[temp];\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        boolean[] vis = new boolean[edges.length];\\n        int ans= -1;\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            if(!vis[i]){\\n                vis[i] = true;\\n                ans = Math.max(ans, findLength(i, edges, vis));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n\\n    public int findLength(int ind, int[] edges, boolean[] vis){\\n        int len = 0;\\n        int temp = ind;\\n        while(len < edges.length){\\n            len++;\\n            if(temp == -1 || !vis[temp])\\n                return -1;\\n            if(edges[temp] == ind)\\n                return len;\\n\\n            temp = edges[temp];\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345221,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        boolean[] vis = new boolean[edges.length];\\n        int ans= -1;\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            if(!vis[i]){\\n                vis[i] = true;\\n                ans = Math.max(ans, findLength(i, edges, vis));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int findLength(int ind, int[] edges, boolean[] vis){\\n        int len = 0;\\n        int temp = ind;\\n        while(len < edges.length){\\n            len++;\\n            if(temp == -1 || !vis[temp])\\n                return -1;\\n            if(edges[temp] == ind)\\n                return len;\\n\\n            temp = edges[temp];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        boolean[] vis = new boolean[edges.length];\\n        int ans= -1;\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            if(!vis[i]){\\n                vis[i] = true;\\n                ans = Math.max(ans, findLength(i, edges, vis));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    int findLength(int ind, int[] edges, boolean[] vis){\\n        int len = 0;\\n        int temp = ind;\\n        while(len < edges.length){\\n            len++;\\n            if(temp == -1 || !vis[temp])\\n                return -1;\\n            if(edges[temp] == ind)\\n                return len;\\n\\n            temp = edges[temp];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344979,
                "title": "just-store-the-path-and-and-get-the-length-from-the-index",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &g,vector<bool> &vis,int s, int &res, vector<int > &mem)\\n    {\\n        if(s == -1)return ;\\n        \\n        \\n        \\n        if(vis[s])\\n        {\\n            int cnt = -1;\\n            for(int i=0;i<mem.size();i++)\\n            {\\n                \\n                if(mem[i] == s)\\n                {\\n                    cnt = i;\\n                    break;\\n                }\\n                \\n            }\\n            \\n            if(cnt ==-1) return;\\n            res = max(res,(int)mem.size()-cnt);\\n            return;\\n        }\\n        vis[s] = 1;\\n        mem.push_back(s);\\n        for(int i=0;i<g[s].size();i++)\\n        {\\n            dfs(g,vis,g[s][i],res,mem);\\n        }\\n    }\\n    \\n    \\n    int longestCycle(vector<int>& e) {\\n        \\n        int n = e.size();\\n        vector<vector<int>> g(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            g[i].push_back(e[i]);\\n        }\\n        \\n        vector<bool> vis(n,false);\\n        \\n        int res = -1;\\n        int cnt = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                vector<int > mem;                \\n                dfs(g,vis,i,res,mem);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &g,vector<bool> &vis,int s, int &res, vector<int > &mem)\\n    {\\n        if(s == -1)return ;\\n        \\n        \\n        \\n        if(vis[s])\\n        {\\n            int cnt = -1;\\n            for(int i=0;i<mem.size();i++)\\n            {\\n                \\n                if(mem[i] == s)\\n                {\\n                    cnt = i;\\n                    break;\\n                }\\n                \\n            }\\n            \\n            if(cnt ==-1) return;\\n            res = max(res,(int)mem.size()-cnt);\\n            return;\\n        }\\n        vis[s] = 1;\\n        mem.push_back(s);\\n        for(int i=0;i<g[s].size();i++)\\n        {\\n            dfs(g,vis,g[s][i],res,mem);\\n        }\\n    }\\n    \\n    \\n    int longestCycle(vector<int>& e) {\\n        \\n        int n = e.size();\\n        vector<vector<int>> g(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            g[i].push_back(e[i]);\\n        }\\n        \\n        vector<bool> vis(n,false);\\n        \\n        int res = -1;\\n        int cnt = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                vector<int > mem;                \\n                dfs(g,vis,i,res,mem);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344841,
                "title": "dfs-easy-for-beginner",
                "content": "Intution: There may be only one circle exist in one component hence find the starting node of that circle and compute the length of that circle.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    void checkCycle(int papa, vector<int>graph[], int &circle_node){//Here we will check the cycle in current component\\n        vis[papa] = 1;\\n        for(int child : graph[papa]){\\n            if(vis[child] == 2)continue;\\n            else if(vis[child] == 1){\\n                circle_node = child;\\n                return;\\n            }\\n            else{\\n                checkCycle(child, graph, circle_node);\\n            }\\n        }\\n        vis[papa] = 2;\\n    }\\n    \\n    int getCircleLength(int papa, vector<int>graph[]){//Calculating the length of current circle\\n        if(vis[papa] == 1)return 0;\\n        vis[papa] = 1;\\n        return 1 + getCircleLength(graph[papa][0], graph);   \\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> graph[n];\\n        \\n        for(int i = 0;i < n;i++){\\n            if(edges[i] != -1)graph[i].push_back(edges[i]);\\n        }\\n        vis.resize(n, 0);\\n        vector<int> circles;//Store every starting node of circle from every component.\\n        for(int i = 0;i < n;i++){\\n            int circle_node = -1;\\n            if(vis[i] == 0){\\n                checkCycle(i, graph, circle_node);\\n            }\\n            if(circle_node != -1){//Means found the cycle//circle_node is first node of cycle where cycle begins\\n                circles.push_back(circle_node);\\n            } \\n        }\\n        if(circles.size() == 0)return -1;//Means no cycle exist\\n\\t\\tvis.assign(n, 0);\\n        int mx_len = INT_MIN;\\n        for(auto node : circles){\\n            mx_len = max(mx_len, getCircleLength(node, graph));\\n        }\\n        return mx_len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vis;\\n    void checkCycle(int papa, vector<int>graph[], int &circle_node){//Here we will check the cycle in current component\\n        vis[papa] = 1;\\n        for(int child : graph[papa]){\\n            if(vis[child] == 2)continue;\\n            else if(vis[child] == 1){\\n                circle_node = child;\\n                return;\\n            }\\n            else{\\n                checkCycle(child, graph, circle_node);\\n            }\\n        }\\n        vis[papa] = 2;\\n    }\\n    \\n    int getCircleLength(int papa, vector<int>graph[]){//Calculating the length of current circle\\n        if(vis[papa] == 1)return 0;\\n        vis[papa] = 1;\\n        return 1 + getCircleLength(graph[papa][0], graph);   \\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> graph[n];\\n        \\n        for(int i = 0;i < n;i++){\\n            if(edges[i] != -1)graph[i].push_back(edges[i]);\\n        }\\n        vis.resize(n, 0);\\n        vector<int> circles;//Store every starting node of circle from every component.\\n        for(int i = 0;i < n;i++){\\n            int circle_node = -1;\\n            if(vis[i] == 0){\\n                checkCycle(i, graph, circle_node);\\n            }\\n            if(circle_node != -1){//Means found the cycle//circle_node is first node of cycle where cycle begins\\n                circles.push_back(circle_node);\\n            } \\n        }\\n        if(circles.size() == 0)return -1;//Means no cycle exist\\n\\t\\tvis.assign(n, 0);\\n        int mx_len = INT_MIN;\\n        for(auto node : circles){\\n            mx_len = max(mx_len, getCircleLength(node, graph));\\n        }\\n        return mx_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344669,
                "title": "similar-to-linked-list-cycle-detection",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe first thought was to start with every node and find if its a part of the circular linked list we would get if it had a cycle. then was return any node thats in the cycle.  then find the length of the cycle\\n\\nDo this to all nodes.\\nreturn max length.\\n\\nthen tried sample test cases. \\n\\nconsider these two circular linked lists. \\n0-1-2-3-2\\n4-5-6-0-1-2-3-2\\n\\nnow both the list has same cycle. if i could somehow identify if ive already seen this cycle , it would be good.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nto do this , ill create a visited[] , which basically has a value of \\n0 -> ive not seen this node. \\n1 -> ive seen this node once before and its part of a cycle.\\n2 -> ive already seen this node when i checked with some other node, no need to find cycle length. \\n\\ngoal : make sure that after finish visiting the circular linked list , put visited[all nodes in the linked list]=2;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    int[] edge;\\n    int[] visited;\\n    public int longestCycle(int[] edges) {\\n        edge=edges;\\n        int ans=-1;\\n        visited=new int[edges.length];\\n        \\n        for(int i=0;i<edge.length;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                int cycleNode=findCycleNode(i);\\n                ans=Math.max(ans,findCycleLength(cycleNode));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int findCycleNode(int node)\\n    {\\n        if(node==-1 || visited[node]==2) return -1;\\n        if(visited[node]==1) return node;\\n        visited[node]++;\\n        int temp=findCycleNode(edge[node]);\\n        visited[node]++;\\n        return temp;\\n    }\\n\\n    public int findCycleLength(int node)\\n    {\\n        if(node==-1) return -1;\\n        int n=node;\\n        int ans=1;\\n        while(edge[node]!=n) {\\n            ans++;\\n            node=edge[node];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] edge;\\n    int[] visited;\\n    public int longestCycle(int[] edges) {\\n        edge=edges;\\n        int ans=-1;\\n        visited=new int[edges.length];\\n        \\n        for(int i=0;i<edge.length;i++)\\n        {\\n            if(visited[i]==0)\\n            {\\n                int cycleNode=findCycleNode(i);\\n                ans=Math.max(ans,findCycleLength(cycleNode));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public int findCycleNode(int node)\\n    {\\n        if(node==-1 || visited[node]==2) return -1;\\n        if(visited[node]==1) return node;\\n        visited[node]++;\\n        int temp=findCycleNode(edge[node]);\\n        visited[node]++;\\n        return temp;\\n    }\\n\\n    public int findCycleLength(int node)\\n    {\\n        if(node==-1) return -1;\\n        int n=node;\\n        int ans=1;\\n        while(edge[node]!=n) {\\n            ans++;\\n            node=edge[node];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344628,
                "title": "java-simple-and-short-o-n-time-faster-than-100-10ms-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int maxLenCycle=-1,n=edges.length,visTime[]=new int[n],time=1;\\n        for(int st=0;st<n;st++){\\n            if(visTime[st]==0){\\n                int start=time,i=st;\\n                while(i!=-1 && visTime[i]==0){\\n                    visTime[i]=time++;\\n                    i=edges[i];\\n                }\\n                if(i!=-1 && visTime[i]>=start)  \\n                    maxLenCycle=Math.max(maxLenCycle,time-visTime[i]);\\n            }   \\n        }\\n        return maxLenCycle;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int maxLenCycle=-1,n=edges.length,visTime[]=new int[n],time=1;\\n        for(int st=0;st<n;st++){\\n            if(visTime[st]==0){\\n                int start=time,i=st;\\n                while(i!=-1 && visTime[i]==0){\\n                    visTime[i]=time++;\\n                    i=edges[i];\\n                }\\n                if(i!=-1 && visTime[i]>=start)  \\n                    maxLenCycle=Math.max(maxLenCycle,time-visTime[i]);\\n            }   \\n        }\\n        return maxLenCycle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344592,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> partof; \\n    int DFS(int i , vector<int>&visited, vector<int>&edges, int count, int source)\\n    {       \\n    \\n        count++;\\n        if(visited[i]!=-1  && partof[i]==source)\\n        {\\n            //cout<<\"Eccxe\";\\n            return count-visited[i];\\n        }\\n        else if(visited[i]!=-1 && partof[i]!=source)\\n            return -1;\\n        visited[i]=count;\\n        partof[i]=source;\\n            if(edges[i]!=-1)\\n            return DFS(edges[i],visited,edges,count,source);\\n        return -1;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        //visited array // will mark count \\n        //partof map // will mark source vertex\\n        int ans=-1,n=edges.size();\\n        vector<int> visited(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==-1)\\n                ans= max(ans,DFS(i,visited,edges,0,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> partof; \\n    int DFS(int i , vector<int>&visited, vector<int>&edges, int count, int source)\\n    {       \\n    \\n        count++;\\n        if(visited[i]!=-1  && partof[i]==source)\\n        {\\n            //cout<<\"Eccxe\";\\n            return count-visited[i];\\n        }\\n        else if(visited[i]!=-1 && partof[i]!=source)\\n            return -1;\\n        visited[i]=count;\\n        partof[i]=source;\\n            if(edges[i]!=-1)\\n            return DFS(edges[i],visited,edges,count,source);\\n        return -1;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        //visited array // will mark count \\n        //partof map // will mark source vertex\\n        int ans=-1,n=edges.size();\\n        vector<int> visited(n,-1);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(visited[i]==-1)\\n                ans= max(ans,DFS(i,visited,edges,0,i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3344473,
                "title": "simple-cycle-detection-on-steroids-easy-fast-and-efficient-image-explanation",
                "content": "# Intuition\\nEnhanced cycle detection. Since one node has only one child that means irrespective of how you reach a particular node you will always end up in the same path from there on\\n\\n# Approach\\n1. Since we know that once a node is visited it can only be visited again under two circumstances\\n1.1. If it is part of a cycle (or)\\n1.2. If it was already visited earlier from some other path\\n2. Since we have established that once the node is visited it will always lead to the same path from thereon, we can skip the node if it was previously visited.\\n3. To track whether the node is visited again in current cycle or it was visited earlier we will maintain a batch counter\\n4. Batch counter will increment for every attempt to check the cycles and the moment we detect a dead end or cycle we will increment the batch counter for next detection\\n5. Another important part of the problem is the length of the cycle\\n6. To count the size of cycle we will calculate the distance of the node from starting point and keep on incrementing it as we move further.\\n7. The moment we encounter cycle we will subtract the new distance and old distance of cycle node to get the size of the cycle\\n```\\ncycle_length = new_distance - old_distance\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/dae56515-0f6d-48d2-8719-5ea172108459_1679845494.7687435.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n\\n        // Enhanced visited flag that records batch wise visits\\n        final var visited = new int[edges.length];\\n\\n        // Record the distance to the node in given index\\n        final var distance = new int[edges.length];\\n\\n        // Max cycle length so far\\n        int max = -1;\\n\\n        // Current running batch\\n        int batch = 0;\\n        for(int i=0; i<edges.length; i++) {\\n            if(edges[i] >= 0) {\\n\\n                // Increment the batch every time new cycle detection starts\\n                batch++;\\n\\n                // Local distance counter\\n                int d = 0;\\n\\n                visited[i] = batch;\\n                distance[i] = d++;\\n                int next = edges[i];\\n                while (next != -1) {\\n                    // visited = 0 means that node is not visited in any batch yet\\n                    if(visited[next] == 0) {\\n                        visited[next] = batch;\\n                        distance[next] = d++;\\n                        next = edges[next];\\n                    }\\n                    \\n                    // Check if this node is already visited in this batch\\n                    else if(visited[next] == batch){\\n                        int cycle = d - distance[next];\\n                        max = Math.max(max, cycle);\\n                        break;\\n                    }\\n                    \\n                    // If the node is already visited in previous batches then terminate the cycle detection\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\ncycle_length = new_distance - old_distance\\n```\n```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n\\n        // Enhanced visited flag that records batch wise visits\\n        final var visited = new int[edges.length];\\n\\n        // Record the distance to the node in given index\\n        final var distance = new int[edges.length];\\n\\n        // Max cycle length so far\\n        int max = -1;\\n\\n        // Current running batch\\n        int batch = 0;\\n        for(int i=0; i<edges.length; i++) {\\n            if(edges[i] >= 0) {\\n\\n                // Increment the batch every time new cycle detection starts\\n                batch++;\\n\\n                // Local distance counter\\n                int d = 0;\\n\\n                visited[i] = batch;\\n                distance[i] = d++;\\n                int next = edges[i];\\n                while (next != -1) {\\n                    // visited = 0 means that node is not visited in any batch yet\\n                    if(visited[next] == 0) {\\n                        visited[next] = batch;\\n                        distance[next] = d++;\\n                        next = edges[next];\\n                    }\\n                    \\n                    // Check if this node is already visited in this batch\\n                    else if(visited[next] == batch){\\n                        int cycle = d - distance[next];\\n                        max = Math.max(max, cycle);\\n                        break;\\n                    }\\n                    \\n                    // If the node is already visited in previous batches then terminate the cycle detection\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344325,
                "title": "ruby-dfs",
                "content": "## Leetcode: 2360. Longest Cycle in a Graph.\\n\\n**Ruby: DFS.**\\n\\nTranslation of the Leetcode\\'s solution.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 2360. Longest Cycle in a Graph.\\n# https://leetcode.com/problems/longest-cycle-in-a-graph/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 366 ms, faster than 100.00% of Ruby online submissions for Longest\\n# Cycle in a Graph.\\n# Memory Usage: 253.6 MB, less than 100.00% of Ruby online submissions for\\n# Longest Cycle in a Graph.\\n# 2023.03.26 Daily Challenge.\\n# @param {Integer[]} edges\\n# @return {Integer}\\ndef longest_cycle(edges)\\n  # Based on:\\n  # https://leetcode.com/problems/longest-cycle-in-a-graph/solution/\\n\\n  # 1. Initialize ann integer `answer = -1`. This would store the longest cycle\\n  # in the graph.\\n  @ans = -1\\n  # 2. Initialize another integer `n = edges.length` wich stores the number of\\n  # nodes in teh graph.\\n  @n = edges.size\\n  @e = edges\\n  # 3. Create a `visit` array of length `n` to keep trak of nodes that have been\\n  # visited.\\n  @v = Array.new(@n,false)\\n  # 4. Iterate through all of the nodes and for each node `i` check if it is\\n  # visited or not. If node `i` is not visited, create a hash map `dist` where\\n  # `dist.get(x)` would sotre the distance of node `x` from starting node `i`.\\n  # Beging the DFS traversal.\\n  (0...@n).each do |i|\\n    next if @v[i]\\n    @dst = {}\\n    @dst[i] = 1\\n    dfs(i)\\n  end\\n  # 5. Return answer.\\n  return @ans\\nend\\n\\ndef dfs(node)\\n  @v[node] = true\\n  nb = @e[node] # neighbor\\n  return if -1 == nb\\n  if !@v[nb]\\n    @dst[nb] = @dst[node] + 1\\n    dfs(nb)\\n  elsif @dst[nb]\\n    @ans = [@ans, @dst[node] - @dst[nb] + 1].max\\n  end\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Depth-First Search"
                ],
                "code": "```Ruby\\n# Leetcode: 2360. Longest Cycle in a Graph.\\n# https://leetcode.com/problems/longest-cycle-in-a-graph/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 366 ms, faster than 100.00% of Ruby online submissions for Longest\\n# Cycle in a Graph.\\n# Memory Usage: 253.6 MB, less than 100.00% of Ruby online submissions for\\n# Longest Cycle in a Graph.\\n# 2023.03.26 Daily Challenge.\\n# @param {Integer[]} edges\\n# @return {Integer}\\ndef longest_cycle(edges)\\n  # Based on:\\n  # https://leetcode.com/problems/longest-cycle-in-a-graph/solution/\\n\\n  # 1. Initialize ann integer `answer = -1`. This would store the longest cycle\\n  # in the graph.\\n  @ans = -1\\n  # 2. Initialize another integer `n = edges.length` wich stores the number of\\n  # nodes in teh graph.\\n  @n = edges.size\\n  @e = edges\\n  # 3. Create a `visit` array of length `n` to keep trak of nodes that have been\\n  # visited.\\n  @v = Array.new(@n,false)\\n  # 4. Iterate through all of the nodes and for each node `i` check if it is\\n  # visited or not. If node `i` is not visited, create a hash map `dist` where\\n  # `dist.get(x)` would sotre the distance of node `x` from starting node `i`.\\n  # Beging the DFS traversal.\\n  (0...@n).each do |i|\\n    next if @v[i]\\n    @dst = {}\\n    @dst[i] = 1\\n    dfs(i)\\n  end\\n  # 5. Return answer.\\n  return @ans\\nend\\n\\ndef dfs(node)\\n  @v[node] = true\\n  nb = @e[node] # neighbor\\n  return if -1 == nb\\n  if !@v[nb]\\n    @dst[nb] = @dst[node] + 1\\n    dfs(nb)\\n  elsif @dst[nb]\\n    @ans = [@ans, @dst[node] - @dst[nb] + 1].max\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3344180,
                "title": "c-solution-well-explained-dfs-bfs-kahn-s-algo",
                "content": "# Approach\\n* BFS Traversal\\n* DFS Traversal\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n    * Initializing the visit array takes $$O(n)$$ time.\\n\\t* The dfs function visits each node once, which takes $$O(n)$$ time in total. Because we have directed edges, each edge will be iterated once, resulting in $$O(n)$$ operations in total while visiting all the nodes.\\n\\t* Each operation on the dist map takes $$O(1)$$ time. Because we insert a distance for each node when it is visited, it will take $$O(n)$$ time to insert distances for all of the nodes. It is also used to check the formation of a cycle when a previously visited node is encountered again. Because there are nnn nodes, it can be checked at most nnn times. It would also take $$O(n)$$ time in that case.\\n\\n- Space complexity: $$O(n)$$\\n\\t* The visit array takes $$O(n)$$ space.\\n\\t* The recursion call stack used by dfs can have no more than $$n$$ elements in the worst-case scenario. It would take up $$O(n)$$ space in that case.\\n\\t* The count array can also have no more than $$n$$ elements and hence it would take up $$O(n)$$ space as well.\\n\\n# Approach #1 - Using DFS - Cycle Detection in Directed Graph\\n```\\nclass Solution {\\npublic:\\n    int result = -1; // to store the longest cycle length\\n\\u200B\\n    void dfs(int src, vector<int>& edges, vector<bool> &visited, vector<bool> &recurStack, vector<int> &count){\\n        //if there is an edge from src node\\n        if(src != -1){\\n            visited[src] = true;\\n            recurStack[src] = true;\\n\\u200B\\n            int dest = edges[src]; // finding the destination node\\n\\u200B\\n            if(dest != -1 && !visited[dest]){\\n                //if it is possible to move to destination node\\n                //means cycle is not yet found\\n                //update the count of destination node in the count array\\n                count[dest] = count[src] + 1; \\n\\u200B\\n                //also make dfs call to dest node\\n                dfs(dest, edges, visited, recurStack, count);\\n            }\\n            else if(dest != -1 && recurStack[dest] == true){\\n                //cycle found at the destination node\\n                //update the result\\n                result = max(result, count[src] - count[dest] + 1);\\n            }\\n\\u200B\\n            //before returing from current recursion call\\n            //make src node false in recurStack Array\\n            recurStack[src] = false; \\n        }\\n    }\\n\\u200B\\n    int longestCycle(vector<int>& edges) {\\n\\u200B\\n        //here we are not required to create adjacency list\\n        //because we can easily extract u and v from edges array\\n\\u200B\\n        int n = edges.size();\\n        //create visited and recurrStack vector\\n        vector<bool> visited(n, false);\\n        vector<bool> recurStack(n, false);\\n\\u200B\\n        //create count array to store the count of the node being visited in the cycle\\n        //initialize all node as 1\\n        vector<int> count(n , 1);\\n\\u200B\\n        //before dfs\\n        for(int i = 0; i < n; i++){\\n            if(!visited[i]){\\n                dfs(i, edges, visited, recurStack, count);\\n            }\\n        }\\n\\u200B\\n        return result;\\n    }\\n};\\n```\\n\\n# Approach #2 - Using BFS - Kahn\\'s Algorithm\\n* Complexity same as in case of DFS\\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n\\n        //create indegree array\\n        vector<int> indegree(n);\\n \\n        //create a visited array\\n        vector<bool> visited(n , false);\\n\\n\\n        for(auto i : edges){\\n            if(i != -1){\\n                indegree[i]++;\\n            }\\n        }\\n\\n        // Kahn\\'s algorithm starts.\\n        //create a queue for the bfs traversal\\n        queue<int> q;\\n\\n        //push all vectices with zero indegree into queue\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n\\n            visited[front] = true;\\n\\n            int neighbor = edges[front];\\n\\n            if(neighbor != -1){\\n                indegree[neighbor]--;\\n                if(indegree[neighbor] == 0){\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n        // Kahn\\'s algorithm ends.\\n\\n        int result = -1;\\n\\n        for(int i = 0; i < n; i++){\\n            if(!visited[i]){\\n                int neighbor = edges[i];\\n\\n                int count = 1;\\n                visited[i] = true;\\n\\n                //iterate in the cycle\\n                while(neighbor != i){\\n                    visited[neighbor] = true;\\n                    count++;\\n                    neighbor = edges[neighbor];\\n                }\\n\\n                result = max(result, count);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n\\n### Please Upvote if you find it Helpful \\uD83D\\uDE42",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int result = -1; // to store the longest cycle length\\n\\u200B\\n    void dfs(int src, vector<int>& edges, vector<bool> &visited, vector<bool> &recurStack, vector<int> &count){\\n        //if there is an edge from src node\\n        if(src != -1){\\n            visited[src] = true;\\n            recurStack[src] = true;\\n\\u200B\\n            int dest = edges[src]; // finding the destination node\\n\\u200B\\n            if(dest != -1 && !visited[dest]){\\n                //if it is possible to move to destination node\\n                //means cycle is not yet found\\n                //update the count of destination node in the count array\\n                count[dest] = count[src] + 1; \\n\\u200B\\n                //also make dfs call to dest node\\n                dfs(dest, edges, visited, recurStack, count);\\n            }\\n            else if(dest != -1 && recurStack[dest] == true){\\n                //cycle found at the destination node\\n                //update the result\\n                result = max(result, count[src] - count[dest] + 1);\\n            }\\n\\u200B\\n            //before returing from current recursion call\\n            //make src node false in recurStack Array\\n            recurStack[src] = false; \\n        }\\n    }\\n\\u200B\\n    int longestCycle(vector<int>& edges) {\\n\\u200B\\n        //here we are not required to create adjacency list\\n        //because we can easily extract u and v from edges array\\n\\u200B\\n        int n = edges.size();\\n        //create visited and recurrStack vector\\n        vector<bool> visited(n, false);\\n        vector<bool> recurStack(n, false);\\n\\u200B\\n        //create count array to store the count of the node being visited in the cycle\\n        //initialize all node as 1\\n        vector<int> count(n , 1);\\n\\u200B\\n        //before dfs\\n        for(int i = 0; i < n; i++){\\n            if(!visited[i]){\\n                dfs(i, edges, visited, recurStack, count);\\n            }\\n        }\\n\\u200B\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n\\n        //create indegree array\\n        vector<int> indegree(n);\\n \\n        //create a visited array\\n        vector<bool> visited(n , false);\\n\\n\\n        for(auto i : edges){\\n            if(i != -1){\\n                indegree[i]++;\\n            }\\n        }\\n\\n        // Kahn\\'s algorithm starts.\\n        //create a queue for the bfs traversal\\n        queue<int> q;\\n\\n        //push all vectices with zero indegree into queue\\n        for(int i = 0; i < n; i++){\\n            if(indegree[i] == 0){\\n                q.push(i);\\n            }\\n        }\\n\\n\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n\\n            visited[front] = true;\\n\\n            int neighbor = edges[front];\\n\\n            if(neighbor != -1){\\n                indegree[neighbor]--;\\n                if(indegree[neighbor] == 0){\\n                    q.push(neighbor);\\n                }\\n            }\\n        }\\n        // Kahn\\'s algorithm ends.\\n\\n        int result = -1;\\n\\n        for(int i = 0; i < n; i++){\\n            if(!visited[i]){\\n                int neighbor = edges[i];\\n\\n                int count = 1;\\n                visited[i] = true;\\n\\n                //iterate in the cycle\\n                while(neighbor != i){\\n                    visited[neighbor] = true;\\n                    count++;\\n                    neighbor = edges[neighbor];\\n                }\\n\\n                result = max(result, count);\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344113,
                "title": "kotlin-java-o-n-dfs-without-hashmap",
                "content": "# Approach\\nHints tells us that:\\n1. Each node can be a part of at most single cycle (because there is at most 1 edge coming out of it).\\n2. We\\'ll need to visit every node at most 1 time to find the answer.\\n\\nSo basically we need to traverse it somehow with these additions:\\n- We can use DFS\\n- We have to start from every node, because the graph is not guaranteed to be single connected component\\n- We need to save how far away was each node in current iteration - we\\'ll need it, so we\\'ll know it has been encountered in current iteration and how far we are from it.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - we need to visit every node\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private lateinit var distance: HashMap<Int, Int>\\n    private lateinit var visited: BooleanArray\\n    private lateinit var edges: IntArray\\n\\n    fun longestCycle(edges: IntArray): Int {\\n        this.edges = edges\\n        visited = BooleanArray(edges.size)\\n        distance = hashMapOf()\\n        var longestCycle = -1\\n        for (v in edges.indices) {\\n            if (visited[v]) continue\\n            distance = hashMapOf()\\n            longestCycle = maxOf(longestCycle, dfs(v, -1))\\n        }\\n        return longestCycle\\n    }\\n\\n    private fun dfs(node: Int, parent: Int): Int {\\n        if (visited[node]) return -1\\n        visited[node] = true\\n        distance[node] = (distance[parent] ?: 0) + 1\\n\\n        val next = edges[node]\\n        if (next == -1) return -1\\n\\n        if (distance.containsKey(next)) {\\n            return distance[node]!! - distance[next]!! + 1\\n        }\\n        return dfs(next, node)\\n    }\\n}\\n```\\n\\nAfter playing around with it, I found out we don\\'t even need to keep distances, if we just compute it while returning back via call stack.\\n\\n# Code \\n```\\nclass Solution {\\n    private HashSet<Integer> currentlyVisited;\\n    private boolean[] visited;\\n    private int[] edges;\\n\\n    public int longestCycle(int[] edges) {\\n        this.edges = edges;\\n        int longestCycle = -1;\\n        visited = new boolean[edges.length];\\n        for (int v = 0; v < edges.length; v++) {\\n            if (visited[v]) continue;\\n            currentlyVisited = new HashSet<>();\\n            longestCycle = Math.max(dfs(v, -1), longestCycle);\\n        }\\n        return longestCycle;\\n    }\\n\\n    private int lastCycle = -1;\\n\\n    private int dfs(int node, int parent) {\\n        if (visited[node]) return -1;\\n        visited[node] = true;\\n        currentlyVisited.add(node);\\n\\n        int next = edges[node];\\n        if (next == -1) return -1;\\n\\n        if (currentlyVisited.contains(next)) {\\n            lastCycle = next;\\n            return 1;\\n        }\\n\\n        int res = dfs(next, node);\\n\\n        if (lastCycle != -1) {\\n            if (lastCycle == node) {\\n                lastCycle = -1;\\n            }\\n\\n            return res + 1;\\n        } else {\\n            return res;\\n        }\\n    }\\n}\\n```\\n\\n\\n---\\n\\n\\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F If you like this solution or find it helpful, please upvote this post. \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    private lateinit var distance: HashMap<Int, Int>\\n    private lateinit var visited: BooleanArray\\n    private lateinit var edges: IntArray\\n\\n    fun longestCycle(edges: IntArray): Int {\\n        this.edges = edges\\n        visited = BooleanArray(edges.size)\\n        distance = hashMapOf()\\n        var longestCycle = -1\\n        for (v in edges.indices) {\\n            if (visited[v]) continue\\n            distance = hashMapOf()\\n            longestCycle = maxOf(longestCycle, dfs(v, -1))\\n        }\\n        return longestCycle\\n    }\\n\\n    private fun dfs(node: Int, parent: Int): Int {\\n        if (visited[node]) return -1\\n        visited[node] = true\\n        distance[node] = (distance[parent] ?: 0) + 1\\n\\n        val next = edges[node]\\n        if (next == -1) return -1\\n\\n        if (distance.containsKey(next)) {\\n            return distance[node]!! - distance[next]!! + 1\\n        }\\n        return dfs(next, node)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private HashSet<Integer> currentlyVisited;\\n    private boolean[] visited;\\n    private int[] edges;\\n\\n    public int longestCycle(int[] edges) {\\n        this.edges = edges;\\n        int longestCycle = -1;\\n        visited = new boolean[edges.length];\\n        for (int v = 0; v < edges.length; v++) {\\n            if (visited[v]) continue;\\n            currentlyVisited = new HashSet<>();\\n            longestCycle = Math.max(dfs(v, -1), longestCycle);\\n        }\\n        return longestCycle;\\n    }\\n\\n    private int lastCycle = -1;\\n\\n    private int dfs(int node, int parent) {\\n        if (visited[node]) return -1;\\n        visited[node] = true;\\n        currentlyVisited.add(node);\\n\\n        int next = edges[node];\\n        if (next == -1) return -1;\\n\\n        if (currentlyVisited.contains(next)) {\\n            lastCycle = next;\\n            return 1;\\n        }\\n\\n        int res = dfs(next, node);\\n\\n        if (lastCycle != -1) {\\n            if (lastCycle == node) {\\n                lastCycle = -1;\\n            }\\n\\n            return res + 1;\\n        } else {\\n            return res;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344089,
                "title": "php-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    function longestCycle($edges) {\\n        $longestCycle = -1;\\n        $timeStep = 1;\\n        $vistedList = array_fill(0, count($edges), 0);\\n\\n        for ($currentNode = 0; $currentNode < count($edges); $currentNode++) {\\n            if ($vistedList[$currentNode] > 0){\\n                continue;\\n            }\\n            $startTime = $timeStep;\\n            $traversedNode = $currentNode;\\n            while ($traversedNode !== -1 && $vistedList[$traversedNode] === 0) {\\n                $vistedList[$traversedNode] = $timeStep++;\\n                $traversedNode = $edges[$traversedNode];\\n            }\\n            if ($traversedNode !== -1 && $vistedList[$traversedNode] >= $startTime){\\n                $longestCycle = max($longestCycle, $timeStep - $vistedList[$traversedNode]);\\n            }\\n        }\\n        unset($vistedList);\\n        return $longestCycle;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n    function longestCycle($edges) {\\n        $longestCycle = -1;\\n        $timeStep = 1;\\n        $vistedList = array_fill(0, count($edges), 0);\\n\\n        for ($currentNode = 0; $currentNode < count($edges); $currentNode++) {\\n            if ($vistedList[$currentNode] > 0){\\n                continue;\\n            }\\n            $startTime = $timeStep;\\n            $traversedNode = $currentNode;\\n            while ($traversedNode !== -1 && $vistedList[$traversedNode] === 0) {\\n                $vistedList[$traversedNode] = $timeStep++;\\n                $traversedNode = $edges[$traversedNode];\\n            }\\n            if ($traversedNode !== -1 && $vistedList[$traversedNode] >= $startTime){\\n                $longestCycle = max($longestCycle, $timeStep - $vistedList[$traversedNode]);\\n            }\\n        }\\n        unset($vistedList);\\n        return $longestCycle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344030,
                "title": "medium-detection-of-cycle-dfs-concept-c",
                "content": "# Intuition\\n- similar to detection of cycle we will store the count of step in \\na vector `visited` and is we encounter a node chose count is not zero means this node is visited in that cycle itself.\\n- just calulate the lenth of `cycle = count-visited[i]+1`.\\n- we will backtrack when we return from recursive call and reset the `visited[i]=0` means return from that loop.\\n- and marking `globalVisited[i]` as `true`. before returning . \\n- if globla visited is `true` means calculation through this node is already being done and no need to calculate any more simply return . (done to avoid the recomputaion and optimising).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n-  $$O(n)$$\\n\\n- Space complexity:\\n- $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) \\n    {\\n       \\n        vector<int>visited(edges.size(),0);\\n        vector<bool>globalVisited(edges.size(),0);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if (visited[i]==0)\\n            {\\n                int temp=dfs(visited,edges,i,0,globalVisited);\\n                if (temp!=0)\\n                {\\n                    ans=max(ans,temp);\\n                }\\n            }\\n        }\\n        return ans;    \\n    }\\n    int dfs(vector<int>&visited,vector<int>&edges,int i,int count,vector<bool>&globalVisited)\\n    {\\n        if (globalVisited[i])\\n        {\\n            return -1;\\n        }\\n        if (edges[i]==-1)\\n        {\\n            globalVisited[i]=1;\\n            return -1;\\n        }\\n        if (visited[i]!=0)\\n        {\\n            return count-visited[i]+1;\\n        }\\n        visited[i]=count+1;\\n        int ans= dfs(visited,edges,edges[i],count+1,globalVisited);\\n        visited[i]=0;\\n        globalVisited[i]=1;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) \\n    {\\n       \\n        vector<int>visited(edges.size(),0);\\n        vector<bool>globalVisited(edges.size(),0);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if (visited[i]==0)\\n            {\\n                int temp=dfs(visited,edges,i,0,globalVisited);\\n                if (temp!=0)\\n                {\\n                    ans=max(ans,temp);\\n                }\\n            }\\n        }\\n        return ans;    \\n    }\\n    int dfs(vector<int>&visited,vector<int>&edges,int i,int count,vector<bool>&globalVisited)\\n    {\\n        if (globalVisited[i])\\n        {\\n            return -1;\\n        }\\n        if (edges[i]==-1)\\n        {\\n            globalVisited[i]=1;\\n            return -1;\\n        }\\n        if (visited[i]!=0)\\n        {\\n            return count-visited[i]+1;\\n        }\\n        visited[i]=count+1;\\n        int ans= dfs(visited,edges,edges[i],count+1,globalVisited);\\n        visited[i]=0;\\n        globalVisited[i]=1;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343929,
                "title": "c-dfs-solution",
                "content": "Just a slight change in detect cycle code\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> size;\\n    int max_size=INT_MIN;\\n    void dffs(vector<int> adj[],int sr,vector<bool>& vis,vector<bool>& pathvis,int curr){\\n        vis[sr]=true;\\n        pathvis[sr]=true;\\n        size[sr]=curr;\\n\\n        for(auto x:adj[sr]){\\n            if(!vis[x]){\\n                dffs(adj,x,vis,pathvis,curr+1);\\n            }\\n            else if(pathvis[x]){\\n                max_size=max(max_size,curr-size[x]+1);\\n                return;\\n            }\\n        }\\n        pathvis[sr]=false;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<n;i++){\\n            if(edges[i]!=-1){\\n                adj[i].push_back(edges[i]);\\n            }\\n        }\\n        vector<bool> vis(n,false);\\n        vector<bool> pathvis(n,false);\\n        size.resize(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                dffs(adj,i,vis,pathvis,0);\\n            }\\n        }\\n        if(max_size==INT_MIN) return -1;\\n        return max_size;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> size;\\n    int max_size=INT_MIN;\\n    void dffs(vector<int> adj[],int sr,vector<bool>& vis,vector<bool>& pathvis,int curr){\\n        vis[sr]=true;\\n        pathvis[sr]=true;\\n        size[sr]=curr;\\n\\n        for(auto x:adj[sr]){\\n            if(!vis[x]){\\n                dffs(adj,x,vis,pathvis,curr+1);\\n            }\\n            else if(pathvis[x]){\\n                max_size=max(max_size,curr-size[x]+1);\\n                return;\\n            }\\n        }\\n        pathvis[sr]=false;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> adj[n];\\n\\n        for(int i=0;i<n;i++){\\n            if(edges[i]!=-1){\\n                adj[i].push_back(edges[i]);\\n            }\\n        }\\n        vector<bool> vis(n,false);\\n        vector<bool> pathvis(n,false);\\n        size.resize(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i]){\\n                dffs(adj,i,vis,pathvis,0);\\n            }\\n        }\\n        if(max_size==INT_MIN) return -1;\\n        return max_size;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343790,
                "title": "c-solution-using-dfs-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int isCycle(int sv, vector<vector<int>> &edges, vector<bool> &vis, set<int> &s){\\n        vis[sv]=true;\\n        s.insert(sv);\\n        for(int i=0;i<edges[sv].size();i++){\\n            if(s.find(edges[sv][i]) != s.end())\\n                return sv;\\n            if(!vis[edges[sv][i]]){\\n                int x = isCycle(edges[sv][i], edges, vis, s);\\n                if(x!=-1)\\n                    return x;\\n            }\\n        }\\n        s.erase(sv);\\n        return -1;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int ans=-1;\\n        int n = edges.size();\\n        vector<vector<int>> v(n);\\n        for(int i=0; i<n; i++){\\n            if(edges[i]!=-1) v[edges[i]].push_back(i);\\n        }\\n        vector<bool> vis(edges.size(), false);\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) continue;\\n            set<int> S;\\n            int getAns=isCycle(i,v,vis,S);\\n            if(getAns>-1){\\n                int c=1;\\n                int sv=i;\\n                while(edges[sv]!=i)\\n                    sv=edges[sv], c++;\\n                ans=max(ans, c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isCycle(int sv, vector<vector<int>> &edges, vector<bool> &vis, set<int> &s){\\n        vis[sv]=true;\\n        s.insert(sv);\\n        for(int i=0;i<edges[sv].size();i++){\\n            if(s.find(edges[sv][i]) != s.end())\\n                return sv;\\n            if(!vis[edges[sv][i]]){\\n                int x = isCycle(edges[sv][i], edges, vis, s);\\n                if(x!=-1)\\n                    return x;\\n            }\\n        }\\n        s.erase(sv);\\n        return -1;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int ans=-1;\\n        int n = edges.size();\\n        vector<vector<int>> v(n);\\n        for(int i=0; i<n; i++){\\n            if(edges[i]!=-1) v[edges[i]].push_back(i);\\n        }\\n        vector<bool> vis(edges.size(), false);\\n        for(int i=0;i<n;i++){\\n            if(vis[i]) continue;\\n            set<int> S;\\n            int getAns=isCycle(i,v,vis,S);\\n            if(getAns>-1){\\n                int c=1;\\n                int sv=i;\\n                while(edges[sv]!=i)\\n                    sv=edges[sv], c++;\\n                ans=max(ans, c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343767,
                "title": "dfs-solution-using-adjlist-and-groups",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>adjlist;\\n    vector<int>vis;\\n    int groupStart;\\n    int ans;\\n    int counter;\\n    void dfs(int node){\\n        vis[node]=counter++;\\n        for(auto x:adjlist[node]){\\n            if(vis[x]==-1){\\n                dfs(x);\\n            }else if(vis[x]>=groupStart){\\n                ans=max(ans,vis[node]-vis[x]+1);\\n            }\\n        }\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        adjlist.clear();\\n        vis.clear();\\n        adjlist.resize(n);\\n        vis.resize(n,-1);\\n        groupStart=0;\\n        counter=0;\\n        ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(edges[i]==-1)continue;\\n            adjlist[i].push_back(edges[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==-1){\\n                groupStart=counter;\\n                dfs(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>adjlist;\\n    vector<int>vis;\\n    int groupStart;\\n    int ans;\\n    int counter;\\n    void dfs(int node){\\n        vis[node]=counter++;\\n        for(auto x:adjlist[node]){\\n            if(vis[x]==-1){\\n                dfs(x);\\n            }else if(vis[x]>=groupStart){\\n                ans=max(ans,vis[node]-vis[x]+1);\\n            }\\n        }\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        adjlist.clear();\\n        vis.clear();\\n        adjlist.resize(n);\\n        vis.resize(n,-1);\\n        groupStart=0;\\n        counter=0;\\n        ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(edges[i]==-1)continue;\\n            adjlist[i].push_back(edges[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==-1){\\n                groupStart=counter;\\n                dfs(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343373,
                "title": "union-find-solution-to-find-edges-that-cause-loops",
                "content": "# Intuition\\n\\nIf you use Union Find you are able to find edges that cause loops. After you find them simply choose one of the vertices to be the starting point.\\n\\nThe description of the problem tells you that from one of this vertices you will come back to the start in a straight line, so simply count how many edges does it take.\\n\\n# Approach\\n- Union Find\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/9c88c5de-857c-4118-afb7-60131ad2caba_1679826530.071576.png)\\n\\n```java\\nclass Solution {\\n    int[] parents, rank;\\n    public int longestCycle(int[] edges) {\\n        parents=new int[edges.length];\\n        rank=new int[edges.length];\\n        for(int i=0;i<parents.length;i++) parents[i]=i;\\n        boolean[] candidates=new boolean[edges.length];\\n            int max=-1;\\n        // Union Find setup\\n        for(int i=0;i<edges.length;i++) {\\n            int go=edges[i];\\n            if(go!=-1&&!uf(i,go)) candidates[i]=true;\\n        }\\n        //After you have the candidates we count in a\\n        // straight line\\n        for(int i=0;i<candidates.length;i++) {\\n            if(!candidates[i]) continue;\\n            int next=edges[i], count=1;\\n            while(next!=i) {\\n                next=edges[next];\\n                count++;\\n            }\\n            if(count>max) max=count;\\n        }\\n        return max;\\n        \\n    }\\n    boolean uf(int a, int b) {\\n        int pa=parent(a), pb=parent(b);\\n        if(pa==pb) return false;\\n        if(rank[a]>rank[b]) {\\n            rank[a]+=rank[b]+1;\\n            parents[pb]=parents[pa];\\n        } else {\\n            rank[b]+=rank[a]+1;\\n            parents[pa]=parents[pb];\\n        }\\n        return true;\\n    }\\n    int parent(int a) {\\n        int pa=parents[a];\\n        if(pa!=a) parents[a]=pa=parent(pa);\\n        return pa;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    int[] parents, rank;\\n    public int longestCycle(int[] edges) {\\n        parents=new int[edges.length];\\n        rank=new int[edges.length];\\n        for(int i=0;i<parents.length;i++) parents[i]=i;\\n        boolean[] candidates=new boolean[edges.length];\\n            int max=-1;\\n        // Union Find setup\\n        for(int i=0;i<edges.length;i++) {\\n            int go=edges[i];\\n            if(go!=-1&&!uf(i,go)) candidates[i]=true;\\n        }\\n        //After you have the candidates we count in a\\n        // straight line\\n        for(int i=0;i<candidates.length;i++) {\\n            if(!candidates[i]) continue;\\n            int next=edges[i], count=1;\\n            while(next!=i) {\\n                next=edges[next];\\n                count++;\\n            }\\n            if(count>max) max=count;\\n        }\\n        return max;\\n        \\n    }\\n    boolean uf(int a, int b) {\\n        int pa=parent(a), pb=parent(b);\\n        if(pa==pb) return false;\\n        if(rank[a]>rank[b]) {\\n            rank[a]+=rank[b]+1;\\n            parents[pb]=parents[pa];\\n        } else {\\n            rank[b]+=rank[a]+1;\\n            parents[pa]=parents[pb];\\n        }\\n        return true;\\n    }\\n    int parent(int a) {\\n        int pa=parents[a];\\n        if(pa!=a) parents[a]=pa=parent(pa);\\n        return pa;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343315,
                "title": "python-iterative-bfs-solution-o-n-solution",
                "content": "```\\n  def longestCycle(self, edges: List[int]) -> int:\\n      dq = deque();\\n      res,n = 0,len(edges) \\n      visitedglobal = [ 0 for i in range(0,n)]\\n      visited = defaultdict(int)\\n      for i in range(0,n):\\n          if(visitedglobal[i] == 0 and edges[i] != -1 ):\\n              visited.clear()\\n              visited[i] = 1\\n              visitedglobal[i] =1\\n              dq.append(i)\\n              depth = 1\\n              while(len(dq)>0):\\n                  size = len(dq)\\n                  while(size):\\n                      size-=1\\n                      v = dq.popleft()\\n                      if(edges[v] == -1 ):\\n                          pass\\n                      elif(visited[edges[v]] == 0 ):\\n                          if( visitedglobal[edges[v]] ==1):\\n                              continue;\\n                          visited[edges[v]]=depth+1\\n                          visitedglobal[edges[v]] =1\\n                          dq.append(edges[v])\\n                      elif(res < depth+1-visited[edges[v]]  ):\\n                          res = depth+1-visited[edges[v]]\\n                  depth+=1\\n      return res if res >0 else -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n  def longestCycle(self, edges: List[int]) -> int:\\n      dq = deque();\\n      res,n = 0,len(edges) \\n      visitedglobal = [ 0 for i in range(0,n)]\\n      visited = defaultdict(int)\\n      for i in range(0,n):\\n          if(visitedglobal[i] == 0 and edges[i] != -1 ):\\n              visited.clear()\\n              visited[i] = 1\\n              visitedglobal[i] =1\\n              dq.append(i)\\n              depth = 1\\n              while(len(dq)>0):\\n                  size = len(dq)\\n                  while(size):\\n                      size-=1\\n                      v = dq.popleft()\\n                      if(edges[v] == -1 ):\\n                          pass\\n                      elif(visited[edges[v]] == 0 ):\\n                          if( visitedglobal[edges[v]] ==1):\\n                              continue;\\n                          visited[edges[v]]=depth+1\\n                          visitedglobal[edges[v]] =1\\n                          dq.append(edges[v])\\n                      elif(res < depth+1-visited[edges[v]]  ):\\n                          res = depth+1-visited[edges[v]]\\n                  depth+=1\\n      return res if res >0 else -1\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3343234,
                "title": "kosaraju-scc-accepted-solution",
                "content": "# Intuition\\nUsing the Kosaraju\\'s algorithm to find all the strongly connected components.\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<int>> graph;\\n    vector<vector<int>> t_graph;\\n    stack<int> st;\\n    bitset<100005> vis;\\n\\n    void dfs(int node) {\\n        vis[node] = 1;\\n        for (auto e: graph[node]) {\\n            if (!vis[e]) dfs(e);\\n        }\\n        st.push(node);\\n    }\\n\\n    void dfs_2(int node, int& nodes) {\\n        nodes+=1;\\n        vis[node] = 1;\\n\\n        for (auto e: t_graph[node]) {\\n            if(!vis[e]) dfs_2(e, nodes);\\n        }\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        graph.resize(100005);\\n        t_graph.resize(100005);\\n        int n = edges.size();\\n        for (int i=0; i<n; i++) {\\n            if (edges[i] == -1) continue;\\n            graph[i].push_back(edges[i]);\\n            t_graph[edges[i]].push_back(i);\\n        }\\n        vis.reset();\\n        for (int i=0; i<n; i++) {\\n            if(!vis[i]) dfs(i);\\n        }\\n        vis.reset();\\n        int ans = -1;\\n        while(!st.empty()) {\\n            int node = st.top();\\n            st.pop();\\n            if (!vis[node]) {\\n                int cnt_nodes = 0;\\n                dfs_2(node, cnt_nodes);\\n                if(cnt_nodes > 1) ans = max(ans, cnt_nodes);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> graph;\\n    vector<vector<int>> t_graph;\\n    stack<int> st;\\n    bitset<100005> vis;\\n\\n    void dfs(int node) {\\n        vis[node] = 1;\\n        for (auto e: graph[node]) {\\n            if (!vis[e]) dfs(e);\\n        }\\n        st.push(node);\\n    }\\n\\n    void dfs_2(int node, int& nodes) {\\n        nodes+=1;\\n        vis[node] = 1;\\n\\n        for (auto e: t_graph[node]) {\\n            if(!vis[e]) dfs_2(e, nodes);\\n        }\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        graph.resize(100005);\\n        t_graph.resize(100005);\\n        int n = edges.size();\\n        for (int i=0; i<n; i++) {\\n            if (edges[i] == -1) continue;\\n            graph[i].push_back(edges[i]);\\n            t_graph[edges[i]].push_back(i);\\n        }\\n        vis.reset();\\n        for (int i=0; i<n; i++) {\\n            if(!vis[i]) dfs(i);\\n        }\\n        vis.reset();\\n        int ans = -1;\\n        while(!st.empty()) {\\n            int node = st.top();\\n            st.pop();\\n            if (!vis[node]) {\\n                int cnt_nodes = 0;\\n                dfs_2(node, cnt_nodes);\\n                if(cnt_nodes > 1) ans = max(ans, cnt_nodes);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343228,
                "title": "ruby-t-s-o-n-o-n-7-liner",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```ruby\\ndef longest_cycle(edges)\\n    t, vis = 1, Array.new(edges.size)\\n    vis.each_with_index.inject(-1) {|maxc, (v, i)|\\n        next maxc unless v.nil?\\n        start, j = t, i\\n        vis[j], j = (t += 1) - 1, edges[j] while !j.negative? && vis[j].nil?\\n        (j.negative? || vis[j] < start) ? maxc : [maxc, t - vis[j]].max\\n    }\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef longest_cycle(edges)\\n    t, vis = 1, Array.new(edges.size)\\n    vis.each_with_index.inject(-1) {|maxc, (v, i)|\\n        next maxc unless v.nil?\\n        start, j = t, i\\n        vis[j], j = (t += 1) - 1, edges[j] while !j.negative? && vis[j].nil?\\n        (j.negative? || vis[j] < start) ? maxc : [maxc, t - vis[j]].max\\n    }\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3343081,
                "title": "c-easy-to-understand-solution-for-dfs-lover",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343062,
                "title": "golang-topological-sort",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc longestCycle(edges []int) int {\\n    n := len(edges)\\n    visited := make([]bool, n)\\n    inDegree := make([]int, n)\\n\\n    // Calculate InDegree for each Nodes, O(N)\\n    for _, edge := range edges {\\n        if edge != -1 {\\n            inDegree[edge]++\\n        }\\n    }\\n\\n    // Find all Nodes with 0-Indegree, O(N)\\n    queue := []int{}\\n    for i := 0; i < n; i++ {\\n        if inDegree[i] == 0 {\\n            queue = append(queue, i)\\n        }\\n    }\\n\\n    // Remove all Nodes which are not part of cycles, O(N)\\n    for len(queue) > 0 {\\n        node := queue[0]\\n        queue = queue[1:]\\n\\n        visited[node] = true\\n        next := edges[node]\\n        if next != -1 {\\n            inDegree[next]--\\n            if inDegree[next] == 0 {\\n                queue = append(queue, next)\\n            }\\n        }\\n    }\\n\\n    // Calculate length of each loop, O(N)\\n    res := -1\\n    for i := 0; i < n; i++ {\\n        if !visited[i] {    // Definitely in Loop\\n            count := 1\\n            next := edges[i]\\n            for next != i {\\n                visited[next] = true\\n                count++\\n                next = edges[next]\\n            }\\n            res = max(res, count)\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestCycle(edges []int) int {\\n    n := len(edges)\\n    visited := make([]bool, n)\\n    inDegree := make([]int, n)\\n\\n    // Calculate InDegree for each Nodes, O(N)\\n    for _, edge := range edges {\\n        if edge != -1 {\\n            inDegree[edge]++\\n        }\\n    }\\n\\n    // Find all Nodes with 0-Indegree, O(N)\\n    queue := []int{}\\n    for i := 0; i < n; i++ {\\n        if inDegree[i] == 0 {\\n            queue = append(queue, i)\\n        }\\n    }\\n\\n    // Remove all Nodes which are not part of cycles, O(N)\\n    for len(queue) > 0 {\\n        node := queue[0]\\n        queue = queue[1:]\\n\\n        visited[node] = true\\n        next := edges[node]\\n        if next != -1 {\\n            inDegree[next]--\\n            if inDegree[next] == 0 {\\n                queue = append(queue, next)\\n            }\\n        }\\n    }\\n\\n    // Calculate length of each loop, O(N)\\n    res := -1\\n    for i := 0; i < n; i++ {\\n        if !visited[i] {    // Definitely in Loop\\n            count := 1\\n            next := edges[i]\\n            for next != i {\\n                visited[next] = true\\n                count++\\n                next = edges[next]\\n            }\\n            res = max(res, count)\\n        }\\n    }\\n\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342798,
                "title": "simple-dfs-approach-with-graph-reversing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve thi\\n# Ap-->\\nstep 1  reverse the graph \\nthe basic intuition behind reversing the graph is lower thje number of dfs calls that ends up having the same cycle which can further leads to tle\\nstep2-make adjaceny matrix\\ninially we are given directed edge from i to edges[i] but we will be storing directed edge from edges[i] to i in our adjancy matrix\\n\\nstep3 make dfs call for diff part of the graph by taking a  vis array \\neach dfs call return a node that is a part of cycle in that part or -1 if no cycle exist in that part\\nhere each part means all the nodes that are reachable thorugh the curr node from which dfs call was initiated\\nif dfs return a cycle we calculate the cycle length using edges[i] \\nthe condition is that same node when reached again in while loop till then increment the cycle \\nfinally return the most optimal cycle length\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int  dfs(int node,vector<vector<int>>&adj,vector<bool>&vis,set<int>&st){\\n        //first clarify what this function is doing and returning\\n        vis[node]=true;\\n        st.insert(node);\\n        int curr=-1;\\n        for(auto e:adj[node]){\\n            if(st.find(e)!=st.end()){\\n                return e;\\n            }else{\\n                curr=max(curr,dfs(e,adj,vis,st));\\n            }\\n        }\\n        //if there is a cyle then current dfs call will return any node that is a part of that cycle\\n\\n        return curr;\\n        \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        //what is the inutition \\n        //the intuition here is to check for cycle then calculate cycle length for each diff cycle that exists\\n        //if we try to dry run we found that multiple dfs calls will made as in  example 1 for the same cycle\\n        //for some big graph input that will be giving tle\\n        //we by reversing the graph we can reduce that number of dfs calls to the same graph \\n        //and greedily that works for many q of graph \\n\\n        int n=edges.size();\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<n;i++){\\n          if(edges[i]!=-1)  adj[edges[i]].push_back(i);\\n            //here reversing the graph means reversing the direction of edges weights in them \\n\\n        }\\n        //how to reverse the edges\\n        \\n        int ans=-1;\\n\\n        vector<bool>vis(n,false);\\n        for(int i=0;i<n;i++){\\n            if(vis[i])continue;\\n            set<int>st;\\n            int c=dfs(i,adj,vis,st);\\n            if(c!=-1){\\n                //there is a cycle at some node \\n                //now calculate the cycle length from this dfs call\\n                int cv=i;\\n                int cl=1;\\n                while(edges[cv]!=i){\\n                    cv=edges[cv];\\n                    cl++;\\n                }\\n                ans=max(ans,cl);\\n\\n            }\\n\\n        }\\n        //finally we will be returning the most optimal answer\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    int  dfs(int node,vector<vector<int>>&adj,vector<bool>&vis,set<int>&st){\\n        //first clarify what this function is doing and returning\\n        vis[node]=true;\\n        st.insert(node);\\n        int curr=-1;\\n        for(auto e:adj[node]){\\n            if(st.find(e)!=st.end()){\\n                return e;\\n            }else{\\n                curr=max(curr,dfs(e,adj,vis,st));\\n            }\\n        }\\n        //if there is a cyle then current dfs call will return any node that is a part of that cycle\\n\\n        return curr;\\n        \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        //what is the inutition \\n        //the intuition here is to check for cycle then calculate cycle length for each diff cycle that exists\\n        //if we try to dry run we found that multiple dfs calls will made as in  example 1 for the same cycle\\n        //for some big graph input that will be giving tle\\n        //we by reversing the graph we can reduce that number of dfs calls to the same graph \\n        //and greedily that works for many q of graph \\n\\n        int n=edges.size();\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<n;i++){\\n          if(edges[i]!=-1)  adj[edges[i]].push_back(i);\\n            //here reversing the graph means reversing the direction of edges weights in them \\n\\n        }\\n        //how to reverse the edges\\n        \\n        int ans=-1;\\n\\n        vector<bool>vis(n,false);\\n        for(int i=0;i<n;i++){\\n            if(vis[i])continue;\\n            set<int>st;\\n            int c=dfs(i,adj,vis,st);\\n            if(c!=-1){\\n                //there is a cycle at some node \\n                //now calculate the cycle length from this dfs call\\n                int cv=i;\\n                int cl=1;\\n                while(edges[cv]!=i){\\n                    cv=edges[cv];\\n                    cl++;\\n                }\\n                ans=max(ans,cl);\\n\\n            }\\n\\n        }\\n        //finally we will be returning the most optimal answer\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342782,
                "title": "dfs-hashmap-c",
                "content": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, unordered_map<int, int> &m, int p, int &ans) {\\n        vis[node] = 1;\\n        for(int ad : adj[node]) {\\n            if(m.find(ad) != m.end()) ans = max(ans, p - m[ad]);\\n            m[ad] = p++;\\n            if(!vis[ad]) dfs(ad, adj, vis, m, p, ans);\\n        }\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size(), ans = -1;\\n        vector<int> adj[n];\\n        for(int i=0; i<n; i++) {\\n            if(edges[i] != -1) adj[i].push_back(edges[i]);\\n        }\\n        vector<int> vis(n);\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) {\\n                unordered_map<int, int> m;\\n                m[i] = 0;\\n                dfs(i, adj, vis, m, 1, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, unordered_map<int, int> &m, int p, int &ans) {\\n        vis[node] = 1;\\n        for(int ad : adj[node]) {\\n            if(m.find(ad) != m.end()) ans = max(ans, p - m[ad]);\\n            m[ad] = p++;\\n            if(!vis[ad]) dfs(ad, adj, vis, m, p, ans);\\n        }\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size(), ans = -1;\\n        vector<int> adj[n];\\n        for(int i=0; i<n; i++) {\\n            if(edges[i] != -1) adj[i].push_back(edges[i]);\\n        }\\n        vector<int> vis(n);\\n        for(int i=0; i<n; i++) {\\n            if(!vis[i]) {\\n                unordered_map<int, int> m;\\n                m[i] = 0;\\n                dfs(i, adj, vis, m, 1, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342756,
                "title": "c-bfs-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor all nodes we will transvers keeping the count of the depth we have passed and if we see a cycle we consider that to be an probable answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo BFS/ DFS transversal keeping the depth we have come so far in the graph using queue/ stack. \\n\\nCases:\\n- Now when we visit a node which we have already seen it will not contribute to answer(2nd point is spl case), if it forms a cycle we will not reach it transversing form another node.\\n- Only we will consider a node to contirbute to answer if we visit a node whihc has been marked as visited by the current loop iteration of i. Hence v[node]=i is important to know if we consider the visited element forms a cycle.\\n\\nThe sz array is used to tell us if we start somewhere eles but a part of the graph form a cycle(Test case 1 , we start with zero but going down another part of array gives us answer), we can use sz to find the depth which we seen the node earlier.\\n\\n# Complexity\\n- Time complexity:O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int ans=0, te=0;\\n        queue<pair<int,int>> bfs;\\n        pair<int,int> p;\\n        vector<int> v(edges.size(),-1), sz(edges.size());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(v[i]==-1 && edges[i]!=-1) bfs.push({i,1}),sz[i]=1, v[i]=i;\\n            while(!bfs.empty())\\n            {\\n                p=bfs.front();\\n                bfs.pop();\\n                //If no edge is formed break and remove all elements from the loop\\n                if(edges[p.first]==-1) break;\\n                if(v[edges[p.first]]==-1) bfs.push({edges[p.first],p.second+1}) , sz[edges[p.first]]=p.second+1, v[edges[p.first]]=i;\\n                //When a cycle forms , I see a visited node which has been marked visted by the current iteration of i.\\n                else if(v[edges[p.first]]==i) ans=max(ans, p.second-sz[edges[p.first]]+1);\\n                else break;\\n            }\\n            while(!bfs.empty()) bfs.pop();\\n        }\\n        return ans==0?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int ans=0, te=0;\\n        queue<pair<int,int>> bfs;\\n        pair<int,int> p;\\n        vector<int> v(edges.size(),-1), sz(edges.size());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            if(v[i]==-1 && edges[i]!=-1) bfs.push({i,1}),sz[i]=1, v[i]=i;\\n            while(!bfs.empty())\\n            {\\n                p=bfs.front();\\n                bfs.pop();\\n                //If no edge is formed break and remove all elements from the loop\\n                if(edges[p.first]==-1) break;\\n                if(v[edges[p.first]]==-1) bfs.push({edges[p.first],p.second+1}) , sz[edges[p.first]]=p.second+1, v[edges[p.first]]=i;\\n                //When a cycle forms , I see a visited node which has been marked visted by the current iteration of i.\\n                else if(v[edges[p.first]]==i) ans=max(ans, p.second-sz[edges[p.first]]+1);\\n                else break;\\n            }\\n            while(!bfs.empty()) bfs.pop();\\n        }\\n        return ans==0?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342742,
                "title": "easy-c-solution-modified-dfs-hard-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan we slightly modify the DFS cycle finding algorithm of directed graph??\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We just need to find the length of the longest cycle , so we find length of each cycle and store the maximum of all the lengths.\\n- For that we slightly modify the dfs function :\\n    1. We store the length of the path till the particular node in dfsvis vector\\n    2. Whenever we find a cycle , we get the length by current_length - length_of_the_path_till_the_node_which_actually_caused_the_cycle \\n    3. We store the maximum of all such cycles\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs_cycle(int node,vector<int> adj[], vector<int> & vis, vector<int> & dfsvis, int &length, int &max_length) {\\n        // MODIFIED DFS FUNCTION for cycle finding in directed graph \\n        length++;\\n        vis[node] = 1;\\n        dfsvis[node] = length;\\n        \\n        for(auto it : adj[node]) {\\n            if(vis[it] == -1) {\\n                dfs_cycle(it, adj, vis, dfsvis, length, max_length);\\n            }\\n            else if (dfsvis[it] != -1) {\\n                max_length = max(max_length , length - dfsvis[it] + 1);\\n            }\\n        }\\n        length--;\\n        dfsvis[node] = -1;\\n\\n\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> adj[n];\\n\\n        //creating adjacency list(graph)\\n        for(int i = 0 ; i < n ; i++) {\\n            if(edges[i]!=-1)\\n            adj[i].push_back(edges[i]);\\n        }\\n\\n        //GENERAL CYCLE FINDING DFS \\n        vector<int> vis(n,-1);\\n        vector<int> dfsvis(n,-1);\\n        int length=1, max_length=-1;\\n        for(int i = 0; i < n ; i++){\\n            length = 0;\\n            if(vis[i] == -1) {\\n            dfs_cycle(i , adj, vis, dfsvis, length, max_length);\\n            }\\n        }\\n        return max_length;\\n    }\\n};\\n```\\nPLEASE UPVOTE IF IT HELPED !! :)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs_cycle(int node,vector<int> adj[], vector<int> & vis, vector<int> & dfsvis, int &length, int &max_length) {\\n        // MODIFIED DFS FUNCTION for cycle finding in directed graph \\n        length++;\\n        vis[node] = 1;\\n        dfsvis[node] = length;\\n        \\n        for(auto it : adj[node]) {\\n            if(vis[it] == -1) {\\n                dfs_cycle(it, adj, vis, dfsvis, length, max_length);\\n            }\\n            else if (dfsvis[it] != -1) {\\n                max_length = max(max_length , length - dfsvis[it] + 1);\\n            }\\n        }\\n        length--;\\n        dfsvis[node] = -1;\\n\\n\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int> adj[n];\\n\\n        //creating adjacency list(graph)\\n        for(int i = 0 ; i < n ; i++) {\\n            if(edges[i]!=-1)\\n            adj[i].push_back(edges[i]);\\n        }\\n\\n        //GENERAL CYCLE FINDING DFS \\n        vector<int> vis(n,-1);\\n        vector<int> dfsvis(n,-1);\\n        int length=1, max_length=-1;\\n        for(int i = 0; i < n ; i++){\\n            length = 0;\\n            if(vis[i] == -1) {\\n            dfs_cycle(i , adj, vis, dfsvis, length, max_length);\\n            }\\n        }\\n        return max_length;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342734,
                "title": "2360-longest-cycle-in-a-graph-java",
                "content": "```\\nclass Solution {\\n    int ans=-1;\\n    public int longestCycle(int[] edges) {\\n        boolean[] vis=new boolean[edges.length];\\n        boolean[] check=new boolean[edges.length];\\n        int[] dis=new int[edges.length];\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            if(!vis[i])\\n                dfs(i,vis,check,dis,edges,0);\\n        }\\n        return ans;\\n    }\\n    public void dfs(int node,boolean []vis,boolean []check,int [] dis,int []edges,int distance)\\n    {\\n        if(node!=-1)\\n        {\\n            if(!vis[node])\\n            {\\n                vis[node]=true;\\n                check[node]=true;\\n                dis[node]=distance;\\n                dfs(edges[node],vis,check,dis,edges,distance+1);\\n            }\\n            else if(check[node])\\n            {\\n                ans=Math.max(ans,distance-dis[node]);\\n            }\\n            check[node]=false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans=-1;\\n    public int longestCycle(int[] edges) {\\n        boolean[] vis=new boolean[edges.length];\\n        boolean[] check=new boolean[edges.length];\\n        int[] dis=new int[edges.length];\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            if(!vis[i])\\n                dfs(i,vis,check,dis,edges,0);\\n        }\\n        return ans;\\n    }\\n    public void dfs(int node,boolean []vis,boolean []check,int [] dis,int []edges,int distance)\\n    {\\n        if(node!=-1)\\n        {\\n            if(!vis[node])\\n            {\\n                vis[node]=true;\\n                check[node]=true;\\n                dis[node]=distance;\\n                dfs(edges[node],vis,check,dis,edges,distance+1);\\n            }\\n            else if(check[node])\\n            {\\n                ans=Math.max(ans,distance-dis[node]);\\n            }\\n            check[node]=false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342707,
                "title": "c-topological-sort-dfs",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int ans = -1;\\n\\n    void dfs(vector<int>& edges, int src, vector<int>& visited, vector<int>& dfsVisited) {\\n        visited[src] = 1;\\n        dfsVisited[src] = 1;\\n\\n        int next = edges[src];\\n\\n        if(next == -1) dfsVisited[src] = 0;\\n        else if(!visited[next]) dfs(edges, next, visited, dfsVisited);\\n        else if(dfsVisited[next]) {\\n            int count = 0;\\n            for(int i = 0; i < edges.size(); i++) {\\n                if(dfsVisited[i]) count++;\\n            }\\n            ans = max(ans, count);\\n        } \\n\\n        dfsVisited[src] = 0;\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n\\n        queue<int> q;\\n        vector<int> visited(n, 0);\\n        vector<int> indegree(n, 0);\\n        vector<int> dfsVisited(n, 0);\\n\\n        for(int i = 0; i < n; i++) {\\n            if(edges[i] != -1) {\\n                indegree[edges[i]]++;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            if(!indegree[i]) {\\n                q.push(i);\\n                visited[i] = 1;\\n            }\\n        }\\n\\n        while(!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int next = edges[curr];\\n\\n            if(next != -1 && --indegree[next] == 0) {\\n                q.push(next);\\n                visited[next] = 1;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) {\\n                dfs(edges, i, visited, dfsVisited);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int ans = -1;\\n\\n    void dfs(vector<int>& edges, int src, vector<int>& visited, vector<int>& dfsVisited) {\\n        visited[src] = 1;\\n        dfsVisited[src] = 1;\\n\\n        int next = edges[src];\\n\\n        if(next == -1) dfsVisited[src] = 0;\\n        else if(!visited[next]) dfs(edges, next, visited, dfsVisited);\\n        else if(dfsVisited[next]) {\\n            int count = 0;\\n            for(int i = 0; i < edges.size(); i++) {\\n                if(dfsVisited[i]) count++;\\n            }\\n            ans = max(ans, count);\\n        } \\n\\n        dfsVisited[src] = 0;\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n\\n        queue<int> q;\\n        vector<int> visited(n, 0);\\n        vector<int> indegree(n, 0);\\n        vector<int> dfsVisited(n, 0);\\n\\n        for(int i = 0; i < n; i++) {\\n            if(edges[i] != -1) {\\n                indegree[edges[i]]++;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            if(!indegree[i]) {\\n                q.push(i);\\n                visited[i] = 1;\\n            }\\n        }\\n\\n        while(!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n\\n            int next = edges[curr];\\n\\n            if(next != -1 && --indegree[next] == 0) {\\n                q.push(next);\\n                visited[next] = 1;\\n            }\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            if(!visited[i]) {\\n                dfs(edges, i, visited, dfsVisited);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342637,
                "title": "c-bfs-dfs-graph-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(V+E)$$\\n\\n- Space complexity:$$O(3V)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=-1;\\n    void dfs(int i, int cnt, vector<int>&v, vector<int>adj[]){\\n        v[i]=1;\\n        cnt++;\\n        ans=max(ans, cnt);\\n       // cout<<i<<\" \"<<cnt<<endl;\\n        for(auto it: adj[i]){\\n            if(!v[it]){\\n                dfs(it, cnt, v, adj);\\n            }\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            if(edges[i]!=-1){adj[i].push_back(edges[i]);}\\n        }\\n        vector<int>v(n, 0), v1(n, 0);\\n        for(int i=0; i<n; i++){\\n            for(auto it: adj[i]){\\n                v[it]++;\\n            }\\n        }\\n        int cnt=0;\\n        queue<int>q;\\n        for(int i=0; i<n; i++){\\n            if(!v[i]){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int l=q.front();\\n            q.pop();\\n            for(auto it: adj[l]){\\n                cnt++;\\n                v[it]--;\\n                if(v[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(cnt==n){\\n            return ans;\\n        }\\n        for(int i=0; i<n; i++){\\n            int cnt1=0;\\n            if(!v1[i] && v[i]){\\n                dfs(i, cnt1, v1, adj);\\n            }\\n            //ans=max(ans, cnt1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=-1;\\n    void dfs(int i, int cnt, vector<int>&v, vector<int>adj[]){\\n        v[i]=1;\\n        cnt++;\\n        ans=max(ans, cnt);\\n       // cout<<i<<\" \"<<cnt<<endl;\\n        for(auto it: adj[i]){\\n            if(!v[it]){\\n                dfs(it, cnt, v, adj);\\n            }\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            if(edges[i]!=-1){adj[i].push_back(edges[i]);}\\n        }\\n        vector<int>v(n, 0), v1(n, 0);\\n        for(int i=0; i<n; i++){\\n            for(auto it: adj[i]){\\n                v[it]++;\\n            }\\n        }\\n        int cnt=0;\\n        queue<int>q;\\n        for(int i=0; i<n; i++){\\n            if(!v[i]){\\n                q.push(i);\\n            }\\n        }\\n        while(!q.empty()){\\n            int l=q.front();\\n            q.pop();\\n            for(auto it: adj[l]){\\n                cnt++;\\n                v[it]--;\\n                if(v[it]==0){\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        if(cnt==n){\\n            return ans;\\n        }\\n        for(int i=0; i<n; i++){\\n            int cnt1=0;\\n            if(!v1[i] && v[i]){\\n                dfs(i, cnt1, v1, adj);\\n            }\\n            //ans=max(ans, cnt1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3342591,
                "title": "best-among-all",
                "content": "# Intuition\\nOnly cycle detection using dfs in directed graph with one extra condition.\\n\\n# Approach\\nBelive me dry run this code this is one of best solution among whole comments.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(vector<int>adj[],int s,vector<int>&vis,int &maxi,int prev,vector<int>&visi)\\n    {\\n        vis[s]=prev;\\n        visi[s]=1;\\n\\n        for(auto ele:adj[s])\\n        {\\n            if(vis[ele]==0)\\n            {\\n                dfs(adj,ele,vis,maxi,prev+1,visi);\\n            }\\n            else if(vis[ele]!=0 and visi[ele]==1)\\n            {\\n                maxi=max(maxi,vis[s]+1-vis[ele]);\\n            }\\n        }\\n        visi[s]=0;\\n        // return ;\\n\\n    }\\n    int longestCycle(vector<int>& edges) {\\n\\n        int n=edges.size();\\n\\n        vector<int>adj[n];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(edges[i]==-1)continue;\\n            adj[i].push_back(edges[i]);\\n        }\\n\\n        vector<int>vis(n,0);\\n\\n        int maxi=INT_MIN;\\n\\n        vector<int>visi=vis;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                dfs(adj,i,vis,maxi,1,visi);\\n            }\\n        }\\n\\n        return maxi==INT_MIN?-1:maxi;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(vector<int>adj[],int s,vector<int>&vis,int &maxi,int prev,vector<int>&visi)\\n    {\\n        vis[s]=prev;\\n        visi[s]=1;\\n\\n        for(auto ele:adj[s])\\n        {\\n            if(vis[ele]==0)\\n            {\\n                dfs(adj,ele,vis,maxi,prev+1,visi);\\n            }\\n            else if(vis[ele]!=0 and visi[ele]==1)\\n            {\\n                maxi=max(maxi,vis[s]+1-vis[ele]);\\n            }\\n        }\\n        visi[s]=0;\\n        // return ;\\n\\n    }\\n    int longestCycle(vector<int>& edges) {\\n\\n        int n=edges.size();\\n\\n        vector<int>adj[n];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(edges[i]==-1)continue;\\n            adj[i].push_back(edges[i]);\\n        }\\n\\n        vector<int>vis(n,0);\\n\\n        int maxi=INT_MIN;\\n\\n        vector<int>visi=vis;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(vis[i]==0)\\n            {\\n                dfs(adj,i,vis,maxi,1,visi);\\n            }\\n        }\\n\\n        return maxi==INT_MIN?-1:maxi;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342094,
                "title": "typescript-dfs-topological-sorting-o-n-time-o-n-space",
                "content": "# Intuition\\ntraverse through the graph and check for cycles, make sure to traverse a node once\\n\\n# Approach\\nUse Depth first Search to traverse through the Graph, and use a map | Object to keep track of the depth of every node passed\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n  $$O(n)$$ \\n\\n# Code\\n```\\nfunction longestCycle(edges: number[]): number {\\n    const seen = new Set();\\n    let result = -1;\\n    const DFS = (n:number,depth:number,register:Record<number,number>) => {\\n        // seen before in this loop \\n        if(register[n] != null){\\n            result = Math.max(depth - register[n], result)\\n        }else{\\n            // not seen in the loop & the node has never been seen\\n            if(!seen.has(n)){\\n                seen.add(n)\\n                const next = edges[n]\\n                if(next != -1){\\n                    register[n] = depth\\n                    DFS(next,depth+1,register)\\n                }else{\\n                    seen.add(next)\\n                }\\n            }\\n        }\\n    }\\n    for(const key in edges){\\n        if(!seen.has(key)){\\n            DFS(Number(key),0,{})\\n        }\\n    }\\n    return result\\n};\\n```\\n\\n## TOPOLOGICAL SORTING\\n\\n# Intuition\\nUsing topolgical sorting, you can get the nodes that are not in a cylce because they dont have infinite dependency, so we start from nodes that do not have any edges pointing to them, then we eliminate the node and their edges, then we get new nodes with no incoming edge we keep eliminating these nodes until there is non left \\n# Approach\\nUse topological search and DFS \\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n  $$O(n)$$ \\n\\n# Code\\n```\\n  function longestCycle(edges:number[]) : number {\\n    const seen = new Set();\\n    //topological sort,\\n    // we count number of nodes pointing to a particular node, \\n    const dependencyCount = new Array(edges.length).fill(0)\\n    for(const edge of edges){\\n        dependencyCount[edge]++\\n    }\\n    const queue = new Queue.Queue()\\n    // add nodes with no dependency to the queue. ie nodes with no other node currently pointing them\\n    for(let key = 0; key < edges.length; key++){\\n        if(dependencyCount[key] == 0){\\n            queue.enqueue(key)\\n            seen.add(key)\\n        }\\n    }\\n    while(queue.size() > 0){\\n        const node = queue.dequeue();\\n        const next = edges[node]\\n        dependencyCount[next]--\\n        if(dependencyCount[next] == 0){\\n            // push to queue\\n            queue.enqueue(next)\\n            seen.add(Number(next))\\n        }\\n    }\\n    // done with topology sorting\\n    // after this only nodes that are in a cycle have not been seen \\n    let result = -1;\\n    for(let key = 0; key < edges.length; key++){\\n        if(!seen.has(key)){\\n            let node = key \\n            let count = 0\\n            while(!seen.has(node)){\\n                count++\\n                seen.add(node)\\n                node = edges[node]\\n            }\\n            result = Math.max(result, count)\\n        }\\n    }\\n    return result}\\n```\\n\\n# Optimised DFS (using a while loop since we have only one path while traversing)\\n\\n```\\nfunction longestCycle(edges: number[]): number {\\n    const seen = new Set();\\n    let result = -1;\\n    for(let key = 0; key < edges.length;key++){\\n        if((key != -1) && !seen.has(key)){\\n            seen.add(key)\\n            let count = 0;\\n            let node = key\\n            let found = new Map()\\n            found.set(node,0)\\n            while(node != -1){\\n                count++\\n                node = edges[node]\\n                if(seen.has(node)){\\n                    if(found.has(node)){\\n                        result = Math.max(result,count - found.get(node))\\n                    }\\n                    break;\\n                }else{\\n                    found.set(node,count)\\n                    seen.add(node)\\n                }\\n            }\\n        }\\n    }\\n    return result\\n};\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript",
                    "Depth-First Search",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nfunction longestCycle(edges: number[]): number {\\n    const seen = new Set();\\n    let result = -1;\\n    const DFS = (n:number,depth:number,register:Record<number,number>) => {\\n        // seen before in this loop \\n        if(register[n] != null){\\n            result = Math.max(depth - register[n], result)\\n        }else{\\n            // not seen in the loop & the node has never been seen\\n            if(!seen.has(n)){\\n                seen.add(n)\\n                const next = edges[n]\\n                if(next != -1){\\n                    register[n] = depth\\n                    DFS(next,depth+1,register)\\n                }else{\\n                    seen.add(next)\\n                }\\n            }\\n        }\\n    }\\n    for(const key in edges){\\n        if(!seen.has(key)){\\n            DFS(Number(key),0,{})\\n        }\\n    }\\n    return result\\n};\\n```\n```\\n  function longestCycle(edges:number[]) : number {\\n    const seen = new Set();\\n    //topological sort,\\n    // we count number of nodes pointing to a particular node, \\n    const dependencyCount = new Array(edges.length).fill(0)\\n    for(const edge of edges){\\n        dependencyCount[edge]++\\n    }\\n    const queue = new Queue.Queue()\\n    // add nodes with no dependency to the queue. ie nodes with no other node currently pointing them\\n    for(let key = 0; key < edges.length; key++){\\n        if(dependencyCount[key] == 0){\\n            queue.enqueue(key)\\n            seen.add(key)\\n        }\\n    }\\n    while(queue.size() > 0){\\n        const node = queue.dequeue();\\n        const next = edges[node]\\n        dependencyCount[next]--\\n        if(dependencyCount[next] == 0){\\n            // push to queue\\n            queue.enqueue(next)\\n            seen.add(Number(next))\\n        }\\n    }\\n    // done with topology sorting\\n    // after this only nodes that are in a cycle have not been seen \\n    let result = -1;\\n    for(let key = 0; key < edges.length; key++){\\n        if(!seen.has(key)){\\n            let node = key \\n            let count = 0\\n            while(!seen.has(node)){\\n                count++\\n                seen.add(node)\\n                node = edges[node]\\n            }\\n            result = Math.max(result, count)\\n        }\\n    }\\n    return result}\\n```\n```\\nfunction longestCycle(edges: number[]): number {\\n    const seen = new Set();\\n    let result = -1;\\n    for(let key = 0; key < edges.length;key++){\\n        if((key != -1) && !seen.has(key)){\\n            seen.add(key)\\n            let count = 0;\\n            let node = key\\n            let found = new Map()\\n            found.set(node,0)\\n            while(node != -1){\\n                count++\\n                node = edges[node]\\n                if(seen.has(node)){\\n                    if(found.has(node)){\\n                        result = Math.max(result,count - found.get(node))\\n                    }\\n                    break;\\n                }else{\\n                    found.set(node,count)\\n                    seen.add(node)\\n                }\\n            }\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3342051,
                "title": "beginner-friendly-very-easy-dfs-based-solution-explained-solution-corner-case-java",
                "content": "#\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s undertstand the problem first:\\n1. We have at max one outgoing edge. So cycle detection becomes super easy and can be done in same way as undirected.(We don\\'t need to go through conventional method of detecting cycle as we do for directed graph).\\n2. -1 at any index shows that node don\\'t have any outgoing edge.\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS can be used to solve this problem very easily.\\nFollow the below steps:\\n1. Take a boolean array for keeping track of visited nodes.\\n2. We need to take an array for each new dfs call so that we can keep all the elements which  can be reached in that call at once--> This will help in finding the length of the cycle encountered if present there.\\n3. if src node is -1 then return.\\n4. if the src node is not visited --> Mark it visited --> put that node into the dfsCall array --> do dfs again for that node.\\n5. Now if we encounter any node which is visited in the same dfs call and visited previously.\\n6. Traverse the dfsCall array and find the position of the that node which is encountered again.---> Note its position\\n7. do max = max(max,dfsCall.size()-positionLastEncoutered) // to get the maxLength of the cycle.\\n\\n--> **Note**: We need to also consider a corner case when the element is encounter again but not in the dfsCall array(which means there is no cycle in the array)\\nConsider the edges[] = [-1,4,-1,2,0,4];\\n- After 0 will be marked initially.\\n- when you will reach 0 again through dfs call for 1 dfsCall array would look like [1,4] but you will not find 0 inside the same and will end in giving wrong ans for the same.\\n- So make a check if lastPosition ==-1 simply return.\\n![image.png](https://assets.leetcode.com/users/images/28792917-a4a9-4cbb-a816-fd51a203b684_1679805133.9150915.png)\\n\\n- **Here is the Solution: Please upvote if it helps you thank you.**\\n\\n\\nclass Solution {\\n    \\n    int max = -1;\\n    public void dfs(int[] edges,boolean visited[],int n,int src,ArrayList<Integer> dfsCallDist){\\n\\n        if(src == -1) return;\\n\\n\\n       // if the node called is visited then\\n\\n       if(visited[src] == true){\\n           \\n           int lastVisitPosition = -1;\\n           for(int i=0;i<dfsCallDist.size();i++){\\n                 \\n                 if(dfsCallDist.get(i) == src){\\n                    lastVisitPosition = i;\\n                    break;\\n                 }\\n                 \\n           }\\n         // System.out.println(lastVisitPosition);\\n           if(lastVisitPosition == -1) return;\\n           \\n           \\n            max = Math.max(max,dfsCallDist.size()-lastVisitPosition);\\n            return;\\n       }\\n       \\n      \\n       \\n        \\n        // if the source node is not visited then\\n\\n        visited[src] = true;\\n        dfsCallDist.add(src);\\n        dfs(edges,visited,n,edges[src],dfsCallDist);\\n        return;\\n\\n\\n\\n    }\\n    public int longestCycle(int[] edges) {\\n        \\n        int n = edges.length; // Total nodes in the graph\\n        // -1 represents that there is no furthur edge\\n        boolean visited[] = new boolean[n];\\n\\n        for(int i=0;i<n;i++){\\n\\n            ArrayList<Integer> dfsCallDist = new ArrayList<>();\\n\\n            if(visited[i] == false){\\n                dfs(edges,visited,n,i,dfsCallDist);\\n            }\\n\\n        }\\n\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    int max = -1;\\n    public void dfs(int[] edges,boolean visited[],int n,int src,ArrayList<Integer> dfsCallDist){\\n\\n        if(src == -1) return;\\n\\n\\n       // if the node called is visited then\\n\\n       if(visited[src] == true){\\n           \\n           int lastVisitPosition = -1;\\n           for(int i=0;i<dfsCallDist.size();i++){\\n                 \\n                 if(dfsCallDist.get(i) == src){\\n                    lastVisitPosition = i;\\n                    break;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 3341855,
                "title": "java-runtime-67-ms-beats-54-83-memory-58-7-mb-beats-84-56",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n    int res = -1;\\n    boolean[] vis = new boolean[edges.length]; // global visisted\\n\\n    for(int i=0; i<edges.length; i++){\\n        if(vis[i]) continue;\\n        HashMap<Integer, Integer> x = new HashMap<>();  // local visited\\n        for (int idx=i, dist=0; idx!=-1; idx=edges[idx]){\\n            if(x.containsKey(idx)){\\n                res = Math.max(res, dist-x.get(idx));\\n                break;\\n            }\\n            if(vis[idx]) break;\\n            vis[idx] = true;\\n            x.put(idx, dist++);\\n        } \\n    }\\n    return res;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n    int res = -1;\\n    boolean[] vis = new boolean[edges.length]; // global visisted\\n\\n    for(int i=0; i<edges.length; i++){\\n        if(vis[i]) continue;\\n        HashMap<Integer, Integer> x = new HashMap<>();  // local visited\\n        for (int idx=i, dist=0; idx!=-1; idx=edges[idx]){\\n            if(x.containsKey(idx)){\\n                res = Math.max(res, dist-x.get(idx));\\n                break;\\n            }\\n            if(vis[idx]) break;\\n            vis[idx] = true;\\n            x.put(idx, dist++);\\n        } \\n    }\\n    return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341812,
                "title": "easy-solution-in-java",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int[] cycleLength = new int[edges.length];\\n        Arrays.fill(cycleLength, -1);\\n        boolean[] visited = new boolean[edges.length];\\n        int max = -1;\\n        for (int i = 0; i < edges.length; i++) {\\n            if (!visited[i]) {\\n                visited[i] = true;\\n                int destination = edges[i];\\n                int length = 1;\\n                HashMap<Integer, Integer> nodeToDistance = new HashMap<>();\\n                nodeToDistance.put(i, 0);\\n                while (destination != -1 && !visited[destination]) {\\n                    nodeToDistance.put(destination, length);\\n                    visited[destination] = true;\\n                    destination = edges[destination];\\n                    length++;\\n                }\\n                if (destination != -1 && nodeToDistance.containsKey(destination)) {\\n                    System.out.println(nodeToDistance);\\n                    cycleLength[destination] = length - nodeToDistance.get(destination);\\n                    max = Math.max(length - nodeToDistance.get(destination), max);\\n                }\\n            } \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int[] cycleLength = new int[edges.length];\\n        Arrays.fill(cycleLength, -1);\\n        boolean[] visited = new boolean[edges.length];\\n        int max = -1;\\n        for (int i = 0; i < edges.length; i++) {\\n            if (!visited[i]) {\\n                visited[i] = true;\\n                int destination = edges[i];\\n                int length = 1;\\n                HashMap<Integer, Integer> nodeToDistance = new HashMap<>();\\n                nodeToDistance.put(i, 0);\\n                while (destination != -1 && !visited[destination]) {\\n                    nodeToDistance.put(destination, length);\\n                    visited[destination] = true;\\n                    destination = edges[destination];\\n                    length++;\\n                }\\n                if (destination != -1 && nodeToDistance.containsKey(destination)) {\\n                    System.out.println(nodeToDistance);\\n                    cycleLength[destination] = length - nodeToDistance.get(destination);\\n                    max = Math.max(length - nodeToDistance.get(destination), max);\\n                }\\n            } \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341807,
                "title": "easy-to-understand-bfs-dfs-optimized-approach",
                "content": "# Complexity\\n- Time complexity: `O(V+E)`\\n\\n- Space complexity: `O(V+E)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& edges, int u, vector<bool>& vis, int &count)\\n    {\\n        vis[u] = true; \\n        count++;\\n        \\n        if(edges[u] != -1 && vis[edges[u]] == false)\\n        {\\n            dfs(edges, edges[u], vis, count);\\n        }\\n    }\\n    \\n    int longestCycle(vector<int>& edges) \\n    {\\n        int n = edges.size();       \\n        vector<int> indegree(n, 0);        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int v = edges[i];\\n            \\n            if(v != -1)\\n            {\\n                indegree[v]++;\\n            }\\n        }       \\n        queue<int> q;       \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }        \\n        while(!q.empty())\\n        {\\n            int u = q.front();            \\n            q.pop();           \\n            if(edges[u] != -1)\\n            {\\n                indegree[edges[u]]--;              \\n                if(indegree[edges[u]] == 0)\\n                {\\n                    q.push(edges[u]);\\n                }\\n            }\\n        }       \\n        vector<bool> vis(n, false);        \\n        int maximum = INT_MIN;        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;          \\n            if(indegree[i] > 0 && vis[i] == false)\\n            {\\n                dfs(edges, i, vis, count);\\n            }            \\n            maximum = max(maximum, count);\\n        }\\n               \\n        if(maximum == 0)\\n            return -1;       \\n        return maximum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& edges, int u, vector<bool>& vis, int &count)\\n    {\\n        vis[u] = true; \\n        count++;\\n        \\n        if(edges[u] != -1 && vis[edges[u]] == false)\\n        {\\n            dfs(edges, edges[u], vis, count);\\n        }\\n    }\\n    \\n    int longestCycle(vector<int>& edges) \\n    {\\n        int n = edges.size();       \\n        vector<int> indegree(n, 0);        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int v = edges[i];\\n            \\n            if(v != -1)\\n            {\\n                indegree[v]++;\\n            }\\n        }       \\n        queue<int> q;       \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(indegree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }        \\n        while(!q.empty())\\n        {\\n            int u = q.front();            \\n            q.pop();           \\n            if(edges[u] != -1)\\n            {\\n                indegree[edges[u]]--;              \\n                if(indegree[edges[u]] == 0)\\n                {\\n                    q.push(edges[u]);\\n                }\\n            }\\n        }       \\n        vector<bool> vis(n, false);        \\n        int maximum = INT_MIN;        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int count = 0;          \\n            if(indegree[i] > 0 && vis[i] == false)\\n            {\\n                dfs(edges, i, vis, count);\\n            }            \\n            maximum = max(maximum, count);\\n        }\\n               \\n        if(maximum == 0)\\n            return -1;       \\n        return maximum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341764,
                "title": "python-topological-sort-daily-challenge-mar-day-26",
                "content": "# Intuition\\nuse topological sort to remove outermost nodes step by step,\\nwe remove outermost node by setting **edges[outermost_node] = -1**\\n\\nthen, we can iterate `edges` again and union remain connected components\\n\\n- if every connected component\\'s size is 1, it means there is NO cycle\\n- else we just return max size of connected component\\n\\n# Complexity\\n- Time complexity:\\n$$O(E+V)$$ = $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        indegree = [0] * n\\n        graph = defaultdict(list)\\n\\n        for u, v in enumerate(edges):\\n            if v == -1: continue\\n            graph[u].append(v)\\n            indegree[v] += 1\\n\\n        queue = deque([node for node, indeg in enumerate(indegree) if indeg == 0])\\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                edges[node] = -1\\n\\n                for nei in graph[node]:\\n                    indegree[nei] -= 1\\n                    if indegree[nei] == 0:\\n                        queue.append(nei)\\n        \\n        parent = list(range(n))\\n        rank = [1] * n\\n\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        for u, v in enumerate(edges):\\n            if v == -1: continue\\n            pu, pv = find(u), find(v)\\n            if pu == pv: continue\\n            if rank[pu] <= rank[pv]:\\n                parent[pv] = pu\\n                rank[pu] += rank[pv]\\n            else:\\n                parent[pu] = pv\\n                rank[pv] += rank[pu]\\n        mx = max(rank)\\n        return mx if mx != 1 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n = len(edges)\\n        indegree = [0] * n\\n        graph = defaultdict(list)\\n\\n        for u, v in enumerate(edges):\\n            if v == -1: continue\\n            graph[u].append(v)\\n            indegree[v] += 1\\n\\n        queue = deque([node for node, indeg in enumerate(indegree) if indeg == 0])\\n        while queue:\\n            for _ in range(len(queue)):\\n                node = queue.popleft()\\n                edges[node] = -1\\n\\n                for nei in graph[node]:\\n                    indegree[nei] -= 1\\n                    if indegree[nei] == 0:\\n                        queue.append(nei)\\n        \\n        parent = list(range(n))\\n        rank = [1] * n\\n\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n\\n        for u, v in enumerate(edges):\\n            if v == -1: continue\\n            pu, pv = find(u), find(v)\\n            if pu == pv: continue\\n            if rank[pu] <= rank[pv]:\\n                parent[pv] = pu\\n                rank[pu] += rank[pv]\\n            else:\\n                parent[pu] = pv\\n                rank[pv] += rank[pu]\\n        mx = max(rank)\\n        return mx if mx != 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341719,
                "title": "ruby-dfs",
                "content": "# Code\\n```ruby\\ndef longest_cycle(edges)\\n  max = -1\\n\\n  edges.size.times { |cur|\\n    next if edges[cur] < 0\\n    dists = {}\\n    dist = 0\\n    until cur < 0\\n      if dists[cur]\\n        cycle = dist - dists[cur]\\n        max = cycle if cycle > max\\n        break\\n      else\\n        dists[cur] = dist\\n        cur, edges[cur] = edges[cur], -1\\n        dist += 1\\n      end\\n    end\\n  }\\n  \\n  max\\nend\\n```\\n\\n# Time complexity\\n\\n$$\\\\mathcal{O}(|\\\\text{edges}|)$$\\n\\n# Space complexity\\n\\n$$\\\\mathcal{O}(|\\\\text{edges}|)$$",
                "solutionTags": [
                    "Ruby",
                    "Depth-First Search"
                ],
                "code": "```ruby\\ndef longest_cycle(edges)\\n  max = -1\\n\\n  edges.size.times { |cur|\\n    next if edges[cur] < 0\\n    dists = {}\\n    dist = 0\\n    until cur < 0\\n      if dists[cur]\\n        cycle = dist - dists[cur]\\n        max = cycle if cycle > max\\n        break\\n      else\\n        dists[cur] = dist\\n        cur, edges[cur] = edges[cur], -1\\n        dist += 1\\n      end\\n    end\\n  }\\n  \\n  max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3341657,
                "title": "cpp-solution-beats-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int>indeg(n);\\n        vector<int>vis(n);\\n        // count indegree of each node\\n        for(int i=0; i<n; i++){\\n            if(edges[i] != -1) indeg[edges[i]]++;\\n        }\\n        // Kahn\\'s algorithm\\n        queue<int>q;\\n        for(int i=0; i<n; i++){\\n            if(indeg[i] == 0) q.push(i);\\n        }\\n        while(!q.empty()){\\n            int top = q.front();\\n            vis[top] = 1;\\n            q.pop();\\n            if(edges[top] != -1){\\n                indeg[edges[top]]--;\\n                if(indeg[edges[top]] == 0) q.push(edges[top]);\\n            }\\n        }\\n        int ans = -1;\\n        for(int i=0; i<n; i++){\\n            // If all our visited, that means we dont have a cycle\\n            if(!vis[i]){\\n                int start = i;\\n                int curr = edges[i];\\n                vis[i] = 1;\\n                int c = 0;\\n                // find cycle length\\n                while(curr != start){\\n                    if(indeg[curr] == 0) break;\\n                    curr = edges[curr];\\n                    vis[curr] = 1;\\n                    c++;\\n                }\\n                ans = max(ans,c+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int>indeg(n);\\n        vector<int>vis(n);\\n        // count indegree of each node\\n        for(int i=0; i<n; i++){\\n            if(edges[i] != -1) indeg[edges[i]]++;\\n        }\\n        // Kahn\\'s algorithm\\n        queue<int>q;\\n        for(int i=0; i<n; i++){\\n            if(indeg[i] == 0) q.push(i);\\n        }\\n        while(!q.empty()){\\n            int top = q.front();\\n            vis[top] = 1;\\n            q.pop();\\n            if(edges[top] != -1){\\n                indeg[edges[top]]--;\\n                if(indeg[edges[top]] == 0) q.push(edges[top]);\\n            }\\n        }\\n        int ans = -1;\\n        for(int i=0; i<n; i++){\\n            // If all our visited, that means we dont have a cycle\\n            if(!vis[i]){\\n                int start = i;\\n                int curr = edges[i];\\n                vis[i] = 1;\\n                int c = 0;\\n                // find cycle length\\n                while(curr != start){\\n                    if(indeg[curr] == 0) break;\\n                    curr = edges[curr];\\n                    vis[curr] = 1;\\n                    c++;\\n                }\\n                ans = max(ans,c+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341640,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        visit=set()\\n        ranks=[float(\\'inf\\')]*n\\n\\n        def t(i,rank):\\n            if i in visit or edges[i]==-1:\\n                return -1\\n\\n            if ranks[i]<rank:\\n                return rank-ranks[i]\\n\\n            ranks[i]=rank\\n\\n            val=t(edges[i],rank+1)\\n            visit.add(i)\\n\\n            return val\\n\\n        return max(t(i,0) for i in range(n))           \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        visit=set()\\n        ranks=[float(\\'inf\\')]*n\\n\\n        def t(i,rank):\\n            if i in visit or edges[i]==-1:\\n                return -1\\n\\n            if ranks[i]<rank:\\n                return rank-ranks[i]\\n\\n            ranks[i]=rank\\n\\n            val=t(edges[i],rank+1)\\n            visit.add(i)\\n\\n            return val\\n\\n        return max(t(i,0) for i in range(n))           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341616,
                "title": "daily-leetcoding-challenge-march-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-cycle-in-a-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-cycle-in-a-graph/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3132491,
                "title": "c-dfs-cycle-detection-approach-easy-to-understand-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int ans,c;\\n    bool flag;\\n    void dfs(int node,int par,vector<int> &vis,vector<int> &dvis,vector<vector<int>> &adj,vector<int> & count)\\n    {\\n        vis[node]=1;\\n       dvis[node]=1;\\n        if(par==-1)\\n            count[node]=1;\\n        else\\n        count[node]=count[par]+1;\\n    for(auto it:adj[node])\\n    {\\n        if(!vis[it])\\n        {\\n           \\n            \\n            dfs(it,node,vis,dvis,adj,count);\\n           \\n        }\\n        else if(dvis[it]==1)\\n        {\\n           \\n            ans=max(ans,count[node]-count[it]+1);\\n            flag=true;\\n            \\n        }\\n    }\\n    dvis[node]=0;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(edges[i]!=-1)\\n            adj[i].push_back(edges[i]);\\n        }\\n        flag=false;\\n        ans=0;\\n        vector<int> count(n,0),vis(n,0),dvis(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                c=0;\\n                count.clear();\\n                dfs(i,-1,vis,dvis,adj,count);\\n            }\\n        }\\n        return flag==false?-1:ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2bfb11b9-3013-470e-b811-1323a005737c_1675354890.427724.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans,c;\\n    bool flag;\\n    void dfs(int node,int par,vector<int> &vis,vector<int> &dvis,vector<vector<int>> &adj,vector<int> & count)\\n    {\\n        vis[node]=1;\\n       dvis[node]=1;\\n        if(par==-1)\\n            count[node]=1;\\n        else\\n        count[node]=count[par]+1;\\n    for(auto it:adj[node])\\n    {\\n        if(!vis[it])\\n        {\\n           \\n            \\n            dfs(it,node,vis,dvis,adj,count);\\n           \\n        }\\n        else if(dvis[it]==1)\\n        {\\n           \\n            ans=max(ans,count[node]-count[it]+1);\\n            flag=true;\\n            \\n        }\\n    }\\n    dvis[node]=0;\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(edges[i]!=-1)\\n            adj[i].push_back(edges[i]);\\n        }\\n        flag=false;\\n        ans=0;\\n        vector<int> count(n,0),vis(n,0),dvis(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i])\\n            {\\n                c=0;\\n                count.clear();\\n                dfs(i,-1,vis,dvis,adj,count);\\n            }\\n        }\\n        return flag==false?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070471,
                "title": "c-easy-solution-kahn-s-algo-and-dfs-beats-90",
                "content": "**Code**\\n\\n```\\n\\nclass Solution {\\n    \\npublic:\\n    void dfs(int node, vector<int>& edges, vector<int>& vi, int& ct){\\n        \\n        vi[node] = 1;\\n        ct++;\\n        if(!vi[edges[node]]){\\n            dfs(edges[node],edges,vi,ct); \\n        }\\n        else return;\\n\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> inDegree(n);\\n        for(int i = 0; i < n; i++){\\n            if(edges[i] != -1){\\n                inDegree[edges[i]]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        for(int i = 0; i < n; i++){\\n            if(inDegree[i] == 0) q.push(i);\\n        }\\n        vector<int> vis(n);\\n        while(!q.empty()){\\n            int top = q.front(); q.pop();\\n            vis[top] = 1;\\n            if(edges[top] != -1){\\n                if(--inDegree[edges[top]] == 0) q.push(edges[top]);\\n            }\\n        }\\n        bool flag = false;\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == 0){ flag = true; break;}\\n        }\\n        if(flag == false) return -1;\\n        \\n        vector<int> vi(n, 0);\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(vis[i]) continue;\\n            int ct = 0;\\n            dfs(i, edges, vi, ct);\\n            ans = max(ans,ct);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\npublic:\\n    void dfs(int node, vector<int>& edges, vector<int>& vi, int& ct){\\n        \\n        vi[node] = 1;\\n        ct++;\\n        if(!vi[edges[node]]){\\n            dfs(edges[node],edges,vi,ct); \\n        }\\n        else return;\\n\\n    }\\n    \\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> inDegree(n);\\n        for(int i = 0; i < n; i++){\\n            if(edges[i] != -1){\\n                inDegree[edges[i]]++;\\n            }\\n        }\\n        \\n        queue<int> q;\\n        for(int i = 0; i < n; i++){\\n            if(inDegree[i] == 0) q.push(i);\\n        }\\n        vector<int> vis(n);\\n        while(!q.empty()){\\n            int top = q.front(); q.pop();\\n            vis[top] = 1;\\n            if(edges[top] != -1){\\n                if(--inDegree[edges[top]] == 0) q.push(edges[top]);\\n            }\\n        }\\n        bool flag = false;\\n        for(int i = 0; i < n; i++){\\n            if(vis[i] == 0){ flag = true; break;}\\n        }\\n        if(flag == false) return -1;\\n        \\n        vector<int> vi(n, 0);\\n        int ans = 0;\\n        for(int i = 0; i < n; i++){\\n            if(vis[i]) continue;\\n            int ct = 0;\\n            dfs(i, edges, vi, ct);\\n            ans = max(ans,ct);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974111,
                "title": "c",
                "content": "```\\ntypedef struct _set{\\n    int cycle;\\n    int seq;\\n}set;\\nint longestCycle(int* edges, int edgesSize){\\n    int n = edgesSize;\\n    bool* visited = calloc(n, sizeof(bool));\\n    int ans = -1;\\n    set** hash = calloc(n, sizeof(set*) ) ;\\n    int  run = 1;\\n    for(int i = 0; i < n; i++){        \\n        if(edges[i] == -1 || visited[i])\\n            continue;\\n        int idx = -1;\\n        int p = i;\\n        while(p != -1 ){\\n            idx++;\\n            if(visited[p] == false){\\n                hash[p] = malloc(sizeof(set));\\n                hash[p]->cycle = run;\\n                hash[p]->seq = idx;\\n                visited[p] = true;\\n            }    \\n            else{\\n                if(hash[p]->cycle == run){\\n                    ans = fmax(ans, idx - (hash[p]->seq) );\\n                }\\n                break;\\n            }\\n            p = edges[p];\\n        }\\n        run++;\\n    }\\n    \\n    for(int i = 0; i < n; i++){\\n        if(hash[i] != NULL)\\n            free(hash[i]);\\n    }\\n    free(hash);\\n    free(visited);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct _set{\\n    int cycle;\\n    int seq;\\n}set;\\nint longestCycle(int* edges, int edgesSize){\\n    int n = edgesSize;\\n    bool* visited = calloc(n, sizeof(bool));\\n    int ans = -1;\\n    set** hash = calloc(n, sizeof(set*) ) ;\\n    int  run = 1;\\n    for(int i = 0; i < n; i++){        \\n        if(edges[i] == -1 || visited[i])\\n            continue;\\n        int idx = -1;\\n        int p = i;\\n        while(p != -1 ){\\n            idx++;\\n            if(visited[p] == false){\\n                hash[p] = malloc(sizeof(set));\\n                hash[p]->cycle = run;\\n                hash[p]->seq = idx;\\n                visited[p] = true;\\n            }    \\n            else{\\n                if(hash[p]->cycle == run){\\n                    ans = fmax(ans, idx - (hash[p]->seq) );\\n                }\\n                break;\\n            }\\n            p = edges[p];\\n        }\\n        run++;\\n    }\\n    \\n    for(int i = 0; i < n; i++){\\n        if(hash[i] != NULL)\\n            free(hash[i]);\\n    }\\n    free(hash);\\n    free(visited);\\n    return ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2932158,
                "title": "c-easy-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI\\'ve used DFS approach and modified it a liitle bit. I used the visited array to calulate the distance of the longest cycle. If a node is visited for the second time it means a cycle is there and it\\'s length is dist travelled from the node - distance when we first visited it.\\n\\n# Complexity\\n- Time complexity:\\nO(V+E) since it is the basic dfs question...\\n\\n- Space complexity:\\nO(n) Since we are creating two arrays of length l.\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(vector<int> graph[],int node,vector<int>&vis,int dist, int &res)\\n    {\\n        vis[node]=++dist;\\n        for(auto x: graph[node])\\n        {\\n            if(vis[x]>0){\\n                res = max(res,vis[node]-vis[x]+1);\\n            }\\n            else if(vis[x]==0){\\n                dfs(graph,x,vis,dist, res);\\n            }\\n        }\\n        vis[node]=-1;\\n        return;\\n    }\\n public:\\n    int longestCycle(vector<int>& edges) {\\n        int res= -1;\\n        int n = edges.size();\\n        vector<int>vis(n,0);\\n        vector<int>graph[n];\\n        for(int i=0;i<n;i++){\\n            if(edges[i]!=-1){\\n                graph[i].push_back(edges[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                dfs(graph,i,vis,0, res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(vector<int> graph[],int node,vector<int>&vis,int dist, int &res)\\n    {\\n        vis[node]=++dist;\\n        for(auto x: graph[node])\\n        {\\n            if(vis[x]>0){\\n                res = max(res,vis[node]-vis[x]+1);\\n            }\\n            else if(vis[x]==0){\\n                dfs(graph,x,vis,dist, res);\\n            }\\n        }\\n        vis[node]=-1;\\n        return;\\n    }\\n public:\\n    int longestCycle(vector<int>& edges) {\\n        int res= -1;\\n        int n = edges.size();\\n        vector<int>vis(n,0);\\n        vector<int>graph[n];\\n        for(int i=0;i<n;i++){\\n            if(edges[i]!=-1){\\n                graph[i].push_back(edges[i]);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(vis[i]==0){\\n                dfs(graph,i,vis,0, res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828566,
                "title": "simple-dfs-easy-c",
                "content": "class Solution {\\npublic:\\n\\n    int maxi=-1;\\n    void dfs(int node,vector<int>&vis, vector<int>&edges,int distance,vector<int>&dist){\\n        if(node!=-1){\\n            if(!vis[node]){\\n                vis[node]=2;\\n                dist[node]=distance;\\n                dfs(edges[node],vis,edges,distance+1,dist);\\n            }\\n                else if(vis[node]==2){\\n                    maxi=max(maxi,distance-dist[node]);\\n                }\\n            vis[node]=1;\\n            }\\n        }\\n    int longestCycle(vector<int>& edges) {\\n        int n=edges.size();\\n        vector<int>dist(n);\\n        vector<int>vis(n,0);\\n        for(int i=0;i<n;i++){\\n            if(!vis[i])\\n            dfs(i,vis,edges,0,dist);\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxi=-1;\\n    void dfs(int node,vector<int>&vis, vector<int>&edges,int distance,vector<int>&dist){\\n        if(node!=-1){\\n            if(!vis[node]){\\n                vis[node]=2;\\n                dist[node]=distance;\\n                dfs(edges[node],vis,edges,distance+1,dist);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2741201,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int longestCycle(vector<int>& edges) {\\n    int n = edges.size(), ans = -1;\\n    vector<int> idx(n);\\n    for (int i = 0, k = 1; i < n; i++) {\\n        int j = i, curk = k;\\n        while (j != -1 && !idx[j]) {\\n            idx[j] = k++;\\n            j = edges[j];\\n        }\\n        if (j != -1 && idx[j] >= curk)\\n            ans = max(ans, k - idx[j]);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int longestCycle(vector<int>& edges) {\\n    int n = edges.size(), ans = -1;\\n    vector<int> idx(n);\\n    for (int i = 0, k = 1; i < n; i++) {\\n        int j = i, curk = k;\\n        while (j != -1 && !idx[j]) {\\n            idx[j] = k++;\\n            j = edges[j];\\n        }\\n        if (j != -1 && idx[j] >= curk)\\n            ans = max(ans, k - idx[j]);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2662040,
                "title": "c-simple-dfs-with-explanation-o-n",
                "content": "vis can hold three types of values\\n`vis[i] = -1` ,ith node is traversed and we dont need to use it\\n`vis[i] = 0` , ith node needs to traversed\\n`vis[i] > 0`, ith node is traversed and we can use its value\\n \\n**There is atmost one outgoing edge in the graph, so if we find a node which is visited and is valid that means there is a cycle**. Since there can be multiple components we will traverse through each node to check if it is traversed or not.\\n\\n# Complexity\\n- Time complexity:\\nAdd your time complexity here, e.g. $$O(n)$$, where n = number of nodes\\n\\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(n)$$, where n = number of nodes\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int ans = -1;\\n    /***\\n    * vis can hold three types of values\\n    * vis[i] = -1 ,ith node is traversed and we dont need to use it\\n    * vis[i] = 0 , ith node needs to traversed\\n    * vis[i] > 0, ith node is traversed and we can use its value\\n\\n    * There is atmost one outgoing edge in the graph, so if we find a node which is visited and is valid that means there is a cycle. Since there can be multiple components we will traverse through each node to check if it is traversed or not.\\n    */\\n    void detectCycles(int ind, vector<int>& edges, vector<int>& vis, int cnt = 1){\\n        vis[ind] = cnt;\\n\\n        int nxt = edges[ind];\\n\\n        if(nxt != -1 and vis[nxt] == 0) // Node is not visited, so we travel to it\\n            detectCycles(nxt,edges,vis,cnt+1);\\n        else if(nxt != -1 and vis[nxt] >= 1) { // Node is traversed and is valid so there is a cycle.\\n            ans = max(ans , abs(cnt - vis[nxt])+1);\\n        }\\n\\n        // This node is of no use\\n        vis[ind] = -1;\\n\\n\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        const int N = edges.size();\\n        vector<int> vis(N,0);\\n\\n        for(int i = 0;i<N;i++){\\n            if(vis[i] == 0)\\n                detectCycles(i,edges,vis);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int ans = -1;\\n    /***\\n    * vis can hold three types of values\\n    * vis[i] = -1 ,ith node is traversed and we dont need to use it\\n    * vis[i] = 0 , ith node needs to traversed\\n    * vis[i] > 0, ith node is traversed and we can use its value\\n\\n    * There is atmost one outgoing edge in the graph, so if we find a node which is visited and is valid that means there is a cycle. Since there can be multiple components we will traverse through each node to check if it is traversed or not.\\n    */\\n    void detectCycles(int ind, vector<int>& edges, vector<int>& vis, int cnt = 1){\\n        vis[ind] = cnt;\\n\\n        int nxt = edges[ind];\\n\\n        if(nxt != -1 and vis[nxt] == 0) // Node is not visited, so we travel to it\\n            detectCycles(nxt,edges,vis,cnt+1);\\n        else if(nxt != -1 and vis[nxt] >= 1) { // Node is traversed and is valid so there is a cycle.\\n            ans = max(ans , abs(cnt - vis[nxt])+1);\\n        }\\n\\n        // This node is of no use\\n        vis[ind] = -1;\\n\\n\\n    }\\npublic:\\n    int longestCycle(vector<int>& edges) {\\n        const int N = edges.size();\\n        vector<int> vis(N,0);\\n\\n        for(int i = 0;i<N;i++){\\n            if(vis[i] == 0)\\n                detectCycles(i,edges,vis);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553011,
                "title": "python-simple-dfs-on-graphs",
                "content": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        \\n        def dfs(v, d):\\n            nonlocal res\\n            if v in vis:\\n                if v in done:\\n                    res = max(res, d - done[v])\\n                return\\n            \\n            vis.add(v)\\n            done[v] = d\\n            if edges[v]>=0:\\n                dfs(edges[v], d+1)\\n            return\\n        \\n        res = -1\\n        vis = set()\\n        for i in range(len(edges)):\\n            done = defaultdict(int)\\n            dfs(i, 0)\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        \\n        def dfs(v, d):\\n            nonlocal res\\n            if v in vis:\\n                if v in done:\\n                    res = max(res, d - done[v])\\n                return\\n            \\n            vis.add(v)\\n            done[v] = d\\n            if edges[v]>=0:\\n                dfs(edges[v], d+1)\\n            return\\n        \\n        res = -1\\n        vis = set()\\n        for i in range(len(edges)):\\n            done = defaultdict(int)\\n            dfs(i, 0)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520708,
                "title": "java-dfs",
                "content": "Iterate edges while dfs on the edges. The edgeVisited uses the starting index of dfs to tag as visited within one wave of DFS. It is a cycle if the same tag is encountered within one wave of DFS. The max depth minus the depth of re-encourtered index is the cycle length.\\n\\nEach index is visited once in this solution.\\n\\n```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int maxLength = -1;\\n        int cycleLength = -1;\\n        if (edges == null || edges.length == 1) {\\n            return -1;\\n        }\\n        int[] edgeVisited = new int[edges.length];\\n        int[] depth = new int[edges.length];\\n        for (int i = 0; i < edges.length; i++) {\\n            edgeVisited[i] = -1;\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            if (edges[i] != -1 && edgeVisited[i] == -1) {  \\n                // System.out.println(i + \" \" + i);\\n                cycleLength = dfs(i, i, 0, edges, depth, edgeVisited);\\n                maxLength = maxLength > cycleLength ? maxLength: cycleLength;\\n            }\\n        }\\n        return maxLength;\\n    }\\n    \\n    private int dfs(int index, int id, int dep, int[] edges, int[] depth, int[] edgeVisited) {\\n        if (edgeVisited[index] == id) {\\n            return dep - depth[index];\\n        }\\n        if (edges[index] == -1 || edgeVisited[index] != -1) {\\n            return -1;\\n        }\\n        \\n        edgeVisited[index] = id;\\n        depth[index] = dep;\\n        return dfs(edges[index], id, dep+1,  edges, depth, edgeVisited);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestCycle(int[] edges) {\\n        int maxLength = -1;\\n        int cycleLength = -1;\\n        if (edges == null || edges.length == 1) {\\n            return -1;\\n        }\\n        int[] edgeVisited = new int[edges.length];\\n        int[] depth = new int[edges.length];\\n        for (int i = 0; i < edges.length; i++) {\\n            edgeVisited[i] = -1;\\n        }\\n        for (int i = 0; i < edges.length; i++) {\\n            if (edges[i] != -1 && edgeVisited[i] == -1) {  \\n                // System.out.println(i + \" \" + i);\\n                cycleLength = dfs(i, i, 0, edges, depth, edgeVisited);\\n                maxLength = maxLength > cycleLength ? maxLength: cycleLength;\\n            }\\n        }\\n        return maxLength;\\n    }\\n    \\n    private int dfs(int index, int id, int dep, int[] edges, int[] depth, int[] edgeVisited) {\\n        if (edgeVisited[index] == id) {\\n            return dep - depth[index];\\n        }\\n        if (edges[index] == -1 || edgeVisited[index] != -1) {\\n            return -1;\\n        }\\n        \\n        edgeVisited[index] = id;\\n        depth[index] = dep;\\n        return dfs(edges[index], id, dep+1,  edges, depth, edgeVisited);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466629,
                "title": "longest-cycle-in-a-graph-c-easy-bfs-sol",
                "content": "Brute Force solution:\\n\\n1) first create a vis array to keep track of the vis array \\n2) Run BFS or DFS for every unvisited array and find the length of the cycle \\n3) Update the cycle length\\n \\n Find_length()\\n Traverse through adjacent of source node nd find if it is visited then cycle existes, then find     cycle length and  update source as edge[source].\\n If cycle not found return -1\\n \\n \\n The above sol has O(n*(n+e)) time complexity where n is no of nodes and e is no of edges\\n \\n Better Sol:\\n 1) one observation we can make is that any node in the cycle must has indegree atleast 1\\n 2) All the nodes whose indegree is 0 is potentially unfit to be present in cycle\\n 3) Run BFS by pushing all nodes whose indegree as 1 and mark them visited \\n 4) decrese the indegree of the adjacent by -1 each step\\n 5) Finally all the unvisited nodes must be in the cycle \\n 6) Traverse through them and find the cycle length\\n \\n c++ code:\\n   int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int>indeg(n);\\n        vector<int>vis(n);\\n       // count indegree of each node        \\n        for(int i=0; i<n; i++){\\n            if(edges[i] != -1) indeg[edges[i]]++;\\n        }\\n        // Kahn\\'s algorithm\\n        queue<int>q;\\n        for(int i=0; i<n; i++){\\n            if(indeg[i] == 0) q.push(i);\\n        }\\n        while(!q.empty()){\\n            int top = q.front();\\n            vis[top] = 1;\\n            q.pop();\\n            if(edges[top] != -1){\\n                indeg[edges[top]]--;\\n                if(indeg[edges[top]] == 0) q.push(edges[top]);\\n            }\\n        }\\n        int ans = -1;\\n        for(int i=0; i<n; i++){\\n            // If all our visited, that means we dont have a cycle\\n            if(!vis[i]){\\n                int start = i;\\n                int curr = edges[i];\\n                vis[i] = 1;\\n                int c = 0;\\n                // find cycle length\\n                while(curr != start){\\n                    if(indeg[curr] == 0) break;\\n                    curr = edges[curr];\\n                    vis[curr] = 1;\\n                    c++;\\n                }\\n                ans = max(ans,c+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "Brute Force solution:\\n\\n1) first create a vis array to keep track of the vis array \\n2) Run BFS or DFS for every unvisited array and find the length of the cycle \\n3) Update the cycle length\\n \\n Find_length()\\n Traverse through adjacent of source node nd find if it is visited then cycle existes, then find     cycle length and  update source as edge[source].\\n If cycle not found return -1\\n \\n \\n The above sol has O(n*(n+e)) time complexity where n is no of nodes and e is no of edges\\n \\n Better Sol:\\n 1) one observation we can make is that any node in the cycle must has indegree atleast 1\\n 2) All the nodes whose indegree is 0 is potentially unfit to be present in cycle\\n 3) Run BFS by pushing all nodes whose indegree as 1 and mark them visited \\n 4) decrese the indegree of the adjacent by -1 each step\\n 5) Finally all the unvisited nodes must be in the cycle \\n 6) Traverse through them and find the cycle length\\n \\n c++ code:\\n   int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int>indeg(n);\\n        vector<int>vis(n);\\n       // count indegree of each node        \\n        for(int i=0; i<n; i++){\\n            if(edges[i] != -1) indeg[edges[i]]++;\\n        }\\n        // Kahn\\'s algorithm\\n        queue<int>q;\\n        for(int i=0; i<n; i++){\\n            if(indeg[i] == 0) q.push(i);\\n        }\\n        while(!q.empty()){\\n            int top = q.front();\\n            vis[top] = 1;\\n            q.pop();\\n            if(edges[top] != -1){\\n                indeg[edges[top]]--;\\n                if(indeg[edges[top]] == 0) q.push(edges[top]);\\n            }\\n        }\\n        int ans = -1;\\n        for(int i=0; i<n; i++){\\n            // If all our visited, that means we dont have a cycle\\n            if(!vis[i]){\\n                int start = i;\\n                int curr = edges[i];\\n                vis[i] = 1;\\n                int c = 0;\\n                // find cycle length\\n                while(curr != start){\\n                    if(indeg[curr] == 0) break;\\n                    curr = edges[curr];\\n                    vis[curr] = 1;\\n                    c++;\\n                }\\n                ans = max(ans,c+1);   \\n            }\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2422071,
                "title": "longest-cycle-in-a-graph-c-explained-solution",
                "content": "The question here is quite good and needs some observations. Firstly the given graph is going to be **directed**, secondly **a single node can have atmost 1 outdegree ( edge arising from this node and pointing to some other node )**. The second observation gives us an idea : **Given a Node \\'u\\', if it is a part of some cycle then this cycle can be covered in a single go. Moreover a single node \\'u\\' can be a part of atmost 1 cycle and that\\'s why we can cover the whole cycle in one go**. Since a node cannot be part of more than one cycle, then we just need to see if current node forms a cycle or not. If **yes** then maintain max length cycle value in a variable else for all nodes that were a part of this path ( **as cycle could not be formed** ) should also be updated to default negative value to indicate that this path could not form a cycle. This is done in accordance to the fact that a node cannot have more than **1 outgoing node**. For this purpose we can use combination of simple storage (**DP**). The implementation goes below : \\n\\nTime Complexity : O(N), every node is visited atmost once\\nSpace Complexiy : O(N)\\n\\nCode :\\n```\\nclass Solution {\\npublic:\\n    int findnode(vector<int>&edges,vector<int>&dp,vector<bool>&visited,int cnt,int x){\\n        if(x==-1){\\n            return x;\\n        }\\n        else if(visited[x]){\\n            if(cnt<cnt-dp[x]){              // This node was a part of non cyclic path ( cnt < cnt - dp[x] means that dp[x] is negative )\\n                return -1;\\n            }\\n            else{\\n                return cnt-dp[x];\\n            }\\n        }\\n        else{\\n            visited[x] = true;\\n            dp[x] = cnt;\\n            return dp[x] = findnode(edges,dp,visited,cnt+1,edges[x]);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        ios_base::sync_with_stdio(0);\\n        int n = edges.size(),ans = -1;\\n        vector<int>dp(n,0);\\n        vector<bool>visited(n,false);\\n        for(int i = 0; i<n; i++){\\n            if(!visited[i]){\\n                ans = max(ans,findnode(edges,dp,visited,0,i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/caf76f4f-751b-44a2-8231-64bffd0a8dda_1660449201.707217.png)\\n\\n**Do Upvote If Found Helpful !**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findnode(vector<int>&edges,vector<int>&dp,vector<bool>&visited,int cnt,int x){\\n        if(x==-1){\\n            return x;\\n        }\\n        else if(visited[x]){\\n            if(cnt<cnt-dp[x]){              // This node was a part of non cyclic path ( cnt < cnt - dp[x] means that dp[x] is negative )\\n                return -1;\\n            }\\n            else{\\n                return cnt-dp[x];\\n            }\\n        }\\n        else{\\n            visited[x] = true;\\n            dp[x] = cnt;\\n            return dp[x] = findnode(edges,dp,visited,cnt+1,edges[x]);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        ios_base::sync_with_stdio(0);\\n        int n = edges.size(),ans = -1;\\n        vector<int>dp(n,0);\\n        vector<bool>visited(n,false);\\n        for(int i = 0; i<n; i++){\\n            if(!visited[i]){\\n                ans = max(ans,findnode(edges,dp,visited,0,i));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415390,
                "title": "python-solution-using-dfs",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.maximum = -1\\n        self.dist = 0\\n    \\n    def longestCycle(self, edges: List[int]) -> int:\\n        def dfs(edges: List[int], visited: List[int], distance: List[int], source: int) -> None:\\n            if source == -1:\\n                return\\n            if visited[source] == 0:\\n                visited[source] = 1\\n                distance[source] = self.dist\\n                self.dist += 1\\n                dfs(edges, visited, distance, edges[source])\\n                visited[source] = 2\\n            elif visited[source] == 1:\\n                self.maximum = max(self.maximum, self.dist - distance[source])\\n        \\n        visited, distance = [0 for _ in range(len(edges))], [0 for _ in range(len(edges))]\\n        for i in range(len(edges)):\\n            dfs(edges, visited, distance, i)\\n        return self.maximum\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.maximum = -1\\n        self.dist = 0\\n    \\n    def longestCycle(self, edges: List[int]) -> int:\\n        def dfs(edges: List[int], visited: List[int], distance: List[int], source: int) -> None:\\n            if source == -1:\\n                return\\n            if visited[source] == 0:\\n                visited[source] = 1\\n                distance[source] = self.dist\\n                self.dist += 1\\n                dfs(edges, visited, distance, edges[source])\\n                visited[source] = 2\\n            elif visited[source] == 1:\\n                self.maximum = max(self.maximum, self.dist - distance[source])\\n        \\n        visited, distance = [0 for _ in range(len(edges))], [0 for _ in range(len(edges))]\\n        for i in range(len(edges)):\\n            dfs(edges, visited, distance, i)\\n        return self.maximum\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1785180,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843606,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1807399,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1844011,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843772,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843631,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843628,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843866,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843776,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843651,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1785180,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843606,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1807399,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1844011,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843772,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843631,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843628,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843866,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843776,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1843651,
                "content": [
                    {
                        "username": "sairamyadhav3",
                        "content": "In my opinion this should have been Medium leveled"
                    },
                    {
                        "username": "Entrropic",
                        "content": "Yeah, was surprised by how easy this one was after I put some thought into it. It's definitely not completely trivial, but there are many problems classified as Hard which are WAY harder than this one. And there are even some Medium problems which IMO are harder. This is still in the Medium territory though despite that."
                    },
                    {
                        "username": "wareag1e",
                        "content": "Agree"
                    },
                    {
                        "username": "gbiems",
                        "content": "Although I\\'m not a great leetcoder and have only solved a few \"hard\" problems, I found this one more difficult than the medium problems I\\'ve solved, mainly because of the TLE issues that arise from using a list to store the paths rather than a hashmap.\\n\\nI\\'d agree that once you understand how to do this, it isn\\'t really any harder than a typical medium graph problem.  But I did have to/get to learn something new to solve this without a TLE. \\n\\nSo this one did push the limits of my leetcoding ability a bit beyond what I\\'d normally get out of a medium. "
                    },
                    {
                        "username": "ng812057",
                        "content": "yeah.. it\\'s very easy\\n"
                    },
                    {
                        "username": "rahul1995",
                        "content": "Easy actually."
                    },
                    {
                        "username": "djslim",
                        "content": "i was only 327 solves in contest (weekly 304)"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "A testcase with multiple cycles for your convenience:\\n\\n[1,19,30,87,53,91,36,6,95,14,73,2,59,76,49,41,29,28,8,9,96,80,68,10,31,24,0,42,39,4,51,64,25,90,35,71,97,32,16,18,62,22,40,78,55,13,99,93,66,26,98,5,88,74,89,81,43,12,44,57,75,47,34,72,85,77,3,65,46,20,60,33,48,94,84,21,69,54,56,11,70,83,86,79,61,37,67,15,7,38,23,52,58,27,50,63,92,45,17,82]"
                    },
                    {
                        "username": "allrounderankit",
                        "content": "[@psionl0](/psionl0) yes"
                    },
                    {
                        "username": "heg816",
                        "content": "[@psionl0](/psionl0) Correct."
                    },
                    {
                        "username": "psionl0",
                        "content": "Was the answer 50?"
                    },
                    {
                        "username": "shivamchaurasia2912",
                        "content": "The question will be hard if vertices can have more than one edges "
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes it wont work shortest cycle in a graph question is an example for why it wont work"
                    },
                    {
                        "username": "Swetha6545",
                        "content": "[@kunal_404](/kunal_404) longest cycle in general directed/undirected graph is np complete"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "[@shivasaineelam](/shivasaineelam)  NO"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "[@kunal_404](/kunal_404) it will work right?"
                    },
                    {
                        "username": "kunal_404",
                        "content": "Can you tell me why this approach will not work if we have more than one vertices ?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Using arrays to save the distances will cause LTE. Because if n is large, initiating arrays takes time, it will make all the elements to zero. So this time hashmaps(dict) are more efficient than arrays. "
                    },
                    {
                        "username": "Klemo1997",
                        "content": "[@resurgence24](/resurgence24) I think, that using an array is more efficient if the graph is a tree, so we would accumulate whole graph in a hashmap anyway, but otherwise it\\'s more efficient to use hashmap, because it will only allocate space used for the largest path it will encounter. It is ok to use array for visited, because it\\'ll eat up O(v) space anyway."
                    },
                    {
                        "username": "ikorpse",
                        "content": "try thinking of reusing the array without re-initialisation"
                    },
                    {
                        "username": "resurgence24",
                        "content": "When would using arrays be more efficient than hashmaps? or is it never the case?"
                    },
                    {
                        "username": "DarkDuel012",
                        "content": "Todays contest must be made unrated :("
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Thanks to leetcode for having such graph week , it will really helpful  for me to regain my confidence."
                    },
                    {
                        "username": "arajshow",
                        "content": "Getting memory limit exceeded in DFS cycle detection method on test case 63. \\uD83D\\uDE22"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "I also got that.\\nIn case you guys haven\\' figured out, its probably because you\\'re traversing a vertex that has already been seen in a cycle. \\nSo make sure while you carry out DFS, you avoid the nodes that have been seen in a cycle. A  node can only contribute to a single cycle as there\\'s atmost one outwards edge for every node."
                    },
                    {
                        "username": "gulllak",
                        "content": "I am too"
                    },
                    {
                        "username": "RamilZaripov",
                        "content": "Got TLE on the same test"
                    },
                    {
                        "username": "oldabc",
                        "content": "same"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Test cases that may help you -\\n[-1,4,-1,2,0,4] \\n[1,0]"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\\n\\n1. Initialize a variable longest to -1 to keep track of the longest cycle.\\n2. Loop through each index start of the edges array.\\n3. Initialize two variables slow and fast to the index start.\\n4. While the fast index is not pointing to a -1 element and the element at the index that fast is pointing to is also not -1:\\n    - Move the slow index one step ahead.\\n    - Move the fast index two steps ahead.\\n    - If slow becomes equal to fast, then there is a cycle. Calculate the length of the cycle by moving the slow pointer until it meets fast again, counting the number of steps. Let this be the cycleLen.\\n    - Update the longest variable with the maximum of its current value and the cycleLen.\\n5. Return the longest variable as the answer."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@_stalkmenow](/_stalkmenow) do memoization also"
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "I am getting TLE with this approach coz of O(n^2) Worst case TC"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) We have to make the starting index -1 after a traveral or what ?"
                    },
                    {
                        "username": "sBahmaniJi",
                        "content": "Floyd\\'s cycle detection algorithm for anyone who is wondering"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-)\\nhttps://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342107/easy-to-understand-solution/"
                    },
                    {
                        "username": "vnk01",
                        "content": "I implemented in java similar to to Editorial\\'s solution but run into Time Limit Exceed many times. It turned out I need to change from  `myMap.clear()` to  `myMap = new HashMap<>()`. It\\'s so annoying when your solution already satisfy time/space complexity but still got kicked because things like this  \\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    }
                ]
            },
            {
                "id": 1844403,
                "content": [
                    {
                        "username": "Ayush_Singh_610",
                        "content": "This code is failing for the test case\nInput\nedges =\n[-1,4,-1,2,0,4]\nOutput\n 2 \nExpected\n-1\n\ncan anyone please explain once what's wrong in this code. Literary spent 7 hrs still can't understand\n\n```\nclass Solution:\n    cycle = False\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [False]*len(edges)\n        visiting = [False]*len(edges)\n        intmax = -1\n        for i in range(0,len(visited)):\n            if not visited[i] and edges[i] != -1:\n                intmax = max(intmax, self.dfs(visited,visiting,edges,i,0)[1])\n        if not cycle:\n            return -1\n        return intmax\n\n    def dfs(self,visited,visiting,edges,node,count) -> bool:\n        if node == -1:\n            return [-1,-1,-1]\n        if visited[node]:\n            cycle = True\n            return [node,1,0]  #[node at which the cycle is detected,distance,signal to track during recursion return]\n        \n        visited[node] = True\n        context = self.dfs(visited,visiting,edges,edges[node],count)\n        visiting[node] = False\n        visited[node] = True\n\n        if context[0] == node:\n            context[2] = 1  #cycle complete\n            return context\n        if context[2] == 0:\n            context[1] += 1\n        return context\n```"
                    },
                    {
                        "username": "akrchaubey",
                        "content": "are you still stuck [@Ayush Singh](/Ayush_Singh_610)?"
                    },
                    {
                        "username": "crobat8",
                        "content": "is anyone else getting to testcase 76 then getting a TLE I can post my code if that helps. I feel like I figured out a solution but might need help with a few minor optimization to make it finish."
                    },
                    {
                        "username": "snill901123",
                        "content": "I have same problem."
                    },
                    {
                        "username": "daring-calf",
                        "content": "If you\\'re using an array to save the steps(distances), try use a map(dict)"
                    },
                    {
                        "username": "ramney",
                        "content": "\\nPlease help me to findout error in below code, its showing runtime error of address santizer,\\n\\n\\' class Solution {\\npublic:\\n    int maxPath = 0;\\n    void dfs(vector<int> & edges,int node, vector<bool> &visited,int currentPath)\\n    {\\n        visited[node] = true;\\n        int next = edges[node];\\n        if(visited[next] == true)\\n        {\\n            if(currentPath > maxPath) maxPath = currentPath;\\n            return;\\n        }\\n        if(visited[next] == false && next != -1)\\n        {\\n            currentPath++;\\n            dfs(edges,next,visited,currentPath);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            vector<bool> visited(n, false);\\n            int currentPath = 0;\\n            dfs(edges,i,visited,currentPath);\\n        }\\n        return maxPath;\\n    }\\n}; \\'"
                    },
                    {
                        "username": "manikantaloya",
                        "content": "I assume you code has vector<int> & instead of vector<int> in the function definition. Another error is in the line if(visited[next] == true)\\nHere next can also be -1 if the node doesn\\'t have outgoing edges which is leading to visited[-1] -- incorrect address. You may need to have a check if next != -1"
                    },
                    {
                        "username": "Aryan_Kumar9939",
                        "content": "Same question has been asked in my Goldman Sach OA"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Time Limit Exceeded\\n81 / 81 testcases passed.....\\nTestcases passed, but took too long.........\\n\\nHere we go again!!!!"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Why it is marked as Hard!!! Just finding cycle in a directed graph and also easy way mentioning only one outgoing edge in a node."
                    },
                    {
                        "username": "layyy",
                        "content": "try topological sort"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "This question is hard when it containd more edges from a vertex node..."
                    },
                    {
                        "username": "lalit10368",
                        "content": "This is much easier than the shortest cycle in a graph. Should have done this one first. "
                    },
                    {
                        "username": "feng3245",
                        "content": "Guys a quick tip that if you are using next(iter()) and things are timing out it\\'s probably due to iter() going through your collection every time... learned that the hard way on this question. Probably will save you a lot of TLEs"
                    }
                ]
            },
            {
                "id": 1843931,
                "content": [
                    {
                        "username": "Ayush_Singh_610",
                        "content": "This code is failing for the test case\nInput\nedges =\n[-1,4,-1,2,0,4]\nOutput\n 2 \nExpected\n-1\n\ncan anyone please explain once what's wrong in this code. Literary spent 7 hrs still can't understand\n\n```\nclass Solution:\n    cycle = False\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [False]*len(edges)\n        visiting = [False]*len(edges)\n        intmax = -1\n        for i in range(0,len(visited)):\n            if not visited[i] and edges[i] != -1:\n                intmax = max(intmax, self.dfs(visited,visiting,edges,i,0)[1])\n        if not cycle:\n            return -1\n        return intmax\n\n    def dfs(self,visited,visiting,edges,node,count) -> bool:\n        if node == -1:\n            return [-1,-1,-1]\n        if visited[node]:\n            cycle = True\n            return [node,1,0]  #[node at which the cycle is detected,distance,signal to track during recursion return]\n        \n        visited[node] = True\n        context = self.dfs(visited,visiting,edges,edges[node],count)\n        visiting[node] = False\n        visited[node] = True\n\n        if context[0] == node:\n            context[2] = 1  #cycle complete\n            return context\n        if context[2] == 0:\n            context[1] += 1\n        return context\n```"
                    },
                    {
                        "username": "akrchaubey",
                        "content": "are you still stuck [@Ayush Singh](/Ayush_Singh_610)?"
                    },
                    {
                        "username": "crobat8",
                        "content": "is anyone else getting to testcase 76 then getting a TLE I can post my code if that helps. I feel like I figured out a solution but might need help with a few minor optimization to make it finish."
                    },
                    {
                        "username": "snill901123",
                        "content": "I have same problem."
                    },
                    {
                        "username": "daring-calf",
                        "content": "If you\\'re using an array to save the steps(distances), try use a map(dict)"
                    },
                    {
                        "username": "ramney",
                        "content": "\\nPlease help me to findout error in below code, its showing runtime error of address santizer,\\n\\n\\' class Solution {\\npublic:\\n    int maxPath = 0;\\n    void dfs(vector<int> & edges,int node, vector<bool> &visited,int currentPath)\\n    {\\n        visited[node] = true;\\n        int next = edges[node];\\n        if(visited[next] == true)\\n        {\\n            if(currentPath > maxPath) maxPath = currentPath;\\n            return;\\n        }\\n        if(visited[next] == false && next != -1)\\n        {\\n            currentPath++;\\n            dfs(edges,next,visited,currentPath);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            vector<bool> visited(n, false);\\n            int currentPath = 0;\\n            dfs(edges,i,visited,currentPath);\\n        }\\n        return maxPath;\\n    }\\n}; \\'"
                    },
                    {
                        "username": "manikantaloya",
                        "content": "I assume you code has vector<int> & instead of vector<int> in the function definition. Another error is in the line if(visited[next] == true)\\nHere next can also be -1 if the node doesn\\'t have outgoing edges which is leading to visited[-1] -- incorrect address. You may need to have a check if next != -1"
                    },
                    {
                        "username": "Aryan_Kumar9939",
                        "content": "Same question has been asked in my Goldman Sach OA"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Time Limit Exceeded\\n81 / 81 testcases passed.....\\nTestcases passed, but took too long.........\\n\\nHere we go again!!!!"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Why it is marked as Hard!!! Just finding cycle in a directed graph and also easy way mentioning only one outgoing edge in a node."
                    },
                    {
                        "username": "layyy",
                        "content": "try topological sort"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "This question is hard when it containd more edges from a vertex node..."
                    },
                    {
                        "username": "lalit10368",
                        "content": "This is much easier than the shortest cycle in a graph. Should have done this one first. "
                    },
                    {
                        "username": "feng3245",
                        "content": "Guys a quick tip that if you are using next(iter()) and things are timing out it\\'s probably due to iter() going through your collection every time... learned that the hard way on this question. Probably will save you a lot of TLEs"
                    }
                ]
            },
            {
                "id": 1774168,
                "content": [
                    {
                        "username": "Ayush_Singh_610",
                        "content": "This code is failing for the test case\nInput\nedges =\n[-1,4,-1,2,0,4]\nOutput\n 2 \nExpected\n-1\n\ncan anyone please explain once what's wrong in this code. Literary spent 7 hrs still can't understand\n\n```\nclass Solution:\n    cycle = False\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [False]*len(edges)\n        visiting = [False]*len(edges)\n        intmax = -1\n        for i in range(0,len(visited)):\n            if not visited[i] and edges[i] != -1:\n                intmax = max(intmax, self.dfs(visited,visiting,edges,i,0)[1])\n        if not cycle:\n            return -1\n        return intmax\n\n    def dfs(self,visited,visiting,edges,node,count) -> bool:\n        if node == -1:\n            return [-1,-1,-1]\n        if visited[node]:\n            cycle = True\n            return [node,1,0]  #[node at which the cycle is detected,distance,signal to track during recursion return]\n        \n        visited[node] = True\n        context = self.dfs(visited,visiting,edges,edges[node],count)\n        visiting[node] = False\n        visited[node] = True\n\n        if context[0] == node:\n            context[2] = 1  #cycle complete\n            return context\n        if context[2] == 0:\n            context[1] += 1\n        return context\n```"
                    },
                    {
                        "username": "akrchaubey",
                        "content": "are you still stuck [@Ayush Singh](/Ayush_Singh_610)?"
                    },
                    {
                        "username": "crobat8",
                        "content": "is anyone else getting to testcase 76 then getting a TLE I can post my code if that helps. I feel like I figured out a solution but might need help with a few minor optimization to make it finish."
                    },
                    {
                        "username": "snill901123",
                        "content": "I have same problem."
                    },
                    {
                        "username": "daring-calf",
                        "content": "If you\\'re using an array to save the steps(distances), try use a map(dict)"
                    },
                    {
                        "username": "ramney",
                        "content": "\\nPlease help me to findout error in below code, its showing runtime error of address santizer,\\n\\n\\' class Solution {\\npublic:\\n    int maxPath = 0;\\n    void dfs(vector<int> & edges,int node, vector<bool> &visited,int currentPath)\\n    {\\n        visited[node] = true;\\n        int next = edges[node];\\n        if(visited[next] == true)\\n        {\\n            if(currentPath > maxPath) maxPath = currentPath;\\n            return;\\n        }\\n        if(visited[next] == false && next != -1)\\n        {\\n            currentPath++;\\n            dfs(edges,next,visited,currentPath);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            vector<bool> visited(n, false);\\n            int currentPath = 0;\\n            dfs(edges,i,visited,currentPath);\\n        }\\n        return maxPath;\\n    }\\n}; \\'"
                    },
                    {
                        "username": "manikantaloya",
                        "content": "I assume you code has vector<int> & instead of vector<int> in the function definition. Another error is in the line if(visited[next] == true)\\nHere next can also be -1 if the node doesn\\'t have outgoing edges which is leading to visited[-1] -- incorrect address. You may need to have a check if next != -1"
                    },
                    {
                        "username": "Aryan_Kumar9939",
                        "content": "Same question has been asked in my Goldman Sach OA"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Time Limit Exceeded\\n81 / 81 testcases passed.....\\nTestcases passed, but took too long.........\\n\\nHere we go again!!!!"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Why it is marked as Hard!!! Just finding cycle in a directed graph and also easy way mentioning only one outgoing edge in a node."
                    },
                    {
                        "username": "layyy",
                        "content": "try topological sort"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "This question is hard when it containd more edges from a vertex node..."
                    },
                    {
                        "username": "lalit10368",
                        "content": "This is much easier than the shortest cycle in a graph. Should have done this one first. "
                    },
                    {
                        "username": "feng3245",
                        "content": "Guys a quick tip that if you are using next(iter()) and things are timing out it\\'s probably due to iter() going through your collection every time... learned that the hard way on this question. Probably will save you a lot of TLEs"
                    }
                ]
            },
            {
                "id": 2055150,
                "content": [
                    {
                        "username": "Ayush_Singh_610",
                        "content": "This code is failing for the test case\nInput\nedges =\n[-1,4,-1,2,0,4]\nOutput\n 2 \nExpected\n-1\n\ncan anyone please explain once what's wrong in this code. Literary spent 7 hrs still can't understand\n\n```\nclass Solution:\n    cycle = False\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [False]*len(edges)\n        visiting = [False]*len(edges)\n        intmax = -1\n        for i in range(0,len(visited)):\n            if not visited[i] and edges[i] != -1:\n                intmax = max(intmax, self.dfs(visited,visiting,edges,i,0)[1])\n        if not cycle:\n            return -1\n        return intmax\n\n    def dfs(self,visited,visiting,edges,node,count) -> bool:\n        if node == -1:\n            return [-1,-1,-1]\n        if visited[node]:\n            cycle = True\n            return [node,1,0]  #[node at which the cycle is detected,distance,signal to track during recursion return]\n        \n        visited[node] = True\n        context = self.dfs(visited,visiting,edges,edges[node],count)\n        visiting[node] = False\n        visited[node] = True\n\n        if context[0] == node:\n            context[2] = 1  #cycle complete\n            return context\n        if context[2] == 0:\n            context[1] += 1\n        return context\n```"
                    },
                    {
                        "username": "akrchaubey",
                        "content": "are you still stuck [@Ayush Singh](/Ayush_Singh_610)?"
                    },
                    {
                        "username": "crobat8",
                        "content": "is anyone else getting to testcase 76 then getting a TLE I can post my code if that helps. I feel like I figured out a solution but might need help with a few minor optimization to make it finish."
                    },
                    {
                        "username": "snill901123",
                        "content": "I have same problem."
                    },
                    {
                        "username": "daring-calf",
                        "content": "If you\\'re using an array to save the steps(distances), try use a map(dict)"
                    },
                    {
                        "username": "ramney",
                        "content": "\\nPlease help me to findout error in below code, its showing runtime error of address santizer,\\n\\n\\' class Solution {\\npublic:\\n    int maxPath = 0;\\n    void dfs(vector<int> & edges,int node, vector<bool> &visited,int currentPath)\\n    {\\n        visited[node] = true;\\n        int next = edges[node];\\n        if(visited[next] == true)\\n        {\\n            if(currentPath > maxPath) maxPath = currentPath;\\n            return;\\n        }\\n        if(visited[next] == false && next != -1)\\n        {\\n            currentPath++;\\n            dfs(edges,next,visited,currentPath);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            vector<bool> visited(n, false);\\n            int currentPath = 0;\\n            dfs(edges,i,visited,currentPath);\\n        }\\n        return maxPath;\\n    }\\n}; \\'"
                    },
                    {
                        "username": "manikantaloya",
                        "content": "I assume you code has vector<int> & instead of vector<int> in the function definition. Another error is in the line if(visited[next] == true)\\nHere next can also be -1 if the node doesn\\'t have outgoing edges which is leading to visited[-1] -- incorrect address. You may need to have a check if next != -1"
                    },
                    {
                        "username": "Aryan_Kumar9939",
                        "content": "Same question has been asked in my Goldman Sach OA"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Time Limit Exceeded\\n81 / 81 testcases passed.....\\nTestcases passed, but took too long.........\\n\\nHere we go again!!!!"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Why it is marked as Hard!!! Just finding cycle in a directed graph and also easy way mentioning only one outgoing edge in a node."
                    },
                    {
                        "username": "layyy",
                        "content": "try topological sort"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "This question is hard when it containd more edges from a vertex node..."
                    },
                    {
                        "username": "lalit10368",
                        "content": "This is much easier than the shortest cycle in a graph. Should have done this one first. "
                    },
                    {
                        "username": "feng3245",
                        "content": "Guys a quick tip that if you are using next(iter()) and things are timing out it\\'s probably due to iter() going through your collection every time... learned that the hard way on this question. Probably will save you a lot of TLEs"
                    }
                ]
            },
            {
                "id": 2052916,
                "content": [
                    {
                        "username": "Ayush_Singh_610",
                        "content": "This code is failing for the test case\nInput\nedges =\n[-1,4,-1,2,0,4]\nOutput\n 2 \nExpected\n-1\n\ncan anyone please explain once what's wrong in this code. Literary spent 7 hrs still can't understand\n\n```\nclass Solution:\n    cycle = False\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [False]*len(edges)\n        visiting = [False]*len(edges)\n        intmax = -1\n        for i in range(0,len(visited)):\n            if not visited[i] and edges[i] != -1:\n                intmax = max(intmax, self.dfs(visited,visiting,edges,i,0)[1])\n        if not cycle:\n            return -1\n        return intmax\n\n    def dfs(self,visited,visiting,edges,node,count) -> bool:\n        if node == -1:\n            return [-1,-1,-1]\n        if visited[node]:\n            cycle = True\n            return [node,1,0]  #[node at which the cycle is detected,distance,signal to track during recursion return]\n        \n        visited[node] = True\n        context = self.dfs(visited,visiting,edges,edges[node],count)\n        visiting[node] = False\n        visited[node] = True\n\n        if context[0] == node:\n            context[2] = 1  #cycle complete\n            return context\n        if context[2] == 0:\n            context[1] += 1\n        return context\n```"
                    },
                    {
                        "username": "akrchaubey",
                        "content": "are you still stuck [@Ayush Singh](/Ayush_Singh_610)?"
                    },
                    {
                        "username": "crobat8",
                        "content": "is anyone else getting to testcase 76 then getting a TLE I can post my code if that helps. I feel like I figured out a solution but might need help with a few minor optimization to make it finish."
                    },
                    {
                        "username": "snill901123",
                        "content": "I have same problem."
                    },
                    {
                        "username": "daring-calf",
                        "content": "If you\\'re using an array to save the steps(distances), try use a map(dict)"
                    },
                    {
                        "username": "ramney",
                        "content": "\\nPlease help me to findout error in below code, its showing runtime error of address santizer,\\n\\n\\' class Solution {\\npublic:\\n    int maxPath = 0;\\n    void dfs(vector<int> & edges,int node, vector<bool> &visited,int currentPath)\\n    {\\n        visited[node] = true;\\n        int next = edges[node];\\n        if(visited[next] == true)\\n        {\\n            if(currentPath > maxPath) maxPath = currentPath;\\n            return;\\n        }\\n        if(visited[next] == false && next != -1)\\n        {\\n            currentPath++;\\n            dfs(edges,next,visited,currentPath);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            vector<bool> visited(n, false);\\n            int currentPath = 0;\\n            dfs(edges,i,visited,currentPath);\\n        }\\n        return maxPath;\\n    }\\n}; \\'"
                    },
                    {
                        "username": "manikantaloya",
                        "content": "I assume you code has vector<int> & instead of vector<int> in the function definition. Another error is in the line if(visited[next] == true)\\nHere next can also be -1 if the node doesn\\'t have outgoing edges which is leading to visited[-1] -- incorrect address. You may need to have a check if next != -1"
                    },
                    {
                        "username": "Aryan_Kumar9939",
                        "content": "Same question has been asked in my Goldman Sach OA"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Time Limit Exceeded\\n81 / 81 testcases passed.....\\nTestcases passed, but took too long.........\\n\\nHere we go again!!!!"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Why it is marked as Hard!!! Just finding cycle in a directed graph and also easy way mentioning only one outgoing edge in a node."
                    },
                    {
                        "username": "layyy",
                        "content": "try topological sort"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "This question is hard when it containd more edges from a vertex node..."
                    },
                    {
                        "username": "lalit10368",
                        "content": "This is much easier than the shortest cycle in a graph. Should have done this one first. "
                    },
                    {
                        "username": "feng3245",
                        "content": "Guys a quick tip that if you are using next(iter()) and things are timing out it\\'s probably due to iter() going through your collection every time... learned that the hard way on this question. Probably will save you a lot of TLEs"
                    }
                ]
            },
            {
                "id": 1970036,
                "content": [
                    {
                        "username": "Ayush_Singh_610",
                        "content": "This code is failing for the test case\nInput\nedges =\n[-1,4,-1,2,0,4]\nOutput\n 2 \nExpected\n-1\n\ncan anyone please explain once what's wrong in this code. Literary spent 7 hrs still can't understand\n\n```\nclass Solution:\n    cycle = False\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [False]*len(edges)\n        visiting = [False]*len(edges)\n        intmax = -1\n        for i in range(0,len(visited)):\n            if not visited[i] and edges[i] != -1:\n                intmax = max(intmax, self.dfs(visited,visiting,edges,i,0)[1])\n        if not cycle:\n            return -1\n        return intmax\n\n    def dfs(self,visited,visiting,edges,node,count) -> bool:\n        if node == -1:\n            return [-1,-1,-1]\n        if visited[node]:\n            cycle = True\n            return [node,1,0]  #[node at which the cycle is detected,distance,signal to track during recursion return]\n        \n        visited[node] = True\n        context = self.dfs(visited,visiting,edges,edges[node],count)\n        visiting[node] = False\n        visited[node] = True\n\n        if context[0] == node:\n            context[2] = 1  #cycle complete\n            return context\n        if context[2] == 0:\n            context[1] += 1\n        return context\n```"
                    },
                    {
                        "username": "akrchaubey",
                        "content": "are you still stuck [@Ayush Singh](/Ayush_Singh_610)?"
                    },
                    {
                        "username": "crobat8",
                        "content": "is anyone else getting to testcase 76 then getting a TLE I can post my code if that helps. I feel like I figured out a solution but might need help with a few minor optimization to make it finish."
                    },
                    {
                        "username": "snill901123",
                        "content": "I have same problem."
                    },
                    {
                        "username": "daring-calf",
                        "content": "If you\\'re using an array to save the steps(distances), try use a map(dict)"
                    },
                    {
                        "username": "ramney",
                        "content": "\\nPlease help me to findout error in below code, its showing runtime error of address santizer,\\n\\n\\' class Solution {\\npublic:\\n    int maxPath = 0;\\n    void dfs(vector<int> & edges,int node, vector<bool> &visited,int currentPath)\\n    {\\n        visited[node] = true;\\n        int next = edges[node];\\n        if(visited[next] == true)\\n        {\\n            if(currentPath > maxPath) maxPath = currentPath;\\n            return;\\n        }\\n        if(visited[next] == false && next != -1)\\n        {\\n            currentPath++;\\n            dfs(edges,next,visited,currentPath);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            vector<bool> visited(n, false);\\n            int currentPath = 0;\\n            dfs(edges,i,visited,currentPath);\\n        }\\n        return maxPath;\\n    }\\n}; \\'"
                    },
                    {
                        "username": "manikantaloya",
                        "content": "I assume you code has vector<int> & instead of vector<int> in the function definition. Another error is in the line if(visited[next] == true)\\nHere next can also be -1 if the node doesn\\'t have outgoing edges which is leading to visited[-1] -- incorrect address. You may need to have a check if next != -1"
                    },
                    {
                        "username": "Aryan_Kumar9939",
                        "content": "Same question has been asked in my Goldman Sach OA"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Time Limit Exceeded\\n81 / 81 testcases passed.....\\nTestcases passed, but took too long.........\\n\\nHere we go again!!!!"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Why it is marked as Hard!!! Just finding cycle in a directed graph and also easy way mentioning only one outgoing edge in a node."
                    },
                    {
                        "username": "layyy",
                        "content": "try topological sort"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "This question is hard when it containd more edges from a vertex node..."
                    },
                    {
                        "username": "lalit10368",
                        "content": "This is much easier than the shortest cycle in a graph. Should have done this one first. "
                    },
                    {
                        "username": "feng3245",
                        "content": "Guys a quick tip that if you are using next(iter()) and things are timing out it\\'s probably due to iter() going through your collection every time... learned that the hard way on this question. Probably will save you a lot of TLEs"
                    }
                ]
            },
            {
                "id": 1949013,
                "content": [
                    {
                        "username": "Ayush_Singh_610",
                        "content": "This code is failing for the test case\nInput\nedges =\n[-1,4,-1,2,0,4]\nOutput\n 2 \nExpected\n-1\n\ncan anyone please explain once what's wrong in this code. Literary spent 7 hrs still can't understand\n\n```\nclass Solution:\n    cycle = False\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [False]*len(edges)\n        visiting = [False]*len(edges)\n        intmax = -1\n        for i in range(0,len(visited)):\n            if not visited[i] and edges[i] != -1:\n                intmax = max(intmax, self.dfs(visited,visiting,edges,i,0)[1])\n        if not cycle:\n            return -1\n        return intmax\n\n    def dfs(self,visited,visiting,edges,node,count) -> bool:\n        if node == -1:\n            return [-1,-1,-1]\n        if visited[node]:\n            cycle = True\n            return [node,1,0]  #[node at which the cycle is detected,distance,signal to track during recursion return]\n        \n        visited[node] = True\n        context = self.dfs(visited,visiting,edges,edges[node],count)\n        visiting[node] = False\n        visited[node] = True\n\n        if context[0] == node:\n            context[2] = 1  #cycle complete\n            return context\n        if context[2] == 0:\n            context[1] += 1\n        return context\n```"
                    },
                    {
                        "username": "akrchaubey",
                        "content": "are you still stuck [@Ayush Singh](/Ayush_Singh_610)?"
                    },
                    {
                        "username": "crobat8",
                        "content": "is anyone else getting to testcase 76 then getting a TLE I can post my code if that helps. I feel like I figured out a solution but might need help with a few minor optimization to make it finish."
                    },
                    {
                        "username": "snill901123",
                        "content": "I have same problem."
                    },
                    {
                        "username": "daring-calf",
                        "content": "If you\\'re using an array to save the steps(distances), try use a map(dict)"
                    },
                    {
                        "username": "ramney",
                        "content": "\\nPlease help me to findout error in below code, its showing runtime error of address santizer,\\n\\n\\' class Solution {\\npublic:\\n    int maxPath = 0;\\n    void dfs(vector<int> & edges,int node, vector<bool> &visited,int currentPath)\\n    {\\n        visited[node] = true;\\n        int next = edges[node];\\n        if(visited[next] == true)\\n        {\\n            if(currentPath > maxPath) maxPath = currentPath;\\n            return;\\n        }\\n        if(visited[next] == false && next != -1)\\n        {\\n            currentPath++;\\n            dfs(edges,next,visited,currentPath);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            vector<bool> visited(n, false);\\n            int currentPath = 0;\\n            dfs(edges,i,visited,currentPath);\\n        }\\n        return maxPath;\\n    }\\n}; \\'"
                    },
                    {
                        "username": "manikantaloya",
                        "content": "I assume you code has vector<int> & instead of vector<int> in the function definition. Another error is in the line if(visited[next] == true)\\nHere next can also be -1 if the node doesn\\'t have outgoing edges which is leading to visited[-1] -- incorrect address. You may need to have a check if next != -1"
                    },
                    {
                        "username": "Aryan_Kumar9939",
                        "content": "Same question has been asked in my Goldman Sach OA"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Time Limit Exceeded\\n81 / 81 testcases passed.....\\nTestcases passed, but took too long.........\\n\\nHere we go again!!!!"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Why it is marked as Hard!!! Just finding cycle in a directed graph and also easy way mentioning only one outgoing edge in a node."
                    },
                    {
                        "username": "layyy",
                        "content": "try topological sort"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "This question is hard when it containd more edges from a vertex node..."
                    },
                    {
                        "username": "lalit10368",
                        "content": "This is much easier than the shortest cycle in a graph. Should have done this one first. "
                    },
                    {
                        "username": "feng3245",
                        "content": "Guys a quick tip that if you are using next(iter()) and things are timing out it\\'s probably due to iter() going through your collection every time... learned that the hard way on this question. Probably will save you a lot of TLEs"
                    }
                ]
            },
            {
                "id": 1913124,
                "content": [
                    {
                        "username": "Ayush_Singh_610",
                        "content": "This code is failing for the test case\nInput\nedges =\n[-1,4,-1,2,0,4]\nOutput\n 2 \nExpected\n-1\n\ncan anyone please explain once what's wrong in this code. Literary spent 7 hrs still can't understand\n\n```\nclass Solution:\n    cycle = False\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [False]*len(edges)\n        visiting = [False]*len(edges)\n        intmax = -1\n        for i in range(0,len(visited)):\n            if not visited[i] and edges[i] != -1:\n                intmax = max(intmax, self.dfs(visited,visiting,edges,i,0)[1])\n        if not cycle:\n            return -1\n        return intmax\n\n    def dfs(self,visited,visiting,edges,node,count) -> bool:\n        if node == -1:\n            return [-1,-1,-1]\n        if visited[node]:\n            cycle = True\n            return [node,1,0]  #[node at which the cycle is detected,distance,signal to track during recursion return]\n        \n        visited[node] = True\n        context = self.dfs(visited,visiting,edges,edges[node],count)\n        visiting[node] = False\n        visited[node] = True\n\n        if context[0] == node:\n            context[2] = 1  #cycle complete\n            return context\n        if context[2] == 0:\n            context[1] += 1\n        return context\n```"
                    },
                    {
                        "username": "akrchaubey",
                        "content": "are you still stuck [@Ayush Singh](/Ayush_Singh_610)?"
                    },
                    {
                        "username": "crobat8",
                        "content": "is anyone else getting to testcase 76 then getting a TLE I can post my code if that helps. I feel like I figured out a solution but might need help with a few minor optimization to make it finish."
                    },
                    {
                        "username": "snill901123",
                        "content": "I have same problem."
                    },
                    {
                        "username": "daring-calf",
                        "content": "If you\\'re using an array to save the steps(distances), try use a map(dict)"
                    },
                    {
                        "username": "ramney",
                        "content": "\\nPlease help me to findout error in below code, its showing runtime error of address santizer,\\n\\n\\' class Solution {\\npublic:\\n    int maxPath = 0;\\n    void dfs(vector<int> & edges,int node, vector<bool> &visited,int currentPath)\\n    {\\n        visited[node] = true;\\n        int next = edges[node];\\n        if(visited[next] == true)\\n        {\\n            if(currentPath > maxPath) maxPath = currentPath;\\n            return;\\n        }\\n        if(visited[next] == false && next != -1)\\n        {\\n            currentPath++;\\n            dfs(edges,next,visited,currentPath);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            vector<bool> visited(n, false);\\n            int currentPath = 0;\\n            dfs(edges,i,visited,currentPath);\\n        }\\n        return maxPath;\\n    }\\n}; \\'"
                    },
                    {
                        "username": "manikantaloya",
                        "content": "I assume you code has vector<int> & instead of vector<int> in the function definition. Another error is in the line if(visited[next] == true)\\nHere next can also be -1 if the node doesn\\'t have outgoing edges which is leading to visited[-1] -- incorrect address. You may need to have a check if next != -1"
                    },
                    {
                        "username": "Aryan_Kumar9939",
                        "content": "Same question has been asked in my Goldman Sach OA"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Time Limit Exceeded\\n81 / 81 testcases passed.....\\nTestcases passed, but took too long.........\\n\\nHere we go again!!!!"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Why it is marked as Hard!!! Just finding cycle in a directed graph and also easy way mentioning only one outgoing edge in a node."
                    },
                    {
                        "username": "layyy",
                        "content": "try topological sort"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "This question is hard when it containd more edges from a vertex node..."
                    },
                    {
                        "username": "lalit10368",
                        "content": "This is much easier than the shortest cycle in a graph. Should have done this one first. "
                    },
                    {
                        "username": "feng3245",
                        "content": "Guys a quick tip that if you are using next(iter()) and things are timing out it\\'s probably due to iter() going through your collection every time... learned that the hard way on this question. Probably will save you a lot of TLEs"
                    }
                ]
            },
            {
                "id": 1879240,
                "content": [
                    {
                        "username": "Ayush_Singh_610",
                        "content": "This code is failing for the test case\nInput\nedges =\n[-1,4,-1,2,0,4]\nOutput\n 2 \nExpected\n-1\n\ncan anyone please explain once what's wrong in this code. Literary spent 7 hrs still can't understand\n\n```\nclass Solution:\n    cycle = False\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [False]*len(edges)\n        visiting = [False]*len(edges)\n        intmax = -1\n        for i in range(0,len(visited)):\n            if not visited[i] and edges[i] != -1:\n                intmax = max(intmax, self.dfs(visited,visiting,edges,i,0)[1])\n        if not cycle:\n            return -1\n        return intmax\n\n    def dfs(self,visited,visiting,edges,node,count) -> bool:\n        if node == -1:\n            return [-1,-1,-1]\n        if visited[node]:\n            cycle = True\n            return [node,1,0]  #[node at which the cycle is detected,distance,signal to track during recursion return]\n        \n        visited[node] = True\n        context = self.dfs(visited,visiting,edges,edges[node],count)\n        visiting[node] = False\n        visited[node] = True\n\n        if context[0] == node:\n            context[2] = 1  #cycle complete\n            return context\n        if context[2] == 0:\n            context[1] += 1\n        return context\n```"
                    },
                    {
                        "username": "akrchaubey",
                        "content": "are you still stuck [@Ayush Singh](/Ayush_Singh_610)?"
                    },
                    {
                        "username": "crobat8",
                        "content": "is anyone else getting to testcase 76 then getting a TLE I can post my code if that helps. I feel like I figured out a solution but might need help with a few minor optimization to make it finish."
                    },
                    {
                        "username": "snill901123",
                        "content": "I have same problem."
                    },
                    {
                        "username": "daring-calf",
                        "content": "If you\\'re using an array to save the steps(distances), try use a map(dict)"
                    },
                    {
                        "username": "ramney",
                        "content": "\\nPlease help me to findout error in below code, its showing runtime error of address santizer,\\n\\n\\' class Solution {\\npublic:\\n    int maxPath = 0;\\n    void dfs(vector<int> & edges,int node, vector<bool> &visited,int currentPath)\\n    {\\n        visited[node] = true;\\n        int next = edges[node];\\n        if(visited[next] == true)\\n        {\\n            if(currentPath > maxPath) maxPath = currentPath;\\n            return;\\n        }\\n        if(visited[next] == false && next != -1)\\n        {\\n            currentPath++;\\n            dfs(edges,next,visited,currentPath);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            vector<bool> visited(n, false);\\n            int currentPath = 0;\\n            dfs(edges,i,visited,currentPath);\\n        }\\n        return maxPath;\\n    }\\n}; \\'"
                    },
                    {
                        "username": "manikantaloya",
                        "content": "I assume you code has vector<int> & instead of vector<int> in the function definition. Another error is in the line if(visited[next] == true)\\nHere next can also be -1 if the node doesn\\'t have outgoing edges which is leading to visited[-1] -- incorrect address. You may need to have a check if next != -1"
                    },
                    {
                        "username": "Aryan_Kumar9939",
                        "content": "Same question has been asked in my Goldman Sach OA"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Time Limit Exceeded\\n81 / 81 testcases passed.....\\nTestcases passed, but took too long.........\\n\\nHere we go again!!!!"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Why it is marked as Hard!!! Just finding cycle in a directed graph and also easy way mentioning only one outgoing edge in a node."
                    },
                    {
                        "username": "layyy",
                        "content": "try topological sort"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "This question is hard when it containd more edges from a vertex node..."
                    },
                    {
                        "username": "lalit10368",
                        "content": "This is much easier than the shortest cycle in a graph. Should have done this one first. "
                    },
                    {
                        "username": "feng3245",
                        "content": "Guys a quick tip that if you are using next(iter()) and things are timing out it\\'s probably due to iter() going through your collection every time... learned that the hard way on this question. Probably will save you a lot of TLEs"
                    }
                ]
            },
            {
                "id": 1845740,
                "content": [
                    {
                        "username": "Ayush_Singh_610",
                        "content": "This code is failing for the test case\nInput\nedges =\n[-1,4,-1,2,0,4]\nOutput\n 2 \nExpected\n-1\n\ncan anyone please explain once what's wrong in this code. Literary spent 7 hrs still can't understand\n\n```\nclass Solution:\n    cycle = False\n    def longestCycle(self, edges: List[int]) -> int:\n        visited = [False]*len(edges)\n        visiting = [False]*len(edges)\n        intmax = -1\n        for i in range(0,len(visited)):\n            if not visited[i] and edges[i] != -1:\n                intmax = max(intmax, self.dfs(visited,visiting,edges,i,0)[1])\n        if not cycle:\n            return -1\n        return intmax\n\n    def dfs(self,visited,visiting,edges,node,count) -> bool:\n        if node == -1:\n            return [-1,-1,-1]\n        if visited[node]:\n            cycle = True\n            return [node,1,0]  #[node at which the cycle is detected,distance,signal to track during recursion return]\n        \n        visited[node] = True\n        context = self.dfs(visited,visiting,edges,edges[node],count)\n        visiting[node] = False\n        visited[node] = True\n\n        if context[0] == node:\n            context[2] = 1  #cycle complete\n            return context\n        if context[2] == 0:\n            context[1] += 1\n        return context\n```"
                    },
                    {
                        "username": "akrchaubey",
                        "content": "are you still stuck [@Ayush Singh](/Ayush_Singh_610)?"
                    },
                    {
                        "username": "crobat8",
                        "content": "is anyone else getting to testcase 76 then getting a TLE I can post my code if that helps. I feel like I figured out a solution but might need help with a few minor optimization to make it finish."
                    },
                    {
                        "username": "snill901123",
                        "content": "I have same problem."
                    },
                    {
                        "username": "daring-calf",
                        "content": "If you\\'re using an array to save the steps(distances), try use a map(dict)"
                    },
                    {
                        "username": "ramney",
                        "content": "\\nPlease help me to findout error in below code, its showing runtime error of address santizer,\\n\\n\\' class Solution {\\npublic:\\n    int maxPath = 0;\\n    void dfs(vector<int> & edges,int node, vector<bool> &visited,int currentPath)\\n    {\\n        visited[node] = true;\\n        int next = edges[node];\\n        if(visited[next] == true)\\n        {\\n            if(currentPath > maxPath) maxPath = currentPath;\\n            return;\\n        }\\n        if(visited[next] == false && next != -1)\\n        {\\n            currentPath++;\\n            dfs(edges,next,visited,currentPath);\\n        }\\n    }\\n\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        for(int i = 0;i < n;i++)\\n        {\\n            vector<bool> visited(n, false);\\n            int currentPath = 0;\\n            dfs(edges,i,visited,currentPath);\\n        }\\n        return maxPath;\\n    }\\n}; \\'"
                    },
                    {
                        "username": "manikantaloya",
                        "content": "I assume you code has vector<int> & instead of vector<int> in the function definition. Another error is in the line if(visited[next] == true)\\nHere next can also be -1 if the node doesn\\'t have outgoing edges which is leading to visited[-1] -- incorrect address. You may need to have a check if next != -1"
                    },
                    {
                        "username": "Aryan_Kumar9939",
                        "content": "Same question has been asked in my Goldman Sach OA"
                    },
                    {
                        "username": "sam_Eldoro",
                        "content": "Time Limit Exceeded\\n81 / 81 testcases passed.....\\nTestcases passed, but took too long.........\\n\\nHere we go again!!!!"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Why it is marked as Hard!!! Just finding cycle in a directed graph and also easy way mentioning only one outgoing edge in a node."
                    },
                    {
                        "username": "layyy",
                        "content": "try topological sort"
                    },
                    {
                        "username": "saurabh_175",
                        "content": "This question is hard when it containd more edges from a vertex node..."
                    },
                    {
                        "username": "lalit10368",
                        "content": "This is much easier than the shortest cycle in a graph. Should have done this one first. "
                    },
                    {
                        "username": "feng3245",
                        "content": "Guys a quick tip that if you are using next(iter()) and things are timing out it\\'s probably due to iter() going through your collection every time... learned that the hard way on this question. Probably will save you a lot of TLEs"
                    }
                ]
            },
            {
                "id": 1844599,
                "content": [
                    {
                        "username": "okdiec",
                        "content": "Useful Test case:\n[1,2,0,4,5,3]\n\nanswer = 3"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have seen many medium problems that seemed a lot harder to me than this hard problem. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "In-place O(1) space solution [here](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344343/python-in-place-o-1-space-just-paint-it-black/). Please upvote, if it was helpful."
                    },
                    {
                        "username": "fazil_0399",
                        "content": "A variation of finding cycle in directed graph by keeping distance array and computing max size cycle using distance array."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "PLSSSSSSSSSSSSSSSSSSSSSSSSS help WHY SAME LOGic is working in c++, but in java dist_node array is not saving distance with increment it;\\ni attach both code pls see;\\n\\nJAVA++;;;;;;----\\nclass Solution {\\n   public void dfs(int node,int edges[],int ans,int distance,int pathvis[], int dist_node[],int vis[]){\\n        if(node!=-1){\\n          \\n          if(vis[node]==0){\\n            System.out.print(\"ww\");\\n            vis[node]=1;\\n            pathvis[node]=1;\\n            dist_node[node]=distance;\\n             System.out.print(distance);\\n             dfs(node,edges,ans,distance+1,pathvis,dist_node,vis);\\n          }\\n          else if(pathvis[node]==1){\\n            ans=Math.max(ans,distance-dist_node[node]);\\n            \\n          }\\n           pathvis[node]=0;\\n        }\\n   }\\n\\n\\n    public int longestCycle(int[] edges) {\\n      int vis[]=new int[edges.length];\\n    \\n      int pathvis[]= new int[edges.length];\\n      int dist_node[]= new int[edges.length];\\n      int ans=-1;\\n      for(int i=0;i<edges.length;i++){\\n        if(vis[i]==0){\\n           dfs(i,edges,ans,0,pathvis,dist_node,vis);\\n        }\\n      }\\n      \\n      \\n      return ans; \\n    }\\n}\\n\\n\\n\\n\\nc++ code---\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "iiostream",
                        "content": "leetcode\\'s server..."
                    },
                    {
                        "username": "psionl0",
                        "content": "Adjacency lists and dfs seem to solve all of the problems given this week. In this case, my solution was rather slow but no TLE."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have really helped if they could have clearly mentioned that there can be disconnected components in the graph. If this was a connected graph, a single traversal would have been enough for the answer."
                    },
                    {
                        "username": "amiteshrocks02",
                        "content": "What if more  than one outgoing edge was allowed how would that be handled ? "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "after solving graphs this week: ACHHA ACHHA FEEL HO RAHA HAI\\n "
                    }
                ]
            },
            {
                "id": 1844416,
                "content": [
                    {
                        "username": "okdiec",
                        "content": "Useful Test case:\n[1,2,0,4,5,3]\n\nanswer = 3"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have seen many medium problems that seemed a lot harder to me than this hard problem. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "In-place O(1) space solution [here](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344343/python-in-place-o-1-space-just-paint-it-black/). Please upvote, if it was helpful."
                    },
                    {
                        "username": "fazil_0399",
                        "content": "A variation of finding cycle in directed graph by keeping distance array and computing max size cycle using distance array."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "PLSSSSSSSSSSSSSSSSSSSSSSSSS help WHY SAME LOGic is working in c++, but in java dist_node array is not saving distance with increment it;\\ni attach both code pls see;\\n\\nJAVA++;;;;;;----\\nclass Solution {\\n   public void dfs(int node,int edges[],int ans,int distance,int pathvis[], int dist_node[],int vis[]){\\n        if(node!=-1){\\n          \\n          if(vis[node]==0){\\n            System.out.print(\"ww\");\\n            vis[node]=1;\\n            pathvis[node]=1;\\n            dist_node[node]=distance;\\n             System.out.print(distance);\\n             dfs(node,edges,ans,distance+1,pathvis,dist_node,vis);\\n          }\\n          else if(pathvis[node]==1){\\n            ans=Math.max(ans,distance-dist_node[node]);\\n            \\n          }\\n           pathvis[node]=0;\\n        }\\n   }\\n\\n\\n    public int longestCycle(int[] edges) {\\n      int vis[]=new int[edges.length];\\n    \\n      int pathvis[]= new int[edges.length];\\n      int dist_node[]= new int[edges.length];\\n      int ans=-1;\\n      for(int i=0;i<edges.length;i++){\\n        if(vis[i]==0){\\n           dfs(i,edges,ans,0,pathvis,dist_node,vis);\\n        }\\n      }\\n      \\n      \\n      return ans; \\n    }\\n}\\n\\n\\n\\n\\nc++ code---\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "iiostream",
                        "content": "leetcode\\'s server..."
                    },
                    {
                        "username": "psionl0",
                        "content": "Adjacency lists and dfs seem to solve all of the problems given this week. In this case, my solution was rather slow but no TLE."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have really helped if they could have clearly mentioned that there can be disconnected components in the graph. If this was a connected graph, a single traversal would have been enough for the answer."
                    },
                    {
                        "username": "amiteshrocks02",
                        "content": "What if more  than one outgoing edge was allowed how would that be handled ? "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "after solving graphs this week: ACHHA ACHHA FEEL HO RAHA HAI\\n "
                    }
                ]
            },
            {
                "id": 1844413,
                "content": [
                    {
                        "username": "okdiec",
                        "content": "Useful Test case:\n[1,2,0,4,5,3]\n\nanswer = 3"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have seen many medium problems that seemed a lot harder to me than this hard problem. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "In-place O(1) space solution [here](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344343/python-in-place-o-1-space-just-paint-it-black/). Please upvote, if it was helpful."
                    },
                    {
                        "username": "fazil_0399",
                        "content": "A variation of finding cycle in directed graph by keeping distance array and computing max size cycle using distance array."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "PLSSSSSSSSSSSSSSSSSSSSSSSSS help WHY SAME LOGic is working in c++, but in java dist_node array is not saving distance with increment it;\\ni attach both code pls see;\\n\\nJAVA++;;;;;;----\\nclass Solution {\\n   public void dfs(int node,int edges[],int ans,int distance,int pathvis[], int dist_node[],int vis[]){\\n        if(node!=-1){\\n          \\n          if(vis[node]==0){\\n            System.out.print(\"ww\");\\n            vis[node]=1;\\n            pathvis[node]=1;\\n            dist_node[node]=distance;\\n             System.out.print(distance);\\n             dfs(node,edges,ans,distance+1,pathvis,dist_node,vis);\\n          }\\n          else if(pathvis[node]==1){\\n            ans=Math.max(ans,distance-dist_node[node]);\\n            \\n          }\\n           pathvis[node]=0;\\n        }\\n   }\\n\\n\\n    public int longestCycle(int[] edges) {\\n      int vis[]=new int[edges.length];\\n    \\n      int pathvis[]= new int[edges.length];\\n      int dist_node[]= new int[edges.length];\\n      int ans=-1;\\n      for(int i=0;i<edges.length;i++){\\n        if(vis[i]==0){\\n           dfs(i,edges,ans,0,pathvis,dist_node,vis);\\n        }\\n      }\\n      \\n      \\n      return ans; \\n    }\\n}\\n\\n\\n\\n\\nc++ code---\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "iiostream",
                        "content": "leetcode\\'s server..."
                    },
                    {
                        "username": "psionl0",
                        "content": "Adjacency lists and dfs seem to solve all of the problems given this week. In this case, my solution was rather slow but no TLE."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have really helped if they could have clearly mentioned that there can be disconnected components in the graph. If this was a connected graph, a single traversal would have been enough for the answer."
                    },
                    {
                        "username": "amiteshrocks02",
                        "content": "What if more  than one outgoing edge was allowed how would that be handled ? "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "after solving graphs this week: ACHHA ACHHA FEEL HO RAHA HAI\\n "
                    }
                ]
            },
            {
                "id": 1844292,
                "content": [
                    {
                        "username": "okdiec",
                        "content": "Useful Test case:\n[1,2,0,4,5,3]\n\nanswer = 3"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have seen many medium problems that seemed a lot harder to me than this hard problem. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "In-place O(1) space solution [here](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344343/python-in-place-o-1-space-just-paint-it-black/). Please upvote, if it was helpful."
                    },
                    {
                        "username": "fazil_0399",
                        "content": "A variation of finding cycle in directed graph by keeping distance array and computing max size cycle using distance array."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "PLSSSSSSSSSSSSSSSSSSSSSSSSS help WHY SAME LOGic is working in c++, but in java dist_node array is not saving distance with increment it;\\ni attach both code pls see;\\n\\nJAVA++;;;;;;----\\nclass Solution {\\n   public void dfs(int node,int edges[],int ans,int distance,int pathvis[], int dist_node[],int vis[]){\\n        if(node!=-1){\\n          \\n          if(vis[node]==0){\\n            System.out.print(\"ww\");\\n            vis[node]=1;\\n            pathvis[node]=1;\\n            dist_node[node]=distance;\\n             System.out.print(distance);\\n             dfs(node,edges,ans,distance+1,pathvis,dist_node,vis);\\n          }\\n          else if(pathvis[node]==1){\\n            ans=Math.max(ans,distance-dist_node[node]);\\n            \\n          }\\n           pathvis[node]=0;\\n        }\\n   }\\n\\n\\n    public int longestCycle(int[] edges) {\\n      int vis[]=new int[edges.length];\\n    \\n      int pathvis[]= new int[edges.length];\\n      int dist_node[]= new int[edges.length];\\n      int ans=-1;\\n      for(int i=0;i<edges.length;i++){\\n        if(vis[i]==0){\\n           dfs(i,edges,ans,0,pathvis,dist_node,vis);\\n        }\\n      }\\n      \\n      \\n      return ans; \\n    }\\n}\\n\\n\\n\\n\\nc++ code---\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "iiostream",
                        "content": "leetcode\\'s server..."
                    },
                    {
                        "username": "psionl0",
                        "content": "Adjacency lists and dfs seem to solve all of the problems given this week. In this case, my solution was rather slow but no TLE."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have really helped if they could have clearly mentioned that there can be disconnected components in the graph. If this was a connected graph, a single traversal would have been enough for the answer."
                    },
                    {
                        "username": "amiteshrocks02",
                        "content": "What if more  than one outgoing edge was allowed how would that be handled ? "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "after solving graphs this week: ACHHA ACHHA FEEL HO RAHA HAI\\n "
                    }
                ]
            },
            {
                "id": 1844281,
                "content": [
                    {
                        "username": "okdiec",
                        "content": "Useful Test case:\n[1,2,0,4,5,3]\n\nanswer = 3"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have seen many medium problems that seemed a lot harder to me than this hard problem. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "In-place O(1) space solution [here](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344343/python-in-place-o-1-space-just-paint-it-black/). Please upvote, if it was helpful."
                    },
                    {
                        "username": "fazil_0399",
                        "content": "A variation of finding cycle in directed graph by keeping distance array and computing max size cycle using distance array."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "PLSSSSSSSSSSSSSSSSSSSSSSSSS help WHY SAME LOGic is working in c++, but in java dist_node array is not saving distance with increment it;\\ni attach both code pls see;\\n\\nJAVA++;;;;;;----\\nclass Solution {\\n   public void dfs(int node,int edges[],int ans,int distance,int pathvis[], int dist_node[],int vis[]){\\n        if(node!=-1){\\n          \\n          if(vis[node]==0){\\n            System.out.print(\"ww\");\\n            vis[node]=1;\\n            pathvis[node]=1;\\n            dist_node[node]=distance;\\n             System.out.print(distance);\\n             dfs(node,edges,ans,distance+1,pathvis,dist_node,vis);\\n          }\\n          else if(pathvis[node]==1){\\n            ans=Math.max(ans,distance-dist_node[node]);\\n            \\n          }\\n           pathvis[node]=0;\\n        }\\n   }\\n\\n\\n    public int longestCycle(int[] edges) {\\n      int vis[]=new int[edges.length];\\n    \\n      int pathvis[]= new int[edges.length];\\n      int dist_node[]= new int[edges.length];\\n      int ans=-1;\\n      for(int i=0;i<edges.length;i++){\\n        if(vis[i]==0){\\n           dfs(i,edges,ans,0,pathvis,dist_node,vis);\\n        }\\n      }\\n      \\n      \\n      return ans; \\n    }\\n}\\n\\n\\n\\n\\nc++ code---\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "iiostream",
                        "content": "leetcode\\'s server..."
                    },
                    {
                        "username": "psionl0",
                        "content": "Adjacency lists and dfs seem to solve all of the problems given this week. In this case, my solution was rather slow but no TLE."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have really helped if they could have clearly mentioned that there can be disconnected components in the graph. If this was a connected graph, a single traversal would have been enough for the answer."
                    },
                    {
                        "username": "amiteshrocks02",
                        "content": "What if more  than one outgoing edge was allowed how would that be handled ? "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "after solving graphs this week: ACHHA ACHHA FEEL HO RAHA HAI\\n "
                    }
                ]
            },
            {
                "id": 1844237,
                "content": [
                    {
                        "username": "okdiec",
                        "content": "Useful Test case:\n[1,2,0,4,5,3]\n\nanswer = 3"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have seen many medium problems that seemed a lot harder to me than this hard problem. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "In-place O(1) space solution [here](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344343/python-in-place-o-1-space-just-paint-it-black/). Please upvote, if it was helpful."
                    },
                    {
                        "username": "fazil_0399",
                        "content": "A variation of finding cycle in directed graph by keeping distance array and computing max size cycle using distance array."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "PLSSSSSSSSSSSSSSSSSSSSSSSSS help WHY SAME LOGic is working in c++, but in java dist_node array is not saving distance with increment it;\\ni attach both code pls see;\\n\\nJAVA++;;;;;;----\\nclass Solution {\\n   public void dfs(int node,int edges[],int ans,int distance,int pathvis[], int dist_node[],int vis[]){\\n        if(node!=-1){\\n          \\n          if(vis[node]==0){\\n            System.out.print(\"ww\");\\n            vis[node]=1;\\n            pathvis[node]=1;\\n            dist_node[node]=distance;\\n             System.out.print(distance);\\n             dfs(node,edges,ans,distance+1,pathvis,dist_node,vis);\\n          }\\n          else if(pathvis[node]==1){\\n            ans=Math.max(ans,distance-dist_node[node]);\\n            \\n          }\\n           pathvis[node]=0;\\n        }\\n   }\\n\\n\\n    public int longestCycle(int[] edges) {\\n      int vis[]=new int[edges.length];\\n    \\n      int pathvis[]= new int[edges.length];\\n      int dist_node[]= new int[edges.length];\\n      int ans=-1;\\n      for(int i=0;i<edges.length;i++){\\n        if(vis[i]==0){\\n           dfs(i,edges,ans,0,pathvis,dist_node,vis);\\n        }\\n      }\\n      \\n      \\n      return ans; \\n    }\\n}\\n\\n\\n\\n\\nc++ code---\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "iiostream",
                        "content": "leetcode\\'s server..."
                    },
                    {
                        "username": "psionl0",
                        "content": "Adjacency lists and dfs seem to solve all of the problems given this week. In this case, my solution was rather slow but no TLE."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have really helped if they could have clearly mentioned that there can be disconnected components in the graph. If this was a connected graph, a single traversal would have been enough for the answer."
                    },
                    {
                        "username": "amiteshrocks02",
                        "content": "What if more  than one outgoing edge was allowed how would that be handled ? "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "after solving graphs this week: ACHHA ACHHA FEEL HO RAHA HAI\\n "
                    }
                ]
            },
            {
                "id": 1844194,
                "content": [
                    {
                        "username": "okdiec",
                        "content": "Useful Test case:\n[1,2,0,4,5,3]\n\nanswer = 3"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have seen many medium problems that seemed a lot harder to me than this hard problem. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "In-place O(1) space solution [here](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344343/python-in-place-o-1-space-just-paint-it-black/). Please upvote, if it was helpful."
                    },
                    {
                        "username": "fazil_0399",
                        "content": "A variation of finding cycle in directed graph by keeping distance array and computing max size cycle using distance array."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "PLSSSSSSSSSSSSSSSSSSSSSSSSS help WHY SAME LOGic is working in c++, but in java dist_node array is not saving distance with increment it;\\ni attach both code pls see;\\n\\nJAVA++;;;;;;----\\nclass Solution {\\n   public void dfs(int node,int edges[],int ans,int distance,int pathvis[], int dist_node[],int vis[]){\\n        if(node!=-1){\\n          \\n          if(vis[node]==0){\\n            System.out.print(\"ww\");\\n            vis[node]=1;\\n            pathvis[node]=1;\\n            dist_node[node]=distance;\\n             System.out.print(distance);\\n             dfs(node,edges,ans,distance+1,pathvis,dist_node,vis);\\n          }\\n          else if(pathvis[node]==1){\\n            ans=Math.max(ans,distance-dist_node[node]);\\n            \\n          }\\n           pathvis[node]=0;\\n        }\\n   }\\n\\n\\n    public int longestCycle(int[] edges) {\\n      int vis[]=new int[edges.length];\\n    \\n      int pathvis[]= new int[edges.length];\\n      int dist_node[]= new int[edges.length];\\n      int ans=-1;\\n      for(int i=0;i<edges.length;i++){\\n        if(vis[i]==0){\\n           dfs(i,edges,ans,0,pathvis,dist_node,vis);\\n        }\\n      }\\n      \\n      \\n      return ans; \\n    }\\n}\\n\\n\\n\\n\\nc++ code---\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "iiostream",
                        "content": "leetcode\\'s server..."
                    },
                    {
                        "username": "psionl0",
                        "content": "Adjacency lists and dfs seem to solve all of the problems given this week. In this case, my solution was rather slow but no TLE."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have really helped if they could have clearly mentioned that there can be disconnected components in the graph. If this was a connected graph, a single traversal would have been enough for the answer."
                    },
                    {
                        "username": "amiteshrocks02",
                        "content": "What if more  than one outgoing edge was allowed how would that be handled ? "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "after solving graphs this week: ACHHA ACHHA FEEL HO RAHA HAI\\n "
                    }
                ]
            },
            {
                "id": 1844156,
                "content": [
                    {
                        "username": "okdiec",
                        "content": "Useful Test case:\n[1,2,0,4,5,3]\n\nanswer = 3"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have seen many medium problems that seemed a lot harder to me than this hard problem. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "In-place O(1) space solution [here](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344343/python-in-place-o-1-space-just-paint-it-black/). Please upvote, if it was helpful."
                    },
                    {
                        "username": "fazil_0399",
                        "content": "A variation of finding cycle in directed graph by keeping distance array and computing max size cycle using distance array."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "PLSSSSSSSSSSSSSSSSSSSSSSSSS help WHY SAME LOGic is working in c++, but in java dist_node array is not saving distance with increment it;\\ni attach both code pls see;\\n\\nJAVA++;;;;;;----\\nclass Solution {\\n   public void dfs(int node,int edges[],int ans,int distance,int pathvis[], int dist_node[],int vis[]){\\n        if(node!=-1){\\n          \\n          if(vis[node]==0){\\n            System.out.print(\"ww\");\\n            vis[node]=1;\\n            pathvis[node]=1;\\n            dist_node[node]=distance;\\n             System.out.print(distance);\\n             dfs(node,edges,ans,distance+1,pathvis,dist_node,vis);\\n          }\\n          else if(pathvis[node]==1){\\n            ans=Math.max(ans,distance-dist_node[node]);\\n            \\n          }\\n           pathvis[node]=0;\\n        }\\n   }\\n\\n\\n    public int longestCycle(int[] edges) {\\n      int vis[]=new int[edges.length];\\n    \\n      int pathvis[]= new int[edges.length];\\n      int dist_node[]= new int[edges.length];\\n      int ans=-1;\\n      for(int i=0;i<edges.length;i++){\\n        if(vis[i]==0){\\n           dfs(i,edges,ans,0,pathvis,dist_node,vis);\\n        }\\n      }\\n      \\n      \\n      return ans; \\n    }\\n}\\n\\n\\n\\n\\nc++ code---\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "iiostream",
                        "content": "leetcode\\'s server..."
                    },
                    {
                        "username": "psionl0",
                        "content": "Adjacency lists and dfs seem to solve all of the problems given this week. In this case, my solution was rather slow but no TLE."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have really helped if they could have clearly mentioned that there can be disconnected components in the graph. If this was a connected graph, a single traversal would have been enough for the answer."
                    },
                    {
                        "username": "amiteshrocks02",
                        "content": "What if more  than one outgoing edge was allowed how would that be handled ? "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "after solving graphs this week: ACHHA ACHHA FEEL HO RAHA HAI\\n "
                    }
                ]
            },
            {
                "id": 1844123,
                "content": [
                    {
                        "username": "okdiec",
                        "content": "Useful Test case:\n[1,2,0,4,5,3]\n\nanswer = 3"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have seen many medium problems that seemed a lot harder to me than this hard problem. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "In-place O(1) space solution [here](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344343/python-in-place-o-1-space-just-paint-it-black/). Please upvote, if it was helpful."
                    },
                    {
                        "username": "fazil_0399",
                        "content": "A variation of finding cycle in directed graph by keeping distance array and computing max size cycle using distance array."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "PLSSSSSSSSSSSSSSSSSSSSSSSSS help WHY SAME LOGic is working in c++, but in java dist_node array is not saving distance with increment it;\\ni attach both code pls see;\\n\\nJAVA++;;;;;;----\\nclass Solution {\\n   public void dfs(int node,int edges[],int ans,int distance,int pathvis[], int dist_node[],int vis[]){\\n        if(node!=-1){\\n          \\n          if(vis[node]==0){\\n            System.out.print(\"ww\");\\n            vis[node]=1;\\n            pathvis[node]=1;\\n            dist_node[node]=distance;\\n             System.out.print(distance);\\n             dfs(node,edges,ans,distance+1,pathvis,dist_node,vis);\\n          }\\n          else if(pathvis[node]==1){\\n            ans=Math.max(ans,distance-dist_node[node]);\\n            \\n          }\\n           pathvis[node]=0;\\n        }\\n   }\\n\\n\\n    public int longestCycle(int[] edges) {\\n      int vis[]=new int[edges.length];\\n    \\n      int pathvis[]= new int[edges.length];\\n      int dist_node[]= new int[edges.length];\\n      int ans=-1;\\n      for(int i=0;i<edges.length;i++){\\n        if(vis[i]==0){\\n           dfs(i,edges,ans,0,pathvis,dist_node,vis);\\n        }\\n      }\\n      \\n      \\n      return ans; \\n    }\\n}\\n\\n\\n\\n\\nc++ code---\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "iiostream",
                        "content": "leetcode\\'s server..."
                    },
                    {
                        "username": "psionl0",
                        "content": "Adjacency lists and dfs seem to solve all of the problems given this week. In this case, my solution was rather slow but no TLE."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have really helped if they could have clearly mentioned that there can be disconnected components in the graph. If this was a connected graph, a single traversal would have been enough for the answer."
                    },
                    {
                        "username": "amiteshrocks02",
                        "content": "What if more  than one outgoing edge was allowed how would that be handled ? "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "after solving graphs this week: ACHHA ACHHA FEEL HO RAHA HAI\\n "
                    }
                ]
            },
            {
                "id": 1844115,
                "content": [
                    {
                        "username": "okdiec",
                        "content": "Useful Test case:\n[1,2,0,4,5,3]\n\nanswer = 3"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I have seen many medium problems that seemed a lot harder to me than this hard problem. "
                    },
                    {
                        "username": "almostmonday",
                        "content": "In-place O(1) space solution [here](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3344343/python-in-place-o-1-space-just-paint-it-black/). Please upvote, if it was helpful."
                    },
                    {
                        "username": "fazil_0399",
                        "content": "A variation of finding cycle in directed graph by keeping distance array and computing max size cycle using distance array."
                    },
                    {
                        "username": "underdogsourav",
                        "content": "PLSSSSSSSSSSSSSSSSSSSSSSSSS help WHY SAME LOGic is working in c++, but in java dist_node array is not saving distance with increment it;\\ni attach both code pls see;\\n\\nJAVA++;;;;;;----\\nclass Solution {\\n   public void dfs(int node,int edges[],int ans,int distance,int pathvis[], int dist_node[],int vis[]){\\n        if(node!=-1){\\n          \\n          if(vis[node]==0){\\n            System.out.print(\"ww\");\\n            vis[node]=1;\\n            pathvis[node]=1;\\n            dist_node[node]=distance;\\n             System.out.print(distance);\\n             dfs(node,edges,ans,distance+1,pathvis,dist_node,vis);\\n          }\\n          else if(pathvis[node]==1){\\n            ans=Math.max(ans,distance-dist_node[node]);\\n            \\n          }\\n           pathvis[node]=0;\\n        }\\n   }\\n\\n\\n    public int longestCycle(int[] edges) {\\n      int vis[]=new int[edges.length];\\n    \\n      int pathvis[]= new int[edges.length];\\n      int dist_node[]= new int[edges.length];\\n      int ans=-1;\\n      for(int i=0;i<edges.length;i++){\\n        if(vis[i]==0){\\n           dfs(i,edges,ans,0,pathvis,dist_node,vis);\\n        }\\n      }\\n      \\n      \\n      return ans; \\n    }\\n}\\n\\n\\n\\n\\nc++ code---\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& dist_node, vector<bool> & visited, vector<int>& edges, int distance,int &ans, vector<bool> & extra ){\\n        if(node!=-1){\\n          if(!visited[node]){\\n              visited[node]=true;\\n              extra[node]=true;\\n              dist_node[node]=distance;\\n              dfs(edges[node],dist_node,visited,edges,distance+1,ans,extra);\\n          }\\n          else if(extra[node])\\n               {   \\n                   ans = max(ans, distance - dist_node[node]);\\n               }   \\n               extra[node]  = false;\\n        }\\n       \\n    }\\n    int longestCycle(vector<int>& edges) {\\n        vector<int> dist_node(edges.size(),0);\\n        vector<bool>extra(edges.size(),false);\\n        vector<bool>visited(edges.size(),false);\\n        int ans=-1;\\n        for(int i=0;i<edges.size();i++){\\n            if(!visited[i]){\\n                dfs(i,dist_node,visited,edges,0,ans,extra);\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "iiostream",
                        "content": "leetcode\\'s server..."
                    },
                    {
                        "username": "psionl0",
                        "content": "Adjacency lists and dfs seem to solve all of the problems given this week. In this case, my solution was rather slow but no TLE."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "It would have really helped if they could have clearly mentioned that there can be disconnected components in the graph. If this was a connected graph, a single traversal would have been enough for the answer."
                    },
                    {
                        "username": "amiteshrocks02",
                        "content": "What if more  than one outgoing edge was allowed how would that be handled ? "
                    },
                    {
                        "username": "codeMonarch",
                        "content": "after solving graphs this week: ACHHA ACHHA FEEL HO RAHA HAI\\n "
                    }
                ]
            },
            {
                "id": 1844045,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nJust do a dfs traversal and keep a vis array. As each node can have at most 1 outgoing edge, it can be part of only one cycle.\n\nUse a map to store the length of reaching each node in a cycle, for each potential cycle create a new map. \n\nCalculate cycle length only when when you reach an already visited node.\n\nIf still confused and want to see the answer, refer to the leetcode editorial's first ans, I think they've explained it quite nicely"
                    },
                    {
                        "username": "rvamsi599",
                        "content": "Can anyone explain what is wrong with this code it is not even passing the first test case however when i run the same code  in my local machine with the given test case it is working but in leetcode it is throwing an error \\n`runtime error: addition of unsigned offset to 0x6030000000a0 overflowed to 0x603000000098 (stl_vector.h) `\\nfor the following code someone please try running this and please let me know what is the problem  \\uD83E\\uDD7A \\uD83E\\uDD7A \\uD83E\\uDD7A\\n`class Solution {\\npublic:\\n    int ans = -1;\\n    int longestCycle(vector<int>& edges) {\\n        int siz = edges.size();\\n        vector<int> dist(siz, -1);\\n        for(int i = 0; i < siz; i++){\\n            // if(dist[i] != -1) continue;\\n            cout << i;\\n            dfs(edges, dist, i, -1);\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(vector<int>& edges, vector<int>& dist, int node, int cdis){\\n        if(dist[node] != -1){\\n            int clen = cdis+1 - dist[node];\\n            ans = max(ans, clen);\\n            return;\\n        }\\n        dist[node] = cdis + 1;\\n        dfs(edges, dist, edges[node], cdis+1);\\n    }\\n    };`"
                    },
                    {
                        "username": "resurgence24",
                        "content": "Using ```Map<Integer, Integer> distance = new HashMap<>(); ``` gives AC solution but if I use ```int distance = new int[n]``` it is giving me TLE.\\n\\nCan anyone put light on this situation of mine? Pls... "
                    },
                    {
                        "username": "mrtriumpf",
                        "content": "same thing happened to me, as a fun thing - it didn't do TLE if i run the test case in isolation :)\n\nMaybe something to do with lots of mem allocations .\n\n I turned to another approach - to keep distance array created once, and keep another array to tell which starting node was used to analyze the cycle. \nonce you analyze cycle from node X and you see some other node Y already had been here - you stop"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The only hard thing in this question was me trying to find the hard part in the question."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "The longest cycle in the graph is the one cycle with the maximum length. :>"
                    },
                    {
                        "username": "HinaNarukami",
                        "content": "I tried to use DFS, but it turned out that this had a runtime error: load of null pointer of type \\'std::_Bit_type\\' (aka \\'unsigned long\\') (stl_bvector.h)\\nCan anyone explain the reason that my code didn\\'t work?\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    void dfs(int& count, int& ans, int node, vector<int>& edges, vector<bool>& vis, vector<int>& orders, vector<bool>& check){\\n        vis[node] = 1;\\n        orders[node] = count;\\n        count++;\\n        if(edges[node] == -1) return;\\n        if(vis[edges[node]] == 1){\\n            if(check[edges[node]] == 1) ans = max(ans, orders[node] - orders[edges[node]] + 1);\\n            memset(&check, 0, sizeof(check));\\n            count = 0;\\n        } else {\\n            check[node] = 1;\\n            dfs(count, ans, edges[node], edges, vis, orders, check);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> orders(n);\\n        int ans = -1;\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<bool> check(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]) dfs(count, ans, i, edges, vis, orders, check);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s hard. But we have been solving harder problems for last few days.. "
                    },
                    {
                        "username": "user8228j",
                        "content": "RIP to those who lose their streak due to leetcode outage"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had way more struggles with previous graph problems this month on Daily Challenge. Agreed with other person saying it should be medium level problem.\\nAs for people struggling with TLE, here\\'s a tip: you don\\'t need recursion to solve this. Just jump edges till it\\'s possible or you don\\'t have cycle and keep track of edges visited in a current run."
                    },
                    {
                        "username": "KiraCoder",
                        "content": "The LeetCode is killing me giving only BFS & DFS preblems in this week. "
                    }
                ]
            },
            {
                "id": 1844040,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nJust do a dfs traversal and keep a vis array. As each node can have at most 1 outgoing edge, it can be part of only one cycle.\n\nUse a map to store the length of reaching each node in a cycle, for each potential cycle create a new map. \n\nCalculate cycle length only when when you reach an already visited node.\n\nIf still confused and want to see the answer, refer to the leetcode editorial's first ans, I think they've explained it quite nicely"
                    },
                    {
                        "username": "rvamsi599",
                        "content": "Can anyone explain what is wrong with this code it is not even passing the first test case however when i run the same code  in my local machine with the given test case it is working but in leetcode it is throwing an error \\n`runtime error: addition of unsigned offset to 0x6030000000a0 overflowed to 0x603000000098 (stl_vector.h) `\\nfor the following code someone please try running this and please let me know what is the problem  \\uD83E\\uDD7A \\uD83E\\uDD7A \\uD83E\\uDD7A\\n`class Solution {\\npublic:\\n    int ans = -1;\\n    int longestCycle(vector<int>& edges) {\\n        int siz = edges.size();\\n        vector<int> dist(siz, -1);\\n        for(int i = 0; i < siz; i++){\\n            // if(dist[i] != -1) continue;\\n            cout << i;\\n            dfs(edges, dist, i, -1);\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(vector<int>& edges, vector<int>& dist, int node, int cdis){\\n        if(dist[node] != -1){\\n            int clen = cdis+1 - dist[node];\\n            ans = max(ans, clen);\\n            return;\\n        }\\n        dist[node] = cdis + 1;\\n        dfs(edges, dist, edges[node], cdis+1);\\n    }\\n    };`"
                    },
                    {
                        "username": "resurgence24",
                        "content": "Using ```Map<Integer, Integer> distance = new HashMap<>(); ``` gives AC solution but if I use ```int distance = new int[n]``` it is giving me TLE.\\n\\nCan anyone put light on this situation of mine? Pls... "
                    },
                    {
                        "username": "mrtriumpf",
                        "content": "same thing happened to me, as a fun thing - it didn't do TLE if i run the test case in isolation :)\n\nMaybe something to do with lots of mem allocations .\n\n I turned to another approach - to keep distance array created once, and keep another array to tell which starting node was used to analyze the cycle. \nonce you analyze cycle from node X and you see some other node Y already had been here - you stop"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The only hard thing in this question was me trying to find the hard part in the question."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "The longest cycle in the graph is the one cycle with the maximum length. :>"
                    },
                    {
                        "username": "HinaNarukami",
                        "content": "I tried to use DFS, but it turned out that this had a runtime error: load of null pointer of type \\'std::_Bit_type\\' (aka \\'unsigned long\\') (stl_bvector.h)\\nCan anyone explain the reason that my code didn\\'t work?\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    void dfs(int& count, int& ans, int node, vector<int>& edges, vector<bool>& vis, vector<int>& orders, vector<bool>& check){\\n        vis[node] = 1;\\n        orders[node] = count;\\n        count++;\\n        if(edges[node] == -1) return;\\n        if(vis[edges[node]] == 1){\\n            if(check[edges[node]] == 1) ans = max(ans, orders[node] - orders[edges[node]] + 1);\\n            memset(&check, 0, sizeof(check));\\n            count = 0;\\n        } else {\\n            check[node] = 1;\\n            dfs(count, ans, edges[node], edges, vis, orders, check);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> orders(n);\\n        int ans = -1;\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<bool> check(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]) dfs(count, ans, i, edges, vis, orders, check);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s hard. But we have been solving harder problems for last few days.. "
                    },
                    {
                        "username": "user8228j",
                        "content": "RIP to those who lose their streak due to leetcode outage"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had way more struggles with previous graph problems this month on Daily Challenge. Agreed with other person saying it should be medium level problem.\\nAs for people struggling with TLE, here\\'s a tip: you don\\'t need recursion to solve this. Just jump edges till it\\'s possible or you don\\'t have cycle and keep track of edges visited in a current run."
                    },
                    {
                        "username": "KiraCoder",
                        "content": "The LeetCode is killing me giving only BFS & DFS preblems in this week. "
                    }
                ]
            },
            {
                "id": 1843990,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nJust do a dfs traversal and keep a vis array. As each node can have at most 1 outgoing edge, it can be part of only one cycle.\n\nUse a map to store the length of reaching each node in a cycle, for each potential cycle create a new map. \n\nCalculate cycle length only when when you reach an already visited node.\n\nIf still confused and want to see the answer, refer to the leetcode editorial's first ans, I think they've explained it quite nicely"
                    },
                    {
                        "username": "rvamsi599",
                        "content": "Can anyone explain what is wrong with this code it is not even passing the first test case however when i run the same code  in my local machine with the given test case it is working but in leetcode it is throwing an error \\n`runtime error: addition of unsigned offset to 0x6030000000a0 overflowed to 0x603000000098 (stl_vector.h) `\\nfor the following code someone please try running this and please let me know what is the problem  \\uD83E\\uDD7A \\uD83E\\uDD7A \\uD83E\\uDD7A\\n`class Solution {\\npublic:\\n    int ans = -1;\\n    int longestCycle(vector<int>& edges) {\\n        int siz = edges.size();\\n        vector<int> dist(siz, -1);\\n        for(int i = 0; i < siz; i++){\\n            // if(dist[i] != -1) continue;\\n            cout << i;\\n            dfs(edges, dist, i, -1);\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(vector<int>& edges, vector<int>& dist, int node, int cdis){\\n        if(dist[node] != -1){\\n            int clen = cdis+1 - dist[node];\\n            ans = max(ans, clen);\\n            return;\\n        }\\n        dist[node] = cdis + 1;\\n        dfs(edges, dist, edges[node], cdis+1);\\n    }\\n    };`"
                    },
                    {
                        "username": "resurgence24",
                        "content": "Using ```Map<Integer, Integer> distance = new HashMap<>(); ``` gives AC solution but if I use ```int distance = new int[n]``` it is giving me TLE.\\n\\nCan anyone put light on this situation of mine? Pls... "
                    },
                    {
                        "username": "mrtriumpf",
                        "content": "same thing happened to me, as a fun thing - it didn't do TLE if i run the test case in isolation :)\n\nMaybe something to do with lots of mem allocations .\n\n I turned to another approach - to keep distance array created once, and keep another array to tell which starting node was used to analyze the cycle. \nonce you analyze cycle from node X and you see some other node Y already had been here - you stop"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The only hard thing in this question was me trying to find the hard part in the question."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "The longest cycle in the graph is the one cycle with the maximum length. :>"
                    },
                    {
                        "username": "HinaNarukami",
                        "content": "I tried to use DFS, but it turned out that this had a runtime error: load of null pointer of type \\'std::_Bit_type\\' (aka \\'unsigned long\\') (stl_bvector.h)\\nCan anyone explain the reason that my code didn\\'t work?\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    void dfs(int& count, int& ans, int node, vector<int>& edges, vector<bool>& vis, vector<int>& orders, vector<bool>& check){\\n        vis[node] = 1;\\n        orders[node] = count;\\n        count++;\\n        if(edges[node] == -1) return;\\n        if(vis[edges[node]] == 1){\\n            if(check[edges[node]] == 1) ans = max(ans, orders[node] - orders[edges[node]] + 1);\\n            memset(&check, 0, sizeof(check));\\n            count = 0;\\n        } else {\\n            check[node] = 1;\\n            dfs(count, ans, edges[node], edges, vis, orders, check);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> orders(n);\\n        int ans = -1;\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<bool> check(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]) dfs(count, ans, i, edges, vis, orders, check);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s hard. But we have been solving harder problems for last few days.. "
                    },
                    {
                        "username": "user8228j",
                        "content": "RIP to those who lose their streak due to leetcode outage"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had way more struggles with previous graph problems this month on Daily Challenge. Agreed with other person saying it should be medium level problem.\\nAs for people struggling with TLE, here\\'s a tip: you don\\'t need recursion to solve this. Just jump edges till it\\'s possible or you don\\'t have cycle and keep track of edges visited in a current run."
                    },
                    {
                        "username": "KiraCoder",
                        "content": "The LeetCode is killing me giving only BFS & DFS preblems in this week. "
                    }
                ]
            },
            {
                "id": 1843953,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nJust do a dfs traversal and keep a vis array. As each node can have at most 1 outgoing edge, it can be part of only one cycle.\n\nUse a map to store the length of reaching each node in a cycle, for each potential cycle create a new map. \n\nCalculate cycle length only when when you reach an already visited node.\n\nIf still confused and want to see the answer, refer to the leetcode editorial's first ans, I think they've explained it quite nicely"
                    },
                    {
                        "username": "rvamsi599",
                        "content": "Can anyone explain what is wrong with this code it is not even passing the first test case however when i run the same code  in my local machine with the given test case it is working but in leetcode it is throwing an error \\n`runtime error: addition of unsigned offset to 0x6030000000a0 overflowed to 0x603000000098 (stl_vector.h) `\\nfor the following code someone please try running this and please let me know what is the problem  \\uD83E\\uDD7A \\uD83E\\uDD7A \\uD83E\\uDD7A\\n`class Solution {\\npublic:\\n    int ans = -1;\\n    int longestCycle(vector<int>& edges) {\\n        int siz = edges.size();\\n        vector<int> dist(siz, -1);\\n        for(int i = 0; i < siz; i++){\\n            // if(dist[i] != -1) continue;\\n            cout << i;\\n            dfs(edges, dist, i, -1);\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(vector<int>& edges, vector<int>& dist, int node, int cdis){\\n        if(dist[node] != -1){\\n            int clen = cdis+1 - dist[node];\\n            ans = max(ans, clen);\\n            return;\\n        }\\n        dist[node] = cdis + 1;\\n        dfs(edges, dist, edges[node], cdis+1);\\n    }\\n    };`"
                    },
                    {
                        "username": "resurgence24",
                        "content": "Using ```Map<Integer, Integer> distance = new HashMap<>(); ``` gives AC solution but if I use ```int distance = new int[n]``` it is giving me TLE.\\n\\nCan anyone put light on this situation of mine? Pls... "
                    },
                    {
                        "username": "mrtriumpf",
                        "content": "same thing happened to me, as a fun thing - it didn't do TLE if i run the test case in isolation :)\n\nMaybe something to do with lots of mem allocations .\n\n I turned to another approach - to keep distance array created once, and keep another array to tell which starting node was used to analyze the cycle. \nonce you analyze cycle from node X and you see some other node Y already had been here - you stop"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The only hard thing in this question was me trying to find the hard part in the question."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "The longest cycle in the graph is the one cycle with the maximum length. :>"
                    },
                    {
                        "username": "HinaNarukami",
                        "content": "I tried to use DFS, but it turned out that this had a runtime error: load of null pointer of type \\'std::_Bit_type\\' (aka \\'unsigned long\\') (stl_bvector.h)\\nCan anyone explain the reason that my code didn\\'t work?\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    void dfs(int& count, int& ans, int node, vector<int>& edges, vector<bool>& vis, vector<int>& orders, vector<bool>& check){\\n        vis[node] = 1;\\n        orders[node] = count;\\n        count++;\\n        if(edges[node] == -1) return;\\n        if(vis[edges[node]] == 1){\\n            if(check[edges[node]] == 1) ans = max(ans, orders[node] - orders[edges[node]] + 1);\\n            memset(&check, 0, sizeof(check));\\n            count = 0;\\n        } else {\\n            check[node] = 1;\\n            dfs(count, ans, edges[node], edges, vis, orders, check);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> orders(n);\\n        int ans = -1;\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<bool> check(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]) dfs(count, ans, i, edges, vis, orders, check);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s hard. But we have been solving harder problems for last few days.. "
                    },
                    {
                        "username": "user8228j",
                        "content": "RIP to those who lose their streak due to leetcode outage"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had way more struggles with previous graph problems this month on Daily Challenge. Agreed with other person saying it should be medium level problem.\\nAs for people struggling with TLE, here\\'s a tip: you don\\'t need recursion to solve this. Just jump edges till it\\'s possible or you don\\'t have cycle and keep track of edges visited in a current run."
                    },
                    {
                        "username": "KiraCoder",
                        "content": "The LeetCode is killing me giving only BFS & DFS preblems in this week. "
                    }
                ]
            },
            {
                "id": 1843888,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nJust do a dfs traversal and keep a vis array. As each node can have at most 1 outgoing edge, it can be part of only one cycle.\n\nUse a map to store the length of reaching each node in a cycle, for each potential cycle create a new map. \n\nCalculate cycle length only when when you reach an already visited node.\n\nIf still confused and want to see the answer, refer to the leetcode editorial's first ans, I think they've explained it quite nicely"
                    },
                    {
                        "username": "rvamsi599",
                        "content": "Can anyone explain what is wrong with this code it is not even passing the first test case however when i run the same code  in my local machine with the given test case it is working but in leetcode it is throwing an error \\n`runtime error: addition of unsigned offset to 0x6030000000a0 overflowed to 0x603000000098 (stl_vector.h) `\\nfor the following code someone please try running this and please let me know what is the problem  \\uD83E\\uDD7A \\uD83E\\uDD7A \\uD83E\\uDD7A\\n`class Solution {\\npublic:\\n    int ans = -1;\\n    int longestCycle(vector<int>& edges) {\\n        int siz = edges.size();\\n        vector<int> dist(siz, -1);\\n        for(int i = 0; i < siz; i++){\\n            // if(dist[i] != -1) continue;\\n            cout << i;\\n            dfs(edges, dist, i, -1);\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(vector<int>& edges, vector<int>& dist, int node, int cdis){\\n        if(dist[node] != -1){\\n            int clen = cdis+1 - dist[node];\\n            ans = max(ans, clen);\\n            return;\\n        }\\n        dist[node] = cdis + 1;\\n        dfs(edges, dist, edges[node], cdis+1);\\n    }\\n    };`"
                    },
                    {
                        "username": "resurgence24",
                        "content": "Using ```Map<Integer, Integer> distance = new HashMap<>(); ``` gives AC solution but if I use ```int distance = new int[n]``` it is giving me TLE.\\n\\nCan anyone put light on this situation of mine? Pls... "
                    },
                    {
                        "username": "mrtriumpf",
                        "content": "same thing happened to me, as a fun thing - it didn't do TLE if i run the test case in isolation :)\n\nMaybe something to do with lots of mem allocations .\n\n I turned to another approach - to keep distance array created once, and keep another array to tell which starting node was used to analyze the cycle. \nonce you analyze cycle from node X and you see some other node Y already had been here - you stop"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The only hard thing in this question was me trying to find the hard part in the question."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "The longest cycle in the graph is the one cycle with the maximum length. :>"
                    },
                    {
                        "username": "HinaNarukami",
                        "content": "I tried to use DFS, but it turned out that this had a runtime error: load of null pointer of type \\'std::_Bit_type\\' (aka \\'unsigned long\\') (stl_bvector.h)\\nCan anyone explain the reason that my code didn\\'t work?\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    void dfs(int& count, int& ans, int node, vector<int>& edges, vector<bool>& vis, vector<int>& orders, vector<bool>& check){\\n        vis[node] = 1;\\n        orders[node] = count;\\n        count++;\\n        if(edges[node] == -1) return;\\n        if(vis[edges[node]] == 1){\\n            if(check[edges[node]] == 1) ans = max(ans, orders[node] - orders[edges[node]] + 1);\\n            memset(&check, 0, sizeof(check));\\n            count = 0;\\n        } else {\\n            check[node] = 1;\\n            dfs(count, ans, edges[node], edges, vis, orders, check);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> orders(n);\\n        int ans = -1;\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<bool> check(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]) dfs(count, ans, i, edges, vis, orders, check);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s hard. But we have been solving harder problems for last few days.. "
                    },
                    {
                        "username": "user8228j",
                        "content": "RIP to those who lose their streak due to leetcode outage"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had way more struggles with previous graph problems this month on Daily Challenge. Agreed with other person saying it should be medium level problem.\\nAs for people struggling with TLE, here\\'s a tip: you don\\'t need recursion to solve this. Just jump edges till it\\'s possible or you don\\'t have cycle and keep track of edges visited in a current run."
                    },
                    {
                        "username": "KiraCoder",
                        "content": "The LeetCode is killing me giving only BFS & DFS preblems in this week. "
                    }
                ]
            },
            {
                "id": 1843881,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nJust do a dfs traversal and keep a vis array. As each node can have at most 1 outgoing edge, it can be part of only one cycle.\n\nUse a map to store the length of reaching each node in a cycle, for each potential cycle create a new map. \n\nCalculate cycle length only when when you reach an already visited node.\n\nIf still confused and want to see the answer, refer to the leetcode editorial's first ans, I think they've explained it quite nicely"
                    },
                    {
                        "username": "rvamsi599",
                        "content": "Can anyone explain what is wrong with this code it is not even passing the first test case however when i run the same code  in my local machine with the given test case it is working but in leetcode it is throwing an error \\n`runtime error: addition of unsigned offset to 0x6030000000a0 overflowed to 0x603000000098 (stl_vector.h) `\\nfor the following code someone please try running this and please let me know what is the problem  \\uD83E\\uDD7A \\uD83E\\uDD7A \\uD83E\\uDD7A\\n`class Solution {\\npublic:\\n    int ans = -1;\\n    int longestCycle(vector<int>& edges) {\\n        int siz = edges.size();\\n        vector<int> dist(siz, -1);\\n        for(int i = 0; i < siz; i++){\\n            // if(dist[i] != -1) continue;\\n            cout << i;\\n            dfs(edges, dist, i, -1);\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(vector<int>& edges, vector<int>& dist, int node, int cdis){\\n        if(dist[node] != -1){\\n            int clen = cdis+1 - dist[node];\\n            ans = max(ans, clen);\\n            return;\\n        }\\n        dist[node] = cdis + 1;\\n        dfs(edges, dist, edges[node], cdis+1);\\n    }\\n    };`"
                    },
                    {
                        "username": "resurgence24",
                        "content": "Using ```Map<Integer, Integer> distance = new HashMap<>(); ``` gives AC solution but if I use ```int distance = new int[n]``` it is giving me TLE.\\n\\nCan anyone put light on this situation of mine? Pls... "
                    },
                    {
                        "username": "mrtriumpf",
                        "content": "same thing happened to me, as a fun thing - it didn't do TLE if i run the test case in isolation :)\n\nMaybe something to do with lots of mem allocations .\n\n I turned to another approach - to keep distance array created once, and keep another array to tell which starting node was used to analyze the cycle. \nonce you analyze cycle from node X and you see some other node Y already had been here - you stop"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The only hard thing in this question was me trying to find the hard part in the question."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "The longest cycle in the graph is the one cycle with the maximum length. :>"
                    },
                    {
                        "username": "HinaNarukami",
                        "content": "I tried to use DFS, but it turned out that this had a runtime error: load of null pointer of type \\'std::_Bit_type\\' (aka \\'unsigned long\\') (stl_bvector.h)\\nCan anyone explain the reason that my code didn\\'t work?\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    void dfs(int& count, int& ans, int node, vector<int>& edges, vector<bool>& vis, vector<int>& orders, vector<bool>& check){\\n        vis[node] = 1;\\n        orders[node] = count;\\n        count++;\\n        if(edges[node] == -1) return;\\n        if(vis[edges[node]] == 1){\\n            if(check[edges[node]] == 1) ans = max(ans, orders[node] - orders[edges[node]] + 1);\\n            memset(&check, 0, sizeof(check));\\n            count = 0;\\n        } else {\\n            check[node] = 1;\\n            dfs(count, ans, edges[node], edges, vis, orders, check);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> orders(n);\\n        int ans = -1;\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<bool> check(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]) dfs(count, ans, i, edges, vis, orders, check);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s hard. But we have been solving harder problems for last few days.. "
                    },
                    {
                        "username": "user8228j",
                        "content": "RIP to those who lose their streak due to leetcode outage"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had way more struggles with previous graph problems this month on Daily Challenge. Agreed with other person saying it should be medium level problem.\\nAs for people struggling with TLE, here\\'s a tip: you don\\'t need recursion to solve this. Just jump edges till it\\'s possible or you don\\'t have cycle and keep track of edges visited in a current run."
                    },
                    {
                        "username": "KiraCoder",
                        "content": "The LeetCode is killing me giving only BFS & DFS preblems in this week. "
                    }
                ]
            },
            {
                "id": 1843834,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nJust do a dfs traversal and keep a vis array. As each node can have at most 1 outgoing edge, it can be part of only one cycle.\n\nUse a map to store the length of reaching each node in a cycle, for each potential cycle create a new map. \n\nCalculate cycle length only when when you reach an already visited node.\n\nIf still confused and want to see the answer, refer to the leetcode editorial's first ans, I think they've explained it quite nicely"
                    },
                    {
                        "username": "rvamsi599",
                        "content": "Can anyone explain what is wrong with this code it is not even passing the first test case however when i run the same code  in my local machine with the given test case it is working but in leetcode it is throwing an error \\n`runtime error: addition of unsigned offset to 0x6030000000a0 overflowed to 0x603000000098 (stl_vector.h) `\\nfor the following code someone please try running this and please let me know what is the problem  \\uD83E\\uDD7A \\uD83E\\uDD7A \\uD83E\\uDD7A\\n`class Solution {\\npublic:\\n    int ans = -1;\\n    int longestCycle(vector<int>& edges) {\\n        int siz = edges.size();\\n        vector<int> dist(siz, -1);\\n        for(int i = 0; i < siz; i++){\\n            // if(dist[i] != -1) continue;\\n            cout << i;\\n            dfs(edges, dist, i, -1);\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(vector<int>& edges, vector<int>& dist, int node, int cdis){\\n        if(dist[node] != -1){\\n            int clen = cdis+1 - dist[node];\\n            ans = max(ans, clen);\\n            return;\\n        }\\n        dist[node] = cdis + 1;\\n        dfs(edges, dist, edges[node], cdis+1);\\n    }\\n    };`"
                    },
                    {
                        "username": "resurgence24",
                        "content": "Using ```Map<Integer, Integer> distance = new HashMap<>(); ``` gives AC solution but if I use ```int distance = new int[n]``` it is giving me TLE.\\n\\nCan anyone put light on this situation of mine? Pls... "
                    },
                    {
                        "username": "mrtriumpf",
                        "content": "same thing happened to me, as a fun thing - it didn't do TLE if i run the test case in isolation :)\n\nMaybe something to do with lots of mem allocations .\n\n I turned to another approach - to keep distance array created once, and keep another array to tell which starting node was used to analyze the cycle. \nonce you analyze cycle from node X and you see some other node Y already had been here - you stop"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The only hard thing in this question was me trying to find the hard part in the question."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "The longest cycle in the graph is the one cycle with the maximum length. :>"
                    },
                    {
                        "username": "HinaNarukami",
                        "content": "I tried to use DFS, but it turned out that this had a runtime error: load of null pointer of type \\'std::_Bit_type\\' (aka \\'unsigned long\\') (stl_bvector.h)\\nCan anyone explain the reason that my code didn\\'t work?\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    void dfs(int& count, int& ans, int node, vector<int>& edges, vector<bool>& vis, vector<int>& orders, vector<bool>& check){\\n        vis[node] = 1;\\n        orders[node] = count;\\n        count++;\\n        if(edges[node] == -1) return;\\n        if(vis[edges[node]] == 1){\\n            if(check[edges[node]] == 1) ans = max(ans, orders[node] - orders[edges[node]] + 1);\\n            memset(&check, 0, sizeof(check));\\n            count = 0;\\n        } else {\\n            check[node] = 1;\\n            dfs(count, ans, edges[node], edges, vis, orders, check);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> orders(n);\\n        int ans = -1;\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<bool> check(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]) dfs(count, ans, i, edges, vis, orders, check);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s hard. But we have been solving harder problems for last few days.. "
                    },
                    {
                        "username": "user8228j",
                        "content": "RIP to those who lose their streak due to leetcode outage"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had way more struggles with previous graph problems this month on Daily Challenge. Agreed with other person saying it should be medium level problem.\\nAs for people struggling with TLE, here\\'s a tip: you don\\'t need recursion to solve this. Just jump edges till it\\'s possible or you don\\'t have cycle and keep track of edges visited in a current run."
                    },
                    {
                        "username": "KiraCoder",
                        "content": "The LeetCode is killing me giving only BFS & DFS preblems in this week. "
                    }
                ]
            },
            {
                "id": 1843820,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nJust do a dfs traversal and keep a vis array. As each node can have at most 1 outgoing edge, it can be part of only one cycle.\n\nUse a map to store the length of reaching each node in a cycle, for each potential cycle create a new map. \n\nCalculate cycle length only when when you reach an already visited node.\n\nIf still confused and want to see the answer, refer to the leetcode editorial's first ans, I think they've explained it quite nicely"
                    },
                    {
                        "username": "rvamsi599",
                        "content": "Can anyone explain what is wrong with this code it is not even passing the first test case however when i run the same code  in my local machine with the given test case it is working but in leetcode it is throwing an error \\n`runtime error: addition of unsigned offset to 0x6030000000a0 overflowed to 0x603000000098 (stl_vector.h) `\\nfor the following code someone please try running this and please let me know what is the problem  \\uD83E\\uDD7A \\uD83E\\uDD7A \\uD83E\\uDD7A\\n`class Solution {\\npublic:\\n    int ans = -1;\\n    int longestCycle(vector<int>& edges) {\\n        int siz = edges.size();\\n        vector<int> dist(siz, -1);\\n        for(int i = 0; i < siz; i++){\\n            // if(dist[i] != -1) continue;\\n            cout << i;\\n            dfs(edges, dist, i, -1);\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(vector<int>& edges, vector<int>& dist, int node, int cdis){\\n        if(dist[node] != -1){\\n            int clen = cdis+1 - dist[node];\\n            ans = max(ans, clen);\\n            return;\\n        }\\n        dist[node] = cdis + 1;\\n        dfs(edges, dist, edges[node], cdis+1);\\n    }\\n    };`"
                    },
                    {
                        "username": "resurgence24",
                        "content": "Using ```Map<Integer, Integer> distance = new HashMap<>(); ``` gives AC solution but if I use ```int distance = new int[n]``` it is giving me TLE.\\n\\nCan anyone put light on this situation of mine? Pls... "
                    },
                    {
                        "username": "mrtriumpf",
                        "content": "same thing happened to me, as a fun thing - it didn't do TLE if i run the test case in isolation :)\n\nMaybe something to do with lots of mem allocations .\n\n I turned to another approach - to keep distance array created once, and keep another array to tell which starting node was used to analyze the cycle. \nonce you analyze cycle from node X and you see some other node Y already had been here - you stop"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The only hard thing in this question was me trying to find the hard part in the question."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "The longest cycle in the graph is the one cycle with the maximum length. :>"
                    },
                    {
                        "username": "HinaNarukami",
                        "content": "I tried to use DFS, but it turned out that this had a runtime error: load of null pointer of type \\'std::_Bit_type\\' (aka \\'unsigned long\\') (stl_bvector.h)\\nCan anyone explain the reason that my code didn\\'t work?\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    void dfs(int& count, int& ans, int node, vector<int>& edges, vector<bool>& vis, vector<int>& orders, vector<bool>& check){\\n        vis[node] = 1;\\n        orders[node] = count;\\n        count++;\\n        if(edges[node] == -1) return;\\n        if(vis[edges[node]] == 1){\\n            if(check[edges[node]] == 1) ans = max(ans, orders[node] - orders[edges[node]] + 1);\\n            memset(&check, 0, sizeof(check));\\n            count = 0;\\n        } else {\\n            check[node] = 1;\\n            dfs(count, ans, edges[node], edges, vis, orders, check);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> orders(n);\\n        int ans = -1;\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<bool> check(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]) dfs(count, ans, i, edges, vis, orders, check);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s hard. But we have been solving harder problems for last few days.. "
                    },
                    {
                        "username": "user8228j",
                        "content": "RIP to those who lose their streak due to leetcode outage"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had way more struggles with previous graph problems this month on Daily Challenge. Agreed with other person saying it should be medium level problem.\\nAs for people struggling with TLE, here\\'s a tip: you don\\'t need recursion to solve this. Just jump edges till it\\'s possible or you don\\'t have cycle and keep track of edges visited in a current run."
                    },
                    {
                        "username": "KiraCoder",
                        "content": "The LeetCode is killing me giving only BFS & DFS preblems in this week. "
                    }
                ]
            },
            {
                "id": 1843804,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nJust do a dfs traversal and keep a vis array. As each node can have at most 1 outgoing edge, it can be part of only one cycle.\n\nUse a map to store the length of reaching each node in a cycle, for each potential cycle create a new map. \n\nCalculate cycle length only when when you reach an already visited node.\n\nIf still confused and want to see the answer, refer to the leetcode editorial's first ans, I think they've explained it quite nicely"
                    },
                    {
                        "username": "rvamsi599",
                        "content": "Can anyone explain what is wrong with this code it is not even passing the first test case however when i run the same code  in my local machine with the given test case it is working but in leetcode it is throwing an error \\n`runtime error: addition of unsigned offset to 0x6030000000a0 overflowed to 0x603000000098 (stl_vector.h) `\\nfor the following code someone please try running this and please let me know what is the problem  \\uD83E\\uDD7A \\uD83E\\uDD7A \\uD83E\\uDD7A\\n`class Solution {\\npublic:\\n    int ans = -1;\\n    int longestCycle(vector<int>& edges) {\\n        int siz = edges.size();\\n        vector<int> dist(siz, -1);\\n        for(int i = 0; i < siz; i++){\\n            // if(dist[i] != -1) continue;\\n            cout << i;\\n            dfs(edges, dist, i, -1);\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(vector<int>& edges, vector<int>& dist, int node, int cdis){\\n        if(dist[node] != -1){\\n            int clen = cdis+1 - dist[node];\\n            ans = max(ans, clen);\\n            return;\\n        }\\n        dist[node] = cdis + 1;\\n        dfs(edges, dist, edges[node], cdis+1);\\n    }\\n    };`"
                    },
                    {
                        "username": "resurgence24",
                        "content": "Using ```Map<Integer, Integer> distance = new HashMap<>(); ``` gives AC solution but if I use ```int distance = new int[n]``` it is giving me TLE.\\n\\nCan anyone put light on this situation of mine? Pls... "
                    },
                    {
                        "username": "mrtriumpf",
                        "content": "same thing happened to me, as a fun thing - it didn't do TLE if i run the test case in isolation :)\n\nMaybe something to do with lots of mem allocations .\n\n I turned to another approach - to keep distance array created once, and keep another array to tell which starting node was used to analyze the cycle. \nonce you analyze cycle from node X and you see some other node Y already had been here - you stop"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The only hard thing in this question was me trying to find the hard part in the question."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "The longest cycle in the graph is the one cycle with the maximum length. :>"
                    },
                    {
                        "username": "HinaNarukami",
                        "content": "I tried to use DFS, but it turned out that this had a runtime error: load of null pointer of type \\'std::_Bit_type\\' (aka \\'unsigned long\\') (stl_bvector.h)\\nCan anyone explain the reason that my code didn\\'t work?\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    void dfs(int& count, int& ans, int node, vector<int>& edges, vector<bool>& vis, vector<int>& orders, vector<bool>& check){\\n        vis[node] = 1;\\n        orders[node] = count;\\n        count++;\\n        if(edges[node] == -1) return;\\n        if(vis[edges[node]] == 1){\\n            if(check[edges[node]] == 1) ans = max(ans, orders[node] - orders[edges[node]] + 1);\\n            memset(&check, 0, sizeof(check));\\n            count = 0;\\n        } else {\\n            check[node] = 1;\\n            dfs(count, ans, edges[node], edges, vis, orders, check);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> orders(n);\\n        int ans = -1;\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<bool> check(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]) dfs(count, ans, i, edges, vis, orders, check);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s hard. But we have been solving harder problems for last few days.. "
                    },
                    {
                        "username": "user8228j",
                        "content": "RIP to those who lose their streak due to leetcode outage"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had way more struggles with previous graph problems this month on Daily Challenge. Agreed with other person saying it should be medium level problem.\\nAs for people struggling with TLE, here\\'s a tip: you don\\'t need recursion to solve this. Just jump edges till it\\'s possible or you don\\'t have cycle and keep track of edges visited in a current run."
                    },
                    {
                        "username": "KiraCoder",
                        "content": "The LeetCode is killing me giving only BFS & DFS preblems in this week. "
                    }
                ]
            },
            {
                "id": 1843656,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Some tips:-\n\nJust do a dfs traversal and keep a vis array. As each node can have at most 1 outgoing edge, it can be part of only one cycle.\n\nUse a map to store the length of reaching each node in a cycle, for each potential cycle create a new map. \n\nCalculate cycle length only when when you reach an already visited node.\n\nIf still confused and want to see the answer, refer to the leetcode editorial's first ans, I think they've explained it quite nicely"
                    },
                    {
                        "username": "rvamsi599",
                        "content": "Can anyone explain what is wrong with this code it is not even passing the first test case however when i run the same code  in my local machine with the given test case it is working but in leetcode it is throwing an error \\n`runtime error: addition of unsigned offset to 0x6030000000a0 overflowed to 0x603000000098 (stl_vector.h) `\\nfor the following code someone please try running this and please let me know what is the problem  \\uD83E\\uDD7A \\uD83E\\uDD7A \\uD83E\\uDD7A\\n`class Solution {\\npublic:\\n    int ans = -1;\\n    int longestCycle(vector<int>& edges) {\\n        int siz = edges.size();\\n        vector<int> dist(siz, -1);\\n        for(int i = 0; i < siz; i++){\\n            // if(dist[i] != -1) continue;\\n            cout << i;\\n            dfs(edges, dist, i, -1);\\n        }\\n        return ans;\\n    }\\n\\n    void dfs(vector<int>& edges, vector<int>& dist, int node, int cdis){\\n        if(dist[node] != -1){\\n            int clen = cdis+1 - dist[node];\\n            ans = max(ans, clen);\\n            return;\\n        }\\n        dist[node] = cdis + 1;\\n        dfs(edges, dist, edges[node], cdis+1);\\n    }\\n    };`"
                    },
                    {
                        "username": "resurgence24",
                        "content": "Using ```Map<Integer, Integer> distance = new HashMap<>(); ``` gives AC solution but if I use ```int distance = new int[n]``` it is giving me TLE.\\n\\nCan anyone put light on this situation of mine? Pls... "
                    },
                    {
                        "username": "mrtriumpf",
                        "content": "same thing happened to me, as a fun thing - it didn't do TLE if i run the test case in isolation :)\n\nMaybe something to do with lots of mem allocations .\n\n I turned to another approach - to keep distance array created once, and keep another array to tell which starting node was used to analyze the cycle. \nonce you analyze cycle from node X and you see some other node Y already had been here - you stop"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "The only hard thing in this question was me trying to find the hard part in the question."
                    },
                    {
                        "username": "dankCoder007",
                        "content": "The longest cycle in the graph is the one cycle with the maximum length. :>"
                    },
                    {
                        "username": "HinaNarukami",
                        "content": "I tried to use DFS, but it turned out that this had a runtime error: load of null pointer of type \\'std::_Bit_type\\' (aka \\'unsigned long\\') (stl_bvector.h)\\nCan anyone explain the reason that my code didn\\'t work?\\nMy code:\\n```\\nclass Solution {\\npublic:\\n    void dfs(int& count, int& ans, int node, vector<int>& edges, vector<bool>& vis, vector<int>& orders, vector<bool>& check){\\n        vis[node] = 1;\\n        orders[node] = count;\\n        count++;\\n        if(edges[node] == -1) return;\\n        if(vis[edges[node]] == 1){\\n            if(check[edges[node]] == 1) ans = max(ans, orders[node] - orders[edges[node]] + 1);\\n            memset(&check, 0, sizeof(check));\\n            count = 0;\\n        } else {\\n            check[node] = 1;\\n            dfs(count, ans, edges[node], edges, vis, orders, check);\\n        }\\n    }\\n    int longestCycle(vector<int>& edges) {\\n        int n = edges.size();\\n        vector<int> orders(n);\\n        int ans = -1;\\n        int count = 0;\\n        vector<bool> vis(n, 0);\\n        vector<bool> check(n, 0);\\n        for(int i = 0; i < n; i++){\\n            if(!vis[i]) dfs(count, ans, i, edges, vis, orders, check);\\n        }\\n        return ans;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It\\'s hard. But we have been solving harder problems for last few days.. "
                    },
                    {
                        "username": "user8228j",
                        "content": "RIP to those who lose their streak due to leetcode outage"
                    },
                    {
                        "username": "x-ider",
                        "content": "I had way more struggles with previous graph problems this month on Daily Challenge. Agreed with other person saying it should be medium level problem.\\nAs for people struggling with TLE, here\\'s a tip: you don\\'t need recursion to solve this. Just jump edges till it\\'s possible or you don\\'t have cycle and keep track of edges visited in a current run."
                    },
                    {
                        "username": "KiraCoder",
                        "content": "The LeetCode is killing me giving only BFS & DFS preblems in this week. "
                    }
                ]
            }
        ]
    }
]