[
    {
        "title": "Diet Plan Performance",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566124,
                "content": [
                    {
                        "username": "simonzhu91",
                        "content": "Isn\\'t it a bad diet if they consume `T > upper` calories? :P"
                    },
                    {
                        "username": "Noah492",
                        "content": "Gotta bulk up bro"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Why did people dislike this problem? Looks interesting to me at least. "
                    },
                    {
                        "username": "djslim",
                        "content": "Because it\\'s about bulking diet, not weight loss and it confuses a lot \\uD83E\\uDD23"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Notice k is a fixed value. Can we try sliding window? :)"
                    }
                ]
            },
            {
                "id": 1777219,
                "content": [
                    {
                        "username": "simonzhu91",
                        "content": "Isn\\'t it a bad diet if they consume `T > upper` calories? :P"
                    },
                    {
                        "username": "Noah492",
                        "content": "Gotta bulk up bro"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Why did people dislike this problem? Looks interesting to me at least. "
                    },
                    {
                        "username": "djslim",
                        "content": "Because it\\'s about bulking diet, not weight loss and it confuses a lot \\uD83E\\uDD23"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Notice k is a fixed value. Can we try sliding window? :)"
                    }
                ]
            },
            {
                "id": 1732285,
                "content": [
                    {
                        "username": "simonzhu91",
                        "content": "Isn\\'t it a bad diet if they consume `T > upper` calories? :P"
                    },
                    {
                        "username": "Noah492",
                        "content": "Gotta bulk up bro"
                    },
                    {
                        "username": "vmikhieienko",
                        "content": "Why did people dislike this problem? Looks interesting to me at least. "
                    },
                    {
                        "username": "djslim",
                        "content": "Because it\\'s about bulking diet, not weight loss and it confuses a lot \\uD83E\\uDD23"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Notice k is a fixed value. Can we try sliding window? :)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Can Make Palindrome from Substring",
        "question_content": "<p>You are given a string <code>s</code> and array <code>queries</code> where <code>queries[i] = [left<sub>i</sub>, right<sub>i</sub>, k<sub>i</sub>]</code>. We may rearrange the substring <code>s[left<sub>i</sub>...right<sub>i</sub>]</code> for each query and then choose up to <code>k<sub>i</sub></code> of them to replace with any lowercase English letter.</p>\n\n<p>If the substring is possible to be a palindrome string after the operations above, the result of the query is <code>true</code>. Otherwise, the result is <code>false</code>.</p>\n\n<p>Return a boolean array <code>answer</code> where <code>answer[i]</code> is the result of the <code>i<sup>th</sup></code> query <code>queries[i]</code>.</p>\n\n<p>Note that each letter is counted individually for replacement, so if, for example <code>s[left<sub>i</sub>...right<sub>i</sub>] = &quot;aaa&quot;</code>, and <code>k<sub>i</sub> = 2</code>, we can only replace two of the letters. Also, note that no query modifies the initial string <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example :</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]\n<strong>Output:</strong> [true,false,false,true,true]\n<strong>Explanation:</strong>\nqueries[0]: substring = &quot;d&quot;, is palidrome.\nqueries[1]: substring = &quot;bc&quot;, is not palidrome.\nqueries[2]: substring = &quot;abcd&quot;, is not palidrome after replacing only 1 character.\nqueries[3]: substring = &quot;abcd&quot;, could be changed to &quot;abba&quot; which is palidrome. Also this can be changed to &quot;baab&quot; first rearrange it &quot;bacd&quot; then replace &quot;cd&quot; with &quot;ab&quot;.\nqueries[4]: substring = &quot;abcda&quot;, could be changed to &quot;abcba&quot; which is palidrome.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;lyb&quot;, queries = [[0,1,0],[2,2,1]]\n<strong>Output:</strong> [false,true]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt; s.length</code></li>\n\t<li><code>0 &lt;= k<sub>i</sub> &lt;= s.length</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 371999,
                "title": "python-100-runtime-and-memory",
                "content": "First, the key is understanding we are allowed to *rearrange*. Knowing this, we can forget about order and only count the occurences of each letter.\\nFurthermore, we only care if the count is odd. If it\\'s even, we can place an equal amount of letter on either side:\\n`\\'aaaac\\'` => `\\'aacaa\\'`\\nSince `\\'a\\'`\\'s count is even (4), we can ignore it.\\n\\nIn order to convert a string to a palindrome using replace, we need only to replace half of the letters. For example,\\n`\\'abcd\\'` => `\\'abba\\'` (4 // 2 = 2)\\n`\\'abcde\\'` => `\\'abcba\\'` (5 // 2 = 2)\\nHence, we only need `k` to be at least half rounded down.\\n\\nNaively, we can use `collections.Counter()` to count the letters in the substring, check how many are odd, divide that by 2 (rounded down) and check `<= k`.\\n\\n```\\n  def canMakePaliQueries(s, queries):\\n      ans = []\\n      for l, r, k in queries:\\n          ss = s[l:r+1]\\n          rem = 0\\n          for letter, n in collections.Counter(ss).items():\\n              rem += n % 2\\n          need = rem // 2\\n          ans.append(need <= k)\\n      return ans\\n```\\n\\nHowever, we are counting letters for **every** substring, which may overlap with previous calculations. This solution gives Time Limit Exceeded.\\n\\nTherefore, we can optimize by caching previous results. We can say `dp[i]` represents the count of all the letters in `s[:i]`. Then we know that the counts of `dp[l]` subtracted from `dp[r+1]` will give us the count of all the letters in the substring `s[l:r+1]`. We could naively store them all in `collections.Counter()`:\\n\\n```\\n  def canMakePaliQueries(s, queries):\\n      dp = [collections.Counter()]\\n      for i in range(1, len(s)+1):\\n          dp.append(dp[i-1] + collections.Counter(s[i-1]))\\n      ans = []\\n      for l, r, k in queries:\\n          c = dp[r+1] - dp[l]\\n          need = sum(v % 2 for v in c.values()) // 2\\n          ans.append(need <= k)\\n      return ans\\n```\\n\\nHowever, the overhead is too great. This solution still gives Time Limit Exceeded. We can simplify by realizing we only care about lowercase letters, 26 in total. We can store our data in an array of size 26 for each substring:\\n\\n```\\n  def canMakePaliQueries(s, queries):\\n      N = 26\\n      a = ord(\\'a\\')\\n      dp = [[0] * N]\\n      for i in range(1, len(s)+1):\\n          new = dp[i-1][:]\\n          j = ord(s[i-1]) - a\\n          new[j] += 1\\n          dp.append(new)\\n      ans = []\\n      for l, r, k in queries:\\n          L = dp[l]\\n          R = dp[r+1]\\n          ans.append(sum((R[i] - L[i]) & 1 for i in range(N)) // 2 <= k)\\n      return ans\\n```\\n\\nThis solution is accepted!\\n\\nFurthermore, observe that once we subtract the sums we are only looking at `& 1` (the last bit) to see if it\\'s odd or even. Therefore, we only need to store binary values of either `0` or `1` in the first place. Thus we make our final optimization by storing the count of the letters in a single 32-bit integer, since we only need to use 26 bits. Then we can XOR the substrings\\' counts to get the difference. Then we can count the number of `1` bits to know how many letters need to be changed.\\n\\nFinal solution:\\n\\n```\\ndef canMakePaliQueries(s, queries):\\n    N = 26\\n    S = len(s) + 1\\n    ints = list(map(lambda c: ord(c) - ord(\\'a\\'), s))\\n\\n    dp = [0] * S\\n    for i in range(1, S):\\n        dp[i] = dp[i-1] ^ (1 << ints[i-1])\\n\\n    ones = lambda x: bin(x).count(\\'1\\')\\n    return [\\n        ones(dp[r+1] ^ dp[l]) >> 1 <= k\\n        for l, r, k in queries\\n    ]\\n```",
                "solutionTags": [],
                "code": "```\\n  def canMakePaliQueries(s, queries):\\n      ans = []\\n      for l, r, k in queries:\\n          ss = s[l:r+1]\\n          rem = 0\\n          for letter, n in collections.Counter(ss).items():\\n              rem += n % 2\\n          need = rem // 2\\n          ans.append(need <= k)\\n      return ans\\n```\n```\\n  def canMakePaliQueries(s, queries):\\n      dp = [collections.Counter()]\\n      for i in range(1, len(s)+1):\\n          dp.append(dp[i-1] + collections.Counter(s[i-1]))\\n      ans = []\\n      for l, r, k in queries:\\n          c = dp[r+1] - dp[l]\\n          need = sum(v % 2 for v in c.values()) // 2\\n          ans.append(need <= k)\\n      return ans\\n```\n```\\n  def canMakePaliQueries(s, queries):\\n      N = 26\\n      a = ord(\\'a\\')\\n      dp = [[0] * N]\\n      for i in range(1, len(s)+1):\\n          new = dp[i-1][:]\\n          j = ord(s[i-1]) - a\\n          new[j] += 1\\n          dp.append(new)\\n      ans = []\\n      for l, r, k in queries:\\n          L = dp[l]\\n          R = dp[r+1]\\n          ans.append(sum((R[i] - L[i]) & 1 for i in range(N)) // 2 <= k)\\n      return ans\\n```\n```\\ndef canMakePaliQueries(s, queries):\\n    N = 26\\n    S = len(s) + 1\\n    ints = list(map(lambda c: ord(c) - ord(\\'a\\'), s))\\n\\n    dp = [0] * S\\n    for i in range(1, S):\\n        dp[i] = dp[i-1] ^ (1 << ints[i-1])\\n\\n    ones = lambda x: bin(x).count(\\'1\\')\\n    return [\\n        ones(dp[r+1] ^ dp[l]) >> 1 <= k\\n        for l, r, k in queries\\n    ]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 371849,
                "title": "java-python-3-3-codes-each-prefix-sum-boolean-and-xor-of-characters-frequencies-then-compare",
                "content": "\\nAccording to the description and examples, we can deduce that the `rearrange` implies the input string `s` can be changed to any sequence to get `close` to a palindrome. Here `close` means least times of replacement of chars needed to become a palindrome after `rearranging` of `s`.\\n\\nObviously, any two same chars can be `rearranged` to be symmetric part of a palindrome, only the odd count of the chars we need to care. Therefore, when looping through the String `s`, we need to know if the count of each char in any prefix of the stirng `s` is odd or not by computing the corrsponding prefix sum, then the same information can be obtained for substring between any two given indices `i` and `j` by `prefixSum[j] - prefixSum[i]`. \\nSum those chars with odd number of occurrences, and we only need to replace half of them to make all in symmetric pairs. \\n\\ne.g.,\\n\\nIf we want to make palindrome from `s = \"abbcccddddeeeee\"`: \\nIn `\"abbcccddddeeeee\"`, `a, b, c, d, and e` occur `1, 2, 3, 4, and 5` times, respectively. Among them, `a, c and e` occur `1, 3, and 5` times.\\n\\nWe can easily rearrange `2 b\\'s, 2c\\'s, 4 d\\'s and 4 e\\'s` to a palindrome: `bcddeeeeddcb`. Now only odd number occurrence chars `a, c, and e` remaining, and we can place 1 of them, say, `e`, to the center of the palindrome, and replace either `a` to `c`, or `c` to `a` to complete the conversion of `s` to a palindrome: `c -> a: abcddeeeeeddcba` or `a -> c: bccddeeeeddccb`. \\n\\nIn short, at least need `3 / 2 = 1` replacement: `3` odd number occurrence of chars `a, c, and e` divide by `2` equals to `1`\\n\\nHere is the brief description of my algorithm:\\n\\n1. Compute the prefix sum by counting the number of chars in `substring(0,1), substring(0, 2), ..., substring(0,n)`;\\n2. Use the difference of the prefix sums to get the the number of chars in `substring(queries[i][0], queries[i][1])`, count those do NOT in symmetric pairs, divided by 2, and compare it with `queries[i][2]`.\\n\\n**Method 1: prefix sum - count each char**\\n\\n**Java**\\n```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> ans = new ArrayList<>(); \\n        int[][] cnt = new int[s.length() + 1][26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            cnt[i + 1] = cnt[i].clone(); // copy previous sum.\\n            ++cnt[i + 1][s.charAt(i) - \\'a\\'];\\n        }\\n        for (int[] q : queries) {\\n            int sum = 0; \\n            for (int i = 0; i < 26; ++i) {\\n                sum += (cnt[q[1] + 1][i] - cnt[q[0]][i]) % 2;\\n            }\\n            ans.add(sum / 2 <= q[2]);\\n        }\\n        return ans;\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\n```\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        cnt = [[0] * 26]\\n        for i, c in enumerate(s):\\n            cnt.append(cnt[i][:])\\n            cnt[i + 1][ord(c) - ord(\\'a\\')] += 1\\n        return [sum((cnt[hi + 1][i] - cnt[lo][i]) % 2 for i in range(26)) // 2 <= k for lo, hi, k in queries]\\n```\\n\\n----\\n\\n**Method 2: prefix boolean - use true/false to mark odd/even of the count of each char, credit to @mfboulos**\\n\\n**Java**\\n```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> ans = new ArrayList<>(); \\n        boolean[][] odds = new boolean[s.length() + 1][26]; // odds[i][j]: within range [0...i) of s, if the count of (char)(j + \\'a) is odd. \\n        for (int i = 0; i < s.length(); ++i) {\\n            odds[i + 1] = odds[i].clone();\\n            odds[i + 1][s.charAt(i) - \\'a\\'] ^= true;\\n        }\\n        for (int[] q : queries) {\\n            int sum = 0; \\n            for (int i = 0; i < 26; ++i) {\\n                sum += (odds[q[1] + 1][i] ^ odds[q[0]][i]) ? 1 : 0; // if the count of (char)(i + \\'a\\') in substring(q[0], q[1] + 1) is odd. \\n            }\\n            ans.add(sum / 2 <= q[2]);\\n        }\\n        return ans;\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\n\\n```\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        odds = [[False] * 26]\\n        for i, c in enumerate(s):\\n            odds.append(odds[i][:])\\n            odds[i + 1][ord(c) - ord(\\'a\\')] ^= True\\n        return [sum(odds[hi + 1][i] ^ odds[lo][i] for i in range(26)) // 2 <= k for lo, hi, k in queries]  \\n```\\n\\n----\\n\\n**Method 3: prefix xor - use integer bit 0/1 to mark the even/odd of the count of each char**\\n\\nThe `32` bits in a Java `int` are enough to cover the odd/even of the counts of `26` English letters. Use only the 26 least significant bits in an `int`.\\n\\n**Java**\\n\\n```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> ans = new ArrayList<>(); \\n        int[] odds = new int[s.length() + 1]; // odds[i]: within range [0...i) of s, the jth bit of odd[i] indicates even/odd of the count of (char)(j + \\'a\\'). \\n        for (int i = 0; i < s.length(); ++i)\\n            odds[i + 1] = odds[i] ^ 1 << s.charAt(i) - \\'a\\';\\n        for (int[] q : queries)\\n            ans.add(Integer.bitCount(odds[q[1] + 1] ^ odds[q[0]]) / 2 <= q[2]); // odds[q[1] + 1] ^ odds[q[0]] indicates the count of (char)(i + \\'a\\') in substring(q[0], q[1] + 1) is even/odd.\\n        return ans;\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\n\\n```\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        odds = [False]\\n        for i, c in enumerate(s):\\n            odds.append(odds[i] ^ 1 << (ord(c) - ord(\\'a\\')))\\n        return [bin(odds[hi + 1] ^ odds[lo]).count(\\'1\\') // 2 <= k for lo, hi, k in queries]   \\n```\\n\\n----\\n\\n**Analysis:**\\n\\nTime & space: O(S + Q), where S = s.length(), Q = queries.length.",
                "solutionTags": [],
                "code": "```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> ans = new ArrayList<>(); \\n        int[][] cnt = new int[s.length() + 1][26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            cnt[i + 1] = cnt[i].clone(); // copy previous sum.\\n            ++cnt[i + 1][s.charAt(i) - \\'a\\'];\\n        }\\n        for (int[] q : queries) {\\n            int sum = 0; \\n            for (int i = 0; i < 26; ++i) {\\n                sum += (cnt[q[1] + 1][i] - cnt[q[0]][i]) % 2;\\n            }\\n            ans.add(sum / 2 <= q[2]);\\n        }\\n        return ans;\\n    }\\n```\n```\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        cnt = [[0] * 26]\\n        for i, c in enumerate(s):\\n            cnt.append(cnt[i][:])\\n            cnt[i + 1][ord(c) - ord(\\'a\\')] += 1\\n        return [sum((cnt[hi + 1][i] - cnt[lo][i]) % 2 for i in range(26)) // 2 <= k for lo, hi, k in queries]\\n```\n```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> ans = new ArrayList<>(); \\n        boolean[][] odds = new boolean[s.length() + 1][26]; // odds[i][j]: within range [0...i) of s, if the count of (char)(j + \\'a) is odd. \\n        for (int i = 0; i < s.length(); ++i) {\\n            odds[i + 1] = odds[i].clone();\\n            odds[i + 1][s.charAt(i) - \\'a\\'] ^= true;\\n        }\\n        for (int[] q : queries) {\\n            int sum = 0; \\n            for (int i = 0; i < 26; ++i) {\\n                sum += (odds[q[1] + 1][i] ^ odds[q[0]][i]) ? 1 : 0; // if the count of (char)(i + \\'a\\') in substring(q[0], q[1] + 1) is odd. \\n            }\\n            ans.add(sum / 2 <= q[2]);\\n        }\\n        return ans;\\n    }\\n```\n```\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        odds = [[False] * 26]\\n        for i, c in enumerate(s):\\n            odds.append(odds[i][:])\\n            odds[i + 1][ord(c) - ord(\\'a\\')] ^= True\\n        return [sum(odds[hi + 1][i] ^ odds[lo][i] for i in range(26)) // 2 <= k for lo, hi, k in queries]  \\n```\n```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> ans = new ArrayList<>(); \\n        int[] odds = new int[s.length() + 1]; // odds[i]: within range [0...i) of s, the jth bit of odd[i] indicates even/odd of the count of (char)(j + \\'a\\'). \\n        for (int i = 0; i < s.length(); ++i)\\n            odds[i + 1] = odds[i] ^ 1 << s.charAt(i) - \\'a\\';\\n        for (int[] q : queries)\\n            ans.add(Integer.bitCount(odds[q[1] + 1] ^ odds[q[0]]) / 2 <= q[2]); // odds[q[1] + 1] ^ odds[q[0]] indicates the count of (char)(i + \\'a\\') in substring(q[0], q[1] + 1) is even/odd.\\n        return ans;\\n    }\\n```\n```\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        odds = [False]\\n        for i, c in enumerate(s):\\n            odds.append(odds[i] ^ 1 << (ord(c) - ord(\\'a\\')))\\n        return [bin(odds[hi + 1] ^ odds[lo]).count(\\'1\\') // 2 <= k for lo, hi, k in queries]   \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 372044,
                "title": "short-and-fast-c-prefix-xor-solution-beats-100",
                "content": "We care only about the parity of the character sum in the substring, so there is no need to do the full counting.\\n```\\nvector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n    int mask = 0;\\n    vector<int> ps(1);\\n    for (char c : s)\\n        ps.push_back(mask ^= 1 << (c - \\'a\\'));\\n\\n    vector<bool> r;\\n    for (auto &q : queries) {\\n        int odds = __builtin_popcount(ps[q[1] + 1] ^ ps[q[0]]);\\n        r.push_back(q[2] >= odds / 2);\\n    }\\n    return r;\\n}\\n```\\nPS: The `__builtin_popcount()` function is for g++ only. For C++20 use `popcount()`. For other compilers use `bitset<26>().count()`.",
                "solutionTags": [],
                "code": "```\\nvector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n    int mask = 0;\\n    vector<int> ps(1);\\n    for (char c : s)\\n        ps.push_back(mask ^= 1 << (c - \\'a\\'));\\n\\n    vector<bool> r;\\n    for (auto &q : queries) {\\n        int odds = __builtin_popcount(ps[q[1] + 1] ^ ps[q[0]]);\\n        r.push_back(q[2] >= odds / 2);\\n    }\\n    return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371874,
                "title": "c-o-n-typical-prefix-sum-question",
                "content": "* Create a prefix sum ```vector<vector<int>(26)>``` where each of the inner vector will contain the count of alphabets till index i of string s.\\n* use charactercount(\\'a\\')%2 to get the leftover character and make sure that its ```sum of leftovers <=  2*k```\\n```\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        // prefix vector\\n        vector<vector<int>> vec;\\n        \\n        // current sum\\n        vector<int> tmp(26, 0);\\n        vec.push_back(tmp);\\n        \\n        // fill prefix vector\\n        for(int i=0; i<s.size(); i++){\\n            tmp[s[i]-\\'a\\']++;\\n            vec.push_back(tmp);\\n        }\\n        \\n        vector<bool> ans;\\n        for(auto const& q: queries){\\n            int lo = q[0], hi = q[1], k = q[2];\\n            vector<int> cnt = vec[hi+1];\\n            \\n            // odd = elements to be matched\\n            int odds = 0, sum = 0;\\n            \\n            // compute letter count from prefix array\\n            for(int i=0; i<26; i++){\\n                cnt[i]-=vec[lo][i];\\n                sum += cnt[i];\\n                odds += (cnt[i]%2);\\n            }\\n            \\n            // if total sum of elements is odd, decrement odds--\\n            // we can change odds/2 elements to match other odds/2 elements so odds/2<=k or rewriting it as odds<=2*k(considering odds can be odd ^_^)\\n            ans.push_back((odds-=(sum%2))<= k*2?true:false);\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```vector<vector<int>(26)>```\n```sum of leftovers <=  2*k```\n```\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        // prefix vector\\n        vector<vector<int>> vec;\\n        \\n        // current sum\\n        vector<int> tmp(26, 0);\\n        vec.push_back(tmp);\\n        \\n        // fill prefix vector\\n        for(int i=0; i<s.size(); i++){\\n            tmp[s[i]-\\'a\\']++;\\n            vec.push_back(tmp);\\n        }\\n        \\n        vector<bool> ans;\\n        for(auto const& q: queries){\\n            int lo = q[0], hi = q[1], k = q[2];\\n            vector<int> cnt = vec[hi+1];\\n            \\n            // odd = elements to be matched\\n            int odds = 0, sum = 0;\\n            \\n            // compute letter count from prefix array\\n            for(int i=0; i<26; i++){\\n                cnt[i]-=vec[lo][i];\\n                sum += cnt[i];\\n                odds += (cnt[i]%2);\\n            }\\n            \\n            // if total sum of elements is odd, decrement odds--\\n            // we can change odds/2 elements to match other odds/2 elements so odds/2<=k or rewriting it as odds<=2*k(considering odds can be odd ^_^)\\n            ans.push_back((odds-=(sum%2))<= k*2?true:false);\\n            \\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371888,
                "title": "java-easy-to-understand-beat-100-time-100-space",
                "content": "*Attention*: Seems like the test cases have been updated for this problem that make this solution TLE. The idea stays the same as explaination below. WIll update the code when I have time to do so.\\n\\nBasically, for each query, we will count the number of characters that appear odd times. These characters prevent substring from being a palindrome.\\n\\nOut of these `m` odd-appearance characters, we only need to change `m/2` characters. Indeed, we changes these characters to the other `m/2` characters to make the substring a palindrome.\\n\\nFor example, the substring `abcdefghhiijjkk`, we have 7 odd-appearance character `abcdefg`. Change `7/2 = 3` characters to form a palinedrome `aacceeghhiijjkk` (this string will be a palinedrome after rearraging, which is allowed to do unlimited time).\\n\\n**One small thing to keep in mind:** There are maximum 26 lowercase characters, therefore, the total amount of odd-appearance  <= 26. Therefore, if maximum number of changes allowed >= 26/2 = 13, we return `true`\\n\\n```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> res = new ArrayList();\\n        \\n        for (int[] query : queries) {\\n            res.add(canMakePal(s, query[0], query[1], query[2]));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean canMakePal(String s, int start, int end, int max) {\\n        if (max >= 13) return true;\\n        Set<Character> set = new HashSet();\\n        for (int i = start; i <= end; i++) {\\n            if (!set.add(s.charAt(i))) set.remove(s.charAt(i));\\n        }\\n        return max >= set.size()/2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> res = new ArrayList();\\n        \\n        for (int[] query : queries) {\\n            res.add(canMakePal(s, query[0], query[1], query[2]));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean canMakePal(String s, int start, int end, int max) {\\n        if (max >= 13) return true;\\n        Set<Character> set = new HashSet();\\n        for (int i = start; i <= end; i++) {\\n            if (!set.add(s.charAt(i))) set.remove(s.charAt(i));\\n        }\\n        return max >= set.size()/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340842,
                "title": "c-solution-using-prefix-sum-with-explaination",
                "content": "There are 2 parts to solve the question:\\n\\n**Part 1:**\\nFirst to check if the substring can be made into a palindrome, given k tries. Here we actually dont compare the substring, but do computations on the frequency of each character in the substring. If a character appears even number of times, surely, we can have half of them on left and half of them on right side of the palindrome, hence characters with even frequency require 0 resets to contribute to a palindrome. Example freq of \\'c\\' = 4 -> .... cc ....... cc .... we can create palindrome like this.\\nNow, if there are odd numbers, we need to count them. If,\\nodd_numbers > (k * 2) + (total number of characters in substring)%2\\nthen we cannot create a palindromic string even with k resets. \\nWhy is that so? Because with 1 reset, we can make 1 odd freq char equal to another. For example there are 1 a\\'s, 2 b\\'s and 3 c\\'s in a substring, converting 1 c to 1 a makes 2 a\\'s, 2 b\\'s and 2 c\\'s, hence a palindrome is possible from such characters and number of resets used in this case = 1 (c converted to a). Also, if total number of characters in a subtring are odd, we dont care for that one odd character that can appear in the middle of the subtring.\\n\\n**Part 2:**\\nInitially I was creating a substring, counting the frequency of each character in it and check for the condition given above. It gave TLE as length of s and queries can be 10^5. So there is something known as prefix sum that we need to maintain. That will give us the frequency of characters in each substring, without having to calculate it again and again.\\nHow to maintain this prefix sum? Imagine a string-> \"abcbc\"\\n[index: prefix_sum]\\n[0: (a=1), 1: (a=1, b=1), 2: (a=1, b=1, c=1), 3: (a=1, b=2, c=1), 4: (a=1, b=2, c=2)]\\nSo we use a 2D vector to keep track of prefix sum. We traverse through all the characters in the string and store the updated vector in our 2D vector prefix. Also, dont forget to push_back empty vector at start- as that will be needed when the lower bound of your subtring will be at index 0.\\nNow when we are processing the queries, count the frequency of each character by doing:\\nprefix[hi][i]-prefix[lo][i] (If you notice this ultimately what we are doing for each index in the vector sub (representing the frequency of each character in the substring).\\nAtlast check the condition given in the part 1 and add true/false in the return vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool> ret;\\n        vector<vector<int>> prefix;\\n        vector<int> temp(26, 0);\\n        prefix.push_back(temp);\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            temp[s[i]-\\'a\\']++;\\n            prefix.push_back(temp);\\n        }\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            int hi = queries[i][1], lo = queries[i][0], k = queries[i][2];\\n            vector<int> sub = prefix[hi+1];\\n            int odd=0, sum=hi-lo+1;\\n            for(int j=0; j<26; j++)\\n            {\\n                sub[j] = sub[j] - prefix[lo][j];\\n                odd+=sub[j]%2;\\n            }\\n            bool t = (odd <= k*2 + sum%2);\\n            ret.push_back(t);\\n        }\\n        return ret;\\n    }\\n};\\n```\\nn = s.length()\\nSpace complexity = O(26 * n (prefix) + 26 (temp) + 26 (sub) + n (ret)) = O(n)\\nTime complexity = O(n + n * 26) (1st and 2nd loop) = O(n)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool> ret;\\n        vector<vector<int>> prefix;\\n        vector<int> temp(26, 0);\\n        prefix.push_back(temp);\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            temp[s[i]-\\'a\\']++;\\n            prefix.push_back(temp);\\n        }\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            int hi = queries[i][1], lo = queries[i][0], k = queries[i][2];\\n            vector<int> sub = prefix[hi+1];\\n            int odd=0, sum=hi-lo+1;\\n            for(int j=0; j<26; j++)\\n            {\\n                sub[j] = sub[j] - prefix[lo][j];\\n                odd+=sub[j]%2;\\n            }\\n            bool t = (odd <= k*2 + sum%2);\\n            ret.push_back(t);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372153,
                "title": "detailed-explanation-using-dp",
                "content": "# Intuition\\n\\n* * Let us create a **DP** matrix, where `dp[i][j]` represents the count of `i-th` character in the substring `str[0...j]`. \\n\\n* Let us fix an `i` and see the recursive structure. \\n\\t* Suppose, the `j - th` character is `i`, then `dp[i][j] = dp[i][j-1] + 1`.\\n\\t* If the `j-th` character is not `i`, then `dp[i][j] = dp[i][j-1]`\\n\\t* If `j == 0`, `dp[i][j]` would be one if the first character is equal to the `i-th` character or else zero.\\n\\n* For each query, we find out the count of the each character in the substring `str[left,...right]` by the simple relation, `dp[i][right] - dp[i][left] + (str[left] == i + \\'a\\')`.\\n\\n* Get the count of unmatched pairs. It can be atmost 26.\\n\\n* We need to convert half unmatched to the remaining unmatched. If the count is `odd`, we can leave one element unmatched. Hence, we take the floor value of `unMatched / 2` , and check whether it is possible to convert this many values or not.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries);\\n};\\n\\nvector<bool> Solution :: canMakePaliQueries(string str, vector<vector<int>>& queries)\\n{\\n    int n = str.length();\\n    vector<vector<int>> dp(26, vector<int>(n,0));\\n    \\n    /* dp[i][j] represents the count of the i-th character in the string str[0...i] */\\n    \\n    for(int i = 0; i < 26; i++)\\n    {\\n        char currentChar = i + \\'a\\';\\n        for(int j = 0; j < n; j++)\\n        {\\n            if(j == 0)\\n                dp[i][j] = (str[j] == currentChar);\\n            else\\n                dp[i][j] = dp[i][j-1] + (str[j] == currentChar);\\n        }\\n    }\\n    \\n    vector<bool> ans;\\n    for(auto query : queries)\\n    {\\n        int left =  query[0];\\n        int right = query[1];\\n        int k = query[2];\\n        \\n        int unMatchedCount = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            int occurrence = dp[i][right] - dp[i][left] + (str[left] == (i + \\'a\\'));\\n            \\n            if(occurrence & 1)\\n                unMatchedCount++;\\n        }\\n        \\n        int requiredConversions = unMatchedCount / 2;\\n        ans.push_back(requiredConversions <= k);\\n    }\\n    \\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries);\\n};\\n\\nvector<bool> Solution :: canMakePaliQueries(string str, vector<vector<int>>& queries)\\n{\\n    int n = str.length();\\n    vector<vector<int>> dp(26, vector<int>(n,0));\\n    \\n    /* dp[i][j] represents the count of the i-th character in the string str[0...i] */\\n    \\n    for(int i = 0; i < 26; i++)\\n    {\\n        char currentChar = i + \\'a\\';\\n        for(int j = 0; j < n; j++)\\n        {\\n            if(j == 0)\\n                dp[i][j] = (str[j] == currentChar);\\n            else\\n                dp[i][j] = dp[i][j-1] + (str[j] == currentChar);\\n        }\\n    }\\n    \\n    vector<bool> ans;\\n    for(auto query : queries)\\n    {\\n        int left =  query[0];\\n        int right = query[1];\\n        int k = query[2];\\n        \\n        int unMatchedCount = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            int occurrence = dp[i][right] - dp[i][left] + (str[left] == (i + \\'a\\'));\\n            \\n            if(occurrence & 1)\\n                unMatchedCount++;\\n        }\\n        \\n        int requiredConversions = unMatchedCount / 2;\\n        ans.push_back(requiredConversions <= k);\\n    }\\n    \\n    return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925760,
                "title": "c-91-faster-runtime-solution-using-bitset-and-dp-easy-to-understand-clear-concise-code",
                "content": "We need to find the **number of odd occurences of characters in the range left,right efficiently**\\nSo we use bitset available in c++ to store the odd/even occurences of each character upto index i in the string using a dp array and toggling the character to account for odd/even occurences.\\n\\nSee code below for implementation of above idea.\\n**To find in the given range left to right, just xor dp[left-1] with dp[right]**\\n\\n**If the count of odd occurences divide by 2 is <=k , then return false.This works bcoz we need to only change the half of odd occuring characters to make a palindrome**.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size(),i;\\n        bitset<26> dp[n];\\n        \\n       dp[0][s[0]-\\'a\\']=1;\\n        //cout<<dp[0]<<\"\\\\n\";\\n        for(i=1;i<n;i++)\\n        {\\n           // cout<<(1<<(s[i]-\\'a\\'))<<\"\\\\n\";\\n            dp[i]=dp[i-1];\\n            dp[i]^=(1<<(s[i]-\\'a\\'));//toggle\\n                //cout<<dp[i]<<\" bit\\\\n\";\\n        }\\n        vector<bool> ans;\\n        for(auto &q:queries)\\n        {\\n            int end=q[1],st=q[0],k=q[2];\\n            bitset<26> res=st==0?dp[end]:dp[end]^dp[st-1];\\n            //cout<<res.count()<<\"\\\\n\";\\n            ans.push_back(res.count()/2<=k?true:false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size(),i;\\n        bitset<26> dp[n];\\n        \\n       dp[0][s[0]-\\'a\\']=1;\\n        //cout<<dp[0]<<\"\\\\n\";\\n        for(i=1;i<n;i++)\\n        {\\n           // cout<<(1<<(s[i]-\\'a\\'))<<\"\\\\n\";\\n            dp[i]=dp[i-1];\\n            dp[i]^=(1<<(s[i]-\\'a\\'));//toggle\\n                //cout<<dp[i]<<\" bit\\\\n\";\\n        }\\n        vector<bool> ans;\\n        for(auto &q:queries)\\n        {\\n            int end=q[1],st=q[0],k=q[2];\\n            bitset<26> res=st==0?dp[end]:dp[end]^dp[st-1];\\n            //cout<<res.count()<<\"\\\\n\";\\n            ans.push_back(res.count()/2<=k?true:false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 373956,
                "title": "java-bit-vector-linear-clean-code-solution-explained",
                "content": "We need to simplify the condition for the query first. \\n\\nIf we can change position of the char this means that we interested only in quantity of every character. If we met same character 2, 4 or any other even number of times - we can do a palindrome anyways, so don\\'t need to spend a replacement point for it, so we don\\'t care of such characters. If the number is odd - this one we need to replace. How many of those we need to replace - every second one, becace by replacing one of odd with another odd we\\'ll make it even number (like 3 + 5 = 8 - even). The catch here - we have to exclude one odd because it can be in the center of the string and don\\'t need to be replaced. But this is only in case there are odd number of odd characters :) \\n\\nThis condition can be met by doing whole-number division by 2 of number of odd characters - in Java /2. \\n\\nSo for one query the algorithm is clear - count the number of characters between query[0] and query[1], count number of times we have odd count, divide it by 2 and compare with allowed replacements - query[2].\\n\\nIf we do it for every query separately this will time out. Complexity is O(len(s) x len(queries)), the reason is - we count characters for substring every time, and substring can be very long. \\n\\nImproved approach can do just the single pass on the string => O(Max(len(s), len(queries))) - pre-calculate counts for every position in the string - do the prefix counts. Then for every query the count can be found quickly be substracting count of lower index from count for greater index. This way we calculate counts only once.\\n\\nAnother improvement - we can store only flag that indicates odd or even number of each character. In this case we need to store bits only, not real numbers. If we use bit-vector to store those counts and there are only 26 allowed characters it\\'s enough to use single int for this - we can use single int.This leads to final solution.\\n\\nComplexity - O(Max(len(s), len(queries))) for time. We do len(s) and then len(queries) iterations and save it in separate arrays. So whichever element dominates - this directs the complexity. O(len(s)) space - need to store one int  per character in the string.\\n\\n```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> res = new ArrayList();\\n        \\n        if (queries.length == 0)\\n            return res;\\n        //create array of prefix counts for every next char in the string\\n        //count number of odd times we met one character\\n        int[] countArray = new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            //take count for previous charter, 0 if first character\\n            int prev = (i == 0) ? 0 : countArray[i - 1];\\n            //transfrom char into index\\n            int idx = s.charAt(i) - \\'a\\';\\n            //calculate count for this charater in the string by doing XOR\\n            //of this charater bit with the previous count\\n            countArray[i]= (prev^(1<<idx));\\n        }\\n        \\n        //now iterate over the query array\\n        for (int[] q : queries) {\\n            //simple case - query of 1 character is always a palindrome\\n            if (q[0] == q[1]) {\\n                res.add(true);\\n                continue;\\n            }\\n            //take count of previous position in array of prefixes, 0 if it\\'s first element\\n            int p = q[0] == 0 ? 0 : countArray[q[0] - 1];\\n            //by doing XOR take count of even number of chars between q[1] and q[0] - 1\\n            int counts = (p^countArray[q[1]]);\\n            //check the number of even chars, if / 2 is less then a q[2] - we can satisfy the\\n            //condition of the query\\n            res.add((Integer.bitCount(counts) / 2)<= q[2]);\\n        } \\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> res = new ArrayList();\\n        \\n        if (queries.length == 0)\\n            return res;\\n        //create array of prefix counts for every next char in the string\\n        //count number of odd times we met one character\\n        int[] countArray = new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            //take count for previous charter, 0 if first character\\n            int prev = (i == 0) ? 0 : countArray[i - 1];\\n            //transfrom char into index\\n            int idx = s.charAt(i) - \\'a\\';\\n            //calculate count for this charater in the string by doing XOR\\n            //of this charater bit with the previous count\\n            countArray[i]= (prev^(1<<idx));\\n        }\\n        \\n        //now iterate over the query array\\n        for (int[] q : queries) {\\n            //simple case - query of 1 character is always a palindrome\\n            if (q[0] == q[1]) {\\n                res.add(true);\\n                continue;\\n            }\\n            //take count of previous position in array of prefixes, 0 if it\\'s first element\\n            int p = q[0] == 0 ? 0 : countArray[q[0] - 1];\\n            //by doing XOR take count of even number of chars between q[1] and q[0] - 1\\n            int counts = (p^countArray[q[1]]);\\n            //check the number of even chars, if / 2 is less then a q[2] - we can satisfy the\\n            //condition of the query\\n            res.add((Integer.bitCount(counts) / 2)<= q[2]);\\n        } \\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626657,
                "title": "c-prefix-sum-map-of-vectors",
                "content": "C++:\\nThe idea here is to use a map of vectors which stores the snapshot of our frequency array for each prefix of the given string. This enables us to achieve the frequency array of the left--right substring in constant time. After that we can simply check if the (number of odd letters)/2 is less than equal to k or not. Here we have divided by 2 as a palindrome can be formed by replacing half of the odd frequency letters with the other half. This works for both even and odd number as integer division gives us the lower value and thus for odd we need to replace odd/2 letters only.\\n\\nTime Complexity : O(Length of queries array)\\nSpace Complexity : O(n * 26) where n is the size of string\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        int n = s.size();\\n        \\n        unordered_map<int,vector<int>> mp;\\n        vector<int> freq(26,0);\\n        mp[-1] = freq;\\n        \\n        for(int i = 0; i<n; i++){\\n            freq[s[i]-97]++;\\n            mp[i] = freq;\\n        }\\n        \\n        int m = queries.size();\\n        vector<bool> ans(m);\\n        \\n        for(int i = 0; i<m; i++){\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            int k = queries[i][2];\\n            \\n            vector<int> freq(26,0);\\n            int odd_cnt = 0;\\n            \\n            for(int j = 0; j<26; j++){\\n                freq[j] = mp[r][j] - mp[l-1][j];\\n                if(freq[j]&1)\\n                    odd_cnt++;\\n            }\\n            \\n            \\n            \\n            if(odd_cnt/2 > k){\\n                ans[i] = false;\\n            }\\n            else{\\n                ans[i] = true;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        int n = s.size();\\n        \\n        unordered_map<int,vector<int>> mp;\\n        vector<int> freq(26,0);\\n        mp[-1] = freq;\\n        \\n        for(int i = 0; i<n; i++){\\n            freq[s[i]-97]++;\\n            mp[i] = freq;\\n        }\\n        \\n        int m = queries.size();\\n        vector<bool> ans(m);\\n        \\n        for(int i = 0; i<m; i++){\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            int k = queries[i][2];\\n            \\n            vector<int> freq(26,0);\\n            int odd_cnt = 0;\\n            \\n            for(int j = 0; j<26; j++){\\n                freq[j] = mp[r][j] - mp[l-1][j];\\n                if(freq[j]&1)\\n                    odd_cnt++;\\n            }\\n            \\n            \\n            \\n            if(odd_cnt/2 > k){\\n                ans[i] = false;\\n            }\\n            else{\\n                ans[i] = true;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572010,
                "title": "java-use-bit-mask-to-count-odd-chars",
                "content": "```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] qs) {\\n        int[] cnt = new int[s.length() + 1];\\n        int i = 0;\\n        for (char c : s.toCharArray()) {\\n            cnt[i + 1] = cnt[i++] ^ (1 << (c - \\'a\\'));\\n        }\\n        List<Boolean> res = new ArrayList<>();\\n        for (int[] q : qs) {\\n            int sum = (q[1] - q[0]) % 2;\\n            sum += Integer.bitCount(cnt[q[1] + 1] ^ cnt[q[0]]);\\n            res.add(sum / 2 <= q[2]);  // if odd, just put it in center;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] qs) {\\n        int[] cnt = new int[s.length() + 1];\\n        int i = 0;\\n        for (char c : s.toCharArray()) {\\n            cnt[i + 1] = cnt[i++] ^ (1 << (c - \\'a\\'));\\n        }\\n        List<Boolean> res = new ArrayList<>();\\n        for (int[] q : qs) {\\n            int sum = (q[1] - q[0]) % 2;\\n            sum += Integer.bitCount(cnt[q[1] + 1] ^ cnt[q[0]]);\\n            res.add(sum / 2 <= q[2]);  // if odd, just put it in center;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 372529,
                "title": "python-concise-prefix-sum-solution",
                "content": "```\\nclass Solution(object):\\n    def canMakePaliQueries(self, s, queries):\\n        res=[]\\n        pre=[[True]*26]\\n        for i,ch in enumerate(s):\\n            counter=pre[-1][:]\\n            counter[ord(ch)-ord(\\'a\\')]^=True\\n            pre.append(counter)     \\n        for l,r,k in queries:\\n            res.append(2*k>=sum((pre[r+1][i]-pre[l][i])%2==1 for i in range(26))-1)\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canMakePaliQueries(self, s, queries):\\n        res=[]\\n        pre=[[True]*26]\\n        for i,ch in enumerate(s):\\n            counter=pre[-1][:]\\n            counter[ord(ch)-ord(\\'a\\')]^=True\\n            pre.append(counter)     \\n        for l,r,k in queries:\\n            res.append(2*k>=sum((pre[r+1][i]-pre[l][i])%2==1 for i in range(26))-1)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 371840,
                "title": "java-pruning",
                "content": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> list = new ArrayList<>();\\n        for (int[] q : queries) {\\n// if k >= 13, we can always make the substring to palindrome\\n            if (q[2] >= 13) {\\n                list.add(true);\\n                continue;\\n            }\\n            String str = s.substring(q[0], q[1] + 1);\\n            list.add(check(str, q[2]));\\n        }\\n        return list;\\n    }\\n    boolean check(String str, int k) {\\n        int l = 0;\\n        int r = str.length() - 1;\\n        int count = 0;\\n        char[] memo = new char[26];\\n        for (char c : str.toCharArray()) {\\n            memo[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (memo[i] % 2 == 1) {\\n                count++;\\n            }\\n        }\\n        if (k == 0 && count > 1) {\\n            return false;\\n        }\\n        if (count % 2 == 1) {\\n            return (count - 1) / 2 <= k;\\n        } else {\\n            return count / 2 <= k;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> list = new ArrayList<>();\\n        for (int[] q : queries) {\\n// if k >= 13, we can always make the substring to palindrome\\n            if (q[2] >= 13) {\\n                list.add(true);\\n                continue;\\n            }\\n            String str = s.substring(q[0], q[1] + 1);\\n            list.add(check(str, q[2]));\\n        }\\n        return list;\\n    }\\n    boolean check(String str, int k) {\\n        int l = 0;\\n        int r = str.length() - 1;\\n        int count = 0;\\n        char[] memo = new char[26];\\n        for (char c : str.toCharArray()) {\\n            memo[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < 26; i++) {\\n            if (memo[i] % 2 == 1) {\\n                count++;\\n            }\\n        }\\n        if (k == 0 && count > 1) {\\n            return false;\\n        }\\n        if (count % 2 == 1) {\\n            return (count - 1) / 2 <= k;\\n        } else {\\n            return count / 2 <= k;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846031,
                "title": "python-3-9-10-lines-xor-three-versions-t-m-99-94",
                "content": "Both are pretty much the same as many posts before, with a few wrinkles. It\\'s not necessary to count chars, only keep track of even/odd. We can accomplish this by using a xor toggle. Similarly, we can use a toggle to determine whether a char changes over a query interval.\\n\\nThe first one employs lists indexed with ord #s. The second one employs dicts using the distinct letters in *s* as keys. The third employs bit-maps to track the changes.\\n```\\nclass Solution:               #  Using lists     T/M: 52%/80%\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n\\n            d, ans = [[0]*26], []\\n\\n            for ch in s:                                            # keep track of even/odd (0/1)\\n                nxt = d[-1][:]                                      # for each char as we iterate\\n                nxt[ord(ch)-97]^= 1                                 # across s.\\n                d.append(nxt)                                       #\\n\\n            for l, r, k in queries:                                 # Check whether all odds can be remedied\\n                odds = sum(d[l][i]^d[r+1][i] for i in range(26))    # with k changes\\n\\n                ans.append(odds//2 <= k)                            # Check whether all odds can be remedied\\n                                                                    # with k changes\\n            return ans            \\n```\\n[https://leetcode.com/submissions/detail/849264474/](http://)\\n\\n\\n\\n\\n```\\nclass Solution:                #  Using dicts   T/M: 89%/21%\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n\\n            S = set(s)\\n            d, ans = [{ch:0 for ch in S}], []\\n\\n            for ch in s:                                        # keep track of even/odd (0/1)\\n                nxt = d[-1].copy()                              # for each char as we iterate\\n                nxt[ch]^= 1                                     # across s.\\n                d.append(nxt)                                   #\\n\\n            for l, r, k in queries:                             # check whether char changes even/odd\\n                odds = sum(d[l][ch]^d[r+1][ch] for ch in S)     # over query interval\\n                                                    \\n                ans.append(odds//2 <= k)                        # Check whether all odds can be remedied \\n                                                                # with k changes\\n            return ans\\n```\\n\\n\\n[https://leetcode.com/submissions/detail/849291479/](http://)\\n\\n```\\nclass Solution:              #  Using bit-map     T/M: 99%/90%\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n       \\n        d, ans = [0], []\\n        int_ = lambda x: ord(x) - 97\\n        \\n        for i, ch in enumerate(s):                              # keep track of even/odd (0/1)\\n            nxt = d[i] ^ (1 << int_(ch))                        # for each char as we iterate\\n            d.append(nxt)                                       # across s.\\n\\n        for l, r, k in queries:                                 # Check whether all odds can be remedied\\n                ans.append((d[l]^d[r+1]).bit_count()//2 <= k)   # with k changes\\n\\n        return ans\\n```\\n[https://leetcode.com/submissions/detail/849323828//](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:               #  Using lists     T/M: 52%/80%\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n\\n            d, ans = [[0]*26], []\\n\\n            for ch in s:                                            # keep track of even/odd (0/1)\\n                nxt = d[-1][:]                                      # for each char as we iterate\\n                nxt[ord(ch)-97]^= 1                                 # across s.\\n                d.append(nxt)                                       #\\n\\n            for l, r, k in queries:                                 # Check whether all odds can be remedied\\n                odds = sum(d[l][i]^d[r+1][i] for i in range(26))    # with k changes\\n\\n                ans.append(odds//2 <= k)                            # Check whether all odds can be remedied\\n                                                                    # with k changes\\n            return ans            \\n```\n```\\nclass Solution:                #  Using dicts   T/M: 89%/21%\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n\\n            S = set(s)\\n            d, ans = [{ch:0 for ch in S}], []\\n\\n            for ch in s:                                        # keep track of even/odd (0/1)\\n                nxt = d[-1].copy()                              # for each char as we iterate\\n                nxt[ch]^= 1                                     # across s.\\n                d.append(nxt)                                   #\\n\\n            for l, r, k in queries:                             # check whether char changes even/odd\\n                odds = sum(d[l][ch]^d[r+1][ch] for ch in S)     # over query interval\\n                                                    \\n                ans.append(odds//2 <= k)                        # Check whether all odds can be remedied \\n                                                                # with k changes\\n            return ans\\n```\n```\\nclass Solution:              #  Using bit-map     T/M: 99%/90%\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n       \\n        d, ans = [0], []\\n        int_ = lambda x: ord(x) - 97\\n        \\n        for i, ch in enumerate(s):                              # keep track of even/odd (0/1)\\n            nxt = d[i] ^ (1 << int_(ch))                        # for each char as we iterate\\n            d.append(nxt)                                       # across s.\\n\\n        for l, r, k in queries:                                 # Check whether all odds can be remedied\\n                ans.append((d[l]^d[r+1]).bit_count()//2 <= k)   # with k changes\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925867,
                "title": "c-n-time-preprocessing-constant-time-query-resolution-bitmasking-hashing-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// FUNTION TO COUNT NUMBER OF SET BITS I.E. NUMBER OF ODD ELEMENTS IN RANGE\\n    int count(int num){\\n        int cnt = 0;\\n        for(int i = 0; i < 31; i++) {\\n            if(num&(1<<i)) cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<int> masks; //MASK WILL HELP US KEEP TRACK OF NUMBER OF ODD ELEMENTS\\n        int curr = 0;\\n        masks.push_back(0); //INITIAL MASK IS ZERO SINCE THE NUMBER OF ODD ELEMENTS IS ZERO\\n        for(auto x: s){\\n            curr^=(1<<(x - \\'a\\')); //XOR WILL KEEP ON SWITCHING THE BITS (1->ODD, 0->EVEN)\\n            masks.push_back(curr); //STORING THE MASK FOR EACH INSTANCE\\n        }\\n        vector<bool> res;\\n        for(auto x: queries){\\n            int new_mask = masks[x[0]]^masks[x[1]+1]; //THE MASK WILL HOLD THE NUMBER OF ODD ELEMTS BETWEEN THE GIVEN RANGE, DRY RUN IT ONCE TO UNDERSTAND\\n            int cnt = count(new_mask);\\n\\t\\t\\t/*\\n\\t\\t\\tSINCE WIL HAVE NO PROBLEM IF THERE IS ONLY ONE ODD ELEMENT LIKE\\n\\t\\t\\t\\n\\t\\t\\tAAAAB WE CAN CONVERT IT TO AABAA\\n\\t\\t\\tSO WE SUBTACT COUNT BY ONE\\n\\t\\t\\t\\n\\t\\t\\tEVERY ELEMENT WE ARE CONVERTING WE CAN CONVERT IT INTO THE OTHER ODD OCCURING ELEMENT SO BY ONE CONVERSION WE CAN TAKE CARE OF TWO ODD NUMBERS \\n\\t\\t\\tSUPPOSE WE HAVE \\n\\t\\t\\tABCD \\n\\t\\t\\tAND THE NUMBER OF CONVERSION IS TWO WE CAN CONVERT IT TO\\n\\t\\t\\tABBA\\n\\t\\t\\tSO EVEN WITH 4 ODD OCCURENCES WE WERE ABLE TO FIX IT WITH TWO CONVERSION SO WE ARE MULTIPLYING X[2] WITH 2\\n\\t\\t\\t*/\\n            res.push_back(cnt-1<= x[2]*2); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// FUNTION TO COUNT NUMBER OF SET BITS I.E. NUMBER OF ODD ELEMENTS IN RANGE\\n    int count(int num){\\n        int cnt = 0;\\n        for(int i = 0; i < 31; i++) {\\n            if(num&(1<<i)) cnt++;\\n        }\\n        return cnt;\\n    }\\n    \\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<int> masks; //MASK WILL HELP US KEEP TRACK OF NUMBER OF ODD ELEMENTS\\n        int curr = 0;\\n        masks.push_back(0); //INITIAL MASK IS ZERO SINCE THE NUMBER OF ODD ELEMENTS IS ZERO\\n        for(auto x: s){\\n            curr^=(1<<(x - \\'a\\')); //XOR WILL KEEP ON SWITCHING THE BITS (1->ODD, 0->EVEN)\\n            masks.push_back(curr); //STORING THE MASK FOR EACH INSTANCE\\n        }\\n        vector<bool> res;\\n        for(auto x: queries){\\n            int new_mask = masks[x[0]]^masks[x[1]+1]; //THE MASK WILL HOLD THE NUMBER OF ODD ELEMTS BETWEEN THE GIVEN RANGE, DRY RUN IT ONCE TO UNDERSTAND\\n            int cnt = count(new_mask);\\n\\t\\t\\t/*\\n\\t\\t\\tSINCE WIL HAVE NO PROBLEM IF THERE IS ONLY ONE ODD ELEMENT LIKE\\n\\t\\t\\t\\n\\t\\t\\tAAAAB WE CAN CONVERT IT TO AABAA\\n\\t\\t\\tSO WE SUBTACT COUNT BY ONE\\n\\t\\t\\t\\n\\t\\t\\tEVERY ELEMENT WE ARE CONVERTING WE CAN CONVERT IT INTO THE OTHER ODD OCCURING ELEMENT SO BY ONE CONVERSION WE CAN TAKE CARE OF TWO ODD NUMBERS \\n\\t\\t\\tSUPPOSE WE HAVE \\n\\t\\t\\tABCD \\n\\t\\t\\tAND THE NUMBER OF CONVERSION IS TWO WE CAN CONVERT IT TO\\n\\t\\t\\tABBA\\n\\t\\t\\tSO EVEN WITH 4 ODD OCCURENCES WE WERE ABLE TO FIX IT WITH TWO CONVERSION SO WE ARE MULTIPLYING X[2] WITH 2\\n\\t\\t\\t*/\\n            res.push_back(cnt-1<= x[2]*2); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919627,
                "title": "c-o-n-26-time-and-o-n-26-space-easy-prefix-solution",
                "content": "class Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        int n=s.length();\\n        \\n        vector<vector<int>> freq(n+1,vector<int>(26,0));\\n        \\n        for(int i=1;i<n+1;i++){                   // i denotes length of string considered\\n            \\n            for(int j=0;j<26;j++){              \\n                \\n                freq[i][j]= freq[i-1][j];\\n            }\\n            \\n            freq[i][s[i-1]-\\'a\\']++;\\n        }    \\n        \\n        int m= queries.size();\\n        \\n        vector<bool> ans(m);\\n        \\n        \\n        for(int i=0;i<queries.size();i++){\\n            \\n            int s= queries[i][0]+1;\\n            int e= queries[i][1]+1;\\n            \\n            int odd=0;\\n            \\n            for(int j=0;j<26;j++){\\n                \\n                if((freq[e][j]-freq[s-1][j])&1)\\n                    odd++;\\n                \\n             }\\n            \\n            if(queries[i][2]>=odd/2)\\n                ans[i]=true;\\n            \\n            else\\n                ans[i]=false;\\n            \\n\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        int n=s.length();\\n        \\n        vector<vector<int>> freq(n+1,vector<int>(26,0));\\n        \\n        for(int i=1;i<n+1;i++){                   // i denotes length of string considered\\n            \\n            for(int j=0;j<26;j++){              \\n                \\n                freq[i][j]= freq[i-1][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 398953,
                "title": "java-solution-8-ms",
                "content": "class Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n        int str_len = s.length();\\n        int j = 0;\\n        List<Boolean> results = new ArrayList<>();\\n        int[] masks = new int[str_len + 1];\\n        \\n        int mask = 0;\\n        for(int i = 0 ; i < str_len; i++){\\n            mask ^= (1 << (s.charAt(i) - \\'a\\'));\\n            masks[++j] = mask;\\n        }\\n\\n        for(int [] query : queries){\\n            if(query[2] >= 13){\\n                results.add(true);\\n            }else{\\n                results.add(Integer.bitCount(masks[query[1] + 1] ^ masks[query[0]]) /2 <= query[2]);\\n            }\\n        }\\n\\n        return results;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n        int str_len = s.length();\\n        int j = 0;\\n        List<Boolean> results = new ArrayList<>();\\n        int[] masks = new int[str_len + 1];\\n        \\n        int mask = 0;\\n        for(int i = 0 ; i < str_len; i++){\\n            mask ^= (1 << (s.charAt(i) - \\'a\\'));\\n            masks[++j] = mask;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 371854,
                "title": "poorly-designed-problem-return-true-when-k-26-gets-you-around-last-input",
                "content": "No memoization (or \"prefix sum\") needed. \\n\\n```\\nclass Solution {\\npublic:\\n  vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n    vector<bool> result(queries.size());\\n    for (int i = 0; i < queries.size(); i++) {\\n      vector<int> q = queries[i];\\n      if (q[2] > 26) result[i] = true;\\n      else{\\n        result[i] = helper(s.substr(q[0], q[1] - q[0] + 1), q[2]);\\n      }\\n    }\\n    \\n    return result;\\n  }\\n  \\n  bool helper(string s, int k){\\n    if (s.size() == 1){\\n      return true;\\n    } else {\\n      unordered_map<char, int> mymap;//char : freq\\n      for (auto c : s){\\n        mymap[c]++;\\n      }\\n      int odd_cnt = 0;\\n      for (auto i : mymap) {\\n        if (i.second % 2) {\\n          odd_cnt++;\\n        }\\n      }\\n      return (odd_cnt <= k * 2 + 1);\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n    vector<bool> result(queries.size());\\n    for (int i = 0; i < queries.size(); i++) {\\n      vector<int> q = queries[i];\\n      if (q[2] > 26) result[i] = true;\\n      else{\\n        result[i] = helper(s.substr(q[0], q[1] - q[0] + 1), q[2]);\\n      }\\n    }\\n    \\n    return result;\\n  }\\n  \\n  bool helper(string s, int k){\\n    if (s.size() == 1){\\n      return true;\\n    } else {\\n      unordered_map<char, int> mymap;//char : freq\\n      for (auto c : s){\\n        mymap[c]++;\\n      }\\n      int odd_cnt = 0;\\n      for (auto i : mymap) {\\n        if (i.second % 2) {\\n          odd_cnt++;\\n        }\\n      }\\n      return (odd_cnt <= k * 2 + 1);\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764118,
                "title": "c-set-bit-count-o-n-xor",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        \\n        vector<bool> res; \\n        vector<int> temp; \\n        int pos = 0; \\n        temp.push_back(0); \\n        \\n        for(int i = 0; i < s.size(); i++) {\\n            pos ^= 1<<(s[i]-\\'a\\');\\n            temp.push_back(pos);\\n        }\\n        for(int i = 0; i < q.size(); i++) {\\n            int left = q[i][0]; \\n            int right = q[i][1]; \\n            int k = q[i][2]; \\n            \\n            int num = temp[left]^temp[right+1];\\n            if(k >= __builtin_popcount(num)/2) res.push_back(true);\\n            else res.push_back(false);\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        \\n        vector<bool> res; \\n        vector<int> temp; \\n        int pos = 0; \\n        temp.push_back(0); \\n        \\n        for(int i = 0; i < s.size(); i++) {\\n            pos ^= 1<<(s[i]-\\'a\\');\\n            temp.push_back(pos);\\n        }\\n        for(int i = 0; i < q.size(); i++) {\\n            int left = q[i][0]; \\n            int right = q[i][1]; \\n            int k = q[i][2]; \\n            \\n            int num = temp[left]^temp[right+1];\\n            if(k >= __builtin_popcount(num)/2) res.push_back(true);\\n            else res.push_back(false);\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733037,
                "title": "simple-java-answer-o-n",
                "content": "```class Solution {\\n    // Variable that will hold frequency for each letter seen till index\\n    private int[][] occurances;\\n    \\n    // Method to initialize occurances\\n    private void calculateSeenAlphabets(String s) {\\n        int[][] occurances = new int[s.length()][26];\\n        occurances[0][s.charAt(0) - \\'a\\'] = 1;\\n        \\n        for(int i = 1; i < s.length(); i++) {\\n            Character ch = s.charAt(i);\\n            \\n            // Copy character frequencies till seen till previous character\\n            for(int j = 0; j < 26; j++) {\\n                occurances[i][j] = occurances[i - 1][j];\\n            }\\n            \\n            // Increment the count of current character\\n            occurances[i][ch - \\'a\\']++;\\n        }\\n        \\n        this.occurances = occurances;\\n    }\\n    \\n    private Boolean canBeMadePalindrome(int left, int right, int numberOfOperationsLimit) {\\n        int numberOfOdds = 0;\\n        if(left == 0) {\\n            for(int i = 0; i < 26; i++) {\\n                if(occurances[right][i] % 2 == 1) {\\n                    numberOfOdds++;\\n                }\\n            }\\n        } else {\\n            for(int i = 0; i < 26; i++) {\\n                if((occurances[right][i] - occurances[left - 1][i]) % 2 == 1) {\\n                    numberOfOdds++;\\n                }\\n            }\\n        }\\n        \\n        return numberOfOdds / 2 <= numberOfOperationsLimit;\\n    }\\n    \\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        calculateSeenAlphabets(s);        \\n        List<Boolean> results = new ArrayList();\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            results.add(canBeMadePalindrome(queries[i][0], queries[i][1], queries[i][2]));\\n        }\\n        return results;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    // Variable that will hold frequency for each letter seen till index\\n    private int[][] occurances;\\n    \\n    // Method to initialize occurances\\n    private void calculateSeenAlphabets(String s) {\\n        int[][] occurances = new int[s.length()][26];\\n        occurances[0][s.charAt(0) - \\'a\\'] = 1;\\n        \\n        for(int i = 1; i < s.length(); i++) {\\n            Character ch = s.charAt(i);\\n            \\n            // Copy character frequencies till seen till previous character\\n            for(int j = 0; j < 26; j++) {\\n                occurances[i][j] = occurances[i - 1][j];\\n            }\\n            \\n            // Increment the count of current character\\n            occurances[i][ch - \\'a\\']++;\\n        }\\n        \\n        this.occurances = occurances;\\n    }\\n    \\n    private Boolean canBeMadePalindrome(int left, int right, int numberOfOperationsLimit) {\\n        int numberOfOdds = 0;\\n        if(left == 0) {\\n            for(int i = 0; i < 26; i++) {\\n                if(occurances[right][i] % 2 == 1) {\\n                    numberOfOdds++;\\n                }\\n            }\\n        } else {\\n            for(int i = 0; i < 26; i++) {\\n                if((occurances[right][i] - occurances[left - 1][i]) % 2 == 1) {\\n                    numberOfOdds++;\\n                }\\n            }\\n        }\\n        \\n        return numberOfOdds / 2 <= numberOfOperationsLimit;\\n    }\\n    \\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        calculateSeenAlphabets(s);        \\n        List<Boolean> results = new ArrayList();\\n        \\n        for(int i = 0; i < queries.length; i++) {\\n            results.add(canBeMadePalindrome(queries[i][0], queries[i][1], queries[i][2]));\\n        }\\n        return results;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181111,
                "title": "java-prefixsum-bitmanipulation-beats-100-7ms-t-c-o-q-s-s-c-o-s",
                "content": "\\n    // O(q+s) O(s)\\n\\tpublic List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n\\t\\tList<Boolean> ans = new ArrayList<>();\\n\\t\\tint len = s.length();\\n\\t\\tint[] prefixSum = new int[len];\\n\\n\\t\\tint mask = 1 << (s.charAt(0) - \\'a\\');\\n\\t\\tprefixSum[0] = mask;\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tprefixSum[i] = prefixSum[i - 1] ^ (1 << (s.charAt(i) - \\'a\\'));\\n\\n\\t\\tfor (int[] query : queries) {\\n\\n\\t\\t\\tint start = query[0], end = query[1], k = query[2], count = 0;\\n\\t\\t\\tif (start == 0)\\n\\t\\t\\t\\tcount = Integer.bitCount(prefixSum[end]);\\n\\t\\t\\telse\\n\\t\\t\\t\\tcount = Integer.bitCount(prefixSum[end] ^ prefixSum[start - 1]);\\n\\t\\t\\tans.add((count / 2 <= k) ? true : false);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(q+s) O(s)\\n\\tpublic List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n\\t\\tList<Boolean> ans = new ArrayList<>();\\n\\t\\tint len = s.length();\\n\\t\\tint[] prefixSum = new int[len];\\n\\n\\t\\tint mask = 1 << (s.charAt(0) - \\'a\\');\\n\\t\\tprefixSum[0] = mask;\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tprefixSum[i] = prefixSum[i - 1] ^ (1 << (s.charAt(i) - \\'a\\'));\\n\\n\\t\\tfor (int[] query : queries) {\\n\\n\\t\\t\\tint start = query[0], end = query[1], k = query[2], count = 0;\\n\\t\\t\\tif (start == 0)\\n\\t\\t\\t\\tcount = Integer.bitCount(prefixSum[end]);\\n\\t\\t\\telse\\n\\t\\t\\t\\tcount = Integer.bitCount(prefixSum[end] ^ prefixSum[start - 1]);\\n\\t\\t\\tans.add((count / 2 <= k) ? true : false);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 770599,
                "title": "c-dp-o-26-n",
                "content": "Here we need a way to process all queries with least cost\\n1. We will make a 2D vector with length+1, 26 size\\n2. we will use the 26 size vector to store the occurence of every character from 0 to n\\n3. when we will traverse the queries, we will process the count of every character left after pairing.\\n4. If the count obtained is less than or equal to the queries [i] [2], we will reuturn true or else false.\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool> ans;\\n        int n=s.length();\\n        vector<vector<int>> dp ( n+1 ,vector<int> (26,0) );\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i]=dp[i-1];\\n            dp[i][ s[i-1]-\\'a\\' ]++;\\n        }\\n        int k,count;\\n        for(auto i:queries)\\n        {\\n            count=0;\\n            for(int j=0;j<26;j++)\\n            {\\n                k= dp[i[1]+1][j] - dp[i[0]][j] ;\\n                count+= (k % 2) ;\\n            }\\n            ans.push_back( count/2<=i[2] ?true:false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool> ans;\\n        int n=s.length();\\n        vector<vector<int>> dp ( n+1 ,vector<int> (26,0) );\\n        for(int i=1;i<=n;i++)\\n        {\\n            dp[i]=dp[i-1];\\n            dp[i][ s[i-1]-\\'a\\' ]++;\\n        }\\n        int k,count;\\n        for(auto i:queries)\\n        {\\n            count=0;\\n            for(int j=0;j<26;j++)\\n            {\\n                k= dp[i[1]+1][j] - dp[i[0]][j] ;\\n                count+= (k % 2) ;\\n            }\\n            ans.push_back( count/2<=i[2] ?true:false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379265,
                "title": "javascript-easy-understand-with-explanation-2-solutions",
                "content": "The core algorithm is to count the frequence for each lowercase letter. And then calculate the number of single charactor for every query.\\n\\nAccording to this, we have 2 solutions here.\\n\\n## SOLUTION 1\\n\\nThis solution is easy to understand. We do the counting for each lowercase letter first. And save it in a two-dimensional array `freq`. Then counting for every query and get the result.\\n\\n```js\\nconst canMakePaliQueries = (s, queries) => {\\n  const freq = [];\\n\\n  for (let i = 0; i < 26; ++i) {\\n    freq[i] = new Int16Array(s.length + 1);\\n  }\\n  for (let i = 1; i <= s.length; ++i) {\\n    const code = s.charCodeAt(i - 1) - 97;\\n    ++freq[code][i - 1];\\n    for (let j = 0; j < 26; ++j) {\\n      freq[j][i] = freq[j][i - 1];\\n    }\\n    --freq[code][i - 1];\\n  }\\n\\n  return queries.map(([start, end, count]) => {\\n    let sum = 0;\\n    for (let i = 0; i < 26; ++i) {\\n      sum += (freq[i][end + 1] - freq[i][start]) & 1;\\n    }\\n    return Math.floor(sum / 2) <= count;\\n  });\\n};\\n```\\n\\n## SOLUTION 2\\n\\nThe second solution has some tricky performance optimizations.\\n\\nWe use an one-dimensional array as the `freq` rather than two-dimensional in solution 1 since we use the bit in a 32-bit number to save the pairing status of each lowercase letter such as `1001` means just single `a` and `d`. And the other thing is to use `^` operation to counting the pairing status. Finally, for every query, we just need to count the bit and get the result.\\n\\n```js\\nconst canMakePaliQueries = (s, queries) => {\\n  const freq = new Int32Array(s.length + 1);\\n\\n  for (let i = 1; i <= s.length; ++i) {\\n    const code = s.charCodeAt(i - 1) - 97;\\n    freq[i] = freq[i - 1] ^ (1 << code);\\n  }\\n\\n  return queries.map(([start, end, count]) => {\\n    if (count >= 13) return true;\\n\\n    let data = freq[end + 1] ^ freq[start];\\n    let sum = 0;\\n    while (data > 0) {\\n      sum += data & 1;\\n      data >>= 1;\\n    }\\n\\n    return Math.floor(sum / 2) <= count;\\n  });\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst canMakePaliQueries = (s, queries) => {\\n  const freq = [];\\n\\n  for (let i = 0; i < 26; ++i) {\\n    freq[i] = new Int16Array(s.length + 1);\\n  }\\n  for (let i = 1; i <= s.length; ++i) {\\n    const code = s.charCodeAt(i - 1) - 97;\\n    ++freq[code][i - 1];\\n    for (let j = 0; j < 26; ++j) {\\n      freq[j][i] = freq[j][i - 1];\\n    }\\n    --freq[code][i - 1];\\n  }\\n\\n  return queries.map(([start, end, count]) => {\\n    let sum = 0;\\n    for (let i = 0; i < 26; ++i) {\\n      sum += (freq[i][end + 1] - freq[i][start]) & 1;\\n    }\\n    return Math.floor(sum / 2) <= count;\\n  });\\n};\\n```\n```js\\nconst canMakePaliQueries = (s, queries) => {\\n  const freq = new Int32Array(s.length + 1);\\n\\n  for (let i = 1; i <= s.length; ++i) {\\n    const code = s.charCodeAt(i - 1) - 97;\\n    freq[i] = freq[i - 1] ^ (1 << code);\\n  }\\n\\n  return queries.map(([start, end, count]) => {\\n    if (count >= 13) return true;\\n\\n    let data = freq[end + 1] ^ freq[start];\\n    let sum = 0;\\n    while (data > 0) {\\n      sum += data & 1;\\n      data >>= 1;\\n    }\\n\\n    return Math.floor(sum / 2) <= count;\\n  });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711839,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        int n = s.size();\\n        \\n        unordered_map<int,vector<int>> mp;\\n        vector<int> freq(26,0);\\n        mp[-1] = freq;\\n        \\n        for(int i = 0; i<n; i++){\\n            freq[s[i]-97]++;\\n            mp[i] = freq;\\n        }\\n        \\n        int m = queries.size();\\n        vector<bool> ans(m);\\n        \\n        for(int i = 0; i<m; i++){\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            int k = queries[i][2];\\n            \\n            vector<int> freq(26,0);\\n            int odd_cnt = 0;\\n            \\n            for(int j = 0; j<26; j++){\\n                freq[j] = mp[r][j] - mp[l-1][j];\\n                if(freq[j]&1)\\n                    odd_cnt++;\\n            }\\n            \\n            \\n            \\n            if(odd_cnt/2 > k){\\n                ans[i] = false;\\n            }\\n            else{\\n                ans[i] = true;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        int n = s.size();\\n        \\n        unordered_map<int,vector<int>> mp;\\n        vector<int> freq(26,0);\\n        mp[-1] = freq;\\n        \\n        for(int i = 0; i<n; i++){\\n            freq[s[i]-97]++;\\n            mp[i] = freq;\\n        }\\n        \\n        int m = queries.size();\\n        vector<bool> ans(m);\\n        \\n        for(int i = 0; i<m; i++){\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            int k = queries[i][2];\\n            \\n            vector<int> freq(26,0);\\n            int odd_cnt = 0;\\n            \\n            for(int j = 0; j<26; j++){\\n                freq[j] = mp[r][j] - mp[l-1][j];\\n                if(freq[j]&1)\\n                    odd_cnt++;\\n            }\\n            \\n            \\n            \\n            if(odd_cnt/2 > k){\\n                ans[i] = false;\\n            }\\n            else{\\n                ans[i] = true;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416785,
                "title": "c-o-q-n-bitmask",
                "content": "Question will become easy if we able to count number of odd occurring chracter in O(1) time.Think of xor ,mask and prefix of mask.\\nHere I am calculating odd count by taking xor just like prefix sum.For example \\na b c d  a\\nmask_prefix[0]=0001\\nmask_prefix[1]=0011\\nmask_prefix[2]=0111\\nmask_prefix[3]=1111\\nmask_prefix[4]=1110\\nnow if we are given count odd occuring char in substring from 1 to 4\\nthis will be equal to  mask_prefix[4]^mask_prefix[1-1]=1110^0001=1111 `i.e abcd` \\n1->3  mask_prefix[3]^mask_prefix[1-1]=1111^0001=1110 `i.e bcd` \\nNow if we are given liberty to change half of odd occuring chracter we can make it pallindrome.\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) { \\n        int n=s.size();\\n        unordered_map<int,int> mask_array(n); \\n        int mask=0;\\n        mask_array[-1]=0;\\n        for(int i=0;i<n;i++){\\n            mask^=(1<<(s[i]-\\'a\\'));\\n            mask_array[i]=mask;\\n        }   \\n        vector<bool> ans;\\n        for(auto q:queries){\\n            int left=q[0];\\n            int right=q[1];\\n            int change=q[2];\\n            int required_change=__builtin_popcount(mask_array[right]^mask_array[left-1]);       \\n            if(change>=required_change/2)\\n                ans.push_back(true);\\n            else \\n                ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) { \\n        int n=s.size();\\n        unordered_map<int,int> mask_array(n); \\n        int mask=0;\\n        mask_array[-1]=0;\\n        for(int i=0;i<n;i++){\\n            mask^=(1<<(s[i]-\\'a\\'));\\n            mask_array[i]=mask;\\n        }   \\n        vector<bool> ans;\\n        for(auto q:queries){\\n            int left=q[0];\\n            int right=q[1];\\n            int change=q[2];\\n            int required_change=__builtin_popcount(mask_array[right]^mask_array[left-1]);       \\n            if(change>=required_change/2)\\n                ans.push_back(true);\\n            else \\n                ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550656,
                "title": "java-solution-using-prefix-array-with-explaination",
                "content": "class Solution {\\n    \\n\\tpublic List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> res = new ArrayList<>();\\n        \\n        int n = s.length();\\n        int[][] prefixArr = new int[n + 1][26];\\n        \\n        for(int i = 1 ; i <= n ; i++){\\n\\t\\t\\t// each index contains all elements from previous indices along with element at current index\\n            prefixArr[i] = Arrays.copyOf(prefixArr[i-1],26); //add all elements from previous indices\\n            prefixArr[i][s.charAt(i-1) - \\'a\\']++; // add current element\\n        }\\n        \\n        for(int[] query : queries){\\n            int l = query[0] , \\n                r = query[1] , \\n                k = ((r - l + 1) % 2) == 0 ? 2*query[2] : 2*query[2]+1 ,  //if(length of substring is even then each character has one or more duplicates but if length is odd then there exist a single element in the middle with no duplicates.\\n                o = 0;\\n            \\n            for(int i = 0 ; i < 26 ; i++)\\n                if((prefixArr[r + 1][i] - prefixArr[l][i]) % 2 != 0) //count number of elements appearing odd number of times\\n                    o++; \\n            \\n            res.add(o <= k);//if count is less than k add true else false\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    \\n\\tpublic List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> res = new ArrayList<>();\\n        \\n        int n = s.length();\\n        int[][] prefixArr = new int[n + 1][26];\\n        \\n        for(int i = 1 ; i <= n ; i++){\\n\\t\\t\\t// each index contains all elements from previous indices along with element at current index\\n            prefixArr[i] = Arrays.copyOf(prefixArr[i-1],26); //add all elements from previous indices\\n            prefixArr[i][s.charAt(i-1) - \\'a\\']++; // add current element\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1269509,
                "title": "c-prefix-frequency-vector-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n            vector<bool>ans;\\n        vector<vector<int>>v(1,vector<int>(26,0));\\n        v[0][s[0]-\\'a\\']++;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            vector<int>t=v[i-1];\\n            t[s[i]-\\'a\\']++;\\n            v.push_back(t);\\n        }\\n        \\n        \\n        for(auto x:queries)\\n        {\\n            int left=x[0],right=x[1],k=x[2];\\n            int arr[26]={0};\\n            for(int i=0;i<26;i++)\\n            {\\n                arr[i]=v[right][i]-v[left][i];\\n            }\\n            arr[s[left]-\\'a\\']++;\\n            \\n            int c=0;\\n              for(int i=0;i<26;i++)\\n              {\\n                  if(arr[i]%2!=0)\\n                      c++;\\n              } \\n            \\n           if(k<(c)/2)\\n           {\\n                 ans.push_back(0);\\n           }\\n            else\\n            {\\n                ans.push_back(1);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/5320557c-7bc5-4a7c-840c-345c5d43192a_1623582907.4345975.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n            vector<bool>ans;\\n        vector<vector<int>>v(1,vector<int>(26,0));\\n        v[0][s[0]-\\'a\\']++;\\n        for(int i=1;i<s.length();i++)\\n        {\\n            vector<int>t=v[i-1];\\n            t[s[i]-\\'a\\']++;\\n            v.push_back(t);\\n        }\\n        \\n        \\n        for(auto x:queries)\\n        {\\n            int left=x[0],right=x[1],k=x[2];\\n            int arr[26]={0};\\n            for(int i=0;i<26;i++)\\n            {\\n                arr[i]=v[right][i]-v[left][i];\\n            }\\n            arr[s[left]-\\'a\\']++;\\n            \\n            int c=0;\\n              for(int i=0;i<26;i++)\\n              {\\n                  if(arr[i]%2!=0)\\n                      c++;\\n              } \\n            \\n           if(k<(c)/2)\\n           {\\n                 ans.push_back(0);\\n           }\\n            else\\n            {\\n                ans.push_back(1);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201798,
                "title": "python3-prefix-freq",
                "content": "\\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        prefix = [[0]*26]\\n        for c in s: \\n            elem = prefix[-1].copy()\\n            elem[ord(c)-97] += 1\\n            prefix.append(elem)\\n        \\n        ans = []\\n        for left, right, k in queries: \\n            cnt = sum(1&(prefix[right+1][i] - prefix[left][i]) for i in range(26))\\n            ans.append(cnt <= 2*k+1)\\n        return ans \\n```\\n\\nEdited on 5/10/2021\\nAdding solution based on \"bit operation\"\\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        prefix = [0]\\n        for c in s: \\n            prefix.append(prefix[-1] ^ (1 << (ord(c)-97)))\\n        \\n        ans = []\\n        for left, right, k in queries: \\n            cnt = bin(prefix[right+1] ^ prefix[left]).count(\"1\")\\n            ans.append(cnt <= 2*k+1)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        prefix = [[0]*26]\\n        for c in s: \\n            elem = prefix[-1].copy()\\n            elem[ord(c)-97] += 1\\n            prefix.append(elem)\\n        \\n        ans = []\\n        for left, right, k in queries: \\n            cnt = sum(1&(prefix[right+1][i] - prefix[left][i]) for i in range(26))\\n            ans.append(cnt <= 2*k+1)\\n        return ans \\n```\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        prefix = [0]\\n        for c in s: \\n            prefix.append(prefix[-1] ^ (1 << (ord(c)-97)))\\n        \\n        ans = []\\n        for left, right, k in queries: \\n            cnt = bin(prefix[right+1] ^ prefix[left]).count(\"1\")\\n            ans.append(cnt <= 2*k+1)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133737,
                "title": "java-solution",
                "content": "Program statements\\n* Calculate pre-sum - this keeps a running sum (or snapshot) of the frequency array for each character at position \\'i\\' in the input string.\\n* Iterate each query. \\n* If k >=13, add true to result. Iteration step is done. The upperBound of oddCount is 26 so the threshold condition would always be true with 2*k (2 x 13 = 26). \\n* If k <13, continue with iteration. Count the number of characters that occur an odd number of times over the given span. If this count falls below threshold, add true to the result, otherwise add false.\\n\\n**Threshold**: an odd number of characters in the span gets one odd character for free so the threshold is 2*k + 1\\n\\n```\\n      public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        var N = s.length();\\n        var f = new int[N + 1][26];\\n        for(int i = 1; i <= N; i++) {\\n            f[i] = Arrays.copyOf(f[i - 1], 26);         \\n            f[i][s.charAt(i - 1) - \\'a\\']++; \\n        }\\n        \\n        var result = new LinkedList<Boolean>();\\n        for(var query : queries) {\\n            var x = query[0];\\n            var y = query[1];\\n            var k = query[2];\\n            var b = true;\\n            if(k < 13) {\\n                var oddCount = 0;\\n                for(int i = 0; i < 26; i++) {\\n                    var z = (f[y + 1][i] - f[x][i]) & 1;\\n                    if(z != 0) oddCount++;                        \\n                }    \\n                var span = y - x + 1;\\n                var threshold = (span & 1) == 0 ? 2*k : 2*k + 1;\\n                b = oddCount <= threshold;         \\n            } \\n            result.add(b); \\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "Program statements\\n* Calculate pre-sum - this keeps a running sum (or snapshot) of the frequency array for each character at position \\'i\\' in the input string.\\n* Iterate each query. \\n* If k >=13, add true to result. Iteration step is done. The upperBound of oddCount is 26 so the threshold condition would always be true with 2*k (2 x 13 = 26). \\n* If k <13, continue with iteration. Count the number of characters that occur an odd number of times over the given span. If this count falls below threshold, add true to the result, otherwise add false.\\n\\n**Threshold**: an odd number of characters in the span gets one odd character for free so the threshold is 2*k + 1\\n\\n```\\n      public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        var N = s.length();\\n        var f = new int[N + 1][26];\\n        for(int i = 1; i <= N; i++) {\\n            f[i] = Arrays.copyOf(f[i - 1], 26);         \\n            f[i][s.charAt(i - 1) - \\'a\\']++; \\n        }\\n        \\n        var result = new LinkedList<Boolean>();\\n        for(var query : queries) {\\n            var x = query[0];\\n            var y = query[1];\\n            var k = query[2];\\n            var b = true;\\n            if(k < 13) {\\n                var oddCount = 0;\\n                for(int i = 0; i < 26; i++) {\\n                    var z = (f[y + 1][i] - f[x][i]) & 1;\\n                    if(z != 0) oddCount++;                        \\n                }    \\n                var span = y - x + 1;\\n                var threshold = (span & 1) == 0 ? 2*k : 2*k + 1;\\n                b = oddCount <= threshold;         \\n            } \\n            result.add(b); \\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 925482,
                "title": "simple-c-easy-linear-time",
                "content": "1. we count all the char at every index.which is no. of char upto that index.\\n2. then we can find count of every char between start and end point of each query.\\n3. so for each query , we need to find the char which count is odd. because for even count no need to replace for palindram. \\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        vector<bool>ans;\\n        vector<vector<int> >v(26,vector<int>(s.size()+1,0));\\n\\t\\t//count the char at every index\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(s[i]-\\'a\\'==j)v[j][i+1]=v[j][i]+1;\\n                else v[j][i+1]=v[j][i];\\n            }\\n        }\\n        // iterate for each query\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int start=q[i][0],end=q[i][1]+1,c=q[i][2],t=0;\\n\\t\\t\\t//find the char which count is odd.\\n            for(int i=0;i<26;i++)\\n            {\\n                t+=(v[i][end]-v[i][start])%2;\\n            }\\n            if(c>=t/2)ans.push_back(1);\\n            else ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        vector<bool>ans;\\n        vector<vector<int> >v(26,vector<int>(s.size()+1,0));\\n\\t\\t//count the char at every index\\n        for(int i=0;i<s.size();i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(s[i]-\\'a\\'==j)v[j][i+1]=v[j][i]+1;\\n                else v[j][i+1]=v[j][i];\\n            }\\n        }\\n        // iterate for each query\\n        for(int i=0;i<q.size();i++)\\n        {\\n            int start=q[i][0],end=q[i][1]+1,c=q[i][2],t=0;\\n\\t\\t\\t//find the char which count is odd.\\n            for(int i=0;i<26;i++)\\n            {\\n                t+=(v[i][end]-v[i][start])%2;\\n            }\\n            if(c>=t/2)ans.push_back(1);\\n            else ans.push_back(0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672743,
                "title": "python-explained-from-scratch-in-the-video",
                "content": "[https://youtu.be/1nUN-s4Y5Y4]\\n\\n```\\n\\t\\tfrom collections import Counter\\n\\n        pre_cnt = [Counter()] * (len(s)+1)\\n        for i in range(1, len(s)+1):\\n            pre_cnt[i] = pre_cnt[i-1] + Counter(s[i-1])\\n        print (\"pre_cnt:\", pre_cnt)\\n        \\n        n = len(queries)\\n        ans = [False for _ in range(n)] \\n        \\n        for i in range(n):\\n            start = queries[i][0]\\n            end = queries[i][1]\\n            k = queries[i][2]\\n            #print (\"s[start:end+1]: \",i, s[start:end+1])\\n            \\n            dict_cnt = pre_cnt[end+1] - pre_cnt[start]\\n            odd_num = 0\\n            for c, cnt in dict_cnt.items():\\n                if cnt %2 != 0:\\n                    odd_num += 1\\n            \\n            if odd_num//2 <= k:         # only half of them changes needed to become palindrome\\n                ans[i] = True\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tfrom collections import Counter\\n\\n        pre_cnt = [Counter()] * (len(s)+1)\\n        for i in range(1, len(s)+1):\\n            pre_cnt[i] = pre_cnt[i-1] + Counter(s[i-1])\\n        print (\"pre_cnt:\", pre_cnt)\\n        \\n        n = len(queries)\\n        ans = [False for _ in range(n)] \\n        \\n        for i in range(n):\\n            start = queries[i][0]\\n            end = queries[i][1]\\n            k = queries[i][2]\\n            #print (\"s[start:end+1]: \",i, s[start:end+1])\\n            \\n            dict_cnt = pre_cnt[end+1] - pre_cnt[start]\\n            odd_num = 0\\n            for c, cnt in dict_cnt.items():\\n                if cnt %2 != 0:\\n                    odd_num += 1\\n            \\n            if odd_num//2 <= k:         # only half of them changes needed to become palindrome\\n                ans[i] = True\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 600042,
                "title": "c-3-solution-prefix-count-prefix-xor-and-xor-of-frequencies",
                "content": "I have provided the three solutions here. They are heavily inspired from this post - https://leetcode.com/problems/can-make-palindrome-from-substring/discuss/371849/JavaPython-3-3-codes-each%3A-prefix-sum-boolean-and-xor-of-characters\\'-frequencies-then-compare\\n\\n**Solution One** -\\n\\nCompute the prefix sum by counting the number of chars in `substring(0,1), substring(0, 2), ..., substring(0,n)`\\nUse the difference of the prefix sums to get the the number of chars in `substring(queries[i][0], queries[i][1])`, count those which do NOT fall in symmetric pairs, divided by 2, and compare it with queries[i][2].\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.length();\\n        vector<vector<int>> count(n+1, vector<int>(26,0));\\n        for(int i=0;i<n;i++){\\n            count[i+1]=count[i];     //count[i+1].assign(begin(count[i]), end(count[i]));\\n            count[i+1][s[i]-\\'a\\']++;\\n        }\\n        vector<bool> res;\\n        for(auto q:queries){\\n            int sum=0;\\n            for(int i=0;i<26;i++) sum+=(count[q[1]+1][i]-count[q[0]][i])%2;\\n            res.push_back((sum/2)<=q[2]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Solution Two**\\n\\nUse `1/0` to mark odd/even of the count of each character. We will use XOR for that.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.length();\\n        vector<vector<int>> count(n+1, vector<int>(26,0));\\n        for(int i=0;i<n;i++){\\n            count[i+1]=count[i];     //count[i+1].assign(begin(count[i]), end(count[i]));\\n            count[i+1][s[i]-\\'a\\']^=1;\\n        }\\n        vector<bool> res;\\n        for(auto q:queries){\\n            int sum=0;\\n            for(int i=0;i<26;i++) sum+=(count[q[1]+1][i]^count[q[0]][i]);\\n            res.push_back((sum/2)<=q[2]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Solution Three**\\n\\nWe can represent the count array using an integer (32 bits). The idea is the same as that of the above solution.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.length();\\n        vector<int> odds(n+1, 0);\\n        for(int i=0;i<n;i++){\\n            odds[i+1]=odds[i]^(1<<(s[i]-\\'a\\'));\\n        }\\n        vector<bool> res;\\n        for(auto q:queries){\\n\\t\\t\\t// __builtin_popcount calculates the number of set bits\\n            int sum=__builtin_popcount(odds[q[1]+1]^odds[q[0]]);\\n            res.push_back((sum/2)<=q[2]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n*Time Complexity* - `O(n + q*26)`\\n*Space Complexity* - `O(n)` for the 3rd method\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.length();\\n        vector<vector<int>> count(n+1, vector<int>(26,0));\\n        for(int i=0;i<n;i++){\\n            count[i+1]=count[i];     //count[i+1].assign(begin(count[i]), end(count[i]));\\n            count[i+1][s[i]-\\'a\\']++;\\n        }\\n        vector<bool> res;\\n        for(auto q:queries){\\n            int sum=0;\\n            for(int i=0;i<26;i++) sum+=(count[q[1]+1][i]-count[q[0]][i])%2;\\n            res.push_back((sum/2)<=q[2]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.length();\\n        vector<vector<int>> count(n+1, vector<int>(26,0));\\n        for(int i=0;i<n;i++){\\n            count[i+1]=count[i];     //count[i+1].assign(begin(count[i]), end(count[i]));\\n            count[i+1][s[i]-\\'a\\']^=1;\\n        }\\n        vector<bool> res;\\n        for(auto q:queries){\\n            int sum=0;\\n            for(int i=0;i<26;i++) sum+=(count[q[1]+1][i]^count[q[0]][i]);\\n            res.push_back((sum/2)<=q[2]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.length();\\n        vector<int> odds(n+1, 0);\\n        for(int i=0;i<n;i++){\\n            odds[i+1]=odds[i]^(1<<(s[i]-\\'a\\'));\\n        }\\n        vector<bool> res;\\n        for(auto q:queries){\\n\\t\\t\\t// __builtin_popcount calculates the number of set bits\\n            int sum=__builtin_popcount(odds[q[1]+1]^odds[q[0]]);\\n            res.push_back((sum/2)<=q[2]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535034,
                "title": "java-prefix-and-xor",
                "content": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] qs) {\\n        int[][] cnt = new int[s.length() + 1][26];\\n        int i = 0;\\n        for (char c : s.toCharArray()) {\\n            cnt[i + 1] = cnt[i].clone();\\n            ++cnt[++i][c - \\'a\\'];\\n        }\\n        List<Boolean> res = new ArrayList<>();\\n        for (int[] q : qs) {\\n            int sum = (q[1] - q[0]) % 2;\\n            for (i = 0; i < 26; i++){\\n                sum += (cnt[q[1]+1][i] - cnt[q[0]][i]) % 2;\\n            }\\n            res.add(sum / 2 <= q[2]);  // if odd, just put it in center;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n```\\npublic List<Boolean> canMakePaliQueries(String s, int[][] qs) {\\n        int[] cnt = new int[s.length() + 1];\\n        int i = 0;\\n        for (char c : s.toCharArray()) {\\n            cnt[i + 1] = cnt[i++] ^ (1 << (c - \\'a\\'));\\n        }\\n        List<Boolean> res = new ArrayList<>();\\n        for (int[] q : qs) {\\n            int sum = (q[1] - q[0]) % 2;\\n            sum += Integer.bitCount(cnt[q[1] + 1] ^ cnt[q[0]]);\\n            res.add(sum / 2 <= q[2]);  // if odd, just put it in center;\\n        }\\n        return res;\\n    }\\n```\\nRef: https://leetcode.com/problems/can-make-palindrome-from-substring/discuss/371849/JavaPython-3-3-codes-each%3A-prefix-sum-boolean-and-xor-of-characters\\'-frequencies-then-compare",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] qs) {\\n        int[][] cnt = new int[s.length() + 1][26];\\n        int i = 0;\\n        for (char c : s.toCharArray()) {\\n            cnt[i + 1] = cnt[i].clone();\\n            ++cnt[++i][c - \\'a\\'];\\n        }\\n        List<Boolean> res = new ArrayList<>();\\n        for (int[] q : qs) {\\n            int sum = (q[1] - q[0]) % 2;\\n            for (i = 0; i < 26; i++){\\n                sum += (cnt[q[1]+1][i] - cnt[q[0]][i]) % 2;\\n            }\\n            res.add(sum / 2 <= q[2]);  // if odd, just put it in center;\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\npublic List<Boolean> canMakePaliQueries(String s, int[][] qs) {\\n        int[] cnt = new int[s.length() + 1];\\n        int i = 0;\\n        for (char c : s.toCharArray()) {\\n            cnt[i + 1] = cnt[i++] ^ (1 << (c - \\'a\\'));\\n        }\\n        List<Boolean> res = new ArrayList<>();\\n        for (int[] q : qs) {\\n            int sum = (q[1] - q[0]) % 2;\\n            sum += Integer.bitCount(cnt[q[1] + 1] ^ cnt[q[0]]);\\n            res.add(sum / 2 <= q[2]);  // if odd, just put it in center;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444303,
                "title": "java-easy-solution",
                "content": "Java very easy to understand solution: \\n\\n```Java\\n  private int[][] table;\\n\\n  public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n    int len = s.length();\\n    table = new int[len][26];\\n    for (int i = 0; i < len; i++) {\\n      table[i] = i == 0 ? new int[26] : table[i - 1].clone();\\n      table[i][s.charAt(i) - \\'a\\']++;\\n    }\\n    List<Boolean> res = new ArrayList<>();\\n    for (int i = 0; i < queries.length; i++) {\\n      res.add(f(queries[i]));\\n    }\\n    return res;\\n  }\\n\\n  private boolean f(int[] arr) {\\n    int left = arr[0];\\n    int right = arr[1];\\n    int k = arr[2];\\n    if (left == right) {\\n      return true;\\n    }\\n    int odd = 0;\\n    int[] tableRight = table[right];\\n    if (left == 0) {\\n      for (int i = 0; i < 26; i++) {\\n        if (tableRight[i] % 2 == 1) {\\n          odd++;\\n        }\\n      }\\n    } else {\\n      int[] tableLeft = table[left - 1];\\n      for (int i = 0; i < 26; i++) {\\n        if ((tableRight[i] - tableLeft[i]) % 2 == 1) {\\n          odd++;\\n        }\\n      }\\n    }\\n    return (odd / 2) <= k;\\n  }\\n```\\n\\n\\n\\nMy Scala solution uses the same idea, but TLE \\n```Scala\\n\\n  def canMakePaliQueries(s: String, queries: Array[Array[Int]]): Array[Boolean] = {\\n\\n    val len = s.length\\n    val table = Array.ofDim[Array[Int]](len)\\n    for (i <- 0 until len) {\\n      val ta = if (i == 0) Array.ofDim[Int](26) else table(i - 1).clone()\\n      ta((s.charAt(i) - \\'a\\')) += 1\\n      table(i) = ta\\n    }\\n\\n    def f(arr: Array[Int]): Boolean = {\\n      val left = arr(0)\\n      val right = arr(1)\\n      val k = arr(2)\\n      if (left == right) return true\\n      var oddCount = 0\\n      val tableRight = table(right)\\n      if (left == 0) {\\n        for (i <- 0 until 26) if (tableRight(i) % 2 == 1) oddCount += 1\\n      } else {\\n        val tableLeft = table(left - 1)\\n        for (i <- 0 until 26) if ((tableRight(i) - tableLeft(i)) % 2 == 1) oddCount += 1\\n      }\\n      (oddCount / 2) <= arr(2)\\n    }\\n    \\n    queries.par.map(f).toArray\\n  }\\n```",
                "solutionTags": [],
                "code": "```Java\\n  private int[][] table;\\n\\n  public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n    int len = s.length();\\n    table = new int[len][26];\\n    for (int i = 0; i < len; i++) {\\n      table[i] = i == 0 ? new int[26] : table[i - 1].clone();\\n      table[i][s.charAt(i) - \\'a\\']++;\\n    }\\n    List<Boolean> res = new ArrayList<>();\\n    for (int i = 0; i < queries.length; i++) {\\n      res.add(f(queries[i]));\\n    }\\n    return res;\\n  }\\n\\n  private boolean f(int[] arr) {\\n    int left = arr[0];\\n    int right = arr[1];\\n    int k = arr[2];\\n    if (left == right) {\\n      return true;\\n    }\\n    int odd = 0;\\n    int[] tableRight = table[right];\\n    if (left == 0) {\\n      for (int i = 0; i < 26; i++) {\\n        if (tableRight[i] % 2 == 1) {\\n          odd++;\\n        }\\n      }\\n    } else {\\n      int[] tableLeft = table[left - 1];\\n      for (int i = 0; i < 26; i++) {\\n        if ((tableRight[i] - tableLeft[i]) % 2 == 1) {\\n          odd++;\\n        }\\n      }\\n    }\\n    return (odd / 2) <= k;\\n  }\\n```\n```Scala\\n\\n  def canMakePaliQueries(s: String, queries: Array[Array[Int]]): Array[Boolean] = {\\n\\n    val len = s.length\\n    val table = Array.ofDim[Array[Int]](len)\\n    for (i <- 0 until len) {\\n      val ta = if (i == 0) Array.ofDim[Int](26) else table(i - 1).clone()\\n      ta((s.charAt(i) - \\'a\\')) += 1\\n      table(i) = ta\\n    }\\n\\n    def f(arr: Array[Int]): Boolean = {\\n      val left = arr(0)\\n      val right = arr(1)\\n      val k = arr(2)\\n      if (left == right) return true\\n      var oddCount = 0\\n      val tableRight = table(right)\\n      if (left == 0) {\\n        for (i <- 0 until 26) if (tableRight(i) % 2 == 1) oddCount += 1\\n      } else {\\n        val tableLeft = table(left - 1)\\n        for (i <- 0 until 26) if ((tableRight(i) - tableLeft(i)) % 2 == 1) oddCount += 1\\n      }\\n      (oddCount / 2) <= arr(2)\\n    }\\n    \\n    queries.par.map(f).toArray\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 399598,
                "title": "c-easy-to-understand",
                "content": "```\\n\\t\\tvector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n\\t\\t\\tvector<vector<int>> maps;\\n\\t\\t\\tvector<int> map(26, 0);\\n\\n\\t\\t\\tmaps.push_back(map);\\n\\n\\t\\t\\tfor (char c : s) {\\n\\t\\t\\t\\tmap[c - \\'a\\']++;\\n\\t\\t\\t\\tmaps.push_back(map);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<bool> result;\\n\\t\\t\\tfor (vector<int>& q : queries) {\\n\\t\\t\\t\\tint low = q[0];\\n\\t\\t\\t\\tint high = q[1];\\n\\t\\t\\t\\tint k = q[2];\\n\\n\\t\\t\\t\\tint diff = 0;\\n\\t\\t\\t\\tint oddCount = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\t\\t\\tdiff = maps[high + 1][i] - maps[low][i];\\n\\t\\t\\t\\t\\toddCount += diff % 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult.push_back(oddCount / 2 <= k);\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tvector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n\\t\\t\\tvector<vector<int>> maps;\\n\\t\\t\\tvector<int> map(26, 0);\\n\\n\\t\\t\\tmaps.push_back(map);\\n\\n\\t\\t\\tfor (char c : s) {\\n\\t\\t\\t\\tmap[c - \\'a\\']++;\\n\\t\\t\\t\\tmaps.push_back(map);\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<bool> result;\\n\\t\\t\\tfor (vector<int>& q : queries) {\\n\\t\\t\\t\\tint low = q[0];\\n\\t\\t\\t\\tint high = q[1];\\n\\t\\t\\t\\tint k = q[2];\\n\\n\\t\\t\\t\\tint diff = 0;\\n\\t\\t\\t\\tint oddCount = 0;\\n\\t\\t\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\t\\t\\tdiff = maps[high + 1][i] - maps[low][i];\\n\\t\\t\\t\\t\\toddCount += diff % 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult.push_back(oddCount / 2 <= k);\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3915491,
                "title": "python-o-n-bit-manipulation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\'\\'\\'\\nFirst how to check if a string rearranged can be a palindrome:\\n1. If length is even, Counter(string) needs to yield even counts for all letters\\n2. If length is odd, Counter(string) needs to yield even counts for all letters except one\\n\\nHow does replacement effect things?\\nFind how many odd counts are off, if that number is higher than k(i)*2 then it cannot be a palindrome\\n\\nNow how to handle many queries in sub-quadratic time. Ideas:\\n\\n1. Keep running totals for all 26 letters? This will allow in O(26) time to get frequencies of all 26 lowercase English letters between i and j\\n\\nTime complexity: len(alphabet)*len(s) == 26*len(s) which is about same as a n log2(n) approach over 32 bit integer range. Over larger range this approach is asymptotically linear.\\n\\nImprovement: Also arguably don\\'t even need to count frequencies? Can just use a bitmask to see if was_frequency_odd at a given time.\\n\\'\\'\\'\\n\\nfrom collections import Counter\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        counter = 0\\n        running_totals = []\\n        for c in s:\\n            counter ^= 1 << (ord(c) - ord(\\'a\\'))\\n            running_totals.append(counter)\\n        result = []\\n        for left, right, k in queries:\\n            frequencies = running_totals[right]\\n            if left > 0:\\n                frequencies ^= running_totals[left-1]\\n            result.append(k >= frequencies.bit_count() // 2)\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\'\\'\\'\\nFirst how to check if a string rearranged can be a palindrome:\\n1. If length is even, Counter(string) needs to yield even counts for all letters\\n2. If length is odd, Counter(string) needs to yield even counts for all letters except one\\n\\nHow does replacement effect things?\\nFind how many odd counts are off, if that number is higher than k(i)*2 then it cannot be a palindrome\\n\\nNow how to handle many queries in sub-quadratic time. Ideas:\\n\\n1. Keep running totals for all 26 letters? This will allow in O(26) time to get frequencies of all 26 lowercase English letters between i and j\\n\\nTime complexity: len(alphabet)*len(s) == 26*len(s) which is about same as a n log2(n) approach over 32 bit integer range. Over larger range this approach is asymptotically linear.\\n\\nImprovement: Also arguably don\\'t even need to count frequencies? Can just use a bitmask to see if was_frequency_odd at a given time.\\n\\'\\'\\'\\n\\nfrom collections import Counter\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        counter = 0\\n        running_totals = []\\n        for c in s:\\n            counter ^= 1 << (ord(c) - ord(\\'a\\'))\\n            running_totals.append(counter)\\n        result = []\\n        for left, right, k in queries:\\n            frequencies = running_totals[right]\\n            if left > 0:\\n                frequencies ^= running_totals[left-1]\\n            result.append(k >= frequencies.bit_count() // 2)\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273324,
                "title": "seg-tree-o-lgn-extra-memory-for-map-map-k-v",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        \\n        System.out.println(s.length());\\n        Bro bro = new Bro(s);\\n        \\n        List< Boolean > list = new ArrayList<>();\\n\\n        for(int[] a : queries){\\n            int[] arr = bro.find(a[0],a[1]);\\n            int odd = 0;\\n            for(int b : arr) if(b % 2 != 0) odd++;\\n            odd /= 2;\\n            if(odd <= a[2]) list.add(true);\\n            else list.add(false);            \\n        }\\n\\n        return list;\\n    }\\n}\\n\\nclass Bro{\\n    Map< Integer, Map < Integer, Integer >  > map = new HashMap<>();\\n    int start = 0, size = 1;\\n    int[] arr;\\n    public Bro(String s){\\n        int n = s.length();\\n        while(size < n) size *= 2;\\n        start = size - 1;\\n        for(int i = 0; i < n; i++){\\n            int c = s.charAt(i) - 97;\\n            Map< Integer , Integer > m = new HashMap<>();\\n            m.put(c,1);\\n            map.put(start + i, m);\\n        }\\n        for(int i = n + start; i < size * 2; i++){\\n            Map< Integer , Integer > m = new HashMap<>();\\n            m.put(25,0);\\n            map.put(i, m);\\n        }\\n\\n        for(int i = start - 1; i >= 0; i--){\\n            Map< Integer , Integer > m = new HashMap<>();\\n            Map< Integer , Integer > h = map.get(i * 2 + 1);\\n            Map< Integer , Integer > c = map.get(i * 2 + 2);\\n\\n            for(Integer q : h.keySet()){\\n                m.put(q,h.get(q));\\n            }\\n            for(Integer q : c.keySet()){\\n                m.put(q,m.getOrDefault(q,0) + c.get(q));\\n            }            \\n            map.put(i,m);\\n        }\\n        \\n    }\\n    public int[] find(int left, int right){\\n        arr = new int[26];\\n        find(left, right, 0,0,size - 1);\\n        return arr;\\n    }\\n    public void find(int left, int right, int ind, int lx, int rx){\\n        \\n        if(lx > right || rx < left) return;\\n        if(lx >= left && rx <= right){\\n            Map< Integer, Integer > m = map.get(ind);\\n            for(Integer l : m.keySet()){\\n                arr[l] += m.get(l);\\n            }\\n            return;\\n        }\\n\\n        int mid = (lx + rx) / 2;\\n\\n        find(left, right, ind * 2 + 1, lx, mid);\\n        find(left, right, ind * 2 + 2, mid + 1, rx);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        \\n        System.out.println(s.length());\\n        Bro bro = new Bro(s);\\n        \\n        List< Boolean > list = new ArrayList<>();\\n\\n        for(int[] a : queries){\\n            int[] arr = bro.find(a[0],a[1]);\\n            int odd = 0;\\n            for(int b : arr) if(b % 2 != 0) odd++;\\n            odd /= 2;\\n            if(odd <= a[2]) list.add(true);\\n            else list.add(false);            \\n        }\\n\\n        return list;\\n    }\\n}\\n\\nclass Bro{\\n    Map< Integer, Map < Integer, Integer >  > map = new HashMap<>();\\n    int start = 0, size = 1;\\n    int[] arr;\\n    public Bro(String s){\\n        int n = s.length();\\n        while(size < n) size *= 2;\\n        start = size - 1;\\n        for(int i = 0; i < n; i++){\\n            int c = s.charAt(i) - 97;\\n            Map< Integer , Integer > m = new HashMap<>();\\n            m.put(c,1);\\n            map.put(start + i, m);\\n        }\\n        for(int i = n + start; i < size * 2; i++){\\n            Map< Integer , Integer > m = new HashMap<>();\\n            m.put(25,0);\\n            map.put(i, m);\\n        }\\n\\n        for(int i = start - 1; i >= 0; i--){\\n            Map< Integer , Integer > m = new HashMap<>();\\n            Map< Integer , Integer > h = map.get(i * 2 + 1);\\n            Map< Integer , Integer > c = map.get(i * 2 + 2);\\n\\n            for(Integer q : h.keySet()){\\n                m.put(q,h.get(q));\\n            }\\n            for(Integer q : c.keySet()){\\n                m.put(q,m.getOrDefault(q,0) + c.get(q));\\n            }            \\n            map.put(i,m);\\n        }\\n        \\n    }\\n    public int[] find(int left, int right){\\n        arr = new int[26];\\n        find(left, right, 0,0,size - 1);\\n        return arr;\\n    }\\n    public void find(int left, int right, int ind, int lx, int rx){\\n        \\n        if(lx > right || rx < left) return;\\n        if(lx >= left && rx <= right){\\n            Map< Integer, Integer > m = map.get(ind);\\n            for(Integer l : m.keySet()){\\n                arr[l] += m.get(l);\\n            }\\n            return;\\n        }\\n\\n        int mid = (lx + rx) / 2;\\n\\n        find(left, right, ind * 2 + 1, lx, mid);\\n        find(left, right, ind * 2 + 2, mid + 1, rx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925811,
                "title": "python3-speed-and-space-90",
                "content": "# Intuition\\nFor every query, we only need to know the number of every letter is even or odd in the substring to get minimum replacement needed. Because there is only 26 letters, we can use a int bitmask to store the parity of every letter in the string.\\n# Approach\\nUse another array mem with length len(s)+1 to store states of substring. Go through the string and for every char do mask ^= 1 << (char - \\'a\\'). mem[i] is the state of substring s[0: i-1], storing the parity of every letter in the substring.\\n\\nThen for every query, we get the state of s[left: right+1] from mem[right+1] ^ mem[left], for every replacement we are allowed to make, we eliminate 2 letter that are not even, if 1 or 0 letter are left as odd after all replacements, then it is a palindrome. n &= (n-1) set the last 1 bit to 0, which is setting an odd letter to even in this case.\\n\\n# Complexity\\n- Time complexity:\\nO(M+N), M is length of s and N is length of N\\n\\n- Space complexity:\\nO(M)\\n\\n# Code\\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        l = len(s)\\n        mem = [0] * (l+1)\\n        mask = 0\\n        for i in range(l):\\n            idx = ord(s[i]) - ord(\\'a\\')\\n            mask ^= 1 << idx\\n            mem[i+1] = mask\\n        \\n        ans = [False] * len(queries)\\n        for i in range(len(queries)):\\n            left,right,k = queries[i]\\n            chars = mem[right+1] ^ mem[left]\\n            for j in range(k):\\n                if chars == 0:\\n                    break\\n                chars &= (chars-1)\\n                chars &= (chars-1)\\n            chars &= (chars-1)\\n            if chars == 0:\\n                ans[i] = True\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        l = len(s)\\n        mem = [0] * (l+1)\\n        mask = 0\\n        for i in range(l):\\n            idx = ord(s[i]) - ord(\\'a\\')\\n            mask ^= 1 << idx\\n            mem[i+1] = mask\\n        \\n        ans = [False] * len(queries)\\n        for i in range(len(queries)):\\n            left,right,k = queries[i]\\n            chars = mem[right+1] ^ mem[left]\\n            for j in range(k):\\n                if chars == 0:\\n                    break\\n                chars &= (chars-1)\\n                chars &= (chars-1)\\n            chars &= (chars-1)\\n            if chars == 0:\\n                ans[i] = True\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2667296,
                "title": "python-solution",
                "content": "```\\ndef canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n\\tpsum = [[0]*26]\\n\\tfor c in s:\\n\\t\\tpsum.append(psum[-1][:])\\n\\t\\tpsum[-1][ord(c)-ord(\\'a\\')] += 1\\n\\t\\tpsum[-1][ord(c)-ord(\\'a\\')] %= 2\\n\\n\\treturn [sum(psum[j+1][x]^psum[i][x] for x in range(26))//2<=k for i, j, k in queries]\\n```",
                "solutionTags": [],
                "code": "```\\ndef canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n\\tpsum = [[0]*26]\\n\\tfor c in s:\\n\\t\\tpsum.append(psum[-1][:])\\n\\t\\tpsum[-1][ord(c)-ord(\\'a\\')] += 1\\n\\t\\tpsum[-1][ord(c)-ord(\\'a\\')] %= 2\\n\\n\\treturn [sum(psum[j+1][x]^psum[i][x] for x in range(26))//2<=k for i, j, k in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2604132,
                "title": "what-s-wrong-with-my-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool> sol;\\n        unordered_map<char,int> m;\\n        int count=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int start=queries[i][0];\\n            int end=queries[i][1];\\n            int count=0;\\n            while(start<end)\\n            {\\n                m[s[start]]++;\\n                if(m[s[start]]%2==0 &&count!=0) count--;\\n                else count++;\\n                m[s[end]]++;\\n                if(m[s[end]]%2==0 && count!=0) count--;\\n                else count++;\\n                start++;\\n                end--;\\n            }\\n            if(count/2<=queries[i][2]) sol.push_back(true);\\n            else \\n            {\\n                sol.push_back(false);\\n                // cout<<queries[i][0]<<\" \"<<queries[i][1]<<endl;\\n            }\\n            m.clear();\\n        }\\n        // cout<<sol.size()<<\" \"<<queries.size()<<endl;\\n        return sol;\\n    }\\n};\\n```\\n\\nIt fails in this test case:\\nTake string from:\\nhttps://leetcode.com/submissions/detail/805046680/testcase/\\nquery is [[3097,3257,5]]",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool> sol;\\n        unordered_map<char,int> m;\\n        int count=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int start=queries[i][0];\\n            int end=queries[i][1];\\n            int count=0;\\n            while(start<end)\\n            {\\n                m[s[start]]++;\\n                if(m[s[start]]%2==0 &&count!=0) count--;\\n                else count++;\\n                m[s[end]]++;\\n                if(m[s[end]]%2==0 && count!=0) count--;\\n                else count++;\\n                start++;\\n                end--;\\n            }\\n            if(count/2<=queries[i][2]) sol.push_back(true);\\n            else \\n            {\\n                sol.push_back(false);\\n                // cout<<queries[i][0]<<\" \"<<queries[i][1]<<endl;\\n            }\\n            m.clear();\\n        }\\n        // cout<<sol.size()<<\" \"<<queries.size()<<endl;\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2531913,
                "title": "c-prefix-bitmask-with-explaination-beats-96-in-time-and-93-in-space",
                "content": "Since we can rearrange all characters in substring, **we only need to consider the parity of the occurence of each character in substring**, and this is the essential point of why we can use bitmask for info storage.\\n\\nBy preprocessing the parity of occurence by using a integer to store the state - `0` for even and `1` for odd, we can easily get the parity of any substring using `XOR` command.\\n\\nFurther, one more case is the parity of the length of the substring,\\n* if `len(substr)` is odd, we can put one extra single character at the center of the substring while it\\'s still palindrome\\n* if `len(substr)` is even, then only paired characters are accepted\\n\\nWe count all single characters (minus one when length is odd), and calling it `cnt`. Now, we only need to change half of them on one side to match with the corresponding character on the other side, so push `true` when `k` is greater than `cnt /  2` in even case and `(cnt - 1) / 2` in odd case, then false otherwise, which should be the final correct result\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<unsigned int> bitPre(s.size(), 0); \\n        for (int i = 0; i < s.size(); i++) { // only need to record parity of each character using XOR\\n            int idx = s[i] - \\'a\\';\\n            if (i == 0) bitPre[i] = 1 << idx;\\n            else bitPre[i] = bitPre[i - 1] ^ (1 << idx);\\n        }\\n        vector<bool> res;\\n        for (auto &q: queries) {\\n            int l = q[0], r = q[1], k = q[2];\\n            unsigned int bits = bitPre[r];\\n            if (l > 0) bits ^= bitPre[l - 1]; \\n            if ((l - r + 1) % 2 == 0) { // check length parity\\n                int cnt = __builtin_popcount(bits); // count number of 1 inside bits\\n                res.push_back(cnt / 2 <= k);\\n            } else {\\n                int cnt = __builtin_popcount(bits); // count number of 1 inside bits\\n                res.push_back((cnt - 1) / 2 <= k);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<unsigned int> bitPre(s.size(), 0); \\n        for (int i = 0; i < s.size(); i++) { // only need to record parity of each character using XOR\\n            int idx = s[i] - \\'a\\';\\n            if (i == 0) bitPre[i] = 1 << idx;\\n            else bitPre[i] = bitPre[i - 1] ^ (1 << idx);\\n        }\\n        vector<bool> res;\\n        for (auto &q: queries) {\\n            int l = q[0], r = q[1], k = q[2];\\n            unsigned int bits = bitPre[r];\\n            if (l > 0) bits ^= bitPre[l - 1]; \\n            if ((l - r + 1) % 2 == 0) { // check length parity\\n                int cnt = __builtin_popcount(bits); // count number of 1 inside bits\\n                res.push_back(cnt / 2 <= k);\\n            } else {\\n                int cnt = __builtin_popcount(bits); // count number of 1 inside bits\\n                res.push_back((cnt - 1) / 2 <= k);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521636,
                "title": "python-solution-character-count-prefix-sum",
                "content": "```\\nclass Solution:\\n    # Since we are free to rearrange the substring, order within substring does not matter\\n    # To be eligible for being palindrome, we have two scenarios:\\n    # 1. The string is even-length: no odd occurrence allowed\\n    # 2. The string is odd-length: only 1 odd occurrence allowed\\n    # How to get character occurrence within substrings quickly? prefix sum of the hash count\\n    # How to decide if a given hash count within substring is ok?\\n    # For each odd, we match with another odd such that the number of pairs <= k\\n    # For example abcd, we change b to c and d to a\\n    # if it is abcde, we change d and e, no need to touch c\\n    # -> odd_count // 2 <= k for even\\n    # -> odd_count // 2 <= k for odd -> They are the same!\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        n, hash_table= len(s), [[0]*26]\\n        for c in s:\\n            row = hash_table[-1][:]\\n            row[ord(c)-ord(\\'a\\')] += 1\\n            hash_table.append(row)\\n        \\n        result = []\\n        for left, right, k in queries:\\n            odd_count = 0\\n            for i in range(26):\\n                if (hash_table[right+1][i] - hash_table[left][i]) % 2 == 1:\\n                    odd_count += 1\\n            result.append(odd_count // 2 <= k)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Since we are free to rearrange the substring, order within substring does not matter\\n    # To be eligible for being palindrome, we have two scenarios:\\n    # 1. The string is even-length: no odd occurrence allowed\\n    # 2. The string is odd-length: only 1 odd occurrence allowed\\n    # How to get character occurrence within substrings quickly? prefix sum of the hash count\\n    # How to decide if a given hash count within substring is ok?\\n    # For each odd, we match with another odd such that the number of pairs <= k\\n    # For example abcd, we change b to c and d to a\\n    # if it is abcde, we change d and e, no need to touch c\\n    # -> odd_count // 2 <= k for even\\n    # -> odd_count // 2 <= k for odd -> They are the same!\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        n, hash_table= len(s), [[0]*26]\\n        for c in s:\\n            row = hash_table[-1][:]\\n            row[ord(c)-ord(\\'a\\')] += 1\\n            hash_table.append(row)\\n        \\n        result = []\\n        for left, right, k in queries:\\n            odd_count = 0\\n            for i in range(26):\\n                if (hash_table[right+1][i] - hash_table[left][i]) % 2 == 1:\\n                    odd_count += 1\\n            result.append(odd_count // 2 <= k)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430106,
                "title": "c-prefix-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<int> pref; pref.push_back(0);\\n        for(char c : s) {\\n            int i = c-\\'a\\';\\n            pref.push_back(pref.back() ^ (1<<i));\\n        }\\n        vector<bool> ans;\\n        for(auto &q : queries) {\\n            int mask = pref[q[0]]^pref[q[1]+1];\\n            int mnc = __builtin_popcount(mask)/2;\\n            ans.push_back(mnc<=q[2]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nbitmask ranges from 0 to (1<<26)-1 where set bit signifies the frequency of character is odd, with every operation we can eliminate 2 set bits from the mask obtained.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Prefix Sum",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<int> pref; pref.push_back(0);\\n        for(char c : s) {\\n            int i = c-\\'a\\';\\n            pref.push_back(pref.back() ^ (1<<i));\\n        }\\n        vector<bool> ans;\\n        for(auto &q : queries) {\\n            int mask = pref[q[0]]^pref[q[1]+1];\\n            int mnc = __builtin_popcount(mask)/2;\\n            ans.push_back(mnc<=q[2]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345589,
                "title": "c-odd-mask-time-o-n-q-space-o-n",
                "content": "Odd Mask solution\\n* we are allowed to **rearrange** the requested ranges of `s` and **change** certain number of chars within a given quota\\n* since we can always form a palindrome by rearranging any even number of chars without using quota, e.g. 2c6f4z\\n* we focus on odd number of chars for the requested ranges, the following formula tells us `to use n/2 quota for n number of odds`\\n* preprocess the odd number state by using bit mask (this step aims for time optimization)\\n* for each query, calculate the remaining odd number of chars for the requested range by using **XOR** bit manipulation\\n* apply the formula and output the result\\n\\n\\n![image](https://assets.leetcode.com/users/images/e2f5a2d2-9485-4488-9cdb-8b8cb49dabc1_1659006462.6289032.png)\\n\\n\\n\\n```\\n// n = len of s\\n// q = size of queries\\n// time: O(n + q)\\n// space: O(n)\\n\\nclass Solution {\\npublic:\\n  vector<bool> canMakePaliQueries(string& s, vector<vector<int>>& queries) {\\n    int n = s.length();\\n    vector<int> prefixOddMasks (n + 1);\\n    for (int i = 1, oddMask = 0; i <= n; i++) {\\n      prefixOddMasks[i] = oddMask ^= 1 << (s[i-1] - \\'a\\');\\n    }\\n    \\n    int q = queries.size();\\n    vector<bool> result (q);\\n    for (int i = 0; i < q; i++) {\\n      int l = queries[i][0];\\n      int r = queries[i][1];\\n      int quota = queries[i][2];\\n      int oddMask = prefixOddMasks[l] ^ prefixOddMasks[r+1]; // set or deduce bits \\'1\\' in range [l, r]\\n      int oddCount = __builtin_popcount(oddMask); // count number of bits \\'1\\' => number of odds\\n      result[i] = oddCount / 2 <= quota; // our formula\\n    }\\n    \\n    return result;\\n  }\\n};\\n```\\n\\nThanks for watching : )",
                "solutionTags": [],
                "code": "```\\n// n = len of s\\n// q = size of queries\\n// time: O(n + q)\\n// space: O(n)\\n\\nclass Solution {\\npublic:\\n  vector<bool> canMakePaliQueries(string& s, vector<vector<int>>& queries) {\\n    int n = s.length();\\n    vector<int> prefixOddMasks (n + 1);\\n    for (int i = 1, oddMask = 0; i <= n; i++) {\\n      prefixOddMasks[i] = oddMask ^= 1 << (s[i-1] - \\'a\\');\\n    }\\n    \\n    int q = queries.size();\\n    vector<bool> result (q);\\n    for (int i = 0; i < q; i++) {\\n      int l = queries[i][0];\\n      int r = queries[i][1];\\n      int quota = queries[i][2];\\n      int oddMask = prefixOddMasks[l] ^ prefixOddMasks[r+1]; // set or deduce bits \\'1\\' in range [l, r]\\n      int oddCount = __builtin_popcount(oddMask); // count number of bits \\'1\\' => number of odds\\n      result[i] = oddCount / 2 <= quota; // our formula\\n    }\\n    \\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333556,
                "title": "c-solution-with-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int len = s.length();\\n        vector<vector<int>> cnt(26, vector<int> (len, 0));\\n        cnt[s[0] - \\'a\\'][0]++;\\n        \\n        /*\\n            cnt[c - \\'a\\'][i] : represents the number of occurrences of the character c, till the index i in the string s\\n            \\n            so to find out the frequency of some character c in the range l to r\\n            \\n            freq = cnt[c - \\'a\\'][r] - cnt[c - \\'a\\'][l - 1]\\n            \\n            now how to check whether it can be rearranged into a palindrome, given that we can change at most k characters \\n            lets say we have this \\n            a b d c c c m m m m m k k k a\\n            \\n            k, m, c, b, d\\n            we can place it like this \\n            \\n            a k m m c ______ c m m k a\\n            \\n            now after doing this the remaining spots are to be filled \\n            other are already matched\\n            we will place the remaining c in the middle\\n            k can be transformed into b, and c can be transformed into d\\n            \\n            so the number of transformations we need is : (number of character with odd frequency) / 2\\n            \\n            \\n        */\\n        \\n        for(int i = 1; i < len; i++) {\\n            cnt[s[i] - \\'a\\'][i] = 1;\\n            for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                 cnt[c - \\'a\\'][i]+=cnt[c - \\'a\\'][i - 1];\\n                    \\n            }\\n        }\\n                \\n        int qLen = queries.size();\\n        vector<bool> ans(qLen, 0);\\n        for(int i = 0; i < qLen; i++) {\\n            auto q = queries[i];\\n            int li = q[0], ri = q[1];\\n    \\n            int oddCount = 0;\\n            for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                int curCount = cnt[c - \\'a\\'][ri] - (li > 0 ? cnt[c - \\'a\\'][li - 1] : 0);            \\n                if(curCount % 2) oddCount++;\\n            }\\n            \\n            int changedNeeded = oddCount / 2;\\n            ans[i] = changedNeeded <= q[2];\\n        }\\n                \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int len = s.length();\\n        vector<vector<int>> cnt(26, vector<int> (len, 0));\\n        cnt[s[0] - \\'a\\'][0]++;\\n        \\n        /*\\n            cnt[c - \\'a\\'][i] : represents the number of occurrences of the character c, till the index i in the string s\\n            \\n            so to find out the frequency of some character c in the range l to r\\n            \\n            freq = cnt[c - \\'a\\'][r] - cnt[c - \\'a\\'][l - 1]\\n            \\n            now how to check whether it can be rearranged into a palindrome, given that we can change at most k characters \\n            lets say we have this \\n            a b d c c c m m m m m k k k a\\n            \\n            k, m, c, b, d\\n            we can place it like this \\n            \\n            a k m m c ______ c m m k a\\n            \\n            now after doing this the remaining spots are to be filled \\n            other are already matched\\n            we will place the remaining c in the middle\\n            k can be transformed into b, and c can be transformed into d\\n            \\n            so the number of transformations we need is : (number of character with odd frequency) / 2\\n            \\n            \\n        */\\n        \\n        for(int i = 1; i < len; i++) {\\n            cnt[s[i] - \\'a\\'][i] = 1;\\n            for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                 cnt[c - \\'a\\'][i]+=cnt[c - \\'a\\'][i - 1];\\n                    \\n            }\\n        }\\n                \\n        int qLen = queries.size();\\n        vector<bool> ans(qLen, 0);\\n        for(int i = 0; i < qLen; i++) {\\n            auto q = queries[i];\\n            int li = q[0], ri = q[1];\\n    \\n            int oddCount = 0;\\n            for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                int curCount = cnt[c - \\'a\\'][ri] - (li > 0 ? cnt[c - \\'a\\'][li - 1] : 0);            \\n                if(curCount % 2) oddCount++;\\n            }\\n            \\n            int changedNeeded = oddCount / 2;\\n            ans[i] = changedNeeded <= q[2];\\n        }\\n                \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234431,
                "title": "c-prefix-sum-algorithm-and-greedy-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    // Space: O(N*26)\\n    // Time: O(N)\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        std::vector<bool>result;\\n        // Prefix sum algorthim \\n        // Prefix[i]: An array which has size 26\\n        // Prefix[i][0] frequency of char \\'a\\' in substring [0:i] \\n        // Prefix[i][1] frequency of char \\'b\\' in substring [0:i]\\n        std::vector<std::vector<int>>prefix((int)s.length(),std::vector<int>(26,0));\\n        prefix[0][s[0]-\\'a\\']=1;\\n        for(int i=1;i<(int)s.length();i++){\\n            prefix[i] = prefix[i-1];\\n            prefix[i][s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<(int)queries.size();i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            int k = queries[i][2];\\n            std::vector<int>arr = prefix[right];\\n            // Find the frequency for each char in substring[left:right]\\n            if(left-1>=0)\\n                for(int i=0;i<(int)prefix[left-1].size();i++)\\n                    arr[i] -= prefix[left-1][i];\\n            result.push_back(is_valid(arr,k));\\n        }\\n        return result;\\n    }\\n    // To check if there is possible to rearrange string and make it palindrome\\n    // Only need to check the char that has odd frequency\\n    // For char that has even frequency, you alway can rearrange it to make it palindrome.\\n\\t// e.g \"axxaxaxxxxxa\" => \"aa{xxxxxxxx}aa\"\\n    // by putting half of \\'a\\' in the front of string and another half of \\'a\\' in the tail of the string\\n    bool is_valid(const std::vector<int>&arr,const int&k){\\n        // counter: how many char we need to replace. \\n        int counter = 0;\\n        for(int i=0;i<(int)arr.size();i++){\\n            if(arr[i]%2==0) continue;\\n            // If a char has odd frequency, just need to one time operation to make it palindrome\\n            // e.g {aaaaa} =>{aaaax} just need to change one of \\'a\\' to other char. \\n            // Then frequency of \\'a\\' becomes even.\\n            counter++;\\n        }\\n        // If counter is a even number, we only need to flip k/2 times\\n        // e.g : {abcdef} => {[abc] [cba]} => total 3 times\\n        // If counter is a odd number, we only need to flip (k-1)/2 times\\n        // e.g {abcde} => {[ab] c [ba]} => total 2 times\\n        return (counter%2==0&&counter/2<=k) || (counter%2!=0 && (counter-1)/2<=k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    // Space: O(N*26)\\n    // Time: O(N)\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        std::vector<bool>result;\\n        // Prefix sum algorthim \\n        // Prefix[i]: An array which has size 26\\n        // Prefix[i][0] frequency of char \\'a\\' in substring [0:i] \\n        // Prefix[i][1] frequency of char \\'b\\' in substring [0:i]\\n        std::vector<std::vector<int>>prefix((int)s.length(),std::vector<int>(26,0));\\n        prefix[0][s[0]-\\'a\\']=1;\\n        for(int i=1;i<(int)s.length();i++){\\n            prefix[i] = prefix[i-1];\\n            prefix[i][s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<(int)queries.size();i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            int k = queries[i][2];\\n            std::vector<int>arr = prefix[right];\\n            // Find the frequency for each char in substring[left:right]\\n            if(left-1>=0)\\n                for(int i=0;i<(int)prefix[left-1].size();i++)\\n                    arr[i] -= prefix[left-1][i];\\n            result.push_back(is_valid(arr,k));\\n        }\\n        return result;\\n    }\\n    // To check if there is possible to rearrange string and make it palindrome\\n    // Only need to check the char that has odd frequency\\n    // For char that has even frequency, you alway can rearrange it to make it palindrome.\\n\\t// e.g \"axxaxaxxxxxa\" => \"aa{xxxxxxxx}aa\"\\n    // by putting half of \\'a\\' in the front of string and another half of \\'a\\' in the tail of the string\\n    bool is_valid(const std::vector<int>&arr,const int&k){\\n        // counter: how many char we need to replace. \\n        int counter = 0;\\n        for(int i=0;i<(int)arr.size();i++){\\n            if(arr[i]%2==0) continue;\\n            // If a char has odd frequency, just need to one time operation to make it palindrome\\n            // e.g {aaaaa} =>{aaaax} just need to change one of \\'a\\' to other char. \\n            // Then frequency of \\'a\\' becomes even.\\n            counter++;\\n        }\\n        // If counter is a even number, we only need to flip k/2 times\\n        // e.g : {abcdef} => {[abc] [cba]} => total 3 times\\n        // If counter is a odd number, we only need to flip (k-1)/2 times\\n        // e.g {abcde} => {[ab] c [ba]} => total 2 times\\n        return (counter%2==0&&counter/2<=k) || (counter%2!=0 && (counter-1)/2<=k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178469,
                "title": "c-solution-prefix-xor-and-bit-mask-beats-97",
                "content": "![image](https://assets.leetcode.com/users/images/a8b31c71-cb5c-4eb1-a102-218919531d1c_1655812702.1114886.jpeg)\\n![image](https://assets.leetcode.com/users/images/63e33e0e-b3f2-425b-93c0-04cf89a9509b_1655812706.7613308.jpeg)\\n![image](https://assets.leetcode.com/users/images/14169187-4ae0-4c29-acce-49d3098c7ca7_1655812721.1267362.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n\\t\\t//prefix array to allow me to compute the xor of a substring in constant time\\n        vector<int>prefix(n+1,0);\\n        for(int i=1;i<prefix.size();i++){\\n            int pos=s[i-1]-\\'a\\';\\n            prefix[i]=prefix[i-1]^(1<<pos);\\n        }\\n        vector<bool>ans(queries.size(),false);\\n        for(int i=0;i<queries.size();i++){\\n            int left=queries[i][0];\\n            int right=queries[i][1];\\n            int k=queries[i][2];\\n            int mask=prefix[right+1]^prefix[left];\\n            int cnt=0;\\n            while(mask){\\n                mask-=mask&(-mask);\\n                cnt++;\\n            }\\n            ans[i]=(cnt/2<=k);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n\\t\\t//prefix array to allow me to compute the xor of a substring in constant time\\n        vector<int>prefix(n+1,0);\\n        for(int i=1;i<prefix.size();i++){\\n            int pos=s[i-1]-\\'a\\';\\n            prefix[i]=prefix[i-1]^(1<<pos);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2131539,
                "title": "easy-dp-c-code-in-o-n-m",
                "content": "class Solution\\n{\\npublic:\\n\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>> &queries)\\n    {\\n        // ! arrangement of char is allowed btw given range\\n        vector<bool> v;\\n        vector<vector<int>> dp(26, vector<int>(s.size(), 0));   // to store the count of characters in the string so that we can \\n                                                                // count the occurence of each character in given range\\n\\n        for (int i = 0; i < 26; i++)\\n        {\\n            for (int j = 0; j < s.size(); j++)\\n            {\\n                if (j == 0)\\n                {\\n                    if ((char(\\'a\\' + i) == s[j]))\\n                        dp[i][j] = 1;\\n                }\\n\\n                else if (char(\\'a\\' + i) == s[j])\\n                    dp[i][j] = dp[i][j - 1] + 1;\\n\\n                else\\n                    dp[i][j] = dp[i][j - 1];\\n            }\\n        }\\n\\n        for (auto &it : queries)\\n        {\\n            int l = it[0], r = it[1], k = it[2];\\n\\n            int oddCnt = 0;    //* to count the number of odd occurence of characters in given range\\n\\n            for (int i = 0; i < 26; i++)\\n            {\\n                int cnt = dp[i][r] - dp[i][l] + (s[l] == char(\\'a\\' + i) ? 1 : 0);\\n                if (cnt % 2 == 1)\\n                    oddCnt++;\\n            }\\n\\n            if ((r - l + 1) % 2 == 1)    //* if length of the string is odd then one odd character is allowed in palindrome\\n                oddCnt--;\\n\\n            if (oddCnt / 2 <= k)   // * if k is greater than or equal to half of the odd character count then it is palindrome\\n                v.push_back(1);\\n            else\\n                v.push_back(0);\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution\\n{\\npublic:\\n\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>> &queries)\\n    {\\n        // ! arrangement of char is allowed btw given range\\n        vector<bool> v;\\n        vector<vector<int>> dp(26, vector<int>(s.size(), 0));   // to store the count of characters in the string so that we can \\n                                                                // count the occurence of each character in given range\\n\\n        for (int i = 0; i < 26; i++)\\n        {\\n            for (int j = 0; j < s.size(); j++)\\n            {\\n                if (j == 0)\\n                {\\n                    if ((char(\\'a\\' + i) == s[j]))\\n                        dp[i][j] = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1929207,
                "title": "91-faster-easy-explanation",
                "content": "Simple Bimasking\\n\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int,int>mp;   // index, mask\\n        int mask=0;\\n        \\n        //0 means even count , 1 means odd count\\n\\t\\t// it stores count of charecters till every index \\n        for(int i=0 ; i<s.size() ; i++){\\n            mask ^= (1<<(s[i]-\\'a\\'));\\n            mp[i]=mask;\\n           // cout<<i<<\\' \\'<<mask<<endl;\\n        }\\n        vector<bool>ans;\\n        int n= s.size();\\n        for(auto &q : queries ){\\n            if(q[0]==q[1]){ ans.push_back(1); continue; }\\n            int l= (q[0]==0 )? 0 : mp[q[0]-1];\\n            int r= mp[q[1]];\\n           \\n            int k= q[2];\\n            \\n            int oddbits=0;\\n            int temp = l^r;\\n            // in above temp it store all the chars between l and r(including)\\n\\t\\t\\t// and no. of 1 in temp correspons to no. of odd occuring charecters\\n\\t\\t\\t\\n            for( int i=0; i<26; i++){\\n                if(temp&(1<<i)) oddbits++;    \\n            }\\n           // cout<<temp<<\\' \\'<<oddbits<<endl;\\n            oddbits--;\\n            if(oddbits>k*2) ans.push_back(0);\\n            else ans.push_back(1);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "Simple Bimasking\\n\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int,int>mp;   // index, mask\\n        int mask=0;\\n        \\n        //0 means even count , 1 means odd count\\n\\t\\t// it stores count of charecters till every index \\n        for(int i=0 ; i<s.size() ; i++){\\n            mask ^= (1<<(s[i]-\\'a\\'));\\n            mp[i]=mask;\\n           // cout<<i<<\\' \\'<<mask<<endl;\\n        }\\n        vector<bool>ans;\\n        int n= s.size();\\n        for(auto &q : queries ){\\n            if(q[0]==q[1]){ ans.push_back(1); continue; }\\n            int l= (q[0]==0 )? 0 : mp[q[0]-1];\\n            int r= mp[q[1]];\\n           \\n            int k= q[2];\\n            \\n            int oddbits=0;\\n            int temp = l^r;\\n            // in above temp it store all the chars between l and r(including)\\n\\t\\t\\t// and no. of 1 in temp correspons to no. of odd occuring charecters\\n\\t\\t\\t\\n            for( int i=0; i<26; i++){\\n                if(temp&(1<<i)) oddbits++;    \\n            }\\n           // cout<<temp<<\\' \\'<<oddbits<<endl;\\n            oddbits--;\\n            if(oddbits>k*2) ans.push_back(0);\\n            else ans.push_back(1);\\n        }\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1899578,
                "title": "simple-solution-in-java-elegant-and-concise",
                "content": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        int[][] dp = new int[s.length() + 1][26]; // Frequency of all the characters for substring from 1 to len\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            for(int j=0; j<26; j++){\\n                if(s.charAt(i-1) - \\'a\\' == j){\\n                    dp[i][j] = dp[i-1][j] + 1;\\n                }else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        \\n        List<Boolean> res = new ArrayList<>();\\n        for(int[] query : queries){\\n            int q0 = query[0];\\n            int q1 = query[1];\\n            int k = query[2];\\n            \\n            int[] leftCount = dp[q0];\\n            int[] rightCount = dp[q1+1];\\n\\n            int diffChar = 0; // Count the unmatched \\n            for(int i=0; i<26; i++){\\n                diffChar += (rightCount[i] - leftCount[i])%2;\\n            }\\n            \\n            Boolean possibleOrNot = false;\\n            if( (q1 - q0 + 1)%2 != 0){ // Odd Length\\n                diffChar -= 1; // One char at the middle \\n            }\\n                \\n            if(diffChar/2 <= k) possibleOrNot = true;\\n            res.add(possibleOrNot);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        int[][] dp = new int[s.length() + 1][26]; // Frequency of all the characters for substring from 1 to len\\n        \\n        for(int i=1; i<=s.length(); i++){\\n            for(int j=0; j<26; j++){\\n                if(s.charAt(i-1) - \\'a\\' == j){\\n                    dp[i][j] = dp[i-1][j] + 1;\\n                }else dp[i][j] = dp[i-1][j];\\n            }\\n        }\\n        \\n        List<Boolean> res = new ArrayList<>();\\n        for(int[] query : queries){\\n            int q0 = query[0];\\n            int q1 = query[1];\\n            int k = query[2];\\n            \\n            int[] leftCount = dp[q0];\\n            int[] rightCount = dp[q1+1];\\n\\n            int diffChar = 0; // Count the unmatched \\n            for(int i=0; i<26; i++){\\n                diffChar += (rightCount[i] - leftCount[i])%2;\\n            }\\n            \\n            Boolean possibleOrNot = false;\\n            if( (q1 - q0 + 1)%2 != 0){ // Odd Length\\n                diffChar -= 1; // One char at the middle \\n            }\\n                \\n            if(diffChar/2 <= k) possibleOrNot = true;\\n            res.add(possibleOrNot);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793872,
                "title": "how-this-is-true-0-3-1",
                "content": "\"hunu\"\\n[[1,1,1],[2,3,0],[3,3,1],[0,3,2],[1,3,3],[2,3,1],[3,3,1],[0,3,0],[1,1,1],[2,3,0],[3,3,1],**[0,3,1]**,[1,1,1]]\\n\\nthe string has three diff char and as per description we can replace **only** one character, possible replacement strings are (**with only one character replacement**):\\n\\n\"hunu\" to \"uunu\" or\\n\"hunu\" to \"hunh\" or\\n\"hunu\" to \"hnnu\" or\\n\"hunu\" to \"huuu\" or\\n\"hunu\" to \"hhnu\" or\\n\"hunu\" to \"huhu\" or\\n\"hunu\" to \"nunu\".....\\n\\nTo make \"hunu\" a palindrom we need **at least 2 characters** to be change.\\n\\nplease comment\\n\\n\\n",
                "solutionTags": [],
                "code": "\"hunu\"\\n[[1,1,1],[2,3,0],[3,3,1],[0,3,2],[1,3,3],[2,3,1],[3,3,1],[0,3,0],[1,1,1],[2,3,0],[3,3,1],**[0,3,1]**,[1,1,1]]\\n\\nthe string has three diff char and as per description we can replace **only** one character, possible replacement strings are (**with only one character replacement**):\\n\\n\"hunu\" to \"uunu\" or\\n\"hunu\" to \"hunh\" or\\n\"hunu\" to \"hnnu\" or\\n\"hunu\" to \"huuu\" or\\n\"hunu\" to \"hhnu\" or\\n\"hunu\" to \"huhu\" or\\n\"hunu\" to \"nunu\".....\\n\\nTo make \"hunu\" a palindrom we need **at least 2 characters** to be change.\\n\\nplease comment\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1760287,
                "title": "c-with-explanation",
                "content": "**Explanation:-**\\n1. Here we can suffle the string ,so we have to count chars only.To do this in constant time for every query we have to precalculate it.\\n2. ```prefix[i]``` will store count of each char from index 0 to index i-1.\\n3. For each query  calculate the chars in the string and,chars which are already in pair can form palindrome with 0 cost and  for remaining chars we can make pair by using remaining/2 steps.\\n\\n**Time complexity :-** O(26n),\\n **Space Complexity:-** O(26n)\\n ```\\n class Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        vector<vector<int>>prefix(s.size()+1,vector<int>(26,0));\\n        for(int i=0;i<s.size();i++){\\n            for(int j=0;j<26;j++)\\n                prefix[i+1][j]=prefix[i][j];\\n            prefix[i+1][s[i]-\\'a\\']++;\\n        }\\n        vector<bool>ans;\\n        int n=q.size();\\n        for(int i=0;i<n;i++){\\n            int start=q[i][0],end=q[i][1],k=q[i][2];\\n            int pairs=0;\\n            for(int j=0;j<26;j++){\\n                int diff=prefix[end+1][j]-prefix[start][j];\\n                pairs+=diff/2;\\n            }\\n            int need=len-pairs*2;\\n            int tochange=need/2;\\n            if(tochange<=k)\\n                ans.push_back(true);\\n            else\\n                ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n ```\\n Do **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```prefix[i]```\n```\\n class Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        vector<vector<int>>prefix(s.size()+1,vector<int>(26,0));\\n        for(int i=0;i<s.size();i++){\\n            for(int j=0;j<26;j++)\\n                prefix[i+1][j]=prefix[i][j];\\n            prefix[i+1][s[i]-\\'a\\']++;\\n        }\\n        vector<bool>ans;\\n        int n=q.size();\\n        for(int i=0;i<n;i++){\\n            int start=q[i][0],end=q[i][1],k=q[i][2];\\n            int pairs=0;\\n            for(int j=0;j<26;j++){\\n                int diff=prefix[end+1][j]-prefix[start][j];\\n                pairs+=diff/2;\\n            }\\n            int need=len-pairs*2;\\n            int tochange=need/2;\\n            if(tochange<=k)\\n                ans.push_back(true);\\n            else\\n                ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1617215,
                "title": "explained-easy-understanding-commented-c-solution-bit-manipulation-o-n-time-o-n-space",
                "content": "```\\n// IDEA:\\n//   1. Recall what is a palidrome string, in short, at most 1 character has a odd cnt\\n//      For example: \"aba\" is palidrme (a = 2, b = 1) and \"ab\" is not (a = 1, b = 1)\\n//\\n//   2. Note that for the examples in step 1, instead of storing (a = 2, b = 1), we can store it as\\n//      (a = 2 mod 2, b = 1 mod 2), i.e. (a = 0, b = 1) since we only care if it is even/odd\\n//\\n//   3. Now we should consider what does the k value do. In terms of creating a palidrome string,\\n//      the most optimal use of a character change is to eliminate a singled character and create\\n//      a complete pair. Note that we can also not change any characters. Let\\'s take a look at a few\\n//      examples:\\n//\\n//      - \"abba\", k = 1: we change nothing\\n//      - \"abc\", k = 1: the optimal use of k is to change string to either \"abb\" or \"acc\", note that\\n//        the results are the same regardless which character you decided to change.\\n//\\n//      In conclusion, each k can optimally elminate 2 odd characters in our string.\\n//\\n//   4. The naive approach will be for each query, we count the characters in the string\\n//      as stated in 2, this will create a time complexity of O(mk), where m = query count,\\n//      k = k in query; space complexity of O(1) because of lookup table of 26 characters\\n//\\n//   5. This time complexity is obviously not ideal, how can we improve by sacraficing space?\\n//      Note that a O(n) time algorithm basically means one pass, and n does not depends on\\n//      query size but string size. Hinting a pre-processing method.\\n//\\n//   6. Observe in step 2, what we really care is the frequency of the element in the sub string,\\n//      what we can do is to store what characters the string contains up to each character. When\\n//      we calculate, simply find the difference between the 2 ends of the sub-string.\\n//\\n//      For a clear demonstration, lets use the string \"aba\"\\n//      s:  a   b   a\\n//      a | 1   1   0 (* a is 0 because of mod 2 stated in step 2)\\n//      b | 0   1   1\\n//\\n//      Let\\'s try to ask if l = 1, r = 2, k = 0 is a palindrome. We can calculate the character difference\\n//      between characterCnt at s[0] and s[2]:\\n//      a = (0 - 1) mod 2 = 1\\n//      b = (1 - 0) mod 2 = 1\\n//      Since there are 2 odds, it is not palindrome.\\n//\\n//      Note that if we want to calculate l = 0, r = 2, you will have to either directly use the 3rd column of\\n//      the table or deduct it with a 0-column (which I did for code readability, sacraficing some memory).\\n//\\n//   7. To futher optimize the code, what we can do is utilize the property of (a - b) mod 2 where:\\n//      a  b  = result\\n//      0  0  = 0\\n//      0  1  = 1\\n//      1  0  = 1\\n//      1  1  = 0\\n//\\n//      Observe the above table, it is simply an XOR chart, hinting a bit manipulation approach, also\\n//      note that (a - b) mod 2 == (a + b) mod 2, which is useful when we do preprocessing.\\n//\\n//   8. So for pre-processing, what we can do is to is do (a + b) mod 2 for each character in a 32-bit value\\n//      When we calculate the difference, we use (a - b) mod 2 find the difference. See the code for the implementation.\\n\\n// NOTE: redundant variables for readability\\nclass Solution {\\nprivate:\\n    const int lIndex = 0;\\n    const int rIndex = 1;\\n    const int kIndex = 2;\\n    \\n\\t// Count number of 1 bits in 32bit value\\n    int cntOnes32(uint32_t val) {\\n        int res = 0;\\n        while (val != 0) {\\n            if (val & 1) res++;\\n            val >>= 1;\\n        }\\n        return res;\\n    }\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<uint32_t> dp (s.size() + 1, 0); // NOTE: strictly speaking this is not Dynamic Programming, but the concept is similar\\n        vector<bool> res;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            dp[i + 1] = dp[i] ^ (1 << (s[i] - \\'a\\'));\\n        }\\n        \\n        for (vector<int> &qry : queries) {\\n            \\n            int l = qry[lIndex]; // left\\n            int r = qry[rIndex]; // right\\n            int k = qry[kIndex]; // k\\n            \\n            uint32_t diff32 = dp[l] ^ dp[r + 1]; // compensated for extra element in dp\\n            \\n\\t\\t\\t// NOTE: push_back is probably not efficent but w/e\\n            if (cntOnes32(diff32) - (k << 1) > 1) {\\n                res.push_back(false);\\n                continue;\\n            }\\n            res.push_back(true);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\n// IDEA:\\n//   1. Recall what is a palidrome string, in short, at most 1 character has a odd cnt\\n//      For example: \"aba\" is palidrme (a = 2, b = 1) and \"ab\" is not (a = 1, b = 1)\\n//\\n//   2. Note that for the examples in step 1, instead of storing (a = 2, b = 1), we can store it as\\n//      (a = 2 mod 2, b = 1 mod 2), i.e. (a = 0, b = 1) since we only care if it is even/odd\\n//\\n//   3. Now we should consider what does the k value do. In terms of creating a palidrome string,\\n//      the most optimal use of a character change is to eliminate a singled character and create\\n//      a complete pair. Note that we can also not change any characters. Let\\'s take a look at a few\\n//      examples:\\n//\\n//      - \"abba\", k = 1: we change nothing\\n//      - \"abc\", k = 1: the optimal use of k is to change string to either \"abb\" or \"acc\", note that\\n//        the results are the same regardless which character you decided to change.\\n//\\n//      In conclusion, each k can optimally elminate 2 odd characters in our string.\\n//\\n//   4. The naive approach will be for each query, we count the characters in the string\\n//      as stated in 2, this will create a time complexity of O(mk), where m = query count,\\n//      k = k in query; space complexity of O(1) because of lookup table of 26 characters\\n//\\n//   5. This time complexity is obviously not ideal, how can we improve by sacraficing space?\\n//      Note that a O(n) time algorithm basically means one pass, and n does not depends on\\n//      query size but string size. Hinting a pre-processing method.\\n//\\n//   6. Observe in step 2, what we really care is the frequency of the element in the sub string,\\n//      what we can do is to store what characters the string contains up to each character. When\\n//      we calculate, simply find the difference between the 2 ends of the sub-string.\\n//\\n//      For a clear demonstration, lets use the string \"aba\"\\n//      s:  a   b   a\\n//      a | 1   1   0 (* a is 0 because of mod 2 stated in step 2)\\n//      b | 0   1   1\\n//\\n//      Let\\'s try to ask if l = 1, r = 2, k = 0 is a palindrome. We can calculate the character difference\\n//      between characterCnt at s[0] and s[2]:\\n//      a = (0 - 1) mod 2 = 1\\n//      b = (1 - 0) mod 2 = 1\\n//      Since there are 2 odds, it is not palindrome.\\n//\\n//      Note that if we want to calculate l = 0, r = 2, you will have to either directly use the 3rd column of\\n//      the table or deduct it with a 0-column (which I did for code readability, sacraficing some memory).\\n//\\n//   7. To futher optimize the code, what we can do is utilize the property of (a - b) mod 2 where:\\n//      a  b  = result\\n//      0  0  = 0\\n//      0  1  = 1\\n//      1  0  = 1\\n//      1  1  = 0\\n//\\n//      Observe the above table, it is simply an XOR chart, hinting a bit manipulation approach, also\\n//      note that (a - b) mod 2 == (a + b) mod 2, which is useful when we do preprocessing.\\n//\\n//   8. So for pre-processing, what we can do is to is do (a + b) mod 2 for each character in a 32-bit value\\n//      When we calculate the difference, we use (a - b) mod 2 find the difference. See the code for the implementation.\\n\\n// NOTE: redundant variables for readability\\nclass Solution {\\nprivate:\\n    const int lIndex = 0;\\n    const int rIndex = 1;\\n    const int kIndex = 2;\\n    \\n\\t// Count number of 1 bits in 32bit value\\n    int cntOnes32(uint32_t val) {\\n        int res = 0;\\n        while (val != 0) {\\n            if (val & 1) res++;\\n            val >>= 1;\\n        }\\n        return res;\\n    }\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<uint32_t> dp (s.size() + 1, 0); // NOTE: strictly speaking this is not Dynamic Programming, but the concept is similar\\n        vector<bool> res;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            dp[i + 1] = dp[i] ^ (1 << (s[i] - \\'a\\'));\\n        }\\n        \\n        for (vector<int> &qry : queries) {\\n            \\n            int l = qry[lIndex]; // left\\n            int r = qry[rIndex]; // right\\n            int k = qry[kIndex]; // k\\n            \\n            uint32_t diff32 = dp[l] ^ dp[r + 1]; // compensated for extra element in dp\\n            \\n\\t\\t\\t// NOTE: push_back is probably not efficent but w/e\\n            if (cntOnes32(diff32) - (k << 1) > 1) {\\n                res.push_back(false);\\n                continue;\\n            }\\n            res.push_back(true);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560811,
                "title": "python-3-solution-using-prefix-frequencies",
                "content": "```\\ndef canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:    \\n\\tprefix = {}\\n\\tl = len(s)\\n\\tprefix[0] = {s[0]:1}\\n\\n\\tfor i in range(1, l):\\n\\t\\tprefix[i] = prefix[i-1].copy()\\n\\t\\tif s[i] in prefix[i]:\\n\\t\\t\\tprefix[i][s[i]]+=1\\n\\t\\telse:\\n\\t\\t\\tprefix[i][s[i]] = 1\\n\\t#print(prefix)\\n\\n\\tres = []\\n\\n\\tfor q in queries:\\n\\t\\tone = 0\\n\\n\\t\\tfor k in prefix[q[1]]:\\n\\t\\t\\tchars = prefix[q[1]][k]-(prefix[q[0]-1].get(k, 0) if q[0]>0 else 0)\\n\\t\\t\\tone+=chars%2\\n\\t\\tif one<=1:\\n\\t\\t\\tres.append(True)\\n\\t\\telse:\\n\\t\\t\\tres.append(q[2]>=(one//2))\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:    \\n\\tprefix = {}\\n\\tl = len(s)\\n\\tprefix[0] = {s[0]:1}\\n\\n\\tfor i in range(1, l):\\n\\t\\tprefix[i] = prefix[i-1].copy()\\n\\t\\tif s[i] in prefix[i]:\\n\\t\\t\\tprefix[i][s[i]]+=1\\n\\t\\telse:\\n\\t\\t\\tprefix[i][s[i]] = 1\\n\\t#print(prefix)\\n\\n\\tres = []\\n\\n\\tfor q in queries:\\n\\t\\tone = 0\\n\\n\\t\\tfor k in prefix[q[1]]:\\n\\t\\t\\tchars = prefix[q[1]][k]-(prefix[q[0]-1].get(k, 0) if q[0]>0 else 0)\\n\\t\\t\\tone+=chars%2\\n\\t\\tif one<=1:\\n\\t\\t\\tres.append(True)\\n\\t\\telse:\\n\\t\\t\\tres.append(q[2]>=(one//2))\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1358279,
                "title": "c-o-n-bitwise-operations-using-xor-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        // Create bitmask to keep track of whether each character count is odd\\n        vector<int> charBitmask(s.size() + 1, 0);\\n        for (int i = 0; i < s.size(); i++)\\n            charBitmask[i + 1] = charBitmask[i] ^ (1 << (s[i] - \\'a\\')); // Toggle bit representing the character\\n\\n        vector<bool> ret;\\n        for (int i = 0; i < queries.size(); i++) {\\n            \\n            int oddBitmask = charBitmask[queries[i][1] + 1] ^ charBitmask[queries[i][0]]; // Find differences in bitmasks\\n            int countOdd = 0;\\n            while (oddBitmask) {\\n                oddBitmask -= oddBitmask & -oddBitmask; // Count number of bits in bitmask\\n                countOdd++;\\n            }\\n            ret.push_back(countOdd <= queries[i][2] * 2 + 1); // If number of bits is more than 2 * k + 1, it can\\'t be palindrome\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        // Create bitmask to keep track of whether each character count is odd\\n        vector<int> charBitmask(s.size() + 1, 0);\\n        for (int i = 0; i < s.size(); i++)\\n            charBitmask[i + 1] = charBitmask[i] ^ (1 << (s[i] - \\'a\\')); // Toggle bit representing the character\\n\\n        vector<bool> ret;\\n        for (int i = 0; i < queries.size(); i++) {\\n            \\n            int oddBitmask = charBitmask[queries[i][1] + 1] ^ charBitmask[queries[i][0]]; // Find differences in bitmasks\\n            int countOdd = 0;\\n            while (oddBitmask) {\\n                oddBitmask -= oddBitmask & -oddBitmask; // Count number of bits in bitmask\\n                countOdd++;\\n            }\\n            ret.push_back(countOdd <= queries[i][2] * 2 + 1); // If number of bits is more than 2 * k + 1, it can\\'t be palindrome\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352329,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(26,0));\\n        for(int i=0;i<s.size();i++){\\n            int j=s[i]-\\'a\\';\\n            dp[i][j]+=1;\\n        }\\n        for(int i=1;i<s.size();i++){\\n            for(int j=0;j<26;j++){\\n                dp[i][j]+=dp[i-1][j];\\n            }\\n        }\\n        vector<bool>ans;\\n        for(auto vec:queries){\\n            int l=vec[0];\\n            int r=vec[1];\\n            int s=vec[2];\\n            int odd=0;\\n            for(int j=0;j<26;j++){\\n                int count=dp[r][j]-(l==0?0:dp[l-1][j]);\\n                if(count%2==1) odd++;\\n            }\\n            if(odd==0 || odd==1){\\n                ans.push_back(true);\\n                continue;\\n            }\\n            int match=odd/2;\\n            if(match<=s){\\n                ans.push_back(true);\\n            }\\n            else{\\n                ans.push_back(false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        vector<vector<int>>dp(n,vector<int>(26,0));\\n        for(int i=0;i<s.size();i++){\\n            int j=s[i]-\\'a\\';\\n            dp[i][j]+=1;\\n        }\\n        for(int i=1;i<s.size();i++){\\n            for(int j=0;j<26;j++){\\n                dp[i][j]+=dp[i-1][j];\\n            }\\n        }\\n        vector<bool>ans;\\n        for(auto vec:queries){\\n            int l=vec[0];\\n            int r=vec[1];\\n            int s=vec[2];\\n            int odd=0;\\n            for(int j=0;j<26;j++){\\n                int count=dp[r][j]-(l==0?0:dp[l-1][j]);\\n                if(count%2==1) odd++;\\n            }\\n            if(odd==0 || odd==1){\\n                ans.push_back(true);\\n                continue;\\n            }\\n            int match=odd/2;\\n            if(match<=s){\\n                ans.push_back(true);\\n            }\\n            else{\\n                ans.push_back(false);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1226176,
                "title": "c-using-prefix-freq-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&v)\\n    {\\n        int odd=0;\\n        for(int i=0;i<26;i++)\\n            if(v[i]%2)\\n                odd++;\\n        return odd/2;\\n    }\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) \\n    {\\n        int n=s.size();\\n        vector<int>count(26,0);\\n        vector<vector<int>>prefix;\\n        for(auto c:s)\\n        {\\n            count[c-\\'a\\']++;\\n            prefix.push_back(count);\\n        }\\n        vector<bool>res;\\n        for(auto &q:queries)\\n        {\\n            int i=q[0],j=q[1],k=q[2];\\n            vector<int>curr(26,0);\\n            if(i==0)\\n                curr=prefix[j];\\n            else\\n            {\\n                for(int x=0;x<26;x++)\\n                    curr[x]=prefix[j][x]-prefix[i-1][x];\\n            }\\n            int req=find(curr);\\n            res.push_back(req<=k);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>&v)\\n    {\\n        int odd=0;\\n        for(int i=0;i<26;i++)\\n            if(v[i]%2)\\n                odd++;\\n        return odd/2;\\n    }\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) \\n    {\\n        int n=s.size();\\n        vector<int>count(26,0);\\n        vector<vector<int>>prefix;\\n        for(auto c:s)\\n        {\\n            count[c-\\'a\\']++;\\n            prefix.push_back(count);\\n        }\\n        vector<bool>res;\\n        for(auto &q:queries)\\n        {\\n            int i=q[0],j=q[1],k=q[2];\\n            vector<int>curr(26,0);\\n            if(i==0)\\n                curr=prefix[j];\\n            else\\n            {\\n                for(int x=0;x<26;x++)\\n                    curr[x]=prefix[j][x]-prefix[i-1][x];\\n            }\\n            int req=find(curr);\\n            res.push_back(req<=k);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180397,
                "title": "js",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {boolean[]}\\n */\\nvar canMakePaliQueries = function(s, queries) {\\n    const len = s.length\\n    const mapSF = new Array(len)\\n    mapSF[-1] = new Map()\\n    \\n    for (let i = 0; i < len; i++) {\\n        const ch = s[i]\\n        \\n        let prevOutcome = mapSF[-1 + i]\\n        let outcome = new Map(prevOutcome)\\n        outcome.set(ch, 1 + (outcome.get(ch) || 0))\\n        \\n        mapSF[i] = outcome\\n    }\\n    \\n    \\n    let result = queries.map(query => {\\n        const [fromIndex, toIndex, k] = query\\n        const startMap = mapSF[-1 + fromIndex]\\n        const endMap = mapSF[toIndex]\\n        \\n        let oddCount = 0\\n        for (const [ch, endCount] of endMap.entries()) {\\n            const startCount = startMap.get(ch) || 0\\n            \\n            const diff = endCount - startCount\\n            if (diff & 1) {\\n                oddCount++\\n            }\\n        }\\n        \\n        if (oddCount > 2 * k + 1)\\n            return false\\n        else\\n            return true\\n    })\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} queries\\n * @return {boolean[]}\\n */\\nvar canMakePaliQueries = function(s, queries) {\\n    const len = s.length\\n    const mapSF = new Array(len)\\n    mapSF[-1] = new Map()\\n    \\n    for (let i = 0; i < len; i++) {\\n        const ch = s[i]\\n        \\n        let prevOutcome = mapSF[-1 + i]\\n        let outcome = new Map(prevOutcome)\\n        outcome.set(ch, 1 + (outcome.get(ch) || 0))\\n        \\n        mapSF[i] = outcome\\n    }\\n    \\n    \\n    let result = queries.map(query => {\\n        const [fromIndex, toIndex, k] = query\\n        const startMap = mapSF[-1 + fromIndex]\\n        const endMap = mapSF[toIndex]\\n        \\n        let oddCount = 0\\n        for (const [ch, endCount] of endMap.entries()) {\\n            const startCount = startMap.get(ch) || 0\\n            \\n            const diff = endCount - startCount\\n            if (diff & 1) {\\n                oddCount++\\n            }\\n        }\\n        \\n        if (oddCount > 2 * k + 1)\\n            return false\\n        else\\n            return true\\n    })\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1137161,
                "title": "array-o-queries-time-and-space",
                "content": "class Solution:\\n\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        res=[]\\n        d=[0 for i in range(26)]\\n        li=[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]\\n        for i in range(len(s)):\\n            d[ord(s[i])-ord(\\'a\\')]+=1\\n            li.append(d.copy())\\n        for x,y,k in queries:\\n            count=0\\n            l=x\\n            r=y+1\\n            d1=[0 for i in range(26)]\\n            for i in range(26):\\n                t=li[r][i]-li[l][i]\\n                if t>0:\\n                    d1[i]=t\\n                    if d1[i]%2==1:\\n                        count+=1\\n            if count%2==0 and count//2<=k:\\n                res.append(1)\\n            elif count%2==1 and count//2<=k and (y-x+1)%2==1:\\n                res.append(1)\\n            else:\\n                res.append(0)\\n        return res\\n        \\n        \\n        \\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution:\\n\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        res=[]\\n        d=[0 for i in range(26)]\\n        li=[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]\\n        for i in range(len(s)):\\n            d[ord(s[i])-ord(\\'a\\')]+=1\\n            li.append(d.copy())\\n        for x,y,k in queries:\\n            count=0\\n            l=x\\n            r=y+1\\n            d1=[0 for i in range(26)]\\n            for i in range(26):\\n                t=li[r][i]-li[l][i]\\n                if t>0:\\n                    d1[i]=t\\n                    if d1[i]%2==1:\\n                        count+=1\\n            if count%2==0 and count//2<=k:\\n                res.append(1)\\n            elif count%2==1 and count//2<=k and (y-x+1)%2==1:\\n                res.append(1)\\n            else:\\n                res.append(0)\\n        return res\\n        \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 1110549,
                "title": "c-prefixsum-and-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n\\t\\tvector<bool> res;\\n        vector<unsigned> presum(n+1,0);\\n        presum[1] |= 1<<(s[0]-\\'a\\');\\n        for (int i=1; i<n; i++)\\n            presum[i+1] = presum[i] ^ (1<<(s[i]-\\'a\\'));\\n        for(auto& q : queries)\\n        {\\n            int oddc = std::bitset<32>((presum[q[1]+1] ^ presum[q[0]])).count();\\n            if ((q[1]-q[0]+1 & 1))\\n                oddc -= 1;\\n            res.push_back(oddc/2 <= q[2]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n\\t\\tvector<bool> res;\\n        vector<unsigned> presum(n+1,0);\\n        presum[1] |= 1<<(s[0]-\\'a\\');\\n        for (int i=1; i<n; i++)\\n            presum[i+1] = presum[i] ^ (1<<(s[i]-\\'a\\'));\\n        for(auto& q : queries)\\n        {\\n            int oddc = std::bitset<32>((presum[q[1]+1] ^ presum[q[0]])).count();\\n            if ((q[1]-q[0]+1 & 1))\\n                oddc -= 1;\\n            res.push_back(oddc/2 <= q[2]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1005789,
                "title": "c-solution-prefix-sum",
                "content": "1. Compute frequency of each character for all the prefixes( which is frequency of each char upto that index).\\n2. Then find the count of every char between start and end point of each query.\\n3. Then for each query,  find the no. of characters whose frequency is odd as there is no need to replace the characters whose frequency is even for making the substring palindrome.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) \\n    {\\n        int n=s.length() ;\\n        vector<bool> ans ;\\n        vector<vector<int>> freq( n , vector<int>(26,0) ) ; // prefix vector \\n        \\n        for( int i=0 ; i<n ; i++ )\\n        {\\n            if( i>0 )\\n            {\\n                for( int j=0 ; j<26 ; j++ )\\n                {\\n                    freq[i][j]  = freq[i-1][j] ;\\n                }\\n            }\\n            freq[i][s[i]-\\'a\\']++ ;\\n        }\\n        \\n        for( int i=0 ; i<queries.size() ; i++ )\\n        {\\n            int st=queries[i][0] , e=queries[i][1] , k=queries[i][2] ;\\n            vector<int> temp(26,0) ; // frequency of characters of current substring\\n            if( st>0 )\\n            {\\n                for( int j=0 ; j<26 ; j++ )\\n                {\\n                    temp[j] = freq[e][j] - freq[st-1][j] ;\\n                }\\n            }\\n            else\\n            {\\n                temp = freq[e] ;\\n            } \\n            \\n            // counting no. of characters that appear odd no. of times\\n            int odd=0  ;\\n            for( int i=0 ; i<26 ; i++ )\\n            {\\n                if(  temp[i]%2!=0) odd++ ;\\n            }\\n            \\n            // if the length of the substring is odd then we can have one character whose frequency is odd in the palindorme and place it in the middle  \\n            if( (e-st+1)%2!=0 )\\n                odd-- ;\\n\\n            if( odd/2 <= k ) //Note that the value of the variable odd will always be even, that is, it will always be divisible by 2  \\n                ans.push_back(true) ;\\n            else\\n                ans.push_back(false) ;\\n        }\\n        return ans ;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) \\n    {\\n        int n=s.length() ;\\n        vector<bool> ans ;\\n        vector<vector<int>> freq( n , vector<int>(26,0) ) ; // prefix vector \\n        \\n        for( int i=0 ; i<n ; i++ )\\n        {\\n            if( i>0 )\\n            {\\n                for( int j=0 ; j<26 ; j++ )\\n                {\\n                    freq[i][j]  = freq[i-1][j] ;\\n                }\\n            }\\n            freq[i][s[i]-\\'a\\']++ ;\\n        }\\n        \\n        for( int i=0 ; i<queries.size() ; i++ )\\n        {\\n            int st=queries[i][0] , e=queries[i][1] , k=queries[i][2] ;\\n            vector<int> temp(26,0) ; // frequency of characters of current substring\\n            if( st>0 )\\n            {\\n                for( int j=0 ; j<26 ; j++ )\\n                {\\n                    temp[j] = freq[e][j] - freq[st-1][j] ;\\n                }\\n            }\\n            else\\n            {\\n                temp = freq[e] ;\\n            } \\n            \\n            // counting no. of characters that appear odd no. of times\\n            int odd=0  ;\\n            for( int i=0 ; i<26 ; i++ )\\n            {\\n                if(  temp[i]%2!=0) odd++ ;\\n            }\\n            \\n            // if the length of the substring is odd then we can have one character whose frequency is odd in the palindorme and place it in the middle  \\n            if( (e-st+1)%2!=0 )\\n                odd-- ;\\n\\n            if( odd/2 <= k ) //Note that the value of the variable odd will always be even, that is, it will always be divisible by 2  \\n                ans.push_back(true) ;\\n            else\\n                ans.push_back(false) ;\\n        }\\n        return ans ;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003124,
                "title": "java-prefix-sum-o-n-solution",
                "content": "Shockingly, O(26 * n) solution is too slow in Java...\\n```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> res = new ArrayList<>();\\n        int n = s.length();\\n        int[][] presum = new int[n + 1][26];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                presum[i][j] += presum[i - 1][j] + ((s.charAt(i - 1) - \\'a\\' == j) ? 1 : 0);\\n            }\\n        }\\n        for (int[] query : queries) {\\n            int odd = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if ((presum[query[1] + 1][i] - presum[query[0]][i]) % 2 == 1) {\\n                    odd++;\\n                }\\n            }\\n            res.add(odd / 2 <= query[2] ? true : false);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> res = new ArrayList<>();\\n        int n = s.length();\\n        int[][] presum = new int[n + 1][26];\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                presum[i][j] += presum[i - 1][j] + ((s.charAt(i - 1) - \\'a\\' == j) ? 1 : 0);\\n            }\\n        }\\n        for (int[] query : queries) {\\n            int odd = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if ((presum[query[1] + 1][i] - presum[query[0]][i]) % 2 == 1) {\\n                    odd++;\\n                }\\n            }\\n            res.add(odd / 2 <= query[2] ? true : false);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002159,
                "title": "python-beats-86-in-time-space-detailed-explanation",
                "content": "Time O(N), Space O(N) Solution\\n\\nHOW TO MAKE A SUBSTRING A PALINDROME\\n\\nTo make a palindorime, we should look at the character counts. There should be at most 1 character\\nthat has an odd count, or we don\\'t have a palindrome. Given any substring, let\\'s say odd_count of the chars have an odd count. \\nWe should reduce the odd count as much as possible. With one replacement, we can make two odd counts even. \\nFor example say counts a:\\'4\\', b:\\'3\\', c:\\'5\\', d:\\'3\\'. We can replace a c by b, which will yield new counts: a:\\'4\\', b:\\'4\\', c:\\'4\\', d:\\'3\\'. \\nAfter reordering, this array will be a palindrome because it has at most one character with odd count. \\n\\nGiven the number of odd counted chars in a substring, and number or replacements k, we can determine if it can\\nbe a palindrome in O(1) time.\\n\\nHOW TO COUNT ODD_COUNTS FOR EACH SUBSTRING\\n\\nFor each index, calculate the parities up until that index.\\nLet\\'s say there are 3 chars in total, so parity arrays will be of size 3. For string\\nabacab, we will have:\\n\\'\\':       [F,F,F]\\n\\'a\\':      [T,F,F]\\n\\'ab\\':     [T,T,F]\\n\\'aba\\':    [F,T,F]\\n\\'abac\\':   [F,T,T]\\n\\'abaca\\':  [T,T,T]\\n\\'abacab\\': [T,F,T]\\n\\nFor each substring, we can get the number of odd elements as follows:\\n\\nConsider \\'baca\\' substring. Before it we have prefix \\'a\\'. The full prefix including \\'baca\\' is \\'abaca\\'\\nWe can determine how many odd characters are between by counting the different bits of \\'a\\' and \\'abaca\\'.\\n\\t- If a bit flipped, it means we have come accross an odd number of chars in this range. \\n\\t- If it didn\\'t flip we have come across an even number of chars (including 0)\\n\\nWe are only interested in the number of odd counts chars. \\nIn the above case there are two flips, \\'baca\\' has two odd counted chars.\\n\\n```\\nclass Solution\\n\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        \\n        def toggle_bit(value, bit):\\n            return value ^ (1 << bit)\\n        \\n        def count_one_bits(value):\\n            return bin(value).count(\"1\")\\n        \\n        odd_counts = dict()\\n        offset = ord(\\'a\\')\\n        res = []\\n        \\n        all_parities = []\\n        parity = 0\\n        all_parities.append(parity)\\n        \\n        for char in s:\\n            char_idx = ord(char) - offset\\n            parity = toggle_bit(parity, char_idx)\\n            all_parities.append(parity)\\n        \\n        for q in queries:\\n            \\n            key = (q[0], q[1]+1)\\n            p1, p2 = all_parities[q[0]], all_parities[q[1]+1]\\n            diff = p1 ^ p2\\n            odd_count = count_one_bits(diff)\\n            # print(odd_count)\\n            \\n            can_make_pali = (odd_count - q[2]*2) <= 1\\n            res.append(can_make_pali)\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        \\n        def toggle_bit(value, bit):\\n            return value ^ (1 << bit)\\n        \\n        def count_one_bits(value):\\n            return bin(value).count(\"1\")\\n        \\n        odd_counts = dict()\\n        offset = ord(\\'a\\')\\n        res = []\\n        \\n        all_parities = []\\n        parity = 0\\n        all_parities.append(parity)\\n        \\n        for char in s:\\n            char_idx = ord(char) - offset\\n            parity = toggle_bit(parity, char_idx)\\n            all_parities.append(parity)\\n        \\n        for q in queries:\\n            \\n            key = (q[0], q[1]+1)\\n            p1, p2 = all_parities[q[0]], all_parities[q[1]+1]\\n            diff = p1 ^ p2\\n            odd_count = count_one_bits(diff)\\n            # print(odd_count)\\n            \\n            can_make_pali = (odd_count - q[2]*2) <= 1\\n            res.append(can_make_pali)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824483,
                "title": "kotlin-prefix-sums",
                "content": "```\\nclass Solution {\\n    fun canMakePaliQueries(s: String, queries: Array<IntArray>): BooleanArray {\\n        var pre = Array(s.length+1) { IntArray(26) }\\n        var res = mutableListOf<Boolean>()\\n        for((i, c) in s.withIndex()) {\\n            pre[i+1] = pre[i].clone()\\n            ++pre[i+1][c - \\'a\\']\\n        }\\n\\n        for(q in queries) {\\n            val l = q[0]\\n            val r = q[1]\\n            var k = q[2]\\n            var odd = 0\\n            for(c in \"abcdefghijklmnopqrstuvwxyz\") {\\n                odd += (pre[r+1][c - \\'a\\'] - pre[l][c - \\'a\\']) % 2\\n            }\\n            res.add((odd / 2) <= k)\\n        }\\n        return res.toBooleanArray()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun canMakePaliQueries(s: String, queries: Array<IntArray>): BooleanArray {\\n        var pre = Array(s.length+1) { IntArray(26) }\\n        var res = mutableListOf<Boolean>()\\n        for((i, c) in s.withIndex()) {\\n            pre[i+1] = pre[i].clone()\\n            ++pre[i+1][c - \\'a\\']\\n        }\\n\\n        for(q in queries) {\\n            val l = q[0]\\n            val r = q[1]\\n            var k = q[2]\\n            var odd = 0\\n            for(c in \"abcdefghijklmnopqrstuvwxyz\") {\\n                odd += (pre[r+1][c - \\'a\\'] - pre[l][c - \\'a\\']) % 2\\n            }\\n            res.add((odd / 2) <= k)\\n        }\\n        return res.toBooleanArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683719,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution \\n{\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) \\n    {\\n        List<Boolean> list = new ArrayList<>();\\n        \\n        int n = s.length();\\n        int[][] map = new int[n+1][26];\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            for(int j=0;j<26;j++)\\n                map[i+1][j] = map[i][j];\\n            \\n            map[i+1][s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int[] q : queries)\\n        {\\n            int l = q[0];\\n            int r = q[1];\\n            int k = q[2];\\n            int count = 0;\\n            \\n            for(int i=0;i<26;i++)\\n                count += (map[r+1][i] - map[l][i]) % 2;\\n            \\n            list.add(count/2 <= k);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) \\n    {\\n        List<Boolean> list = new ArrayList<>();\\n        \\n        int n = s.length();\\n        int[][] map = new int[n+1][26];\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            for(int j=0;j<26;j++)\\n                map[i+1][j] = map[i][j];\\n            \\n            map[i+1][s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int[] q : queries)\\n        {\\n            int l = q[0];\\n            int r = q[1];\\n            int k = q[2];\\n            int count = 0;\\n            \\n            for(int i=0;i<26;i++)\\n                count += (map[r+1][i] - map[l][i]) % 2;\\n            \\n            list.add(count/2 <= k);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653757,
                "title": "c-prefix-odd-even-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        preprocess(s);\\n        std::vector<bool> answer;\\n        for (const auto& query : queries) {\\n            const auto oddNum = std::bitset<26>(prefix[query[1] + 1] ^ prefix[query[0]]).count();\\n            answer.emplace_back(oddNum / 2 <= query[2]);\\n        }\\n        return answer;\\n    }\\n\\nprivate:\\n    void preprocess(const string& s) {\\n        prefix = std::vector<unsigned>(s.size() + 1, 0);\\n        for (std::size_t i = 1; i <= s.size(); ++i) {\\n            prefix[i] = prefix[i - 1] ^ (1u << (s[i - 1] - \\'a\\'));\\n        }\\n    }\\n\\n    std::vector<unsigned> prefix;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        preprocess(s);\\n        std::vector<bool> answer;\\n        for (const auto& query : queries) {\\n            const auto oddNum = std::bitset<26>(prefix[query[1] + 1] ^ prefix[query[0]]).count();\\n            answer.emplace_back(oddNum / 2 <= query[2]);\\n        }\\n        return answer;\\n    }\\n\\nprivate:\\n    void preprocess(const string& s) {\\n        prefix = std::vector<unsigned>(s.size() + 1, 0);\\n        for (std::size_t i = 1; i <= s.size(); ++i) {\\n            prefix[i] = prefix[i - 1] ^ (1u << (s[i - 1] - \\'a\\'));\\n        }\\n    }\\n\\n    std::vector<unsigned> prefix;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652205,
                "title": "c-faster-than-83-33-less-than-100-00-mem-o-max-n-q",
                "content": "Runtime: 620 ms\\nMemory Usage: 59.4 MB\\n\\nO(Max(N,Q)) where N is the length of s and Q is the length of queries.\\n\\n```\\n    public IList<bool> CanMakePaliQueries(string s, int[][] queries) {\\n        int[] dp = new int[s.Length];\\n        \\n        dp[0] = 1 << (s[0]-\\'a\\');\\n        \\n        for(int i=1; i< dp.Length; i++)\\n        {\\n            dp[i] = dp[i-1] ^ (1 << (s[i]-\\'a\\'));\\n        }\\n        \\n        IList<bool> result = new List<bool>();\\n        int oddCount = 0;\\n        int num = 0;\\n        \\n        foreach(int[] query in queries)\\n        {\\n            num = dp[query[1]];\\n            \\n            if (query[0] != 0)\\n            {\\n               num ^= dp[query[0]-1];\\n            }\\n           \\n            oddCount = BitCount(num);\\n            \\n            result.Add(oddCount <= 1 || query[2] >= oddCount/2);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int BitCount(int num)\\n    {\\n        int i=0; \\n        while(num > 0)\\n        {\\n            if((num&1) == 1) { i++;}\\n            num >>= 1;\\n        }\\n        return i;\\n    }",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "Runtime: 620 ms\\nMemory Usage: 59.4 MB\\n\\nO(Max(N,Q)) where N is the length of s and Q is the length of queries.\\n\\n```\\n    public IList<bool> CanMakePaliQueries(string s, int[][] queries) {\\n        int[] dp = new int[s.Length];\\n        \\n        dp[0] = 1 << (s[0]-\\'a\\');\\n        \\n        for(int i=1; i< dp.Length; i++)\\n        {\\n            dp[i] = dp[i-1] ^ (1 << (s[i]-\\'a\\'));\\n        }\\n        \\n        IList<bool> result = new List<bool>();\\n        int oddCount = 0;\\n        int num = 0;\\n        \\n        foreach(int[] query in queries)\\n        {\\n            num = dp[query[1]];\\n            \\n            if (query[0] != 0)\\n            {\\n               num ^= dp[query[0]-1];\\n            }\\n           \\n            oddCount = BitCount(num);\\n            \\n            result.Add(oddCount <= 1 || query[2] >= oddCount/2);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int BitCount(int num)\\n    {\\n        int i=0; \\n        while(num > 0)\\n        {\\n            if((num&1) == 1) { i++;}\\n            num >>= 1;\\n        }\\n        return i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 581782,
                "title": "1177-can-make-palindrome-from-substring-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Brute Force**\\n| O(T): O() | O(S): O() | Rt: ms | TLE\\n```python\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        rst = []\\n        for st, end, k in queries:\\n            m = [0] * 26\\n            for i in range(st, end+1):\\n                ind = ord(s[i]) - ord(\\'a\\')\\n                m[ind] += 1\\n                if m[ind] == 2: m[ind] = 0\\n            if sum(m) // 2 <= k: rst.append(True)\\n            else: rst.append(False)\\n        return rst\\n```\\n\\n\\n**II). Prefix Sum with Bucket Snapshot**\\n| O(T): O() | O(S): O() | Rt: 2872ms | \\n```python\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        l, m = len(s), [0] * 26\\n        presum = [[0]*26 for _ in range(l+1)]\\n        for i in range(l):\\n            m[ord(s[i]) - ord(\\'a\\')] += 1\\n            presum[i+1] = m[:]\\n  \\n        rst = []\\n        for st, end, k in queries:\\n            arr = [presum[end+1][i] - presum[st][i] for i in range(26)]\\n            if sum(i % 2 for i in arr) // 2 <= k: rst.append(True)\\n            else: rst.append(False)\\n        return rst\\n```\\n\\nAlternative: with xor; | Rt: 2480ms |\\n```python\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        l, m = len(s), [0] * 26\\n        presum = [[0]*26 for _ in range(l+1)]\\n        for i in range(l):\\n            m[ord(s[i]) - ord(\\'a\\')] ^= 1\\n            presum[i+1] = m[:]\\n  \\n        rst = []\\n        for st, end, k in queries:\\n            arr = [presum[end+1][i] ^ presum[st][i] for i in range(26)]\\n            rst.append(sum(arr)//2 <= k)\\n        return rst\\n```\\n\\n\\n**III). Bit Manipulation**\\n| O(T): O() | O(S): O() | Rt: 1420ms | \\n```python\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        l, m = len(s), 0\\n        presum = [0] * (l+1)\\n        for i in range(l):\\n            m ^= (1 << (ord(s[i]) - ord(\\'a\\')))\\n            presum[i+1] = m\\n  \\n        rst, mask = [], 0x3ffffff\\n        for st, end, k in queries:\\n            bi = (presum[end+1] ^ presum[st]) & mask\\n            rst.append(bin(bi).count(\\'1\\')//2 <= k)\\n        return rst\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        rst = []\\n        for st, end, k in queries:\\n            m = [0] * 26\\n            for i in range(st, end+1):\\n                ind = ord(s[i]) - ord(\\'a\\')\\n                m[ind] += 1\\n                if m[ind] == 2: m[ind] = 0\\n            if sum(m) // 2 <= k: rst.append(True)\\n            else: rst.append(False)\\n        return rst\\n```\n```python\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        l, m = len(s), [0] * 26\\n        presum = [[0]*26 for _ in range(l+1)]\\n        for i in range(l):\\n            m[ord(s[i]) - ord(\\'a\\')] += 1\\n            presum[i+1] = m[:]\\n  \\n        rst = []\\n        for st, end, k in queries:\\n            arr = [presum[end+1][i] - presum[st][i] for i in range(26)]\\n            if sum(i % 2 for i in arr) // 2 <= k: rst.append(True)\\n            else: rst.append(False)\\n        return rst\\n```\n```python\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        l, m = len(s), [0] * 26\\n        presum = [[0]*26 for _ in range(l+1)]\\n        for i in range(l):\\n            m[ord(s[i]) - ord(\\'a\\')] ^= 1\\n            presum[i+1] = m[:]\\n  \\n        rst = []\\n        for st, end, k in queries:\\n            arr = [presum[end+1][i] ^ presum[st][i] for i in range(26)]\\n            rst.append(sum(arr)//2 <= k)\\n        return rst\\n```\n```python\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        l, m = len(s), 0\\n        presum = [0] * (l+1)\\n        for i in range(l):\\n            m ^= (1 << (ord(s[i]) - ord(\\'a\\')))\\n            presum[i+1] = m\\n  \\n        rst, mask = [], 0x3ffffff\\n        for st, end, k in queries:\\n            bi = (presum[end+1] ^ presum[st]) & mask\\n            rst.append(bin(bi).count(\\'1\\')//2 <= k)\\n        return rst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 552385,
                "title": "c-easy-to-understand-o-n-solution-with-comments-without-any-bit-manipulation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        //This is a tricky question \\n        int n=s.size();\\n        vector<int> freqChar(26);\\n        vector<vector<int>> v(n);  //v contains frequency of characaters till ith position for interval n\\n        for(int i=0;i<n;i++){\\n            freqChar[s[i]-\\'a\\']++;\\n            v[i]=freqChar;\\n        }\\n        int m=queries.size();\\n        vector<bool> ans(m);\\n        for(int i=0;i<m;i++){\\n            int l=queries[i][0],r=queries[i][1],k=queries[i][2];\\n            vector<int> charFreqInR(26);  //Tells character freq in given range\\n            for(int j=0;j<26;j++){\\n                if(l-1>=0){\\n                    charFreqInR[j]=v[r][j]-v[l-1][j];\\n                }\\n                else{\\n                    charFreqInR[j]=v[r][j];\\n                }\\n            }\\n            //Now I now which characters I have in the given range \\n            //Now I ahve to see if making palindrome is possible\\n            if((l==r)||((r-l+1)==(k-1))){\\n                ans[i]=true;\\n            }\\n            else{\\n                int changeNeeded=0;\\n                for(int k=0;k<26;k++){\\n                    changeNeeded+=charFreqInR[k]%2;\\n                }\\n                if(changeNeeded/2>k){\\n                    ans[i]=false;\\n                }\\n                else{\\n                    ans[i]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        //This is a tricky question \\n        int n=s.size();\\n        vector<int> freqChar(26);\\n        vector<vector<int>> v(n);  //v contains frequency of characaters till ith position for interval n\\n        for(int i=0;i<n;i++){\\n            freqChar[s[i]-\\'a\\']++;\\n            v[i]=freqChar;\\n        }\\n        int m=queries.size();\\n        vector<bool> ans(m);\\n        for(int i=0;i<m;i++){\\n            int l=queries[i][0],r=queries[i][1],k=queries[i][2];\\n            vector<int> charFreqInR(26);  //Tells character freq in given range\\n            for(int j=0;j<26;j++){\\n                if(l-1>=0){\\n                    charFreqInR[j]=v[r][j]-v[l-1][j];\\n                }\\n                else{\\n                    charFreqInR[j]=v[r][j];\\n                }\\n            }\\n            //Now I now which characters I have in the given range \\n            //Now I ahve to see if making palindrome is possible\\n            if((l==r)||((r-l+1)==(k-1))){\\n                ans[i]=true;\\n            }\\n            else{\\n                int changeNeeded=0;\\n                for(int k=0;k<26;k++){\\n                    changeNeeded+=charFreqInR[k]%2;\\n                }\\n                if(changeNeeded/2>k){\\n                    ans[i]=false;\\n                }\\n                else{\\n                    ans[i]=true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542014,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> cnt(s.size(), vector<int>(26, 0));\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(i) cnt[i] = cnt[i-1];\\n            cnt[i][s[i]-\\'a\\']++;\\n        }\\n        \\n        vector<bool> out;\\n        for(int i = 0; i < queries.size(); i++)\\n        {\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            int n = queries[i][2];\\n            int sum = 0;\\n            for(int j = 0; j <26; j++) \\n            {\\n                if(left == 0) sum += (cnt[right][j]%2);\\n                else sum += ((cnt[right][j]-cnt[left-1][j])%2);\\n            }\\n            \\n            if(n >= sum/2) out.push_back(true);\\n            else out.push_back(false);\\n        }\\n        return out;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> cnt(s.size(), vector<int>(26, 0));\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(i) cnt[i] = cnt[i-1];\\n            cnt[i][s[i]-\\'a\\']++;\\n        }\\n        \\n        vector<bool> out;\\n        for(int i = 0; i < queries.size(); i++)\\n        {\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            int n = queries[i][2];\\n            int sum = 0;\\n            for(int j = 0; j <26; j++) \\n            {\\n                if(left == 0) sum += (cnt[right][j]%2);\\n                else sum += ((cnt[right][j]-cnt[left-1][j])%2);\\n            }\\n            \\n            if(n >= sum/2) out.push_back(true);\\n            else out.push_back(false);\\n        }\\n        return out;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509156,
                "title": "go-solution-100-100",
                "content": "```\\nfunc canMakePaliQueries(s string, queries [][]int) []bool {\\n    var res []bool\\n    var c [][]int\\n    c = append(c, make([]int, 26))\\n    for i := 0; i < len(s); i ++{\\n        if i > 0 {\\n            c = append(c, make([]int, 26))\\n            for j := 0; j < 26; j ++{\\n                c[i][j] = c[i - 1][j]\\n            }\\n        }\\n        c[i][s[i] - \\'a\\'] ++\\n    }\\n    for i := 0; i < len(queries); i ++{\\n        count := 0\\n        for j := 0; j < 26; j ++{\\n            tmp := c[queries[i][1]][j]\\n            if queries[i][0] != 0 {\\n                tmp -= c[queries[i][0] - 1][j]\\n            }\\n            if tmp % 2 != 0 {\\n                count ++\\n            }\\n        }\\n        res = append(res, count / 2 <= queries[i][2])\\n    }    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canMakePaliQueries(s string, queries [][]int) []bool {\\n    var res []bool\\n    var c [][]int\\n    c = append(c, make([]int, 26))\\n    for i := 0; i < len(s); i ++{\\n        if i > 0 {\\n            c = append(c, make([]int, 26))\\n            for j := 0; j < 26; j ++{\\n                c[i][j] = c[i - 1][j]\\n            }\\n        }\\n        c[i][s[i] - \\'a\\'] ++\\n    }\\n    for i := 0; i < len(queries); i ++{\\n        count := 0\\n        for j := 0; j < 26; j ++{\\n            tmp := c[queries[i][1]][j]\\n            if queries[i][0] != 0 {\\n                tmp -= c[queries[i][0] - 1][j]\\n            }\\n            if tmp % 2 != 0 {\\n                count ++\\n            }\\n        }\\n        res = append(res, count / 2 <= queries[i][2])\\n    }    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 475173,
                "title": "python-3-bitmask-accumulator-solution",
                "content": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        def gen():\\n            acc = 0\\n            yield acc\\n            for c in s:\\n                acc = acc^( 1<<(ord(c)-97))\\n                yield acc\\n\\t\\t# prefix xor accumulator: if ith bit is zero - there was even number of chr(i+96); if it is one - odd.\\n        d=[c for c in gen()]\\n\\t\\t# accumulate result with dull popcount()\\n        ans=[(bin(d[l]^d[r+1]).count(\"1\")<=2*k+1) for l,r,k in queries]\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        def gen():\\n            acc = 0\\n            yield acc\\n            for c in s:\\n                acc = acc^( 1<<(ord(c)-97))\\n                yield acc\\n\\t\\t# prefix xor accumulator: if ith bit is zero - there was even number of chr(i+96); if it is one - odd.\\n        d=[c for c in gen()]\\n\\t\\t# accumulate result with dull popcount()\\n        ans=[(bin(d[l]^d[r+1]).count(\"1\")<=2*k+1) for l,r,k in queries]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437649,
                "title": "c-bitset-solution",
                "content": "```vector<bitset<26>> bitmap(s.size()+1);``` Because this first element of ```bitmap``` is initial bit state.\\n```auto tmp = bitmap[begin] ^ bitmap[end+1];``` if we want to get the state of [begin, end], we need to strip [0, begin-1]. For here ```begin``` is actual ```begin-1``` since I have a initial state. \\n```cpp\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool> res;\\n        vector<bitset<26>> bitmap(s.size()+1);\\n        bitset<26> bit;\\n\\t\\t\\n        for(int i=0; i<s.size(); i++){\\n            bit.flip(s[i] - \\'a\\');\\n            bitmap[i+1] = bit;\\n        }\\n        \\n        for(int i=0; i<queries.size();i++){\\n            if(queries[i][2] >= 13){\\n                res.push_back(true);\\n                continue;\\n            }\\n            int begin = queries[i][0], end = queries[i][1];\\n            auto tmp = bitmap[begin] ^ bitmap[end+1];\\n            if(tmp.count()/2 <= queries[i][2]){\\n                res.push_back(true);\\n                continue;\\n            }\\n            res.push_back(false);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```vector<bitset<26>> bitmap(s.size()+1);```\n```bitmap```\n```auto tmp = bitmap[begin] ^ bitmap[end+1];```\n```begin```\n```begin-1```\n```cpp\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool> res;\\n        vector<bitset<26>> bitmap(s.size()+1);\\n        bitset<26> bit;\\n\\t\\t\\n        for(int i=0; i<s.size(); i++){\\n            bit.flip(s[i] - \\'a\\');\\n            bitmap[i+1] = bit;\\n        }\\n        \\n        for(int i=0; i<queries.size();i++){\\n            if(queries[i][2] >= 13){\\n                res.push_back(true);\\n                continue;\\n            }\\n            int begin = queries[i][0], end = queries[i][1];\\n            auto tmp = bitmap[begin] ^ bitmap[end+1];\\n            if(tmp.count()/2 <= queries[i][2]){\\n                res.push_back(true);\\n                continue;\\n            }\\n            res.push_back(false);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414015,
                "title": "modern-c-using-bitset-detailed-comments-same-solution-as-everyone-s",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    inline const vector<bool> canMakePaliQueries(\\n        const string & s, \\n        const vector<vector<int>>& queries) const \\n    {\\n        // define a bitset with the allowed chars range (26)\\n        using CharBitset = bitset<26>;\\n        \\n        // define a vector to count the pairty of the chars\\n        vector<CharBitset> pairtyVec;\\n        \\n        // reserve memory to lower the amount of allocations\\n        // notice the \"+ 1\" - as we need one extra for the inital state\\n        pairtyVec.reserve(s.size() + 1);\\n        \\n        // this is the bitset we will update in the loop\\n        CharBitset curBitSet;\\n        \\n        // add an inital \"all set to false\" bitset as our start\\n        pairtyVec.push_back(curBitSet);\\n        \\n        // loop the chars\\n        for(const auto c : s)            \\n        {\\n            // flip the current pairty\\n            curBitSet[ c - \\'a\\' ].flip();\\n            \\n            // push back to our vector\\n            pairtyVec.push_back(curBitSet);\\n        }\\n \\n        // create res vec\\n        vector<bool> res;\\n        \\n        // reserve to save allocations\\n        res.reserve(queries.size());\\n        \\n        // loop the queries\\n        for(const auto & q : queries)\\n        {\\n            // get the start bitset\\n            const auto & startBs = pairtyVec[ q[0] ];\\n            \\n            // get the end bitset - notice the \"+1\"\\n            const auto & endBs = pairtyVec[ q[1] + 1 ];\\n            \\n            // xor the bitsets, the bits that remain on are the odds\\n            const auto diffBs = startBs ^ endBs;\\n            \\n            // use count() to get the \"on\" bits\\n            const auto oddsCount = diffBs.count();\\n            \\n            // this is the tricky part, let me explain\\n            // lets say we have 5 odds \"abcde\"\\n            // by replacing one of them to a diffrent one\\n            // we get rid of them both, for example if we change \\'a\\'\\n            // to \\'e\\' - then both of their count are even.\\n            // as we dvide the odd count that is an integer by 2\\n            // if the odd count is odd (for example 1) this is\\n            // ignored, as it should as we are allowed one odd\\n            // char count            \\n            const auto curRes = q[2] >= oddsCount / 2;\\n            \\n            // add to the result\\n            res.push_back(curRes);\\n        }\\n        \\n        // return the result\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    inline const vector<bool> canMakePaliQueries(\\n        const string & s, \\n        const vector<vector<int>>& queries) const \\n    {\\n        // define a bitset with the allowed chars range (26)\\n        using CharBitset = bitset<26>;\\n        \\n        // define a vector to count the pairty of the chars\\n        vector<CharBitset> pairtyVec;\\n        \\n        // reserve memory to lower the amount of allocations\\n        // notice the \"+ 1\" - as we need one extra for the inital state\\n        pairtyVec.reserve(s.size() + 1);\\n        \\n        // this is the bitset we will update in the loop\\n        CharBitset curBitSet;\\n        \\n        // add an inital \"all set to false\" bitset as our start\\n        pairtyVec.push_back(curBitSet);\\n        \\n        // loop the chars\\n        for(const auto c : s)            \\n        {\\n            // flip the current pairty\\n            curBitSet[ c - \\'a\\' ].flip();\\n            \\n            // push back to our vector\\n            pairtyVec.push_back(curBitSet);\\n        }\\n \\n        // create res vec\\n        vector<bool> res;\\n        \\n        // reserve to save allocations\\n        res.reserve(queries.size());\\n        \\n        // loop the queries\\n        for(const auto & q : queries)\\n        {\\n            // get the start bitset\\n            const auto & startBs = pairtyVec[ q[0] ];\\n            \\n            // get the end bitset - notice the \"+1\"\\n            const auto & endBs = pairtyVec[ q[1] + 1 ];\\n            \\n            // xor the bitsets, the bits that remain on are the odds\\n            const auto diffBs = startBs ^ endBs;\\n            \\n            // use count() to get the \"on\" bits\\n            const auto oddsCount = diffBs.count();\\n            \\n            // this is the tricky part, let me explain\\n            // lets say we have 5 odds \"abcde\"\\n            // by replacing one of them to a diffrent one\\n            // we get rid of them both, for example if we change \\'a\\'\\n            // to \\'e\\' - then both of their count are even.\\n            // as we dvide the odd count that is an integer by 2\\n            // if the odd count is odd (for example 1) this is\\n            // ignored, as it should as we are allowed one odd\\n            // char count            \\n            const auto curRes = q[2] >= oddsCount / 2;\\n            \\n            // add to the result\\n            res.push_back(curRes);\\n        }\\n        \\n        // return the result\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393794,
                "title": "java-bit-manipulation-17ms-20-lines-code",
                "content": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        int len = s.length();\\n        int[] bits = new int[len];\\n        int his = 0;\\n        for (int i = 0; i < len; i++) {\\n            his = his ^ (1 << (s.charAt(i) - \\'a\\'));\\n            bits[i] = his;\\n        }\\n        List<Boolean> result = new ArrayList<>();\\n        for (int i = 0; i < queries.length; i++) {\\n            int[] query = queries[i];\\n            int tmp = (query[0] == 0 ? 0 : bits[query[0] - 1]) ^ bits[query[1]];//when index=0, the previous one is 0\\n            int odd = 0;\\n            while (tmp != 0) {\\n                odd += tmp & 1;\\n                tmp >>>= 1;\\n            }\\n            result.add(query[2] >= odd / 2);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        int len = s.length();\\n        int[] bits = new int[len];\\n        int his = 0;\\n        for (int i = 0; i < len; i++) {\\n            his = his ^ (1 << (s.charAt(i) - \\'a\\'));\\n            bits[i] = his;\\n        }\\n        List<Boolean> result = new ArrayList<>();\\n        for (int i = 0; i < queries.length; i++) {\\n            int[] query = queries[i];\\n            int tmp = (query[0] == 0 ? 0 : bits[query[0] - 1]) ^ bits[query[1]];//when index=0, the previous one is 0\\n            int odd = 0;\\n            while (tmp != 0) {\\n                odd += tmp & 1;\\n                tmp >>>= 1;\\n            }\\n            result.add(query[2] >= odd / 2);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389042,
                "title": "not-sure-what-s-wrong-in-my-code-python-but-i-think-it-should-be-right",
                "content": "```\\nimport numpy as np\\nclass Solution:\\n    def canMakePaliQueries(self, our_string, queries):\\n        palindrome_list = []\\n        for i_querie in queries:\\n            \\n            string = our_string[i_querie[0]:(i_querie[1]+1)]\\n            left_string = string[:int(np.ceil(len(string)/2))]\\n            right_string = string[::-1][:int(np.ceil(len(string)/2))]\\n            \\n            not_equal_list = [False for value in left_string if value not in right_string]\\n            \\n            if len(not_equal_list) <= i_querie[2]:\\n                palindrome_list.append(True)\\n            else:\\n                palindrome_list.append(False)\\n        \\n        return palindrome_list\\n```\\n\\nI got an error but I\\'m not sure why it\\'s wrong, it shows like this:\\n\"pqtadspgvinafefk\"\\n[[1,14,5],[14,15,1],[15,15,1]]\\n\\nOutput\\n[false,true,true]\\nExpected\\n[true,true,true]\\n\\nIt seems that the first one was wrong, yet when I checked, it was to find a palindrome from: \\'qtadspg\\' and \\'fefaniv\\'(I\\'ve already made it into two sub-strings here). These two sub-strings only have one letter in common but we can only make 5 replacement, note that the total length for each sub-string is 7. Therefore apart from the only common letter: \\'a\\', we have to make the other 6 letters the same with only 5 replacement, how can we do that???\\n\\nIs the test answer wrong or what I think is incorrect?",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def canMakePaliQueries(self, our_string, queries):\\n        palindrome_list = []\\n        for i_querie in queries:\\n            \\n            string = our_string[i_querie[0]:(i_querie[1]+1)]\\n            left_string = string[:int(np.ceil(len(string)/2))]\\n            right_string = string[::-1][:int(np.ceil(len(string)/2))]\\n            \\n            not_equal_list = [False for value in left_string if value not in right_string]\\n            \\n            if len(not_equal_list) <= i_querie[2]:\\n                palindrome_list.append(True)\\n            else:\\n                palindrome_list.append(False)\\n        \\n        return palindrome_list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384416,
                "title": "java-simple-solution-can-pass-large-test-cases-solution-in-59-ms-beats-100-memory-use",
                "content": "The approach is called prefix sum\\n\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) { \\n        List<Boolean> result = new ArrayList<Boolean>();\\n        \\n\\t\\t//use a 2D array to record total number of [\\'a\\'-\\'z\\'] character in substring(0,n) \\n        int[][] dp = new int[s.length()+1][26];\\n        \\n\\t\\t//base case\\n        for(int i = 0; i<26; i++){\\n            dp[0][i] = 0;\\n        }\\n\\t\\t\\n        //record all the corresponding characters and their total number in substring(0,i-1)\\n        for(int i = 1;i<=s.length();i++){\\n            for(int j = 0; j<26;j++){\\n                dp[i][j] = dp[i-1][j];\\n            }\\n            char c = s.charAt(i-1);\\n            dp[i][c-\\'a\\'] +=1;\\n        }\\n        \\n\\t\\t//execute the queries\\n        for(int[] q: queries){\\n\\t\\t//because the corresponding string index in our 2D array starts at 1, so add 1 to left and right index\\n            int left = q[0] + 1;\\n            int right = q[1] + 1;\\n            int k = q[2];\\n\\t\\t\\t\\n\\t\\t\\t//if k is large than 13, means we can change any substring to a palindrome\\n            if(k>=13)\\n                result.add(true);\\n\\t\\t\\t\\t\\n\\t\\t\\t//else read from the 2D array to see how many extra characters are within substring (left, right)\\n\\t\\t\\t//if the number of extra characters/2 are less than k, add true\\n            else{\\n                int sum = 0;\\n                for(int i = 0; i<26;i++)\\n                    sum += (dp[right][i] - dp[left-1][i]) % 2;\\n                result.add(sum/2<=k);\\n            }\\n        }\\n        return result;      \\n    }\\n\\nSample Run:\\nfor string \"abcad\", the corresponding dp[][] will be:\\nindex 0 1 2 3 4 5\\nadd       a b c a d\\n   \\'a\\'   0 1 1 1 2 2\\n   \\'b\\'\\t 0 0 1 1 1 1\\n   \\'c\\'   0 0 0 1 1 1\\n   \\'d\\'   0 0 0 0 0 1\\n   \\'e\\'   0 0 0 0 0 0\\n   \\'f\\'    0 0 0 0 0 0\\n   ......[no other characters in this example, will be all 0]\\n   \\'z\\'   0 0 0 0 0 0\\n \\n for query [0,3,1], we only want to know the number of extra character that we add in index 1,2,3,4, so we just need to check (dp[4][i] - dp[0][i]) %2 for all characters i: \\n (1-0)%2 + (1-0) %2+ (1-0)%2 + (1-0) %2 + ... + (0-0) %2 = 4\\n \\n since 4/2=2>1, so [0,3,1] is false\\n \\n** [I am a bad explainer, hope this can help!]**\\n",
                "solutionTags": [],
                "code": "The approach is called prefix sum\\n\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) { \\n        List<Boolean> result = new ArrayList<Boolean>();\\n        \\n\\t\\t//use a 2D array to record total number of [\\'a\\'-\\'z\\'] character in substring(0,n) \\n        int[][] dp = new int[s.length()+1][26];\\n        \\n\\t\\t//base case\\n        for(int i = 0; i<26; i++){\\n            dp[0][i] = 0;\\n        }\\n\\t\\t\\n        //record all the corresponding characters and their total number in substring(0,i-1)\\n        for(int i = 1;i<=s.length();i++){\\n            for(int j = 0; j<26;j++){\\n                dp[i][j] = dp[i-1][j];\\n            }\\n            char c = s.charAt(i-1);\\n            dp[i][c-\\'a\\'] +=1;\\n        }\\n        \\n\\t\\t//execute the queries\\n        for(int[] q: queries){\\n\\t\\t//because the corresponding string index in our 2D array starts at 1, so add 1 to left and right index\\n            int left = q[0] + 1;\\n            int right = q[1] + 1;\\n            int k = q[2];\\n\\t\\t\\t\\n\\t\\t\\t//if k is large than 13, means we can change any substring to a palindrome\\n            if(k>=13)\\n                result.add(true);\\n\\t\\t\\t\\t\\n\\t\\t\\t//else read from the 2D array to see how many extra characters are within substring (left, right)\\n\\t\\t\\t//if the number of extra characters/2 are less than k, add true\\n            else{\\n                int sum = 0;\\n                for(int i = 0; i<26;i++)\\n                    sum += (dp[right][i] - dp[left-1][i]) % 2;\\n                result.add(sum/2<=k);\\n            }\\n        }\\n        return result;      \\n    }\\n\\nSample Run:\\nfor string \"abcad\", the corresponding dp[][] will be:\\nindex 0 1 2 3 4 5\\nadd       a b c a d\\n   \\'a\\'   0 1 1 1 2 2\\n   \\'b\\'\\t 0 0 1 1 1 1\\n   \\'c\\'   0 0 0 1 1 1\\n   \\'d\\'   0 0 0 0 0 1\\n   \\'e\\'   0 0 0 0 0 0\\n   \\'f\\'    0 0 0 0 0 0\\n   ......[no other characters in this example, will be all 0]\\n   \\'z\\'   0 0 0 0 0 0\\n \\n for query [0,3,1], we only want to know the number of extra character that we add in index 1,2,3,4, so we just need to check (dp[4][i] - dp[0][i]) %2 for all characters i: \\n (1-0)%2 + (1-0) %2+ (1-0)%2 + (1-0) %2 + ... + (0-0) %2 = 4\\n \\n since 4/2=2>1, so [0,3,1] is false\\n \\n** [I am a bad explainer, hope this can help!]**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 375225,
                "title": "java",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> res = new ArrayList<>();\\n        int[][] sum = new int[s.length() + 1][26];\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < 26; j++) {\\n                sum[i + 1][j] = sum[i][j];\\n            }\\n            sum[i + 1][s.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            int start = queries[i][0];\\n            int end = queries[i][1];\\n            int k = queries[i][2];\\n            int count = 0;\\n            for (int j = 0; j < 26; j++) {\\n                int total = sum[end + 1][j] - sum[start][j];\\n                count += total%2;\\n            }\\n            res.add(count/2 <= k);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> res = new ArrayList<>();\\n        int[][] sum = new int[s.length() + 1][26];\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < 26; j++) {\\n                sum[i + 1][j] = sum[i][j];\\n            }\\n            sum[i + 1][s.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < queries.length; i++) {\\n            int start = queries[i][0];\\n            int end = queries[i][1];\\n            int k = queries[i][2];\\n            int count = 0;\\n            for (int j = 0; j < 26; j++) {\\n                int total = sum[end + 1][j] - sum[start][j];\\n                count += total%2;\\n            }\\n            res.add(count/2 <= k);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372112,
                "title": "java-prefix-sum",
                "content": "solution with prefix array, `pre[i][j]` means the num letter i(0 represents \\'a\\') at index j + 1 of `String s` so far. why we need j + 1, cause when we use the expression `pre[i][end] - pre[i][begin - 1]` the `pre[i][0]` is 0.\\n\\n```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        \\n        int[][] pre = new int[26][s.length() + 1];\\n        for(int i = 1; i <= s.length(); i++){\\n            \\n            for(int j = 0; j < 26; j ++){\\n                if(s.charAt(i-1) - \\'a\\' == j) pre[j][i] = pre[j][i-1] + 1;\\n                else pre[j][i] = pre[j][i-1];\\n            }\\n            \\n        }\\n        List<Boolean> v = new ArrayList<>();\\n        for(int i = 0; i < queries.length; i ++){\\n            int begin = queries[i][0];\\n            int end = queries[i][1];\\n            int k = queries[i][2];\\n            int f = 0;\\n            for(int j = 0; j < 26; j++){\\n                int num = pre[j][end + 1] - pre[j][begin];\\n                if(num%2 == 1)f++;\\n            }\\n            if(k >= f /2)v.add(true);\\n            else v.add(false);\\n        }\\n        return v;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        \\n        int[][] pre = new int[26][s.length() + 1];\\n        for(int i = 1; i <= s.length(); i++){\\n            \\n            for(int j = 0; j < 26; j ++){\\n                if(s.charAt(i-1) - \\'a\\' == j) pre[j][i] = pre[j][i-1] + 1;\\n                else pre[j][i] = pre[j][i-1];\\n            }\\n            \\n        }\\n        List<Boolean> v = new ArrayList<>();\\n        for(int i = 0; i < queries.length; i ++){\\n            int begin = queries[i][0];\\n            int end = queries[i][1];\\n            int k = queries[i][2];\\n            int f = 0;\\n            for(int j = 0; j < 26; j++){\\n                int num = pre[j][end + 1] - pre[j][begin];\\n                if(num%2 == 1)f++;\\n            }\\n            if(k >= f /2)v.add(true);\\n            else v.add(false);\\n        }\\n        return v;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372010,
                "title": "c-solution-with-complete-explanation",
                "content": "**How can we make a non-Palindromic string a Palindrome by changing  minimum characters?**\\n\\n**Explanation:**\\n\\nThe very first step is to count how many characters(a-z) occur odd number of times, because the characters which occur even number of times can be arranged such that we end up with a Palindromic string after arranging them.\\n \\n Eg- **aaaaccccaabb**\\n\\n1.  The frequency of \\'a\\' is 6\\n2.  The frequency of \\'b\\' is 2\\n3.  The frequency of \\'c\\' is 4\\n\\nThe string can be arranged in the following manner(one of the Possible arrangements)\\n\\n**aaabccccbaaa**\\n\\nSo if the frequency of a character is even , we don\\'t worry about that character as it can be arranged in a such a way that we end up with a Palindromic string after the arrangement.\\n\\nNow let\\'s take another example-\\n\\nEg- **aabbbaabba**\\n\\n1. The frequency of \\'a\\' 5\\n2. The frequency of \\'b\\' 5\\n\\nThere are two characters with odd frequency so after arranging 4 \\'a\\' and 4 \\'b\\' in a suitable way as shown above, we have one extra \\'a\\' and one extra \\'b\\', now how many characters do i need to change so that i get a Palindrome , the answer is 1 , I can change the \\'a\\' to \\'b\\' or the \\'b\\' to \\'a\\'.\\n\\n**Similarly if the number of charcters in  a string with odd frequency are let\\'s say cnt, we can make cnt/2 changes to get a Palindrome.**\\n\\nHence the answer for the i\\'th Query will be true if cnt/2 is less than k.\\n\\nBut how do we get the frequency of each character?\\n\\nThe answer is Prefix Sums.\\nLet freq[i][j] denote the frequency of j\\'th character (0-25) till i ( 0 to s.length( ) ) .\\n\\n**So what\\'s the time complexity?**\\n\\n1. For calculating Prefix Sums n times 26\\n2. For answering all the queries Q times 26\\n\\n**O(n times 26+Q times 26)**\\n```\\nvector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.length();\\n        \\n        int freq[n][26];\\n        \\n        memset(freq,0,sizeof(freq));\\n        \\n        int i,j;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            freq[i][s[i]-\\'a\\']++;\\n        }\\n        for(i=1;i<n;i++)\\n        {\\n            for(j=0;j<26;j++)\\n            {\\n                freq[i][j]+=freq[i-1][j];\\n            }\\n        }\\n        vector<bool> answer;\\n        int u;\\n        bool ok=true;\\n        for(i=0;i<queries.size();i++)\\n        {\\n            int l,r,k;\\n            l=queries[i][0];\\n            r=queries[i][1];\\n            k=queries[i][2];\\n            int cnt=0;\\n            for(j=0;j<26;j++)\\n            {\\n                if(l==0)\\n                    u=freq[r][j];\\n                else\\n                    u=freq[r][j]-freq[l-1][j];\\n                \\n                if(u%2==1)\\n                {\\n                    cnt++;\\n                }\\n            }\\n            \\n            if((cnt/2)<=k)\\n            {\\n                answer.push_back(ok);\\n            }\\n            else\\n            {\\n                answer.push_back(!ok);\\n            }\\n        }\\n        return answer;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.length();\\n        \\n        int freq[n][26];\\n        \\n        memset(freq,0,sizeof(freq));\\n        \\n        int i,j;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            freq[i][s[i]-\\'a\\']++;\\n        }\\n        for(i=1;i<n;i++)\\n        {\\n            for(j=0;j<26;j++)\\n            {\\n                freq[i][j]+=freq[i-1][j];\\n            }\\n        }\\n        vector<bool> answer;\\n        int u;\\n        bool ok=true;\\n        for(i=0;i<queries.size();i++)\\n        {\\n            int l,r,k;\\n            l=queries[i][0];\\n            r=queries[i][1];\\n            k=queries[i][2];\\n            int cnt=0;\\n            for(j=0;j<26;j++)\\n            {\\n                if(l==0)\\n                    u=freq[r][j];\\n                else\\n                    u=freq[r][j]-freq[l-1][j];\\n                \\n                if(u%2==1)\\n                {\\n                    cnt++;\\n                }\\n            }\\n            \\n            if((cnt/2)<=k)\\n            {\\n                answer.push_back(ok);\\n            }\\n            else\\n            {\\n                answer.push_back(!ok);\\n            }\\n        }\\n        return answer;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371921,
                "title": "java-preprocess-frequency-map-solution-beats-100",
                "content": "```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> ret = new ArrayList<>();\\n        \\n        int[][] freqDp = new int[s.length()][26];\\n        \\n        int[] freq = new int[26];\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            freq[s.charAt(i) - \\'a\\']++;\\n            freqDp[i] = freq.clone();\\n        }\\n        \\n        for (int[] q : queries) {\\n            ret.add(canMake(s, q[0], q[1], q[2], freqDp));\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    private boolean canMake(String s, int left, int right, int k, int[][] freqDp) {\\n        if (right - left + 1 == 1) return true;\\n        \\n        if (right - left + 1 <= k) return true;\\n        \\n        int[] freq = new int[26];\\n        \\n        for (int i = 0; i < 26; i++) {\\n            freq[i] = freqDp[right][i];\\n            if (left-1 >= 0)\\n                freq[i] -= freqDp[left-1][i];\\n        }\\n        \\n        int oddCount = 0;\\n        \\n        for (int n : freq) {\\n            if (n % 2 == 1) \\n                oddCount++;\\n        }\\n        \\n        if ((right - left + 1) % 2 == 1) oddCount -= 1;\\n        \\n        return k*2 >= oddCount;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> ret = new ArrayList<>();\\n        \\n        int[][] freqDp = new int[s.length()][26];\\n        \\n        int[] freq = new int[26];\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            freq[s.charAt(i) - \\'a\\']++;\\n            freqDp[i] = freq.clone();\\n        }\\n        \\n        for (int[] q : queries) {\\n            ret.add(canMake(s, q[0], q[1], q[2], freqDp));\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    private boolean canMake(String s, int left, int right, int k, int[][] freqDp) {\\n        if (right - left + 1 == 1) return true;\\n        \\n        if (right - left + 1 <= k) return true;\\n        \\n        int[] freq = new int[26];\\n        \\n        for (int i = 0; i < 26; i++) {\\n            freq[i] = freqDp[right][i];\\n            if (left-1 >= 0)\\n                freq[i] -= freqDp[left-1][i];\\n        }\\n        \\n        int oddCount = 0;\\n        \\n        for (int n : freq) {\\n            if (n % 2 == 1) \\n                oddCount++;\\n        }\\n        \\n        if ((right - left + 1) % 2 == 1) oddCount -= 1;\\n        \\n        return k*2 >= oddCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371911,
                "title": "fail-in-the-last-case-scala",
                "content": "My Alg.\\n1. Calculate cumlative frequency of charaters O(N)\\n2. find the ans, O(N)\\nI check some other post, and add the trick when k >= 26, it always true. But still not pass. \\nCan anyone help to improve? \\n```\\nobject Solution {\\n def canMakePaliQueries(s: String, queries: Array[Array[Int]]): Array[Boolean] = {\\n      val A = s.toArray\\n      val fre = Array.fill(s.length + 1)(Array.fill(26)(0))\\n      for {\\n        i <- 1 to s.length\\n        j <- 0 until 26\\n      }{\\n        if(A(i-1) - \\'a\\' == j) fre(i)(j) = 1+fre(i-1)(j)\\n        else fre(i)(j) = fre(i-1)(j)\\n      }\\n      def g(l:Int, r:Int, k:Int):Boolean = {\\n        (fre(r+1) zip fre(l)).count {case (x, y) => (y - x) % 2 != 0} / 2 <= k\\n      }\\n      queries map {case Array(l, r, k) => if(k >= 26) true else g(l, r, k)}\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n def canMakePaliQueries(s: String, queries: Array[Array[Int]]): Array[Boolean] = {\\n      val A = s.toArray\\n      val fre = Array.fill(s.length + 1)(Array.fill(26)(0))\\n      for {\\n        i <- 1 to s.length\\n        j <- 0 until 26\\n      }{\\n        if(A(i-1) - \\'a\\' == j) fre(i)(j) = 1+fre(i-1)(j)\\n        else fre(i)(j) = fre(i-1)(j)\\n      }\\n      def g(l:Int, r:Int, k:Int):Boolean = {\\n        (fre(r+1) zip fre(l)).count {case (x, y) => (y - x) % 2 != 0} / 2 <= k\\n      }\\n      queries map {case Array(l, r, k) => if(k >= 26) true else g(l, r, k)}\\n    }\\n\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 371896,
                "title": "i-didn-t-really-get-about-one-of-the-test-case-help-me",
                "content": "why this answer is true?\\n\\n```\\n\"hunu\"\\n[[0,3,1]]\\n-> true\\n```\\n\\n- \"hunu\" substring(0, 3) is \"hunu\". right?\\n- It can replace only one character to any, but it can\\'t make palindrome. right??\\n\\n\\nreference:\\n\\n```\\nInput:\\n\"hunu\"\\n[[1,1,1],[2,3,0],[3,3,1],[0,3,2],[1,3,3],[2,3,1],[3,3,1],[0,3,0],[1,1,1],[2,3,0],[3,3,1],[0,3,1],[1,1,1]]\\nOutput:\\n[true,false,true,true,true,true,true,false,true,false,true,false,true]\\nExpected:\\n[true,false,true,true,true,true,true,false,true,false,true,true,true]\\n```",
                "solutionTags": [],
                "code": "```\\n\"hunu\"\\n[[0,3,1]]\\n-> true\\n```\n```\\nInput:\\n\"hunu\"\\n[[1,1,1],[2,3,0],[3,3,1],[0,3,2],[1,3,3],[2,3,1],[3,3,1],[0,3,0],[1,1,1],[2,3,0],[3,3,1],[0,3,1],[1,1,1]]\\nOutput:\\n[true,false,true,true,true,true,true,false,true,false,true,false,true]\\nExpected:\\n[true,false,true,true,true,true,true,false,true,false,true,true,true]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371889,
                "title": "easy-readable-python-solution",
                "content": "Easy Python solution. Because we can rearrange the substring s[left], ..., s[right], we only need to check characters that are not in pairs. For example, \\'aaab\\' -> we only need to check whether \\'ab\\' is a valid Palindrome, because \\'aa\\' is in-pair. Quote from [link](https://leetcode.com/problems/can-make-palindrome-from-substring/discuss/371861/python-straightforward) \"The worst case will be \\'abcdef...z\\', we need to use 13 alphabet to make it a palindrome.\" So, we can simply return True, when k >= 13. \\n\\n```\\nclass Solution(object):\\n    \\n    def isPalin(self, subStr, k):\\n        if k >= 13:\\n            return True\\n        newStr = \\'\\'\\n        strDic = collections.defaultdict(int)\\n        for char in subStr:\\n            strDic[char] += 1\\n        for key in strDic.keys():\\n            if strDic[key] % 2 == 1:\\n                newStr += key\\n        # get mid index\\n        mid = len(newStr) // 2\\n        left, right = mid-1,mid\\n        # odd length\\n        if len(newStr) %2 == 1:\\n            right = mid + 1\\n        while left >=0 and right <len(newStr):\\n            if newStr[left] != newStr[right]:\\n                if k <=0:\\n                    return False\\n                else:\\n                    k -= 1\\n            left -= 1\\n            right += 1   \\n        return True\\n            \\n      \\n    def canMakePaliQueries(self, s, queries):\\n        \"\"\"\\n        :type s: str\\n        :type queries: List[List[int]]\\n        :rtype: List[bool]\\n        \"\"\"\\n        result = []\\n        for query in queries:\\n            subStr = s[query[0]:query[1]+1]\\n            k = query[2]\\n            result.append(self.isPalin(subStr,k))\\n        return result\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    \\n    def isPalin(self, subStr, k):\\n        if k >= 13:\\n            return True\\n        newStr = \\'\\'\\n        strDic = collections.defaultdict(int)\\n        for char in subStr:\\n            strDic[char] += 1\\n        for key in strDic.keys():\\n            if strDic[key] % 2 == 1:\\n                newStr += key\\n        # get mid index\\n        mid = len(newStr) // 2\\n        left, right = mid-1,mid\\n        # odd length\\n        if len(newStr) %2 == 1:\\n            right = mid + 1\\n        while left >=0 and right <len(newStr):\\n            if newStr[left] != newStr[right]:\\n                if k <=0:\\n                    return False\\n                else:\\n                    k -= 1\\n            left -= 1\\n            right += 1   \\n        return True\\n            \\n      \\n    def canMakePaliQueries(self, s, queries):\\n        \"\"\"\\n        :type s: str\\n        :type queries: List[List[int]]\\n        :rtype: List[bool]\\n        \"\"\"\\n        result = []\\n        for query in queries:\\n            subStr = s[query[0]:query[1]+1]\\n            k = query[2]\\n            result.append(self.isPalin(subStr,k))\\n        return result\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 371882,
                "title": "c-with-prefix-cache",
                "content": "```csharp\\npublic class Solution {\\n    public IList<bool> CanMakePaliQueries(string s, int[][] queries) {\\n        int[,] count = new int[s.Length+1,26];\\n        List<bool> result = new List<bool>();\\n        for(int i = 1; i<= s.Length; i++)\\n        {\\n            for(int j = 0; j< 26; j++)\\n            {\\n                if(s[i-1]-\\'a\\'==j)\\n                {\\n                    count[i, j] = count[i-1, j]+1;\\n                }\\n                else\\n                {\\n                    count[i, j] = count[i-1, j];\\n                }\\n            }\\n            \\n        }\\n        foreach(int[] query in queries)\\n        {\\n            int c = 0;\\n            for(int i = 0; i< 26; i++)\\n            {\\n                int difference = (count[query[1]+1, i]-count[query[0], i])%2;\\n                c+=difference;\\n            }\\n            result.Add(c/2<=query[2]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    public IList<bool> CanMakePaliQueries(string s, int[][] queries) {\\n        int[,] count = new int[s.Length+1,26];\\n        List<bool> result = new List<bool>();\\n        for(int i = 1; i<= s.Length; i++)\\n        {\\n            for(int j = 0; j< 26; j++)\\n            {\\n                if(s[i-1]-\\'a\\'==j)\\n                {\\n                    count[i, j] = count[i-1, j]+1;\\n                }\\n                else\\n                {\\n                    count[i, j] = count[i-1, j];\\n                }\\n            }\\n            \\n        }\\n        foreach(int[] query in queries)\\n        {\\n            int c = 0;\\n            for(int i = 0; i< 26; i++)\\n            {\\n                int difference = (count[query[1]+1, i]-count[query[0], i])%2;\\n                c+=difference;\\n            }\\n            result.Add(c/2<=query[2]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371861,
                "title": "python-straightforward",
                "content": "Since we can rearrange the substring, for a same letter, we can always put one left and one right to generate a palindrome. Hence if we have even number of chacters, we can put half left half right to generate a palindrome. We only need care about the odd case where we have one chacter left. \\nThen we have the even and odd number of letter left cases:\\nfor even, such as \\'abcd\\', we can change to \\'abba\\'  which needs 2 replacement\\nfor odd, such ad \\'abcde\\', we need change to \\'abcba\\', which needs 2 replacement.\\nThe worst case will be \\'abcdef...z\\', we need using 13 alphabet to make it a palindrome. And 13 works for all cases since it works for the worst case.\\nThen we have the solution below:\\n```python\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        def is_palidrome(a, k):\\n            if k>13:return True\\n            c = collections.Counter(a)\\n            temp_res = \\'\\'\\n            for key in c:\\n                if c[key]%2==1:\\n                    temp_res += key\\n            return len(temp_res)//2 <= k       \\n        return [is_palidrome(s[l:r+1], k) for l,r,k in queries]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        def is_palidrome(a, k):\\n            if k>13:return True\\n            c = collections.Counter(a)\\n            temp_res = \\'\\'\\n            for key in c:\\n                if c[key]%2==1:\\n                    temp_res += key\\n            return len(temp_res)//2 <= k       \\n        return [is_palidrome(s[l:r+1], k) for l,r,k in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371856,
                "title": "sliding-window-count-parlindrome-o-n-time-complexity-but-used-o-s-length-space",
                "content": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        if (queries == null || queries.length == 0) {\\n            return new ArrayList<>();\\n        }\\n        List<Boolean> res = new ArrayList<>();\\n        Map<Integer,int[]> map = new HashMap<>();\\n        map.put(-1, new int[26]);\\n        char[] chs = s.toCharArray();\\n        int[] chars = new int[26];\\n        for (int j = 0; j < chs.length; j++) {\\n            chars[chs[j] - \\'a\\']++;\\n            map.put(j, Arrays.copyOfRange(chars, 0, 26));\\n        }\\n        for (int[] inte : queries) {\\n            if (inte[0] == inte[1]) {\\n                res.add(true);\\n                continue;\\n            }\\n            int[] before = map.get(inte[0] - 1);\\n            int[] after = map.get(inte[1]);\\n            int count = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if ((after[i] - before[i]) % 2 != 0) {\\n                    count++;\\n                }\\n            }\\n            res.add(count / 2 <= inte[2] ? true : false);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        if (queries == null || queries.length == 0) {\\n            return new ArrayList<>();\\n        }\\n        List<Boolean> res = new ArrayList<>();\\n        Map<Integer,int[]> map = new HashMap<>();\\n        map.put(-1, new int[26]);\\n        char[] chs = s.toCharArray();\\n        int[] chars = new int[26];\\n        for (int j = 0; j < chs.length; j++) {\\n            chars[chs[j] - \\'a\\']++;\\n            map.put(j, Arrays.copyOfRange(chars, 0, 26));\\n        }\\n        for (int[] inte : queries) {\\n            if (inte[0] == inte[1]) {\\n                res.add(true);\\n                continue;\\n            }\\n            int[] before = map.get(inte[0] - 1);\\n            int[] after = map.get(inte[1]);\\n            int count = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if ((after[i] - before[i]) % 2 != 0) {\\n                    count++;\\n                }\\n            }\\n            res.add(count / 2 <= inte[2] ? true : false);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045690,
                "title": "java-prefix-sum-o-n-26",
                "content": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> ans = new ArrayList<>();\\n        int n = s.length();\\n        int[][] dataSet = new int[n][26];\\n        for(int i = 0 ; i < n ; i++){\\n            char ele = s.charAt(i);\\n            if(i > 0){\\n                for(int j = 0 ; j < 25 ; j++){\\n                    dataSet[i][j] = dataSet[i-1][j];\\n                }\\n            }\\n            dataSet[i][ele - \\'a\\']++;\\n        }\\n        \\n        for(int[] q : queries){\\n            int start = q[0];\\n            int end = q[1];\\n            int k = q[2];\\n            int valid = 0;\\n            int inValid = 0;\\n            int len = end - start + 1;\\n            for(int j = 0 ; j < 25 ; j++){\\n                int count = dataSet[end][j];\\n                if(start - 1 >= 0){\\n                    count -= dataSet[start-1][j];\\n                }\\n                if(count > 0 && count % 2 == 0){\\n                    valid++;\\n                }else if(count > 0){\\n                    inValid++;\\n                }\\n            }\\n            if(len % 2 != 0 && inValid > 0) {\\n                inValid--;\\n            }\\n            if(k > 0 && k * 2 >= inValid) \\n                ans.add(true);\\n            else if(k == 0 && inValid == 0)\\n                ans.add(true);\\n            else\\n                ans.add(false);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n***Please UpVote, if you found it useful :)***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        List<Boolean> ans = new ArrayList<>();\\n        int n = s.length();\\n        int[][] dataSet = new int[n][26];\\n        for(int i = 0 ; i < n ; i++){\\n            char ele = s.charAt(i);\\n            if(i > 0){\\n                for(int j = 0 ; j < 25 ; j++){\\n                    dataSet[i][j] = dataSet[i-1][j];\\n                }\\n            }\\n            dataSet[i][ele - \\'a\\']++;\\n        }\\n        \\n        for(int[] q : queries){\\n            int start = q[0];\\n            int end = q[1];\\n            int k = q[2];\\n            int valid = 0;\\n            int inValid = 0;\\n            int len = end - start + 1;\\n            for(int j = 0 ; j < 25 ; j++){\\n                int count = dataSet[end][j];\\n                if(start - 1 >= 0){\\n                    count -= dataSet[start-1][j];\\n                }\\n                if(count > 0 && count % 2 == 0){\\n                    valid++;\\n                }else if(count > 0){\\n                    inValid++;\\n                }\\n            }\\n            if(len % 2 != 0 && inValid > 0) {\\n                inValid--;\\n            }\\n            if(k > 0 && k * 2 >= inValid) \\n                ans.add(true);\\n            else if(k == 0 && inValid == 0)\\n                ans.add(true);\\n            else\\n                ans.add(false);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017953,
                "title": "simple-c-solution-hash-map-and-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore the counts of each variable for each each index.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a vector of size 26 to store the count of each alphabet for each index of string s uisng a hashmap.Then using the concepts of prefix sum you can check the count of all alphabets for any range from 0 to s.size().Then just check the alphabets who have count as odd number.Now if we add or substract one from any odd number it becomes even.Lets understand by example : The number of a\\'s are 3 and number of b\\'s are 5, now if we convert any of these three a\\'s to b then the count of a becomes 2 and that of b becomes 6, and rearrenging them we can make a palindrome.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    N=s.size() M=queries.size()\\n    Total Time Complexity = O ( N + 25 * M )  \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    Total Space Complexity = O(M)\\nSp\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int,vector<int>>mp;\\n        vector<int>count(26,0);\\n        for(int i=0;i<s.size();i++){\\n            count[s[i]-\\'a\\']++;\\n            mp[i]=count;\\n        }\\n        int n=queries.size();\\n        vector<bool>ans(n);\\n        for(int i=0;i<n;i++)   \\n        {\\n            if(queries[i][0]!=0){\\n                int count_odd=0;\\n                for(int j=0;j<=25;j++){\\n                    if((mp[queries[i][1]][j]-mp[queries[i][0]-1][j])%2==1)count_odd++;\\n                }\\n                if(count_odd<=1)ans[i]=true;\\n                else if(count_odd/2<=queries[i][2])ans[i]=true;\\n                else ans[i]=false;\\n            }\\n            else{\\n                int count_odd=0;\\n                for(int j=0;j<=25;j++){\\n                    if(mp[queries[i][1]][j]%2==1)count_odd++;\\n                }\\n                if(count_odd<=1)ans[i]=true;\\n                else if(count_odd/2<=queries[i][2])ans[i]=true;\\n                else ans[i]=false;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        unordered_map<int,vector<int>>mp;\\n        vector<int>count(26,0);\\n        for(int i=0;i<s.size();i++){\\n            count[s[i]-\\'a\\']++;\\n            mp[i]=count;\\n        }\\n        int n=queries.size();\\n        vector<bool>ans(n);\\n        for(int i=0;i<n;i++)   \\n        {\\n            if(queries[i][0]!=0){\\n                int count_odd=0;\\n                for(int j=0;j<=25;j++){\\n                    if((mp[queries[i][1]][j]-mp[queries[i][0]-1][j])%2==1)count_odd++;\\n                }\\n                if(count_odd<=1)ans[i]=true;\\n                else if(count_odd/2<=queries[i][2])ans[i]=true;\\n                else ans[i]=false;\\n            }\\n            else{\\n                int count_odd=0;\\n                for(int j=0;j<=25;j++){\\n                    if(mp[queries[i][1]][j]%2==1)count_odd++;\\n                }\\n                if(count_odd<=1)ans[i]=true;\\n                else if(count_odd/2<=queries[i][2])ans[i]=true;\\n                else ans[i]=false;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862941,
                "title": "easy-commented-xor-prefix-approach-simplified-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool>ans;\\n        int n=s.size();\\n        vector<int>pre(n,0);\\n        pre[0]=1<<(s[0]-\\'a\\');\\n        for(int i=1;i<n;i++){\\n            //left shift each char position and take xor        \\n            pre[i]=pre[i-1]^(1<<(s[i]-\\'a\\'));\\n        } \\n        for(int i=0;i<queries.size();i++){\\n            int k=queries[i][2];\\n            int l=queries[i][0];\\n            int r=queries[i][1];\\n            int x;\\n            if(l==0){\\n                x=pre[r];\\n            }else if(l>0){\\n                //xor till l-1 (xor) xor till r gives the xor bw l r\\n                x=pre[l-1]^pre[r];\\n            }\\n            int st=__builtin_popcount(x);\\n            //counted the set bits in xored product to determine\\n            //non repeating chars\\n            st/=2;     \\n            // divide the non repeating chars frequency by 2 as any 2 different\\n            // chars can be replaced by a single char to make them equal...also \\n            // /2 ensures removal of odd frequency elements like dbc st=3 (set\\n            // bits) as d b c are 3 single non repeating ..when /2 it becomes 1 \\n            // making d and c equal and palindrome can be dbd/ cbc (b remaining unaffected)\\n            if(st<=k){\\n                ans.push_back(1);\\n            }else{\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPS: PLEASE DO UPVOTE IF YOU LIKED!!\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool>ans;\\n        int n=s.size();\\n        vector<int>pre(n,0);\\n        pre[0]=1<<(s[0]-\\'a\\');\\n        for(int i=1;i<n;i++){\\n            //left shift each char position and take xor        \\n            pre[i]=pre[i-1]^(1<<(s[i]-\\'a\\'));\\n        } \\n        for(int i=0;i<queries.size();i++){\\n            int k=queries[i][2];\\n            int l=queries[i][0];\\n            int r=queries[i][1];\\n            int x;\\n            if(l==0){\\n                x=pre[r];\\n            }else if(l>0){\\n                //xor till l-1 (xor) xor till r gives the xor bw l r\\n                x=pre[l-1]^pre[r];\\n            }\\n            int st=__builtin_popcount(x);\\n            //counted the set bits in xored product to determine\\n            //non repeating chars\\n            st/=2;     \\n            // divide the non repeating chars frequency by 2 as any 2 different\\n            // chars can be replaced by a single char to make them equal...also \\n            // /2 ensures removal of odd frequency elements like dbc st=3 (set\\n            // bits) as d b c are 3 single non repeating ..when /2 it becomes 1 \\n            // making d and c equal and palindrome can be dbd/ cbc (b remaining unaffected)\\n            if(st<=k){\\n                ans.push_back(1);\\n            }else{\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857316,
                "title": "java-solution-explaination-in-comments",
                "content": "# Code\\n```\\nclass Solution \\n{ public List<Boolean> canMakePaliQueries(String s, int[][] queries) \\n    {\\n        List<Boolean> list = new ArrayList<>();\\n        \\n        int n = s.length();\\n        // prefix map to count number of time each letters have occured to access in queries in O(1)\\n       //s=  a b c d a\\n        // a 1 1 1 1 2\\n        // b 0 1 1 1 1\\n        // c 0 0 1 1 1\\n        // d 0 0 0 1 1\\n        // e\\n        // f\\n        // .\\n        // .\\n        // .\\n        int[][] map = new int[n+1][26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            for(int j=0;j<26;j++)\\n                map[i+1][j] = map[i][j];\\n            \\n            map[i+1][s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int[] q : queries)\\n        {\\n            int l = q[0];\\n            int r = q[1];\\n            int k = q[2];\\n            int count = 0;\\n            \\n            for(int i=0;i<26;i++)\\n                count += (map[r+1][i] - map[l][i]) % 2;// count total characters that have odd count, so that we can replace the half of them with their pair.\\n            \\n            list.add(count/2 <= k);// if we can replace half of them with their pair\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{ public List<Boolean> canMakePaliQueries(String s, int[][] queries) \\n    {\\n        List<Boolean> list = new ArrayList<>();\\n        \\n        int n = s.length();\\n        // prefix map to count number of time each letters have occured to access in queries in O(1)\\n       //s=  a b c d a\\n        // a 1 1 1 1 2\\n        // b 0 1 1 1 1\\n        // c 0 0 1 1 1\\n        // d 0 0 0 1 1\\n        // e\\n        // f\\n        // .\\n        // .\\n        // .\\n        int[][] map = new int[n+1][26];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            for(int j=0;j<26;j++)\\n                map[i+1][j] = map[i][j];\\n            \\n            map[i+1][s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int[] q : queries)\\n        {\\n            int l = q[0];\\n            int r = q[1];\\n            int k = q[2];\\n            int count = 0;\\n            \\n            for(int i=0;i<26;i++)\\n                count += (map[r+1][i] - map[l][i]) % 2;// count total characters that have odd count, so that we can replace the half of them with their pair.\\n            \\n            list.add(count/2 <= k);// if we can replace half of them with their pair\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853426,
                "title": "python3-bitmask-10-lines-beats-99-17-in-speed",
                "content": "# Code\\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        masks = [0]\\n        for i, c in enumerate(s):\\n            masks.append((1 << (ord(s[i]) - ord(\\'a\\'))) ^ masks[-1])\\n        \\n        ans = []\\n        for (l, r, k) in queries:\\n            ans.append(bin(masks[r + 1] ^ masks[l])[2:].count(\\'1\\') <= 2 * k + 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        masks = [0]\\n        for i, c in enumerate(s):\\n            masks.append((1 << (ord(s[i]) - ord(\\'a\\'))) ^ masks[-1])\\n        \\n        ans = []\\n        for (l, r, k) in queries:\\n            ans.append(bin(masks[r + 1] ^ masks[l])[2:].count(\\'1\\') <= 2 * k + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846356,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        vector<vector<int>>pre(n);\\n        vector<int>temp(26,0);\\n        temp[s[0]-\\'a\\']++;\\n        pre[0]=temp;\\n        for (int i=1;i<n;i++)\\n        {\\n            pre[i]=pre[i-1];\\n            pre[i][s[i]-\\'a\\']++;\\n        }\\n        vector<bool>ans;\\n        for (auto it: queries)\\n        {\\n            int left=it[0];\\n            int right=it[1];\\n            int k=it[2];\\n            vector<int>temp=pre[right];\\n            int odd=0;\\n                for (int i=0;i<26;i++)\\n                {\\n                     if (left!=0)\\n                    {temp[i]-=pre[left-1][i];}\\n                    if (temp[i]%2==1) odd++;\\n                }\\n                if ((right-left+1)%2==0)\\n                {\\n                   if (k>=(odd)/2) ans.push_back(true);\\n                   else ans.push_back(false);\\n                }\\n                else{\\n                    if (k>=(odd-1)/2)\\n                    ans.push_back(true);\\n                    else ans.push_back(false);\\n                }\\n                \\n            \\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        vector<vector<int>>pre(n);\\n        vector<int>temp(26,0);\\n        temp[s[0]-\\'a\\']++;\\n        pre[0]=temp;\\n        for (int i=1;i<n;i++)\\n        {\\n            pre[i]=pre[i-1];\\n            pre[i][s[i]-\\'a\\']++;\\n        }\\n        vector<bool>ans;\\n        for (auto it: queries)\\n        {\\n            int left=it[0];\\n            int right=it[1];\\n            int k=it[2];\\n            vector<int>temp=pre[right];\\n            int odd=0;\\n                for (int i=0;i<26;i++)\\n                {\\n                     if (left!=0)\\n                    {temp[i]-=pre[left-1][i];}\\n                    if (temp[i]%2==1) odd++;\\n                }\\n                if ((right-left+1)%2==0)\\n                {\\n                   if (k>=(odd)/2) ans.push_back(true);\\n                   else ans.push_back(false);\\n                }\\n                else{\\n                    if (k>=(odd-1)/2)\\n                    ans.push_back(true);\\n                    else ans.push_back(false);\\n                }\\n                \\n            \\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828831,
                "title": "cummulative-frequency-bit-manipulation",
                "content": "**explained in comments**\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        int qz=queries.size();\\n        vector<int> freq(n,0); \\n        //stores whether freq of all the characters till i are either odd or even\\n\\n        int temp=0;\\n        for(int i=0;i<n;i++){\\n            temp=temp^(1<<(s[i]-\\'a\\'));  //makes 0 to 1 and 1 to 0\\n            freq[i]=temp;\\n        }\\n        vector<bool>ans(qz,0);\\n        for(int i=0;i<qz;i++){\\n            int from = queries[i][0],to=queries[i][1],k=queries[i][2];\\n            int temp=freq[to];\\n            if(from>0) temp=temp^freq[from-1];\\n            int count=0;    //odd counts\\n            while(temp!=0){\\n                count+=(temp&1);\\n                temp/=2;\\n            }\\n            //we can make max k character to get into palindrome\\n            ans[i]=(count/2)<=k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n=s.size();\\n        int qz=queries.size();\\n        vector<int> freq(n,0); \\n        //stores whether freq of all the characters till i are either odd or even\\n\\n        int temp=0;\\n        for(int i=0;i<n;i++){\\n            temp=temp^(1<<(s[i]-\\'a\\'));  //makes 0 to 1 and 1 to 0\\n            freq[i]=temp;\\n        }\\n        vector<bool>ans(qz,0);\\n        for(int i=0;i<qz;i++){\\n            int from = queries[i][0],to=queries[i][1],k=queries[i][2];\\n            int temp=freq[to];\\n            if(from>0) temp=temp^freq[from-1];\\n            int count=0;    //odd counts\\n            while(temp!=0){\\n                count+=(temp&1);\\n                temp/=2;\\n            }\\n            //we can make max k character to get into palindrome\\n            ans[i]=(count/2)<=k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677212,
                "title": "modified-from-another-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n# modified from solution 100% Python with Bit mask\\n\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: list[list[int]]) -> list[bool]:\\n        mask = 0\\n        chardict = {chr(i): 1<<(i-ord(\"a\")) for i in range(ord(\"a\"), ord(\"z\")+1)}\\n        result = []\\n        after_pass = [0] \\n\\n        for i, char in enumerate(s):\\n            mask ^= chardict[char]\\n            after_pass += [mask]\\n\\n        for i, (l,r,k) in enumerate(queries):\\n            if (r-l +1)//2 <=k:\\n                result += [True]\\n            else:        \\n                num_odd = (after_pass[l] ^ after_pass[r+1]).bit_count()\\n                result += [num_odd//2 <= k]\\n        return result\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n# modified from solution 100% Python with Bit mask\\n\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: list[list[int]]) -> list[bool]:\\n        mask = 0\\n        chardict = {chr(i): 1<<(i-ord(\"a\")) for i in range(ord(\"a\"), ord(\"z\")+1)}\\n        result = []\\n        after_pass = [0] \\n\\n        for i, char in enumerate(s):\\n            mask ^= chardict[char]\\n            after_pass += [mask]\\n\\n        for i, (l,r,k) in enumerate(queries):\\n            if (r-l +1)//2 <=k:\\n                result += [True]\\n            else:        \\n                num_odd = (after_pass[l] ^ after_pass[r+1]).bit_count()\\n                result += [num_odd//2 <= k]\\n        return result\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639362,
                "title": "a-simple-way-in-java-by-prefix",
                "content": "a simple way\\n```\\nclass Solution {\\n\\n    static final int PRE_ARRAY_LENGTH = 26;\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n        List<Boolean> result = new ArrayList<>();\\n        //If it is an even number then it must form a palindrome\\n        //If there is an odd number then a classification is required:\\n        //If there is an odd number, then no exchange is required\\n        //2 for 1 exchange\\n        //3 for 1\\n        //4 for 2\\n        //5 for 2\\n\\n        int[][] preCharArray = new int [s.length()+1][PRE_ARRAY_LENGTH];\\n        // Constructing prefix arrays\\n        buildPreCharacterArray(preCharArray,s);\\n        // traversing queries\\n        for (int[] query : queries) {\\n            int left = query[0];\\n            int right = query[1];\\n            int k = query[2];\\n            //If k is greater than or equal to the number of odd numbers, then the palindrome must be formed\\n            //first even characters - even characters must be even characters do not affect\\n            if (judgeIsPalindrome(preCharArray[right+1],preCharArray[left],k)){\\n                result.add(true);\\n            }else {\\n                result.add(false);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private void buildPreCharacterArray(int [][] preCharArray,String s){\\n        for(int i=1;i<=s.length();i++){\\n            for(int j=0;j<PRE_ARRAY_LENGTH;j++){\\n                preCharArray[i][j] = preCharArray[i-1][j];\\n            }\\n            preCharArray[i][s.charAt(i-1)-\\'a\\']++;\\n        }\\n    }\\n\\n    private boolean judgeIsPalindrome(int [] preCharArrayRight,int [] preCharArrayLeft,int k){\\n        int oddCnt = 0;\\n        for(int i=0;i<preCharArrayRight.length;i++){\\n            // if odd\\n            if((preCharArrayRight[i]-preCharArrayLeft[i])%2==1){\\n                oddCnt++;\\n            }\\n        }\\n    \\n        return oddCnt/2<=k;\\n    }\\n}\\n```\\noptimize\\n```\\n/**\\n * Since you only need to know the parity state and not the exact number of states, you can record it in binary\\n */\\nclass Solution {\\n\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n        List<Boolean> result = new ArrayList<>();\\n        //If it is an even number then it must form a palindrome\\n        //If odd then classification is required:\\n        //if there is more than 1 odd number then n-1 swaps are required, otherwise none are needed\\n        //more than one digit is needed to record how many odd numbers are currently present\\n        int[] preCharArray = new int [s.length()+1];\\n        // Constructing prefix arrays\\n        buildPreCharacterArray(preCharArray,s);\\n        //traverse queries\\n        for (int[] query : queries) {\\n            int left = query[0];\\n            int right = query[1];\\n            int k = query[2];\\n            //If k is greater than or equal to the number of odd numbers, then the palindrome must be formed\\n            //first even characters - even characters must be even characters do not affect\\n            if (judgeIsPalindrome(preCharArray[right+1],preCharArray[left],k)){\\n                result.add(true);\\n            }else {\\n                result.add(false);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private void buildPreCharacterArray(int [] preCharArray,String s){\\n        for(int i=1;i<=s.length();i++){\\n            preCharArray[i] = preCharArray[i-1]^(1<<(s.charAt(i-1)-\\'a\\'));\\n        }\\n    }\\n\\n    private boolean judgeIsPalindrome(int preCharArrayRight,int preCharArrayLeft,int k){\\n        int oddCnt = 0;\\n        int diff = preCharArrayRight^preCharArrayLeft;\\n        for(;diff>0;){\\n            // if odd\\n            diff = diff&(diff-1);\\n            oddCnt++;\\n        }\\n        return oddCnt/2<=k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    static final int PRE_ARRAY_LENGTH = 26;\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n        List<Boolean> result = new ArrayList<>();\\n        //If it is an even number then it must form a palindrome\\n        //If there is an odd number then a classification is required:\\n        //If there is an odd number, then no exchange is required\\n        //2 for 1 exchange\\n        //3 for 1\\n        //4 for 2\\n        //5 for 2\\n\\n        int[][] preCharArray = new int [s.length()+1][PRE_ARRAY_LENGTH];\\n        // Constructing prefix arrays\\n        buildPreCharacterArray(preCharArray,s);\\n        // traversing queries\\n        for (int[] query : queries) {\\n            int left = query[0];\\n            int right = query[1];\\n            int k = query[2];\\n            //If k is greater than or equal to the number of odd numbers, then the palindrome must be formed\\n            //first even characters - even characters must be even characters do not affect\\n            if (judgeIsPalindrome(preCharArray[right+1],preCharArray[left],k)){\\n                result.add(true);\\n            }else {\\n                result.add(false);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private void buildPreCharacterArray(int [][] preCharArray,String s){\\n        for(int i=1;i<=s.length();i++){\\n            for(int j=0;j<PRE_ARRAY_LENGTH;j++){\\n                preCharArray[i][j] = preCharArray[i-1][j];\\n            }\\n            preCharArray[i][s.charAt(i-1)-\\'a\\']++;\\n        }\\n    }\\n\\n    private boolean judgeIsPalindrome(int [] preCharArrayRight,int [] preCharArrayLeft,int k){\\n        int oddCnt = 0;\\n        for(int i=0;i<preCharArrayRight.length;i++){\\n            // if odd\\n            if((preCharArrayRight[i]-preCharArrayLeft[i])%2==1){\\n                oddCnt++;\\n            }\\n        }\\n    \\n        return oddCnt/2<=k;\\n    }\\n}\\n```\n```\\n/**\\n * Since you only need to know the parity state and not the exact number of states, you can record it in binary\\n */\\nclass Solution {\\n\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n        List<Boolean> result = new ArrayList<>();\\n        //If it is an even number then it must form a palindrome\\n        //If odd then classification is required:\\n        //if there is more than 1 odd number then n-1 swaps are required, otherwise none are needed\\n        //more than one digit is needed to record how many odd numbers are currently present\\n        int[] preCharArray = new int [s.length()+1];\\n        // Constructing prefix arrays\\n        buildPreCharacterArray(preCharArray,s);\\n        //traverse queries\\n        for (int[] query : queries) {\\n            int left = query[0];\\n            int right = query[1];\\n            int k = query[2];\\n            //If k is greater than or equal to the number of odd numbers, then the palindrome must be formed\\n            //first even characters - even characters must be even characters do not affect\\n            if (judgeIsPalindrome(preCharArray[right+1],preCharArray[left],k)){\\n                result.add(true);\\n            }else {\\n                result.add(false);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private void buildPreCharacterArray(int [] preCharArray,String s){\\n        for(int i=1;i<=s.length();i++){\\n            preCharArray[i] = preCharArray[i-1]^(1<<(s.charAt(i-1)-\\'a\\'));\\n        }\\n    }\\n\\n    private boolean judgeIsPalindrome(int preCharArrayRight,int preCharArrayLeft,int k){\\n        int oddCnt = 0;\\n        int diff = preCharArrayRight^preCharArrayLeft;\\n        for(;diff>0;){\\n            // if odd\\n            diff = diff&(diff-1);\\n            oddCnt++;\\n        }\\n        return oddCnt/2<=k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629157,
                "title": "c-easy-solution-t-c-o-26-q-s-c-o-q",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& arr) {\\n\\n        int n = s.size();\\n        vector<bool> ans;\\n        vector<vector<int>> cnt(n,vector<int>(26));\\n\\n        vector<int> temp(26,0);\\n        temp[s[0]-\\'a\\']++;\\n        cnt[0]=temp;\\n\\n        for(int i = 1; i < n ; i++){\\n            cnt[i]=cnt[i-1];\\n            cnt[i][s[i]-\\'a\\']++;\\n        }\\n\\n        for(int i=0 ; i<arr.size() ;i++){\\n            int l = arr[i][0],r=arr[i][1],k=arr[i][2];\\n            int unpaired = 0;\\n\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(l==0){\\n                    if(cnt[r][j]&1)unpaired++;\\n                }else{\\n                    if((cnt[r][j]-cnt[l-1][j])&1)unpaired++;\\n                }\\n            }\\n\\n            if(unpaired/2<=k)ans.push_back(true);\\n            else ans.push_back(false);\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& arr) {\\n\\n        int n = s.size();\\n        vector<bool> ans;\\n        vector<vector<int>> cnt(n,vector<int>(26));\\n\\n        vector<int> temp(26,0);\\n        temp[s[0]-\\'a\\']++;\\n        cnt[0]=temp;\\n\\n        for(int i = 1; i < n ; i++){\\n            cnt[i]=cnt[i-1];\\n            cnt[i][s[i]-\\'a\\']++;\\n        }\\n\\n        for(int i=0 ; i<arr.size() ;i++){\\n            int l = arr[i][0],r=arr[i][1],k=arr[i][2];\\n            int unpaired = 0;\\n\\n            for(int j = 0 ; j < 26 ; j++){\\n                if(l==0){\\n                    if(cnt[r][j]&1)unpaired++;\\n                }else{\\n                    if((cnt[r][j]-cnt[l-1][j])&1)unpaired++;\\n                }\\n            }\\n\\n            if(unpaired/2<=k)ans.push_back(true);\\n            else ans.push_back(false);\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544858,
                "title": "c-python-prefix-sum-solution-with-explanation",
                "content": "Given ```k```, ```str```, how to check ```str``` is a palindrome after ```k``` operations.\\nIf the size of ```str``` is odd, there must have a number of  a letter is odd, and others are even.\\nIf the size of ```str``` is even, number of each letter are even.\\nIf the size of ```str``` is odd, ```k >=number of odd // 2``` can make ```str``` be a palindrome after ```k``` operations.\\nIf the size of ```str``` is even, ```k >=number of odd // 2``` can make ```str``` be a palindrome after ```k``` operations.\\nWe just focus on which letter whose number is odd or even, we can use a bit mask to do it, a bit is 1 mean a letter whose number is odd or is even.\\n\\nWe can use prefix sum to check which letters whose number is odd, just use ```prefix[r+1] ^ prefix[l]```, ```prefix[i]``` is a bit mask for ```s[0~i-1]``` \\nand use ```bit_count``` to check number of letters whose number is odd.\\n\\ntc is O(s.size() + queries.size()), sc is O(s.size() + queries.size())\\n### c++\\n``` cpp\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<int> prefix (s.size() + 1, 0);\\n\\t\\t// prefix sum to check which letters whose number is odd\\n        for(int i = 0; i < s.size(); i+=1) \\n            prefix[i+1] = prefix[i] ^ (1 << (s[i] - \\'a\\'));\\n        auto bit_count = [] (int x) {\\n            int cnt = 0;\\n            while (x){\\n                cnt += x & 1;\\n                x >>= 1;\\n            }\\n            return cnt;\\n        };\\n        vector<bool> ans (queries.size());\\n        for (int i = 0, odd; i < queries.size(); i+=1) {\\n            int& l = queries[i][0], &r = queries[i][1], &k = queries[i][2];\\n            odd = bit_count(prefix[r+1] ^ prefix[l]); // number of letters whose number is odd\\n            if (k >= odd/2) ans[i] = true;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n### python\\n```python\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        prefix = [0]\\n        for le in s: # prefix sum to check which letters whose number is odd\\n            prefix.append(prefix[-1] ^ 1 << (ord(le) - ord(\\'a\\')))\\n        ans = []\\n        for l, r, k in queries:\\n            odd = (prefix[r+1] ^ prefix[l]).bit_count() # number of letters whose number is odd\\n            if k >= odd//2: ans.append(True)\\n            else: ans.append(False)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```k```\n```str```\n```str```\n```k```\n```str```\n```str```\n```str```\n```k >=number of odd // 2```\n```str```\n```k```\n```str```\n```k >=number of odd // 2```\n```str```\n```k```\n```prefix[r+1] ^ prefix[l]```\n```prefix[i]```\n```s[0~i-1]```\n```bit_count```\n``` cpp\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<int> prefix (s.size() + 1, 0);\\n\\t\\t// prefix sum to check which letters whose number is odd\\n        for(int i = 0; i < s.size(); i+=1) \\n            prefix[i+1] = prefix[i] ^ (1 << (s[i] - \\'a\\'));\\n        auto bit_count = [] (int x) {\\n            int cnt = 0;\\n            while (x){\\n                cnt += x & 1;\\n                x >>= 1;\\n            }\\n            return cnt;\\n        };\\n        vector<bool> ans (queries.size());\\n        for (int i = 0, odd; i < queries.size(); i+=1) {\\n            int& l = queries[i][0], &r = queries[i][1], &k = queries[i][2];\\n            odd = bit_count(prefix[r+1] ^ prefix[l]); // number of letters whose number is odd\\n            if (k >= odd/2) ans[i] = true;\\n        }\\n        return ans; \\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        prefix = [0]\\n        for le in s: # prefix sum to check which letters whose number is odd\\n            prefix.append(prefix[-1] ^ 1 << (ord(le) - ord(\\'a\\')))\\n        ans = []\\n        for l, r, k in queries:\\n            odd = (prefix[r+1] ^ prefix[l]).bit_count() # number of letters whose number is odd\\n            if k >= odd//2: ans.append(True)\\n            else: ans.append(False)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537216,
                "title": "100-python-with-bit-mask",
                "content": "Check [my first submission](https://leetcode.com/problems/can-make-palindrome-from-substring/submissions/952532375/)\\n\\n\\n# Intuition\\n- focus on the not-paired characters\\n\\n# Approach\\n- bit mask\\n\\n# Complexity\\n- Time complexity: O(len(s)+len(queries))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(len(s)+len(queries))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# At first I thought this should be \"hard\" but since we can rearrange\\n# the substring, we can focus on the not-paired characters.\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: list[list[int]]) -> list[bool]:\\n        mask = 0  # prefix-parity of each character,0 -> even, 1 -> odd\\n        parity_after = [0] * (len(s) + 1)\\n        d = {chr(i): 1 << (i - ord(\"a\")) for i in range(ord(\"a\"), ord(\"z\") + 1)}\\n        for i, c in enumerate(s, start=1):\\n            mask ^= d[c]\\n            parity_after[i] = mask\\n\\n        ans = [True] * len(queries)\\n        for i, (l, r, k) in enumerate(queries):  # l, r inclusive\\n            if k >= (r - l + 1) // 2:\\n                continue\\n            odd = parity_after[r + 1] ^ parity_after[l]  # mask of odd-parity\\n            ans[i] = (odd.bit_count()) // 2 <= k  # count,ans: 3,1; 4,2; 5,2\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# At first I thought this should be \"hard\" but since we can rearrange\\n# the substring, we can focus on the not-paired characters.\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: list[list[int]]) -> list[bool]:\\n        mask = 0  # prefix-parity of each character,0 -> even, 1 -> odd\\n        parity_after = [0] * (len(s) + 1)\\n        d = {chr(i): 1 << (i - ord(\"a\")) for i in range(ord(\"a\"), ord(\"z\") + 1)}\\n        for i, c in enumerate(s, start=1):\\n            mask ^= d[c]\\n            parity_after[i] = mask\\n\\n        ans = [True] * len(queries)\\n        for i, (l, r, k) in enumerate(queries):  # l, r inclusive\\n            if k >= (r - l + 1) // 2:\\n                continue\\n            odd = parity_after[r + 1] ^ parity_after[l]  # mask of odd-parity\\n            ans[i] = (odd.bit_count()) // 2 <= k  # count,ans: 3,1; 4,2; 5,2\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523885,
                "title": "easy-and-beginner-friendly-cpp-solution-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStoring the count of each alphabet at each index then finding the count of each alphabet using prefix sum approach\\n# Complexity\\n- Time complexity:O(s.length() + q.size())\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(s.length())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        vector<bool> ans;\\n        int n = s.length();\\n        vector<vector<int>> v(n,vector<int>(26,0));\\n        v[0][s[0]-\\'a\\']++;\\n        for(int i=1; i<n; i++){\\n            v[i] = v[i-1];\\n            v[i][s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<q.size(); i++){\\n            int left = q[i][0];\\n            int right = q[i][1];\\n            int k = q[i][2];\\n            int len = right-left+1;\\n            int cnt = len%2==0 ? 0 : -1;\\n            for(int j=0; j<26; j++){\\n                int top = v[right][j];\\n                int bottom = left==0 ? 0 : v[left-1][j];\\n                int diff = top-bottom;\\n                if(diff%2==1)cnt++;\\n            }\\n            ans.push_back(cnt/2<=k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        vector<bool> ans;\\n        int n = s.length();\\n        vector<vector<int>> v(n,vector<int>(26,0));\\n        v[0][s[0]-\\'a\\']++;\\n        for(int i=1; i<n; i++){\\n            v[i] = v[i-1];\\n            v[i][s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<q.size(); i++){\\n            int left = q[i][0];\\n            int right = q[i][1];\\n            int k = q[i][2];\\n            int len = right-left+1;\\n            int cnt = len%2==0 ? 0 : -1;\\n            for(int j=0; j<26; j++){\\n                int top = v[right][j];\\n                int bottom = left==0 ? 0 : v[left-1][j];\\n                int diff = top-bottom;\\n                if(diff%2==1)cnt++;\\n            }\\n            ans.push_back(cnt/2<=k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448332,
                "title": "java-easy-to-understand-with-comments-solution",
                "content": "```\\nclass Solution {\\n    int dp[][];\\n    \\n    void preparePallindrome(String s){\\n        dp = new int[s.length()+1][26];\\n\\n        // prepare quick lookup matrix similar to prefix sum, this will give us how many char are there between (i,j)\\n        for(int i=0; i<s.length(); i++){\\n            \\n            dp[i+1][s.charAt(i)- \\'a\\']++;\\n                \\n            for(int j=0; j<26;j++){\\n                dp[i+1][j]+=dp[i][j];\\n            }    \\n        }\\n        \\n    }\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        \\n        preparePallindrome(s);    \\n        List<Boolean> ans = new ArrayList<>();\\n        for(int i=0; i<queries.length; i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            int changes = queries[i][2];\\n            \\n            // if no of operations is greater than number of character in substring then we can convert all character in single character\\n            if(right - left+1 <=changes) ans.add(true);\\n            else {\\n                int odd=0;\\n                \\n                for(int j=0; j<26; j++){\\n                    // right+1 as we\\'ve to include right\\n                    int c = dp[right+1][j] - dp[left][j];\\n                    if(c%2!=0) odd++;\\n                }\\n                //convert two odd into same and make a pair, so we can make max 2*operations odd to pallindrome\\n                odd = odd - 2*changes;\\n                if(odd>1) ans.add(false);\\n                else ans.add(true);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    \\n    void preparePallindrome(String s){\\n        dp = new int[s.length()+1][26];\\n\\n        // prepare quick lookup matrix similar to prefix sum, this will give us how many char are there between (i,j)\\n        for(int i=0; i<s.length(); i++){\\n            \\n            dp[i+1][s.charAt(i)- \\'a\\']++;\\n                \\n            for(int j=0; j<26;j++){\\n                dp[i+1][j]+=dp[i][j];\\n            }    \\n        }\\n        \\n    }\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        \\n        preparePallindrome(s);    \\n        List<Boolean> ans = new ArrayList<>();\\n        for(int i=0; i<queries.length; i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            int changes = queries[i][2];\\n            \\n            // if no of operations is greater than number of character in substring then we can convert all character in single character\\n            if(right - left+1 <=changes) ans.add(true);\\n            else {\\n                int odd=0;\\n                \\n                for(int j=0; j<26; j++){\\n                    // right+1 as we\\'ve to include right\\n                    int c = dp[right+1][j] - dp[left][j];\\n                    if(c%2!=0) odd++;\\n                }\\n                //convert two odd into same and make a pair, so we can make max 2*operations odd to pallindrome\\n                odd = odd - 2*changes;\\n                if(odd>1) ans.add(false);\\n                else ans.add(true);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396547,
                "title": "easy-to-understand-javascript-solution-prefix-sum",
                "content": "```\\nvar canMakePaliQueries = function(s, queries) {\\n    const DEFAULT_CHAR_CODE = \\'a\\'.charCodeAt(0);\\n    const size = s.length;\\n    const prefixSum = Array(size + 1);\\n\\n    prefixSum[0] = Array(26).fill(0);\\n\\n    for (let index = 1; index <= size; index++) {\\n        const str = s[index - 1];\\n        const charCode = str.charCodeAt(0) - DEFAULT_CHAR_CODE;\\n\\n        prefixSum[index] = [...prefixSum[index - 1]];\\n        prefixSum[index][charCode] += 1;\\n    }\\n\\n    return queries.map(([left, right, k]) => {\\n        let sum = 0;\\n\\n        for (let code = 0; code < 26; code++) {\\n            sum += (prefixSum[right + 1][code] - prefixSum[left][code]) % 2;\\n        }\\n        return (sum / 2 | 0) <= k;\\n    });\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canMakePaliQueries = function(s, queries) {\\n    const DEFAULT_CHAR_CODE = \\'a\\'.charCodeAt(0);\\n    const size = s.length;\\n    const prefixSum = Array(size + 1);\\n\\n    prefixSum[0] = Array(26).fill(0);\\n\\n    for (let index = 1; index <= size; index++) {\\n        const str = s[index - 1];\\n        const charCode = str.charCodeAt(0) - DEFAULT_CHAR_CODE;\\n\\n        prefixSum[index] = [...prefixSum[index - 1]];\\n        prefixSum[index][charCode] += 1;\\n    }\\n\\n    return queries.map(([left, right, k]) => {\\n        let sum = 0;\\n\\n        for (let code = 0; code < 26; code++) {\\n            sum += (prefixSum[right + 1][code] - prefixSum[left][code]) % 2;\\n        }\\n        return (sum / 2 | 0) <= k;\\n    });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3377421,
                "title": "simple-c-solution-using-maths",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> getDifference(vector<int>&a , vector<int> &b){\\n        int odd = 0 , even = 0;\\n\\n        for(int i=0 ; i<26 ; i++){\\n            int d = b[i]-a[i];\\n            if(d%2==0 and d!=0) even++;\\n            else if(d%2==1)odd++;\\n        }\\n\\n        return {odd , even};\\n    }\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        int m = queries.size();\\n        vector<bool> ans(m , false);\\n\\n        vector<vector<int>> freq(n, vector<int>(26 , 0));\\n\\n        vector<int> mp(26 , 0);\\n\\n        for(int i=0 ; i<n ; i++){\\n            mp[s[i]-\\'a\\']++;\\n            freq[i] = mp;\\n        }\\n\\n        for(int i=0 ; i<m ; i++){\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            int k = queries[i][2];\\n\\n            pair<int,int> p;\\n\\n            if(l==0){\\n                vector<int> temp(26 , 0);\\n                p = getDifference(temp , freq[r]);\\n            }\\n            else{\\n                p = getDifference(freq[l-1] , freq[r]);\\n            }\\n\\n            int d = r-l+1;\\n\\n            if(d%2==0){\\n                if(p.first<=2*k) ans[i] = true;\\n            }\\n            else{\\n                if(p.first==1){\\n                    ans[i] = true;\\n                }\\n\\n                int x = p.first-1;\\n\\n                if(x%2==0 and x<=2*k){\\n                    ans[i] = true;\\n                }\\n                else{\\n                    k--;\\n                    if(x<=2*k){\\n                        ans[i] = true;\\n                    }\\n                }\\n\\n                \\n            }\\n\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> getDifference(vector<int>&a , vector<int> &b){\\n        int odd = 0 , even = 0;\\n\\n        for(int i=0 ; i<26 ; i++){\\n            int d = b[i]-a[i];\\n            if(d%2==0 and d!=0) even++;\\n            else if(d%2==1)odd++;\\n        }\\n\\n        return {odd , even};\\n    }\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        int m = queries.size();\\n        vector<bool> ans(m , false);\\n\\n        vector<vector<int>> freq(n, vector<int>(26 , 0));\\n\\n        vector<int> mp(26 , 0);\\n\\n        for(int i=0 ; i<n ; i++){\\n            mp[s[i]-\\'a\\']++;\\n            freq[i] = mp;\\n        }\\n\\n        for(int i=0 ; i<m ; i++){\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            int k = queries[i][2];\\n\\n            pair<int,int> p;\\n\\n            if(l==0){\\n                vector<int> temp(26 , 0);\\n                p = getDifference(temp , freq[r]);\\n            }\\n            else{\\n                p = getDifference(freq[l-1] , freq[r]);\\n            }\\n\\n            int d = r-l+1;\\n\\n            if(d%2==0){\\n                if(p.first<=2*k) ans[i] = true;\\n            }\\n            else{\\n                if(p.first==1){\\n                    ans[i] = true;\\n                }\\n\\n                int x = p.first-1;\\n\\n                if(x%2==0 and x<=2*k){\\n                    ans[i] = true;\\n                }\\n                else{\\n                    k--;\\n                    if(x<=2*k){\\n                        ans[i] = true;\\n                    }\\n                }\\n\\n                \\n            }\\n\\n        }\\n\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351227,
                "title": "easy-java-solution-prefix-readable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n        int[][] pre = new int[s.length()][26];\\n        int[] temp = new int[26];\\n        for(int i =0;i<s.length();i++){\\n            temp[s.charAt(i)-\\'a\\']++;\\n            for(int j =0;j<26;j++){\\n                pre[i][j] = temp[j];\\n            }\\n        }\\n        List<Boolean>list = new ArrayList<>();\\n        for(int[] q:queries){\\n            int cnt =0;\\n            int l = q[0];\\n            int r = q[1];\\n            int k = q[2];\\n            for(int i =0;i<26;i++){\\n                if(l-1>=0){\\n                    cnt += (pre[r][i] - pre[l-1][i])%2;\\n                }\\n                else{\\n                    cnt+= pre[r][i]%2;\\n                }\\n            }\\n            list.add(cnt/2<=k);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n\\n        int[][] pre = new int[s.length()][26];\\n        int[] temp = new int[26];\\n        for(int i =0;i<s.length();i++){\\n            temp[s.charAt(i)-\\'a\\']++;\\n            for(int j =0;j<26;j++){\\n                pre[i][j] = temp[j];\\n            }\\n        }\\n        List<Boolean>list = new ArrayList<>();\\n        for(int[] q:queries){\\n            int cnt =0;\\n            int l = q[0];\\n            int r = q[1];\\n            int k = q[2];\\n            for(int i =0;i<26;i++){\\n                if(l-1>=0){\\n                    cnt += (pre[r][i] - pre[l-1][i])%2;\\n                }\\n                else{\\n                    cnt+= pre[r][i]%2;\\n                }\\n            }\\n            list.add(cnt/2<=k);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334034,
                "title": "python-26-n-q-brute-force-solution-preprocessing",
                "content": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        pref = [[0] for _ in range(26)]\\n        \\n        for i in range(len(s)):\\n            char = ord(s[i])-ord(\\'a\\')\\n            select = pref[char]\\n            select.append(select[-1]+1)\\n            for j in range(26):\\n                if j == char:\\n                    continue \\n                pref[j].append(pref[j][-1])\\n                \\n        ans = []\\n        \\n        for q in queries:\\n            l,r,k = q\\n            violate = 0 if (l-r+1)%2 == 0 else -1\\n            \\n            for p in range(26):\\n                if (pref[p][r+1] - pref[p][l])%2 != 0:\\n                    violate += 1\\n                    \\n            ans.append(True if 2*k>=violate else False)\\n\\n        return ans",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        pref = [[0] for _ in range(26)]\\n        \\n        for i in range(len(s)):\\n            char = ord(s[i])-ord(\\'a\\')\\n            select = pref[char]\\n            select.append(select[-1]+1)\\n            for j in range(26):\\n                if j == char:\\n                    continue \\n                pref[j].append(pref[j][-1])\\n                \\n        ans = []\\n        \\n        for q in queries:\\n            l,r,k = q\\n            violate = 0 if (l-r+1)%2 == 0 else -1\\n            \\n            for p in range(26):\\n                if (pref[p][r+1] - pref[p][l])%2 != 0:\\n                    violate += 1\\n                    \\n            ans.append(True if 2*k>=violate else False)\\n\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 3318275,
                "title": "327-ms",
                "content": "Matsumoto rejects `Integer#popcount` : https://bugs.ruby-lang.org/issues/8748#note-1\\n```ruby\\nclass Integer\\n\\n    @@m = 256.times.map { _1.to_s(2).count(?1) }\\n\\n    def popcount\\n        r, x = 0, self\\n        while x > 0\\n            r += @@m[x & 255]\\n            x >>= 8\\n        end\\n        r\\n    end\\n\\nend\\n\\ndef can_make_pali_queries s, q\\n    p = [0]\\n    s.each_byte do\\n        p.push p.last ^ (1 << _1 - 97)\\n    end\\n    q.map do | (l, r, k) |\\n        (p[l] ^ p[r + 1]).popcount >> 1 <= k\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass Integer\\n\\n    @@m = 256.times.map { _1.to_s(2).count(?1) }\\n\\n    def popcount\\n        r, x = 0, self\\n        while x > 0\\n            r += @@m[x & 255]\\n            x >>= 8\\n        end\\n        r\\n    end\\n\\nend\\n\\ndef can_make_pali_queries s, q\\n    p = [0]\\n    s.each_byte do\\n        p.push p.last ^ (1 << _1 - 97)\\n    end\\n    q.map do | (l, r, k) |\\n        (p[l] ^ p[r + 1]).popcount >> 1 <= k\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316779,
                "title": "python-prefix-sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        freqPS = [[0 for j in range(26)] for i in range(len(s)+1)]\\n        for i in range(len(s)):\\n            freqPS[i+1] = freqPS[i].copy()\\n            freqPS[i+1][ord(s[i]) - 97] += 1\\n        \\n        return [k >= sum((freqPS[r+1][i] - freqPS[l][i]) % 2 for i in range(26))//2 for l, r, k in queries]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        freqPS = [[0 for j in range(26)] for i in range(len(s)+1)]\\n        for i in range(len(s)):\\n            freqPS[i+1] = freqPS[i].copy()\\n            freqPS[i+1][ord(s[i]) - 97] += 1\\n        \\n        return [k >= sum((freqPS[r+1][i] - freqPS[l][i]) % 2 for i in range(26))//2 for l, r, k in queries]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288889,
                "title": "2-prefix-solution-space-26-time-n-26-and-bit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def using_prefix(self, s, queires):\\n        m = len(s)\\n        n = len(queries)\\n        self.res = [False] * n\\n        prefix = [[0]*26 for _ in range(m+1)]\\n\\n        for i in range(m):\\n            prefix[i+1] = prefix[i][:]\\n            prefix[i+1][ord(s[i])-ord(\\'a\\')] += 1\\n        \\n        for j in range(n):\\n            l, r, k = queries[j]\\n            \\n            if r-l+1 <= k:\\n                self.res[j] = True\\n                continue\\n            k *= 2\\n            middle = (r-l+1)%2 != 0\\n            \\n            for i in range(26):\\n                \\n                if k < -1:\\n                    break\\n                elif k == -1 and not middle:\\n                    break \\n                substring = prefix[r+1][i] - prefix[l][i]\\n                \\n                if substring %2 != 0:\\n                    k -= 1\\n            # print(j, k)\\n            if k >=0 or (k ==-1 and middle):\\n                self.res[j] = True\\n\\n        return self.res\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n\\n        # use 26 * m space prefix\\n        # return self.using_prefix(s, queries)\\n        m, n = len(s), len(queries)\\n        prefix = [0]* (m+1)\\n        prefix[0] = 1<<26\\n        res = [False]*n\\n        for i in range(m):\\n            prefix[i+1] = prefix[i]^(1<<(ord(s[i])-ord(\\'a\\')))\\n            \\n        for j in range(n):\\n            l, r, k = queries[j]\\n            odd = bin(prefix[r+1]^prefix[l]).count(\\'1\\') -1\\n            \\n            if odd - ((r+1-l)%2 !=0) <= 2*k:\\n                res[j] =True\\n\\n        return res\\n\\n            \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def using_prefix(self, s, queires):\\n        m = len(s)\\n        n = len(queries)\\n        self.res = [False] * n\\n        prefix = [[0]*26 for _ in range(m+1)]\\n\\n        for i in range(m):\\n            prefix[i+1] = prefix[i][:]\\n            prefix[i+1][ord(s[i])-ord(\\'a\\')] += 1\\n        \\n        for j in range(n):\\n            l, r, k = queries[j]\\n            \\n            if r-l+1 <= k:\\n                self.res[j] = True\\n                continue\\n            k *= 2\\n            middle = (r-l+1)%2 != 0\\n            \\n            for i in range(26):\\n                \\n                if k < -1:\\n                    break\\n                elif k == -1 and not middle:\\n                    break \\n                substring = prefix[r+1][i] - prefix[l][i]\\n                \\n                if substring %2 != 0:\\n                    k -= 1\\n            # print(j, k)\\n            if k >=0 or (k ==-1 and middle):\\n                self.res[j] = True\\n\\n        return self.res\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n\\n        # use 26 * m space prefix\\n        # return self.using_prefix(s, queries)\\n        m, n = len(s), len(queries)\\n        prefix = [0]* (m+1)\\n        prefix[0] = 1<<26\\n        res = [False]*n\\n        for i in range(m):\\n            prefix[i+1] = prefix[i]^(1<<(ord(s[i])-ord(\\'a\\')))\\n            \\n        for j in range(n):\\n            l, r, k = queries[j]\\n            odd = bin(prefix[r+1]^prefix[l]).count(\\'1\\') -1\\n            \\n            if odd - ((r+1-l)%2 !=0) <= 2*k:\\n                res[j] =True\\n\\n        return res\\n\\n            \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229195,
                "title": "very-easy-to-understand-must-see-interesting-question",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) \\n    {\\n          //final vector to be returned from the function\\n          vector<bool>ans(queries.size(),false);\\n\\n          //first we will calculate the frequency count for all of the prefix of the string \\n          //initially freq of all the character is zero\\n          vector<int>freq(26,0);    \\n\\n          //to keep the freq array/vector upto till ith psosition\\n          vector<vector<int>>v(s.length());\\n\\n          //computing all the pre freq vector for all the index i\\n          for(int i=0;i<s.length();i++)\\n          {\\n              char ch = s[i];\\n              freq[ch - \\'a\\']++;\\n\\n              v[i] = freq;\\n          }\\n          \\n          //processing every query\\n          for(int i=0;i<(queries.size());i++)\\n          {\\n              int start = queries[i][0];\\n              int end   = queries[i][1];\\n              int k     = queries[i][2];\\n\\n              if(start == 0)\\n              {\\n                  vector<int>temp_end = v[end];\\n                  \\n                  int evencount = 0;\\n                  int oddcount = 0;\\n\\n                  for(int i=0;i<26;i++)\\n                  {\\n                      //temp_end[i] = temp_end[i];\\n\\n                      if((temp_end[i] > 0) and (temp_end[i]%2) == 0)\\n                      evencount++;\\n                      else if((temp_end[i]%2)!=0)\\n                      oddcount++;\\n                  }\\n                  if(oddcount <= 1)\\n                  {\\n                       ans[i] = true;           \\n                  }\\n                  else\\n                  {\\n                      if((oddcount%2)==0)\\n                      {\\n                          if((oddcount/2) <= k)\\n                          {\\n                              ans[i] = true;\\n                          }\\n                      }\\n                      else if((oddcount%2)!=0)\\n                      {\\n                          if((oddcount/2) <= k)\\n                          {\\n                              ans[i] = true;\\n                          }\\n                      }\\n                  }\\n              }\\n              else\\n              {\\n                  vector<int>temp_end = v[end];\\n                  vector<int>temp_start = v[start-1];\\n\\n                  int evencount = 0;\\n                  int oddcount = 0;\\n\\n                  for(int i=0;i<26;i++)\\n                  {\\n                      temp_end[i] = temp_end[i] - temp_start[i];\\n\\n                      if((temp_end[i] > 0) and (temp_end[i]%2) == 0)\\n                      evencount++;\\n                      else if((temp_end[i]%2)!=0)\\n                      oddcount++;\\n                  }\\n                  if(oddcount <= 1)\\n                  {\\n                       ans[i] = true;           \\n                  }\\n                  else\\n                  {\\n                      if((oddcount%2)==0)\\n                      {\\n                          if((oddcount/2) <= k)\\n                          {\\n                              ans[i] = true;\\n                          }\\n                      }\\n                      else if((oddcount%2)!=0)\\n                      {\\n                          if((oddcount/2) <= k)\\n                          {\\n                              ans[i] = true;\\n                          }\\n                      }\\n                  }\\n              }\\n          }       \\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) \\n    {\\n          //final vector to be returned from the function\\n          vector<bool>ans(queries.size(),false);\\n\\n          //first we will calculate the frequency count for all of the prefix of the string \\n          //initially freq of all the character is zero\\n          vector<int>freq(26,0);    \\n\\n          //to keep the freq array/vector upto till ith psosition\\n          vector<vector<int>>v(s.length());\\n\\n          //computing all the pre freq vector for all the index i\\n          for(int i=0;i<s.length();i++)\\n          {\\n              char ch = s[i];\\n              freq[ch - \\'a\\']++;\\n\\n              v[i] = freq;\\n          }\\n          \\n          //processing every query\\n          for(int i=0;i<(queries.size());i++)\\n          {\\n              int start = queries[i][0];\\n              int end   = queries[i][1];\\n              int k     = queries[i][2];\\n\\n              if(start == 0)\\n              {\\n                  vector<int>temp_end = v[end];\\n                  \\n                  int evencount = 0;\\n                  int oddcount = 0;\\n\\n                  for(int i=0;i<26;i++)\\n                  {\\n                      //temp_end[i] = temp_end[i];\\n\\n                      if((temp_end[i] > 0) and (temp_end[i]%2) == 0)\\n                      evencount++;\\n                      else if((temp_end[i]%2)!=0)\\n                      oddcount++;\\n                  }\\n                  if(oddcount <= 1)\\n                  {\\n                       ans[i] = true;           \\n                  }\\n                  else\\n                  {\\n                      if((oddcount%2)==0)\\n                      {\\n                          if((oddcount/2) <= k)\\n                          {\\n                              ans[i] = true;\\n                          }\\n                      }\\n                      else if((oddcount%2)!=0)\\n                      {\\n                          if((oddcount/2) <= k)\\n                          {\\n                              ans[i] = true;\\n                          }\\n                      }\\n                  }\\n              }\\n              else\\n              {\\n                  vector<int>temp_end = v[end];\\n                  vector<int>temp_start = v[start-1];\\n\\n                  int evencount = 0;\\n                  int oddcount = 0;\\n\\n                  for(int i=0;i<26;i++)\\n                  {\\n                      temp_end[i] = temp_end[i] - temp_start[i];\\n\\n                      if((temp_end[i] > 0) and (temp_end[i]%2) == 0)\\n                      evencount++;\\n                      else if((temp_end[i]%2)!=0)\\n                      oddcount++;\\n                  }\\n                  if(oddcount <= 1)\\n                  {\\n                       ans[i] = true;           \\n                  }\\n                  else\\n                  {\\n                      if((oddcount%2)==0)\\n                      {\\n                          if((oddcount/2) <= k)\\n                          {\\n                              ans[i] = true;\\n                          }\\n                      }\\n                      else if((oddcount%2)!=0)\\n                      {\\n                          if((oddcount/2) <= k)\\n                          {\\n                              ans[i] = true;\\n                          }\\n                      }\\n                  }\\n              }\\n          }       \\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024892,
                "title": "prefix-sum-python3-solution-with-complexity-analysis",
                "content": "```\\nclass Solution:\\n    \\n    def getWindowCount(self, start, end, char_map):\\n        \\n        at_start = char_map[start]\\n        at_end = char_map[end+1]\\n        window_count = {}\\n        \\n        for ch, cnt in at_end.items():\\n            window_count[ch] = cnt-at_start[ch]\\n            \\n        return window_count\\n    \\n    \\n    def isPossible(self, char_map, start, end, k) -> bool:\\n        \\n        window_count = self.getWindowCount(start, end, char_map)\\n        widows_len = end+1-start\\n        odd_count, even_count = 0, 0\\n\\n        for cnt in window_count.values():\\n            if cnt % 2 == 1:\\n                odd_count += 1\\n                \\n        return odd_count//2 <= k\\n    \\n    \\n    # O(len(s) + len(queries)) time, getting the chars in current window is O(1) cause we iterate over only 26 times, \\n    # O(len(s)) space,\\n    # Approach: prefix sum, hashmap, \\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        \\n        char_count = defaultdict(int)\\n        count_at_index = [defaultdict(int)]\\n        \\n        for ch in s:\\n            char_count[ch] += 1\\n            count_at_index.append(char_count.copy())\\n\\n        answer = [False for _ in range(len(queries))]\\n        for index, query in enumerate(queries):\\n            start, end, k = query\\n            if self.isPossible(count_at_index, start, end, k):\\n                answer[index] = True\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def getWindowCount(self, start, end, char_map):\\n        \\n        at_start = char_map[start]\\n        at_end = char_map[end+1]\\n        window_count = {}\\n        \\n        for ch, cnt in at_end.items():\\n            window_count[ch] = cnt-at_start[ch]\\n            \\n        return window_count\\n    \\n    \\n    def isPossible(self, char_map, start, end, k) -> bool:\\n        \\n        window_count = self.getWindowCount(start, end, char_map)\\n        widows_len = end+1-start\\n        odd_count, even_count = 0, 0\\n\\n        for cnt in window_count.values():\\n            if cnt % 2 == 1:\\n                odd_count += 1\\n                \\n        return odd_count//2 <= k\\n    \\n    \\n    # O(len(s) + len(queries)) time, getting the chars in current window is O(1) cause we iterate over only 26 times, \\n    # O(len(s)) space,\\n    # Approach: prefix sum, hashmap, \\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        \\n        char_count = defaultdict(int)\\n        count_at_index = [defaultdict(int)]\\n        \\n        for ch in s:\\n            char_count[ch] += 1\\n            count_at_index.append(char_count.copy())\\n\\n        answer = [False for _ in range(len(queries))]\\n        for index, query in enumerate(queries):\\n            start, end, k = query\\n            if self.isPossible(count_at_index, start, end, k):\\n                answer[index] = True\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948767,
                "title": "c",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nbool process(char* s, bool** alpha, int begin, int end, int n){\\n    if(begin == end || n >=26 || (end-begin+1)/2 <= n)\\n        return true;\\n    int k = 0;\\n    for(int i = 0; i < 26; i++){\\n        if(begin == 0){\\n            k += alpha[end][i];\\n        }\\n        else{\\n            k += alpha[end][i] ^ alpha[begin-1][i];\\n        }\\n    }\\n    if(k/2 <= n)\\n        return true;\\n    else\\n        return false;\\n}\\nbool* canMakePaliQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    int  n = strlen(s);\\n    bool* ans = malloc(queriesSize * sizeof(bool));\\n    bool** alpha = malloc(n * sizeof(bool*));\\n    alpha[0] = calloc(26, sizeof(bool));\\n    alpha[0][s[0]-\\'a\\'] = true;\\n    for(int i = 1; i < n; i++){\\n        alpha[i] = malloc(26 * sizeof(bool));\\n        memcpy(alpha[i], alpha[i-1], 26*sizeof(bool));\\n        alpha[i][s[i]-\\'a\\'] ^= true;\\n    }\\n    *returnSize = queriesSize;\\n    for(int i = 0; i < queriesSize; i++){\\n        ans[i] = process(s, alpha, queries[i][0], queries[i][1], queries[i][2]);\\n    }\\n    for(int i = 0; i < n; i++){\\n        free(alpha[i]);\\n    }\\n    free(alpha);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nbool process(char* s, bool** alpha, int begin, int end, int n){\\n    if(begin == end || n >=26 || (end-begin+1)/2 <= n)\\n        return true;\\n    int k = 0;\\n    for(int i = 0; i < 26; i++){\\n        if(begin == 0){\\n            k += alpha[end][i];\\n        }\\n        else{\\n            k += alpha[end][i] ^ alpha[begin-1][i];\\n        }\\n    }\\n    if(k/2 <= n)\\n        return true;\\n    else\\n        return false;\\n}\\nbool* canMakePaliQueries(char * s, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    int  n = strlen(s);\\n    bool* ans = malloc(queriesSize * sizeof(bool));\\n    bool** alpha = malloc(n * sizeof(bool*));\\n    alpha[0] = calloc(26, sizeof(bool));\\n    alpha[0][s[0]-\\'a\\'] = true;\\n    for(int i = 1; i < n; i++){\\n        alpha[i] = malloc(26 * sizeof(bool));\\n        memcpy(alpha[i], alpha[i-1], 26*sizeof(bool));\\n        alpha[i][s[i]-\\'a\\'] ^= true;\\n    }\\n    *returnSize = queriesSize;\\n    for(int i = 0; i < queriesSize; i++){\\n        ans[i] = process(s, alpha, queries[i][0], queries[i][1], queries[i][2]);\\n    }\\n    for(int i = 0; i < n; i++){\\n        free(alpha[i]);\\n    }\\n    free(alpha);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2867086,
                "title": "easy-to-understand-solution-java-solution-prefix-sum-with-comments",
                "content": "Idea is Simple :\\n\\t1. calculate the count of all the previous characters and keep it in some place.\\n\\t2. Once queries comes, the find all the diff between count of characters for left -1 position and right position\\n\\t3. We can remove pairs of characters if both are same, so only consider remaining characters\\n\\t4. Then check if substring is even or odd if odd, then we can have one distinct character so remove one from difference\\n\\t5. then divide it into two parts and we will try to make first half same as second \\n\\t6. So If first half count is less than or equal to k then it should be true\\n\\t7. \\n```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        HashMap<Integer,int[]> map = new HashMap<>();\\n        \\n        int[] arr = new int[26];\\n        map.put(-1, new int[26]);\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            arr[c-\\'a\\']++;\\n            map.put(i, getArray(arr));\\n        }\\n        \\n        List<Boolean> list = new ArrayList<>();\\n        for(int[] query : queries) {\\n            int diff = 0;\\n            int left = query[0];\\n            int right = query[1];\\n            int k = query[2];\\n            for(int i=0; i<26; i++) {\\n                diff += (map.get(right)[i] - map.get(left-1)[i])%2;\\n            }\\n            int count = right - left + 1;\\n            if(count%2==0) {\\n                list.add(diff/2 <= k);\\n            }\\n            else{\\n                list.add((diff-1)/2 <= k);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    public int[] getArray(int[] arr) {\\n        int[] temp = new int[26];\\n        for(int i=0; i<26; i++) {\\n            temp[i] = arr[i];\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n        HashMap<Integer,int[]> map = new HashMap<>();\\n        \\n        int[] arr = new int[26];\\n        map.put(-1, new int[26]);\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            arr[c-\\'a\\']++;\\n            map.put(i, getArray(arr));\\n        }\\n        \\n        List<Boolean> list = new ArrayList<>();\\n        for(int[] query : queries) {\\n            int diff = 0;\\n            int left = query[0];\\n            int right = query[1];\\n            int k = query[2];\\n            for(int i=0; i<26; i++) {\\n                diff += (map.get(right)[i] - map.get(left-1)[i])%2;\\n            }\\n            int count = right - left + 1;\\n            if(count%2==0) {\\n                list.add(diff/2 <= k);\\n            }\\n            else{\\n                list.add((diff-1)/2 <= k);\\n            }\\n        }\\n        \\n        return list;\\n    }\\n    \\n    public int[] getArray(int[] arr) {\\n        int[] temp = new int[26];\\n        for(int i=0; i<26; i++) {\\n            temp[i] = arr[i];\\n        }\\n        \\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821527,
                "title": "cpp-solution-bit-masking",
                "content": "please UPVOTE :)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.length();\\n        vector<long long> prefix(n+1, 0);\\n        vector<bool> ans(queries.size(), false);\\n        long long mask = 1;\\n        prefix[1] = (mask << (s[0]-\\'a\\'));\\n        for(int i = 1 ; i < n ; i++)\\n            prefix[i+1] = (prefix[i] ^ (mask << s[i]-\\'a\\'));\\n\\n        for(int i = 0 ; i < queries.size() ; i++){\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            int k = queries[i][2];\\n\\n            long long val = (prefix[r+1]^prefix[l]);\\n\\n            int setBits = 0;\\n            while(val != 0){\\n                int rmsb = (val & -val);\\n                val = val - rmsb;\\n                setBits++;\\n            }\\n\\n            if(setBits == 0 || setBits == 1)    ans[i] = true;\\n            else if(setBits-2*k <= 1)   ans[i] = true;\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.length();\\n        vector<long long> prefix(n+1, 0);\\n        vector<bool> ans(queries.size(), false);\\n        long long mask = 1;\\n        prefix[1] = (mask << (s[0]-\\'a\\'));\\n        for(int i = 1 ; i < n ; i++)\\n            prefix[i+1] = (prefix[i] ^ (mask << s[i]-\\'a\\'));\\n\\n        for(int i = 0 ; i < queries.size() ; i++){\\n            int l = queries[i][0];\\n            int r = queries[i][1];\\n            int k = queries[i][2];\\n\\n            long long val = (prefix[r+1]^prefix[l]);\\n\\n            int setBits = 0;\\n            while(val != 0){\\n                int rmsb = (val & -val);\\n                val = val - rmsb;\\n                setBits++;\\n            }\\n\\n            if(setBits == 0 || setBits == 1)    ans[i] = true;\\n            else if(setBits-2*k <= 1)   ans[i] = true;\\n        } \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818964,
                "title": "golang-prefix-sum",
                "content": "```go\\nfunc canMakePaliQueries(s string, queries [][]int) []bool {\\n  psum := make([][26]int, len(s)+1)\\n  for i := 0; i < len(s); i++ {\\n    psum[i+1] = psum[i]\\n    psum[i+1][s[i]-\\'a\\']++\\n  }\\n  res := make([]bool, len(queries))\\n  for idx, query := range queries {\\n    left, right, k := query[0], query[1], query[2]\\n    var odds int\\n    for i := 0; i < 26; i++ {\\n      if (psum[right+1][i] - psum[left][i])%2 == 1 {\\n        odds++\\n      }\\n    }\\n    odds -= k*2 // The corrections we can make\\n    res[idx] = odds <= 1 // There must be at most 1 odd after the corrections\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Prefix Sum"
                ],
                "code": "```go\\nfunc canMakePaliQueries(s string, queries [][]int) []bool {\\n  psum := make([][26]int, len(s)+1)\\n  for i := 0; i < len(s); i++ {\\n    psum[i+1] = psum[i]\\n    psum[i+1][s[i]-\\'a\\']++\\n  }\\n  res := make([]bool, len(queries))\\n  for idx, query := range queries {\\n    left, right, k := query[0], query[1], query[2]\\n    var odds int\\n    for i := 0; i < 26; i++ {\\n      if (psum[right+1][i] - psum[left][i])%2 == 1 {\\n        odds++\\n      }\\n    }\\n    odds -= k*2 // The corrections we can make\\n    res[idx] = odds <= 1 // There must be at most 1 odd after the corrections\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761867,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        vector<vector<int>> prefix(26, vector<int>(s.size()+1));\\n        \\n        for(int i=0, sz=s.size(); i<sz; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n                if(j==(s[i]-\\'a\\'))\\n                    prefix[j][i+1]=prefix[j][i]+1;\\n                else\\n                    prefix[j][i+1]=prefix[j][i];\\n        }\\n        \\n        vector<bool> ans;\\n        \\n        int size=queries.size();\\n        \\n        for(int i=0; i<size; i++)\\n        {\\n            int count=0;\\n            int left=queries[i][0], right=queries[i][1];\\n            \\n            int n=0; //number of characters with odd occurrences in the range\\n            for(int j=0; j<26; j++)\\n            {\\n                if((prefix[j][right+1]-prefix[j][left])%2!=0)\\n                    n++;\\n            }\\n            \\n            if(n/2 <= queries[i][2])\\n                ans.push_back(true);\\n            else\\n                ans.push_back(false);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        vector<vector<int>> prefix(26, vector<int>(s.size()+1));\\n        \\n        for(int i=0, sz=s.size(); i<sz; i++)\\n        {\\n            for(int j=0; j<26; j++)\\n                if(j==(s[i]-\\'a\\'))\\n                    prefix[j][i+1]=prefix[j][i]+1;\\n                else\\n                    prefix[j][i+1]=prefix[j][i];\\n        }\\n        \\n        vector<bool> ans;\\n        \\n        int size=queries.size();\\n        \\n        for(int i=0; i<size; i++)\\n        {\\n            int count=0;\\n            int left=queries[i][0], right=queries[i][1];\\n            \\n            int n=0; //number of characters with odd occurrences in the range\\n            for(int j=0; j<26; j++)\\n            {\\n                if((prefix[j][right+1]-prefix[j][left])%2!=0)\\n                    n++;\\n            }\\n            \\n            if(n/2 <= queries[i][2])\\n                ans.push_back(true);\\n            else\\n                ans.push_back(false);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722472,
                "title": "prefix",
                "content": "```\\nvector<bool> canMakePaliQueries(string s, vector<vector<int>>& q)\\n{\\n\\tint d[100001][26]{};\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t\\tfor(int j{}; j<26; ++j)\\n\\t\\t\\td[i+1][j]=d[i][j]+(\\'a\\'+j==s[i]);  \\n\\n\\tvector<bool> out(size(q));\\n\\tfor(int i{}; i<size(q); ++i)\\n\\t{\\n\\t\\tint o{};\\n\\t\\tfor(int j{}; j<26; ++j) o += d[q[i][1]+1][j]-d[q[i][0]][j]&1;\\n\\t\\tout[i] = (o+(q[i][1]-q[i][0]&1))/2<=q[i][2];\\n\\t}\\n\\treturn out;\\n}\\n```\\n**Notation:**\\n`o` -**o**dd;\\n`d` - prefix sum for each of the characters `a...z`.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<bool> canMakePaliQueries(string s, vector<vector<int>>& q)\\n{\\n\\tint d[100001][26]{};\\n\\tfor(int i{}; i<size(s); ++i)\\n\\t\\tfor(int j{}; j<26; ++j)\\n\\t\\t\\td[i+1][j]=d[i][j]+(\\'a\\'+j==s[i]);  \\n\\n\\tvector<bool> out(size(q));\\n\\tfor(int i{}; i<size(q); ++i)\\n\\t{\\n\\t\\tint o{};\\n\\t\\tfor(int j{}; j<26; ++j) o += d[q[i][1]+1][j]-d[q[i][0]][j]&1;\\n\\t\\tout[i] = (o+(q[i][1]-q[i][0]&1))/2<=q[i][2];\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2692782,
                "title": "c-simple-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.length(), mask = 0;\\n        vector<int> maskStr;\\n        for (char ch: s) {\\n            mask ^= (1 << (ch-\\'a\\'));\\n            maskStr.push_back(mask);\\n        }\\n        vector<bool> res;\\n        for (auto &q: queries) {\\n            if (q[0]-1 >= 0) mask = maskStr[q[1]] ^ maskStr[q[0]-1];\\n            else mask = maskStr[q[1]];\\n            if (mask == 0 || ((mask & (mask-1))==0)) res.push_back(true);\\n            else {\\n                int count = 0;\\n                while (mask > 0) {\\n                    count += (mask&1);\\n                    mask >>= 1;\\n                }\\n                res.push_back((count/2)<=q[2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.length(), mask = 0;\\n        vector<int> maskStr;\\n        for (char ch: s) {\\n            mask ^= (1 << (ch-\\'a\\'));\\n            maskStr.push_back(mask);\\n        }\\n        vector<bool> res;\\n        for (auto &q: queries) {\\n            if (q[0]-1 >= 0) mask = maskStr[q[1]] ^ maskStr[q[0]-1];\\n            else mask = maskStr[q[1]];\\n            if (mask == 0 || ((mask & (mask-1))==0)) res.push_back(true);\\n            else {\\n                int count = 0;\\n                while (mask > 0) {\\n                    count += (mask&1);\\n                    mask >>= 1;\\n                }\\n                res.push_back((count/2)<=q[2]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665351,
                "title": "c-460-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(const string& s, const vector<vector<int>>& queries) {\\n        vector<int> masks(s.size());\\n        for(size_t i=0; i<s.size(); ++i)\\n            masks[i]=(i? masks[i-1]: 0) ^ (1<<s[i]-\\'a\\');\\n        \\n        vector<bool> res(queries.size());\\n        for(size_t i=0; i<queries.size(); ++i) {\\n            int odd=bitset<32>((queries[i][0]? masks[queries[i][0]-1]: 0) ^ masks[queries[i][1]]).count();\\n            if((odd%2? --odd: odd)/2 <= queries[i][2]) res[i]=true;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(const string& s, const vector<vector<int>>& queries) {\\n        vector<int> masks(s.size());\\n        for(size_t i=0; i<s.size(); ++i)\\n            masks[i]=(i? masks[i-1]: 0) ^ (1<<s[i]-\\'a\\');\\n        \\n        vector<bool> res(queries.size());\\n        for(size_t i=0; i<queries.size(); ++i) {\\n            int odd=bitset<32>((queries[i][0]? masks[queries[i][0]-1]: 0) ^ masks[queries[i][1]]).count();\\n            if((odd%2? --odd: odd)/2 <= queries[i][2]) res[i]=true;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640882,
                "title": "detailed-explanation-new-leetcode-template",
                "content": "# Intuition\\nsince we can rearrange substring , we have to check freq of every character and see if we can somehow arrange those characters to make a palindrome\\n\\n# Approach\\nif freq of every element is even , we can make that substring as palindrome.\\nif freq of all element is even except one, we can still make it palindrome..\\n\\nwe count number of letters with odd freq [ as they can create problem]\\nin one operation we can make 2 characters same [by making one equal to other]\\n\\nsuppose we have frequencies like this\\na->11\\nb->13\\nc->9\\nd->15\\ne->14\\n\\nnow we have to find which characters are creating problem\\na->1 ( one character of a might create problem)\\nb->1 ( one character of b might create problem)\\nc->1 ( one character of c might create problem)\\nd->1 ( one character of d might create problem)\\ne->0 ( zero character of e might create problem) // we dont have to consider this case as it can always make a palindrome.\\n\\nnow we have 4 characters [a,b,c,d] which will create problem.\\nin one operation we can change any character to any!\\nlets say if k>0 then we change problematic occurence of a to b\\nnow since we have changed one occurence of a to b, b becomes even in nature thus there are no problematic occurences of b in the array now.\\n\\nso in one operation we can somehow adjust 2 characters.\\nand in the end we can have atmax 1 problematic character, which we can plate in the middle of string\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nN*26 + N = 27N = > O(n)\\n\\n- Space complexity:\\nN*26\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n         vector<bool> ans;\\n         vector<vector<int>> freq(s.size()+2,vector<int>(26,0));\\n         for (int i=0;i<s.size();i++)\\n         {\\n          freq[i+1][s[i]-\\'a\\']++;\\n          for (int j=0;j<26;j++)\\n          {\\n              freq[i+1][j]+=freq[i][j];\\n          }\\n         }\\n         for (int i=0;i<queries.size();i++)\\n         {\\n             int left=queries[i][0];\\n             int right=queries[i][1];\\n             int operations=queries[i][2];\\n             if (right-left+1<=operations)\\n             ans.push_back(true);\\n             else\\n             {\\n                 int count=0;\\n\\nfor (int j=0;j<26;j++)\\n{\\n    int c=freq[right+1][j]-freq[left][j];\\n    if (c%2!=0)\\n    count++;\\n}\\ncout<<count<<endl;\\n\\ncount=count-2*operations;\\nif (count>1)\\nans.push_back(false);\\nelse\\nans.push_back(true);\\n\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n         vector<bool> ans;\\n         vector<vector<int>> freq(s.size()+2,vector<int>(26,0));\\n         for (int i=0;i<s.size();i++)\\n         {\\n          freq[i+1][s[i]-\\'a\\']++;\\n          for (int j=0;j<26;j++)\\n          {\\n              freq[i+1][j]+=freq[i][j];\\n          }\\n         }\\n         for (int i=0;i<queries.size();i++)\\n         {\\n             int left=queries[i][0];\\n             int right=queries[i][1];\\n             int operations=queries[i][2];\\n             if (right-left+1<=operations)\\n             ans.push_back(true);\\n             else\\n             {\\n                 int count=0;\\n\\nfor (int j=0;j<26;j++)\\n{\\n    int c=freq[right+1][j]-freq[left][j];\\n    if (c%2!=0)\\n    count++;\\n}\\ncout<<count<<endl;\\n\\ncount=count-2*operations;\\nif (count>1)\\nans.push_back(false);\\nelse\\nans.push_back(true);\\n\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2639684,
                "title": "c-bitmask",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n\\t\\t\\tvector<int> mask;\\n\\t\\t\\tvector<bool> res;\\n\\t\\t\\tint cur=0;\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tcur^=(1<<(s[i]-\\'a\\'));\\n\\t\\t\\t\\tmask.push_back(cur);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<q.size();i++) {\\n\\t\\t\\t\\tint l=q[i][0]-1;\\n\\t\\t\\t\\tint r=q[i][1];\\n\\t\\t\\t\\tif(l>=0) cur=mask[r]^mask[l];\\n\\t\\t\\t\\telse cur=mask[r];\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\t\\tif(cur&1) count++;\\n\\t\\t\\t\\t\\tcur>>=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres.push_back(count/2<=q[i][2]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n\\t\\t\\tvector<int> mask;\\n\\t\\t\\tvector<bool> res;\\n\\t\\t\\tint cur=0;\\n\\t\\t\\tfor(int i=0;i<s.length();i++) {\\n\\t\\t\\t\\tcur^=(1<<(s[i]-\\'a\\'));\\n\\t\\t\\t\\tmask.push_back(cur);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2620186,
                "title": "c-xor-range-with-fenwick-tree-o-nlogn",
                "content": "```\\nclass Solution {\\n    vector<int> f;\\n    string str;\\npublic:\\n    int get(int i, int j) {\\n        int ans = 0;\\n        while (j>=i) {\\n            if(j - (j & -j) >= i) {\\n                ans ^= f[j];\\n                j -= (j & -j);\\n            } else {\\n                ans ^= (1<<(str[j-1]-\\'a\\'));\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void update(int i, char c) {\\n        while (i<=str.size()) {\\n            f[i] ^= (1 << (c-\\'a\\'));\\n            i += (i & -i);\\n        }\\n    }\\n    \\n    int countSetBit(int num) {\\n        return __builtin_popcount(num);\\n    }\\n    \\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool> ans = vector<bool>(queries.size(), false);\\n        f = vector<int>(s.length() + 1, 0);\\n        str = s;\\n        \\n        for(int i=1; i<=s.length(); i++) {\\n            update(i, s[i-1]);\\n        }\\n        \\n        int i = 0;  \\n        for(auto q: queries) {\\n            int left = q[0]+1, right = q[1]+1, k = q[2];\\n            int xorRange = get(left,right);\\n            int setBits = countSetBit(xorRange);\\n            if(setBits / 2 <= k) {\\n                ans[i] = true;\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> f;\\n    string str;\\npublic:\\n    int get(int i, int j) {\\n        int ans = 0;\\n        while (j>=i) {\\n            if(j - (j & -j) >= i) {\\n                ans ^= f[j];\\n                j -= (j & -j);\\n            } else {\\n                ans ^= (1<<(str[j-1]-\\'a\\'));\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void update(int i, char c) {\\n        while (i<=str.size()) {\\n            f[i] ^= (1 << (c-\\'a\\'));\\n            i += (i & -i);\\n        }\\n    }\\n    \\n    int countSetBit(int num) {\\n        return __builtin_popcount(num);\\n    }\\n    \\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<bool> ans = vector<bool>(queries.size(), false);\\n        f = vector<int>(s.length() + 1, 0);\\n        str = s;\\n        \\n        for(int i=1; i<=s.length(); i++) {\\n            update(i, s[i-1]);\\n        }\\n        \\n        int i = 0;  \\n        for(auto q: queries) {\\n            int left = q[0]+1, right = q[1]+1, k = q[2];\\n            int xorRange = get(left,right);\\n            int setBits = countSetBit(xorRange);\\n            if(setBits / 2 <= k) {\\n                ans[i] = true;\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604731,
                "title": "python-simple-dp",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        # dp=[Counter()]*(len(s)+1)\\n        # freq=[]\\n        res=[]\\n        \\n        dp=[[0]*26]\\n        \\n        \\n        \\n        \\n        for i in range(1,len(s)+1):\\n            # dp[i]=dp[i-1]+Counter(s[i-1])\\n            new=dp[i-1][:]\\n            j=ord(s[i-1])-97\\n            new[j]+=1\\n            dp.append(new)\\n            \\n        \\n            \\n        # print(dp)\\n            \\n            \\n            \\n        \\n        \\n        for l,r,k in queries:\\n            # p=s[l:r+1]\\n            # c=Counter(p)\\n            # c=dp[r+1]-dp[l]\\n            cnt=0\\n            \\n            rr=dp[r+1][:]\\n            ll=dp[l][:]\\n            # print(rr,ll)\\n            for i in range(26):\\n                \\n                cnt+=(rr[i]-ll[i])&1\\n                \\n                # if c[i]%2==1:\\n                    # cnt+=1\\n                    \\n            if cnt//2<=k:\\n                res.append(True)\\n                \\n            else:\\n                res.append(False)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        # dp=[Counter()]*(len(s)+1)\\n        # freq=[]\\n        res=[]\\n        \\n        dp=[[0]*26]\\n        \\n        \\n        \\n        \\n        for i in range(1,len(s)+1):\\n            # dp[i]=dp[i-1]+Counter(s[i-1])\\n            new=dp[i-1][:]\\n            j=ord(s[i-1])-97\\n            new[j]+=1\\n            dp.append(new)\\n            \\n        \\n            \\n        # print(dp)\\n            \\n            \\n            \\n        \\n        \\n        for l,r,k in queries:\\n            # p=s[l:r+1]\\n            # c=Counter(p)\\n            # c=dp[r+1]-dp[l]\\n            cnt=0\\n            \\n            rr=dp[r+1][:]\\n            ll=dp[l][:]\\n            # print(rr,ll)\\n            for i in range(26):\\n                \\n                cnt+=(rr[i]-ll[i])&1\\n                \\n                # if c[i]%2==1:\\n                    # cnt+=1\\n                    \\n            if cnt//2<=k:\\n                res.append(True)\\n                \\n            else:\\n                res.append(False)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471836,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        ll sz = s.length(), szq = q.size();\\n        vi(bool)ans(szq, false);\\n        vi(ll)bm(sz, 0);\\n        bm[0] = 1 << (s[0] - \\'a\\');\\n        for (ll i = 1;i < sz;++i) {\\n            bm[i] = bm[i - 1] ^ (1 << (s[i] - \\'a\\'));\\n        }\\n        for (ll i = 0;i < szq;++i) {\\n            ll o = 0, mask = bm[q[i][1]];\\n            if (q[i][0] > 0) {\\n                mask ^= bm[q[i][0] - 1];\\n            }\\n            while (mask) {\\n                o += mask & 1;\\n                mask >>= 1;\\n            }\\n            if (q[i][2] >= o / 2) {\\n                ans[i] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        ll sz = s.length(), szq = q.size();\\n        vi(bool)ans(szq, false);\\n        vi(ll)bm(sz, 0);\\n        bm[0] = 1 << (s[0] - \\'a\\');\\n        for (ll i = 1;i < sz;++i) {\\n            bm[i] = bm[i - 1] ^ (1 << (s[i] - \\'a\\'));\\n        }\\n        for (ll i = 0;i < szq;++i) {\\n            ll o = 0, mask = bm[q[i][1]];\\n            if (q[i][0] > 0) {\\n                mask ^= bm[q[i][0] - 1];\\n            }\\n            while (mask) {\\n                o += mask & 1;\\n                mask >>= 1;\\n            }\\n            if (q[i][2] >= o / 2) {\\n                ans[i] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415722,
                "title": "solution-using-bit-fields-and-prefix-sums-with-detailed-explanation",
                "content": "## Insights & Non-Optimal Solution\\nFor any palindrome string, if we keep a count for each distinct characters that make up the string, we will always find that one and only one character can have an odd count. For example, take the character counts for `racecar`: `{ \"a\": 2, \"c\": 2, \"e\": 1,\"r\": 2 }`. You can see that only the count for `e` is odd.\\n\\nAny string that can be rearranged into a palindrome string must have the same characteristic above. So in order to edit a string so that the resulting string can be rearranged into a palindrome, we need to edit all the characters with odd counts so that at most only one character in the result have an odd count.\\n\\nIt is fairly easy to see that we can then pair two characters with odd counts together, and for each pair edit one character of one kind in the substring to become the other, until there is only at most one character with odd count.\\n\\nTake the word `basilides` for example. In this word five characers being `b`, `a`, `e`, `l`, `d` have odd counts. We can then pair `b` and `d`, and edit `b` into `d`. This results in the string `dasilides`. Now we have `a`, `e`, `l` remaining as characters with odd counts. Pair `a` and `e` together and then edit `e` into `a`, we get `dasilidas`. This string can be rearranged into the palindrome `dasilisad`.\\n\\nUsing this strategy, the number of edits would then be the number of characters with odd counts divided by 2, modulo 2. In the example above, the number of edits is `2 = 5 % 2`. This is in fact the optimal amount of edits required for the string `basilides`.\\n\\nWith the strategy above, we can solve this problem for each query by making a hash map that contains the counts for each characters in the substring formed by the pair of indices in the query, calculate the number of edits based on the hash map, then compare the number of edits we got with the number of edits in the query to give the correct answer for the query.\\n\\nUsing a hash map, however, will not be enough to pass the time limit of the problem.\\n\\n## Efficient Solution\\nSince one of the problem constraints states that the string will only have lower case characters, and we do not really care about the count of the characters themselves but the oddness of the counts, we can **replace the hash map used for counting characters with a bit field**, where each bit represents the modulo under modulo 2 of the count for each characters.\\n\\nTo do the bit flipping we calculate a mask by shifting `1` left by the index of the character in the bit field. Call a mask for the character at `i` `mask(s[i])`.\\n\\nSo for any subarray, what we will be doing instead is to simply flip the bit in the bit field corresponding to a character every time we encounter that character in a subarray. To count the number of characters in a substring with odd counts, we can count the number of bits that are `1` in the bit field. To toggle the bit corresponding to a character in the bit field, we can calculate a mask by \\n\\nUsing bit fields, it is possible to further optimize the problem by using **prefix sums** to take advantage of some properties of the XOR operation and calculate the bit field for any subarray delimited by the indices `(i, j)` very quickly. Take `bit_field(s[i..=j])` to be the bit field produced for the sub array delimited by the indices `(i, j)`, and `i..=j` to denote the inclusive range between `i` and `j`, then for any `i > 0` and `j`, we have:\\n\\n```Rust\\nbit_field(s[i..=j]) = bit_field(s[0..=(i - 1)]) ^ bit_field(s[0..=j]);\\n```\\n\\nWhy does this work? Because of how we calculate the bit fields for a subarray, we always have:\\n\\n```Rust\\nbit_field(s[0..=j]) = bit_field(s[0..=i]) ^ mask(s[i + 1]) ^ mask(s[i + 2]) ^ ... ^ mask(s[j]);\\n```\\n\\nWhich is equivalent to:\\n\\n```Rust\\nbit_field(s[0..=j]) = bit_field(s[0..=i]) ^ bit_field(s[(i+1)..=j]);\\n```\\n\\nAs the inverse of a bit array under the XOR operation is itself, and XOR is associative and commutative, we can XOR both sides with `bit_field(s[0..=i])` to get what we wanted.\\n\\nWhat is nice about this property is that we can calculate the prefix `bit_field(s[0..=i])` when i is in `0..=s.len()`, as:\\n```Rust\\nbit_field(s[0..=(i + 1)]) = bit_field(s[0..=i]) ^ mask(s[i + 1])\\n```\\n\\nSo we can calculate the prefix sums/bit fields in linear time.\\n\\n## Code for the Efficient Solution\\nHere is a solution using Rust:\\n\\n```Rust\\nimpl Solution {\\n  pub fn can_make_pali_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<bool> {\\n    let mut results: Vec<bool> = Vec::with_capacity(queries.len());\\n    let s_len: usize = s.len();\\n\\n    let mut prefix_modulo_bit_fields: Vec<u32> = Vec::with_capacity(s_len);\\n    let byte_array = s.as_bytes();\\n\\n    let char_bit_index = byte_array[0] - 97;\\n    let index_0_mask = 1 << char_bit_index;\\n    prefix_modulo_bit_fields.insert(0, 0 ^ index_0_mask);\\n\\n    for i in (1..s_len) {\\n      let char_bit_index = byte_array[i] - 97;\\n      let mask = 1 << char_bit_index;\\n      let previous_bit_field = *prefix_modulo_bit_fields.get(i - 1).unwrap();\\n      prefix_modulo_bit_fields.insert(i, previous_bit_field ^ mask);\\n    }\\n\\n    for query in queries.iter() {\\n      let i = *query.get(0).unwrap() as usize;\\n      let j = *query.get(1).unwrap() as usize;\\n      let max_nummber_of_edits = *query.get(2).unwrap() as u32;\\n\\n      if (i > 0) {\\n        let head = *prefix_modulo_bit_fields.get(i - 1).unwrap();\\n        let head_tail = *prefix_modulo_bit_fields.get(j).unwrap();\\n  \\n        results.push(((head ^ head_tail).count_ones() / 2) <= max_nummber_of_edits);\\n      } else {\\n        let head = *prefix_modulo_bit_fields.get(j).unwrap();\\n\\n        results.push((head.count_ones() / 2) <= max_nummber_of_edits);\\n      }\\n    }\\n\\n    return results;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```Rust\\nbit_field(s[i..=j]) = bit_field(s[0..=(i - 1)]) ^ bit_field(s[0..=j]);\\n```\n```Rust\\nbit_field(s[0..=j]) = bit_field(s[0..=i]) ^ mask(s[i + 1]) ^ mask(s[i + 2]) ^ ... ^ mask(s[j]);\\n```\n```Rust\\nbit_field(s[0..=j]) = bit_field(s[0..=i]) ^ bit_field(s[(i+1)..=j]);\\n```\n```Rust\\nbit_field(s[0..=(i + 1)]) = bit_field(s[0..=i]) ^ mask(s[i + 1])\\n```\n```Rust\\nimpl Solution {\\n  pub fn can_make_pali_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<bool> {\\n    let mut results: Vec<bool> = Vec::with_capacity(queries.len());\\n    let s_len: usize = s.len();\\n\\n    let mut prefix_modulo_bit_fields: Vec<u32> = Vec::with_capacity(s_len);\\n    let byte_array = s.as_bytes();\\n\\n    let char_bit_index = byte_array[0] - 97;\\n    let index_0_mask = 1 << char_bit_index;\\n    prefix_modulo_bit_fields.insert(0, 0 ^ index_0_mask);\\n\\n    for i in (1..s_len) {\\n      let char_bit_index = byte_array[i] - 97;\\n      let mask = 1 << char_bit_index;\\n      let previous_bit_field = *prefix_modulo_bit_fields.get(i - 1).unwrap();\\n      prefix_modulo_bit_fields.insert(i, previous_bit_field ^ mask);\\n    }\\n\\n    for query in queries.iter() {\\n      let i = *query.get(0).unwrap() as usize;\\n      let j = *query.get(1).unwrap() as usize;\\n      let max_nummber_of_edits = *query.get(2).unwrap() as u32;\\n\\n      if (i > 0) {\\n        let head = *prefix_modulo_bit_fields.get(i - 1).unwrap();\\n        let head_tail = *prefix_modulo_bit_fields.get(j).unwrap();\\n  \\n        results.push(((head ^ head_tail).count_ones() / 2) <= max_nummber_of_edits);\\n      } else {\\n        let head = *prefix_modulo_bit_fields.get(j).unwrap();\\n\\n        results.push((head.count_ones() / 2) <= max_nummber_of_edits);\\n      }\\n    }\\n\\n    return results;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330699,
                "title": "c-brute-to-optimal-using-prefix-hash-array",
                "content": "Brute (TLE)\\n```\\nbool isPalindrome(string& s, vector<int>& q){\\n        \\n        int l = q[0], r = q[1];\\n        int cnt = 0;\\n        \\n        while(l<r){\\n            if(s[l++] != s[r--]) cnt++;\\n            if(cnt > q[2]) return false;\\n        }\\n        \\n        return true;\\n    }\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        \\n        vector<bool> ans;\\n        \\n        for(int i=0; i<q.size(); i++){\\n            \\n            if(isPalindrome(s, q[i]))\\n                ans.push_back(true);\\n            else\\n                ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n```\\n\\nStore freq of char till ith char,\\nCnt char between given range and see if possible to make palindrome making k changes.\\n\\n```\\nbool isPalindrome(vector<vector<int>>& hash,  vector<int>& q){\\n        \\n        int l=q[0], r=q[1];\\n        int cnt = 0;\\n        \\n        for(int i=0; i<26; i++){\\n            \\n            int freq = hash[r][i] - (l>0 ? hash[l-1][i] : 0);\\n            if(freq&1) cnt++;\\n        }\\n        \\n        return (cnt%2==0 and cnt/2<=q[2]) or (cnt%2!=0 and (cnt-1)/2<=q[2]);\\n    }\\n    \\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q){\\n        \\n        int n = s.size();\\n        \\n        vector<vector<int>> hash(n, vector<int>(26, 0));\\n        \\n        hash[0][s[0]-\\'a\\']++;\\n        \\n        for(int i=1; i<n; i++){\\n            hash[i] = hash[i-1];\\n            hash[i][s[i] - \\'a\\']++;\\n        }\\n        \\n        // for(int i=0; i<n; i++){\\n        //     for(int j=0; j<26; j++){\\n        //         cout << hash[i][j] << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n        \\n        vector<bool> ans;\\n        \\n        for(int i=0; i<q.size(); i++){\\n            \\n           if(isPalindrome(hash, q[i]))\\n               ans.push_back(true);\\n            else\\n                ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPalindrome(string& s, vector<int>& q){\\n        \\n        int l = q[0], r = q[1];\\n        int cnt = 0;\\n        \\n        while(l<r){\\n            if(s[l++] != s[r--]) cnt++;\\n            if(cnt > q[2]) return false;\\n        }\\n        \\n        return true;\\n    }\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q) {\\n        \\n        vector<bool> ans;\\n        \\n        for(int i=0; i<q.size(); i++){\\n            \\n            if(isPalindrome(s, q[i]))\\n                ans.push_back(true);\\n            else\\n                ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n```\n```\\nbool isPalindrome(vector<vector<int>>& hash,  vector<int>& q){\\n        \\n        int l=q[0], r=q[1];\\n        int cnt = 0;\\n        \\n        for(int i=0; i<26; i++){\\n            \\n            int freq = hash[r][i] - (l>0 ? hash[l-1][i] : 0);\\n            if(freq&1) cnt++;\\n        }\\n        \\n        return (cnt%2==0 and cnt/2<=q[2]) or (cnt%2!=0 and (cnt-1)/2<=q[2]);\\n    }\\n    \\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& q){\\n        \\n        int n = s.size();\\n        \\n        vector<vector<int>> hash(n, vector<int>(26, 0));\\n        \\n        hash[0][s[0]-\\'a\\']++;\\n        \\n        for(int i=1; i<n; i++){\\n            hash[i] = hash[i-1];\\n            hash[i][s[i] - \\'a\\']++;\\n        }\\n        \\n        // for(int i=0; i<n; i++){\\n        //     for(int j=0; j<26; j++){\\n        //         cout << hash[i][j] << \" \";\\n        //     }\\n        //     cout << endl;\\n        // }\\n        \\n        vector<bool> ans;\\n        \\n        for(int i=0; i<q.size(); i++){\\n            \\n           if(isPalindrome(hash, q[i]))\\n               ans.push_back(true);\\n            else\\n                ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2304506,
                "title": "python-hashmap-prefix-with-notes-not-very-optimized-though",
                "content": "```\\n/*\\n    for every query, \\n    if we have a map storing the counts of each letter, we can figure out whether \\n    we can form a palindrom or not. \\n    To a string to be a palindrome, there can be utmost one character with odd frequency\\n    rest all characters in the substring needs to have even count.\\n    Now, one operation can reduce the number of odd count characters in a substring by 2\\n*/\\n```\\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        hash_map = {s[0]: 1}\\n        x = hash_map\\n        prefix = [hash_map]\\n        for i in range(1, len(s)):\\n            x = x.copy()\\n            x[s[i]] = x.get(s[i], 0) + 1\\n            prefix.append(x)\\n            \\n        result = []\\n        for query in queries:\\n            cnt = 0\\n            for key, value in prefix[query[1]].items():\\n                if query[0] > 0:\\n                    x = value - prefix[query[0]-1].get(key, 0)\\n                else:\\n                    x = value\\n                if x % 2:\\n                    cnt+=1\\n            if cnt - 2 * query[2] > 1:\\n                result.append(False)\\n            else:\\n                result.append(True)\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n/*\\n    for every query, \\n    if we have a map storing the counts of each letter, we can figure out whether \\n    we can form a palindrom or not. \\n    To a string to be a palindrome, there can be utmost one character with odd frequency\\n    rest all characters in the substring needs to have even count.\\n    Now, one operation can reduce the number of odd count characters in a substring by 2\\n*/\\n```\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        hash_map = {s[0]: 1}\\n        x = hash_map\\n        prefix = [hash_map]\\n        for i in range(1, len(s)):\\n            x = x.copy()\\n            x[s[i]] = x.get(s[i], 0) + 1\\n            prefix.append(x)\\n            \\n        result = []\\n        for query in queries:\\n            cnt = 0\\n            for key, value in prefix[query[1]].items():\\n                if query[0] > 0:\\n                    x = value - prefix[query[0]-1].get(key, 0)\\n                else:\\n                    x = value\\n                if x % 2:\\n                    cnt+=1\\n            if cnt - 2 * query[2] > 1:\\n                result.append(False)\\n            else:\\n                result.append(True)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281921,
                "title": "python-prefix-sum-using-bit-manipulations",
                "content": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        \\n        freqs = [ 1 << 26 - 1 ] # parity of the frequencies\\n        \\n        for w in s:\\n            p = ord(w) - ord(\\'a\\') # position to toggle\\n            freqs.append(freqs[-1]^(1 << p))\\n\\n        res = []\\n        \\n        for l,r,k in queries:\\n            count = (freqs[r+1]^freqs[l]).bit_count() # count odd freqs\\n            res.append( k >= (count // 2) )\\n       \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        \\n        freqs = [ 1 << 26 - 1 ] # parity of the frequencies\\n        \\n        for w in s:\\n            p = ord(w) - ord(\\'a\\') # position to toggle\\n            freqs.append(freqs[-1]^(1 << p))\\n\\n        res = []\\n        \\n        for l,r,k in queries:\\n            count = (freqs[r+1]^freqs[l]).bit_count() # count odd freqs\\n            res.append( k >= (count // 2) )\\n       \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281486,
                "title": "python-sol-explained-well-easy-to-understand-fast",
                "content": "# EXPLANATION\\n```\\nTHE PROBLEM SAY TO FIND IF WE CAN MAKE A SUBSTRING PALINDROME GIVEN \\n1. WE CAN REARRANGE THE SUBSTRING \\n2. WE CAN CHANGE AT MOST K CHARACTERS\\n\\nNow to think of the brute force :\\n1. Find the count of each character in substring\\n2. find the no of characters whose no of occurence / count is odd : say x\\n3. check if we can use k transformation to make the x elements palindrome\\n\\nNow for odd size subsequence the value of x will always be odd \\nAs we are removing characters that are in pair or we can say we are doind -2 from total size\\n\\nAnd for even size subsequence we have x as even\\n\\nso now we have x element and all of them are different and to make it palindrom we need to\\nconvert exactly x // 2 no of elements.\\n( why x//2 : in case of odd : \"abc\" if we convert c into a we make the string palindrome as b is fixed )\\n\\nso if k <= x // 2 we can make our string palindrome\\n\\n\\nNow , finding the count everytime may be problamatic so here is the optimization :\\n\\nPREFIX SUM \\nexample : \\n\" abcda\"\\nat index = 0: we have { a: 1 }\\nat index = 1: we have { a: 1 , b: 1}\\nat index = 2: we have { a: 1 , b: 1 ,c: 1 }\\nat index = 3: we have { a: 1 , b: 1 ,c: 1, d: 1 }\\nat index = 4: we have { a: 2 , b: 1 ,c: 1, d: 1 }\\n\\nso say if our substring is from index  = 1 to index  = 4\\n\\nSo we can substract the count at index = 0 from index = 4 to get the count of characters\\nbetween index 1 and 4 inclusively\\n\\nwhich is { a: 1 , b: 1 , c: 1 , d: 1 } \\nnow these items are not having any pair \\nso x = 4 \\nlets say k = 2\\nso we can convert only 2 characters and we need to convert x// 2 = 2 characters\\nhence we return True\\n```\\n\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        n = len(s)\\n        d = defaultdict(int)\\n        count = [None]*n\\n        for i in range(n):\\n            d[s[i]] += 1\\n            count[i] = d.copy()\\n        def check(start,end,k):\\n            prev = defaultdict(int) if start == 0 else count[start-1]\\n            left = 0\\n            for i in range(26):\\n                diff = (count[end][chr(i+97)] - prev[chr(i+97)]) % 2\\n                if diff == 1: left += 1\\n            left = left // 2\\n            return left <= k\\n        ans = []\\n        for start,end,k in queries:\\n            ans.append(check(start,end,k))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nTHE PROBLEM SAY TO FIND IF WE CAN MAKE A SUBSTRING PALINDROME GIVEN \\n1. WE CAN REARRANGE THE SUBSTRING \\n2. WE CAN CHANGE AT MOST K CHARACTERS\\n\\nNow to think of the brute force :\\n1. Find the count of each character in substring\\n2. find the no of characters whose no of occurence / count is odd : say x\\n3. check if we can use k transformation to make the x elements palindrome\\n\\nNow for odd size subsequence the value of x will always be odd \\nAs we are removing characters that are in pair or we can say we are doind -2 from total size\\n\\nAnd for even size subsequence we have x as even\\n\\nso now we have x element and all of them are different and to make it palindrom we need to\\nconvert exactly x // 2 no of elements.\\n( why x//2 : in case of odd : \"abc\" if we convert c into a we make the string palindrome as b is fixed )\\n\\nso if k <= x // 2 we can make our string palindrome\\n\\n\\nNow , finding the count everytime may be problamatic so here is the optimization :\\n\\nPREFIX SUM \\nexample : \\n\" abcda\"\\nat index = 0: we have { a: 1 }\\nat index = 1: we have { a: 1 , b: 1}\\nat index = 2: we have { a: 1 , b: 1 ,c: 1 }\\nat index = 3: we have { a: 1 , b: 1 ,c: 1, d: 1 }\\nat index = 4: we have { a: 2 , b: 1 ,c: 1, d: 1 }\\n\\nso say if our substring is from index  = 1 to index  = 4\\n\\nSo we can substract the count at index = 0 from index = 4 to get the count of characters\\nbetween index 1 and 4 inclusively\\n\\nwhich is { a: 1 , b: 1 , c: 1 , d: 1 } \\nnow these items are not having any pair \\nso x = 4 \\nlets say k = 2\\nso we can convert only 2 characters and we need to convert x// 2 = 2 characters\\nhence we return True\\n```\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        n = len(s)\\n        d = defaultdict(int)\\n        count = [None]*n\\n        for i in range(n):\\n            d[s[i]] += 1\\n            count[i] = d.copy()\\n        def check(start,end,k):\\n            prev = defaultdict(int) if start == 0 else count[start-1]\\n            left = 0\\n            for i in range(26):\\n                diff = (count[end][chr(i+97)] - prev[chr(i+97)]) % 2\\n                if diff == 1: left += 1\\n            left = left // 2\\n            return left <= k\\n        ans = []\\n        for start,end,k in queries:\\n            ans.append(check(start,end,k))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2225624,
                "title": "rust-solution-using-prefix-sum",
                "content": "```\\nimpl Solution {\\n    pub fn can_make_pali_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<bool> {\\n        let s = s.chars().map(|v| (v as u8 - \\'a\\' as u8) as usize).collect::<Vec<usize>>();\\n        let n = s.len();\\n        let mut memo = vec![vec![0;26];n+1];\\n\\n        for i in 0..n {\\n            memo[i+1] = memo[i].clone();\\n            memo[i+1][s[i]] += 1;\\n        }\\n\\n        let q = queries.len();\\n        let mut result = vec![false;q];\\n        for i in 0..q {\\n            let l = queries[i][0] as usize;\\n            let r = queries[i][1] as usize;\\n            let c = queries[i][2] as usize;\\n\\n            let mut odd = 0;\\n            for j in 0..26 {\\n                odd += (memo[r+1][j] - memo[l][j]) % 2;\\n            }\\n            odd += odd % 2;\\n\\n            let padding = (r - l + 1) % 2; \\n            result[i] = (odd / 2) <= (c + padding);\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_make_pali_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<bool> {\\n        let s = s.chars().map(|v| (v as u8 - \\'a\\' as u8) as usize).collect::<Vec<usize>>();\\n        let n = s.len();\\n        let mut memo = vec![vec![0;26];n+1];\\n\\n        for i in 0..n {\\n            memo[i+1] = memo[i].clone();\\n            memo[i+1][s[i]] += 1;\\n        }\\n\\n        let q = queries.len();\\n        let mut result = vec![false;q];\\n        for i in 0..q {\\n            let l = queries[i][0] as usize;\\n            let r = queries[i][1] as usize;\\n            let c = queries[i][2] as usize;\\n\\n            let mut odd = 0;\\n            for j in 0..26 {\\n                odd += (memo[r+1][j] - memo[l][j]) % 2;\\n            }\\n            odd += odd % 2;\\n\\n            let padding = (r - l + 1) % 2; \\n            result[i] = (odd / 2) <= (c + padding);\\n        }\\n\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2219701,
                "title": "golang-prefix-sum-solution",
                "content": "```\\nfunc canMakePaliQueries(s string, queries [][]int) []bool {\\n    n := len(queries)\\n    ans := make([]bool, n)\\n    \\n    prefix := make([][]int, 26)\\n    for row := range prefix {\\n        prefix[row] = make([]int, len(s)+1)\\n\\n        for i := 1; i <= len(s); i++ {\\n            if s[i-1] == string(\\'a\\'+row)[0] {\\n                prefix[row][i] = prefix[row][i-1] + 1\\n            } else {\\n                prefix[row][i] = prefix[row][i-1]\\n            }\\n        }\\n    }\\n\\n    for i := 0; i < n; i++ {\\n        l, r := queries[i][0], queries[i][1]\\n\\n        odds := 0\\n        for i := 0; i < 26; i++ {\\n            if (prefix[i][r+1] - prefix[i][l]) % 2 == 1 {\\n                odds += 1\\n            }\\n        }\\n\\n        if odds / 2 <= queries[i][2] {\\n            ans[i] = true\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nfunc canMakePaliQueries(s string, queries [][]int) []bool {\\n    n := len(queries)\\n    ans := make([]bool, n)\\n    \\n    prefix := make([][]int, 26)\\n    for row := range prefix {\\n        prefix[row] = make([]int, len(s)+1)\\n\\n        for i := 1; i <= len(s); i++ {\\n            if s[i-1] == string(\\'a\\'+row)[0] {\\n                prefix[row][i] = prefix[row][i-1] + 1\\n            } else {\\n                prefix[row][i] = prefix[row][i-1]\\n            }\\n        }\\n    }\\n\\n    for i := 0; i < n; i++ {\\n        l, r := queries[i][0], queries[i][1]\\n\\n        odds := 0\\n        for i := 0; i < 26; i++ {\\n            if (prefix[i][r+1] - prefix[i][l]) % 2 == 1 {\\n                odds += 1\\n            }\\n        }\\n\\n        if odds / 2 <= queries[i][2] {\\n            ans[i] = true\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2215115,
                "title": "python-simple-prefix-sum",
                "content": "\\n    def canMakePaliQueries(self, s, queries):\\n        ans = [0]*len(s)\\n        \\n        ans[0] = 1<<(ord(s[0]) - ord(\"a\"))\\n        \\n        for i in range(1,len(s)):\\n            ans[i] = ans[i-1]^(1<<(ord(s[i]) - ord(\"a\")))\\n            \\n        result = []\\n        \\n        for i, j, k in queries:\\n            mask = ans[j]^(ans[i-1] if i >= 1 else 0)\\n            \\n            if mask.bit_count()//2 <= k:\\n                result.append(True)\\n            else:\\n                result.append(False)\\n            \\n        return result",
                "solutionTags": [],
                "code": "\\n    def canMakePaliQueries(self, s, queries):\\n        ans = [0]*len(s)\\n        \\n        ans[0] = 1<<(ord(s[0]) - ord(\"a\"))\\n        \\n        for i in range(1,len(s)):\\n            ans[i] = ans[i-1]^(1<<(ord(s[i]) - ord(\"a\")))\\n            \\n        result = []\\n        \\n        for i, j, k in queries:\\n            mask = ans[j]^(ans[i-1] if i >= 1 else 0)\\n            \\n            if mask.bit_count()//2 <= k:\\n                result.append(True)\\n            else:\\n                result.append(False)\\n            \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2157681,
                "title": "c-using-prefix-sum",
                "content": "class Solution\\n{\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>> &queries)\\n    {\\n        int n = s.size();\\n        vector<bool> ans;\\n        //         pefix sum array\\n        vector<vector<int>> V;\\n        vector<int> temp(26, 0);\\n        char tt = \\'a\\';\\n        for (auto it : s)\\n        {\\n            temp[it - tt] += 1;\\n            V.push_back(temp);\\n        }\\n\\n        for (int p = 0; p < queries.size(); p++)\\n        {\\n\\n            int aa = queries[p][0];\\n            int bb = queries[p][1];\\n            int k = queries[p][2];\\n            vector<int> v(26);\\n\\n            if (aa > 0)\\n            {\\n                for (int i = 0; i < 26; i++)\\n                {\\n                    v[i] = V[bb][i];\\n                    v[i] = v[i] - V[aa - 1][i];\\n                }\\n            }\\n            else\\n            {\\n                for (int i = 0; i < 26; i++)\\n                {\\n\\n                    v[i] = V[bb][i];\\n                }\\n            }\\n\\n            int length = (bb - aa) + 1;\\n            // check if we make palindrome when length is even\\n            if (length % 2 == 0)\\n            {\\n                int count = 0;\\n                for (int i = 0; i <= 25; i++)\\n                {\\n\\n                    if (v[i] % 2 != 0)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                count = count / 2;\\n\\n                if (k >= count)\\n                {\\n                    ans.push_back(true);\\n                }\\n                else\\n                {\\n                    ans.push_back(false);\\n                }\\n            }\\n            else\\n            {\\n\\n                // check if we make palindrome when length is even\\n                int count = 0;\\n                for (int i = 0; i <= 25; i++)\\n                {\\n                    if (v[i] % 2 != 0)\\n                    {\\n                        count++;\\n                    }\\n                }\\n\\n                count = count / 2;\\n\\n                if (k >= (count))\\n                {\\n                    ans.push_back(true);\\n                }\\n                else\\n                {\\n                    ans.push_back(false);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution\\n{\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>> &queries)\\n    {\\n        int n = s.size();\\n        vector<bool> ans;\\n        //         pefix sum array\\n        vector<vector<int>> V;\\n        vector<int> temp(26, 0);\\n        char tt = \\'a\\';\\n        for (auto it : s)\\n        {\\n            temp[it - tt] += 1;\\n            V.push_back(temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2151705,
                "title": "c-solution-based-on-letter-counting-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        int n = s.size();\\n        vector<vector<int>> prefix_letter_count(26, vector<int>(n, 0));\\n        prefix_letter_count[s[0] - \\'a\\'][0] = 1;\\n        for (int i = 1; i < n; i++){\\n            int current_letter = s[i] - \\'a\\';\\n            for (int letter = 0; letter < 26; letter++){\\n                prefix_letter_count[letter][i] = prefix_letter_count[letter][i - 1];\\n                if (letter == current_letter){\\n                    prefix_letter_count[letter][i]++;\\n                }\\n            }\\n        }\\n        vector<bool> result(queries.size());\\n        int region_letter_count[26] = {0};\\n        for (int i = 0; i < queries.size(); i++){\\n            int start = queries[i][0], back = queries[i][1], k = queries[i][2];\\n            int size = back - start + 1;\\n            if (k >= size / 2){\\n                result[i] = true;\\n                continue;\\n            }\\n            // check the [start, back] in s\\n            memset(region_letter_count, 0, sizeof(region_letter_count));\\n            if (start == 0){\\n                for (int letter = 0; letter < 26; letter++){\\n                    region_letter_count[letter] = prefix_letter_count[letter][back];\\n                }\\n            }\\n            else{\\n                for (int letter = 0; letter < 26; letter++){\\n                    region_letter_count[letter] = prefix_letter_count[letter][back] - prefix_letter_count[letter][start - 1];\\n                }\\n            }\\n            // check whether the region_letter_count is satisfied:\\n            size = 0;\\n            for (int letter = 0; letter < 26; letter++){\\n                if (region_letter_count[letter] % 2 == 1){\\n                    size++;\\n                }\\n            }\\n            if (k >= size / 2){result[i] = true;}\\n            else{result[i] = false;}\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        int n = s.size();\\n        vector<vector<int>> prefix_letter_count(26, vector<int>(n, 0));\\n        prefix_letter_count[s[0] - \\'a\\'][0] = 1;\\n        for (int i = 1; i < n; i++){\\n            int current_letter = s[i] - \\'a\\';\\n            for (int letter = 0; letter < 26; letter++){\\n                prefix_letter_count[letter][i] = prefix_letter_count[letter][i - 1];\\n                if (letter == current_letter){\\n                    prefix_letter_count[letter][i]++;\\n                }\\n            }\\n        }\\n        vector<bool> result(queries.size());\\n        int region_letter_count[26] = {0};\\n        for (int i = 0; i < queries.size(); i++){\\n            int start = queries[i][0], back = queries[i][1], k = queries[i][2];\\n            int size = back - start + 1;\\n            if (k >= size / 2){\\n                result[i] = true;\\n                continue;\\n            }\\n            // check the [start, back] in s\\n            memset(region_letter_count, 0, sizeof(region_letter_count));\\n            if (start == 0){\\n                for (int letter = 0; letter < 26; letter++){\\n                    region_letter_count[letter] = prefix_letter_count[letter][back];\\n                }\\n            }\\n            else{\\n                for (int letter = 0; letter < 26; letter++){\\n                    region_letter_count[letter] = prefix_letter_count[letter][back] - prefix_letter_count[letter][start - 1];\\n                }\\n            }\\n            // check whether the region_letter_count is satisfied:\\n            size = 0;\\n            for (int letter = 0; letter < 26; letter++){\\n                if (region_letter_count[letter] % 2 == 1){\\n                    size++;\\n                }\\n            }\\n            if (k >= size / 2){result[i] = true;}\\n            else{result[i] = false;}\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146120,
                "title": "python-tc-o-n-m-prefix-xor-and-bitmask-beat-96",
                "content": "It\\'s very simple. If you have any question or need explanation, please give comments down below\\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        n = len(s)\\n        prefix_xor = [0]*n\\n        \\n        prefix_xor[0] ^= 1<<(ord(s[0]) - ord(\\'a\\'))\\n        for i in range(1, n):\\n            prefix_xor[i] = prefix_xor[i-1] ^ (1 << (ord(s[i]) - ord(\\'a\\')))\\n        \\n        ans = []\\n        for i, j, k in queries:\\n            mask = prefix_xor[j] ^ (prefix_xor[i-1] if i >= 1 else 0)\\n            if mask.bit_count()//2 <= k:\\n                ans.append(True)\\n            else:\\n                ans.append(False)\\n        return ans",
                "solutionTags": [],
                "code": "It\\'s very simple. If you have any question or need explanation, please give comments down below\\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        n = len(s)\\n        prefix_xor = [0]*n\\n        \\n        prefix_xor[0] ^= 1<<(ord(s[0]) - ord(\\'a\\'))\\n        for i in range(1, n):\\n            prefix_xor[i] = prefix_xor[i-1] ^ (1 << (ord(s[i]) - ord(\\'a\\')))\\n        \\n        ans = []\\n        for i, j, k in queries:\\n            mask = prefix_xor[j] ^ (prefix_xor[i-1] if i >= 1 else 0)\\n            if mask.bit_count()//2 <= k:\\n                ans.append(True)\\n            else:\\n                ans.append(False)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2106115,
                "title": "js-solution-bit-masking",
                "content": "```\\nconst getBitCount = (n) => {\\n    let cnt = 0;\\n    while(n > 0) {\\n        cnt += n & 1;\\n        n >>= 1;\\n    }\\n    return cnt;\\n}\\n\\nvar canMakePaliQueries = function(s, queries) {\\n    const masks = [0], base = \\'a\\'.charCodeAt(0);\\n    let mask = 0;\\n    for(let c of s) {\\n        mask ^= (1 << (c.charCodeAt(0) - base));\\n        masks.push(mask);\\n    }\\n    return queries.map(([l, r, k]) => {\\n        const cnt = getBitCount(masks[l] ^ masks[r+1]);\\n        return cnt - 1 <= 2 * k\\n    });\\n};\\n```\\nI haven\\'t came up with this implementation but I\\'m still putting my answer. \\nI really liked this question.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getBitCount = (n) => {\\n    let cnt = 0;\\n    while(n > 0) {\\n        cnt += n & 1;\\n        n >>= 1;\\n    }\\n    return cnt;\\n}\\n\\nvar canMakePaliQueries = function(s, queries) {\\n    const masks = [0], base = \\'a\\'.charCodeAt(0);\\n    let mask = 0;\\n    for(let c of s) {\\n        mask ^= (1 << (c.charCodeAt(0) - base));\\n        masks.push(mask);\\n    }\\n    return queries.map(([l, r, k]) => {\\n        const cnt = getBitCount(masks[l] ^ masks[r+1]);\\n        return cnt - 1 <= 2 * k\\n    });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2089150,
                "title": "javascript-solution-100-100",
                "content": "<img src=\"https://assets.leetcode.com/users/images/668f9537-9011-49f9-b043-c494aeec19f0_1653871537.3050041.png\" width=\"640\" />\\n\\n```\\nfunction canMakePaliQueries(s, queries) => {\\n    const f = new Array(s.length + 1)\\n\\n    for (let i = 1; i <= s.length; i++) {\\n        f[i] = f[i - 1] ^ (1 << s.charCodeAt(i - 1) - 97)\\n    }\\n\\n    return queries.map(([a, b, k]) => {\\n        if (k >= 13) return true\\n\\n        let n = f[b + 1] ^ f[a], m = 0\\n\\n        while (n > 0) {\\n            m += n & 1\\n            n >>= 1\\n        }\\n\\n        return Math.floor(m / 2) <= k\\n    })\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction canMakePaliQueries(s, queries) => {\\n    const f = new Array(s.length + 1)\\n\\n    for (let i = 1; i <= s.length; i++) {\\n        f[i] = f[i - 1] ^ (1 << s.charCodeAt(i - 1) - 97)\\n    }\\n\\n    return queries.map(([a, b, k]) => {\\n        if (k >= 13) return true\\n\\n        let n = f[b + 1] ^ f[a], m = 0\\n\\n        while (n > 0) {\\n            m += n & 1\\n            n >>= 1\\n        }\\n\\n        return Math.floor(m / 2) <= k\\n    })\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2001521,
                "title": "javascript-o-n-q-n-26q-space-o-n-26n-parity-of-prefix",
                "content": "```\\nvar canMakePaliQueries = function(s, queries) {\\n  const base = \"a\".codePointAt(0);\\n  const sub_freq = new Array(s.length);\\n  let last = new Array(26).fill(0);\\n  sub_freq[-1] = last;\\n  for( let i = 0; i < s.length; i++ ) {\\n    sub_freq[i] = Array.from(last);\\n    sub_freq[i][s[i].codePointAt(0) - base] ^= 1;\\n    last = sub_freq[i];\\n  }\\n  //console.log(sub_freq);\\n  const results = queries.map(([left, right, k]) => {\\n    let oddCount = 0;\\n    for( let i = 0; i < 26; i++ ) {\\n      oddCount += sub_freq[right][i] ^ sub_freq[left-1][i];\\n    }\\n    //console.log(oddCount);\\n    //console.log(s, left, right, freq);\\n    const oddLength = ((right - left) + 1) % 2;\\n    return (oddCount - oddLength) <= 2*k;  \\n  });\\n  return results;\\n};\\n```\\n\\nThe reason for the `2*k` factor is that each change to the string can optimally fix two odd frequency counts: increasing an odd count to an even count (to create a palindrome), and (to keep the substring the same length) decreasing another odd count to an even count. \\n\\nAs long as you have even frequencies of characters you can rearrange them into a palindrome. So the mismatch between such a string and one which can be rearranged into a palindrome, is the number of odd frequency counts in the original string (ignoring the case of the odd-length palindrome, which involves subtracting 1 from the count of odds as it will be in the center and not contribute to the mismatch). You can then fix two odd frequency counts for each substitution, and so as long as you can count the frequencies of the characters (or at least their parity), you can determine if the changes can make it into a palindrome.\\n\\nThis was a very mathematical / number theory like question! :P ;) xxx ;p",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canMakePaliQueries = function(s, queries) {\\n  const base = \"a\".codePointAt(0);\\n  const sub_freq = new Array(s.length);\\n  let last = new Array(26).fill(0);\\n  sub_freq[-1] = last;\\n  for( let i = 0; i < s.length; i++ ) {\\n    sub_freq[i] = Array.from(last);\\n    sub_freq[i][s[i].codePointAt(0) - base] ^= 1;\\n    last = sub_freq[i];\\n  }\\n  //console.log(sub_freq);\\n  const results = queries.map(([left, right, k]) => {\\n    let oddCount = 0;\\n    for( let i = 0; i < 26; i++ ) {\\n      oddCount += sub_freq[right][i] ^ sub_freq[left-1][i];\\n    }\\n    //console.log(oddCount);\\n    //console.log(s, left, right, freq);\\n    const oddLength = ((right - left) + 1) % 2;\\n    return (oddCount - oddLength) <= 2*k;  \\n  });\\n  return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946497,
                "title": "accumulated-frequencies-of-letters-78-speed",
                "content": "![image](https://assets.leetcode.com/users/images/908eb202-e85e-4181-8b83-492c446637f8_1649940893.863777.png)\\n```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        len_s = len(s)\\n        freq = [defaultdict(int)] * len_s\\n        freq[0][s[0]] += 1\\n        for i in range(1, len_s):\\n            freq[i] = freq[i - 1].copy()\\n            freq[i][s[i]] += 1\\n        ans = [True] * len(queries)\\n        for i, (left, right, k) in enumerate(queries):\\n            left1 = left - 1\\n            n_odd = sum((n - (freq[left1][c] if left1 > -1 else 0)) % 2\\n                        for c, n in freq[right].items())\\n            ans[i] = n_odd - 2 * k <= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        len_s = len(s)\\n        freq = [defaultdict(int)] * len_s\\n        freq[0][s[0]] += 1\\n        for i in range(1, len_s):\\n            freq[i] = freq[i - 1].copy()\\n            freq[i][s[i]] += 1\\n        ans = [True] * len(queries)\\n        for i, (left, right, k) in enumerate(queries):\\n            left1 = left - 1\\n            n_odd = sum((n - (freq[left1][c] if left1 > -1 else 0)) % 2\\n                        for c, n in freq[right].items())\\n            ans[i] = n_odd - 2 * k <= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1925470,
                "title": "c-easy-solution-using-prefix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.length();\\n        vector<vector<int>> v(n,vector<int>(26));\\n        v[0][s[0]-\\'a\\']++;\\n        for(int i=1;i<n;i++){\\n            v[i][s[i]-\\'a\\']++;\\n            for(int j=0;j<26;j++) v[i][j] += v[i-1][j];\\n        }\\n        vector<bool> ans;\\n        for(auto q:queries){\\n            int l = q[0], r = q[1], k = q[2];\\n            int odd = 0;\\n            for(int i=0;i<26;i++){\\n                int cnt = v[r][i];\\n                if(l>0) cnt -= v[l-1][i];\\n                if(cnt%2) odd++;\\n            }\\n            if(k>=(odd/2)) ans.push_back(true);\\n            else ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.length();\\n        vector<vector<int>> v(n,vector<int>(26));\\n        v[0][s[0]-\\'a\\']++;\\n        for(int i=1;i<n;i++){\\n            v[i][s[i]-\\'a\\']++;\\n            for(int j=0;j<26;j++) v[i][j] += v[i-1][j];\\n        }\\n        vector<bool> ans;\\n        for(auto q:queries){\\n            int l = q[0], r = q[1], k = q[2];\\n            int odd = 0;\\n            for(int i=0;i<26;i++){\\n                int cnt = v[r][i];\\n                if(l>0) cnt -= v[l-1][i];\\n                if(cnt%2) odd++;\\n            }\\n            if(k>=(odd/2)) ans.push_back(true);\\n            else ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899013,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        freq_array = [self.convertStringToArrayFreq(s[0])]\\n        \\n        for i in range(1, len(s)):\\n            prev_freq = freq_array[i-1].copy()\\n            prev_freq[ord(s[i]) - 97] += 1\\n            freq_array.append(prev_freq)\\n          \\n        res = []\\n        for left, right, num in queries:\\n            if left - 1 < 0: \\n                substring_freq = freq_array[right]\\n            else:\\n                substring_freq = self.getFreq(freq_array[left-1], freq_array[right])\\n            numOdd = self.getNumberOfOddFrequencies(substring_freq)\\n            res.append(numOdd//2 <= num)\\n        \\n        return res\\n    \\n    def getFreq(self, start, end):\\n        ar = [0] * 26\\n        for i in range(0, len(ar)):\\n            ar[i] = end[i] - start[i]\\n        return ar\\n            \\n    def convertStringToArrayFreq(self, word):\\n        ar = [0]*26\\n        for letter in word:\\n            ar[ord(letter) - 97] += 1\\n        return ar\\n    \\n    def getNumberOfOddFrequencies(self, count):\\n        res = 0\\n        for key, value in enumerate(count):\\n            res += value % 2\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        freq_array = [self.convertStringToArrayFreq(s[0])]\\n        \\n        for i in range(1, len(s)):\\n            prev_freq = freq_array[i-1].copy()\\n            prev_freq[ord(s[i]) - 97] += 1\\n            freq_array.append(prev_freq)\\n          \\n        res = []\\n        for left, right, num in queries:\\n            if left - 1 < 0: \\n                substring_freq = freq_array[right]\\n            else:\\n                substring_freq = self.getFreq(freq_array[left-1], freq_array[right])\\n            numOdd = self.getNumberOfOddFrequencies(substring_freq)\\n            res.append(numOdd//2 <= num)\\n        \\n        return res\\n    \\n    def getFreq(self, start, end):\\n        ar = [0] * 26\\n        for i in range(0, len(ar)):\\n            ar[i] = end[i] - start[i]\\n        return ar\\n            \\n    def convertStringToArrayFreq(self, word):\\n        ar = [0]*26\\n        for letter in word:\\n            ar[ord(letter) - 97] += 1\\n        return ar\\n    \\n    def getNumberOfOddFrequencies(self, count):\\n        res = 0\\n        for key, value in enumerate(count):\\n            res += value % 2\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1875504,
                "title": "java-solution-with-comments",
                "content": "```\\nclass Solution {\\n  // Array of arrays where each location is the histogram\\n  // of characters up to and inculding that location.\\n  int hist[][];\\n  \\n  public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n    hist = new int[s.length()][26];\\n    for (int i = 0; i < s.length(); i++) {\\n      Arrays.fill(hist[i], 0);\\n      if (i > 0) {\\n        for (int j = 0; j < 26; j++) {\\n          hist[i][j] = hist[i-1][j];\\n        }\\n      }\\n      hist[i][s.charAt(i) - \\'a\\']++;\\n    }\\n    \\n    List<Boolean> list = new ArrayList();\\n    for (int i = 0; i < queries.length; i++) {\\n      int entry[] = queries[i];\\n      boolean can = canMakePali(s, entry[0], entry[1], entry[2]);\\n      list.add(can);\\n    }\\n    return(list);\\n  }\\n  \\n  private boolean canMakePali(String s, int start, int end, int k) {\\n    if (start == end) {\\n      return(true);\\n    }\\n\\n    int count[] = new int[26];\\n    for (int i = 0; i < 26; i++) {\\n      if (start == 0)\\n        count[i] = hist[end][i];\\n      else\\n        count[i] = hist[end][i] - hist[start-1][i];\\n    }\\n\\n    int numOdd = 0;\\n    for (int i = 0; i < 26; i++) {\\n      if (count[i] % 2 == 1)\\n        numOdd++;\\n    }\\n    if ((end-start) % 2 == 0) {\\n      // Odd length;\\n      if (numOdd == 1) {\\n        // Only one odd set. it will be in the middle. All\\n        // other sets are even, so matching automatically\\n        // already\\n        return(true);\\n      }\\n      else if ((numOdd - 1) <= k*2) {\\n        // Excluding the center, there are less <= 2*k other\\n        // odd sets. we can convert each of them to even\\n        // within k changes. Each change converts 2 odd sets\\n        // into even.\\n        return(true);\\n      }\\n      return(false);\\n    }\\n    else {\\n      // Even length\\n      if (numOdd == 0)\\n        return(true); // Everything is already even.\\n      else if (numOdd <= k*2)\\n        return(true);\\n      else\\n        return(false);\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  // Array of arrays where each location is the histogram\\n  // of characters up to and inculding that location.\\n  int hist[][];\\n  \\n  public List<Boolean> canMakePaliQueries(String s, int[][] queries) {\\n    hist = new int[s.length()][26];\\n    for (int i = 0; i < s.length(); i++) {\\n      Arrays.fill(hist[i], 0);\\n      if (i > 0) {\\n        for (int j = 0; j < 26; j++) {\\n          hist[i][j] = hist[i-1][j];\\n        }\\n      }\\n      hist[i][s.charAt(i) - \\'a\\']++;\\n    }\\n    \\n    List<Boolean> list = new ArrayList();\\n    for (int i = 0; i < queries.length; i++) {\\n      int entry[] = queries[i];\\n      boolean can = canMakePali(s, entry[0], entry[1], entry[2]);\\n      list.add(can);\\n    }\\n    return(list);\\n  }\\n  \\n  private boolean canMakePali(String s, int start, int end, int k) {\\n    if (start == end) {\\n      return(true);\\n    }\\n\\n    int count[] = new int[26];\\n    for (int i = 0; i < 26; i++) {\\n      if (start == 0)\\n        count[i] = hist[end][i];\\n      else\\n        count[i] = hist[end][i] - hist[start-1][i];\\n    }\\n\\n    int numOdd = 0;\\n    for (int i = 0; i < 26; i++) {\\n      if (count[i] % 2 == 1)\\n        numOdd++;\\n    }\\n    if ((end-start) % 2 == 0) {\\n      // Odd length;\\n      if (numOdd == 1) {\\n        // Only one odd set. it will be in the middle. All\\n        // other sets are even, so matching automatically\\n        // already\\n        return(true);\\n      }\\n      else if ((numOdd - 1) <= k*2) {\\n        // Excluding the center, there are less <= 2*k other\\n        // odd sets. we can convert each of them to even\\n        // within k changes. Each change converts 2 odd sets\\n        // into even.\\n        return(true);\\n      }\\n      return(false);\\n    }\\n    else {\\n      // Even length\\n      if (numOdd == 0)\\n        return(true); // Everything is already even.\\n      else if (numOdd <= k*2)\\n        return(true);\\n      else\\n        return(false);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867079,
                "title": "python3-prefix-counter-dp",
                "content": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        arr=[[0 for _ in range(26)]]\\n        for el in s:\\n            new=arr[-1][::]\\n            new[ord(el)-ord(\\'a\\')]^=1\\n            arr.append(new)\\n        res=[]\\n        for start,end,k in queries:\\n            odd=sum((x-y)%2!=0 for x,y in zip(arr[end+1],arr[start]))\\n            res.append(odd//2<=k)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        arr=[[0 for _ in range(26)]]\\n        for el in s:\\n            new=arr[-1][::]\\n            new[ord(el)-ord(\\'a\\')]^=1\\n            arr.append(new)\\n        res=[]\\n        for start,end,k in queries:\\n            odd=sum((x-y)%2!=0 for x,y in zip(arr[end+1],arr[start]))\\n            res.append(odd//2<=k)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841093,
                "title": "python-bit-manipulation-prefix-sum",
                "content": "At the centre of the algorithm, we need to know how to get the number of replacements. So for a string that we can easily rearrange, we only replace the chars that have odd frequencies. If a char has a frequency of 5, we can arrange the 4 to be on the two sides, and keep the one in the centre. In this case, if this is the only character with odd frequency, we can actually just keep it. If not, we need to replace it. Following this idea, we know, if we have `n` characters that have odd frequencies, we need `n // 2` replacements, because we are replacing half of them to another half to match.\\n\\nBased on this idea, we just need to figure out for each query how many characters have odd frequencies. Here we can use a bit map to represent frequency status, if a bit is 1 then it means the related char has odd frequency, 0 means even frequencies. So we can have a prefix frequency array, and by using the same maner of prefix sum, we can easily get the frequency bits for a given range. Using xor can help us get there. \\n\\n```python\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        size = len(s)\\n        frequency = [0] * (size + 1)\\n        for i, char in enumerate(s):\\n            frequency[i+1] = frequency[i] ^ (1 << string.ascii_lowercase.index(s[i]))\\n        num_of_queries = len(queries)\\n        ans = [False] * num_of_queries\\n        def num_of_ones(bits):\\n            count = 0\\n            while bits:\\n                bits &= bits - 1\\n                count += 1\\n            return count\\n        for query, (q_start, q_end, allowed_replaces) in enumerate(queries):\\n            single_bits = frequency[q_end+1] ^ frequency[q_start]\\n            singles = num_of_ones(single_bits)\\n            replacements = singles // 2\\n            ans[query] = replacements <= allowed_replaces\\n        return ans\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```python\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        size = len(s)\\n        frequency = [0] * (size + 1)\\n        for i, char in enumerate(s):\\n            frequency[i+1] = frequency[i] ^ (1 << string.ascii_lowercase.index(s[i]))\\n        num_of_queries = len(queries)\\n        ans = [False] * num_of_queries\\n        def num_of_ones(bits):\\n            count = 0\\n            while bits:\\n                bits &= bits - 1\\n                count += 1\\n            return count\\n        for query, (q_start, q_end, allowed_replaces) in enumerate(queries):\\n            single_bits = frequency[q_end+1] ^ frequency[q_start]\\n            singles = num_of_ones(single_bits)\\n            replacements = singles // 2\\n            ans[query] = replacements <= allowed_replaces\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834416,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> dp;\\n        vector<int> v(26, 0);\\n        int n = s.size();\\n        for(int i = 0; i < n; i++){\\n            char ch = s[i];\\n            v[ch-\\'a\\']++;\\n            dp.push_back(v);\\n        }\\n        vector<bool> ans;\\n        for(auto it : queries){\\n            int start = it[0];\\n            int end = it[1];\\n            int k = it[2];\\n            \\n            \\n            int count = 0;\\n            \\n            for(int i = 0; i < 26; i++){\\n                int val = dp[end][i] - ((start > 0)?dp[start-1][i]:0);\\n                if(val%2 != 0) count++;\\n            }\\n            if(count/2 <= k) ans.push_back(true);\\n            else ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        vector<vector<int>> dp;\\n        vector<int> v(26, 0);\\n        int n = s.size();\\n        for(int i = 0; i < n; i++){\\n            char ch = s[i];\\n            v[ch-\\'a\\']++;\\n            dp.push_back(v);\\n        }\\n        vector<bool> ans;\\n        for(auto it : queries){\\n            int start = it[0];\\n            int end = it[1];\\n            int k = it[2];\\n            \\n            \\n            int count = 0;\\n            \\n            for(int i = 0; i < 26; i++){\\n                int val = dp[end][i] - ((start > 0)?dp[start-1][i]:0);\\n                if(val%2 != 0) count++;\\n            }\\n            if(count/2 <= k) ans.push_back(true);\\n            else ans.push_back(false);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738883,
                "title": "c-1100ms-simple-but-slow",
                "content": "```\\nclass Solution {\\npublic:\\n  vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n    vector<vector<int>>table(s.size(), vector<int>(26,0));\\n    vector<bool>ans;\\n    \\n    table[0][s[0]-\\'a\\']++;\\n    for(int i = 1; i != s.size(); i++){\\n      for(int j = 0; j != 26; j++) table[i][j] = table[i-1][j];\\n      table[i][s[i]-\\'a\\']++;\\n    }\\n      \\n    for(auto &q: queries){\\n      int odd = 2 + (q[2]<<1);\\n      for(int i = 0; i != 26; i++){\\n        int val = table[q[1]][i] - (q[0] ? table[q[0]-1][i] : 0);\\n        if( (val & 1) &&  --odd == 0){ans.push_back(false); goto mark;}\\n      }\\n      \\n      ans.push_back(true);\\n      mark:;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n    vector<vector<int>>table(s.size(), vector<int>(26,0));\\n    vector<bool>ans;\\n    \\n    table[0][s[0]-\\'a\\']++;\\n    for(int i = 1; i != s.size(); i++){\\n      for(int j = 0; j != 26; j++) table[i][j] = table[i-1][j];\\n      table[i][s[i]-\\'a\\']++;\\n    }\\n      \\n    for(auto &q: queries){\\n      int odd = 2 + (q[2]<<1);\\n      for(int i = 0; i != 26; i++){\\n        int val = table[q[1]][i] - (q[0] ? table[q[0]-1][i] : 0);\\n        if( (val & 1) &&  --odd == 0){ans.push_back(false); goto mark;}\\n      }\\n      \\n      ans.push_back(true);\\n      mark:;\\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727667,
                "title": "python3-using-prefix-and-dictionaries",
                "content": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        def helper(i, j):\\n            ans = {}\\n            for key in counter[i]:\\n                diff = counter[i][key] - counter[j][key]\\n                if diff > 0:\\n                    ans[key] = diff\\n                \\n            return ans\\n            \\n        cnt = defaultdict(lambda: 0)\\n        counter = [cnt]\\n        for char in s: \\n            cnt = counter[-1].copy()\\n            cnt[char] += 1 \\n            counter.append(cnt)\\n                \\n        ans = []\\n        for (start, end, k) in queries: \\n            end += 1 \\n            cnt = helper(end, start)\\n            \\n            total = 0 \\n            for key in cnt:\\n                total += cnt[key] % 2\\n                \\n            ans.append(total//2 <= k)\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\\n        def helper(i, j):\\n            ans = {}\\n            for key in counter[i]:\\n                diff = counter[i][key] - counter[j][key]\\n                if diff > 0:\\n                    ans[key] = diff\\n                \\n            return ans\\n            \\n        cnt = defaultdict(lambda: 0)\\n        counter = [cnt]\\n        for char in s: \\n            cnt = counter[-1].copy()\\n            cnt[char] += 1 \\n            counter.append(cnt)\\n                \\n        ans = []\\n        for (start, end, k) in queries: \\n            end += 1 \\n            cnt = helper(end, start)\\n            \\n            total = 0 \\n            for key in cnt:\\n                total += cnt[key] % 2\\n                \\n            ans.append(total//2 <= k)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727282,
                "title": "c-prefix-sums-of-frequency-arrays",
                "content": "**Solution:**\\n\\nThe idea is to have prefix sums of frequencies so that we can quickly answer range queries.\\nSimilar to normal prefix sum we will be able to say what are the character frequencies of any substring.\\nThen just iterate over all queries and see how many frequencies are odd.\\nFor example if odd frequency = 1, it is a palindrome ( \"a\", \"b\", \"aba\").\\nOtherwise it should be less or equal to twice the number of edits we allowed to make in the query.\\nThat is because if, let\\'s say number of odd frequencies = 3 and we make 1 edit we can reduce the number by 2.\\nFor example \"abc\" we can change to \"aba\" by making just one edit.\\nSo each edit reduces number of odd frequences by 2 and odd frequency = 1 is special because it\\'s a palindrome, so we round it down to an even number (odd = odd & ~1)\\n\\n**Code:**\\n```\\ntypedef array<int, 26> A26;    \\nA26 operator-(const A26& a, const A26& b) {\\n    A26 answer{};\\n    for(int i = 0; i < 26; i++) {\\n        answer[i] = a[i] - b[i];\\n    }\\n    return answer;\\n}\\nclass Solution {    \\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        vector<A26> prefs;\\n        A26 curr{};\\n        prefs.emplace_back();\\n        for(char c : s) {\\n            curr[c - \\'a\\']++;\\n            prefs.push_back(curr);\\n        }        \\n        vector<bool> answer;\\n        for(const vector<int>& q : queries) {\\n            A26 freq = prefs[q[1]+1] - prefs[q[0]];\\n            int odd = 0;\\n            for(int i = 0; i < 26; i++) {\\n                if(freq[i] > 0 && freq[i] % 2 != 0) {\\n                    odd++;\\n                }\\n            }\\n            odd = odd & ~1;\\n            answer.push_back(odd <= q[2]*2);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\ntypedef array<int, 26> A26;    \\nA26 operator-(const A26& a, const A26& b) {\\n    A26 answer{};\\n    for(int i = 0; i < 26; i++) {\\n        answer[i] = a[i] - b[i];\\n    }\\n    return answer;\\n}\\nclass Solution {    \\npublic:\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        int n = s.size();\\n        vector<A26> prefs;\\n        A26 curr{};\\n        prefs.emplace_back();\\n        for(char c : s) {\\n            curr[c - \\'a\\']++;\\n            prefs.push_back(curr);\\n        }        \\n        vector<bool> answer;\\n        for(const vector<int>& q : queries) {\\n            A26 freq = prefs[q[1]+1] - prefs[q[0]];\\n            int odd = 0;\\n            for(int i = 0; i < 26; i++) {\\n                if(freq[i] > 0 && freq[i] % 2 != 0) {\\n                    odd++;\\n                }\\n            }\\n            odd = odd & ~1;\\n            answer.push_back(odd <= q[2]*2);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723120,
                "title": "golang-bitops-o-n-detail-explained",
                "content": "We just need to care about number of character in each substring is **Odd** or **Even**. \\n\\nLet\\'s say: we have a set of chars whose occurene is odd. Then to make substring palin, we need to change set_size / 2 char (pick half of set, make other half equal to this half). So in short, we only care about Odd/Even, count the odd.\\n\\nTo optimize memory usage, we could using bits to store odd/even state. Thus, 0 is even, 1 is odd. \\n\\n- +1 occurence means toggle 0->1, 1->0\\n- SetX - SetY = bits_of_X `XOR`  bits_of_Y\\n\\nNow, we just accumulate bits (same as prefix sum) and check the state to count number of bit 1 (number of odd char)\\n\\n```go\\nfunc canMakePaliQueries(s string, queries [][]int) []bool {\\n    states := make([]uint32, len(s))\\n    \\n    var prev uint32\\n    for i := range s {\\n        prev ^= 1 << uint32(s[i] - \\'a\\') // toggle bit\\n        states[i] = prev\\n    }\\n    \\n    ans := make([]bool, len(queries))\\n    for i, q := range queries {\\n        var state uint32\\n        if q[0] == 0 {\\n            state = states[q[1]]\\n        } else {\\n            state = states[q[1]] ^ states[q[0] - 1]\\n        }\\n        \\n        ans[i] = q[2] >= bits.OnesCount32(state) / 2\\n    }\\n    \\n    return ans \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc canMakePaliQueries(s string, queries [][]int) []bool {\\n    states := make([]uint32, len(s))\\n    \\n    var prev uint32\\n    for i := range s {\\n        prev ^= 1 << uint32(s[i] - \\'a\\') // toggle bit\\n        states[i] = prev\\n    }\\n    \\n    ans := make([]bool, len(queries))\\n    for i, q := range queries {\\n        var state uint32\\n        if q[0] == 0 {\\n            state = states[q[1]]\\n        } else {\\n            state = states[q[1]] ^ states[q[0] - 1]\\n        }\\n        \\n        ans[i] = q[2] >= bits.OnesCount32(state) / 2\\n    }\\n    \\n    return ans \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1685804,
                "title": "python3-bit-presum",
                "content": "\\'\\'\\'\\n\\n        dic=defaultdict(list)\\n        n=len(s)\\n        state=0\\n        c=[0]*n\\n        dic[state].append(-1)\\n        for i in range(n):\\n            k=ord(s[i])-ord(\"a\")\\n            state^=1<<k\\n            dic[state].append(i)\\n            c[i]=state\\n            print(bin(state))\\n        res=[]\\n        for a,b,m in queries:\\n            if a==0:\\n                start=0\\n            else:\\n                start=c[a-1]\\n            end=c[b]\\n            sta=start^end\\n            count=0\\n        \\n            for i in range(26):\\n                if sta & 1:\\n                    count+=1\\n                sta = sta>>1\\n               \\n            if count//2<=m:\\n                res.append(True)\\n            else:\\n                res.append(False)\\n        return res\\n            \\n\\'\\'\\'",
                "solutionTags": [
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "\\'\\'\\'\\n\\n        dic=defaultdict(list)\\n        n=len(s)\\n        state=0\\n        c=[0]*n\\n        dic[state].append(-1)\\n        for i in range(n):\\n            k=ord(s[i])-ord(\"a\")\\n            state^=1<<k\\n            dic[state].append(i)\\n            c[i]=state\\n            print(bin(state))\\n        res=[]\\n        for a,b,m in queries:\\n            if a==0:\\n                start=0\\n            else:\\n                start=c[a-1]\\n            end=c[b]\\n            sta=start^end\\n            count=0\\n        \\n            for i in range(26):\\n                if sta & 1:\\n                    count+=1\\n                sta = sta>>1\\n               \\n            if count//2<=m:\\n                res.append(True)\\n            else:\\n                res.append(False)\\n        return res\\n            \\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 1659284,
                "title": "prefix-sum-parity-property-c",
                "content": "```\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        vector<bool> res;\\n        int v[s.size()][26]; memset(v, 0, sizeof(v)); v[0][s.front() - \\'a\\']++;\\n        for(int i = 1 ; i < s.size() ; i++) {\\n            for(int j = 0 ; j < 26 ; j++) v[i][j] = v[i - 1][j];\\n            v[i][s[i] - \\'a\\']++;\\n        }\\n        \\n        for(auto q : queries) {\\n            \\n            int odds = 0;\\n            int l = q[0]; int r = q[1]; int k = q[2];\\n            for(auto c = \\'a\\' ; c <= \\'z\\' ; c++) odds += \\n                (v[r][c - \\'a\\'] - (l == 0? 0 : v[l - 1][c - \\'a\\'])) % 2;\\n            \\n            if(odds > k * 2 + 1) res.push_back(false);\\n            else res.push_back(true);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\\n        \\n        vector<bool> res;\\n        int v[s.size()][26]; memset(v, 0, sizeof(v)); v[0][s.front() - \\'a\\']++;\\n        for(int i = 1 ; i < s.size() ; i++) {\\n            for(int j = 0 ; j < 26 ; j++) v[i][j] = v[i - 1][j];\\n            v[i][s[i] - \\'a\\']++;\\n        }\\n        \\n        for(auto q : queries) {\\n            \\n            int odds = 0;\\n            int l = q[0]; int r = q[1]; int k = q[2];\\n            for(auto c = \\'a\\' ; c <= \\'z\\' ; c++) odds += \\n                (v[r][c - \\'a\\'] - (l == 0? 0 : v[l - 1][c - \\'a\\'])) % 2;\\n            \\n            if(odds > k * 2 + 1) res.push_back(false);\\n            else res.push_back(true);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564893,
                "content": [
                    {
                        "username": "xzj104",
                        "content": "maybe I just didn\\'t understand the question....\\n\\n\\ncan\\'t believe I missed \"rearrange\".....\\n\\nThanks!"
                    },
                    {
                        "username": "saisaket",
                        "content": "hunu [0,3,1] should get a false value right ?, but my testcase is failing even if I get false. leetcode says I need to get true for that. Can someone tell me where am I going wrong\\n"
                    },
                    {
                        "username": "piyush0004",
                        "content": "first rearrange then you have to replace"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "Wait guys :\\nRead the Question again , I know where you are stuck is that you can also rearrange the string"
                    },
                    {
                        "username": "grawlixes",
                        "content": "I submitted a working solution which used a simple DP strategy + a Counter to solve the problem in O(26\\\\*N) time.\\n\\nHowever, that solution got me a big fat TLE due to the overhead of Counter. But, when I submitted a slightly different solution that just used arrays of size 26 to do the exact same thing, it barely passed. Again, the complexity is the same.\\n\\nI know Counter is just a fancier dictionary, so in a practical sense, I maybe should have seen this coming. But if the lower level, less convenient array solution passes, surely the Counter solution also should pass, no? **I believe the largest input should be 10\\\\*\\\\*4, not 10\\\\*\\\\*5 - that will solve this issue.**"
                    },
                    {
                        "username": "adalinge",
                        "content": "how can string \\'hunu\\' be converted to palindrome in one change ? as one of test case returns true"
                    },
                    {
                        "username": "harisht26698",
                        "content": "\"hunu\" can be converted to palindrome with one change of letter and by rearranging \"u\" in the string. that means, it is mentioned we can do any number of rearrangements like \"hunu\" to \"huun\" or \"uhnu\". so these new rearranged string can be converted to palindrome by one change of letter. "
                    },
                    {
                        "username": "amohan93",
                        "content": "\"hunu\"\\n[[1,1,1],[2,3,0],[3,3,1],[0,3,2],[1,3,3],[2,3,1],[3,3,1],[0,3,0],[1,1,1],[2,3,0],[3,3,1],[0,3,1],[1,1,1]]\\n\\nThis is my output versus the expected:\\n\\nOutput: \\n[true,false,true,true,true,true,true,false,true,false,true,false,true]\\n\\nExpected:\\n[true,false,true,true,true,true,true,false,true,false,true,true,true]\\n\\nYou cannot turn \\'hunu\\' into a palindrome with just one letter change\\n\\nExpected:\\n\\n"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "We can rearrange stuff\\n"
                    }
                ]
            },
            {
                "id": 1568220,
                "content": [
                    {
                        "username": "xzj104",
                        "content": "maybe I just didn\\'t understand the question....\\n\\n\\ncan\\'t believe I missed \"rearrange\".....\\n\\nThanks!"
                    },
                    {
                        "username": "saisaket",
                        "content": "hunu [0,3,1] should get a false value right ?, but my testcase is failing even if I get false. leetcode says I need to get true for that. Can someone tell me where am I going wrong\\n"
                    },
                    {
                        "username": "piyush0004",
                        "content": "first rearrange then you have to replace"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "Wait guys :\\nRead the Question again , I know where you are stuck is that you can also rearrange the string"
                    },
                    {
                        "username": "grawlixes",
                        "content": "I submitted a working solution which used a simple DP strategy + a Counter to solve the problem in O(26\\\\*N) time.\\n\\nHowever, that solution got me a big fat TLE due to the overhead of Counter. But, when I submitted a slightly different solution that just used arrays of size 26 to do the exact same thing, it barely passed. Again, the complexity is the same.\\n\\nI know Counter is just a fancier dictionary, so in a practical sense, I maybe should have seen this coming. But if the lower level, less convenient array solution passes, surely the Counter solution also should pass, no? **I believe the largest input should be 10\\\\*\\\\*4, not 10\\\\*\\\\*5 - that will solve this issue.**"
                    },
                    {
                        "username": "adalinge",
                        "content": "how can string \\'hunu\\' be converted to palindrome in one change ? as one of test case returns true"
                    },
                    {
                        "username": "harisht26698",
                        "content": "\"hunu\" can be converted to palindrome with one change of letter and by rearranging \"u\" in the string. that means, it is mentioned we can do any number of rearrangements like \"hunu\" to \"huun\" or \"uhnu\". so these new rearranged string can be converted to palindrome by one change of letter. "
                    },
                    {
                        "username": "amohan93",
                        "content": "\"hunu\"\\n[[1,1,1],[2,3,0],[3,3,1],[0,3,2],[1,3,3],[2,3,1],[3,3,1],[0,3,0],[1,1,1],[2,3,0],[3,3,1],[0,3,1],[1,1,1]]\\n\\nThis is my output versus the expected:\\n\\nOutput: \\n[true,false,true,true,true,true,true,false,true,false,true,false,true]\\n\\nExpected:\\n[true,false,true,true,true,true,true,false,true,false,true,true,true]\\n\\nYou cannot turn \\'hunu\\' into a palindrome with just one letter change\\n\\nExpected:\\n\\n"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "We can rearrange stuff\\n"
                    }
                ]
            },
            {
                "id": 1701982,
                "content": [
                    {
                        "username": "xzj104",
                        "content": "maybe I just didn\\'t understand the question....\\n\\n\\ncan\\'t believe I missed \"rearrange\".....\\n\\nThanks!"
                    },
                    {
                        "username": "saisaket",
                        "content": "hunu [0,3,1] should get a false value right ?, but my testcase is failing even if I get false. leetcode says I need to get true for that. Can someone tell me where am I going wrong\\n"
                    },
                    {
                        "username": "piyush0004",
                        "content": "first rearrange then you have to replace"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "Wait guys :\\nRead the Question again , I know where you are stuck is that you can also rearrange the string"
                    },
                    {
                        "username": "grawlixes",
                        "content": "I submitted a working solution which used a simple DP strategy + a Counter to solve the problem in O(26\\\\*N) time.\\n\\nHowever, that solution got me a big fat TLE due to the overhead of Counter. But, when I submitted a slightly different solution that just used arrays of size 26 to do the exact same thing, it barely passed. Again, the complexity is the same.\\n\\nI know Counter is just a fancier dictionary, so in a practical sense, I maybe should have seen this coming. But if the lower level, less convenient array solution passes, surely the Counter solution also should pass, no? **I believe the largest input should be 10\\\\*\\\\*4, not 10\\\\*\\\\*5 - that will solve this issue.**"
                    },
                    {
                        "username": "adalinge",
                        "content": "how can string \\'hunu\\' be converted to palindrome in one change ? as one of test case returns true"
                    },
                    {
                        "username": "harisht26698",
                        "content": "\"hunu\" can be converted to palindrome with one change of letter and by rearranging \"u\" in the string. that means, it is mentioned we can do any number of rearrangements like \"hunu\" to \"huun\" or \"uhnu\". so these new rearranged string can be converted to palindrome by one change of letter. "
                    },
                    {
                        "username": "amohan93",
                        "content": "\"hunu\"\\n[[1,1,1],[2,3,0],[3,3,1],[0,3,2],[1,3,3],[2,3,1],[3,3,1],[0,3,0],[1,1,1],[2,3,0],[3,3,1],[0,3,1],[1,1,1]]\\n\\nThis is my output versus the expected:\\n\\nOutput: \\n[true,false,true,true,true,true,true,false,true,false,true,false,true]\\n\\nExpected:\\n[true,false,true,true,true,true,true,false,true,false,true,true,true]\\n\\nYou cannot turn \\'hunu\\' into a palindrome with just one letter change\\n\\nExpected:\\n\\n"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "We can rearrange stuff\\n"
                    }
                ]
            },
            {
                "id": 1567408,
                "content": [
                    {
                        "username": "xzj104",
                        "content": "maybe I just didn\\'t understand the question....\\n\\n\\ncan\\'t believe I missed \"rearrange\".....\\n\\nThanks!"
                    },
                    {
                        "username": "saisaket",
                        "content": "hunu [0,3,1] should get a false value right ?, but my testcase is failing even if I get false. leetcode says I need to get true for that. Can someone tell me where am I going wrong\\n"
                    },
                    {
                        "username": "piyush0004",
                        "content": "first rearrange then you have to replace"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "Wait guys :\\nRead the Question again , I know where you are stuck is that you can also rearrange the string"
                    },
                    {
                        "username": "grawlixes",
                        "content": "I submitted a working solution which used a simple DP strategy + a Counter to solve the problem in O(26\\\\*N) time.\\n\\nHowever, that solution got me a big fat TLE due to the overhead of Counter. But, when I submitted a slightly different solution that just used arrays of size 26 to do the exact same thing, it barely passed. Again, the complexity is the same.\\n\\nI know Counter is just a fancier dictionary, so in a practical sense, I maybe should have seen this coming. But if the lower level, less convenient array solution passes, surely the Counter solution also should pass, no? **I believe the largest input should be 10\\\\*\\\\*4, not 10\\\\*\\\\*5 - that will solve this issue.**"
                    },
                    {
                        "username": "adalinge",
                        "content": "how can string \\'hunu\\' be converted to palindrome in one change ? as one of test case returns true"
                    },
                    {
                        "username": "harisht26698",
                        "content": "\"hunu\" can be converted to palindrome with one change of letter and by rearranging \"u\" in the string. that means, it is mentioned we can do any number of rearrangements like \"hunu\" to \"huun\" or \"uhnu\". so these new rearranged string can be converted to palindrome by one change of letter. "
                    },
                    {
                        "username": "amohan93",
                        "content": "\"hunu\"\\n[[1,1,1],[2,3,0],[3,3,1],[0,3,2],[1,3,3],[2,3,1],[3,3,1],[0,3,0],[1,1,1],[2,3,0],[3,3,1],[0,3,1],[1,1,1]]\\n\\nThis is my output versus the expected:\\n\\nOutput: \\n[true,false,true,true,true,true,true,false,true,false,true,false,true]\\n\\nExpected:\\n[true,false,true,true,true,true,true,false,true,false,true,true,true]\\n\\nYou cannot turn \\'hunu\\' into a palindrome with just one letter change\\n\\nExpected:\\n\\n"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "We can rearrange stuff\\n"
                    }
                ]
            },
            {
                "id": 1566888,
                "content": [
                    {
                        "username": "xzj104",
                        "content": "maybe I just didn\\'t understand the question....\\n\\n\\ncan\\'t believe I missed \"rearrange\".....\\n\\nThanks!"
                    },
                    {
                        "username": "saisaket",
                        "content": "hunu [0,3,1] should get a false value right ?, but my testcase is failing even if I get false. leetcode says I need to get true for that. Can someone tell me where am I going wrong\\n"
                    },
                    {
                        "username": "piyush0004",
                        "content": "first rearrange then you have to replace"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "Wait guys :\\nRead the Question again , I know where you are stuck is that you can also rearrange the string"
                    },
                    {
                        "username": "grawlixes",
                        "content": "I submitted a working solution which used a simple DP strategy + a Counter to solve the problem in O(26\\\\*N) time.\\n\\nHowever, that solution got me a big fat TLE due to the overhead of Counter. But, when I submitted a slightly different solution that just used arrays of size 26 to do the exact same thing, it barely passed. Again, the complexity is the same.\\n\\nI know Counter is just a fancier dictionary, so in a practical sense, I maybe should have seen this coming. But if the lower level, less convenient array solution passes, surely the Counter solution also should pass, no? **I believe the largest input should be 10\\\\*\\\\*4, not 10\\\\*\\\\*5 - that will solve this issue.**"
                    },
                    {
                        "username": "adalinge",
                        "content": "how can string \\'hunu\\' be converted to palindrome in one change ? as one of test case returns true"
                    },
                    {
                        "username": "harisht26698",
                        "content": "\"hunu\" can be converted to palindrome with one change of letter and by rearranging \"u\" in the string. that means, it is mentioned we can do any number of rearrangements like \"hunu\" to \"huun\" or \"uhnu\". so these new rearranged string can be converted to palindrome by one change of letter. "
                    },
                    {
                        "username": "amohan93",
                        "content": "\"hunu\"\\n[[1,1,1],[2,3,0],[3,3,1],[0,3,2],[1,3,3],[2,3,1],[3,3,1],[0,3,0],[1,1,1],[2,3,0],[3,3,1],[0,3,1],[1,1,1]]\\n\\nThis is my output versus the expected:\\n\\nOutput: \\n[true,false,true,true,true,true,true,false,true,false,true,false,true]\\n\\nExpected:\\n[true,false,true,true,true,true,true,false,true,false,true,true,true]\\n\\nYou cannot turn \\'hunu\\' into a palindrome with just one letter change\\n\\nExpected:\\n\\n"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "We can rearrange stuff\\n"
                    }
                ]
            },
            {
                "id": 1568274,
                "content": [
                    {
                        "username": "xzj104",
                        "content": "maybe I just didn\\'t understand the question....\\n\\n\\ncan\\'t believe I missed \"rearrange\".....\\n\\nThanks!"
                    },
                    {
                        "username": "saisaket",
                        "content": "hunu [0,3,1] should get a false value right ?, but my testcase is failing even if I get false. leetcode says I need to get true for that. Can someone tell me where am I going wrong\\n"
                    },
                    {
                        "username": "piyush0004",
                        "content": "first rearrange then you have to replace"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "Wait guys :\\nRead the Question again , I know where you are stuck is that you can also rearrange the string"
                    },
                    {
                        "username": "grawlixes",
                        "content": "I submitted a working solution which used a simple DP strategy + a Counter to solve the problem in O(26\\\\*N) time.\\n\\nHowever, that solution got me a big fat TLE due to the overhead of Counter. But, when I submitted a slightly different solution that just used arrays of size 26 to do the exact same thing, it barely passed. Again, the complexity is the same.\\n\\nI know Counter is just a fancier dictionary, so in a practical sense, I maybe should have seen this coming. But if the lower level, less convenient array solution passes, surely the Counter solution also should pass, no? **I believe the largest input should be 10\\\\*\\\\*4, not 10\\\\*\\\\*5 - that will solve this issue.**"
                    },
                    {
                        "username": "adalinge",
                        "content": "how can string \\'hunu\\' be converted to palindrome in one change ? as one of test case returns true"
                    },
                    {
                        "username": "harisht26698",
                        "content": "\"hunu\" can be converted to palindrome with one change of letter and by rearranging \"u\" in the string. that means, it is mentioned we can do any number of rearrangements like \"hunu\" to \"huun\" or \"uhnu\". so these new rearranged string can be converted to palindrome by one change of letter. "
                    },
                    {
                        "username": "amohan93",
                        "content": "\"hunu\"\\n[[1,1,1],[2,3,0],[3,3,1],[0,3,2],[1,3,3],[2,3,1],[3,3,1],[0,3,0],[1,1,1],[2,3,0],[3,3,1],[0,3,1],[1,1,1]]\\n\\nThis is my output versus the expected:\\n\\nOutput: \\n[true,false,true,true,true,true,true,false,true,false,true,false,true]\\n\\nExpected:\\n[true,false,true,true,true,true,true,false,true,false,true,true,true]\\n\\nYou cannot turn \\'hunu\\' into a palindrome with just one letter change\\n\\nExpected:\\n\\n"
                    },
                    {
                        "username": "Akshatjain_",
                        "content": "We can rearrange stuff\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Valid Words for Each Puzzle",
        "question_content": "With respect to a given <code>puzzle</code> string, a <code>word</code> is <em>valid</em> if both the following conditions are satisfied:\n<ul>\n\t<li><code>word</code> contains the first letter of <code>puzzle</code>.</li>\n\t<li>For each letter in <code>word</code>, that letter is in <code>puzzle</code>.\n\t<ul>\n\t\t<li>For example, if the puzzle is <code>&quot;abcdefg&quot;</code>, then valid words are <code>&quot;faced&quot;</code>, <code>&quot;cabbage&quot;</code>, and <code>&quot;baggage&quot;</code>, while</li>\n\t\t<li>invalid words are <code>&quot;beefed&quot;</code> (does not include <code>&#39;a&#39;</code>) and <code>&quot;based&quot;</code> (includes <code>&#39;s&#39;</code> which is not in the puzzle).</li>\n\t</ul>\n\t</li>\n</ul>\nReturn <em>an array </em><code>answer</code><em>, where </em><code>answer[i]</code><em> is the number of words in the given word list </em><code>words</code><em> that is valid with respect to the puzzle </em><code>puzzles[i]</code>.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;aaaa&quot;,&quot;asas&quot;,&quot;able&quot;,&quot;ability&quot;,&quot;actt&quot;,&quot;actor&quot;,&quot;access&quot;], puzzles = [&quot;aboveyz&quot;,&quot;abrodyz&quot;,&quot;abslute&quot;,&quot;absoryz&quot;,&quot;actresz&quot;,&quot;gaswxyz&quot;]\n<strong>Output:</strong> [1,1,3,2,4,0]\n<strong>Explanation:</strong> \n1 valid word for &quot;aboveyz&quot; : &quot;aaaa&quot; \n1 valid word for &quot;abrodyz&quot; : &quot;aaaa&quot;\n3 valid words for &quot;abslute&quot; : &quot;aaaa&quot;, &quot;asas&quot;, &quot;able&quot;\n2 valid words for &quot;absoryz&quot; : &quot;aaaa&quot;, &quot;asas&quot;\n4 valid words for &quot;actresz&quot; : &quot;aaaa&quot;, &quot;asas&quot;, &quot;actt&quot;, &quot;access&quot;\nThere are no valid words for &quot;gaswxyz&quot; cause none of the words in the list contains letter &#39;g&#39;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;apple&quot;,&quot;pleas&quot;,&quot;please&quot;], puzzles = [&quot;aelwxyz&quot;,&quot;aelpxyz&quot;,&quot;aelpsxy&quot;,&quot;saelpxy&quot;,&quot;xaelpsy&quot;]\n<strong>Output:</strong> [0,1,3,2,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>4 &lt;= words[i].length &lt;= 50</code></li>\n\t<li><code>1 &lt;= puzzles.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>puzzles[i].length == 7</code></li>\n\t<li><code>words[i]</code> and <code>puzzles[i]</code> consist of lowercase English letters.</li>\n\t<li>Each <code>puzzles[i] </code>does not contain repeated characters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 372385,
                "title": "java-bit-manipulation-map-solution-90ms",
                "content": "First of all, create a map to cache the frequency of the encoded word.\\n\\nNext, loop the puzzles. During the inner loop, instead of loop through map\\'s keyset (which cause TLE), use ``` sub = (sub - 1) & mask ``` to find all possible char combinations of current puzzel. \\n\\nWe need update count only if combination contains first element of puzzle as well as map has a record of it (means this puzzle\\'s char combination is as the same as one of the encoded word).\\n\\nTime Compliexity: O( n * 2 ^ 7 +  m * k) = O(n + mk)\\nn = len(puzzles);\\nm = len(words);\\nk = len(single word)\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(String w : words){\\n            int mask = 0;\\n            for(int i = 0; i < w.length(); i++){\\n                mask |= 1 << (w.charAt(i) - \\'a\\');\\n            }\\n            map.put(mask, map.getOrDefault(mask, 0) + 1);\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(String p : puzzles){\\n            int mask = 0;\\n            for(int i = 0; i < p.length(); i++){\\n                mask |= 1 << (p.charAt(i) - \\'a\\');\\n            }\\n            int c = 0;\\n            int sub = mask;\\n            int first = 1 << (p.charAt(0) - \\'a\\');\\n            while(true){\\n                if((sub & first) == first && map.containsKey(sub)){\\n                    c += map.get(sub);\\n                }\\n                \\n                if(sub == 0) break;\\n                \\n                sub = (sub - 1) & mask; // get the next substring\\n            }\\n            \\n            res.add(c);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "``` sub = (sub - 1) & mask ```\n```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(String w : words){\\n            int mask = 0;\\n            for(int i = 0; i < w.length(); i++){\\n                mask |= 1 << (w.charAt(i) - \\'a\\');\\n            }\\n            map.put(mask, map.getOrDefault(mask, 0) + 1);\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(String p : puzzles){\\n            int mask = 0;\\n            for(int i = 0; i < p.length(); i++){\\n                mask |= 1 << (p.charAt(i) - \\'a\\');\\n            }\\n            int c = 0;\\n            int sub = mask;\\n            int first = 1 << (p.charAt(0) - \\'a\\');\\n            while(true){\\n                if((sub & first) == first && map.containsKey(sub)){\\n                    c += map.get(sub);\\n                }\\n                \\n                if(sub == 0) break;\\n                \\n                sub = (sub - 1) & mask; // get the next substring\\n            }\\n            \\n            res.add(c);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372145,
                "title": "python-bit-manipulation-detailed-explanation",
                "content": "The idea behind this puzzle is to generate a set of the characters in every word, and for every puzzle, count how many words\\' sets are strict subsets of the puzzle\\'s set.\\n\\nTo do so, we have to generate a way to represent the unique set of a given word. One way to do so is to create a bit mask, where the i-th bit being 1 means the i-th character in the alphabet is in the given word (implemented at [1]). For example, because the word \\'apple\\' is composed of the characters a, e, l, p, it would  have a key as follows:\\n```\\n0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1\\nz y x w v u t s r q p o n m l k j i h g f e d c b a\\n```\\nThe alphabet is to show the mapping between characters and their position in the bit mask. In this example, the words \\'appppppple\\' and \\'pale\\' would have the same bit mask.\\n\\nThen in [2] we create a mapping from a bit mask to the count of words that generate that bit mask.\\n\\nNext, for every puzzle, we need to see what words are composed of characters that only exist in puzzle. So if puzzle is \\'abd\\', then \\'ba\\' would count but \\'bc\\' would not because \\'c\\' is not in \\'abd\\'. To do so, we want to generate every possible set of characters that is a strict subset of the characters in puzzle. In the previous example, this would be [a], [b], [d], [a,b], [a,d], [b,d], [a,b,d]. In bitwise terms, this means we need to generate every \"submask\", s, where the bits in s are also in puzzle\\'s mask. For example, the puzzle \\'abd\\' would have the bitmask 1011, and every submask would be 0000, 0001, 0010, 1000, 1001, 1010, 0011, 1011. We generate every submask by taking advantage of subtracting by 1, which in base 2 flips the lowest bit to 0, and flips all bits to the right of that to 1. By subtracting by 1 and bitwise and-ing with the original mask, we turn off every bit one-by-one. For puzzle with mask 1011, this would go as follows:\\n```\\nsubMask = originalMask = 1011 // [d, b, a]\\n(subMask - 1) & originalMask = (1011 - 1) & 1011 = 1010 & 1011 = 1010 // [d, b]\\n(subMask - 1) & originalMask = (1010 - 1) & 1011 = 1001 & 1011 = 1001 // [d, a]\\n(subMask - 1) & originalMask = (1001 - 1) & 1011 = 1000 & 1011 = 1000 // [d]\\n(subMask - 1) & originalMask = (1000 - 1) & 1011 = 0111 & 1011 = 0011 // [b, a]\\n(subMask - 1) & originalMask = (0011 - 1) & 1011 = 0010 & 1011 = 0010 // [b]\\n(subMask - 1) & originalMask = (0010 - 1) & 1011 = 0001 & 1011 = 0001 // [a]\\n(subMask - 1) & originalMask = (0001 - 1) & 1011 = 0000 & 1011 = 0000 // []\\n```\\n\\nWe implement generating every submask in [3].\\n\\nFinally, for every submask, we also have to ensure that the first letter in the puzzle is in the word. To accomplish this, if the puzzle\\'s first letter is the i-th character in the alphabet, we check if the submask has its i-th bit flipped [4]. If it contains it, it\\'s a valid word and we add the count of words corresponding to that bit mask to our total for this puzzle.\\n\\nOnce we\\'ve added the total number of words that correspond to every submask for a puzzle, we have the solution for that puzzle. We then repeat the task for every puzzle and we have the solution. The solution implemented in Python is as follows:\\n\\n```\\nclass Solution:\\n    # [1]\\n\\t# Generates a bit mask given a word, where the i-th bit being 1 mean\\n\\t# the word contains the i-th letter of the alphabet.\\n\\t# For example the word \\'acf\\' -> 100101 because a, c, f are the 1st, 3rd,\\n\\t# and 6th letters of the alphabet, so those corresponding bits are 1.\\n    def getBitMask(self, word: str) -> int:\\n        mask = 0\\n        for c in word:\\n\\t\\t    # Maps \\'a\\' -> 0, \\'b\\' -> 1, \\'c\\' -> 2, ...\\n            i = ord(c) - ord(\\'a\\')\\n\\t\\t\\t# Sets the i-th bit to 1.\\n            mask |= 1 << i\\n        return mask\\n\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n\\t    # [2]\\n\\t\\t# Maps the bit mask for every word to the count of words with that same bit mask.\\n\\t\\t# For example \\'abd\\' and \\'baddd\\' would have the same mask because they are composed\\n\\t\\t# of the same set of characters.\\n        letterFrequencies = {}\\n        for word in words:\\n            mask = self.getBitMask(word)\\n            letterFrequencies[mask] = letterFrequencies.get(mask, 0) + 1\\n        \\n        solution = [0] * len(puzzles)\\n        \\n        for i in range(len(puzzles)):\\n            puzzle = puzzles[i]\\n            mask = self.getBitMask(puzzle)\\n            subMask = mask\\n            total = 0\\n\\t\\t\\t\\n\\t\\t\\t# The index of the first bit in the puzzle. We need this to check if the\\n\\t\\t\\t# submasks we generate are of valid words.\\n            firstBitIndex = ord(puzzle[0]) - ord(\\'a\\')\\n\\n\\t\\t\\t# [3]\\n            # In this while loop we want to go through all possible \"submasks\" of the bit\\n\\t\\t\\t# mask for the current puzzle. If our puzzle bit mask is 1011, for example, we\\n\\t\\t\\t# would generate 1011, 1010, 1001, 1000, 0011, 0010, 0001, 0000\\n            while True:\\n\\t\\t\\t\\t# [4]\\n\\t\\t\\t    # If this submask contains the first letter of the puzzle, it\\'s a valid word. Here\\n\\t\\t\\t\\t# we add to the number of words we\\'ve seen with this mask to our total.\\n                if subMask >> firstBitIndex & 1:\\n                    total += letterFrequencies.get(subMask, 0)\\n\\t\\t\\t\\t# We\\'ve exhausted all possible submasks.\\n                if subMask == 0:\\n                    break\\n\\t\\t\\t\\t# Get rid of the right-most bit, and restore any bits to the right of it that were\\n\\t\\t\\t\\t# originally in the mask. If the original mask was \\'01011\\' current submask is \\'01000\\',\\n\\t\\t\\t\\t# then submask - 1 = \\'00111\\' and (submask - 1) & mask = \\'00011\\'.\\n                subMask = (subMask - 1) & mask\\n            solution[i] = total\\n        \\n        return solution\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\n0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1\\nz y x w v u t s r q p o n m l k j i h g f e d c b a\\n```\n```\\nsubMask = originalMask = 1011 // [d, b, a]\\n(subMask - 1) & originalMask = (1011 - 1) & 1011 = 1010 & 1011 = 1010 // [d, b]\\n(subMask - 1) & originalMask = (1010 - 1) & 1011 = 1001 & 1011 = 1001 // [d, a]\\n(subMask - 1) & originalMask = (1001 - 1) & 1011 = 1000 & 1011 = 1000 // [d]\\n(subMask - 1) & originalMask = (1000 - 1) & 1011 = 0111 & 1011 = 0011 // [b, a]\\n(subMask - 1) & originalMask = (0011 - 1) & 1011 = 0010 & 1011 = 0010 // [b]\\n(subMask - 1) & originalMask = (0010 - 1) & 1011 = 0001 & 1011 = 0001 // [a]\\n(subMask - 1) & originalMask = (0001 - 1) & 1011 = 0000 & 1011 = 0000 // []\\n```\n```\\nclass Solution:\\n    # [1]\\n\\t# Generates a bit mask given a word, where the i-th bit being 1 mean\\n\\t# the word contains the i-th letter of the alphabet.\\n\\t# For example the word \\'acf\\' -> 100101 because a, c, f are the 1st, 3rd,\\n\\t# and 6th letters of the alphabet, so those corresponding bits are 1.\\n    def getBitMask(self, word: str) -> int:\\n        mask = 0\\n        for c in word:\\n\\t\\t    # Maps \\'a\\' -> 0, \\'b\\' -> 1, \\'c\\' -> 2, ...\\n            i = ord(c) - ord(\\'a\\')\\n\\t\\t\\t# Sets the i-th bit to 1.\\n            mask |= 1 << i\\n        return mask\\n\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n\\t    # [2]\\n\\t\\t# Maps the bit mask for every word to the count of words with that same bit mask.\\n\\t\\t# For example \\'abd\\' and \\'baddd\\' would have the same mask because they are composed\\n\\t\\t# of the same set of characters.\\n        letterFrequencies = {}\\n        for word in words:\\n            mask = self.getBitMask(word)\\n            letterFrequencies[mask] = letterFrequencies.get(mask, 0) + 1\\n        \\n        solution = [0] * len(puzzles)\\n        \\n        for i in range(len(puzzles)):\\n            puzzle = puzzles[i]\\n            mask = self.getBitMask(puzzle)\\n            subMask = mask\\n            total = 0\\n\\t\\t\\t\\n\\t\\t\\t# The index of the first bit in the puzzle. We need this to check if the\\n\\t\\t\\t# submasks we generate are of valid words.\\n            firstBitIndex = ord(puzzle[0]) - ord(\\'a\\')\\n\\n\\t\\t\\t# [3]\\n            # In this while loop we want to go through all possible \"submasks\" of the bit\\n\\t\\t\\t# mask for the current puzzle. If our puzzle bit mask is 1011, for example, we\\n\\t\\t\\t# would generate 1011, 1010, 1001, 1000, 0011, 0010, 0001, 0000\\n            while True:\\n\\t\\t\\t\\t# [4]\\n\\t\\t\\t    # If this submask contains the first letter of the puzzle, it\\'s a valid word. Here\\n\\t\\t\\t\\t# we add to the number of words we\\'ve seen with this mask to our total.\\n                if subMask >> firstBitIndex & 1:\\n                    total += letterFrequencies.get(subMask, 0)\\n\\t\\t\\t\\t# We\\'ve exhausted all possible submasks.\\n                if subMask == 0:\\n                    break\\n\\t\\t\\t\\t# Get rid of the right-most bit, and restore any bits to the right of it that were\\n\\t\\t\\t\\t# originally in the mask. If the original mask was \\'01011\\' current submask is \\'01000\\',\\n\\t\\t\\t\\t# then submask - 1 = \\'00111\\' and (submask - 1) & mask = \\'00011\\'.\\n                subMask = (subMask - 1) & mask\\n            solution[i] = total\\n        \\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567291,
                "title": "c-simple-and-clean-solution-easy-explanation",
                "content": "**Explanation:**\\n\\nTo easily find if a word contains all the letters of another word, we can use bit masking.\\nWe set all the bits of the corresponding indices of each letter, then we easily see if it\\'s a submask.\\n\\nSo first, we create a hashmap to keep the frequency of each mask, so that if we have two words with the same letter we will count both.\\n\\nNow, we iterate through the `puzzles`:\\nWe need to find all combinations of submasks to check. This is the faster than iterating through all the words because each puzzle is only 7 letters. \\nFor that we just do `(submask-1) & mask` - we are turning off a bit by subtracting one which sets the lowest 1 to 0 and all 0s in the right to 1s, and then we do & with the original mask to get only the desired bits.\\n\\nWe need two conditions: \\n1. The word should contain the first letter of the puzzle - we check that with `submask & first`.\\n2. The hashmap saves how many words match this submask, so we just add `mask_freq[submask]`. if it\\'s not in the map it will add zero.\\n\\n```\\nclass Solution {\\npublic:\\n    int maskWord(string word) {\\n        int mask = 0;\\n        for (auto c : word) mask |= (1 << c-\\'a\\');\\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> mask_freq;\\n        for (auto word : words) mask_freq[(maskWord(word))]++;\\n        \\n        vector<int> res;\\n        \\n        for (auto p : puzzles) {\\n            int mask = maskWord(p), submask = mask, first = (1 << p[0]-\\'a\\'), curr = 0;\\n            \\n            while (submask) {\\n                if (submask & first) curr += mask_freq[submask];\\n                \\n                submask = (submask-1) & mask;\\n            }\\n            \\n            res.push_back(curr);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maskWord(string word) {\\n        int mask = 0;\\n        for (auto c : word) mask |= (1 << c-\\'a\\');\\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> mask_freq;\\n        for (auto word : words) mask_freq[(maskWord(word))]++;\\n        \\n        vector<int> res;\\n        \\n        for (auto p : puzzles) {\\n            int mask = maskWord(p), submask = mask, first = (1 << p[0]-\\'a\\'), curr = 0;\\n            \\n            while (submask) {\\n                if (submask & first) curr += mask_freq[submask];\\n                \\n                submask = (submask-1) & mask;\\n            }\\n            \\n            res.push_back(curr);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567324,
                "title": "c-python-clean-solutions-w-detailed-explanation-bit-masking-trie-approaches",
                "content": "**Note:** `words` and `puzzles` are renamed to `W` and `P` respectively in explanation and code below for conciseness. `word` and `puzzle` refer to a string from `W` and `P` respectively.\\n\\nWe are given a string of words `W` and string of puzzles `P`. We need to find number of valid words for each `P[i]` following the conditions of validity mentioned below.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Bitmasking & Submask Enumeration)***\\n\\n\\nLet\\'s first see what a valid `word` string for given `puzzle` string means -\\n1. `word` must contain `puzzle[0]`\\n2. `puzzle` must contain `word[i]` (for `0<=i<=size(word)`)\\n\\nNote that we only need to check if `puzzle` contains a certain letter from `word[i]` or not. For this, we can maintain a 26-sized boolean array, say `letters` denoting whether each of 26 letter is present or not in `word[i]`. However, a better approach would be using `bitmask` where a set bit denotes a letter is present and vice-versa. Then, we can do a similar bitmask thing with each `puzzle` string. Now, we can compare bitmask of `puzzle` string with bitmask  of each `word` and see if every bit that\\'s set in `word`\\'s bitmask is also set in `puzzle`\\'s bitmask or not. In other words, **we need to ensure that the set bits in puzzle\\'s bitmask are subset of word\\'s bitmask**.\\n\\nThis still involves us taking each `puzzle` string from array of puzzles `P` and comparing it against each `word` string from array of words `W`. This approach wont work for the given input size. We need a more efficient approach.\\n\\nA key to finding this approach is observing the constraint - **`P[i].length == 7`**. We can compute the bitmask of `P[i]`. Now, we only need to check if any of the bitmask of `W[i]` is a subset of bitmask of `P[i]`. The total number of subsets of bitmask of `P[i]` comes out to be <code>subsets <= 2<sup>7</sup> = 128</code> which is much less than <code>W.length <= 10<sup>5</sup></code>. \\n\\nSo, we can iterate over `W` and compute all bitmasks. We can store them in a hashmap  along with their frequency. Now, all we need to do is iterate over `P` array and for each `P[i]`, compute its bitmask and check if any of its subset - `submask` is present in hashmap or not. For generating the subsets of a bitmask, we can either follow the simple algorithm to generate all subsets of given array/string as in [78. Subsets](https://leetcode.com/problems/subsets/) or we can use a neat trick for it which you can read more on here - **[Submask Enumeration](https://cp-algorithms.com/algebra/all-submasks.html)**.\\n\\nTill now, we focused on the 2nd point of checking validity of `word` for a given `puzzle` string. For ensuring the 1st point of validity is satisfied as well, we just need to ensure that we **check for only those submask which contain set bit for `puzzle[0]`** meaning we are checking for number of words that consists atleast 1st letter of `puzzle` and a subset of rest of the letters.\\n\\nWe can summarize the algorithm as -\\n\\n1. Calculate bitmasks of each word from `W` and store it in a hashmap along with its frequency\\n2. Iterate over each puzzle from `P` and generate its bitmask.\\n3. Enumerate over each of the submask of above-generated bitmask.\\n4. Count the number of occurences of this submask in the hashmap. This gives us the number of words which only contain letters that are subset of current puzzle string.\\n5. To ensure 1st condition of validity is satisfied, only consider submasks having a set bit corresponding to 1st letter of puzzle.\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& W, vector<string>& P) {\\n        unordered_map<int, int> mp;         // { bitmask : frequency }\\n        vector<int> ans(size(P));\\n\\t\\t// following function returns bitmask of a string\\n        auto getBitmask = [](string& s) {\\n            int bitmask = 0;\\n            for(auto c : s) bitmask |= 1 << c-\\'a\\';\\n            return bitmask;\\n        };\\n\\t\\t// generating bitmask for each word and filling in hashmap\\n        for(auto& word : W)  mp[getBitmask(word)]++;\\n\\t\\t// generate bitmask for each puzzle and enumerate over its subset\\n        for(int i = 0; auto& puzzle : P) {\\n            int mask = getBitmask(puzzle), cnt = 0, firstLetter = 1 << puzzle[0]-\\'a\\';\\n            for(int submask = mask; submask; submask = (submask - 1) & mask)    // https://cp-algorithms.com/algebra/all-submasks.html\\n                if(submask & firstLetter)    // ensure 1st letter is present in submask to satisfy condition-1\\n                    cnt += mp[submask];      // add count of words having same bitmask as submask\\n            ans[i++] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n    def findNumOfValidWords(self, W: List[str], P: List[str]) -> List[int]:\\n        def getBitmask(s):\\n            bitmask = 0\\n            for c in s: bitmask |= 1 << ord(c)-ord(\\'a\\')\\n            return bitmask\\n        mp, ans = Counter(getBitmask(w) for w in W), []\\n        for puzzle in P:\\n            mask, cnt, firstLetter = getBitmask(puzzle), 0, 1 << ord(puzzle[0])-ord(\\'a\\')\\n            submask = mask\\n            while submask:\\n                if submask & firstLetter:\\n                    cnt += mp[submask]\\n                submask = (submask - 1) & mask\\n            ans.append(cnt)\\n        return ans\\n```\\n\\n***Time Complexity :*** **`O(N + m)`**, where `N` is the total number of letters present in `W` and `m` is the number of puzzle strings in `P`. We are iterating over `W` and storing bitmask of each word in hashmap. This takes `O(N)` time in total to compute bitmask of every word from `W`. Then we are iterating over `P`, generating bitmask for each puzzle and enumerating over submasks of bit. The total number of submasks comes out to be <code><= 2<sup>7</sup> = 128</code> which is constant for this problem. So this takes `O(m)` in total. If we are given that `P[i].length` may vary, then the overall time complexity comes out to be <code>O(N+m*2<sup>P<sub>avg</sub></sup>)</code>, where <code>P<sub>avg</sub></code> is  the average length of strings in `P`.\\n***Space Complexity :*** **`O(n)`**, where `n` is the number of word strings in `W`.\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Trie)***\\n\\nThe brute-force appraoch of taking each puzzle string and comparing it with each word string one by one. In the above approach we optmized it by taking bitmasks of words, storing it in hashmaps and then for each puzzle string, we iterated over each of its possible submasks. This essentially allowed us to compare against every possible valid word\\'s bitmask for a specific puzzle string and check if a word having that submask existed or not. The set of bitmasks of valid words being a lot less than size of `W` was the main reason of efficiency.\\n\\nThere\\'s another way of optimising the brute-force process of comparing words against puzzle to find if it\\'s valid. It involves using a Trie in which we will insert all words from `W` and for each puzzle string from `P`, we will perform a DFS over trie to count number of valid words. \\n\\nHowever, directly inserting the words into Trie will result in lots of inefficiency. For eg. We have no use for duplicate characters of a word because if one letter is present in puzzle string, we know that all other occurences of that letter in word will also be present \\uD83E\\uDD37\\u200D. So, we **only insert unique characters from each word into the Trie**. Also, we will **only insert words having 7 or less unique characters** since any more words means that we can be sure that all characters wont be found in any puzzle string because they are of length 7.\\n\\nAnother optimization that we will apply here is **sorting the unique characters before inserting**. This wont affect the answer as the order of characters doesnt matter to us and will help minimize number of nodes in Trie due to common prefix in word strings after sorting.\\n\\n<blockquote>\\n<details>\\n<summary><b>\\u26A0\\uFE0F<em> LC weak Test-cases passes non-optimized version as well</em></b></summary>\\n\\nThe below is direct usage of Trie without above-mentioned optimization and it still passes all the test-cases within time - probably due to absence of stronger test cases.\\n\\n```cpp\\nclass Trie {\\n    Trie* chars[26] {};\\n    int endsHere = 0;\\npublic:\\n    void insert(string& s) {\\n        Trie* cur = this;\\n        for(auto c : s) {\\n            if(!cur -> chars[c - \\'a\\']) \\n                cur -> chars[c - \\'a\\'] = new Trie();            \\n            cur = cur -> chars[c - \\'a\\'];\\n        }\\n        cur -> endsHere++;\\n    }\\n    \\n    int dfs(string& s, Trie* cur, bool hasFirst = false) {\\n        int ans = hasFirst ? cur -> endsHere : 0;\\n        for(auto c : s) \\n            if(cur -> chars[c-\\'a\\']) \\n                ans += dfs(s, cur -> chars[c-\\'a\\'], hasFirst | c == s[0]);\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& W, vector<string>& P) {\\n        vector<int> ans(size(P));\\n        Trie* root = new Trie();\\n        for(auto& word : W) \\n            root -> insert(word);    // <- directly inserting works as well\\n        for(int i = 0; auto& puzzle : P) \\n            ans[i++] = root -> dfs(puzzle, root);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n***Also, if anyone can estimate the Time Complexity of the above code, please do comment***. My guess is it should be `O(N*m)`.\\n\\n</details>\\n</blockquote>\\n\\nThe optimization in this case comes from the fact that for each puzzle, we dont have to check if all <code>1 <= words.length <= 10<sup>5</sup></code> words from `W` are valid or not. Inserting words into Trie with above-mentioned optimizations and then doing DFS on Trie for each puzzle takes takes much less time than brute-force checking of every word for each puzzle.\\n\\nAgain, we can summarize the algorithm as -\\n1. Iterate over each word in `W` and uniquify them, sort them and insert into Trie.\\n2. For each puzzle in `P`, perform a DFS over Trie to find the number of valid words.\\n\\t1. For every letter in current puzzle string, explore further path if that letter is present as descendant of current Trie node.\\n\\t2. If `hasFirst` is set to true, add count of number of words ending at current node to `ans`.\\n\\n**C++**\\n```cpp\\nclass Trie {\\n    Trie* chars[26] {};    // initially all are null\\n    int endsHere = 0;      // number of words ending at a Trie node\\npublic:\\n    void insert(set<char> s) {\\n\\t\\tif(size(s) > 7) return;\\n        Trie* cur = this;\\n        for(auto c : s) {\\n            if(!cur -> chars[c - \\'a\\']) \\n                cur -> chars[c - \\'a\\'] = new Trie();            \\n            cur = cur -> chars[c - \\'a\\'];\\n        }\\n        cur -> endsHere++;\\n    }\\n    int dfs(string& s, Trie* cur, bool hasFirst = false) {\\n        int ans = hasFirst ? cur -> endsHere : 0;   // if condition-1 is satisfied, add number of words ending at this node\\n        for(auto c : s) \\n            if(cur -> chars[c-\\'a\\'])                 // if a char from puzzle is present in Trie, explore that path\\n                ans += dfs(s, cur -> chars[c-\\'a\\'], hasFirst | c == s[0]);\\n\\t\\t\\t\\t                                   //    ^ update everytime to store if 1st char of puzzle is seen in path till now\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& W, vector<string>& P) {\\n        vector<int> ans(size(P));\\n        Trie* root = new Trie();\\n        for(auto& word : W) \\n            root -> insert(set<char>(begin(word), end(word)));  // inserts only unique letters of word in sorted order\\n        for(int i = 0; auto& puzzle : P) \\n            ans[i++] = root -> dfs(puzzle, root);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.chars, self.endsHere = defaultdict(Trie), 0\\n    def insert(self, s):\\n        cur = self\\n        for c in s:\\n            cur = cur.chars[c]\\n        cur.endsHere += 1\\n    def dfs(self, s, cur, hasFirst):\\n        ans = cur.endsHere if hasFirst else 0\\n        for c in s:\\n            ans += self.dfs(s, cur.chars[c], hasFirst or c == s[0]) if c in cur.chars else 0\\n        return ans\\n        \\nclass Solution:\\n    def findNumOfValidWords(self, W: List[str], P: List[str]) -> List[int]:\\n        root = Trie()\\n        for word in W:\\n            root.insert(set(word))\\n        return [root.dfs(puzzle, root, False) for puzzle in P]\\n```\\n\\n***Time Complexity :*** <code>O(n\\\\*W<sub>avg</sub>log(W<sub>avg</sub>) + m)</code>, where `n` is the number of words in `W`, <code>W<sub>avg</sub></code> is the average length of words in `W` and `m` is the number of puzzles in `P`. We iterate over all words, uniquify, sort and insert them into Trie which takes <code>O(W<sub>avg</sub>log(W<sub>avg</sub>))</code> for each. \\nLastly, we perform DFS search for each puzzle string. This may iterate over Trie over a maximum of `7! = 5040` nodes. This is because in the base layer we can 7 points of new recursion, then 6 at the next layer(since only unique-lettered words are inserted, so 1 choice reduced each level) and so on upto 1.\\n***Space Complexity :*** `O(n)`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& W, vector<string>& P) {\\n        unordered_map<int, int> mp;         // { bitmask : frequency }\\n        vector<int> ans(size(P));\\n\\t\\t// following function returns bitmask of a string\\n        auto getBitmask = [](string& s) {\\n            int bitmask = 0;\\n            for(auto c : s) bitmask |= 1 << c-\\'a\\';\\n            return bitmask;\\n        };\\n\\t\\t// generating bitmask for each word and filling in hashmap\\n        for(auto& word : W)  mp[getBitmask(word)]++;\\n\\t\\t// generate bitmask for each puzzle and enumerate over its subset\\n        for(int i = 0; auto& puzzle : P) {\\n            int mask = getBitmask(puzzle), cnt = 0, firstLetter = 1 << puzzle[0]-\\'a\\';\\n            for(int submask = mask; submask; submask = (submask - 1) & mask)    // https://cp-algorithms.com/algebra/all-submasks.html\\n                if(submask & firstLetter)    // ensure 1st letter is present in submask to satisfy condition-1\\n                    cnt += mp[submask];      // add count of words having same bitmask as submask\\n            ans[i++] = cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def findNumOfValidWords(self, W: List[str], P: List[str]) -> List[int]:\\n        def getBitmask(s):\\n            bitmask = 0\\n            for c in s: bitmask |= 1 << ord(c)-ord(\\'a\\')\\n            return bitmask\\n        mp, ans = Counter(getBitmask(w) for w in W), []\\n        for puzzle in P:\\n            mask, cnt, firstLetter = getBitmask(puzzle), 0, 1 << ord(puzzle[0])-ord(\\'a\\')\\n            submask = mask\\n            while submask:\\n                if submask & firstLetter:\\n                    cnt += mp[submask]\\n                submask = (submask - 1) & mask\\n            ans.append(cnt)\\n        return ans\\n```\n```cpp\\nclass Trie {\\n    Trie* chars[26] {};\\n    int endsHere = 0;\\npublic:\\n    void insert(string& s) {\\n        Trie* cur = this;\\n        for(auto c : s) {\\n            if(!cur -> chars[c - \\'a\\']) \\n                cur -> chars[c - \\'a\\'] = new Trie();            \\n            cur = cur -> chars[c - \\'a\\'];\\n        }\\n        cur -> endsHere++;\\n    }\\n    \\n    int dfs(string& s, Trie* cur, bool hasFirst = false) {\\n        int ans = hasFirst ? cur -> endsHere : 0;\\n        for(auto c : s) \\n            if(cur -> chars[c-\\'a\\']) \\n                ans += dfs(s, cur -> chars[c-\\'a\\'], hasFirst | c == s[0]);\\n        return ans;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& W, vector<string>& P) {\\n        vector<int> ans(size(P));\\n        Trie* root = new Trie();\\n        for(auto& word : W) \\n            root -> insert(word);    // <- directly inserting works as well\\n        for(int i = 0; auto& puzzle : P) \\n            ans[i++] = root -> dfs(puzzle, root);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Trie {\\n    Trie* chars[26] {};    // initially all are null\\n    int endsHere = 0;      // number of words ending at a Trie node\\npublic:\\n    void insert(set<char> s) {\\n\\t\\tif(size(s) > 7) return;\\n        Trie* cur = this;\\n        for(auto c : s) {\\n            if(!cur -> chars[c - \\'a\\']) \\n                cur -> chars[c - \\'a\\'] = new Trie();            \\n            cur = cur -> chars[c - \\'a\\'];\\n        }\\n        cur -> endsHere++;\\n    }\\n    int dfs(string& s, Trie* cur, bool hasFirst = false) {\\n        int ans = hasFirst ? cur -> endsHere : 0;   // if condition-1 is satisfied, add number of words ending at this node\\n        for(auto c : s) \\n            if(cur -> chars[c-\\'a\\'])                 // if a char from puzzle is present in Trie, explore that path\\n                ans += dfs(s, cur -> chars[c-\\'a\\'], hasFirst | c == s[0]);\\n\\t\\t\\t\\t                                   //    ^ update everytime to store if 1st char of puzzle is seen in path till now\\n        return ans;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& W, vector<string>& P) {\\n        vector<int> ans(size(P));\\n        Trie* root = new Trie();\\n        for(auto& word : W) \\n            root -> insert(set<char>(begin(word), end(word)));  // inserts only unique letters of word in sorted order\\n        for(int i = 0; auto& puzzle : P) \\n            ans[i++] = root -> dfs(puzzle, root);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.chars, self.endsHere = defaultdict(Trie), 0\\n    def insert(self, s):\\n        cur = self\\n        for c in s:\\n            cur = cur.chars[c]\\n        cur.endsHere += 1\\n    def dfs(self, s, cur, hasFirst):\\n        ans = cur.endsHere if hasFirst else 0\\n        for c in s:\\n            ans += self.dfs(s, cur.chars[c], hasFirst or c == s[0]) if c in cur.chars else 0\\n        return ans\\n        \\nclass Solution:\\n    def findNumOfValidWords(self, W: List[str], P: List[str]) -> List[int]:\\n        root = Trie()\\n        for word in W:\\n            root.insert(set(word))\\n        return [root.dfs(puzzle, root, False) for puzzle in P]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371864,
                "title": "python-find-all-sub-puzzles",
                "content": "## **Part I**\\n1. For each word `w` in `words`, calculate the set of word\\'s letters.\\n2. count the number of differen set, save to the `counter`.\\n<br>\\n\\n## **Part II**\\n1. For each puzzle `p` in `puzzles`, calculate all subset of puzzle `p`.\\nThe subset has to include puzzle\\'s first letter.\\n2. For each set of sub-puzzle, find its occurrence from the counter of part.\\n3. Sum up the occurrencesmof all sub-puzzles, push it to the result list `res`\\n<br>\\n\\n## **Complexity**\\n**Part I** Time `O(W)`, space `O(W)`\\n**Part II** Time `O(2^6 * P)` = `O(64P)`, space `O(1)`\\n<br>\\n\\n## **Set of letters**\\nWe use hashmap to count the sets of letters.\\nSo that the set of letters need to presented as hashable(immutable).\\nI used `str(sorted(set(w)))`, it works but not very efficient.\\n\\n`frozenset(w)` seems to be a good choice,\\nIt is an inbuilt function is Python,\\nSame as set, except its elements are immutable.\\nSimply it freezes the iterable objects and makes them unchangeable.\\n\\nA faster way of doing that is to use a bit mask.\\nWe use an integer of 26 bits to present the set of letters.\\n\\nHashmap of words can still be improved.\\nA much faster way to build up a trie of words.\\n<br>\\n\\n**Python, use build-in combinations:**\\n```python\\n    def findNumOfValidWords(self, words, puzzles):\\n        count = collections.Counter(frozenset(w) for w in words)\\n        res = []\\n        for p in puzzles:\\n            cur = 0\\n            for k in xrange(7):\\n                for c in itertools.combinations(p[1:], k):\\n                    cur += count[frozenset(tuple(p[0]) + c)]\\n            res.append(cur)\\n        return res\\n```\\n**Python, use bfs to find all combinations**\\n```python\\n    def findNumOfValidWords(self, words, puzzles):\\n        count = collections.Counter(frozenset(w) for w in words)\\n        res = []\\n        for p in puzzles:\\n            subs = [p[0]]\\n            for c in p[1:]:\\n                subs += [s + c for s in subs]\\n            res.append(sum(count[frozenset(s)] for s in subs))\\n        return res\\n```\\n\\n**Python, use bfs + mask**\\n```python\\n    def findNumOfValidWords(self, words, puzzles):\\n        count = collections.Counter()\\n        for w in words:\\n            if len(set(w)) > 7: continue\\n            m = 0\\n            for c in w:\\n                m |= 1 << (ord(c) - 97)\\n            count[m] += 1\\n        res = []\\n        for p in puzzles:\\n            bfs = [1 << (ord(p[0]) - 97)]\\n            for c in p[1:]:\\n                bfs += [m | 1 << (ord(c) - 97) for m in bfs]\\n            res.append(sum(count[m] for m in bfs))\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n    def findNumOfValidWords(self, words, puzzles):\\n        count = collections.Counter(frozenset(w) for w in words)\\n        res = []\\n        for p in puzzles:\\n            cur = 0\\n            for k in xrange(7):\\n                for c in itertools.combinations(p[1:], k):\\n                    cur += count[frozenset(tuple(p[0]) + c)]\\n            res.append(cur)\\n        return res\\n```\n```python\\n    def findNumOfValidWords(self, words, puzzles):\\n        count = collections.Counter(frozenset(w) for w in words)\\n        res = []\\n        for p in puzzles:\\n            subs = [p[0]]\\n            for c in p[1:]:\\n                subs += [s + c for s in subs]\\n            res.append(sum(count[frozenset(s)] for s in subs))\\n        return res\\n```\n```python\\n    def findNumOfValidWords(self, words, puzzles):\\n        count = collections.Counter()\\n        for w in words:\\n            if len(set(w)) > 7: continue\\n            m = 0\\n            for c in w:\\n                m |= 1 << (ord(c) - 97)\\n            count[m] += 1\\n        res = []\\n        for p in puzzles:\\n            bfs = [1 << (ord(p[0]) - 97)]\\n            for c in p[1:]:\\n                bfs += [m | 1 << (ord(c) - 97) for m in bfs]\\n            res.append(sum(count[m] for m in bfs))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 371876,
                "title": "detailed-explanation-using-trie-o-word-length-100-puzzle-length",
                "content": "The bitwise solution is a genius one. However, `bits` didn\\'t even cross my mind during the contest. I need to up my coding skills!\\nAnyway, I was thinking of the *trie* based approach during the contest (by looking at the constraints given). It cleared all the test cases and hence I would like to share my approach.\\n# Intuition\\n* First of all, notice that for each word, the ordering and the count of elements does not matter. So, we can keep all our words in a sorted order and avoid the duplicate letters. This makes the maximum size of the word to be 26 (instead of 50). \\n\\n* Further, notice that the ordering of words in the puzzle doesn\\'t matter. We just need to keep track of the first letter of the puzzle.  So, we can also keep our puzzle in sorted manner.\\n\\n* Let us define a **trie** on the set of words. The `bool isEndOfWord` field has been modified to store the number of words ending at that node. \\n\\n* Insertion in the trie is trivial, just follow the normal procedure for insertion, and in the end, increase the count of words ending at the last node by 1. \\n\\n* For any puzzle, we willl traverse the tree and get the answer. Observe that we only need to go 7 levels deep. \\n\\n* We explore all the 7 possibilities. As soon as we see the first element, we can keep incrementing the count from this node onwards. \\n\\n* If we don\\'t see the first element, we keep going down without changing count.\\n\\n\\n# Time Complexity Analysis\\nAt the first level, we have 7 choices, but at the next level, we only have 6 choice, and the next 5, and so on, This gives us an upper bound od `7 * 6 * ....1` = `7!`,  for each query. The overall complexity becomes **O(query_length * 7!)**, which is on the border but would hopefully pass.\\n\\n### Is the bound asymptotically tight?\\nIf we think about it in big O notation, the derivation is correct. But to make the bounds tighter, let\\'s use the theta notation and amortized analysis,\\n\\n## Lowering the upper bound\\nNotice that we can only go 7 levels deep. So, the answer can lie in either or all of this levels.\\n\\n1) How many answers lie in the first level ? Clearly, in the worst case, it is `7C1` , as selecting any 1 would give us an answer.\\n\\n2) How many answers lie in the second level? Clearly, selecting any 2 elements out of the 7 would give us an answer (since any 2 elements from the set can have only 1 sorted order, hence we need to just select elements instead of permuting them). So, the answer at the second level is `7C2`\\n\\n3) Similarly, how many at the third level? Clearly, we can select 3 elements out of the 7, and it would give us a unique answer. Therefore, at the third level. we have `7C3`.\\n\\n.\\n.\\n.\\n\\n7) At the 7th level, we have `7C7` = 1 answer (as there is only one way to reach the 7th level as everything has to be sorted).\\n\\n\\nIn conclusion, the maximum nodes we would have to visit is `7C1 + ... 7C7` = `2^7 - 1` = 127.\\n\\nSo, the worst case traversal would be of the order of `10 ^ 2`. So, the overall complexity is O(100 * queries_length). \\n\\n[Even if you include the hidden constant factors, it won\\'t go beyond `100 * queries_length`\\n\\n\\n\\n```\\nconst int ALPHABET_SIZE = 26;\\n\\n/* The structure of a trie node */\\nstruct TrieNode\\n{\\n    struct TrieNode* children[ALPHABET_SIZE];\\n    int count = 0;\\n};\\n\\n/* Creates a new trie node and returns the pointer */\\nstruct TrieNode* getNode()\\n{\\n    struct TrieNode* newNode = new TrieNode;\\n\\n    for(int i = 0; i < ALPHABET_SIZE; i++)\\n        newNode->children[i] = nullptr;\\n    \\n    newNode->count = 0;\\n\\n    return newNode;\\n}\\n\\n/* Inserts the given string to the collection */\\nvoid insert(struct TrieNode* root, string str)\\n{\\n    struct TrieNode* pCrawl = root;\\n\\n    for(int i = 0; i < str.length(); i++)\\n    {\\n        int index = str[i]-\\'a\\';\\n\\n        if(!pCrawl->children[index])\\n            pCrawl->children[index] = getNode();\\n        \\n        pCrawl = pCrawl->children[index];\\n    }\\n\\n    pCrawl->count++;\\n}\\n\\n/* Returns the count of strings which are valid */\\nint search(struct TrieNode* root, string str, bool firstSeen, char firstLetter)\\n{\\n    if(!root)\\n        return 0;\\n    \\n    int count = 0;\\n    \\n    if(firstSeen)\\n        count += root->count;\\n    \\n    for(int i = 0; i < str.length(); i++)\\n    {\\n        int index = str[i] - \\'a\\';\\n        \\n        if(str[i] == firstLetter)\\n            count += search(root->children[index], str, true, firstLetter);\\n        else\\n            count += search(root->children[index], str, firstSeen, firstLetter);\\n    }\\n\\n    return count;\\n}\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles);\\n};\\n\\nvector<int> Solution :: findNumOfValidWords(vector<string>& words, vector<string>& puzzles)\\n{\\n    struct TrieNode* root = getNode();\\n    \\n    for(auto str : words)\\n    {\\n        set<char> temp;\\n        temp.insert(str.begin(), str.end());\\n        \\n        string sorted = \"\";\\n        for(auto ele : temp)\\n            sorted += ele;\\n        \\n        insert(root, sorted);\\n    }\\n    \\n    vector<int> count;\\n    for(auto puzzle : puzzles)\\n    {\\n        char firstLetter = puzzle[0];\\n        sort(puzzle.begin(), puzzle.end());\\n        count.push_back(search(root, puzzle, false, firstLetter));\\n    }\\n    \\n    return count;\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst int ALPHABET_SIZE = 26;\\n\\n/* The structure of a trie node */\\nstruct TrieNode\\n{\\n    struct TrieNode* children[ALPHABET_SIZE];\\n    int count = 0;\\n};\\n\\n/* Creates a new trie node and returns the pointer */\\nstruct TrieNode* getNode()\\n{\\n    struct TrieNode* newNode = new TrieNode;\\n\\n    for(int i = 0; i < ALPHABET_SIZE; i++)\\n        newNode->children[i] = nullptr;\\n    \\n    newNode->count = 0;\\n\\n    return newNode;\\n}\\n\\n/* Inserts the given string to the collection */\\nvoid insert(struct TrieNode* root, string str)\\n{\\n    struct TrieNode* pCrawl = root;\\n\\n    for(int i = 0; i < str.length(); i++)\\n    {\\n        int index = str[i]-\\'a\\';\\n\\n        if(!pCrawl->children[index])\\n            pCrawl->children[index] = getNode();\\n        \\n        pCrawl = pCrawl->children[index];\\n    }\\n\\n    pCrawl->count++;\\n}\\n\\n/* Returns the count of strings which are valid */\\nint search(struct TrieNode* root, string str, bool firstSeen, char firstLetter)\\n{\\n    if(!root)\\n        return 0;\\n    \\n    int count = 0;\\n    \\n    if(firstSeen)\\n        count += root->count;\\n    \\n    for(int i = 0; i < str.length(); i++)\\n    {\\n        int index = str[i] - \\'a\\';\\n        \\n        if(str[i] == firstLetter)\\n            count += search(root->children[index], str, true, firstLetter);\\n        else\\n            count += search(root->children[index], str, firstSeen, firstLetter);\\n    }\\n\\n    return count;\\n}\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles);\\n};\\n\\nvector<int> Solution :: findNumOfValidWords(vector<string>& words, vector<string>& puzzles)\\n{\\n    struct TrieNode* root = getNode();\\n    \\n    for(auto str : words)\\n    {\\n        set<char> temp;\\n        temp.insert(str.begin(), str.end());\\n        \\n        string sorted = \"\";\\n        for(auto ele : temp)\\n            sorted += ele;\\n        \\n        insert(root, sorted);\\n    }\\n    \\n    vector<int> count;\\n    for(auto puzzle : puzzles)\\n    {\\n        char firstLetter = puzzle[0];\\n        sort(puzzle.begin(), puzzle.end());\\n        count.push_back(search(root, puzzle, false, firstLetter));\\n    }\\n    \\n    return count;\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567314,
                "title": "java-simple-clean-solution-bit-manipulation-hashmap-60ms-tc-o-nl-p-sc-o-n",
                "content": "For this question we will use Bit Manipulation to generate an encoding (or mask) for each string. \\n\\nAs per the constraints, input can only have lower case alphabers. Thus we will need just 26 bits for the mask.\\nWe can set `0th` bit for `\\'a\\'`, `1st` bit for `\\'b\\'`, `2nd` bit for `\\'c\\'`, ...... ,  `25th` bit for `\\'z\\'`.\\n\\nFirst we will create a `wordMaskCountMap`. This map will contain the count of each unique word mask.\\n\\nIn the second step, we will generate all valid subsets of the puzzle using the last 6 characters in each puzzle.\\nWe only only take the `last 6 characters` in each puzzle, because the `first character` needs to be present in each word as given in the question. This will help us to reduce the time complexity of the solution from `2^7` to `2^6`.\\nIf the `subsetMask | firstCharMask` exists in the map, then add the count of words in the result list.\\n\\nTo get all possible subsets, we do `subsetMask = (subsetMask - 1) & puzzleMask`.\\n`subsetMask - 1` will give all possible subsets and then we perfom an AND with `puzzleMask` to make sure its not containing characters outside the given puzzle.\\n\\n---\\n\\n**Time Complexity:** `O(N * L + P * (6 + 2^6)) = O(N * L + P)`.\\n--> `N*L` for generating masks for each word\\n--> `P*6` for generating masks for each puzzle\\n--> `P * 2^6` for Generating number of subsets. (Note: we are only using 6 chars for finding subsets as we have exlcuded the first char from subsets)\\n\\n**Space Complexity:** `O(N)` --> Required for the HashMap. It will contain upto `O(N)` keys and values.\\n\\nWhere:\\nN --> Number of Words\\nL --> Average length of each word\\nP --> Number of puzzles. (As per input constraints, Length of each puzzle is 7)\\n\\n---\\n\\n```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        if (words == null || puzzles == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int puzzlesLen = puzzles.length;\\n        List<Integer> result = new ArrayList<>(puzzlesLen);\\n        if (puzzlesLen == 0 || words.length == 0) {\\n            for (int i = 0; i < puzzlesLen; i++) {\\n                result.add(0);\\n            }\\n            return result;\\n        }\\n\\n        // This map will store the count of unique word masks\\n        HashMap<Integer, Integer> wordMaskCountMap = new HashMap<>();\\n        for (String word : words) {\\n            int wordMask = getMask(word, 0);\\n            wordMaskCountMap.put(wordMask, wordMaskCountMap.getOrDefault(wordMask, 0) + 1);\\n        }\\n\\n        for (String puzzle : puzzles) {\\n            // We will only create subsets of last 6 characters because 1st character needs\\n            // to be present in all words\\n            int puzzleMask = getMask(puzzle, 1);\\n            int firstCharMask = 1 << (puzzle.charAt(0) - \\'a\\');\\n            int subsetMask = puzzleMask;\\n            int count = wordMaskCountMap.getOrDefault(firstCharMask, 0);\\n\\n            while (subsetMask != 0) {\\n                // Check if the (puzzle subset + first character) is present in the\\n                // wordMaskCountMap map and add its count.\\n                count += wordMaskCountMap.getOrDefault(subsetMask | firstCharMask, 0);\\n\\n                // Get next subset of the puzzle.\\n                subsetMask = (subsetMask - 1) & puzzleMask;\\n            }\\n\\n            result.add(count);\\n        }\\n\\n        return result;\\n    }\\n\\n    // In this function, we are generating a bit mask of each String.\\n    // Here we set 0th bit for \\'a\\', 1st bit for \\'b\\', and so on.\\n    // We will be setting upto 26 bits only.\\n    private static int getMask(String s, int start) {\\n        int mask = 0;\\n        for (int i = start; i < s.length(); i++) {\\n            mask |= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        return mask;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        if (words == null || puzzles == null) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int puzzlesLen = puzzles.length;\\n        List<Integer> result = new ArrayList<>(puzzlesLen);\\n        if (puzzlesLen == 0 || words.length == 0) {\\n            for (int i = 0; i < puzzlesLen; i++) {\\n                result.add(0);\\n            }\\n            return result;\\n        }\\n\\n        // This map will store the count of unique word masks\\n        HashMap<Integer, Integer> wordMaskCountMap = new HashMap<>();\\n        for (String word : words) {\\n            int wordMask = getMask(word, 0);\\n            wordMaskCountMap.put(wordMask, wordMaskCountMap.getOrDefault(wordMask, 0) + 1);\\n        }\\n\\n        for (String puzzle : puzzles) {\\n            // We will only create subsets of last 6 characters because 1st character needs\\n            // to be present in all words\\n            int puzzleMask = getMask(puzzle, 1);\\n            int firstCharMask = 1 << (puzzle.charAt(0) - \\'a\\');\\n            int subsetMask = puzzleMask;\\n            int count = wordMaskCountMap.getOrDefault(firstCharMask, 0);\\n\\n            while (subsetMask != 0) {\\n                // Check if the (puzzle subset + first character) is present in the\\n                // wordMaskCountMap map and add its count.\\n                count += wordMaskCountMap.getOrDefault(subsetMask | firstCharMask, 0);\\n\\n                // Get next subset of the puzzle.\\n                subsetMask = (subsetMask - 1) & puzzleMask;\\n            }\\n\\n            result.add(count);\\n        }\\n\\n        return result;\\n    }\\n\\n    // In this function, we are generating a bit mask of each String.\\n    // Here we set 0th bit for \\'a\\', 1st bit for \\'b\\', and so on.\\n    // We will be setting upto 26 bits only.\\n    private static int getMask(String s, int start) {\\n        int mask = 0;\\n        for (int i = start; i < s.length(); i++) {\\n            mask |= 1 << (s.charAt(i) - \\'a\\');\\n        }\\n        return mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567327,
                "title": "c-easy-intuitive-sol-bit-manipulation-full-explanation",
                "content": "Hello everyone, first of all thanks in advance for reading it.\\n\\nThis problem can be solved with bit manipulation and I will explain how.\\n\\n**How to check whether a word is valid for a puzzle or not?**\\nWe can make a bitmask for word and for puzzle both. Bitmask means we will set the ith bit if ith letter of alphabet is present in our word, you will understand better with an example:\\n\\nword = a e f g\\npuzzle = f g h e r t a\\n\\nword_mask = 1110001\\n\\n**Explanation:**\\n* Here 0th bit is set because `a` is present in word and `a` is the 0th letter of our alphabet\\n* Also 4th, 5th, 6th bits are set in our word_mask because e, f, g are present in our word and they are 4th, 5th, 6th letter in our alphabet.\\n\\nSimilarly, puzzle_mask is also calculated.\\n\\nNow, to check whether this word is a valid word for our respective puzzle, we will do the AND (&) operation between  word_mask and puzzle_mask, because we want all the set bit of word_mask to be set in the puzzle_mask and if the result of their AND operation is equal to word_mask, then it means all letters of word are present in our puzzle.\\n\\nAlso, we have to check whether first char of puzzle in present in word, that we\\'ll do easily as you will read forward.\\n\\n**My Appraoch:**\\n1. I will first make a map of character and vector of masks. In this, for each letter `letter_i`, we\\'ll store vector of bitmask of words that contains the letter `letter_i`.\\n\\n2. This, will help us in future as let us assume we want all words that must contain some letter `letter_i` which is a first char of our puzzle, then we can simply see the vector of bitmask of words in our map where key is `letter_i`. By this we will then only need to check whether all characters of word (from our vector of bitmask that we got from map) are present in our puzzle or not (We can easily check this from explanation above).\\n\\n3. Then for every puzzle, we will retrieve their first character and get their corresponding vector of bitmasks of useful words from our map.\\n\\n4. Then check whether that word is valid or not and increment the counter if valid.\\n\\nBelow is the code for my approach:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        map<char, vector<int>>mp{};\\n        \\n\\t\\t// Initialize the map for each char in alphabet\\n        for(int i{}; i<26; ++i){\\n            vector<int>v{};\\n            mp[(char)i + \\'a\\'] = v;\\n        }\\n        \\n        for(auto &word:words){\\n            int mask{};\\n            \\n\\t\\t\\t// generate mask for each word\\n            for(auto &letter: word){\\n                int bit = letter - \\'a\\';\\n                mask = mask | (1<<bit);\\n            }\\n            \\n\\t\\t\\t//This is a checker that will help us NOT to incluce same word twice in our map for some character\\n            vector<bool>letter_found(26, 0);\\n            \\n            for(auto &letter: word){\\n                \\n                if(letter_found[letter - \\'a\\'] == 0){\\n                    mp[letter].push_back(mask);\\n                    letter_found[letter - \\'a\\'] = 1;\\n                }\\n            }\\n        }\\n        \\n        vector<int>res{};\\n        \\n        for(auto &puzzle: puzzles){\\n            \\n            char first_char = puzzle[0];\\n            int cnt{};\\n            int puzzle_mask{};\\n            \\n\\t\\t\\t// Generate puzzle mask\\n            for(auto &letter: puzzle){\\n                int bit = letter - \\'a\\';\\n                puzzle_mask = puzzle_mask | (1<<bit);\\n            }\\n            \\n\\t\\t\\t//Get our desired vector of bitmask that contains our first char\\n            for(auto word_mask: mp[first_char]){\\n\\t\\t\\t\\n\\t\\t\\t\\t//check if all letter is contained by puzzle or not\\n                if((word_mask & puzzle_mask) == word_mask)\\n                    cnt++;\\n            }\\n            // Add the count for current puzzle\\n            res.push_back(cnt);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n`\\nPlease do`  **Upvote**  `\\uD83D\\uDD3C this post if it was helpful for you! \\n`\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        map<char, vector<int>>mp{};\\n        \\n\\t\\t// Initialize the map for each char in alphabet\\n        for(int i{}; i<26; ++i){\\n            vector<int>v{};\\n            mp[(char)i + \\'a\\'] = v;\\n        }\\n        \\n        for(auto &word:words){\\n            int mask{};\\n            \\n\\t\\t\\t// generate mask for each word\\n            for(auto &letter: word){\\n                int bit = letter - \\'a\\';\\n                mask = mask | (1<<bit);\\n            }\\n            \\n\\t\\t\\t//This is a checker that will help us NOT to incluce same word twice in our map for some character\\n            vector<bool>letter_found(26, 0);\\n            \\n            for(auto &letter: word){\\n                \\n                if(letter_found[letter - \\'a\\'] == 0){\\n                    mp[letter].push_back(mask);\\n                    letter_found[letter - \\'a\\'] = 1;\\n                }\\n            }\\n        }\\n        \\n        vector<int>res{};\\n        \\n        for(auto &puzzle: puzzles){\\n            \\n            char first_char = puzzle[0];\\n            int cnt{};\\n            int puzzle_mask{};\\n            \\n\\t\\t\\t// Generate puzzle mask\\n            for(auto &letter: puzzle){\\n                int bit = letter - \\'a\\';\\n                puzzle_mask = puzzle_mask | (1<<bit);\\n            }\\n            \\n\\t\\t\\t//Get our desired vector of bitmask that contains our first char\\n            for(auto word_mask: mp[first_char]){\\n\\t\\t\\t\\n\\t\\t\\t\\t//check if all letter is contained by puzzle or not\\n                if((word_mask & puzzle_mask) == word_mask)\\n                    cnt++;\\n            }\\n            // Add the count for current puzzle\\n            res.push_back(cnt);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372025,
                "title": "3-cpp-solutions-bit-manipulation-trie-and-two-fold-hash",
                "content": "# Brute-force + bit manipulation + subset enumeration (1000+ms 300+mb)\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> count(1<<26, 0);\\n        for (int i = 0; i < words.size(); i++) {\\n            int bit = 0;\\n            for (auto c: words[i]) {\\n                bit |= (1<<(c-\\'a\\'));\\n            }\\n            count[bit] ++;\\n        }\\n        vector<int> res;\\n        for (int i = 0; i < puzzles.size(); i++) {\\n            int cnt = 0;\\n            for (int j = 0; j < (1<<6); j++) {\\n                int bit = 1<<(puzzles[i][0]-\\'a\\');\\n                for (int k = 0; k < 6; k++) {\\n                    if ((j & (1<<k)) > 0) {\\n                        bit |= 1<<(puzzles[i][k+1]-\\'a\\');\\n                    }\\n                }\\n                cnt += count[bit];\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Same idea as the above solution, in a smarter way. (150+ms, 30mb)\\n- use hashmap instead of vector of size 2^26.\\n- subset enumeration by `i = (i-1)&mask` \\n```cpp\\nclass Solution {\\n    int getMask(string & s) {\\n        int mask = 0;\\n        for (auto c: s)\\n            mask |= (1<<(c-\\'a\\'));\\n        return mask;\\n    }\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> freq;\\n        for (auto & w: words) {\\n            int mask = getMask(w);\\n            freq[mask] ++;\\n        }\\n        vector<int> res;\\n        for (auto & p : puzzles) {\\n            int mask = getMask(p);\\n            int cnt = 0;\\n            int maskFirstChar = 1<<(p[0]-\\'a\\');\\n            for (int i = mask; i > 0; i = ((i-1) & mask)) {\\n                if ((i & maskFirstChar) > 0 && freq.count(i)) {\\n                    cnt += freq[i];\\n                }\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Trie of words, search by puzzles (160+ms 60+mb)\\n```cpp\\nclass Solution {\\n    struct TrieNode{\\n        int countEnd;\\n        TrieNode* children[26];\\n        TrieNode() {\\n            countEnd = 0;\\n            memset(children, 0, sizeof(TreeNode*)*26);\\n        }\\n    };\\n    TrieNode trie;\\n    \\n    void insert(int countChar[26]) {\\n        TrieNode * currNode = & trie;\\n        for (int i = 0; i < 26; i++) {\\n            if (countChar[i] == 1) {\\n                if (currNode->children[i] == nullptr)\\n                    currNode->children[i] = new TrieNode();\\n                currNode = currNode->children[i];\\n            }\\n        }\\n        currNode->countEnd ++;\\n    }\\n    \\n    void buildTrie(vector<string> & words) {\\n        int countChar[26];\\n        for (int i = 0; i < words.size(); i++) {\\n            memset(countChar, 0, sizeof(int)*26);\\n            string & w = words[i];\\n            for (auto c: w) { countChar[c-\\'a\\'] = 1; }\\n            int count = 0;\\n            for (int i = 0; i < 26; i++) { count += countChar[i]; }\\n            if (count > 7) continue;\\n            insert(countChar);\\n        }\\n    }\\n\\t\\n\\tint search(TrieNode* node, string & p, int idx, char firstChar, bool metFirst) {\\n        int res = 0;\\n        if (node->countEnd > 0 && metFirst) {\\n            res += node->countEnd;\\n        }\\n        for (int i = idx; i < p.length(); i++) {\\n            if (node->children[p[i]-\\'a\\'] != nullptr) {\\n                res += search(node->children[p[i]-\\'a\\'], p, i+1, firstChar, metFirst || (p[i] == firstChar));\\n            }\\n        }\\n        return res;\\n    }\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        buildTrie(words);\\n        vector<int> res;\\n        for (int i = 0; i < puzzles.size(); i++) {\\n            char firstChar = puzzles[i][0];\\n            sort(puzzles[i].begin(), puzzles[i].end());\\n            int cnt = search(&trie, puzzles[i], 0, firstChar, false);\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# Two-fold hashtable + bit manipulation(400+ms, 40+mb)\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<char, unordered_map<int, vector<int>>> mem;\\n        for (auto & s : words) {\\n            int key = 0;\\n            for (auto & c : s) {\\n                key |= (1<<(c-\\'a\\'));\\n            }\\n            int first13 = key & (((1<<13)-1)<<13);\\n            for (int j = 0; j < 26; j++) {\\n                if ((key & (1<<j)) > 0 ) {\\n                    mem[\\'a\\'+j][first13].push_back(key);\\n                }\\n            }\\n        }\\n        vector<int> res(puzzles.size(), 0);\\n        for (int i = 0; i < puzzles.size(); i++) {\\n            string & s = puzzles[i];\\n            int key = 0;\\n            for (auto c : s) {\\n                key |= (1<<(c-\\'a\\'));\\n            }\\n            int first13 = key & (((1<<13)-1)<<13);\\n            char firstChar = s[0];\\n            if (mem.count(firstChar)) {\\n                for (auto & kv1 : mem[firstChar]) {\\n                    if ((first13 & kv1.first) == kv1.first) {\\n                        for (auto n : kv1.second) {\\n                            if ((key & n) == n) {\\n                                    res[i] ++;\\n                            }\\n                        }\\n                    }\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> count(1<<26, 0);\\n        for (int i = 0; i < words.size(); i++) {\\n            int bit = 0;\\n            for (auto c: words[i]) {\\n                bit |= (1<<(c-\\'a\\'));\\n            }\\n            count[bit] ++;\\n        }\\n        vector<int> res;\\n        for (int i = 0; i < puzzles.size(); i++) {\\n            int cnt = 0;\\n            for (int j = 0; j < (1<<6); j++) {\\n                int bit = 1<<(puzzles[i][0]-\\'a\\');\\n                for (int k = 0; k < 6; k++) {\\n                    if ((j & (1<<k)) > 0) {\\n                        bit |= 1<<(puzzles[i][k+1]-\\'a\\');\\n                    }\\n                }\\n                cnt += count[bit];\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int getMask(string & s) {\\n        int mask = 0;\\n        for (auto c: s)\\n            mask |= (1<<(c-\\'a\\'));\\n        return mask;\\n    }\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> freq;\\n        for (auto & w: words) {\\n            int mask = getMask(w);\\n            freq[mask] ++;\\n        }\\n        vector<int> res;\\n        for (auto & p : puzzles) {\\n            int mask = getMask(p);\\n            int cnt = 0;\\n            int maskFirstChar = 1<<(p[0]-\\'a\\');\\n            for (int i = mask; i > 0; i = ((i-1) & mask)) {\\n                if ((i & maskFirstChar) > 0 && freq.count(i)) {\\n                    cnt += freq[i];\\n                }\\n            }\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    struct TrieNode{\\n        int countEnd;\\n        TrieNode* children[26];\\n        TrieNode() {\\n            countEnd = 0;\\n            memset(children, 0, sizeof(TreeNode*)*26);\\n        }\\n    };\\n    TrieNode trie;\\n    \\n    void insert(int countChar[26]) {\\n        TrieNode * currNode = & trie;\\n        for (int i = 0; i < 26; i++) {\\n            if (countChar[i] == 1) {\\n                if (currNode->children[i] == nullptr)\\n                    currNode->children[i] = new TrieNode();\\n                currNode = currNode->children[i];\\n            }\\n        }\\n        currNode->countEnd ++;\\n    }\\n    \\n    void buildTrie(vector<string> & words) {\\n        int countChar[26];\\n        for (int i = 0; i < words.size(); i++) {\\n            memset(countChar, 0, sizeof(int)*26);\\n            string & w = words[i];\\n            for (auto c: w) { countChar[c-\\'a\\'] = 1; }\\n            int count = 0;\\n            for (int i = 0; i < 26; i++) { count += countChar[i]; }\\n            if (count > 7) continue;\\n            insert(countChar);\\n        }\\n    }\\n\\t\\n\\tint search(TrieNode* node, string & p, int idx, char firstChar, bool metFirst) {\\n        int res = 0;\\n        if (node->countEnd > 0 && metFirst) {\\n            res += node->countEnd;\\n        }\\n        for (int i = idx; i < p.length(); i++) {\\n            if (node->children[p[i]-\\'a\\'] != nullptr) {\\n                res += search(node->children[p[i]-\\'a\\'], p, i+1, firstChar, metFirst || (p[i] == firstChar));\\n            }\\n        }\\n        return res;\\n    }\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        buildTrie(words);\\n        vector<int> res;\\n        for (int i = 0; i < puzzles.size(); i++) {\\n            char firstChar = puzzles[i][0];\\n            sort(puzzles[i].begin(), puzzles[i].end());\\n            int cnt = search(&trie, puzzles[i], 0, firstChar, false);\\n            res.push_back(cnt);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<char, unordered_map<int, vector<int>>> mem;\\n        for (auto & s : words) {\\n            int key = 0;\\n            for (auto & c : s) {\\n                key |= (1<<(c-\\'a\\'));\\n            }\\n            int first13 = key & (((1<<13)-1)<<13);\\n            for (int j = 0; j < 26; j++) {\\n                if ((key & (1<<j)) > 0 ) {\\n                    mem[\\'a\\'+j][first13].push_back(key);\\n                }\\n            }\\n        }\\n        vector<int> res(puzzles.size(), 0);\\n        for (int i = 0; i < puzzles.size(); i++) {\\n            string & s = puzzles[i];\\n            int key = 0;\\n            for (auto c : s) {\\n                key |= (1<<(c-\\'a\\'));\\n            }\\n            int first13 = key & (((1<<13)-1)<<13);\\n            char firstChar = s[0];\\n            if (mem.count(firstChar)) {\\n                for (auto & kv1 : mem[firstChar]) {\\n                    if ((first13 & kv1.first) == kv1.first) {\\n                        for (auto n : kv1.second) {\\n                            if ((key & n) == n) {\\n                                    res[i] ++;\\n                            }\\n                        }\\n                    }\\n                }\\n            } \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567856,
                "title": "python-short-solution-with-bitmasks-explained",
                "content": "The idea is to create bitmask for each word and create counter of all words. Then we iterate over puzzles and for each puzzle we need to get 2^6 (not 2^7, becauswe first symbol should be used) possible submasks and check how many times each of them used, using our counter. Here I use trick how to traverse all submasks, it can be done in different way, for example with bfs.\\n\\n#### Complexity\\nTime complexity is `O(M + P*2^6)`, where `M` is total length of words and `P` is number of puzzles we have.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def findNumOfValidWords(self, words, puzzles):\\n        def get_mask(s):\\n            return reduce(lambda x, y: x|y, [1<<(ord(c) - 97) for c in s])\\n        \\n        ans, cnt = [0]*len(puzzles), Counter()\\n        for word in words: cnt[get_mask(word)] += 1\\n\\n        for i, puzzle in enumerate(puzzles):\\n            mask = get_mask(puzzle[1:])\\n            addon = 1<<(ord(puzzle[0]) - 97)\\n            submask = mask\\n            while submask:\\n                ans[i] += cnt[submask|addon]\\n                submask = (submask - 1) & mask\\n            ans[i] += cnt[addon]\\n            \\n        return ans\\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```python\\nclass Solution:\\n    def findNumOfValidWords(self, words, puzzles):\\n        def get_mask(s):\\n            return reduce(lambda x, y: x|y, [1<<(ord(c) - 97) for c in s])\\n        \\n        ans, cnt = [0]*len(puzzles), Counter()\\n        for word in words: cnt[get_mask(word)] += 1\\n\\n        for i, puzzle in enumerate(puzzles):\\n            mask = get_mask(puzzle[1:])\\n            addon = 1<<(ord(puzzle[0]) - 97)\\n            submask = mask\\n            while submask:\\n                ans[i] += cnt[submask|addon]\\n                submask = (submask - 1) & mask\\n            ans[i] += cnt[addon]\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567415,
                "title": "python-trie-bitmasking-solutions-with-explanation",
                "content": "### Approach 1: Trie\\n\\nThis approach is more intuitive for working with sets of words. Essentially, we can perform the following:\\n\\n- Generate a Trie for all the given words in the input. (If you don\\'t know what a Trie is or how it works, I suggest starting [here](https://medium.com/basecs/trying-to-understand-tries-3ec6bede0014).)\\n\\n```python\\nclass TrieNode:\\n\\t\"\"\"This class represents a node in a Trie.\"\"\"\\n    def __init__(self, ch: Optional[str] = \\'\\'):\\n        self.ch = ch        # denotes the current character\\n        self.count = 0      # denotes how many words end here\\n        self.children = {}  # denotes possible next characters\\n\\nclass Trie:\\n\\t\"\"\"This class represents the Trie itself.\"\"\"\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def add(self, word: str) -> None:\\n\\t\\t\"\"\"Adding words into the Trie in linear time.\"\"\"\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children.keys():\\n                node.children[ch] = TrieNode(ch)\\n            node = node.children[ch]\\n        node.count += 1\\n```\\n\\n- Perform DFS search for each word in the given puzzles to see how many words in the Trie match.\\n\\n```python\\nclass Trie:\\n\\t# as per ealier implementation...\\n    def search(self, word: str) -> int:\\n\\t\\t\"\"\"DFS search for all words that are valid based on input.\"\"\"\\n        def dfs(node: TrieNode, found: Optional[bool] = False) -> int:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDFS algo search.\\n\\t\\t\\t:param node:  The current node being searched.\\n\\t\\t\\t:param found: Flag to indicate if the first character has been found (validity criteria).\\n\\t\\t\\t:returns:     The total number of valid words found.\\n\\t\\t\\t\"\"\"\\n            result = node.count*found  # if there are words here, add them only if first character is found\\n            for ch in word:\\n                if ch in node.children.keys():\\n\\t\\t\\t\\t\\t# traverse through all valid next characters to find valid words\\n                    result += dfs(node.children[ch], found or ch == word[0])\\n            return result\\n        return dfs(self.root)\\n```\\n\\nThis gives us the following (long) implementation:\\n\\n```python\\nclass TrieNode:\\n    def __init__(self, ch: Optional[str] = \\'\\'):\\n        self.ch = ch\\n        self.count = 0\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def add(self, word: str) -> None:\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children.keys():\\n                node.children[ch] = TrieNode(ch)\\n            node = node.children[ch]\\n        node.count += 1\\n    \\n    def search(self, word: str) -> int:       \\n        def dfs(node: TrieNode, found: Optional[bool] = False) -> int:\\n            result = node.count*found\\n            for ch in word:\\n                if ch in node.children.keys():\\n                    result += dfs(node.children[ch], found or ch == word[0])\\n            return result\\n        return dfs(self.root)\\n\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        trie = Trie()\\n        for word in words:\\n            trie.add(word)\\n        return [trie.search(word) for word in puzzles]\\n```\\n\\nAs you can tell, the runtime and memory usage for the above solution isn\\'t great (it barely passes both). [This post](https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/discuss/371876/Detailed-Explanation-using-Trie-O(word_length-%2B-100*puzzle_length)) (with credit to [@Just__a__Visitor](https://leetcode.com/Just__a__Visitor/)) goes into much more detail as to why this is the case, if you are interested. It should also be noted that we can [implement the Trie more concisely](https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/discuss/372368/Concise-python-trie-solution) (with credit to [@tclh123](https://leetcode.com/tclh123/)) which would significantly increase performance but still come out slow and less efficient overall. So, maybe Trie just isn\\'t cut out for this problem after all.\\n\\n---\\n\\n### Approach 2: Bitmasking\\n\\nThis approach works by comparing masks instead of words, improving the comparison from O(mn) to O(1) time. The idea is that:\\n\\n- We generate masks for each word, and for each puzzle subsequently.\\n\\n```python\\ndef mask(self, word: str) -> int:\\n\\t\"\"\"Generate mask for a given word.\"\"\"\\n\\tresult = 0\\n\\tfor ch in word:\\n\\t\\tresult |= 1 << (ord(ch)-ord(\\'a\\'))  # [a-z] constraint\\n\\treturn result\\n```\\n\\n- Iterating through each puzzle, we check if its mask matches any of the word masks. Then, we obtain the masks of each possible combination of letters in the puzzle, and check if those masks match.\\n\\nFor example, if the puzzle was \\'abcdefg\\', its mask would be `1111111` (omitting leading `0`s). Then, if a word only used the letters \\'a\\'-\\'d\\', we would expect its mask to be `0001111` which can be obtained from the puzzle mask by flipping the \\'e\\', \\'f\\' and \\'g\\' bits off (i.e. denoting not in use).\\n\\nThere is a clever way of iterating through all possible mask combinations of a 7-letter puzzle: `(curr_mask-1) & original_mask`. This turns the toggled bits in the mask off iteratively from the rightmost bit to the leftmost bit, while preserving the untoggled bits of the original mask. For example:\\n\\n```text\\nPuzzle: \\'ejkmv\\'\\n                               v\\n          zyxwvutsrqponmlkjihgfedcba\\nOriginal: 00001001001001011000010000\\n-1:       00001001001001011000001111\\n&orig:    00001001001001011000000000\\n                               ^\\nSub-puzzle: \\'jkmv\\'\\n```\\n\\nNote that the first letter of the puzzle has to be included in the words. Hence, to avoid toggling that letter off, we can generate the mask for the first letter and the rest of the puzzle word separately, and perform bitwise-OR afterward.\\n\\n```python\\nclass Solution:\\n    def mask(self, word: str) -> int:\\n        result = 0\\n        for ch in word:\\n            result |= 1 << (ord(ch)-ord(\\'a\\'))\\n        return result\\n\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        word_count = Counter(self.mask(word) for word in words)\\n        result = []\\n        for puzzle in puzzles:\\n            original_mask, first = self.mask(puzzle[1:]), self.mask(puzzle[0])\\n            curr_mask, count = original_mask, word_count[first]\\n            while curr_mask:\\n                count += word_count[curr_mask|first]\\n                curr_mask = (curr_mask-1)&original_mask\\n            result.append(count)\\n        return result\\n```\\n\\n---\\n\\n### Final Result\\n\\n![image](https://assets.leetcode.com/users/images/c0bff39a-c5fb-4691-a662-630239d9666c_1636426457.543878.png)\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Trie",
                    "Bitmask"
                ],
                "code": "```python\\nclass TrieNode:\\n\\t\"\"\"This class represents a node in a Trie.\"\"\"\\n    def __init__(self, ch: Optional[str] = \\'\\'):\\n        self.ch = ch        # denotes the current character\\n        self.count = 0      # denotes how many words end here\\n        self.children = {}  # denotes possible next characters\\n\\nclass Trie:\\n\\t\"\"\"This class represents the Trie itself.\"\"\"\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def add(self, word: str) -> None:\\n\\t\\t\"\"\"Adding words into the Trie in linear time.\"\"\"\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children.keys():\\n                node.children[ch] = TrieNode(ch)\\n            node = node.children[ch]\\n        node.count += 1\\n```\n```python\\nclass Trie:\\n\\t# as per ealier implementation...\\n    def search(self, word: str) -> int:\\n\\t\\t\"\"\"DFS search for all words that are valid based on input.\"\"\"\\n        def dfs(node: TrieNode, found: Optional[bool] = False) -> int:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDFS algo search.\\n\\t\\t\\t:param node:  The current node being searched.\\n\\t\\t\\t:param found: Flag to indicate if the first character has been found (validity criteria).\\n\\t\\t\\t:returns:     The total number of valid words found.\\n\\t\\t\\t\"\"\"\\n            result = node.count*found  # if there are words here, add them only if first character is found\\n            for ch in word:\\n                if ch in node.children.keys():\\n\\t\\t\\t\\t\\t# traverse through all valid next characters to find valid words\\n                    result += dfs(node.children[ch], found or ch == word[0])\\n            return result\\n        return dfs(self.root)\\n```\n```python\\nclass TrieNode:\\n    def __init__(self, ch: Optional[str] = \\'\\'):\\n        self.ch = ch\\n        self.count = 0\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def add(self, word: str) -> None:\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children.keys():\\n                node.children[ch] = TrieNode(ch)\\n            node = node.children[ch]\\n        node.count += 1\\n    \\n    def search(self, word: str) -> int:       \\n        def dfs(node: TrieNode, found: Optional[bool] = False) -> int:\\n            result = node.count*found\\n            for ch in word:\\n                if ch in node.children.keys():\\n                    result += dfs(node.children[ch], found or ch == word[0])\\n            return result\\n        return dfs(self.root)\\n\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        trie = Trie()\\n        for word in words:\\n            trie.add(word)\\n        return [trie.search(word) for word in puzzles]\\n```\n```python\\ndef mask(self, word: str) -> int:\\n\\t\"\"\"Generate mask for a given word.\"\"\"\\n\\tresult = 0\\n\\tfor ch in word:\\n\\t\\tresult |= 1 << (ord(ch)-ord(\\'a\\'))  # [a-z] constraint\\n\\treturn result\\n```\n```text\\nPuzzle: \\'ejkmv\\'\\n                               v\\n          zyxwvutsrqponmlkjihgfedcba\\nOriginal: 00001001001001011000010000\\n-1:       00001001001001011000001111\\n&orig:    00001001001001011000000000\\n                               ^\\nSub-puzzle: \\'jkmv\\'\\n```\n```python\\nclass Solution:\\n    def mask(self, word: str) -> int:\\n        result = 0\\n        for ch in word:\\n            result |= 1 << (ord(ch)-ord(\\'a\\'))\\n        return result\\n\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        word_count = Counter(self.mask(word) for word in words)\\n        result = []\\n        for puzzle in puzzles:\\n            original_mask, first = self.mask(puzzle[1:]), self.mask(puzzle[0])\\n            curr_mask, count = original_mask, word_count[first]\\n            while curr_mask:\\n                count += word_count[curr_mask|first]\\n                curr_mask = (curr_mask-1)&original_mask\\n            result.append(count)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372047,
                "title": "java-short-bit-map-easy-understand-explained",
                "content": "Tricky Problem because of the large test case.\\n1. Create a map: key: 1-25(Characters), value: List of words(Bit Mask) with this Character in it\\n2. Compute every word\\'s bit mask\\n3. Compute every puzzle\\'s bit mask and get the list from map by puzzle\\'s first character, then traverse word mask and do a  `&` operation to check if the puzzle has all the characters the word contains. `count++`\\n```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        Map<Integer, List<Integer>> memo = new HashMap<>();\\n        for (int i = 0; i < 26; i++) {\\n            memo.put(i, new ArrayList<>());\\n        }\\n        for (String word : words) {\\n            int temp = 0;\\n            for (char c : word.toCharArray()) {\\n                temp = temp | (1 << (c - \\'a\\'));\\n            }\\n            for (int i = 0; i < 26; i++) {\\n                if ((temp & (1 << i)) != 0) {\\n                    memo.get(i).add(temp);\\n                }\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (String p : puzzles) {\\n            int temp = 0;\\n            for (char c : p.toCharArray()) {\\n                temp = temp | (1 << (c - \\'a\\'));\\n            }\\n            int c = p.charAt(0) - \\'a\\';\\n            int count = 0;\\n            for (int key : memo.get(c)) {\\n                if ((key & temp) == key) {\\n                    count++;\\n                }\\n            }\\n            res.add(count);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        Map<Integer, List<Integer>> memo = new HashMap<>();\\n        for (int i = 0; i < 26; i++) {\\n            memo.put(i, new ArrayList<>());\\n        }\\n        for (String word : words) {\\n            int temp = 0;\\n            for (char c : word.toCharArray()) {\\n                temp = temp | (1 << (c - \\'a\\'));\\n            }\\n            for (int i = 0; i < 26; i++) {\\n                if ((temp & (1 << i)) != 0) {\\n                    memo.get(i).add(temp);\\n                }\\n            }\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for (String p : puzzles) {\\n            int temp = 0;\\n            for (char c : p.toCharArray()) {\\n                temp = temp | (1 << (c - \\'a\\'));\\n            }\\n            int c = p.charAt(0) - \\'a\\';\\n            int count = 0;\\n            for (int key : memo.get(c)) {\\n                if ((key & temp) == key) {\\n                    count++;\\n                }\\n            }\\n            res.add(count);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 454706,
                "title": "java-trie-139ms",
                "content": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        Trie root = new Trie();\\n        for (String word : words){\\n            char[] cs = word.toCharArray();\\n            Arrays.sort(cs);\\n            StringBuffer sb = new StringBuffer();\\n            sb.append(cs[0]);\\n            for (int i=1;i<cs.length;i++){\\n                if (cs[i]!=cs[i-1])sb.append(cs[i]);\\n            }\\n            addWord(sb.toString(), root);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for (String puzzle : puzzles){\\n            list.add(search(puzzle, root,  \\'a\\'));\\n        }\\n        return list;\\n    }\\n\\n\\n    private int search(String puzzle, Trie cur, char start){\\n        int count = 0;\\n        if (cur.word!=null && cur.word.indexOf(puzzle.charAt(0))!=-1){\\n            count+=cur.count;\\n        }\\n        for (char c = start; c<=\\'z\\';c++){\\n            if (cur.children[c-\\'a\\']!=null && puzzle.indexOf(c)!=-1){\\n                count+=search(puzzle, cur.children[c-\\'a\\'], (char)(c+1));\\n            }\\n        }\\n        return count;\\n    }\\n\\n\\n\\n\\n    private void addWord(String word, Trie root){\\n        Trie cur = root;\\n        for (int i=0;i<word.length();i++){\\n            int j = word.charAt(i)-\\'a\\';\\n            if (cur.children[j]==null){\\n                cur.children[j] = new Trie();\\n            }\\n            cur = cur.children[j];\\n        }\\n        cur.word = word;\\n        cur.count++;\\n    }\\n\\n\\n\\n    class Trie{\\n        Trie[] children = new Trie[26];\\n        String word = null;\\n        int count = 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        Trie root = new Trie();\\n        for (String word : words){\\n            char[] cs = word.toCharArray();\\n            Arrays.sort(cs);\\n            StringBuffer sb = new StringBuffer();\\n            sb.append(cs[0]);\\n            for (int i=1;i<cs.length;i++){\\n                if (cs[i]!=cs[i-1])sb.append(cs[i]);\\n            }\\n            addWord(sb.toString(), root);\\n        }\\n        List<Integer> list = new ArrayList<>();\\n        for (String puzzle : puzzles){\\n            list.add(search(puzzle, root,  \\'a\\'));\\n        }\\n        return list;\\n    }\\n\\n\\n    private int search(String puzzle, Trie cur, char start){\\n        int count = 0;\\n        if (cur.word!=null && cur.word.indexOf(puzzle.charAt(0))!=-1){\\n            count+=cur.count;\\n        }\\n        for (char c = start; c<=\\'z\\';c++){\\n            if (cur.children[c-\\'a\\']!=null && puzzle.indexOf(c)!=-1){\\n                count+=search(puzzle, cur.children[c-\\'a\\'], (char)(c+1));\\n            }\\n        }\\n        return count;\\n    }\\n\\n\\n\\n\\n    private void addWord(String word, Trie root){\\n        Trie cur = root;\\n        for (int i=0;i<word.length();i++){\\n            int j = word.charAt(i)-\\'a\\';\\n            if (cur.children[j]==null){\\n                cur.children[j] = new Trie();\\n            }\\n            cur = cur.children[j];\\n        }\\n        cur.word = word;\\n        cur.count++;\\n    }\\n\\n\\n\\n    class Trie{\\n        Trie[] children = new Trie[26];\\n        String word = null;\\n        int count = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373937,
                "title": "python-trie-method",
                "content": "```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        \\n        #the output list\\n        res = [0] * len(puzzles)\\n        \\n        #set up the trie using dictionary\\n        dic = {}\\n        for word in words:\\n            cur = dic\\n            for letter in sorted(set(word)):\\n                if letter not in cur:\\n                    cur[letter] = {}\\n                cur = cur[letter]\\n            # if only this word contains all the letters along the branch\\n            if \\'*\\' not in cur:\\n                cur[\\'*\\'] = 1\\n                \\n            # if there exists other words that contain all the \\n            # letters along the branch\\n            else:\\n                cur[\\'*\\'] += 1\\n        \\n        # search the trie using depth first search;\\n        # check_head checks whether the first letter of puzzle is in the word\\n        def dfs(dic, i, check_head):\\n            p = puzzles[i]\\n            if \\'*\\' in dic and check_head:\\n                # add the number of words that meet the specification to the                        \\n\\t\\t\\t\\t# corresponding position of puzzle\\n                res[i] += dic[\\'*\\']\\n            for key in dic:\\n                if key in p:\\n                    if p[0] == key or check_head:\\n                        dfs(dic[key], i, True)\\n                    else:\\n                        dfs(dic[key], i, False)\\n            else:\\n                return\\n        \\n        # run dfs for all puzzles\\n        for i in range(len(puzzles)):\\n            dfs(dic, i, False)\\n        \\n        \\n        # return result\\n        return res",
                "solutionTags": [],
                "code": "class Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        \\n        #the output list\\n        res = [0] * len(puzzles)\\n        \\n        #set up the trie using dictionary\\n        dic = {}",
                "codeTag": "Java"
            },
            {
                "id": 371923,
                "title": "c-bit-manipulation-map-do-not-compare-element-wisely",
                "content": "# Analysis\\n\\nThe question asks for the number of words that satisfy the condition for each puzzle. Let `M = words.size(), N = words.size()`. It seems that the time complexity is at least O(MN) without considering the overhead of processing each word/puzzle as one have to verify each pair, but we should seek alternative ways to retrive answer.\\n\\nBefore that, we first think about how should we process these words and puzzles. A brute-force solution is to save whether a character exists in a word/puzzle, which takes a space of O(26(M+N)), and when it comes to verification, one needs O(26) (but it is still a constant) for each pair.\\n\\nTo save memory space, observe that for all 26 alphabets, the status is either `true`(exist) or `false`, and `2^26 < INT_MAX`, so one can use one integer to represent each word. Note that there might exist some words that have the same integer representation, and by using a `map` or `unordered_map` we can potentially reduce the running time. Let `s[i]` denote the number of words of the same integer representation `i`.\\n\\nWe now think about how should we find the solution for each puzzle. Observe that `N <= 10^5` and `M < 10^4`, it is infeasible to use an algorithm of O(MN). Then observe that `puzzles[i].length == 7`, then for each puzzle, there are at most `2^6` feasible integer representation (note the first requirement: `word` contains the first letter of `puzzle`). So eventually, for each puzzle, we can enumerate all feasible integers `i` and sum over all `s[i]`. \\n\\nThe time complexity for processing all words is O(kM) assuming we are using `unordered_map` with time complexity O(1) for each find and add operation, and `k = words[i].length <= 50`, and for find solutions for each word O(mN), where `m= 2^6`. It is a total of O(kM + mN).\\n\\n# Code\\n\\n```c++\\nclass Solution {\\npublic:    \\n    unordered_map<int, int> s;\\n    vector<int> ans;    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<vector<int>> p(26);\\n        const int N = words.size();\\n        const int M = puzzles.size();\\n        ans.resize(M, 0);        \\n        for (int i = 0;i < N; ++i)\\n        {\\n            int k = 0;\\n            int cnt = 0;\\n            for (int j = 0;j < words[i].size(); ++j)\\n            {\\n                if ((k & (1<<(words[i][j]-\\'a\\'))) == 0)\\n                {\\n                    cnt++;\\n                    if (cnt > 7)break;\\n                    k = (k | (1<<(words[i][j]-\\'a\\')));\\n                }\\n            }\\n            if (cnt <= 7){\\n                if (s.find(k) == s.end())\\n                    s[k] = 1;\\n                else\\n                    s[k]++;\\n            }\\n        }\\n        int Q = s.size(), tmp;\\n        for (int i = 0;i < M; ++i)\\n        {\\n            vector<int> all_p;\\n            all_p.push_back(1<<(puzzles[i][0] - \\'a\\'));\\n            for (int j = 0;j < puzzles[i].size(); ++j)\\n            {\\n                int K = all_p.size();\\n                for (int m = 0;m < K; ++m)\\n                    if ((all_p[m] & (1<<(puzzles[i][j] - \\'a\\'))) == 0)\\n                        all_p.push_back(all_p[m] | (1<<(puzzles[i][j] - \\'a\\')));\\n            }\\n            for (int j = 0;j < all_p.size(); ++j)\\n                if (s.find(all_p[j]) != s.end())\\n                    ans[i] += s[all_p[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```c++\\nclass Solution {\\npublic:    \\n    unordered_map<int, int> s;\\n    vector<int> ans;    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<vector<int>> p(26);\\n        const int N = words.size();\\n        const int M = puzzles.size();\\n        ans.resize(M, 0);        \\n        for (int i = 0;i < N; ++i)\\n        {\\n            int k = 0;\\n            int cnt = 0;\\n            for (int j = 0;j < words[i].size(); ++j)\\n            {\\n                if ((k & (1<<(words[i][j]-\\'a\\'))) == 0)\\n                {\\n                    cnt++;\\n                    if (cnt > 7)break;\\n                    k = (k | (1<<(words[i][j]-\\'a\\')));\\n                }\\n            }\\n            if (cnt <= 7){\\n                if (s.find(k) == s.end())\\n                    s[k] = 1;\\n                else\\n                    s[k]++;\\n            }\\n        }\\n        int Q = s.size(), tmp;\\n        for (int i = 0;i < M; ++i)\\n        {\\n            vector<int> all_p;\\n            all_p.push_back(1<<(puzzles[i][0] - \\'a\\'));\\n            for (int j = 0;j < puzzles[i].size(); ++j)\\n            {\\n                int K = all_p.size();\\n                for (int m = 0;m < K; ++m)\\n                    if ((all_p[m] & (1<<(puzzles[i][j] - \\'a\\'))) == 0)\\n                        all_p.push_back(all_p[m] | (1<<(puzzles[i][j] - \\'a\\')));\\n            }\\n            for (int j = 0;j < all_p.size(); ++j)\\n                if (s.find(all_p[j]) != s.end())\\n                    ans[i] += s[all_p[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372110,
                "title": "python-2-liner-w-explanation",
                "content": "* For each puzzle, we want to see its first letter in candidate word.\\n* For each puzzle, maximum length of puzzle is 7. \\n* We can generate all combinations of each puzzle. Each combination should start with puzzle[0] (puzzle[0] + combination of puzzle[1:])\\n* Sort each combination so that we can map with words.\\n* Maximum number of combinations could be C(6, 0) + C(6, 1) + ... + C(6, 6)  = 2 ** 6 = 64 (which is safe)\\n* For each combination of current puzzle, we count how many there are in words. \\n* To do this, we make a counter of each word in words without duplicate character and in sorted order.\\n```\\nfrom itertools import combinations as cb\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        cnt = collections.Counter(\\'\\'.join(sorted(set(w))) for w in words)\\n        return [sum(cnt[\\'\\'.join(sorted(s + (p[0], )))] for l in range(len(p)) for s in cb(p[1:], l)) for p in puzzles]\\n```\\n* Expressive\\n```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        res = []\\n        cnt = collections.Counter(\\'\\'.join(sorted(set(w))) for w in words)\\n        for p in puzzles:\\n            bfs = [p[0]]\\n            for c in p[1:]:\\n                bfs += [s + c for s in bfs]\\n            res.append(sum(cnt[\\'\\'.join(sorted(s))] for s in bfs))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import combinations as cb\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        cnt = collections.Counter(\\'\\'.join(sorted(set(w))) for w in words)\\n        return [sum(cnt[\\'\\'.join(sorted(s + (p[0], )))] for l in range(len(p)) for s in cb(p[1:], l)) for p in puzzles]\\n```\n```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        res = []\\n        cnt = collections.Counter(\\'\\'.join(sorted(set(w))) for w in words)\\n        for p in puzzles:\\n            bfs = [p[0]]\\n            for c in p[1:]:\\n                bfs += [s + c for s in bfs]\\n            res.append(sum(cnt[\\'\\'.join(sorted(s))] for s in bfs))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375212,
                "title": "c-using-bit-manipulation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        // Lengths\\n        int P = puzzles.size();\\n        int W = words.size();\\n        \\n        // Letter masks\\n        vector<int> letterMask(26, 0);\\n        \\n        for (int i = 0, mask = 1; i < 26; ++i, mask <<= 1) {\\n            letterMask[i] = mask;\\n        }\\n        \\n        // Word masks with count info\\n        unordered_map<int, int> wordsMask;\\n        \\n        // For each word\\n        for (int i = 0; i < W; ++i) {\\n            // Compute word mask\\n            int mask = 0;\\n            \\n            for (char c: words[i]) {\\n                mask = mask | letterMask[c - \\'a\\'];\\n            }\\n            \\n            ++wordsMask[mask];\\n        }\\n       \\n         // Result : result[i] => number of words covered by puzzles[i]\\n        vector<int> result(P, 0); \\n        \\n        // For each puzzle\\n        for (int i = 0; i < P; ++i) {\\n            // Compute puzzle mask\\n            int mask = 0;\\n            \\n            for (char c: puzzles[i]) {\\n                mask = mask | letterMask[c - \\'a\\'];\\n            }\\n            \\n            // Iterate through all valid subset of mask i.e. subset of puzzle chars = 2^7 = 64 in count\\n            // This makes the complexity O(P*64)\\n            int subMask = mask;\\n            \\n            while (subMask) {\\n                if ((subMask & letterMask[puzzles[i][0] - \\'a\\']) && wordsMask.count(subMask)) {\\n                    result[i] += wordsMask[subMask];\\n                }\\n                \\n                // Only select valid bits i.e. bits corresponding to chars in puzzle\\n                subMask = (subMask - 1) & mask;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        // Lengths\\n        int P = puzzles.size();\\n        int W = words.size();\\n        \\n        // Letter masks\\n        vector<int> letterMask(26, 0);\\n        \\n        for (int i = 0, mask = 1; i < 26; ++i, mask <<= 1) {\\n            letterMask[i] = mask;\\n        }\\n        \\n        // Word masks with count info\\n        unordered_map<int, int> wordsMask;\\n        \\n        // For each word\\n        for (int i = 0; i < W; ++i) {\\n            // Compute word mask\\n            int mask = 0;\\n            \\n            for (char c: words[i]) {\\n                mask = mask | letterMask[c - \\'a\\'];\\n            }\\n            \\n            ++wordsMask[mask];\\n        }\\n       \\n         // Result : result[i] => number of words covered by puzzles[i]\\n        vector<int> result(P, 0); \\n        \\n        // For each puzzle\\n        for (int i = 0; i < P; ++i) {\\n            // Compute puzzle mask\\n            int mask = 0;\\n            \\n            for (char c: puzzles[i]) {\\n                mask = mask | letterMask[c - \\'a\\'];\\n            }\\n            \\n            // Iterate through all valid subset of mask i.e. subset of puzzle chars = 2^7 = 64 in count\\n            // This makes the complexity O(P*64)\\n            int subMask = mask;\\n            \\n            while (subMask) {\\n                if ((subMask & letterMask[puzzles[i][0] - \\'a\\']) && wordsMask.count(subMask)) {\\n                    result[i] += wordsMask[subMask];\\n                }\\n                \\n                // Only select valid bits i.e. bits corresponding to chars in puzzle\\n                subMask = (subMask - 1) & mask;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562101,
                "title": "javascript-bit-manipulation-map-solution",
                "content": "Looks like no one posted the bit-manipulation solution for js, here is what I wrote by JS:\\n```\\nvar findNumOfValidWords = function(words, puzzles) {\\n    const wordMap = new Map();\\n    const aCharCode = \\'a\\'.charCodeAt(0);\\n    words.forEach(word => {\\n        let mask = 0;\\n        for (let i = 0; i < word.length; i++) {\\n            mask |= (1 << (word.charCodeAt(i) - aCharCode));\\n        }\\n        if (wordMap.has(mask)) {\\n            wordMap.set(mask, wordMap.get(mask) + 1);\\n        } else {\\n            wordMap.set(mask, 1);\\n        }\\n    });\\n\\n    const result = [];\\n    for (let i = 0; i < puzzles.length; i++) {\\n        result.push(0);\\n        let curMask = 0;\\n        for (let j = 0; j < puzzles[i].length; j++) {\\n            curMask |= (1 << (puzzles[i].charCodeAt(j) - aCharCode));\\n        }\\n        const firstLetter = 1 << (puzzles[i].charCodeAt(0) - aCharCode);\\n        \\n        let start = curMask;\\n        while (start > 0) {\\n            if ((start & firstLetter) === firstLetter && wordMap.has(start)) {\\n                result[i] += wordMap.get(start);\\n            }\\n            \\n            start = (start - 1) & curMask\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nvar findNumOfValidWords = function(words, puzzles) {\\n    const wordMap = new Map();\\n    const aCharCode = \\'a\\'.charCodeAt(0);\\n    words.forEach(word => {\\n        let mask = 0;\\n        for (let i = 0; i < word.length; i++) {\\n            mask |= (1 << (word.charCodeAt(i) - aCharCode));\\n        }\\n        if (wordMap.has(mask)) {\\n            wordMap.set(mask, wordMap.get(mask) + 1);\\n        } else {\\n            wordMap.set(mask, 1);\\n        }\\n    });\\n\\n    const result = [];\\n    for (let i = 0; i < puzzles.length; i++) {\\n        result.push(0);\\n        let curMask = 0;\\n        for (let j = 0; j < puzzles[i].length; j++) {\\n            curMask |= (1 << (puzzles[i].charCodeAt(j) - aCharCode));\\n        }\\n        const firstLetter = 1 << (puzzles[i].charCodeAt(0) - aCharCode);\\n        \\n        let start = curMask;\\n        while (start > 0) {\\n            if ((start & firstLetter) === firstLetter && wordMap.has(start)) {\\n                result[i] += wordMap.get(start);\\n            }\\n            \\n            start = (start - 1) & curMask\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1480187,
                "title": "c-bit-manipulation-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<char,vector<int>> map; //to store mask of each char in the word\\n\\t\\t\\n        for(string word:words){\\n            int mask = 0; //calculate mask\\n            for(char ch:word){\\n                int bit = ch-\\'a\\';\\n                mask = mask | (1<<bit);\\n            }\\n            set<char> unique;  /* to store only unique values, here we are storing the mask in every char that starts with ch, we are precalculating \\n\\t\\t\\tit to avoid it calculating the mask for every character every time (if we do this then we are repeating some tasks, hence pre-store \\n\\t\\t\\tthe mask for all words that starts with a char in puzzle*/\\n\\t\\t\\t\\n            for(char ch : word){\\n                if(unique.find(ch)!=unique.end())continue;\\n                unique.insert(ch);\\n                map[ch].push_back(mask);\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for(string puzzle:puzzles){\\n            int pmask = 0;\\n            for(char ch:puzzle){\\n                int bit = ch-\\'a\\';\\n                pmask = pmask | (1<<bit);\\n            }\\n            char firstchar = puzzle[0];\\n            int count = 0;\\n            vector<int> wordsToCheck = map[firstchar]; //fetch all the word masks that have first char in puzzle\\n            for(int wmask : wordsToCheck){\\n                if((wmask & pmask) == wmask)count++; //if all the chars of word are present in puzzle then & of wmask and pmask will be equal to mask of word, i.e wmask.\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<char,vector<int>> map; //to store mask of each char in the word\\n\\t\\t\\n        for(string word:words){\\n            int mask = 0; //calculate mask\\n            for(char ch:word){\\n                int bit = ch-\\'a\\';\\n                mask = mask | (1<<bit);\\n            }\\n            set<char> unique;  /* to store only unique values, here we are storing the mask in every char that starts with ch, we are precalculating \\n\\t\\t\\tit to avoid it calculating the mask for every character every time (if we do this then we are repeating some tasks, hence pre-store \\n\\t\\t\\tthe mask for all words that starts with a char in puzzle*/\\n\\t\\t\\t\\n            for(char ch : word){\\n                if(unique.find(ch)!=unique.end())continue;\\n                unique.insert(ch);\\n                map[ch].push_back(mask);\\n            }\\n        }\\n        \\n        vector<int> res;\\n        for(string puzzle:puzzles){\\n            int pmask = 0;\\n            for(char ch:puzzle){\\n                int bit = ch-\\'a\\';\\n                pmask = pmask | (1<<bit);\\n            }\\n            char firstchar = puzzle[0];\\n            int count = 0;\\n            vector<int> wordsToCheck = map[firstchar]; //fetch all the word masks that have first char in puzzle\\n            for(int wmask : wordsToCheck){\\n                if((wmask & pmask) == wmask)count++; //if all the chars of word are present in puzzle then & of wmask and pmask will be equal to mask of word, i.e wmask.\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371838,
                "title": "leetcode-weekly-contest-152-screencast",
                "content": "https://www.youtube.com/watch?v=C9FYBX-j61s",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=C9FYBX-j61s",
                "codeTag": "Unknown"
            },
            {
                "id": 1567964,
                "title": "c-clean-solution-with-explanation",
                "content": "Thanks in Advance for refering to my solution :)\\n\\nFirst let us understand what a bitmask or mask is...\\n* A bitmask stores states of multiple values as bits( 0 - false & 1 - true )\\n* For instance if a word is : \"face\" and we want to check what all alphabets the word contains we can either do it by using a map where each value corresponds to a key. But this would waste a lot of space if there are many words( 1 map for each word).\\n* Ergo, we use bitmasks which are integers storing the state of the variables. \\n* For the given word, the mask is : \\'110101\\' (indexing starting from right).\\n\\nSo, for this problem we can use Bit Masking.\\n\\nHere we create a map which stores the frequences of all the bitmasks of all the words (in the \\'words\\' array).\\n\\n**How to check if a word  has same letters as a puzzle**\\nDo AND(&) operation between mask(word) and mask(puzzle). \\nIf the result is equal to the word, then the word has only those letters that are in the puzzle.\\n**How to check if the word has the first letter of puzzle**\\nDo AND(&) operation between ```(1<<(p[0]-\\'a\\')``` and the word. If the result is not zero then the word contains the first letter of puzzle.\\n\\n**Approach:**\\n1) Create a map freq which stores the frequencies of the masks of all the words.\\n2) Mask all the words and store the frequencies of masks in the map.\\n3) Now loop through \\'puzzles\\' and compute the mask of each puzzle. Store it in \\'mask\\'.\\n4) Since looping through thw whole array of words is time-consuming, we\\'re gonna take advantage of the fact that each puzzle contains only 7 letters and make different combinations of masks of each puzzle, do \\'&\\' operation between the submasks and ```(1<<(puzzle[0]-\\'a\\'))``` and increase the count of words that satisfy the conditions accordingly.\\n5) Finally we add all the counts to a vector and return the vector.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int maskWord(string word) {  \\n        int mask = 0;\\n        for(auto ch : word) mask |= 1 << (ch-\\'a\\');  //sets the bit correspoding to each letter of the                                                                           //word in the mask\\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> freq;  //map to store the frequencies of masks of words\\n        for(auto word : words) freq[(maskWord(word))]++;\\n\\t\\t\\n        vector<int> ans; //final answer that stores the counts of matching words\\n        \\n        for (auto puzzle : puzzles) {\\n            int mask = maskWord(puzzle), submask = mask, //we try different combinations of                                                                                                 //submasks \\n            first = (1 << puzzle[0]-\\'a\\'), count = 0;\\n            \\n            while(submask) {\\n                if(submask&first) count+=freq[submask];\\n                \\n                submask = mask&(submask-1);\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n \\nPlease upvote, if you like my solution and explanation. And please comment if there are any mistakes or suggestions.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```(1<<(p[0]-\\'a\\')```\n```(1<<(puzzle[0]-\\'a\\'))```\n```\\nclass Solution {\\npublic:\\n    int maskWord(string word) {  \\n        int mask = 0;\\n        for(auto ch : word) mask |= 1 << (ch-\\'a\\');  //sets the bit correspoding to each letter of the                                                                           //word in the mask\\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> freq;  //map to store the frequencies of masks of words\\n        for(auto word : words) freq[(maskWord(word))]++;\\n\\t\\t\\n        vector<int> ans; //final answer that stores the counts of matching words\\n        \\n        for (auto puzzle : puzzles) {\\n            int mask = maskWord(puzzle), submask = mask, //we try different combinations of                                                                                                 //submasks \\n            first = (1 << puzzle[0]-\\'a\\'), count = 0;\\n            \\n            while(submask) {\\n                if(submask&first) count+=freq[submask];\\n                \\n                submask = mask&(submask-1);\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991296,
                "title": "python-26-tries",
                "content": "**Approach:**\\n\\nMake an array (```trees```) of 26 Tries where ```trees[0]``` is a Trie that only \\nhas words that contain the letter \"a\" and ```trees[25]``` is a Trie \\nthat only has words that contain the letter \"z\". \\n\\n<details>\\n\\n<summary><b>Why?</b> (click to show)</summary>\\n\\n*This step is taken because the first letter of puzzle must appear in word\\nso we want to group words that contain a specific letter:* ```puzzle[0]```\\n\\n</details>\\n\\nNext convert all words to a sorted set: \"badfad\" -> [\\'a\\', \\'b\\', \\'d\\', \\'f\\']\\nAnd insert the sorted set into trees[0], trees[1], trees[3], and trees[5]\\nbecause word contains the 1<sup>st</sup>, 2<sup>nd</sup>, 4<sup>th</sup>, and 6<sup>th</sup> letter of the alphabet.\\n\\n<details>\\n\\n<summary><b>Why?</b> (click to show)</summary>\\n\\n*The second condition in the problem description allows us to reuse \\nletters from puzzle when checking if word is in puzzle.  Since the\\nword \"aaaaaaaaaaa\" is a subset of puzzle \"a\" we can reduce \\neach word to a set.\\n\\n*The second thing to notice is that we sort the set.  This is not\\na necessary step, but it is an optimization.  By sorting set(word) we\\nsignificantly reduce the size of each Trie because there is a higher\\nprobability of two words sharing the same node(s) in the Trie.*\\n\\n</details>\\n\\nLastly, for each puzzle perform a DFS in ```trees[ord(puzzle[0]) - 97]``` to find out\\nhow many words are a subset of that puzzle.\\n\\n<details>\\n\\n<summary><b>Notes:</b> (click to show)</summary> \\n\\n*```ord(puzzle[0]) - 97``` is used because the integer representation of \"a\"\\nis 97 (ord(\"a\") = 97) and the integer representation of \"z\" is 122. So the \\nminus 97 maps \"a\" to 0 and \"z\" to 25.*\\n\\n*We only perform a DFS search on ```trees[puzzle[0]]``` because this\\nTrie only consists of words that contain puzzle[0] as a letter.*\\n\\n*When inserting words into a Trie, we mark the end of a word by\\nincrementing node.tail by 1.  This is because we may have multiple\\nwords that are the same when doing sorted(set(word)).  Furthermore\\nthis allows us to count how many words are a subset of puzzle\\nby adding node.tail as we traverse the Trie.*\\n\\n</details>\\n\\n<br>\\n\\n```python\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        words = [sorted(set(w)) for w in words]\\n        puzzles = [(p[0], set(p)) for p in puzzles]\\n        trees = [Trie() for _ in range(26)]\\n        for w in words:\\n            for char in w:\\n                trees[ord(char) - 97].insert(w)\\n        return [trees[ord(f) - 97].puzzle_match(p) for f,p in puzzles]\\n\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.tail = 0\\n        \\nclass Trie(object):\\n    def __init__(self):\\n        self.root = Node(None)\\n        \\n    def insert(self, word):\\n        curr = self.root\\n        for char in word:\\n            if char not in curr.children:\\n                curr.children[char] = Node(char)\\n            curr = curr.children[char]\\n        curr.tail += 1\\n        \\n    def puzzle_match(self, puzzle):\\n        def helper(node):\\n            nonlocal res\\n            res += node.tail\\n            for child in node.children:\\n                if child in puzzle:\\n                    helper(node.children[child])\\n        res = 0\\n        helper(self.root)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```trees```\n```trees[0]```\n```trees[25]```\n```puzzle[0]```\n```trees[ord(puzzle[0]) - 97]```\n```ord(puzzle[0]) - 97```\n```trees[puzzle[0]]```\n```python\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        words = [sorted(set(w)) for w in words]\\n        puzzles = [(p[0], set(p)) for p in puzzles]\\n        trees = [Trie() for _ in range(26)]\\n        for w in words:\\n            for char in w:\\n                trees[ord(char) - 97].insert(w)\\n        return [trees[ord(f) - 97].puzzle_match(p) for f,p in puzzles]\\n\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.tail = 0\\n        \\nclass Trie(object):\\n    def __init__(self):\\n        self.root = Node(None)\\n        \\n    def insert(self, word):\\n        curr = self.root\\n        for char in word:\\n            if char not in curr.children:\\n                curr.children[char] = Node(char)\\n            curr = curr.children[char]\\n        curr.tail += 1\\n        \\n    def puzzle_match(self, puzzle):\\n        def helper(node):\\n            nonlocal res\\n            res += node.tail\\n            for child in node.children:\\n                if child in puzzle:\\n                    helper(node.children[child])\\n        res = 0\\n        helper(self.root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372747,
                "title": "enumerating-all-submasks-of-a-given-mask",
                "content": "For people who gets TLEs or does not get why other posts\\' solutions work, hope this short explanation can help. \\n\\n##### How to generate all submasks of a given mask? \\n\\nGiven a bitmask *m* of a puzzle string, to find all its submasks, simply do:\\n\\n```\\nint sub = m;\\nwhile (sub > 0) {\\n\\tsub = (sub - 1) & m;\\n}\\n```\\n\\nFor why does this work please follow this link of an awesome explanation: \\nhttps://cp-algorithms.com/algebra/all-submasks.html\\n\\n##### Why do we do this?\\n\\nOne of the brute force ways of checking which word is valid might be looping through the entire collection like this:\\n\\n```\\n\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> lst = new ArrayList<>();\\n        for (String s : words) {\\n            int mask = 0;\\n            for (char c : s.toCharArray()) {\\n                mask |= (1 << (c - \\'a\\'));\\n            }\\n            map.put(mask, map.getOrDefault(mask, 0) + 1);\\n        }\\n        for (String s : puzzles) {\\n            int mask = 0;\\n            for (char c : s.toCharArray()) {\\n                mask |= (1 << (c - \\'a\\'));\\n            } \\n            int first = (1 << (s.charAt(0) - \\'a\\'));\\n            int res = 0;\\n            for (int w : map.keySet()) { // looping through the whole map\\n                if (Integer.bitCount(w) > s.length()) continue;\\n                if ((w & first) == first) {\\n                    if ((w & mask) == w) {\\n                        res += map.get(w);\\n                    }\\n                }\\n            }\\n            lst.add(res);\\n        }\\n        return lst;\\n    }\\n```\\nThis would get TLE for large test cases because \\n\\n*1 <= words.length <= 10^5*\\n\\nwhich means there could be 10^5 keys in the map and the loop could run 10^5 times.\\n\\nHowever, if we visit all submasks of a puzzle word mask mentioned above, since \\n\\n*puzzles[i].length == 7*\\n\\nat worst case the loop will only run 2^7 times, which significantly reduce the runtime.\\n\\n##### Lessons\\n1. Take advantage of the input data range to make optimizations (as hint 1 suggests).\\n2. Methods to generate submask of a given mask \\n\\nPlease let me know if there\\'s any mistake!\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nint sub = m;\\nwhile (sub > 0) {\\n\\tsub = (sub - 1) & m;\\n}\\n```\n```\\n\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> lst = new ArrayList<>();\\n        for (String s : words) {\\n            int mask = 0;\\n            for (char c : s.toCharArray()) {\\n                mask |= (1 << (c - \\'a\\'));\\n            }\\n            map.put(mask, map.getOrDefault(mask, 0) + 1);\\n        }\\n        for (String s : puzzles) {\\n            int mask = 0;\\n            for (char c : s.toCharArray()) {\\n                mask |= (1 << (c - \\'a\\'));\\n            } \\n            int first = (1 << (s.charAt(0) - \\'a\\'));\\n            int res = 0;\\n            for (int w : map.keySet()) { // looping through the whole map\\n                if (Integer.bitCount(w) > s.length()) continue;\\n                if ((w & first) == first) {\\n                    if ((w & mask) == w) {\\n                        res += map.get(w);\\n                    }\\n                }\\n            }\\n            lst.add(res);\\n        }\\n        return lst;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1567448,
                "title": "c-version-of-the-trie-approach-in-solution",
                "content": "```\\npublic class Solution {\\n    class TrieNode{\\n        public TrieNode[] nodes;\\n        public int wordCount;\\n        public TrieNode(){\\n            nodes = new TrieNode[26];\\n            wordCount = 0;\\n        }\\n    }\\n    \\n    public IList<int> FindNumOfValidWords(string[] words, string[] puzzles) {\\n        TrieNode root = new TrieNode();\\n        foreach(var word in words){\\n            TrieNode curr = root;\\n            foreach(var c in word){\\n                if(curr.nodes[c - \\'a\\'] == null)\\n                    curr.nodes[c - \\'a\\'] = new TrieNode();\\n                curr = curr.nodes[c - \\'a\\'];\\n            }\\n            curr.wordCount++;\\n        }\\n        List<int> result = new List<int>();\\n        foreach(var puzzle in puzzles){\\n            result.Add(DFS(root, puzzle, false));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int DFS(TrieNode node, string puzzle, bool hasFirst){\\n        int result = hasFirst ? node.wordCount : 0;\\n        foreach(var c in puzzle){\\n            if(node.nodes[c - \\'a\\'] != null)\\n                result += DFS(node.nodes[c - \\'a\\'], puzzle, hasFirst || c == puzzle[0]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class TrieNode{\\n        public TrieNode[] nodes;\\n        public int wordCount;\\n        public TrieNode(){\\n            nodes = new TrieNode[26];\\n            wordCount = 0;\\n        }\\n    }\\n    \\n    public IList<int> FindNumOfValidWords(string[] words, string[] puzzles) {\\n        TrieNode root = new TrieNode();\\n        foreach(var word in words){\\n            TrieNode curr = root;\\n            foreach(var c in word){\\n                if(curr.nodes[c - \\'a\\'] == null)\\n                    curr.nodes[c - \\'a\\'] = new TrieNode();\\n                curr = curr.nodes[c - \\'a\\'];\\n            }\\n            curr.wordCount++;\\n        }\\n        List<int> result = new List<int>();\\n        foreach(var puzzle in puzzles){\\n            result.Add(DFS(root, puzzle, false));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int DFS(TrieNode node, string puzzle, bool hasFirst){\\n        int result = hasFirst ? node.wordCount : 0;\\n        foreach(var c in puzzle){\\n            if(node.nodes[c - \\'a\\'] != null)\\n                result += DFS(node.nodes[c - \\'a\\'], puzzle, hasFirst || c == puzzle[0]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274934,
                "title": "java-concise-trie-solution",
                "content": "```java\\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        Trie trie = new Trie();\\n        for (String w : words) {\\n            boolean[] letters = toLetters(w);\\n            Trie node = trie;\\n            for (int i = 0; i < letters.length; i++)\\n                if (letters[i])\\n                    node = node.children[i] == null ? (node.children[i] = new Trie()) : node.children[i];\\n            node.n++;\\n        }\\n        return Arrays.stream(puzzles).map(p -> count(trie, p.charAt(0) - \\'a\\', toLetters(p), new boolean[26])).collect(Collectors.toList());\\n    }\\n\\n    int count(Trie node, int puzzleFirstLetter, boolean[] puzzleLetters, boolean[] wordLetters) {\\n        int count = wordLetters[puzzleFirstLetter] ? node.n : 0;\\n        for (int i = 0; i < node.children.length; i++)\\n            if (node.children[i] != null && puzzleLetters[i]) {\\n                wordLetters[i] = true;\\n                count += count(node.children[i], puzzleFirstLetter, puzzleLetters, wordLetters);\\n                wordLetters[i] = false;\\n            }\\n        return count;\\n    }\\n\\n    boolean[] toLetters(String w) {\\n        boolean[] letters = new boolean[26];\\n        w.chars().forEach(c -> letters[c - \\'a\\'] = true);\\n        return letters;\\n    }\\n\\n    class Trie {\\n        final Trie[] children = new Trie[26];\\n        int n;\\n    }\\n",
                "solutionTags": [],
                "code": "```java\\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        Trie trie = new Trie();\\n        for (String w : words) {\\n            boolean[] letters = toLetters(w);\\n            Trie node = trie;\\n            for (int i = 0; i < letters.length; i++)\\n                if (letters[i])\\n                    node = node.children[i] == null ? (node.children[i] = new Trie()) : node.children[i];\\n            node.n++;\\n        }\\n        return Arrays.stream(puzzles).map(p -> count(trie, p.charAt(0) - \\'a\\', toLetters(p), new boolean[26])).collect(Collectors.toList());\\n    }\\n\\n    int count(Trie node, int puzzleFirstLetter, boolean[] puzzleLetters, boolean[] wordLetters) {\\n        int count = wordLetters[puzzleFirstLetter] ? node.n : 0;\\n        for (int i = 0; i < node.children.length; i++)\\n            if (node.children[i] != null && puzzleLetters[i]) {\\n                wordLetters[i] = true;\\n                count += count(node.children[i], puzzleFirstLetter, puzzleLetters, wordLetters);\\n                wordLetters[i] = false;\\n            }\\n        return count;\\n    }\\n\\n    boolean[] toLetters(String w) {\\n        boolean[] letters = new boolean[26];\\n        w.chars().forEach(c -> letters[c - \\'a\\'] = true);\\n        return letters;\\n    }\\n\\n    class Trie {\\n        final Trie[] children = new Trie[26];\\n        int n;\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 372368,
                "title": "concise-python-trie-solution",
                "content": "```python\\ndef findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n\\tNode = lambda: collections.defaultdict(Node)\\n\\ttrie = Node()\\n\\tfor w in words:\\n\\t\\tnode = functools.reduce(dict.__getitem__, sorted(set(w)), trie)\\n\\t\\t# use key 0 to store counts\\n\\t\\tnode[0] = node.get(0, 0) + 1\\n\\n\\tdef dfs(p, node=trie, collect=False):\\n\\t\\tif not node:\\n\\t\\t\\treturn 0\\n\\t\\tans = node.get(0, 0) if collect else 0\\n\\t\\t# iter all possible chars            \\n\\t\\tfor c in p:\\n\\t\\t\\tif c in node:\\n\\t\\t\\t\\t# start to collect if we see the first char of puzzle\\n\\t\\t\\t\\tans += dfs(p, node[c], collect or c == p[0])\\n\\t\\treturn ans\\n\\n\\treturn [dfs(p) for p in puzzles]\\n```\\n\\nI learned the trie solution from https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/discuss/371876/Detailed-Explanation-using-Trie-O(word_length-%2B-100*puzzle_length), and implemented it more concisely with python.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```python\\ndef findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n\\tNode = lambda: collections.defaultdict(Node)\\n\\ttrie = Node()\\n\\tfor w in words:\\n\\t\\tnode = functools.reduce(dict.__getitem__, sorted(set(w)), trie)\\n\\t\\t# use key 0 to store counts\\n\\t\\tnode[0] = node.get(0, 0) + 1\\n\\n\\tdef dfs(p, node=trie, collect=False):\\n\\t\\tif not node:\\n\\t\\t\\treturn 0\\n\\t\\tans = node.get(0, 0) if collect else 0\\n\\t\\t# iter all possible chars            \\n\\t\\tfor c in p:\\n\\t\\t\\tif c in node:\\n\\t\\t\\t\\t# start to collect if we see the first char of puzzle\\n\\t\\t\\t\\tans += dfs(p, node[c], collect or c == p[0])\\n\\t\\treturn ans\\n\\n\\treturn [dfs(p) for p in puzzles]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 372003,
                "title": "python-no-need-for-bit-operation-o-2-6-n-instead-of-o-7-m-n",
                "content": "Notice that for each puzzle, we can check in two ways:\\n1. check all the words (10^5 )\\n2. generate all possible words that solve this puzzle, and sum them (2^6 )\\n```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        words = [frozenset(word) for word in words if len(set(word)) <= 7]\\n        cnt = collections.Counter(words)\\n        res = []            \\n        for p in puzzles:\\n            pre = (p[0],)\\n            t = set(p[1:])\\n            tmp = 0\\n            for i in range(len(t)+1):\\n                for c in itertools.combinations(t, i):\\n                    tmp += cnt[frozenset(pre+c)]\\n            res += [tmp]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        words = [frozenset(word) for word in words if len(set(word)) <= 7]\\n        cnt = collections.Counter(words)\\n        res = []            \\n        for p in puzzles:\\n            pre = (p[0],)\\n            t = set(p[1:])\\n            tmp = 0\\n            for i in range(len(t)+1):\\n                for c in itertools.combinations(t, i):\\n                    tmp += cnt[frozenset(pre+c)]\\n            res += [tmp]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1964853,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n    class Solution {\\n\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(String w : words){\\n            int mask = 0;\\n            for(int i = 0; i < w.length(); i++){\\n                mask |= 1 << (w.charAt(i) - \\'a\\');\\n            }\\n            map.put(mask, map.getOrDefault(mask, 0) + 1);\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(String p : puzzles){\\n            int mask = 0;\\n            for(int i = 0; i < p.length(); i++){\\n                mask |= 1 << (p.charAt(i) - \\'a\\');\\n            }\\n            int c = 0;\\n            int sub = mask;\\n            int first = 1 << (p.charAt(0) - \\'a\\');\\n            while(true){\\n                if((sub & first) == first && map.containsKey(sub)){\\n                    c += map.get(sub);\\n                }\\n                \\n                if(sub == 0) break;\\n                \\n                sub = (sub - 1) & mask; // get the next substring\\n            }\\n            \\n            res.add(c);\\n        }\\n        \\n        return res;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        for(String w : words){\\n            int mask = 0;\\n            for(int i = 0; i < w.length(); i++){\\n                mask |= 1 << (w.charAt(i) - \\'a\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1567787,
                "title": "python-dfs-from-the-na-ve-solution-to-trie-dfs",
                "content": "Without using the Trie, just using word set to check... It can pass 9 cases but not the last one.\\n```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        words = [sorted(set(w)) for w in words]\\n        puzzles = [(p[0], set(p)) for p in puzzles]\\n        \\n        dic = defaultdict(list)\\n        for w in words:\\n            for c in w:\\n                dic[c].append(w)\\n\\n        rsts = []\\n        for f, puzzle in puzzles:\\n            rst = 0\\n            print(puzzle, dic[f])\\n            for w in dic[f]:\\n                if all([(c in puzzle) for c in w]):\\n                    rst+=1\\n            rsts.append(rst)\\n            break\\n        return rsts\\n```\\n\\nTo improve it, using Trie. \\n1.  First create the dictionary of each possible first letter of Trie Tree. \\n2. Then do DFS, and for each path of the node if the  Letter (k in the code) is not in the puzzle stop the path.\\n\\n```\\nclass TrieNode:\\n    # Trie node class\\n    def __init__(self, val):\\n        self.val=val\\n        self.children = {}\\n        self.nums= 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(None)\\n\\n    def insert(self, word):\\n        p=self.root\\n        for c in word:\\n            if c not in p.children:\\n                p.children[c] = TrieNode(c)\\n            p = p.children[c]\\n        p.nums += 1\\n    \\n    def search(self, puzzle):\\n        def dfs(node):\\n            rst=0\\n            rst += node.nums\\n            for k, nodec in node.children.items():\\n                if k in puzzle:\\n                    rst+=dfs(nodec)\\n            return rst\\n        return dfs(self.root)\\n\\n\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        words = [sorted(set(w)) for w in words]\\n        puzzles = [(p[0], set(p)) for p in puzzles]\\n        \\n        dic = defaultdict(Trie)\\n        for w in words:\\n            for c in w:\\n                dic[c].insert(w)\\n\\n        rsts = []\\n        for f, puzzle in puzzles:\\n            rst = 0\\n            rsts.append(dic[f].search(puzzle))\\n            \\n        return rsts\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        words = [sorted(set(w)) for w in words]\\n        puzzles = [(p[0], set(p)) for p in puzzles]\\n        \\n        dic = defaultdict(list)\\n        for w in words:\\n            for c in w:\\n                dic[c].append(w)\\n\\n        rsts = []\\n        for f, puzzle in puzzles:\\n            rst = 0\\n            print(puzzle, dic[f])\\n            for w in dic[f]:\\n                if all([(c in puzzle) for c in w]):\\n                    rst+=1\\n            rsts.append(rst)\\n            break\\n        return rsts\\n```\n```\\nclass TrieNode:\\n    # Trie node class\\n    def __init__(self, val):\\n        self.val=val\\n        self.children = {}\\n        self.nums= 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(None)\\n\\n    def insert(self, word):\\n        p=self.root\\n        for c in word:\\n            if c not in p.children:\\n                p.children[c] = TrieNode(c)\\n            p = p.children[c]\\n        p.nums += 1\\n    \\n    def search(self, puzzle):\\n        def dfs(node):\\n            rst=0\\n            rst += node.nums\\n            for k, nodec in node.children.items():\\n                if k in puzzle:\\n                    rst+=dfs(nodec)\\n            return rst\\n        return dfs(self.root)\\n\\n\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        words = [sorted(set(w)) for w in words]\\n        puzzles = [(p[0], set(p)) for p in puzzles]\\n        \\n        dic = defaultdict(Trie)\\n        for w in words:\\n            for c in w:\\n                dic[c].insert(w)\\n\\n        rsts = []\\n        for f, puzzle in puzzles:\\n            rst = 0\\n            rsts.append(dic[f].search(puzzle))\\n            \\n        return rsts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567547,
                "title": "approach-using-trie-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<int> FindNumOfValidWords(string[] words, string[] puzzles) {        \\n        // Add words to the Trie\\n        var trie = new Trie();          \\n        foreach (var word in words) {\\n            // Get distinct characters in the word and sort it\\n            var chars = word.Distinct().ToArray();\\n            \\n            // Longer words are never valid\\n            if (chars.Length <= 7) {\\n                Array.Sort(chars);\\n                trie.Insert(new String(chars));\\n            }\\n        }\\n        \\n        // Check how many words in the puzzle match in the Trie\\n        var result = new List<int>();\\n        foreach (var word in puzzles) {\\n            result.Add(trie.Search(word));\\n        }        \\n        return result;\\n    }  \\n    \\n    // Trie\\n    public class Trie {\\n        private TrieNode root;\\n        \\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n        public void Insert(string word) {\\n            var node = root;\\n            foreach (var ch in word) {\\n                if (!node.ContainsKey(ch)) {\\n                    node.Add(ch, new TrieNode());\\n                }\\n                node = node.Get(ch);\\n            }\\n            node.SetComplete();\\n        }\\n        public int Search(string word) {\\n            return DFS(root, word, false);\\n        }        \\n        private int DFS(TrieNode node, string word, bool firstFound) {\\n            var result = firstFound ? node.WordCount() : 0;\\n            foreach (var ch in word) {\\n                if (node.ContainsKey(ch)) {\\n                    result += DFS(node.Get(ch), word, firstFound || ch == word[0]);\\n                }\\n            }\\n            return result;\\n        }\\n    }\\n\\n    // TrieNode\\n    class TrieNode {\\n        private Dictionary<char, TrieNode> children;\\n        private bool isComplete;\\n        private int count;\\n        \\n        public TrieNode() {\\n            children = new Dictionary<char, TrieNode>();\\n        }\\n        public bool ContainsKey(char ch) {\\n            return children.ContainsKey(ch);\\n        }\\n        public TrieNode Get(char ch) {\\n            return children[ch];\\n        }\\n        public void Add(char ch, TrieNode node) {\\n            children[ch] = node;\\n        }\\n        public void SetComplete() {\\n            isComplete = true;\\n            ++count;\\n        }\\n        public bool IsComplete() {\\n            return isComplete;\\n        }\\n        public int WordCount() {\\n            return count;\\n        }\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindNumOfValidWords(string[] words, string[] puzzles) {        \\n        // Add words to the Trie\\n        var trie = new Trie();          \\n        foreach (var word in words) {\\n            // Get distinct characters in the word and sort it\\n            var chars = word.Distinct().ToArray();\\n            \\n            // Longer words are never valid\\n            if (chars.Length <= 7) {\\n                Array.Sort(chars);\\n                trie.Insert(new String(chars));\\n            }\\n        }\\n        \\n        // Check how many words in the puzzle match in the Trie\\n        var result = new List<int>();\\n        foreach (var word in puzzles) {\\n            result.Add(trie.Search(word));\\n        }        \\n        return result;\\n    }  \\n    \\n    // Trie\\n    public class Trie {\\n        private TrieNode root;\\n        \\n        public Trie() {\\n            root = new TrieNode();\\n        }\\n        public void Insert(string word) {\\n            var node = root;\\n            foreach (var ch in word) {\\n                if (!node.ContainsKey(ch)) {\\n                    node.Add(ch, new TrieNode());\\n                }\\n                node = node.Get(ch);\\n            }\\n            node.SetComplete();\\n        }\\n        public int Search(string word) {\\n            return DFS(root, word, false);\\n        }        \\n        private int DFS(TrieNode node, string word, bool firstFound) {\\n            var result = firstFound ? node.WordCount() : 0;\\n            foreach (var ch in word) {\\n                if (node.ContainsKey(ch)) {\\n                    result += DFS(node.Get(ch), word, firstFound || ch == word[0]);\\n                }\\n            }\\n            return result;\\n        }\\n    }\\n\\n    // TrieNode\\n    class TrieNode {\\n        private Dictionary<char, TrieNode> children;\\n        private bool isComplete;\\n        private int count;\\n        \\n        public TrieNode() {\\n            children = new Dictionary<char, TrieNode>();\\n        }\\n        public bool ContainsKey(char ch) {\\n            return children.ContainsKey(ch);\\n        }\\n        public TrieNode Get(char ch) {\\n            return children[ch];\\n        }\\n        public void Add(char ch, TrieNode node) {\\n            children[ch] = node;\\n        }\\n        public void SetComplete() {\\n            isComplete = true;\\n            ++count;\\n        }\\n        public bool IsComplete() {\\n            return isComplete;\\n        }\\n        public int WordCount() {\\n            return count;\\n        }\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246459,
                "title": "c-using-bit-mask-and-hashmap-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        /*\\n        map ->\\n        a== mask of( aaaa , able , ability , actt,actor,access)\\n        b== mask of( able , ability)\\n        c== so on\\n        \\n        using set to not pushing mask again if char repeats like aaaa , a is repeating.\\n        \\n        again make mask of every puzzle word.\\n        \\n        take the mask vector of the first char of puzzleword.\\n        \\n        check if the puzzle also contains the word by using & operator.\\n        \\n         */\\n        vector<int> ans;\\n        \\n        unordered_map<char,vector<int>> m;\\n        //Map to store map of every word from vector words.\\n       \\n        for(string word : words){\\n            //calculating mask of every word\\n            int mask =0;\\n            for(char ch : word){\\n                int bit = ch - \\'a\\';\\n                mask = mask | (1<<bit);\\n                \\n            }\\n            \\n            set <char> unique;\\n            //Here we are using set to not add the mask again if the word will come again.\\n            for(char ch : word){\\n                if(unique.count(ch))continue;\\n                //pushing the mask into the map.\\n                m[ch].push_back(mask);\\n                unique.insert(ch);\\n            }\\n        }\\n        \\n        \\n        for(string puzzle : puzzles){\\n            \\n            //calculate mask of the puzzle\\n            int pmask =0;\\n            for(char ch : puzzle){\\n                int bit = ch - \\'a\\';\\n                pmask = pmask | (1<<bit);\\n                \\n            }\\n            //take the vector of mask contains first character.\\n            vector<int>  wordstocheck = m[puzzle[0]];\\n            int count =0;\\n            for(int wmask : wordstocheck){\\n                \\n                //check if puzzle mask and word mask contains char.\\n                if((wmask & pmask) == wmask){\\n                   count++; \\n                }\\n            }\\n            \\n            ans.push_back(count);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        /*\\n        map ->\\n        a== mask of( aaaa , able , ability , actt,actor,access)\\n        b== mask of( able , ability)\\n        c== so on\\n        \\n        using set to not pushing mask again if char repeats like aaaa , a is repeating.\\n        \\n        again make mask of every puzzle word.\\n        \\n        take the mask vector of the first char of puzzleword.\\n        \\n        check if the puzzle also contains the word by using & operator.\\n        \\n         */\\n        vector<int> ans;\\n        \\n        unordered_map<char,vector<int>> m;\\n        //Map to store map of every word from vector words.\\n       \\n        for(string word : words){\\n            //calculating mask of every word\\n            int mask =0;\\n            for(char ch : word){\\n                int bit = ch - \\'a\\';\\n                mask = mask | (1<<bit);\\n                \\n            }\\n            \\n            set <char> unique;\\n            //Here we are using set to not add the mask again if the word will come again.\\n            for(char ch : word){\\n                if(unique.count(ch))continue;\\n                //pushing the mask into the map.\\n                m[ch].push_back(mask);\\n                unique.insert(ch);\\n            }\\n        }\\n        \\n        \\n        for(string puzzle : puzzles){\\n            \\n            //calculate mask of the puzzle\\n            int pmask =0;\\n            for(char ch : puzzle){\\n                int bit = ch - \\'a\\';\\n                pmask = pmask | (1<<bit);\\n                \\n            }\\n            //take the vector of mask contains first character.\\n            vector<int>  wordstocheck = m[puzzle[0]];\\n            int count =0;\\n            for(int wmask : wordstocheck){\\n                \\n                //check if puzzle mask and word mask contains char.\\n                if((wmask & pmask) == wmask){\\n                   count++; \\n                }\\n            }\\n            \\n            ans.push_back(count);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442718,
                "title": "python-trie-tree-linear-time-complexity",
                "content": "\\n\\n```\\nimport collections\\nclass Node(object):\\n    def __init__(self):\\n        self.dic = collections.defaultdict(Node)\\n        self.counter = 0\\n        \\n    def insert(self, word):\\n        if not word:\\n            return\\n        node = self.dic[word[0]]\\n        for ind in xrange(1, len(word)):\\n            node = node.dic[word[ind]]\\n        node.counter += 1\\n        \\n            \\nclass Solution(object):\\n    def findNumOfValidWords(self, words, puzzles):\\n        \"\"\"\\n        :type words: List[str]\\n        :type puzzles: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        def dfs(puzzle, i, node):\\n            if i == len(puzzle):\\n                self.count += node.counter\\n                return \\n            \\n            if puzzle[i] == self.initial:\\n                if puzzle[i] not in node.dic:\\n                    return\\n                dfs(puzzle, i + 1, node.dic[puzzle[i]])\\n                \\n            else:\\n                dfs(puzzle, i + 1, node)\\n                if puzzle[i] not in node.dic:\\n                    return\\n                dfs(puzzle, i + 1, node.dic[puzzle[i]])\\n        \\n        trie = Node()\\n        for word in words:\\n            word = \\'\\'.join(sorted(set(word)))\\n            trie.insert(word)\\n        \\n        \\n        final = [0 for _ in xrange(len(puzzles))]\\n        for ind in xrange(len(puzzles)):\\n            self.initial = puzzles[ind][0]\\n            self.count = 0\\n            puzzle = \\'\\'.join(sorted(set(puzzles[ind])))\\n            dfs(puzzle, 0, trie)\\n            final[ind] = self.count\\n            \\n        return final\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Node(object):\\n    def __init__(self):\\n        self.dic = collections.defaultdict(Node)\\n        self.counter = 0\\n        \\n    def insert(self, word):\\n        if not word:\\n            return\\n        node = self.dic[word[0]]\\n        for ind in xrange(1, len(word)):\\n            node = node.dic[word[ind]]\\n        node.counter += 1\\n        \\n            \\nclass Solution(object):\\n    def findNumOfValidWords(self, words, puzzles):\\n        \"\"\"\\n        :type words: List[str]\\n        :type puzzles: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        def dfs(puzzle, i, node):\\n            if i == len(puzzle):\\n                self.count += node.counter\\n                return \\n            \\n            if puzzle[i] == self.initial:\\n                if puzzle[i] not in node.dic:\\n                    return\\n                dfs(puzzle, i + 1, node.dic[puzzle[i]])\\n                \\n            else:\\n                dfs(puzzle, i + 1, node)\\n                if puzzle[i] not in node.dic:\\n                    return\\n                dfs(puzzle, i + 1, node.dic[puzzle[i]])\\n        \\n        trie = Node()\\n        for word in words:\\n            word = \\'\\'.join(sorted(set(word)))\\n            trie.insert(word)\\n        \\n        \\n        final = [0 for _ in xrange(len(puzzles))]\\n        for ind in xrange(len(puzzles)):\\n            self.initial = puzzles[ind][0]\\n            self.count = 0\\n            puzzle = \\'\\'.join(sorted(set(puzzles[ind])))\\n            dfs(puzzle, 0, trie)\\n            final[ind] = self.count\\n            \\n        return final\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 376102,
                "title": "standard-javascript-solution",
                "content": "JavaScript Version solution in case you are an JS user and no answer to reference to.\\n\\n```\\nvar findNumOfValidWords = function(words, puzzles) {\\n  let base = \"a\".charCodeAt();\\n  let afterwords = [];\\n  words.forEach(x => {\\n    let bit = 0, lenChecker = [], pass = false;\\n    for(let i = 0; i < x.length; i++){\\n      if(lenChecker.indexOf(x[i]) < 0){\\n        lenChecker.push(x[i]);\\n        if(lenChecker.length > 7){ \\n          pass = true;\\n          i = x.length;\\n        } else {\\n          bit |= 1 << (x[i].charCodeAt() - base);\\n        }\\n      }\\n    }\\n\\n    if(!pass){\\n      afterwords.push(bit);\\n    }\\n  });\\n\\n  let res = [], pMemo = {};\\n\\n  puzzles.forEach(puzzle => {\\n    let count = 0;\\n\\n    let first = 0;\\n    first |= 1 << (puzzle[0].charCodeAt() - base);\\n    let mybit = 0;\\n    for(let i = 0; i < puzzle.length; i++){\\n      mybit |= 1 << (puzzle[i].charCodeAt() - base);\\n    }\\n\\n    if(pMemo[[puzzle[0], mybit].join(\",\")]){\\n      res.push(pMemo[[puzzle[0], mybit].join(\",\")]);\\n    } else {\\n      afterwords.forEach(wordBit => {\\n        if((wordBit & first) == first && (mybit & wordBit) == wordBit ){\\n          count++;\\n        }\\n      });\\n  \\n      pMemo[[puzzle[0], mybit].join(\",\")] = count;\\n      res.push(count);\\n    }\\n  });\\n\\n  return res;\\n};",
                "solutionTags": [],
                "code": "JavaScript Version solution in case you are an JS user and no answer to reference to.\\n\\n```\\nvar findNumOfValidWords = function(words, puzzles) {\\n  let base = \"a\".charCodeAt();\\n  let afterwords = [];\\n  words.forEach(x => {\\n    let bit = 0, lenChecker = [], pass = false;\\n    for(let i = 0; i < x.length; i++){\\n      if(lenChecker.indexOf(x[i]) < 0){\\n        lenChecker.push(x[i]);\\n        if(lenChecker.length > 7){ \\n          pass = true;\\n          i = x.length;\\n        } else {\\n          bit |= 1 << (x[i].charCodeAt() - base);\\n        }\\n      }\\n    }\\n\\n    if(!pass){\\n      afterwords.push(bit);\\n    }\\n  });\\n\\n  let res = [], pMemo = {};\\n\\n  puzzles.forEach(puzzle => {\\n    let count = 0;\\n\\n    let first = 0;\\n    first |= 1 << (puzzle[0].charCodeAt() - base);\\n    let mybit = 0;\\n    for(let i = 0; i < puzzle.length; i++){\\n      mybit |= 1 << (puzzle[i].charCodeAt() - base);\\n    }\\n\\n    if(pMemo[[puzzle[0], mybit].join(\",\")]){\\n      res.push(pMemo[[puzzle[0], mybit].join(\",\")]);\\n    } else {\\n      afterwords.forEach(wordBit => {\\n        if((wordBit & first) == first && (mybit & wordBit) == wordBit ){\\n          count++;\\n        }\\n      });\\n  \\n      pMemo[[puzzle[0], mybit].join(\",\")] = count;\\n      res.push(count);\\n    }\\n  });\\n\\n  return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 372141,
                "title": "c-bit-manipulation-hash-beats-100",
                "content": "\\tclass Solution {\\n\\t\\tint bits(string& s){\\n\\t\\t\\tint val = 0;\\n\\t\\t\\tfor(auto c : s) val |= 1<<(c-\\'a\\');\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\n\\t\\tint count(int x){\\n\\t\\t\\tint cnt = 0;\\n\\t\\t\\twhile(x){\\n\\t\\t\\t\\tx &= x-1;\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\n\\t\\tint pack(int x, int i){\\n\\t\\t\\tint val = 0;\\n\\t\\t\\twhile(i){\\n\\t\\t\\t\\tint t = -x&x;\\n\\t\\t\\t\\tif(i&1) val |= t;\\n\\t\\t\\t\\tx -= t;\\n\\t\\t\\t\\ti >>= 1;\\n\\t\\t\\t}\\n\\t\\t\\treturn val;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tvector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n\\t\\t\\tunordered_map<int, int> hash;\\n\\t\\t\\tfor(string& s : words){\\n\\t\\t\\t\\tint val = bits(s);\\n\\t\\t\\t\\tif (count(val) > 7) continue;\\n\\t\\t\\t\\tif (hash.find(val) != hash.end()) hash[val]++;\\n\\t\\t\\t\\telse hash[val]=1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> res;\\n\\t\\t\\tfor(string& s : puzzles){\\n\\t\\t\\t\\tint first = 1<<(s[0]-\\'a\\');\\n\\t\\t\\t\\tint target = bits(s)&~first;\\n\\t\\t\\t\\tint cnt = 0;\\n\\t\\t\\t\\tfor(int i=0; i<(1<<6); i++){\\n\\t\\t\\t\\t\\tint val = pack(target, i) | first;\\n\\t\\t\\t\\t\\tauto it = hash.find(val);\\n\\t\\t\\t\\t\\tif(it != hash.end()) cnt += it->second;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tres.push_back(cnt);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tint bits(string& s){\\n\\t\\t\\tint val = 0;\\n\\t\\t\\tfor(auto c : s) val |= 1<<(c-\\'a\\');\\n\\t\\t\\treturn val;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 372088,
                "title": "python-bitmask-way-detailed-explanation",
                "content": "Basic ides: Pre-process the puzzles list, so that for any one word, we can find ALL its matching puzzles in O(1). Since this question is asking the number of word matching a puzzle, not the number of puzzle matching a word, we just add 1 to the result counter of all matched puzzles.\\n\\nHow to do such pre-process?\\nFor each puzzle we try to find all possible words that could possibly match this puzzle, by \"ALL\" we mean \"ALL\" words no matter this word is in the provided list or not. Put them in a dict so that for any given word, we can immediately know whether this word match the puzzle or not.\\nThe poblem is, each puzzle can have infinite number of such matching words, we can\\'t find them all. The trick is, we don\\'t have to find exact matching words, we only find the bitmasks of matching words. This reduces the possibility to only 64 for each puzzle. \\n\\nUse a 26-bit bitmask to represent a word or puzzle, each bit represents a char exists in that bit.\\ne.g. \\'acz\\'=>10000000000000000000000101. \\nWe can do this because in this question, char order and repetition in a word or puzzle doesn\\'t matter.\\n\\nFor each puzzle, there are at most 7 chars. The 1st char must be picked, other 6 can be either picked or not, total number of possibilities are 2^6=64. Each puzzle can form at most 64 bitmasks. If a word\\'s bitmask exactly matches one of these 64 bitmasks, then we know this word match this puzzle, otherwise, that means this word must contain chars that does\\'t exist in the puzzle so they don\\'t match.\\nUse a dict to record bitmask->puzzle mapping. Each bitmask in this dict can correspond to many puzzles. Building this dict takes O(64\\\\*len(puzzles)). For each word, we can use this dict to find all puzzles that maches this word in O(1). \\n\\nTime complexity: O(64\\\\*len(puzzles))+O(len(words))\\n\\n```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        def helper(mask,pIdx,i):\\n            str1=puzzles[pIdx]\\n            if i>=len(str1):\\n                return\\n            mask2=mask\\n            mask2|=1<<(ord(str1[i])-ord(\\'a\\'))\\n            if mask2^mask:\\n                d[mask2].add(pIdx)\\n                helper(mask2,pIdx,i+1)\\n            helper(mask,pIdx,i+1)\\n\\n        d=collections.defaultdict(set)\\n        n=len(puzzles)\\n        for i,p in enumerate(puzzles):\\n            mask=1<<(ord(p[0])-ord(\\'a\\'))\\n            d[mask].add(i)\\n            helper(mask,i,1)\\n        res=[0]*len(puzzles)\\n        for w in words:\\n            mask=0\\n            for c in w:\\n                mask|=1<<(ord(c)-ord(\\'a\\'))\\n            for idx in d[mask]:\\n                res[idx]+=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        def helper(mask,pIdx,i):\\n            str1=puzzles[pIdx]\\n            if i>=len(str1):\\n                return\\n            mask2=mask\\n            mask2|=1<<(ord(str1[i])-ord(\\'a\\'))\\n            if mask2^mask:\\n                d[mask2].add(pIdx)\\n                helper(mask2,pIdx,i+1)\\n            helper(mask,pIdx,i+1)\\n\\n        d=collections.defaultdict(set)\\n        n=len(puzzles)\\n        for i,p in enumerate(puzzles):\\n            mask=1<<(ord(p[0])-ord(\\'a\\'))\\n            d[mask].add(i)\\n            helper(mask,i,1)\\n        res=[0]*len(puzzles)\\n        for w in words:\\n            mask=0\\n            for c in w:\\n                mask|=1<<(ord(c)-ord(\\'a\\'))\\n            for idx in d[mask]:\\n                res[idx]+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616354,
                "title": "",
                "content": "\\u0422\\u0443\\u0442 \\u0441\\u0440\\u0430\\u0432\\u043D\\u0435\\u043D\\u0438\\u0435 \\u0434\\u0432\\u0443\\u0445 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u043E\\u0432, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u0432\\u0440\\u044F\\u0434 \\u043B\\u0438 \\u0435\\u0441\\u0442\\u044C \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442 \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C \\u0431\\u044B\\u0441\\u0442\\u0440\\u0435\\u0435, \\u0447\\u0435\\u043C \\u0437\\u0430 `O(n*m)`. \\u0412 \\u043D\\u0435\\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0445 \\u043C\\u0435\\u0441\\u0442\\u0430\\u0445 \\u043C\\u043E\\u0436\\u043D\\u043E \\u043E\\u043F\\u0442\\u0438\\u043C\\u0438\\u0437\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C, \\u043D\\u043E \\u0441\\u043B\\u043E\\u0436\\u043D\\u043E\\u0441\\u0442\\u044C \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C\\u0430 \\u043D\\u0435 \\u0443\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u0442\\u0441\\u044F.\\n\\n\\u0418\\u0434\\u0442\\u0438 \\u043F\\u043E \\u0441\\u043B\\u043E\\u0432\\u0430\\u043C, \\u043F\\u043E\\u0442\\u043E\\u043C \\u043F\\u043E \\u0431\\u0443\\u043A\\u0432\\u0430\\u043C, \\u043F\\u043E\\u0442\\u043E\\u043C \\u043F\\u043E \\u043A\\u0430\\u0436\\u0434\\u043E\\u043C\\u0443 \\u043F\\u0430\\u0437\\u0437\\u043B\\u0443 (\\u0438\\u043B\\u0438 \\u0432 \\u0434\\u0440\\u0443\\u0433\\u043E\\u043C \\u043F\\u043E\\u0440\\u044F\\u0434\\u043A\\u0435) - \\u043E\\u0447\\u0435\\u043D\\u044C \\u0434\\u043E\\u0440\\u043E\\u0433\\u043E, `O(n*m*k)` \\u041F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 \\u043D\\u0443\\u0436\\u043D\\u0430 \\u043A\\u0430\\u043A\\u0430\\u044F-\\u0442\\u043E \\u0441\\u0445\\u0435\\u043C\\u0430, \\u0433\\u0434\\u0435 \\u0441\\u0440\\u0430\\u0432\\u043D\\u0438\\u0432\\u0430\\u0442\\u044C \\u043C\\u043E\\u0436\\u043D\\u043E \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0441\\u043B\\u043E\\u0432\\u0430 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u0443\\u044E \\u0441 \\u043F\\u0430\\u0437\\u0437\\u043B\\u0430\\u043C\\u0438, \\u043C\\u0438\\u043D\\u0443\\u044F \\u043F\\u043E\\u0434\\u0441\\u0447\\u0435\\u0442 \\u0431\\u0443\\u043A\\u0432.\\n\\u0422\\u0443\\u0442-\\u0442\\u043E \\u043D\\u0430\\u043C \\u0438 \\u043F\\u0440\\u0438\\u0433\\u043E\\u0434\\u044F\\u0442\\u0441\\u044F \\u0431\\u0438\\u0442\\u043E\\u0432\\u044B\\u0435 \\u043C\\u0430\\u0441\\u043A\\u0438.\\n\\n\\u0414\\u043B\\u044F \\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u043F\\u0435\\u0440\\u0435\\u0431\\u0435\\u0440\\u0435\\u043C \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432 \\u0441\\u043E \\u0441\\u043B\\u043E\\u0432\\u0430\\u043C\\u0438, \\u0447\\u0442\\u043E\\u0431\\u044B \\u0437\\u0430\\u043C\\u0435\\u043D\\u0438\\u0442\\u044C \\u0441\\u043B\\u043E\\u0432\\u0430 \\u043C\\u0430\\u0441\\u043A\\u0430\\u043C\\u0438. \\u041D\\u0430 \\u043A\\u0430\\u0436\\u0434\\u0443\\u044E \\u0431\\u0443\\u043A\\u0432\\u0443 \\u043C\\u044B \\u0437\\u0430\\u0432\\u0435\\u0434\\u0435\\u043C \\u0441\\u0432\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E (\\u0441\\u0442\\u0435\\u043F\\u0435\\u043D\\u044C \\u0434\\u0432\\u043E\\u0439\\u043A\\u0438), \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0435 \\u043D\\u0435 \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043F\\u0435\\u0440\\u0435\\u0441\\u0435\\u043A\\u0430\\u0442\\u044C\\u0441\\u044F \\u0441 \\u0434\\u0440\\u0443\\u0433\\u0438\\u043C\\u0438 \\u0447\\u0438\\u0441\\u043B\\u0430\\u043C\\u0438 \\u0432 \\u0434\\u0432\\u043E\\u0438\\u0447\\u043D\\u043E\\u043C \\u043F\\u0440\\u0435\\u0434\\u0441\\u0442\\u0430\\u0432\\u043B\\u0435\\u043D\\u0438\\u0438: `\\u0430 - 0001, b - 0010, c - 0100, d - 1000` \\u0438 \\u0442.\\u0434.\\n\\u042D\\u0442\\u043E \\u043D\\u0443\\u0436\\u043D\\u043E \\u0447\\u0442\\u043E\\u0431\\u044B \\u043F\\u0440\\u0438 \\u043F\\u043E\\u0431\\u0438\\u0442\\u043E\\u0432\\u043E\\u043C \\u0418\\u041B\\u0418 \\u043F\\u043E\\u043B\\u0443\\u0447\\u0430\\u043B\\u0438\\u0441\\u044C \\u0443\\u043D\\u0438\\u043A\\u0430\\u043B\\u044C\\u043D\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430, \\u0438\\u0437 \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0445 \\u043B\\u0435\\u0433\\u043A\\u043E \\u043C\\u043E\\u0436\\u043D\\u043E \\u043F\\u043E\\u043D\\u044F\\u0442\\u044C, \\u0431\\u044B\\u043B\\u0430 \\u043B\\u0438 \\u0431\\u0443\\u043A\\u0432\\u0430 \\u0432 \\u0441\\u043B\\u043E\\u0432\\u0435 (\\u043D\\u043E \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u044D\\u0442\\u0438\\u0445 \\u0431\\u0443\\u043A\\u0432 \\u0443\\u0437\\u043D\\u0430\\u0442\\u044C \\u043D\\u0435 \\u0443\\u0434\\u0430\\u0441\\u0442\\u0441\\u044F). \\n\\u041C\\u0430\\u0442\\u0435\\u043C\\u0430\\u0442\\u0438\\u043A\\u0430 \\u0442\\u0443\\u0442 \\u043F\\u0440\\u043E\\u0441\\u0442\\u0430\\u044F:\\n`a | b = 0001 | 0010 = 0011`\\n`a | d = 0001 | 1000 = 1001`\\n\\n\\u041A\\u0430\\u043A \\u043F\\u0435\\u0440\\u0435\\u0432\\u0435\\u0441\\u0442\\u0438 \\u0431\\u0443\\u043A\\u0432\\u0443 \\u0432 \\u0447\\u0438\\u0441\\u043B\\u043E? \\u0421 \\u043F\\u043E\\u043C\\u043E\\u0449\\u044C\\u044E \\u0441\\u0442\\u0430\\u043D\\u0434\\u0430\\u0440\\u0442\\u043D\\u043E\\u0433\\u043E \\u043C\\u0435\\u0442\\u043E\\u0434\\u0430 `charCodeAt(index)`. \\u041E\\u043D \\u0432\\u043E\\u0437\\u0432\\u0440\\u0430\\u0449\\u0430\\u0435\\u0442 \\u043A\\u043E\\u0434 \\u0437\\u043D\\u0430\\u043A\\u0430, \\u043B\\u0430\\u0442\\u0438\\u043D\\u0441\\u043A\\u0438\\u0435 \\u0446\\u0438\\u0444\\u0440\\u044B \\u0438\\u0434\\u0443\\u0442 \\u043F\\u043E\\u0441\\u043B\\u0435 97, \\u043C\\u043E\\u0436\\u043D\\u043E \\u0437\\u0430\\u043F\\u043E\\u043C\\u043D\\u0438\\u0442\\u044C, \\u043C\\u043E\\u0436\\u043D\\u043E \\u0432\\u044B\\u0447\\u0438\\u0441\\u043B\\u044F\\u0442\\u044C \\u0447\\u0435\\u0440\\u0435\\u0437 `\\'a\\'.charCodeAt(0)`. \\u041F\\u043E \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044E \\u0437\\u0430\\u0434\\u0430\\u0447\\u0438 \\u0443 \\u043D\\u0430\\u0441 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043B\\u0430\\u0442\\u0438\\u043D\\u0438\\u0446\\u0430, \\u043F\\u043E\\u044D\\u0442\\u043E\\u043C\\u0443 97 \\u0438\\u0437 \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u043A\\u043E\\u0434\\u0430 \\u0432\\u044B\\u0447\\u0438\\u0442\\u0430\\u0435\\u043C, \\u0447\\u0442\\u043E\\u0431\\u044B \\u0438\\u0442\\u043E\\u0433\\u043E\\u0432\\u044B\\u0435 \\u0447\\u0438\\u0441\\u043B\\u0430 \\u043F\\u043E\\u043C\\u0435\\u043D\\u044C\\u0448\\u0435 \\u0431\\u044B\\u043B\\u0438.\\n\\u041F\\u043E\\u043B\\u0443\\u0447\\u0438\\u043B\\u043E\\u0441\\u044C `a = 0, b = 1, c = 2`. \\u041A\\u0430\\u043A \\u0438\\u0445 \\u043F\\u0435\\u0440\\u0435\\u0432\\u0435\\u0441\\u0442\\u0438 \\u0432 \\u0441\\u0442\\u0435\\u043F\\u0435\\u043D\\u0438 \\u0434\\u0432\\u043E\\u0439\\u043A\\u0438? \\u041D\\u0443\\u0436\\u0435\\u043D \\u043F\\u043E\\u0431\\u0438\\u0442\\u043E\\u0432\\u044B\\u0439 \\u0441\\u0434\\u0432\\u0438\\u0433 - \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0434\\u043E\\u0431\\u0430\\u0432\\u043B\\u044F\\u0435\\u043C \\u043D\\u0443\\u043B\\u0438 \\u0441\\u043F\\u0440\\u0430\\u0432\\u0430, \\u043E\\u0442\\u0442\\u0430\\u043B\\u043A\\u0438\\u0432\\u0430\\u044F\\u0441\\u044C \\u043E\\u0442 \\u0446\\u0438\\u0444\\u0440\\u044B, \\u043E\\u0441\\u0442\\u0430\\u0432\\u0448\\u0435\\u0439\\u0441\\u044F \\u043E\\u0442 \\u043A\\u043E\\u0434\\u0430 \\u0441\\u0438\\u043C\\u0432\\u043E\\u043B\\u0430 \\u043F\\u043E\\u0441\\u043B\\u0435 \\u0432\\u044B\\u0447\\u0438\\u0442\\u0430\\u043D\\u0438\\u044F 97.\\n`1 << 0 = 1`\\n`1 << 3 = 1000`\\n(\\u0415\\u0441\\u043B\\u0438 \\u043D\\u0435 \\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u043B\\u0438\\u0441\\u044C \\u0440\\u0430\\u043D\\u044C\\u0448\\u0435, \\u0442\\u043E \\u043E\\u0431\\u044A\\u044F\\u0441\\u043D\\u044E, \\u0447\\u0442\\u043E \\u0441\\u0442\\u0440\\u0435\\u043B\\u043A\\u0438 \\u0442\\u0443\\u0442 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u044E\\u0442 \\u0432 \\u043B\\u044E\\u0431\\u0443\\u044E \\u0441\\u0442\\u043E\\u0440\\u043E\\u043D\\u0443: \\u0435\\u0441\\u043B\\u0438 \\u043F\\u043E\\u043A\\u0430\\u0437\\u044B\\u0432\\u0430\\u044E\\u0442 \\u0432\\u043B\\u0435\\u0432\\u043E, \\u0442\\u043E `1` \\u043F\\u043E\\u0439\\u0434\\u0435\\u0442 \\u0432\\u043B\\u0435\\u0432\\u043E, \\u0441\\u043F\\u0440\\u0430\\u0432\\u0430 \\u043C\\u0435\\u0441\\u0442\\u043E \\u0431\\u0443\\u0434\\u0435\\u0442 \\u0437\\u0430\\u043F\\u043E\\u043B\\u043D\\u044F\\u0442\\u044C\\u0441\\u044F \\u043D\\u0443\\u043B\\u044F\\u043C\\u0438. \\u0418 \\u043D\\u0430\\u043E\\u0431\\u043E\\u0440\\u043E\\u0442)\\n\\n\\u0420\\u0430\\u0437\\u043E\\u0431\\u0440\\u0430\\u043B\\u0438\\u0441\\u044C \\u0441 \\u0431\\u0438\\u0442\\u043E\\u0432\\u044B\\u043C\\u0438 \\u043E\\u043F\\u0435\\u0440\\u0430\\u0446\\u0438\\u044F\\u043C\\u0438, \\u0442\\u0435\\u043F\\u0435\\u0440\\u044C \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0437\\u0430\\u043C\\u0435\\u043D\\u044F\\u0435\\u043C \\u043A\\u0430\\u0436\\u0434\\u043E\\u0435 \\u0441\\u043B\\u043E\\u0432\\u043E \\u043D\\u0430 \\u0431\\u0438\\u0442\\u043E\\u0432\\u0443\\u044E \\u043C\\u0430\\u0441\\u043A\\u0443.\\n\\u0410 \\u043F\\u043E\\u0442\\u043E\\u043C \\u043A\\u0430\\u0436\\u0434\\u044B\\u0439 \\u043F\\u0430\\u0437\\u0437\\u043B. \\u0418 \\u0441\\u0440\\u0430\\u0432\\u043D\\u0438\\u0432\\u0430\\u0435\\u043C \\u0438\\u0445 \\u043C\\u0435\\u0436\\u0434\\u0443 \\u0441\\u043E\\u0431\\u043E\\u0439. \\u0415\\u0441\\u043B\\u0438 \\u043A \\u0441\\u043B\\u043E\\u0432\\u0443 \\u043F\\u043E\\u0431\\u0438\\u0442\\u043E\\u0432\\u043E \\u0434\\u043E\\u0431\\u0430\\u0432\\u0438\\u0442\\u044C \\u043F\\u0430\\u0437\\u0437\\u043B, \\u0438\\u0437 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u043E\\u043D\\u043E \\u0443\\u0436\\u0435 \\u0438 \\u0442\\u0430\\u043A \\u0441\\u043E\\u0441\\u0442\\u043E\\u0438\\u0442, \\u0442\\u043E \\u0441\\u043B\\u043E\\u0432\\u043E \\u043D\\u0435 \\u0438\\u0437\\u043C\\u0435\\u043D\\u0438\\u0442\\u0441\\u044F\\n`\\'a\\' & \\'ab\\' = 0001 & 0011 = 0001 = \\'a\\'`\\n\\u041F\\u043E\\u0442\\u043E\\u043C\\u0443 \\u0447\\u0442\\u043E \\u043F\\u043E\\u0431\\u0438\\u0442\\u043E\\u0432\\u043E\\u0435 \\u0418 \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442 \\u0442\\u043E\\u043B\\u044C\\u043A\\u043E \\u043F\\u0440\\u0438 \\u043F\\u0430\\u0440\\u043D\\u044B\\u0445 \\u0435\\u0434\\u0438\\u043D\\u0438\\u0446\\u0430\\u0445 \\u043D\\u0430 \\u043E\\u0434\\u043D\\u0438\\u0445 \\u0438 \\u0442\\u0435\\u0445 \\u0436\\u0435 \\u043C\\u0435\\u0441\\u0442\\u0430\\u0445.\\n\\u0422\\u043E \\u0436\\u0435 \\u0441\\u0430\\u043C\\u043E\\u0435 \\u0438 \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0432\\u043E\\u0439 \\u0431\\u0443\\u043A\\u0432\\u044B.\\n\\n\\u0412\\u043E\\u0442, \\u043F\\u043E\\u043B\\u043D\\u044B\\u0439 \\u043A\\u043E\\u0434:\\n```\\nfunction findNumOfValidWords(words, puzzles) {\\n    const wordBits = words.map((word) => getBitMask(word)); // \\u0441\\u043E\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u043C\\u0430\\u0441\\u043A\\u0438 \\u0441\\u043B\\u043E\\u0432\\n    return puzzles.map((puzzle) => {\\n        const fl = getBitMask(puzzle[0]); // \\u0434\\u0435\\u043B\\u0430\\u0435\\u043C \\u043C\\u0430\\u0441\\u043A\\u0443 \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0432\\u043E\\u0439 \\u0431\\u0443\\u043A\\u0432\\u044B\\n        const p = getBitMask(puzzle); // \\u0434\\u0435\\u043B\\u0430\\u0435\\u043C \\u043C\\u0430\\u0441\\u043A\\u0443 \\u0434\\u043B\\u044F \\u043F\\u0430\\u0437\\u0437\\u043B\\u0430\\n\\t\\t// \\u041F\\u043E\\u0434\\u0441\\u0447\\u0438\\u0442\\u044B\\u0432\\u0430\\u0435\\u043C \\u0434\\u043B\\u044F \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u043F\\u0430\\u0437\\u0437\\u043B\\u0430 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u043F\\u043E\\u0434\\u0445\\u043E\\u0434\\u044F\\u0449\\u0438\\u0445 \\u0435\\u043C\\u0443 \\u0441\\u043B\\u043E\\u0432\\n        return wordBits.reduce((res, w) => ((w & p) === w && (fl & w) === fl) ? ++res : res, 0);\\n    });\\n};\\n\\nfunction getBitMask(word) {\\n\\treturn word.split(\\'\\').reduce((acc, letter) => acc | (1 << (letter.charCodeAt(0) - 97)), 0);\\n}\\n ```\\n \\nPS: \\u041A\\u0430\\u043A \\u044F \\u043D\\u0438 \\u043F\\u044B\\u0442\\u0430\\u043B\\u0441\\u044F, \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u0431\\u0435\\u0437 \\u0431\\u0438\\u0442\\u043E\\u0432\\u043E\\u0439 \\u043C\\u0430\\u0441\\u043A\\u0438, \\u0443\\u043A\\u043B\\u0430\\u0434\\u044B\\u0432\\u0430\\u044E\\u0449\\u0435\\u0435\\u0441\\u044F \\u0432\\u043E \\u0432\\u0440\\u0435\\u043C\\u0435\\u043D\\u043D\\u043E\\u0435 \\u043E\\u0433\\u0440\\u0430\\u043D\\u0438\\u0447\\u0435\\u043D\\u0438\\u0435, \\u043D\\u0430\\u0439\\u0442\\u0438 \\u043D\\u0435 \\u0441\\u043C\\u043E\\u0433. \\u0415\\u0441\\u043B\\u0438 \\u043A\\u0442\\u043E \\u0441\\u043C\\u043E\\u0433, \\u043F\\u043E\\u0434\\u0435\\u043B\\u0438\\u0442\\u044C, \\u043F\\u043B\\u0437. \\u041B\\u0443\\u0447\\u0448\\u0435\\u0435 \\u043C\\u043E\\u0435 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u0435 \\u0442\\u0440\\u0430\\u0442\\u0438\\u043B\\u043E \\u0447\\u0443\\u0442\\u044C \\u043C\\u0435\\u043D\\u044C\\u0448\\u0435 5 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434 \\u043D\\u0430 \\u043C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0439 \\u0434\\u043B\\u0438\\u043D\\u044B \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430\\u0445.\\n",
                "solutionTags": [
                    "JavaScript",
                    "Bitmask"
                ],
                "code": "```\\nfunction findNumOfValidWords(words, puzzles) {\\n    const wordBits = words.map((word) => getBitMask(word)); // \\u0441\\u043E\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C \\u043C\\u0430\\u0441\\u043A\\u0438 \\u0441\\u043B\\u043E\\u0432\\n    return puzzles.map((puzzle) => {\\n        const fl = getBitMask(puzzle[0]); // \\u0434\\u0435\\u043B\\u0430\\u0435\\u043C \\u043C\\u0430\\u0441\\u043A\\u0443 \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0432\\u043E\\u0439 \\u0431\\u0443\\u043A\\u0432\\u044B\\n        const p = getBitMask(puzzle); // \\u0434\\u0435\\u043B\\u0430\\u0435\\u043C \\u043C\\u0430\\u0441\\u043A\\u0443 \\u0434\\u043B\\u044F \\u043F\\u0430\\u0437\\u0437\\u043B\\u0430\\n\\t\\t// \\u041F\\u043E\\u0434\\u0441\\u0447\\u0438\\u0442\\u044B\\u0432\\u0430\\u0435\\u043C \\u0434\\u043B\\u044F \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u043F\\u0430\\u0437\\u0437\\u043B\\u0430 \\u043A\\u043E\\u043B\\u0438\\u0447\\u0435\\u0441\\u0442\\u0432\\u043E \\u043F\\u043E\\u0434\\u0445\\u043E\\u0434\\u044F\\u0449\\u0438\\u0445 \\u0435\\u043C\\u0443 \\u0441\\u043B\\u043E\\u0432\\n        return wordBits.reduce((res, w) => ((w & p) === w && (fl & w) === fl) ? ++res : res, 0);\\n    });\\n};\\n\\nfunction getBitMask(word) {\\n\\treturn word.split(\\'\\').reduce((acc, letter) => acc | (1 << (letter.charCodeAt(0) - 97)), 0);\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570668,
                "title": "javascript-simple-and-clean-solution-with-explanation",
                "content": "To come to a fast enough solution there are several conclusions to be made.\\n1. A word is a string of up to 50 letters while a puzzle is a string of exactly 7 **unique** letters. A word would likely contain letter duplicates, but we have to check if any given letter is in puzzle only once. Understanding this we can \\'hash\\' a word by removing all duplicating characters and still validate it against a puzzle, reducing number of checks.\\n2. \\'Hashed\\' words will result in multiple duplicate entries as different words could consist of the same letters. We\\'ll need a map to store unique \\'hashes\\' with word counts for each.\\n3. Comparing letter by letter is a time-consumig process given the size of input data. Luckily we have a way to compare a \\'hashed\\' word with a puzzle in a single run! Letters could be used to index bits in a number. Setting bits for only present letters will result in a bitmask of a word (```wMask```) or a puzzle (```pMask```). For example, word ```acdgh``` would correspond to bitmask ```11001101``` (bit with index \\'a\\'(0) is the rightmost).\\n4. We have everything to perform a word verification against a puzzle in a rather efficient manner!\\n\\t* To check if first letter of a puzzle is in a word, we form a bitmask for this letter (```pFirstMask```) and check if it is set in a word: ```pFirstMask & wMask```.\\n\\t* To check if a word contais **only** letters present in a puzzle we logically add both masks ```wMask | pMask``` then XOR it with ```pMask```. If ```wMask``` didn\\'t have any other bits than ```pMask```, the result will be zero.\\n\\n```\\nvar findNumOfValidWords = function(words, puzzles) {\\n\\t// Form map of word\\'s bitmasks\\n    const wordsMaskMap = words.reduce((map, word) => addToMap(map, getMask(word)), new Map())\\n\\n    return puzzles.map(puzzle => {\\n        const pMask = getMask(puzzle)\\n        const pFirstMask = getFirstMask(puzzle)\\n        let count = 0\\n        \\n\\t\\t// Verify each bitmask against a given puzzle\\n        for (let wMask of wordsMaskMap.keys()) {\\n            if((wMask & pFirstMask) && (!((wMask | pMask) ^ pMask))) {\\n                count += wordsMaskMap.get(wMask)\\n            }\\n        }\\n        return count\\n    })\\n}\\n\\n// Transform a char into a bit index\\nvar getBit = (char) => 1 << char.charCodeAt(0) - \\'a\\'.charCodeAt(0)\\n\\n// Transform a word into a bitmask\\nvar getMask = (word) => word.split(\\'\\').reduce((acc, c) => acc | getBit(c), 0)\\n\\n// Get a bitmask for the first letter of a word\\nvar getFirstMask = (word) => getBit(word[0])\\n\\n// Helper function to count hashes in a Map object \\nvar addToMap = (map, val) => map.has(val) ? map.set(val, map.get(val) + 1) : map.set(val, 1)",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```wMask```\n```pMask```\n```acdgh```\n```11001101```\n```pFirstMask```\n```pFirstMask & wMask```\n```wMask | pMask```\n```pMask```\n```wMask```\n```pMask```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568068,
                "title": "c-using-trie-with-complete-explaination",
                "content": "```\\nclass Solution {\\n  \\n  struct TrieNode {\\n    struct TrieNode* children[26];\\n    int ew;  //word end\\n};\\n  \\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n      \\n      struct TrieNode* root = getNode();\\n      \\n      /* \\n      Insert each word[i] in Trie,Then for each puzzles[i] search in Trie\\n      \\n      There is no need to insert duplicate chars of word, also order of char in a word do not matter , so insert each word in trie in sorted order without any duplicate\\n      \\n      To do this , first insert each chars of a word in a set \\n      */\\n      \\n      for(string& s:words){\\n        set<char>st;  //using set to avoid duplicates as well as word also get sorted\\n        \\n        st.insert(s.begin(),s.end());\\n        \\n        string sorted_str=\"\";\\n        for(char ch:st)\\n          sorted_str+=ch;\\n        \\n        insert(root,sorted_str);\\n          \\n    }\\n      \\n    /*\\n        after removing duplicates and sorting\\n  (a,as,abel,abilty,act,acort,aces) -> Present in Trie\\n  \\n    Also while searching the count of words corresponding to puzzles[i], first we need to check presence of first char of puzzles[i], order of chars not matters, so we store the first char and sort the puzzles[i]\\n    \\n  Now lets search for count of words corresponds to actresz-> sorted(acerstz) , First_ch=a\\n  \\n  for(acerstz){\\n  a==First_ch (true) , move toward a , count=count+count of ew(at \\'a\\')= 0+1=1\\n  c(First_ch \\'a\\' already get(true)) , a->c(in trie) , count=count+count of ew(at \\'c\\')=1+0=1\\n  e , a->c->e(in trie) , count=count+count of ew( at \\'e\\')=1+0=1\\n  r , a->c->e->r , count=count + count of ew(at \\'r\\')=1+0=1\\n  s , a->c->e->r->s, count=count+ count of ew (at \\'s\\')= 1+2(for \"as\" and \"aces\")=3\\n  t , a->c->e->r->s->t , count=count+ count of ew(at \\'t\\')=3+1(for \"act\")=4\\n  z , a->c->e->r->s->t->z , count=count+ count of ew (at \\'z\\')= 4+0=4\\n  \\n  return count=4;\\n  \\n  }\\n\\n    \\n    */\\n      \\n      vector<int>count;\\n      for(string puzz:puzzles){\\n        char first_ch=puzz[0];\\n        sort(puzz.begin(),puzz.end());\\n        \\n        int c=0;\\n        c= search(root,puzz,first_ch,false);\\n        count.push_back(c);\\n        \\n      }\\n      return count; \\n    }\\n  \\n          \\nstruct TrieNode* getNode(void)\\n{\\n\\n    struct TrieNode* pNode = new TrieNode;\\n    pNode->ew= 0;\\n  \\n    for (int i = 0; i < 26; i++)\\n        pNode->children[i] = NULL;\\n \\n    return pNode;\\n}\\n \\n  \\nvoid insert(struct TrieNode* root, string key)\\n{\\n    struct TrieNode* pCrawl = root;\\n  \\n   for (int i = 0; i < key.length(); i++) {\\n        int index = key[i] - \\'a\\';\\n        if (!pCrawl->children[index])\\n            pCrawl->children[index] = getNode();\\n     \\n        pCrawl = pCrawl->children[index];\\n    }\\n  \\n    pCrawl->ew +=1;\\n}\\n  \\n\\nint search(struct TrieNode* root, string str,char first_ch,bool firstSeen)\\n{\\n    if(!root)\\n        return 0;\\n    \\n    int count = 0;\\n\\n    if(firstSeen)\\n        count += root->ew;\\n    \\n    for(int i = 0; i < str.length(); i++)\\n    {\\n       int index=str[i]-\\'a\\';\\n        if(str[i] == first_ch)\\n            count += search(root->children[index], str, first_ch,true);\\n        else\\n            count += search(root->children[index], str,first_ch,firstSeen);\\n    }\\n\\n    return count;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n  \\n  struct TrieNode {\\n    struct TrieNode* children[26];\\n    int ew;  //word end\\n};\\n  \\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n      \\n      struct TrieNode* root = getNode();\\n      \\n      /* \\n      Insert each word[i] in Trie,Then for each puzzles[i] search in Trie\\n      \\n      There is no need to insert duplicate chars of word, also order of char in a word do not matter , so insert each word in trie in sorted order without any duplicate\\n      \\n      To do this , first insert each chars of a word in a set \\n      */\\n      \\n      for(string& s:words){\\n        set<char>st;  //using set to avoid duplicates as well as word also get sorted\\n        \\n        st.insert(s.begin(),s.end());\\n        \\n        string sorted_str=\"\";\\n        for(char ch:st)\\n          sorted_str+=ch;\\n        \\n        insert(root,sorted_str);\\n          \\n    }\\n      \\n    /*\\n        after removing duplicates and sorting\\n  (a,as,abel,abilty,act,acort,aces) -> Present in Trie\\n  \\n    Also while searching the count of words corresponding to puzzles[i], first we need to check presence of first char of puzzles[i], order of chars not matters, so we store the first char and sort the puzzles[i]\\n    \\n  Now lets search for count of words corresponds to actresz-> sorted(acerstz) , First_ch=a\\n  \\n  for(acerstz){\\n  a==First_ch (true) , move toward a , count=count+count of ew(at \\'a\\')= 0+1=1\\n  c(First_ch \\'a\\' already get(true)) , a->c(in trie) , count=count+count of ew(at \\'c\\')=1+0=1\\n  e , a->c->e(in trie) , count=count+count of ew( at \\'e\\')=1+0=1\\n  r , a->c->e->r , count=count + count of ew(at \\'r\\')=1+0=1\\n  s , a->c->e->r->s, count=count+ count of ew (at \\'s\\')= 1+2(for \"as\" and \"aces\")=3\\n  t , a->c->e->r->s->t , count=count+ count of ew(at \\'t\\')=3+1(for \"act\")=4\\n  z , a->c->e->r->s->t->z , count=count+ count of ew (at \\'z\\')= 4+0=4\\n  \\n  return count=4;\\n  \\n  }\\n\\n    \\n    */\\n      \\n      vector<int>count;\\n      for(string puzz:puzzles){\\n        char first_ch=puzz[0];\\n        sort(puzz.begin(),puzz.end());\\n        \\n        int c=0;\\n        c= search(root,puzz,first_ch,false);\\n        count.push_back(c);\\n        \\n      }\\n      return count; \\n    }\\n  \\n          \\nstruct TrieNode* getNode(void)\\n{\\n\\n    struct TrieNode* pNode = new TrieNode;\\n    pNode->ew= 0;\\n  \\n    for (int i = 0; i < 26; i++)\\n        pNode->children[i] = NULL;\\n \\n    return pNode;\\n}\\n \\n  \\nvoid insert(struct TrieNode* root, string key)\\n{\\n    struct TrieNode* pCrawl = root;\\n  \\n   for (int i = 0; i < key.length(); i++) {\\n        int index = key[i] - \\'a\\';\\n        if (!pCrawl->children[index])\\n            pCrawl->children[index] = getNode();\\n     \\n        pCrawl = pCrawl->children[index];\\n    }\\n  \\n    pCrawl->ew +=1;\\n}\\n  \\n\\nint search(struct TrieNode* root, string str,char first_ch,bool firstSeen)\\n{\\n    if(!root)\\n        return 0;\\n    \\n    int count = 0;\\n\\n    if(firstSeen)\\n        count += root->ew;\\n    \\n    for(int i = 0; i < str.length(); i++)\\n    {\\n       int index=str[i]-\\'a\\';\\n        if(str[i] == first_ch)\\n            count += search(root->children[index], str, first_ch,true);\\n        else\\n            count += search(root->children[index], str,first_ch,firstSeen);\\n    }\\n\\n    return count;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567720,
                "title": "java-o-w-p-via-bitmasks",
                "content": "```\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        int wLen = words.length, pLen = puzzles.length;\\n        int[] wBitMask = new int[wLen], pBitMask = new int[pLen], pMustBitMask = new int[pLen];\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i=0;i<wLen;i++){\\n            for(char ch : words[i].toCharArray())\\n                wBitMask[i] |= 1<<(ch-\\'a\\');\\n        }\\n\\n        for(int i=0;i<pLen;i++){\\n            pMustBitMask[i] |= 1<<(puzzles[i].charAt(0)-\\'a\\');\\n            for(char ch : puzzles[i].toCharArray())\\n                pBitMask[i] |= 1<<(ch-\\'a\\');\\n        }\\n\\n        for(int j=0;j<pLen;j++){\\n            int count=0;\\n            for(int i=0;i<wLen;i++){\\n                if((wBitMask[i] & pBitMask[j]) == wBitMask[i] && (wBitMask[i] & pMustBitMask[j]) == pMustBitMask[j])\\n                    count++;\\n            }\\n            list.add(count);\\n        }\\n\\n        return list;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        int wLen = words.length, pLen = puzzles.length;\\n        int[] wBitMask = new int[wLen], pBitMask = new int[pLen], pMustBitMask = new int[pLen];\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i=0;i<wLen;i++){\\n            for(char ch : words[i].toCharArray())\\n                wBitMask[i] |= 1<<(ch-\\'a\\');\\n        }\\n\\n        for(int i=0;i<pLen;i++){\\n            pMustBitMask[i] |= 1<<(puzzles[i].charAt(0)-\\'a\\');\\n            for(char ch : puzzles[i].toCharArray())\\n                pBitMask[i] |= 1<<(ch-\\'a\\');\\n        }\\n\\n        for(int j=0;j<pLen;j++){\\n            int count=0;\\n            for(int i=0;i<wLen;i++){\\n                if((wBitMask[i] & pBitMask[j]) == wBitMask[i] && (wBitMask[i] & pMustBitMask[j]) == pMustBitMask[j])\\n                    count++;\\n            }\\n            list.add(count);\\n        }\\n\\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 767278,
                "title": "ruby-tire-beat-100",
                "content": "1. Sort chars in every words and puzzles.\\n2. Build the **Tire of words**, tips: use the **end_count** to accumulate the numbers of words end at current node.\\n3. Find every puzzle in the Tire, for every childs of a node, search it in the puzzle. If exist, find the rest puzzle in the child.\\n4. Use a **flag** to check if current node is a capital of puzzle.\\n5. After flag is true, we could accumulate the **end_count** when node is end.\\n\\n```\\nclass WordDictionary\\n\\n  attr_accessor :childs, :end_count\\n\\n  def initialize()\\n    @childs, @end_count = {}, 0\\n  end\\n\\n  def insert(word)\\n    iterator = self\\n    word.each_char do |char|\\n      iterator.childs[char] ||= WordDictionary.new\\n      iterator = iterator.childs[char]\\n    end\\n    iterator.end_count += 1\\n  end\\n\\n  def find_satisfied(puzzle, capital)\\n    @@puzzle, @@capital = puzzle, capital\\n    @@count = 0\\n    self.find_rest(0)\\n    @@count\\n  end\\n\\n  def find_rest(start_at, contain_capital = false)\\n    @@count += self.end_count if contain_capital && self.end_count > 0\\n    self.childs.each do |char, rest|\\n      i = @@puzzle.index(char, start_at)\\n      rest&.find_rest(i+1, contain_capital || char == @@capital ) if i\\n    end\\n  end\\nend\\n\\ndef find_num_of_valid_words(words, puzzles)\\n  dict = WordDictionary.new\\n  words = words.map { |word| word.chars.uniq.sort.join }\\n  words.each { |word| dict.insert(word) }\\n\\n  capitals = puzzles.map { |puzzle| puzzle[0] }\\n  puzzles = puzzles.map { |puzzle| puzzle.chars.uniq.sort.join }\\n  (0..puzzles.size-1).map { |i| dict.find_satisfied(puzzles[i], capitals[i]) }\\nend\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass WordDictionary\\n\\n  attr_accessor :childs, :end_count\\n\\n  def initialize()\\n    @childs, @end_count = {}, 0\\n  end\\n\\n  def insert(word)\\n    iterator = self\\n    word.each_char do |char|\\n      iterator.childs[char] ||= WordDictionary.new\\n      iterator = iterator.childs[char]\\n    end\\n    iterator.end_count += 1\\n  end\\n\\n  def find_satisfied(puzzle, capital)\\n    @@puzzle, @@capital = puzzle, capital\\n    @@count = 0\\n    self.find_rest(0)\\n    @@count\\n  end\\n\\n  def find_rest(start_at, contain_capital = false)\\n    @@count += self.end_count if contain_capital && self.end_count > 0\\n    self.childs.each do |char, rest|\\n      i = @@puzzle.index(char, start_at)\\n      rest&.find_rest(i+1, contain_capital || char == @@capital ) if i\\n    end\\n  end\\nend\\n\\ndef find_num_of_valid_words(words, puzzles)\\n  dict = WordDictionary.new\\n  words = words.map { |word| word.chars.uniq.sort.join }\\n  words.each { |word| dict.insert(word) }\\n\\n  capitals = puzzles.map { |puzzle| puzzle[0] }\\n  puzzles = puzzles.map { |puzzle| puzzle.chars.uniq.sort.join }\\n  (0..puzzles.size-1).map { |i| dict.find_satisfied(puzzles[i], capitals[i]) }\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372771,
                "title": "fastest-solution-o-m-n-utilising-fixed-7-chars-pattern-length-bit-encoding-of-words",
                "content": "``` csharp\\npublic class Solution\\n{\\n\\t\\tpublic List<int> FindNumOfValidWords(string[] words, string[] puzzles)\\n        {\\n            List<int> result = new List<int>();\\n            Dictionary<int, int> wordSets = new Dictionary<int, int>();\\n            \\n            // Encode word of 26 chars in 31 bit (signed Int)\\n            foreach (string word in words)\\n            {\\n                int bits = 0;\\n                foreach (char c in word)\\n                {\\n                    bits |= 1 << (c - \\'a\\');\\n                }\\n\\n                if (wordSets.ContainsKey(bits))\\n                {\\n                    wordSets[bits]++;\\n                }\\n                else\\n                {\\n                    wordSets[bits] = 1;\\n                }\\n            }\\n\\n            foreach (string puzzle in puzzles)\\n            {\\n                int bits = 0;\\n                int firstCharBitSet = 1 << (puzzle[0] - \\'a\\');\\n                foreach (char c in puzzle)\\n                {\\n                    bits |= 1 << (c - \\'a\\');\\n                }\\n\\n                int count = 0;          \\n                // Decrement pattern (not all chars are mandatory) \\n                // and do \\'and\\' with bits to make sure only bits in puzzle are set\\n                for (int b = bits; b > 0; b = --b & bits)\\n                {\\n                    if ((b & firstCharBitSet) != 0 && wordSets.ContainsKey(b))\\n                    {\\n                        count += wordSets[b];\\n                    }\\n                }\\n\\n                result.Add(count);\\n            }\\n\\n            return result;\\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "``` csharp\\npublic class Solution\\n{\\n\\t\\tpublic List<int> FindNumOfValidWords(string[] words, string[] puzzles)\\n        {\\n            List<int> result = new List<int>();\\n            Dictionary<int, int> wordSets = new Dictionary<int, int>();\\n            \\n            // Encode word of 26 chars in 31 bit (signed Int)\\n            foreach (string word in words)\\n            {\\n                int bits = 0;\\n                foreach (char c in word)\\n                {\\n                    bits |= 1 << (c - \\'a\\');\\n                }\\n\\n                if (wordSets.ContainsKey(bits))\\n                {\\n                    wordSets[bits]++;\\n                }\\n                else\\n                {\\n                    wordSets[bits] = 1;\\n                }\\n            }\\n\\n            foreach (string puzzle in puzzles)\\n            {\\n                int bits = 0;\\n                int firstCharBitSet = 1 << (puzzle[0] - \\'a\\');\\n                foreach (char c in puzzle)\\n                {\\n                    bits |= 1 << (c - \\'a\\');\\n                }\\n\\n                int count = 0;          \\n                // Decrement pattern (not all chars are mandatory) \\n                // and do \\'and\\' with bits to make sure only bits in puzzle are set\\n                for (int b = bits; b > 0; b = --b & bits)\\n                {\\n                    if ((b & firstCharBitSet) != 0 && wordSets.ContainsKey(b))\\n                    {\\n                        count += wordSets[b];\\n                    }\\n                }\\n\\n                result.Add(count);\\n            }\\n\\n            return result;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372744,
                "title": "c-trie-built-by-bits-of-words-time-o-2-puzzles-i-length-puzzles-length-words-length-words",
                "content": "I read lots of threads in discuss. There are many brilliant solution using Trie or bitmap. My solution used both of them. I remember that there is a similair problem in LeetCode and the same solution as mine. But I cannot figure out what it is exactly.\\nHere, I give my solution. I think it is a elegant solution.\\n\\n1. convert a word to bits. Many people find that the order of chars in word is useless.\\n2. insert the bits into Trie. Therefore the children of node are only zero and one because bits presentation.\\n3. For each puzzle, search the Tire using dfs. Because the limit of puzzles[i].length is 7, the time complexity of searching is 2^7.\\n\\nTime complexity: O(2^puzzles[i].length * puzzles.length+ words.length * words).\\nSpace: O(puzzles.length + min(2 ^ 26, words.length)).\\n\\n```cpp\\nclass Solution {\\n    struct Trie {\\n        shared_ptr<Trie> zero, one;\\n        int value = 0;\\n    };\\n    shared_ptr<Trie> root;\\n    int dfs(const vector<bool>& appear, int begin, shared_ptr<Trie> current, int special) {\\n        if (current == nullptr)\\n            return 0;\\n        if (special == begin) {\\n            return dfs(appear, begin + 1, current->one, special) + current->value;\\n        }\\n        if (appear[begin]) {\\n            return dfs(appear, begin + 1, current->zero, special) + dfs(appear, begin + 1, current->one, special) + current->value;\\n        } else {\\n            return dfs(appear, begin + 1, current->zero, special) + current->value;\\n        }\\n    }\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        root = make_shared<Trie>();\\n        for (const string& w : words) {\\n            vector<bool> appear(26, false);\\n            for (char c : w) {\\n                appear[c - \\'a\\'] = true;\\n            }\\n            auto current = root;\\n            for (bool b : appear) {\\n                if (b) {\\n                    if (current->one == nullptr) {\\n                        current->one = make_shared<Trie>();\\n                    }\\n                    current = current->one;\\n                } else {\\n                    if (current->zero == nullptr) {\\n                        current->zero = make_shared<Trie>();\\n                    }\\n                    current = current->zero;\\n                }\\n            }\\n            ++current->value;\\n        }\\n        vector<int> ans(puzzles.size());\\n        for (int i = 0; i < puzzles.size(); ++i) {\\n            const auto& puzzle = puzzles[i];\\n            auto current = root;\\n            vector<bool> appear(26, false);\\n            for (char c : puzzle) {\\n                appear[c - \\'a\\'] = true;\\n            }\\n            ans[i] = dfs(appear, 0, root, puzzle[0] - \\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    struct Trie {\\n        shared_ptr<Trie> zero, one;\\n        int value = 0;\\n    };\\n    shared_ptr<Trie> root;\\n    int dfs(const vector<bool>& appear, int begin, shared_ptr<Trie> current, int special) {\\n        if (current == nullptr)\\n            return 0;\\n        if (special == begin) {\\n            return dfs(appear, begin + 1, current->one, special) + current->value;\\n        }\\n        if (appear[begin]) {\\n            return dfs(appear, begin + 1, current->zero, special) + dfs(appear, begin + 1, current->one, special) + current->value;\\n        } else {\\n            return dfs(appear, begin + 1, current->zero, special) + current->value;\\n        }\\n    }\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        root = make_shared<Trie>();\\n        for (const string& w : words) {\\n            vector<bool> appear(26, false);\\n            for (char c : w) {\\n                appear[c - \\'a\\'] = true;\\n            }\\n            auto current = root;\\n            for (bool b : appear) {\\n                if (b) {\\n                    if (current->one == nullptr) {\\n                        current->one = make_shared<Trie>();\\n                    }\\n                    current = current->one;\\n                } else {\\n                    if (current->zero == nullptr) {\\n                        current->zero = make_shared<Trie>();\\n                    }\\n                    current = current->zero;\\n                }\\n            }\\n            ++current->value;\\n        }\\n        vector<int> ans(puzzles.size());\\n        for (int i = 0; i < puzzles.size(); ++i) {\\n            const auto& puzzle = puzzles[i];\\n            auto current = root;\\n            vector<bool> appear(26, false);\\n            for (char c : puzzle) {\\n                appear[c - \\'a\\'] = true;\\n            }\\n            ans[i] = dfs(appear, 0, root, puzzle[0] - \\'a\\');\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372276,
                "title": "c-144ms-29-6mb-using-bit-operation-to-generate-valid-words-from-puzzle",
                "content": "**Disclaimer:**\\nThe idea for this approach came from Neal_wu\\'s code presented in the following [post](https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/discuss/372037/Can-anyone-explain-neal_wu\\'s-AC-code).\\nHowever, i did manage to improve the performance **from 964ms to 144ms** using maps instead of vectors :).\\n\\nThe idea for the solution is as follows:\\n1. We convert the words to corresponding bitmask(ith bit corresponds to (i+\\'a\\')th character). However, since multiple words maybe having same bitmap(since order doesn\\'t matter), we save the frequency of the same in a map(bitmask -> frequency).\\n2. Similarly, we calculate the bitmasks for every puzzle word.\\n\\t* Instead of calculating all possible words corresponding to puzzle, we use bit operation to only find the next valid bitmask using the statement:\\n\\t* ```temp = (temp - 1) & val;```\\n\\t* In my opinion, the above statement is the core of the algo and an genius trick\\n\\t* It simply produces the next bitmask pattern reducing one char at a time and producing all possible combinations, but only produces valid options i.e. never include a bit that was already unset to start with in puzzle bitmask.\\n3. For each valid permutation, we check if its valid(both conditions) and add the corresponding frequency to our count.\\n\\nFollowing is my final code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& w, vector<string>& p) {\\n        unordered_map<int, int> m;\\n        vector<int> res;\\n        for(string &s: w){\\n            int val = 0;\\n            for(char c: s){\\n                val = val|(1<<(c-\\'a\\'));\\n            }\\n            m[val]++;\\n        }\\n        \\n        for(string &s: p){\\n            int val = 0;\\n            for(char c: s){\\n                val = val|(1<<(c-\\'a\\'));\\n            }\\n            \\n            int temp = val;\\n            int first = s[0] - \\'a\\';\\n            int count = 0;\\n            while(temp != 0){\\n                if(((temp>>first) & 1) == 1){\\n                    if(m.find(temp) != m.end()){\\n                        count += m[temp];\\n                    }\\n                }\\n                \\n                temp = (temp - 1) & val;\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nPlease do comment if you feel my understanding or explanation of the same, needs any improvement :)",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```temp = (temp - 1) & val;```\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& w, vector<string>& p) {\\n        unordered_map<int, int> m;\\n        vector<int> res;\\n        for(string &s: w){\\n            int val = 0;\\n            for(char c: s){\\n                val = val|(1<<(c-\\'a\\'));\\n            }\\n            m[val]++;\\n        }\\n        \\n        for(string &s: p){\\n            int val = 0;\\n            for(char c: s){\\n                val = val|(1<<(c-\\'a\\'));\\n            }\\n            \\n            int temp = val;\\n            int first = s[0] - \\'a\\';\\n            int count = 0;\\n            while(temp != 0){\\n                if(((temp>>first) & 1) == 1){\\n                    if(m.find(temp) != m.end()){\\n                        count += m[temp];\\n                    }\\n                }\\n                \\n                temp = (temp - 1) & val;\\n            }\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372190,
                "title": "1300ms-18mb-17-lines-beats-100-c-solution-explanation",
                "content": "I\\'ve stuck at the last testcase but finally worked it out. \\n Put the version 1 code here first.\\n```\\nint* findNumOfValidWords(char ** words, int wordsSize, char ** puzzles, int puzzlesSize, int* returnSize){\\n    *returnSize = puzzlesSize;\\n    int *ret = (int *)malloc(sizeof(int)**returnSize);\\n    uint32_t *bitmap_p = (int *)malloc(sizeof(uint32_t)*puzzlesSize);\\n    for(int i=0; i < puzzlesSize ; i++)\\n    {\\n        ret[i] = 0;\\n        bitmap_p[i] = (1U<<puzzles[i][0]-\\'a\\') | (1U<<puzzles[i][1]-\\'a\\') | (1U<<puzzles[i][2]-\\'a\\') | (1U<<puzzles[i][3]-\\'a\\') | (1U<<puzzles[i][4]-\\'a\\') | (1U<<puzzles[i][5]-\\'a\\') | (1U<<puzzles[i][6]-\\'a\\') | ((puzzles[i][0]-\\'a\\')<<26);\\n    }\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        register uint32_t bitmap_w = 0, j=0;\\n        while(words[i][j]) bitmap_w |= (1<<(words[i][j++]-\\'a\\'));\\n        for(j=0; j < puzzlesSize; j++)\\n            if((bitmap_p[j] & bitmap_w) == bitmap_w && ((1<<(bitmap_p[j]>>26)) | bitmap_w) == bitmap_w) ret[j]++;\\n    }\\n    free(bitmap_p);\\n    return ret;\\n}\\n```\\n\\nWhen I saw the description, I knew it must be bitmap. However, I spent hours to conqure the last testcase.\\n\\nUntil I realized the most important point lies in the **last lines** of the **Condition** .\\nWhat I do is **just swap two expression in if** to:\\n```\\n(bitmap_p[j] & bitmap_w) == bitmap_w && ((1<<(bitmap_p[j]>>26)) | bitmap_w) == bitmap_w\\n```\\n\\n1. How bitmap builds ?\\nwe know words is more than puzzles, so we build bitmap map array of puzzles to *save memory*.\\nfrom **puzzles[i].length == 7**: this is a const value, so we just copy-paste 7 times `1U<<puzzles[i][0]-\\'a\\'` after `bitmap_p[i] = `.\\n\\tthe last `((puzzles[i][0]-\\'a\\')<<26)`  just for *no subsequent reference* of `puzzles[i]`,  5-bit value can denote decimal number from 0 ~ 31 and 26+5 is exactly 31 bits, which fits a `int` fine!\\n\\n2. why swap the two expression?\\nwhile the first one just need 3 cheap arithmetic logic operation, the second one needs 2 more shift operation.\\nthe hit rate is not that high, the second expression compares 1 byte only, the other one compares whole string!\\n\\nThe solution is not as fast as I expected but it keeps simplicity and memory-saving.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint* findNumOfValidWords(char ** words, int wordsSize, char ** puzzles, int puzzlesSize, int* returnSize){\\n    *returnSize = puzzlesSize;\\n    int *ret = (int *)malloc(sizeof(int)**returnSize);\\n    uint32_t *bitmap_p = (int *)malloc(sizeof(uint32_t)*puzzlesSize);\\n    for(int i=0; i < puzzlesSize ; i++)\\n    {\\n        ret[i] = 0;\\n        bitmap_p[i] = (1U<<puzzles[i][0]-\\'a\\') | (1U<<puzzles[i][1]-\\'a\\') | (1U<<puzzles[i][2]-\\'a\\') | (1U<<puzzles[i][3]-\\'a\\') | (1U<<puzzles[i][4]-\\'a\\') | (1U<<puzzles[i][5]-\\'a\\') | (1U<<puzzles[i][6]-\\'a\\') | ((puzzles[i][0]-\\'a\\')<<26);\\n    }\\n    for(int i=0;i<wordsSize;i++)\\n    {\\n        register uint32_t bitmap_w = 0, j=0;\\n        while(words[i][j]) bitmap_w |= (1<<(words[i][j++]-\\'a\\'));\\n        for(j=0; j < puzzlesSize; j++)\\n            if((bitmap_p[j] & bitmap_w) == bitmap_w && ((1<<(bitmap_p[j]>>26)) | bitmap_w) == bitmap_w) ret[j]++;\\n    }\\n    free(bitmap_p);\\n    return ret;\\n}\\n```\n```\\n(bitmap_p[j] & bitmap_w) == bitmap_w && ((1<<(bitmap_p[j]>>26)) | bitmap_w) == bitmap_w\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2988751,
                "title": "python-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the number of valid words for each puzzle in the list, we can create a dictionary where the keys are masks representing the unique characters in each word and the values are the number of occurrences of words with those characters. Then, for each puzzle, we can iterate through all possible subsets of the characters in the puzzle (excluding the first character) and check if the mask representing those characters is present in the dictionary. If it is, we can add the corresponding value to the total count. Finally, we can check if the first character of the puzzle is present in any of the words and add the corresponding value from the dictionary to the total count.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize an empty dictionary d.\\n- Iterate through the list of words and for each word, create a mask representing the unique characters in the word by setting the corresponding bit in the mask to 1. For example, if the word has the characters \\'a\\', \\'c\\' and \\'e\\', the mask will be 111001.\\n- If the mask is not present in the dictionary, set the value of the mask in the dictionary to 1. If it is present, increment the value by 1.\\n- Initialize an empty result list ans.\\n- Iterate through the list of puzzles and for each puzzle, create a mask representing the characters in the puzzle (excluding the first character) and store it in a variable mask.\\n- Initialize a variable subset to the value of mask.\\n- While subset is not 0, create a new mask representing the characters in the subset combined with the first character of the puzzle and store it in a variable s.\\n- If s is present in the dictionary, add the corresponding value to the total count.\\n- Update the value of subset to be the result of performing a bitwise AND operation between subset - 1 and mask.\\n- If the mask representing the first character of the puzzle is present in the dictionary, add the corresponding value to the total count.\\n- Append the total count to the result list.\\n- Return the result list.\\n# Complexity\\n- Time complexity: O(n * 2^l)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere n is the number of puzzles and l is the maximum length of any puzzle. This is because we have a loop that runs for all n puzzles and for each puzzle, we have a loop that runs for all 2^l possible subsets of the characters in the puzzle.\\n\\n\\n- Space complexity: O(2^l) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we use a dictionary to store the masks representing the unique characters in the words, and the maximum number of entries in the dictionary is 2^l.\\n# Code\\n```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        d = {}\\n        for word in words:\\n            mask = 0\\n            for c in word:\\n                mask |= 1 << (ord(c) - ord(\\'a\\'))\\n            d[mask] = d.get(mask, 0) + 1\\n        ans = []\\n        for puzzle in puzzles:\\n            total = 0\\n            mask = 0\\n            for i in range(1, 7):\\n                mask |= 1 << (ord(puzzle[i]) - ord(\\'a\\'))\\n            subset = mask\\n            while subset:\\n                s = subset | (1 << (ord(puzzle[0]) - ord(\\'a\\')))\\n                if s in d:\\n                    total += d[s]\\n                subset = (subset - 1) & mask\\n            if (1 << (ord(puzzle[0]) - ord(\\'a\\'))) in d:\\n                total += d[1 << (ord(puzzle[0]) - ord(\\'a\\'))]\\n            ans.append(total)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        d = {}\\n        for word in words:\\n            mask = 0\\n            for c in word:\\n                mask |= 1 << (ord(c) - ord(\\'a\\'))\\n            d[mask] = d.get(mask, 0) + 1\\n        ans = []\\n        for puzzle in puzzles:\\n            total = 0\\n            mask = 0\\n            for i in range(1, 7):\\n                mask |= 1 << (ord(puzzle[i]) - ord(\\'a\\'))\\n            subset = mask\\n            while subset:\\n                s = subset | (1 << (ord(puzzle[0]) - ord(\\'a\\')))\\n                if s in d:\\n                    total += d[s]\\n                subset = (subset - 1) & mask\\n            if (1 << (ord(puzzle[0]) - ord(\\'a\\'))) in d:\\n                total += d[1 << (ord(puzzle[0]) - ord(\\'a\\'))]\\n            ans.append(total)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787105,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int maskWord(string word) {\\n        int mask = 0;\\n        for (auto c : word) mask |= (1 << c-\\'a\\');\\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> mask_freq;\\n        for (auto word : words) mask_freq[(maskWord(word))]++;\\n        \\n        vector<int> res;\\n        \\n        for (auto p : puzzles) {\\n            int mask = maskWord(p), submask = mask, first = (1 << p[0]-\\'a\\'), curr = 0;\\n            \\n            while (submask) {\\n                if (submask & first) curr += mask_freq[submask];\\n                \\n                submask = (submask-1) & mask;\\n            }\\n            \\n            res.push_back(curr);\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int maskWord(string word) {\\n        int mask = 0;\\n        for (auto c : word) mask |= (1 << c-\\'a\\');\\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> mask_freq;\\n        for (auto word : words) mask_freq[(maskWord(word))]++;\\n        \\n        vector<int> res;\\n        \\n        for (auto p : puzzles) {\\n            int mask = maskWord(p), submask = mask, first = (1 << p[0]-\\'a\\'), curr = 0;\\n            \\n            while (submask) {\\n                if (submask & first) curr += mask_freq[submask];\\n                \\n                submask = (submask-1) & mask;\\n            }\\n            \\n            res.push_back(curr);\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371934,
                "title": "java-explained-in-detail-every-step-of-bit-manipulation-tc-sc-explained",
                "content": "// General Bit operations\\n// & operator - & operator (operates on 2 bitmasks) returns the new bitmask that contains only those bits set as 1 which are 1 in both bitmasks\\n// m << i => shift each bit of \\'m\\' to left \\'i\\' times (1 << i means shift 1 to left \\'i\\' times -> this would basically SET \\'ith\\' bit as 1)\\n// mask = mask | 1 << i (this will SET the \\'ith\\' bit in \\'mask\\' as 1)\\n// mask - 1 -> eliminates the LAST SUBSEQUENT bit (meaning, the last bit which is 1 will be removed -> this is used to find other subset)\\n// (submask - 1) & mask -> gives ALL the SUBSETs of mask one by one\\n\\n// TC : O(M*N + P*2^7); M = words.length, N = words[0].length, P = puzzles.length, puzzle[0],length = max(7) so number of subsets that could be made is (2 ^ 7) - 1\\n// SC : O(M); if M different masks could be formed\\n```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        Map<Integer, Integer> mapOfBitmask = new HashMap<>(); // map contains the bitmasked string and their frequency\\n        \\n        for(String word : words){\\n            int maskWord = 0; // this butmask would tell that which all characters are there in the word \\n            for(int i = 0; i < word.length(); i++){\\n                maskWord |= 1 << (word.charAt(i) - \\'a\\'); // set \\'ith\\' char(bit in bitmask) as 1\\n            }\\n            mapOfBitmask.put(maskWord, mapOfBitmask.getOrDefault(maskWord, 0) + 1);\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(String puzzle : puzzles) { // puzzle = bde (b, d, e) -> its subsets are -> {b}, {d}, {e}, {b, d}, {b, e}, {d, e}, {} -> total = (2 ^ n) - 1 = 8 - 1 = 7 where n = len(bde)\\n            int puzzleMask = 0; // this butmask would tell that which all characters are there in the puzzle \\n            for(int i = 0; i < puzzle.length(); i++){\\n                puzzleMask |= 1 << (puzzle.charAt(i) - \\'a\\');  // set \\'ith\\' char (bit in bitmask) as 1\\n            }\\n            \\n            int count = 0;\\n            int subMask = puzzleMask; // if mask represents the SET of characters then subMask is the SUBSET of the characters in SET\\n            int first = 1 << (puzzle.charAt(0) - \\'a\\'); // first is a bitmask which which only have 0th idx char to be set as 1\\n            \\n            // this while be out of loop after it checks ALL the subsets of puzzle and it finally sees the empty subset\\n            while(true) {\\n                // (subMask & first) == first -> subMask & first will ONLY be equals to first if and only if the \\'ith\\' bit in subMask and first is set as 1 because all other bits in first are set as 0 so \\'&\\' will make every other bit as 0\\n                // if map contains the subset, then add it to answer\\n                if((subMask & first) == first && mapOfBitmask.containsKey(subMask)){\\n                    count += mapOfBitmask.get(subMask);\\n                }\\n                \\n                if(subMask == 0) break; // if submask is 0, it means subset is empty so break out (submask will become 0 AFTER we tried all the subsets)\\n                \\n                // once we find out if the subset of chars (submask) is present in map or not, it is time to try other subset (submask)\\n                // subMask - 1 eliminates the LAST bit and (& mask) will make sure that after eliminating the LAST significant bit from submask the new submask will ONLY contains the bits which are set to 1 in mask (this means that \\'& mask\\' will make sure that chars in new subset will only come from original set)\\n                // for ex: p = bdeg => 0101101 = mask\\n                // subMask - 1 = 0101101 - 0000001 = 0101100 => bde (bde is a subset of bdeg)\\n                // 0101100 & 0101101 = 0101100\\n                // Now sub = 0101100 => bde (subset of bdeg)\\n                // sub - 1 = 0101100 - 0000001 = 0101010\\n                // 0101010 & 0101100 = 0101000 = bd (again subset of bdeg)\\n                // if we would have not done \\'& mask\\' from above we would have got 0101010 = bdf (\\'f\\' was not present in bdeg so its wron)\\n                subMask = (subMask - 1) & puzzleMask; // get the next substring\\n            }\\n            \\n            res.add(count);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        Map<Integer, Integer> mapOfBitmask = new HashMap<>(); // map contains the bitmasked string and their frequency\\n        \\n        for(String word : words){\\n            int maskWord = 0; // this butmask would tell that which all characters are there in the word \\n            for(int i = 0; i < word.length(); i++){\\n                maskWord |= 1 << (word.charAt(i) - \\'a\\'); // set \\'ith\\' char(bit in bitmask) as 1\\n            }\\n            mapOfBitmask.put(maskWord, mapOfBitmask.getOrDefault(maskWord, 0) + 1);\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        for(String puzzle : puzzles) { // puzzle = bde (b, d, e) -> its subsets are -> {b}, {d}, {e}, {b, d}, {b, e}, {d, e}, {} -> total = (2 ^ n) - 1 = 8 - 1 = 7 where n = len(bde)\\n            int puzzleMask = 0; // this butmask would tell that which all characters are there in the puzzle \\n            for(int i = 0; i < puzzle.length(); i++){\\n                puzzleMask |= 1 << (puzzle.charAt(i) - \\'a\\');  // set \\'ith\\' char (bit in bitmask) as 1\\n            }\\n            \\n            int count = 0;\\n            int subMask = puzzleMask; // if mask represents the SET of characters then subMask is the SUBSET of the characters in SET\\n            int first = 1 << (puzzle.charAt(0) - \\'a\\'); // first is a bitmask which which only have 0th idx char to be set as 1\\n            \\n            // this while be out of loop after it checks ALL the subsets of puzzle and it finally sees the empty subset\\n            while(true) {\\n                // (subMask & first) == first -> subMask & first will ONLY be equals to first if and only if the \\'ith\\' bit in subMask and first is set as 1 because all other bits in first are set as 0 so \\'&\\' will make every other bit as 0\\n                // if map contains the subset, then add it to answer\\n                if((subMask & first) == first && mapOfBitmask.containsKey(subMask)){\\n                    count += mapOfBitmask.get(subMask);\\n                }\\n                \\n                if(subMask == 0) break; // if submask is 0, it means subset is empty so break out (submask will become 0 AFTER we tried all the subsets)\\n                \\n                // once we find out if the subset of chars (submask) is present in map or not, it is time to try other subset (submask)\\n                // subMask - 1 eliminates the LAST bit and (& mask) will make sure that after eliminating the LAST significant bit from submask the new submask will ONLY contains the bits which are set to 1 in mask (this means that \\'& mask\\' will make sure that chars in new subset will only come from original set)\\n                // for ex: p = bdeg => 0101101 = mask\\n                // subMask - 1 = 0101101 - 0000001 = 0101100 => bde (bde is a subset of bdeg)\\n                // 0101100 & 0101101 = 0101100\\n                // Now sub = 0101100 => bde (subset of bdeg)\\n                // sub - 1 = 0101100 - 0000001 = 0101010\\n                // 0101010 & 0101100 = 0101000 = bd (again subset of bdeg)\\n                // if we would have not done \\'& mask\\' from above we would have got 0101010 = bdf (\\'f\\' was not present in bdeg so its wron)\\n                subMask = (subMask - 1) & puzzleMask; // get the next substring\\n            }\\n            \\n            res.add(count);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570888,
                "title": "python-solution-with-no-bit-manipulations",
                "content": "This might be easier to understand than the subset and mask generating code of the other solutions I\\'ve seen.\\nUse itertools.combinations to find all subsets of a puzzle set, and add together the frequency counts.\\n```\\nfrom itertools import combinations\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def findNumOfValidWords(self, words, puzzles):\\n        freq = Counter(frozenset(word) for word in words)\\n\\n        def gen_subsets(puzzle):\\n            for i in range(1, len(puzzle)+1):\\n                for comb in combinations(puzzle, i):\\n                    yield frozenset(comb)\\n\\n        return [sum(freq[subset]\\n                    for subset in gen_subsets(puzzle) if puzzle[0] in subset) for puzzle in puzzles]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import combinations\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def findNumOfValidWords(self, words, puzzles):\\n        freq = Counter(frozenset(word) for word in words)\\n\\n        def gen_subsets(puzzle):\\n            for i in range(1, len(puzzle)+1):\\n                for comb in combinations(puzzle, i):\\n                    yield frozenset(comb)\\n\\n        return [sum(freq[subset]\\n                    for subset in gen_subsets(puzzle) if puzzle[0] in subset) for puzzle in puzzles]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568969,
                "title": "c-bitmask-based-solution-60-time-70-space",
                "content": "This is a really plain one, once you figure out a quick and cheap way to compare strings all the time.\\n\\nAnd we can do so by hashing them into bitmasks so that we will store a `1` into each. slot matching an alphabet letter, starting from the right and ignoring of course repeated characters. For example `\"aaa\"` becomes just `1` in a bitmask representation; `\"acdgaacgca\"` becomes `1001101` (with the `1`s representing respectively: `g00dc0a`) and so on.\\n\\nOnce we have done so, all the work of comparing strings becomes way cheaper!\\n\\nTo do so, we will first of all declare a few variables:\\n* `wLen` and `pLen` will store, respectively, the length of `words` and `puzzles`;\\n* `bits` is going to be a 2D array there we will store our hashes by letter contained (first index) and position (second index);\\n* `bitsPos` will tell us how much we have written in each sub-array of `bits`, with all his cells initially set to `0`;\\n* `s` is a convenient reference to a string we will later use (initialised with the first element of `words`, just because a reference like that has to be initialised);\\n* `res` will be our accumulator variables, already set on the right size (`pLen`) to avoid reallocations.\\n\\nWe will then initialised all the elements of `bits` to be `0` and then proceed parsing `words` with the pointer `i` going across all its elements and using also `tmp`; in this loop we will:\\n* assign the currently pointed element `words[i]` to `s`;\\n* reset `tmp` to be `0`;\\n* compute `tmp` going through each character `c` in `s` and:\\n\\t* subtracting `\\'a\\'` from it, in order to make each value of `c` in the more convenient `0 - 25` range;\\n\\t* using the binary OR operation to add the currently relevant bit (`1 << c`) to `tmp`;\\n* we will then store the final hashed bitmask in all the relevant buckets in `bits` with another loop, storing `tmp` into `j`, setting `k` to be `0` and proceeding until `j` is not `0` we will:\\n\\t* check if the rightmost bit (the currently parsed one) of `j` is `1` and, in case, store `tmp` into `bits[k][bitsPos[k]]`;\\n\\t* increase `bitsPos[k]`;\\n\\t* left shift `j` by one position;\\n\\t* increase `k` by `1` (since we are parsing increasing character values, as long as we still have some left - ie: `j != 0`).\\n\\nAfter all this preparation is done, time to properly parse `puzzles`, similarly going through all of its element with the pointer `i` and also using the variables `tmp` and `start`, we will:\\n* assign the currently pointed element `words[i]` to `s`;\\n* reset `tmp` to be `0`;\\n* compute `tmp` going through each character `c` in `s` and:\\n\\t* subtracting `\\'a\\'` from it, in order to make each value of `c` in the more convenient `0 - 25` range;\\n\\t* using the binary OR operation to add the currently relevant bit (`1 << c`) to `tmp`;\\n* assign the normalised value of the first character of `s` to `start`;\\n* look with `j` through all the `bitsPos[start]` elements that contain `start` and:\\n\\t* if all the letters of `bits[start][j]` are present in `tmp` (`(bits[start][j] & tmp) == bits[start][j]`), then we increase `res[i]`.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        // support variables\\n        int wLen = words.size(), pLen = puzzles.size(), bits[26][wLen], bitsPos[26] = {};\\n        string &s = words[0];\\n        vector<int> res(pLen);\\n        // preparing the bitmask arrays\\n        for (int i = 0; i < 26; i++) {\\n            fill(bits[i], bits[i] + wLen, 0);\\n        }\\n        // parsing words into bitmasks\\n        for (int i = 0, tmp; i < wLen; i++) {\\n            s = words[i];\\n            // turning s into a bitmask\\n            tmp = 0;\\n            for (char c: s) {\\n                c -= \\'a\\';\\n                tmp |= 1 << c;\\n            }\\n            // storing the bitmask in bits by its letters\\n            for (int j = tmp, k = 0; j; j >>= 1, k++) {\\n                if (j & 1) bits[k][bitsPos[k]++] = tmp;\\n            }\\n        }\\n        // parsing puzzles into bitmasks\\n        for (int i = 0, tmp, start; i < pLen; i++) {\\n            s = puzzles[i];\\n            // turning s into a bitmask\\n            tmp = 0;\\n            for (char c: s) {\\n                c -= \\'a\\';\\n                tmp |= 1 << c;\\n            }\\n            // storing the bitmask in bits by its starting letter\\n            start = s[0] - \\'a\\';\\n            for (int j = 0, lmtJ = bitsPos[start]; j < lmtJ; j++) {\\n                if ((bits[start][j] & tmp) == bits[start][j]) res[i]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        // support variables\\n        int wLen = words.size(), pLen = puzzles.size(), bits[26][wLen], bitsPos[26] = {};\\n        string &s = words[0];\\n        vector<int> res(pLen);\\n        // preparing the bitmask arrays\\n        for (int i = 0; i < 26; i++) {\\n            fill(bits[i], bits[i] + wLen, 0);\\n        }\\n        // parsing words into bitmasks\\n        for (int i = 0, tmp; i < wLen; i++) {\\n            s = words[i];\\n            // turning s into a bitmask\\n            tmp = 0;\\n            for (char c: s) {\\n                c -= \\'a\\';\\n                tmp |= 1 << c;\\n            }\\n            // storing the bitmask in bits by its letters\\n            for (int j = tmp, k = 0; j; j >>= 1, k++) {\\n                if (j & 1) bits[k][bitsPos[k]++] = tmp;\\n            }\\n        }\\n        // parsing puzzles into bitmasks\\n        for (int i = 0, tmp, start; i < pLen; i++) {\\n            s = puzzles[i];\\n            // turning s into a bitmask\\n            tmp = 0;\\n            for (char c: s) {\\n                c -= \\'a\\';\\n                tmp |= 1 << c;\\n            }\\n            // storing the bitmask in bits by its starting letter\\n            start = s[0] - \\'a\\';\\n            for (int j = 0, lmtJ = bitsPos[start]; j < lmtJ; j++) {\\n                if ((bits[start][j] & tmp) == bits[start][j]) res[i]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568800,
                "title": "typescript-fast-trie-solution",
                "content": "```\\n\\nfunction findNumOfValidWords(words: string[], puzzles: string[]): number[] {\\n  const trie = new STrie(\\'\\');\\n  words.forEach(w => trie.insert(w));\\n\\n  var ret: number[] = new Array(puzzles.length).fill(0);\\n  for (let i = 0; i < puzzles.length; i++) {\\n    let puzzle = puzzles[i];\\n    ret[i] = getPuzzleCount(trie, puzzle);\\n  }\\n\\n  return ret;\\n};\\n\\n\\nfunction getPuzzleCount(trieMaster: STrie, puzzle: string): number {\\n  var p = puzzle.split(\\'\\').sort();\\n  var tries: Set<STrie> = new Set();\\n  tries.add(trieMaster);\\n\\n  for (let i = 0; i < p.length; i++) {\\n    let l = p[i];\\n\\n    var newTries: STrie[] = [];\\n\\n    tries.forEach(trie => {\\n      if (trie.children.has(l))\\n        newTries.push(trie.children.get(l)!);\\n    });\\n\\n    newTries.forEach(t => tries.add(t));\\n  }\\n\\n\\n  var count = 0;\\n  tries.forEach((trie) => {\\n\\n    if (!trie.end.length) return;\\n    count += trie.end.filter(e => e.includes(puzzle.charAt(0))).length;\\n  });\\n\\n  return count;\\n}\\n\\nclass STrie {\\n  v: string;\\n  children: Map<string, STrie>;\\n  end: string[];\\n\\n  constructor(v: string) {\\n    this.v = v;\\n    this.children = new Map();\\n    this.end = [];\\n  }\\n\\n  insert(string: string) {\\n    let set = new Set(string.split(\\'\\').sort());\\n    let t: STrie = this;\\n\\n    set.forEach(s => {\\n      if (!t.children.has(s))\\n        t.children.set(s, new STrie(s));\\n      t = t.children.get(s)!;\\n    })\\n\\n    t.end.push(string);\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Trie"
                ],
                "code": "```\\n\\nfunction findNumOfValidWords(words: string[], puzzles: string[]): number[] {\\n  const trie = new STrie(\\'\\');\\n  words.forEach(w => trie.insert(w));\\n\\n  var ret: number[] = new Array(puzzles.length).fill(0);\\n  for (let i = 0; i < puzzles.length; i++) {\\n    let puzzle = puzzles[i];\\n    ret[i] = getPuzzleCount(trie, puzzle);\\n  }\\n\\n  return ret;\\n};\\n\\n\\nfunction getPuzzleCount(trieMaster: STrie, puzzle: string): number {\\n  var p = puzzle.split(\\'\\').sort();\\n  var tries: Set<STrie> = new Set();\\n  tries.add(trieMaster);\\n\\n  for (let i = 0; i < p.length; i++) {\\n    let l = p[i];\\n\\n    var newTries: STrie[] = [];\\n\\n    tries.forEach(trie => {\\n      if (trie.children.has(l))\\n        newTries.push(trie.children.get(l)!);\\n    });\\n\\n    newTries.forEach(t => tries.add(t));\\n  }\\n\\n\\n  var count = 0;\\n  tries.forEach((trie) => {\\n\\n    if (!trie.end.length) return;\\n    count += trie.end.filter(e => e.includes(puzzle.charAt(0))).length;\\n  });\\n\\n  return count;\\n}\\n\\nclass STrie {\\n  v: string;\\n  children: Map<string, STrie>;\\n  end: string[];\\n\\n  constructor(v: string) {\\n    this.v = v;\\n    this.children = new Map();\\n    this.end = [];\\n  }\\n\\n  insert(string: string) {\\n    let set = new Set(string.split(\\'\\').sort());\\n    let t: STrie = this;\\n\\n    set.forEach(s => {\\n      if (!t.children.has(s))\\n        t.children.set(s, new STrie(s));\\n      t = t.children.get(s)!;\\n    })\\n\\n    t.end.push(string);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568788,
                "title": "java-solution-brute-optimized-beats-94-5",
                "content": "The question explicitly states 2 condition for a word to be valid:\\nFor a given puzzle word, the corresponding word should:\\n1. Word should contain the first letter of the puzzle word\\n2. All the letters of the word should be contained in the puzzle word\\n\\nSo, the brute force approach can be, we can iterate through each puzzle word, and then for each puzzle word, we can iterate through all the words of the word array. Then check if the word contains the first letter of the puzzle word. If yes, then we can check if all the letters of the word is contained in the puzzle word, if yes then we can update the count of the number of words satisfied for a puzzle word by 1. Similarly, we check the same for the rest of the words in the word array and keep updating the count. At the end of each iteration of the puzzle word, we will add the answer in the final list.\\n\\nThe code for the same is as follows:\\n```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<HashSet<Character>> arr_word = new ArrayList<>();\\n        List<HashSet<Character>> arr_puzzle = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for(String x : words)\\n        {\\n            HashSet<Character> hs = new HashSet<>();\\n            for(char c : x.toCharArray())\\n            {\\n                hs.add(c);\\n            }\\n            arr_word.add(hs);\\n        }\\n        for(String y : puzzles)\\n        {\\n            HashSet<Character> hs = new HashSet<>();\\n            for(char d : y.toCharArray())\\n            {\\n                hs.add(d);\\n            }\\n            arr_puzzle.add(hs);\\n        }\\n        for(int i=0;i<puzzles.length;i++)\\n        {\\n            String puzzles_word = puzzles[i];\\n            int count = 0;\\n            HashSet<Character> temp1 = arr_puzzle.get(i);\\n            char first = puzzles_word.charAt(0);\\n            outer : for(int j=0;j<words.length;j++)\\n            {\\n                HashSet<Character> temp = arr_word.get(j);\\n                if(!temp.contains(first))\\n                    continue;\\n                String current_word = words[j];\\n               inner: for(char e : current_word.toCharArray())\\n               {\\n                   if(temp1.contains(e))\\n                       continue;\\n                   else\\n                      continue outer;\\n               }\\n                count++;\\n            }\\n            ans.add(count);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nBut this method will result in Time Limit Exceeded because the number of the words in the Puzzles array is around 10^4 and in the words array is 10^5. \\n\\nSo, we need to come with a better approach. For this there is a prerequisite and we need to know about concept of Bitmask. You can read this article on the link page to understand about it more clearly.\\n\\nhttps://cp-algorithms.com/algebra/all-submasks.html\\n\\nHere we can make the bitmask for all the words in the the words array and by taking them as a key, store them in a hash table, along with their count as the value. Though getting the TLE error, gives us an indication of using a bitmask. But then using a hashmap and concept of enumeration of submasks of a given bitmask is not intuitive. Then we can iterate through all the puzzle words, and enumerate all submasks for the bitmask of the puzzle word. The number of submasks which is for a given bit mask we just change the positions that are set in the bit mask which generates all the subsets of the bit mask. TWe iterate over each puzzle word. For each puzzle word, we enumerate all submasks for the bitmask of the puzzle word. This will give us a complexity of O(2^puzzle_word.length) but here it is given that puzzle_word.length = 7 at max, so it is not a problem. Then we check if if the given submask is present in the hash table, we then add the value corresponding to it to the count of valid words for the puzzle word. This way, we keep on doing the same thing for all the submasks of the puzzle word. But, there is an issue here, we also need to consider the valid words contains the first letter of the puzzle. In order to satisfy this, while creating the bitmask, we don\\'t consider the first letter of the puzzle as it should always be set. What we do is while checking the hashtable for the submask, we do an OR opearation of submask and the bitmask for the first letter of the puzzle, and then use it as a key. This ensures that the first letter is always present in the word. \\n\\nThe code for the same is as follows:\\n\\n```\\nclass Solution {\\n    private int bitMask(String word)\\n    {\\n        int mask = 0;\\n        for(char c : word.toCharArray())\\n        {\\n            mask |= 1 << (c - \\'a\\');\\n        }\\n        return mask;\\n    }\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        for(String word : words)\\n        {\\n            int key = bitMask(word);\\n            hm.put(key,hm.getOrDefault(key,0)+1);\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(String puz : puzzles)\\n        {   \\n            int first = 1 << (puz.charAt(0) - \\'a\\');\\n            int count = hm.getOrDefault(first,0);\\n            //Otherwise count will be double, once for 1, once for 0 in the submask for first letter of puzzle word \\n            int mask = bitMask(puz.substring(1));\\n            int subset = mask;\\n            while(subset > 0)\\n            {\\n                count += hm.getOrDefault(first | subset, 0);\\n                subset = (subset - 1) & mask;\\n            }\\n            ans.add(count);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nIf you find the solution to be useful, please upvote it.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<HashSet<Character>> arr_word = new ArrayList<>();\\n        List<HashSet<Character>> arr_puzzle = new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for(String x : words)\\n        {\\n            HashSet<Character> hs = new HashSet<>();\\n            for(char c : x.toCharArray())\\n            {\\n                hs.add(c);\\n            }\\n            arr_word.add(hs);\\n        }\\n        for(String y : puzzles)\\n        {\\n            HashSet<Character> hs = new HashSet<>();\\n            for(char d : y.toCharArray())\\n            {\\n                hs.add(d);\\n            }\\n            arr_puzzle.add(hs);\\n        }\\n        for(int i=0;i<puzzles.length;i++)\\n        {\\n            String puzzles_word = puzzles[i];\\n            int count = 0;\\n            HashSet<Character> temp1 = arr_puzzle.get(i);\\n            char first = puzzles_word.charAt(0);\\n            outer : for(int j=0;j<words.length;j++)\\n            {\\n                HashSet<Character> temp = arr_word.get(j);\\n                if(!temp.contains(first))\\n                    continue;\\n                String current_word = words[j];\\n               inner: for(char e : current_word.toCharArray())\\n               {\\n                   if(temp1.contains(e))\\n                       continue;\\n                   else\\n                      continue outer;\\n               }\\n                count++;\\n            }\\n            ans.add(count);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int bitMask(String word)\\n    {\\n        int mask = 0;\\n        for(char c : word.toCharArray())\\n        {\\n            mask |= 1 << (c - \\'a\\');\\n        }\\n        return mask;\\n    }\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        for(String word : words)\\n        {\\n            int key = bitMask(word);\\n            hm.put(key,hm.getOrDefault(key,0)+1);\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        for(String puz : puzzles)\\n        {   \\n            int first = 1 << (puz.charAt(0) - \\'a\\');\\n            int count = hm.getOrDefault(first,0);\\n            //Otherwise count will be double, once for 1, once for 0 in the submask for first letter of puzzle word \\n            int mask = bitMask(puz.substring(1));\\n            int subset = mask;\\n            while(subset > 0)\\n            {\\n                count += hm.getOrDefault(first | subset, 0);\\n                subset = (subset - 1) & mask;\\n            }\\n            ans.add(count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568379,
                "title": "javascript-bit-manipulation-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @param {string[]} puzzles\\n * @return {number[]}\\n */\\nvar findNumOfValidWords = function(words, puzzles) {\\n    \\n    let wordCountMap = new Map();\\n    let res = [];\\n    \\n    for(let i = 0; i < words.length; i++){\\n        \\n        let mask = buildbitmask(words[i]);\\n        \\n        if(wordCountMap.has(mask)){\\n            wordCountMap.set(mask, wordCountMap.get(mask) + 1);\\n        }else{\\n            wordCountMap.set(mask, 1);\\n        }\\n    }\\n    \\n    //console.log(wordCountMap)\\n    \\n    for(let i = 0; i < puzzles.length; i++){\\n        \\n        let first = 1 << (puzzles[i].charCodeAt(0) - 97);\\n        let count = wordCountMap.has(first)? wordCountMap.get(first):0;\\n        \\n        \\n        let mask = buildbitmask(puzzles[i].substring(1));\\n        \\n        for(let submask = mask; submask > 0; submask = (submask - 1) & mask){\\n            \\n            count += wordCountMap.has(submask | first) ? wordCountMap.get(submask | first) : 0;\\n        }\\n        \\n        res.push(count);\\n    }\\n    \\n    \\n    return res;\\n};\\n\\nconst buildbitmask = function(word) {\\n    \\n    let mask = 0;\\n    for(let i = 0; i < word.length; i++){\\n        \\n        mask |= 1 << (word.charCodeAt(i) - 97);\\n    }\\n    return mask;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string[]} puzzles\\n * @return {number[]}\\n */\\nvar findNumOfValidWords = function(words, puzzles) {\\n    \\n    let wordCountMap = new Map();\\n    let res = [];\\n    \\n    for(let i = 0; i < words.length; i++){\\n        \\n        let mask = buildbitmask(words[i]);\\n        \\n        if(wordCountMap.has(mask)){\\n            wordCountMap.set(mask, wordCountMap.get(mask) + 1);\\n        }else{\\n            wordCountMap.set(mask, 1);\\n        }\\n    }\\n    \\n    //console.log(wordCountMap)\\n    \\n    for(let i = 0; i < puzzles.length; i++){\\n        \\n        let first = 1 << (puzzles[i].charCodeAt(0) - 97);\\n        let count = wordCountMap.has(first)? wordCountMap.get(first):0;\\n        \\n        \\n        let mask = buildbitmask(puzzles[i].substring(1));\\n        \\n        for(let submask = mask; submask > 0; submask = (submask - 1) & mask){\\n            \\n            count += wordCountMap.has(submask | first) ? wordCountMap.get(submask | first) : 0;\\n        }\\n        \\n        res.push(count);\\n    }\\n    \\n    \\n    return res;\\n};\\n\\nconst buildbitmask = function(word) {\\n    \\n    let mask = 0;\\n    for(let i = 0; i < word.length; i++){\\n        \\n        mask |= 1 << (word.charCodeAt(i) - 97);\\n    }\\n    return mask;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568333,
                "title": "typescript-bit-manipulation-map",
                "content": "```typescript\\nfunction findNumOfValidWords(words: string[], puzzles: string[]): number[] {\\n  const A: number = \\'a\\'.charCodeAt(0);\\n  \\n  const bit = (char: string): number => {\\n    return (1 << (char.charCodeAt(0) - A));\\n  }\\n\\n  const signature = (word: string): number => {\\n    let sign: number = 0;\\n    for (const c of word) sign |= bit(c);\\n    return sign;\\n  }\\n\\n  const signatureCounts: Map<number, number> = new Map();\\n  for (const word of words) {\\n    const sign = signature(word);\\n    const count = signatureCounts.get(sign) || 0;\\n    signatureCounts.set(sign, count + 1);\\n  }\\n\\n  return puzzles.map((puzzle): number => {\\n    const first = bit(puzzle[0]);\\n    const puzzleSign = signature(puzzle.slice(1));\\n    let count = signatureCounts.get(first) || 0;\\n    for (let submask = puzzleSign; submask > 0; \\n        submask = (submask - 1) & puzzleSign) {\\n      count += (signatureCounts.get(submask | first) || 0); \\n    }\\n    return count;\\n  });\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Bit Manipulation"
                ],
                "code": "```typescript\\nfunction findNumOfValidWords(words: string[], puzzles: string[]): number[] {\\n  const A: number = \\'a\\'.charCodeAt(0);\\n  \\n  const bit = (char: string): number => {\\n    return (1 << (char.charCodeAt(0) - A));\\n  }\\n\\n  const signature = (word: string): number => {\\n    let sign: number = 0;\\n    for (const c of word) sign |= bit(c);\\n    return sign;\\n  }\\n\\n  const signatureCounts: Map<number, number> = new Map();\\n  for (const word of words) {\\n    const sign = signature(word);\\n    const count = signatureCounts.get(sign) || 0;\\n    signatureCounts.set(sign, count + 1);\\n  }\\n\\n  return puzzles.map((puzzle): number => {\\n    const first = bit(puzzle[0]);\\n    const puzzleSign = signature(puzzle.slice(1));\\n    let count = signatureCounts.get(first) || 0;\\n    for (let submask = puzzleSign; submask > 0; \\n        submask = (submask - 1) & puzzleSign) {\\n      count += (signatureCounts.get(submask | first) || 0); \\n    }\\n    return count;\\n  });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568186,
                "title": "java-3-progressive-methods",
                "content": "**Method 1:** Although this brute force method gets TLE, it forms the base of the further optimized solutions, so its essential to understand this trivial but important solution.\\n```\\n/**\\n * 1. puzzle[0] (first letter of puzzle) is in word\\n * 2. All letters of word are in puzzle.\\n * 3. Length of puzzle = 7\\n * 4. All letters of puzzle and word are lowercase alphabets\\n * 5. puzzle has unique letters\\n */\\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\n\\tvar wordLettersList = new ArrayList<Set<Character>>();\\n\\tfor (var word : words)\\n\\t\\twordLettersList.add(toSet(word));\\n\\n\\tvar validWordsCount = new ArrayList<Integer>();\\n\\tfor (var puzzle : puzzles) {\\n\\t\\tvar puzzleLetters = toSet(puzzle);\\n\\t\\tvar count = wordLettersList.stream()\\n\\t\\t\\t\\t\\t\\t\\t\\t   .filter(wordLetters -> wordLetters.contains(puzzle.charAt(0)) && \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      puzzleLetters.containsAll(wordLetters))\\n\\t\\t\\t\\t\\t\\t\\t\\t   .count();\\n\\t\\tvalidWordsCount.add((int) count);\\n\\t}\\n\\treturn validWordsCount;\\n}\\n\\n/**\\n * @param s string\\n * @return character set of s\\n */\\nprivate Set<Character> toSet(String s) {\\n\\treturn IntStream.range(0, s.length())\\n\\t\\t\\t\\t\\t.mapToObj(s::charAt)\\n\\t\\t\\t\\t\\t.collect(Collectors.toCollection(HashSet::new));\\n}\\n```\\n\\n**Method 2:** With our base idea clear that we need to hash and check for subsets, let\\'s optmize it by taking advantage of the fact that the given character set is lowercase alphabets, i.e. only 26 possible characters, which will fit perfectly in a 32 bit int. If uppercase where there as well, then we\\'d have used long. For more characters, our approach might have been slightly different.\\nThis approach is better than method 1, but still gets TLE because of the inner loop. It\\'s possible that in an interview setting this method may get accepted, but for leetcode we need to optimize further.\\n```\\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\tvar maskFreq = getMaskFrequency(words);\\n\\tvar validWordsCount = new ArrayList<Integer>();\\n\\n\\tfor (var puzzle : puzzles) {\\n\\t\\tvar puzzleBitMask = toBitMask(puzzle);\\n\\t\\tvar puzzleFirstLetter = 1 << puzzle.charAt(0) - \\'a\\';\\n\\t\\tvar count = 0;\\n\\n\\t\\tfor (var wordBitMask : maskFreq.keySet()) {\\n\\t\\t\\tvar isPuzzleFirstLetterInWord = (wordBitMask & puzzleFirstLetter) == puzzleFirstLetter;\\n\\t\\t\\tvar puzzleContainsWord = (wordBitMask & puzzleBitMask) == wordBitMask;\\n\\t\\t\\tif (isPuzzleFirstLetterInWord && puzzleContainsWord)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\tvalidWordsCount.add(count);\\n\\t}\\n\\n\\treturn validWordsCount;\\n}\\n\\nprivate Map<Integer, Integer> getMaskFrequency(String[] words) {\\n\\tvar maskFreq = new HashMap<Integer, Integer>();\\n\\tfor (var word : words)\\n\\t\\tmaskFreq.compute(toBitMask(word), (k, frequency) -> (frequency == null) ? 1 : frequency + 1);\\n\\treturn maskFreq;\\n}\\n\\nprivate int toBitMask(String s) {\\n\\treturn IntStream.range(0, s.length())\\n\\t\\t\\t\\t\\t.map(i -> 1 << (s.charAt(i) - \\'a\\'))\\n\\t\\t\\t\\t\\t.reduce(0, (a, b) -> a | b);\\n}\\n```\\n\\n**Method 3**: Optimize inner loop. AC solution, beats 97% submissions.\\n```\\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\tvar maskFreq = getMaskFrequency(words);\\n\\tvar valid = new ArrayList<Integer>();\\n\\n\\tfor (var puzzle : puzzles) {\\n\\t\\tvar puzzleBitMask = toBitMask(puzzle);\\n\\t\\tvar puzzleFirstLetter = 1 << (puzzle.charAt(0) - \\'a\\');\\n\\t\\tvar count = 0;\\n\\t\\tvar combination = puzzleBitMask;\\n\\n\\t\\twhile (combination != 0) {\\n\\t\\t\\tif ((combination & puzzleFirstLetter) == puzzleFirstLetter)\\n\\t\\t\\t\\tcount += maskFreq.getOrDefault(combination, 0);\\n\\t\\t\\tcombination = (combination - 1) & puzzleBitMask;\\n\\t\\t}\\n\\t\\tvalid.add(count);\\n\\t}\\n\\n\\treturn valid;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * 1. puzzle[0] (first letter of puzzle) is in word\\n * 2. All letters of word are in puzzle.\\n * 3. Length of puzzle = 7\\n * 4. All letters of puzzle and word are lowercase alphabets\\n * 5. puzzle has unique letters\\n */\\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\n\\tvar wordLettersList = new ArrayList<Set<Character>>();\\n\\tfor (var word : words)\\n\\t\\twordLettersList.add(toSet(word));\\n\\n\\tvar validWordsCount = new ArrayList<Integer>();\\n\\tfor (var puzzle : puzzles) {\\n\\t\\tvar puzzleLetters = toSet(puzzle);\\n\\t\\tvar count = wordLettersList.stream()\\n\\t\\t\\t\\t\\t\\t\\t\\t   .filter(wordLetters -> wordLetters.contains(puzzle.charAt(0)) && \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t      puzzleLetters.containsAll(wordLetters))\\n\\t\\t\\t\\t\\t\\t\\t\\t   .count();\\n\\t\\tvalidWordsCount.add((int) count);\\n\\t}\\n\\treturn validWordsCount;\\n}\\n\\n/**\\n * @param s string\\n * @return character set of s\\n */\\nprivate Set<Character> toSet(String s) {\\n\\treturn IntStream.range(0, s.length())\\n\\t\\t\\t\\t\\t.mapToObj(s::charAt)\\n\\t\\t\\t\\t\\t.collect(Collectors.toCollection(HashSet::new));\\n}\\n```\n```\\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\tvar maskFreq = getMaskFrequency(words);\\n\\tvar validWordsCount = new ArrayList<Integer>();\\n\\n\\tfor (var puzzle : puzzles) {\\n\\t\\tvar puzzleBitMask = toBitMask(puzzle);\\n\\t\\tvar puzzleFirstLetter = 1 << puzzle.charAt(0) - \\'a\\';\\n\\t\\tvar count = 0;\\n\\n\\t\\tfor (var wordBitMask : maskFreq.keySet()) {\\n\\t\\t\\tvar isPuzzleFirstLetterInWord = (wordBitMask & puzzleFirstLetter) == puzzleFirstLetter;\\n\\t\\t\\tvar puzzleContainsWord = (wordBitMask & puzzleBitMask) == wordBitMask;\\n\\t\\t\\tif (isPuzzleFirstLetterInWord && puzzleContainsWord)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\tvalidWordsCount.add(count);\\n\\t}\\n\\n\\treturn validWordsCount;\\n}\\n\\nprivate Map<Integer, Integer> getMaskFrequency(String[] words) {\\n\\tvar maskFreq = new HashMap<Integer, Integer>();\\n\\tfor (var word : words)\\n\\t\\tmaskFreq.compute(toBitMask(word), (k, frequency) -> (frequency == null) ? 1 : frequency + 1);\\n\\treturn maskFreq;\\n}\\n\\nprivate int toBitMask(String s) {\\n\\treturn IntStream.range(0, s.length())\\n\\t\\t\\t\\t\\t.map(i -> 1 << (s.charAt(i) - \\'a\\'))\\n\\t\\t\\t\\t\\t.reduce(0, (a, b) -> a | b);\\n}\\n```\n```\\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\tvar maskFreq = getMaskFrequency(words);\\n\\tvar valid = new ArrayList<Integer>();\\n\\n\\tfor (var puzzle : puzzles) {\\n\\t\\tvar puzzleBitMask = toBitMask(puzzle);\\n\\t\\tvar puzzleFirstLetter = 1 << (puzzle.charAt(0) - \\'a\\');\\n\\t\\tvar count = 0;\\n\\t\\tvar combination = puzzleBitMask;\\n\\n\\t\\twhile (combination != 0) {\\n\\t\\t\\tif ((combination & puzzleFirstLetter) == puzzleFirstLetter)\\n\\t\\t\\t\\tcount += maskFreq.getOrDefault(combination, 0);\\n\\t\\t\\tcombination = (combination - 1) & puzzleBitMask;\\n\\t\\t}\\n\\t\\tvalid.add(count);\\n\\t}\\n\\n\\treturn valid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568118,
                "title": "c-easy-unordered-map-and-bitmasking",
                "content": "First thought was using Trie but thought we can also solve this using two maps and then keeping a len 26 array for storing that if the char is present in the string or not.\\nThis approach gave **TLE** on the **9th test case.** So had to try and improve the approach.\\n```\\nvector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> ans;\\n        unordered_map<char,vector<string>> startsWith;\\n        unordered_map<string,vector<bool>> charMap;\\n        for(string word:words){\\n            vector<bool> store(26,false);\\n            for(char x:word)\\n                store[x-\\'a\\']=true;\\n            for(int i=0;i<26;i++){\\n                if(store[i])\\n                    startsWith[char(\\'a\\'+i)].push_back(word);\\n            }\\n            charMap[word]=store;\\n        }\\n        \\n        for(string puzzle:puzzles){\\n            int count=0;\\n            vector<bool> store(26,false);\\n            for(char x:puzzle) store[x-\\'a\\']=true;\\n            for(string possible:startsWith[puzzle[0]]){\\n                vector<bool> check=charMap[possible];\\n                bool cond=true;\\n                for(int i=0;i<26;i++){\\n                    if(check[i] and !store[i]) cond=false;\\n                }\\n                if(cond) count++;\\n            }\\n            ans.push_back(count);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n**Bit mask to the rescue**\\nUsed bitmasking for faster lookup and removed the charMap as well. Then it passed all the test cases.\\n```\\nvector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> ans;\\n        unordered_map<char,vector<int>> startsWith;\\n        for(string word:words){\\n            int mask=0;\\n            for(char x:word)\\n                mask|=(1<<(x-\\'a\\'));\\n            for(int i=0;i<26;i++){\\n                if(mask&(1<<i))\\n                    startsWith[char(\\'a\\'+i)].push_back(mask);\\n            }\\n        }\\n        for(string puzzle:puzzles){\\n            int count=0;\\n            int smask=0;\\n            for(char x:puzzle)\\n                smask|=(1<<(x-\\'a\\'));\\n            for(int mask:startsWith[puzzle[0]]){\\n                if((smask&mask)==mask)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nvector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> ans;\\n        unordered_map<char,vector<string>> startsWith;\\n        unordered_map<string,vector<bool>> charMap;\\n        for(string word:words){\\n            vector<bool> store(26,false);\\n            for(char x:word)\\n                store[x-\\'a\\']=true;\\n            for(int i=0;i<26;i++){\\n                if(store[i])\\n                    startsWith[char(\\'a\\'+i)].push_back(word);\\n            }\\n            charMap[word]=store;\\n        }\\n        \\n        for(string puzzle:puzzles){\\n            int count=0;\\n            vector<bool> store(26,false);\\n            for(char x:puzzle) store[x-\\'a\\']=true;\\n            for(string possible:startsWith[puzzle[0]]){\\n                vector<bool> check=charMap[possible];\\n                bool cond=true;\\n                for(int i=0;i<26;i++){\\n                    if(check[i] and !store[i]) cond=false;\\n                }\\n                if(cond) count++;\\n            }\\n            ans.push_back(count);\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\nvector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> ans;\\n        unordered_map<char,vector<int>> startsWith;\\n        for(string word:words){\\n            int mask=0;\\n            for(char x:word)\\n                mask|=(1<<(x-\\'a\\'));\\n            for(int i=0;i<26;i++){\\n                if(mask&(1<<i))\\n                    startsWith[char(\\'a\\'+i)].push_back(mask);\\n            }\\n        }\\n        for(string puzzle:puzzles){\\n            int count=0;\\n            int smask=0;\\n            for(char x:puzzle)\\n                smask|=(1<<(x-\\'a\\'));\\n            for(int mask:startsWith[puzzle[0]]){\\n                if((smask&mask)==mask)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568020,
                "title": "runtime-168-ms-faster-than-83-81-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maskWord(string word) {\\n        int mask = 0;\\n        for (auto c : word) mask |= (1 << c-\\'a\\');\\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> mask_freq;\\n        for (auto word : words) mask_freq[(maskWord(word))]++;\\n        \\n        vector<int> res;\\n        \\n        for (auto p : puzzles) {\\n            int mask = maskWord(p), submask = mask, first = (1 << p[0]-\\'a\\'), curr = 0;\\n            \\n            while (submask) {\\n                if (submask & first) curr += mask_freq[submask];\\n                \\n                submask = (submask-1) & mask;\\n            }\\n            \\n            res.push_back(curr);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maskWord(string word) {\\n        int mask = 0;\\n        for (auto c : word) mask |= (1 << c-\\'a\\');\\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> mask_freq;\\n        for (auto word : words) mask_freq[(maskWord(word))]++;\\n        \\n        vector<int> res;\\n        \\n        for (auto p : puzzles) {\\n            int mask = maskWord(p), submask = mask, first = (1 << p[0]-\\'a\\'), curr = 0;\\n            \\n            while (submask) {\\n                if (submask & first) curr += mask_freq[submask];\\n                \\n                submask = (submask-1) & mask;\\n            }\\n            \\n            res.push_back(curr);\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567954,
                "title": "c-solution-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n\\t\\tmap<int, vector<int>>hashMap;\\n\\t\\tint n = words.size();\\n\\t\\tint m = puzzles.size();\\n\\t\\tvector<int>ans(m, 0);     // to store final answer\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint word_mask = 0;\\n\\t\\t\\t// generating mask for each word\\n\\t\\t\\tfor (auto v : words[i])\\n\\t\\t\\t\\tword_mask = (word_mask | (1 << (v - \\'a\\')));\\n\\n\\t\\t\\t// to restrict pushing the mask of a same word again with the same key\\n\\t\\t\\t// For eg: aaaa will be pushed four times in hashmap if not kept track\\n\\t\\t\\tvector<bool>check(26, 0);\\n\\n\\t\\t\\tfor (auto c : words[i]) {\\n\\t\\t\\t\\tint r = c - \\'a\\';\\n\\t\\t\\t\\tif (check[r] == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\thashMap[c - \\'a\\'].push_back(word_mask);\\n\\t\\t\\t\\tcheck[r] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t// generating mask for each puzzle\\n\\t\\t\\tint puzzle_mask = 0;\\n\\t\\t\\tfor (auto v : puzzles[i]) {\\n\\t\\t\\t\\tpuzzle_mask = (puzzle_mask | (1 << (v - \\'a\\')));\\n\\t\\t\\t}\\n\\t\\t\\tint count = 0;\\n\\t\\t\\t// iterating over words mask which contains first character of puzzle\\n\\t\\t\\tfor (auto word_mask : hashMap[puzzles[i][0] - \\'a\\']) {\\n\\t\\t\\t// if the \\'&\\' and of both mask is equal to the words mask increment count\\n\\t\\t\\t\\tif ((word_mask & puzzle_mask) == word_mask)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tans[i] = count;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n\\t\\tmap<int, vector<int>>hashMap;\\n\\t\\tint n = words.size();\\n\\t\\tint m = puzzles.size();\\n\\t\\tvector<int>ans(m, 0);     // to store final answer\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint word_mask = 0;\\n\\t\\t\\t// generating mask for each word\\n\\t\\t\\tfor (auto v : words[i])\\n\\t\\t\\t\\tword_mask = (word_mask | (1 << (v - \\'a\\')));\\n\\n\\t\\t\\t// to restrict pushing the mask of a same word again with the same key\\n\\t\\t\\t// For eg: aaaa will be pushed four times in hashmap if not kept track\\n\\t\\t\\tvector<bool>check(26, 0);\\n\\n\\t\\t\\tfor (auto c : words[i]) {\\n\\t\\t\\t\\tint r = c - \\'a\\';\\n\\t\\t\\t\\tif (check[r] == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\thashMap[c - \\'a\\'].push_back(word_mask);\\n\\t\\t\\t\\tcheck[r] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t// generating mask for each puzzle\\n\\t\\t\\tint puzzle_mask = 0;\\n\\t\\t\\tfor (auto v : puzzles[i]) {\\n\\t\\t\\t\\tpuzzle_mask = (puzzle_mask | (1 << (v - \\'a\\')));\\n\\t\\t\\t}\\n\\t\\t\\tint count = 0;\\n\\t\\t\\t// iterating over words mask which contains first character of puzzle\\n\\t\\t\\tfor (auto word_mask : hashMap[puzzles[i][0] - \\'a\\']) {\\n\\t\\t\\t// if the \\'&\\' and of both mask is equal to the words mask increment count\\n\\t\\t\\t\\tif ((word_mask & puzzle_mask) == word_mask)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tans[i] = count;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567829,
                "title": "c-iterate-over-submasks",
                "content": "Think of puzzles as a list of queries, because we have `O(n)` queries and `O(m)` words, it is a good idea to preprocess the `words` in `O(m)` time and run query in time of proportional to `n`.\\n\\nSteps:\\n1. Generate and count the occurrence of bit mask for each word in `words`, where bit mask is the occurrence of letters in word.\\n2. For each puzzle, generate a bit mask, and sum the occurrence over all its submasks that include the first letter of puzzle, as for every submask represent one of the combination of letters that a word has.\\n\\n[Here](https://cp-algorithms.com/algebra/all-submasks.html) introduce a common and useful technique to iterate over all submasks.\\n\\n\\n**Complexity**\\n\\nTime: `O(m + n * 2^k)`, where k is size of puzzles[i],\\nMemory: `O(m)`.\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int get_mask(string s) {\\n        int mask = 0;\\n        for (const auto &c : s)\\n            mask |= (1 << (c - \\'a\\'));\\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        int n = puzzles.size();\\n        vector<int> res(n, 0);\\n        unordered_map<int, int> dict;\\n        \\n        // Counter of character set for each word\\n        for (const auto &w : words) {\\n            ++dict[get_mask(w)];\\n        }\\n        \\n        // Iterate over submasks for each word in puzzles\\n        for (int i = 0; i < n; ++i) {\\n            char first = puzzles[i][0] - \\'a\\';\\n            int mask = get_mask(puzzles[i]);\\n            for (int m = mask; m > 0; m = --m & mask) {\\n                if (m & (1 << first)) // Consider a set that contains first letter\\n                    res[i] += dict[m];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int get_mask(string s) {\\n        int mask = 0;\\n        for (const auto &c : s)\\n            mask |= (1 << (c - \\'a\\'));\\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        int n = puzzles.size();\\n        vector<int> res(n, 0);\\n        unordered_map<int, int> dict;\\n        \\n        // Counter of character set for each word\\n        for (const auto &w : words) {\\n            ++dict[get_mask(w)];\\n        }\\n        \\n        // Iterate over submasks for each word in puzzles\\n        for (int i = 0; i < n; ++i) {\\n            char first = puzzles[i][0] - \\'a\\';\\n            int mask = get_mask(puzzles[i]);\\n            for (int m = mask; m > 0; m = --m & mask) {\\n                if (m & (1 << first)) // Consider a set that contains first letter\\n                    res[i] += dict[m];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567734,
                "title": "rust-solution",
                "content": "```\\nuse std::collections::HashMap;\\nuse std::iter::successors;\\n\\nfn to_bit(c: u8) -> u32 {\\n    1 << (c - b\\'a\\') as u32\\n}\\n\\nfn calc_mask(word: &str) -> u32 {\\n    word.bytes().map(to_bit).fold(0, |x, y| x | y)\\n}\\n\\nimpl Solution {\\n    pub fn find_num_of_valid_words(words: Vec<String>, puzzles: Vec<String>) -> Vec<i32> {\\n        let mut cnt = HashMap::new();\\n        for word in words {\\n            *cnt.entry(calc_mask(&word)).or_default() += 1;\\n        }\\n\\n        puzzles\\n            .into_iter()\\n            .map(|puzzle| {\\n                let first = to_bit(puzzle.as_bytes()[0]);\\n                let m = calc_mask(&puzzle) ^ first;\\n                successors(Some(m), |&s| if s > 0 { Some((s - 1) & m) } else { None })\\n                    .filter_map(|m| cnt.get(&(m | first)))\\n                    .sum()\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\nuse std::iter::successors;\\n\\nfn to_bit(c: u8) -> u32 {\\n    1 << (c - b\\'a\\') as u32\\n}\\n\\nfn calc_mask(word: &str) -> u32 {\\n    word.bytes().map(to_bit).fold(0, |x, y| x | y)\\n}\\n\\nimpl Solution {\\n    pub fn find_num_of_valid_words(words: Vec<String>, puzzles: Vec<String>) -> Vec<i32> {\\n        let mut cnt = HashMap::new();\\n        for word in words {\\n            *cnt.entry(calc_mask(&word)).or_default() += 1;\\n        }\\n\\n        puzzles\\n            .into_iter()\\n            .map(|puzzle| {\\n                let first = to_bit(puzzle.as_bytes()[0]);\\n                let m = calc_mask(&puzzle) ^ first;\\n                successors(Some(m), |&s| if s > 0 { Some((s - 1) & m) } else { None })\\n                    .filter_map(|m| cnt.get(&(m | first)))\\n                    .sum()\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1567623,
                "title": "python3-solution",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        n = len(words)\\n        m = len(puzzles)\\n        \\n        freq = defaultdict(int)   # Hash the words in this dictionary\\n        \\n        for w in words:\\n            freq[tuple(sorted(list(set(w))))] += 1\\n        \\n        ans = [0]*m\\n        \\n        for i, w in enumerate(puzzles):\\n            puzzleSet = list(w)\\n\\t\\t\\t# Try all subsets of puzzles[i] because 2nd condition in question is word should be subset of puzzle\\n            for x in range(1 << (len(puzzleSet)-1)):  # Using the fact that length of puzzles[i] is 7 --> 64 iterations (2^6)\\n                puzzleSubSet = [w[0]]   # First letter should be included in the subset of puzzles[i]\\n                for c in puzzleSet[1:]:  # --> 6 iterations\\n                    if x & 1:    # Select the characters whose bit is set to 1\\n                        puzzleSubSet.append(c)\\n                    x = x >> 1  # Divide x by 2\\n                ans[i] += freq[tuple(sorted(puzzleSubSet))]   # Add answer of that subset for puzzles[i]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        n = len(words)\\n        m = len(puzzles)\\n        \\n        freq = defaultdict(int)   # Hash the words in this dictionary\\n        \\n        for w in words:\\n            freq[tuple(sorted(list(set(w))))] += 1\\n        \\n        ans = [0]*m\\n        \\n        for i, w in enumerate(puzzles):\\n            puzzleSet = list(w)\\n\\t\\t\\t# Try all subsets of puzzles[i] because 2nd condition in question is word should be subset of puzzle\\n            for x in range(1 << (len(puzzleSet)-1)):  # Using the fact that length of puzzles[i] is 7 --> 64 iterations (2^6)\\n                puzzleSubSet = [w[0]]   # First letter should be included in the subset of puzzles[i]\\n                for c in puzzleSet[1:]:  # --> 6 iterations\\n                    if x & 1:    # Select the characters whose bit is set to 1\\n                        puzzleSubSet.append(c)\\n                    x = x >> 1  # Divide x by 2\\n                ans[i] += freq[tuple(sorted(puzzleSubSet))]   # Add answer of that subset for puzzles[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529703,
                "title": "rust-trie-based-solution-80ms",
                "content": "\\n```rust\\nuse std::collections::HashMap;\\n\\npub fn find_num_of_valid_words<W: AsRef<str>>(words: Vec<W>, puzzles: Vec<W>) -> Vec<i32> {\\n    let mut trie = Node::default();\\n\\n    // Use a single, pre-allocated buffer in order to avoid wasting time in\\n    // (de)allocating temporary buffers\\n    let mut buffer = Vec::with_capacity(50);\\n\\n    // Sort and deduplicate each word, then add it to the trie\\n    for word in words.iter().map(|w| w.as_ref()) {\\n        buffer.clear();\\n        buffer.extend_from_slice(word.as_bytes());\\n        buffer.sort_unstable();\\n        buffer.dedup();\\n\\n        // Given that the max puzzle length is 7, if the word contains more\\n        // than 7 unique characters, then it cannot be a valid puzzle word\\n        if buffer.len() <= 7 {\\n            trie.insert(buffer.as_slice());\\n        }\\n    }\\n\\n    // We can preallocate the result vector, because we know exactly\\n    // how many elements we need\\n    let mut result = Vec::with_capacity(puzzles.len());\\n\\n    // We need to sort the puzzle input in order to reduce the number of\\n    // searches later\\n    for puzzle in puzzles.iter().map(|w| w.as_ref()) {\\n        buffer.clear();\\n        buffer.extend_from_slice(puzzle.as_bytes());\\n        buffer.sort_unstable();\\n\\n        let first_char = puzzle.as_bytes()[0];\\n        let num_words = trie.matches(&buffer, first_char);\\n        result.push(num_words)\\n    }\\n\\n    result\\n}\\n\\n#[derive(Default)]\\nstruct Node {\\n    nodes: HashMap<u8, Node>,\\n\\n    // Track how many words end here. For instance after\\n    // sorting & deduplication any of \"abc\", \"cba\" and\\n    // \"acb\".. etc will end here, and we must count all\\n    // of them\\n    words: i32,\\n}\\n\\nimpl Node {\\n    pub fn insert<W: AsRef<[u8]>>(&mut self, word: W) {\\n        let word = word.as_ref();\\n\\n        let mut node = self;\\n        for &ch in word.iter() {\\n            node = node.nodes.entry(ch).or_default();\\n        }\\n        node.words += 1;\\n    }\\n\\n    pub fn matches<W: AsRef<[u8]>>(&self, word: W, mark: u8) -> i32 {\\n        let mut word = word.as_ref();\\n        dfs(self, mark, word)\\n    }\\n}\\n\\nfn dfs(mut node: &Node, first: u8, word: &[u8]) -> i32 {\\n    let mut count = 0;\\n\\n    // The current word contains the first character of the puzzle word, so we\\n    // need to add its word counter to the total count. If `first` != 0, then\\n    // the current word does not contain the first character of the puzzle, thus\\n    // we must ignore its word counter\\n    if first == 0 {\\n        count += node.words;\\n    }\\n\\n    for (idx, ch) in word.iter().enumerate() {\\n        // Because the puzzle word is sorted, if the current character (i.e. `ch`)\\n        // is larger than the required first character, then we can `break` out of\\n        // the loop because it will not appear anywhere in the trie\\n        if first != 0 && *ch > first {\\n            break;\\n        }\\n\\n        match node.nodes.get(ch) {\\n            None => continue,\\n            Some(n) => {\\n                // We need to use a local variable, because if `*ch == first`\\n                // for the current iteration of the loop, that will not be\\n                // true for the next iteration!\\n                let mut contains_first = first;\\n                if *ch == contains_first {\\n                    contains_first = 0;\\n                }\\n\\n                // Given that we use sorted puzzles as input, we can safely\\n                // skip all processed characters (idx + 1), as they will be\\n                // \"less\" than the current character,thus they cannot appear\\n                // in the trie at that point, and thus we can greatly reduce\\n                // the number of search operations (`hashmap.get()`)\\n                count += dfs(n, contains_first, &word[idx + 1..]);\\n            }\\n        }\\n    }\\n\\n    count\\n}\\n```\\n\\nThe implementation can be made faster by using a faster Hasher, because the default one is pretty slow",
                "solutionTags": [
                    "Rust",
                    "Trie"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\npub fn find_num_of_valid_words<W: AsRef<str>>(words: Vec<W>, puzzles: Vec<W>) -> Vec<i32> {\\n    let mut trie = Node::default();\\n\\n    // Use a single, pre-allocated buffer in order to avoid wasting time in\\n    // (de)allocating temporary buffers\\n    let mut buffer = Vec::with_capacity(50);\\n\\n    // Sort and deduplicate each word, then add it to the trie\\n    for word in words.iter().map(|w| w.as_ref()) {\\n        buffer.clear();\\n        buffer.extend_from_slice(word.as_bytes());\\n        buffer.sort_unstable();\\n        buffer.dedup();\\n\\n        // Given that the max puzzle length is 7, if the word contains more\\n        // than 7 unique characters, then it cannot be a valid puzzle word\\n        if buffer.len() <= 7 {\\n            trie.insert(buffer.as_slice());\\n        }\\n    }\\n\\n    // We can preallocate the result vector, because we know exactly\\n    // how many elements we need\\n    let mut result = Vec::with_capacity(puzzles.len());\\n\\n    // We need to sort the puzzle input in order to reduce the number of\\n    // searches later\\n    for puzzle in puzzles.iter().map(|w| w.as_ref()) {\\n        buffer.clear();\\n        buffer.extend_from_slice(puzzle.as_bytes());\\n        buffer.sort_unstable();\\n\\n        let first_char = puzzle.as_bytes()[0];\\n        let num_words = trie.matches(&buffer, first_char);\\n        result.push(num_words)\\n    }\\n\\n    result\\n}\\n\\n#[derive(Default)]\\nstruct Node {\\n    nodes: HashMap<u8, Node>,\\n\\n    // Track how many words end here. For instance after\\n    // sorting & deduplication any of \"abc\", \"cba\" and\\n    // \"acb\".. etc will end here, and we must count all\\n    // of them\\n    words: i32,\\n}\\n\\nimpl Node {\\n    pub fn insert<W: AsRef<[u8]>>(&mut self, word: W) {\\n        let word = word.as_ref();\\n\\n        let mut node = self;\\n        for &ch in word.iter() {\\n            node = node.nodes.entry(ch).or_default();\\n        }\\n        node.words += 1;\\n    }\\n\\n    pub fn matches<W: AsRef<[u8]>>(&self, word: W, mark: u8) -> i32 {\\n        let mut word = word.as_ref();\\n        dfs(self, mark, word)\\n    }\\n}\\n\\nfn dfs(mut node: &Node, first: u8, word: &[u8]) -> i32 {\\n    let mut count = 0;\\n\\n    // The current word contains the first character of the puzzle word, so we\\n    // need to add its word counter to the total count. If `first` != 0, then\\n    // the current word does not contain the first character of the puzzle, thus\\n    // we must ignore its word counter\\n    if first == 0 {\\n        count += node.words;\\n    }\\n\\n    for (idx, ch) in word.iter().enumerate() {\\n        // Because the puzzle word is sorted, if the current character (i.e. `ch`)\\n        // is larger than the required first character, then we can `break` out of\\n        // the loop because it will not appear anywhere in the trie\\n        if first != 0 && *ch > first {\\n            break;\\n        }\\n\\n        match node.nodes.get(ch) {\\n            None => continue,\\n            Some(n) => {\\n                // We need to use a local variable, because if `*ch == first`\\n                // for the current iteration of the loop, that will not be\\n                // true for the next iteration!\\n                let mut contains_first = first;\\n                if *ch == contains_first {\\n                    contains_first = 0;\\n                }\\n\\n                // Given that we use sorted puzzles as input, we can safely\\n                // skip all processed characters (idx + 1), as they will be\\n                // \"less\" than the current character,thus they cannot appear\\n                // in the trie at that point, and thus we can greatly reduce\\n                // the number of search operations (`hashmap.get()`)\\n                count += dfs(n, contains_first, &word[idx + 1..]);\\n            }\\n        }\\n    }\\n\\n    count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1416564,
                "title": "scala",
                "content": "```\\nobject Solution {\\n  def findNumOfValidWords(words: Array[String], puzzles: Array[String]): List[Int] = {\\n    val encodedWords = words.map(encodeWord)\\n    puzzles\\n      .toList\\n      .map(Puzzle(_))\\n      .map(puzzle => encodedWords.count(puzzle.isValid))\\n  }\\n\\n  private def encodeChar(char: Char) = 1 << (char - \\'a\\')\\n\\n  private def encodeWord(word: String) = word.map(encodeChar).reduce(_ | _)\\n\\n  private final case class Puzzle(first: Char, encoding: Int) {\\n    def isValid(encodedWord: Int): Boolean = (encodedWord & encodeChar(first)) != 0 && (encodedWord & ~encoding) == 0\\n  }\\n\\n  private object Puzzle {\\n    def apply(puzzle: String): Puzzle = Puzzle(puzzle.head, encodeWord(puzzle))\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  def findNumOfValidWords(words: Array[String], puzzles: Array[String]): List[Int] = {\\n    val encodedWords = words.map(encodeWord)\\n    puzzles\\n      .toList\\n      .map(Puzzle(_))\\n      .map(puzzle => encodedWords.count(puzzle.isValid))\\n  }\\n\\n  private def encodeChar(char: Char) = 1 << (char - \\'a\\')\\n\\n  private def encodeWord(word: String) = word.map(encodeChar).reduce(_ | _)\\n\\n  private final case class Puzzle(first: Char, encoding: Int) {\\n    def isValid(encodedWord: Int): Boolean = (encodedWord & encodeChar(first)) != 0 && (encodedWord & ~encoding) == 0\\n  }\\n\\n  private object Puzzle {\\n    def apply(puzzle: String): Puzzle = Puzzle(puzzle.head, encodeWord(puzzle))\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364628,
                "title": "python3-just-use-bitmasks-and-numpy",
                "content": "Convert words and puzzles to bitmasks, then use vector operations as brute force.\\n\\n```\\nimport numpy as np\\n\\ndef bitmask(w):\\n    res = 0\\n    for c in set(w):\\n        res += (1<<(ord(c)-ord(\\'a\\')))\\n    return res\\n\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        N = len(puzzles)\\n        pz = np.array([bitmask(p) for p in puzzles], dtype=np.int32)\\n        p1 = np.array([bitmask(p[:1]) for p in puzzles], dtype=np.int32)\\n        ans = np.zeros(N, dtype=np.int32)\\n        for w in words:\\n            m = bitmask(w)\\n            l1 = (p1&m).astype(bool)\\n            l2 = (pz&m)==m\\n            ans += (l1&l2)\\n        return [int(x) for x in ans]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nimport numpy as np\\n\\ndef bitmask(w):\\n    res = 0\\n    for c in set(w):\\n        res += (1<<(ord(c)-ord(\\'a\\')))\\n    return res\\n\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        N = len(puzzles)\\n        pz = np.array([bitmask(p) for p in puzzles], dtype=np.int32)\\n        p1 = np.array([bitmask(p[:1]) for p in puzzles], dtype=np.int32)\\n        ans = np.zeros(N, dtype=np.int32)\\n        for w in words:\\n            m = bitmask(w)\\n            l1 = (p1&m).astype(bool)\\n            l2 = (pz&m)==m\\n            ans += (l1&l2)\\n        return [int(x) for x in ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274118,
                "title": "c-clean-soln-using-unordered-map-and-bitmasking-fully-explained-with-examples",
                "content": "Firstly we calculate frequency of different masks from all words storing them in unordered_map. We remove duplicate characters from each word and calculate its corresponding mask and increase its frequency. \\nWhat mask here means is- Eg, word=abdaa, set of characters=abd, its mask is 1011=11(decimal) set bits are for a,b and d.\\n\\nAfter that for each word in puzzle we calculate all its different masks which contains first character always, so these would be total 2^6 different masks(for each character either include it or not). Calcsubset funtion is used for this purpose. \\nThen we iterate through 64 masks of each word in puzzle and for each mask add its corresponding frequency by looking into our hash table and finally store it in our answer vector. \\nI hope it\\'s all clear now.\\n\\n```\\nclass Solution {\\npublic:\\n    void calcsubset(string s,vector<int> &tp){\\n        int bit=s[0]-\\'a\\';\\n        int mask=1<<bit;\\n        tp.push_back(mask);\\n        for(int i=1;i<7;i++){\\n            int sz=tp.size();\\n            for(int j=0;j<sz;j++){\\n                mask=tp[j];\\n                bit=s[i]-\\'a\\';\\n                mask=mask | (1<<bit);\\n                tp.push_back(mask);\\n            }\\n        }\\n    }\\n\\t\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzz) {\\n        unordered_map<int,int> m;\\n        int n=words.size();\\n        for(int i=0;i<n;i++){\\n            int mask=0;\\n            for(char c:words[i]){\\n                int bit=c-\\'a\\';\\n                mask=mask | (1<<bit);\\n            }\\n            m[mask]++;\\n        }\\n\\t\\t\\n        int psz=puzz.size();\\n        vector<int> ans(psz);\\n        for(int i=0;i<psz;i++){\\n            vector<int> tp;\\n            calcsubset(puzz[i],tp);\\n            int ct=0;\\n            for(int j=0;j<tp.size();j++){\\n                if(m.find(tp[j])!=m.end()) ct+=m[tp[j]];\\n            }\\n            ans[i]=ct;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void calcsubset(string s,vector<int> &tp){\\n        int bit=s[0]-\\'a\\';\\n        int mask=1<<bit;\\n        tp.push_back(mask);\\n        for(int i=1;i<7;i++){\\n            int sz=tp.size();\\n            for(int j=0;j<sz;j++){\\n                mask=tp[j];\\n                bit=s[i]-\\'a\\';\\n                mask=mask | (1<<bit);\\n                tp.push_back(mask);\\n            }\\n        }\\n    }\\n\\t\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzz) {\\n        unordered_map<int,int> m;\\n        int n=words.size();\\n        for(int i=0;i<n;i++){\\n            int mask=0;\\n            for(char c:words[i]){\\n                int bit=c-\\'a\\';\\n                mask=mask | (1<<bit);\\n            }\\n            m[mask]++;\\n        }\\n\\t\\t\\n        int psz=puzz.size();\\n        vector<int> ans(psz);\\n        for(int i=0;i<psz;i++){\\n            vector<int> tp;\\n            calcsubset(puzz[i],tp);\\n            int ct=0;\\n            for(int j=0;j<tp.size();j++){\\n                if(m.find(tp[j])!=m.end()) ct+=m[tp[j]];\\n            }\\n            ans[i]=ct;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1273365,
                "title": "bit-manipulation-using-java-and-hashmap",
                "content": "\\tpublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\t\\t\\tHashMap<Character,ArrayList<Integer>> hashMap = new HashMap<>();\\n\\t\\t\\tfor (int i = 0; i <26; i++) {\\n\\t\\t\\t\\thashMap.put((char)(\\'a\\'+i),new ArrayList<>());\\n\\t\\t\\t}\\n\\t\\t\\tfor(String word:words){\\n\\t\\t\\t\\tint mask=0;\\n\\t\\t\\t\\tfor (char ch:word.toCharArray()){\\n\\t\\t\\t\\t\\tint bit=ch-\\'a\\';\\n\\t\\t\\t\\t\\tmask = mask|(1<<bit);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tHashSet<Character> unique =  new HashSet<>();\\n\\t\\t\\t\\tfor (char ch:word.toCharArray()){\\n\\t\\t\\t\\t\\tif (unique.contains(ch)){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tunique.add(ch);\\n\\t\\t\\t\\t\\thashMap.get(ch).add(mask);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// System.out.println(hashMap);\\n\\t\\t\\tArrayList<Integer> res = new ArrayList<>();\\n\\t\\t\\tfor(String puzzle:puzzles){\\n\\t\\t\\t\\tint pmask=0;\\n\\t\\t\\t\\tfor (char ch:puzzle.toCharArray()){\\n\\t\\t\\t\\t\\tint bit=ch-\\'a\\';\\n\\t\\t\\t\\t\\tpmask = pmask|(1<<bit);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchar fch = puzzle.charAt(0);\\n\\t\\t\\t\\tArrayList<Integer> wordsToCheck = hashMap.get(fch);\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tfor (int wmask:wordsToCheck){\\n\\t\\t\\t\\t\\tif ((wmask & pmask)==wmask){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres.add(count);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\n\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\tpublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\t\\t\\tHashMap<Character,ArrayList<Integer>> hashMap = new HashMap<>();\\n\\t\\t\\tfor (int i = 0; i <26; i++) {\\n\\t\\t\\t\\thashMap.put((char)(\\'a\\'+i),new ArrayList<>());\\n\\t\\t\\t}\\n\\t\\t\\tfor(String word:words){\\n\\t\\t\\t\\tint mask=0;\\n\\t\\t\\t\\tfor (char ch:word.toCharArray()){\\n\\t\\t\\t\\t\\tint bit=ch-\\'a\\';\\n\\t\\t\\t\\t\\tmask = mask|(1<<bit);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tHashSet<Character> unique =  new HashSet<>();\\n\\t\\t\\t\\tfor (char ch:word.toCharArray()){\\n\\t\\t\\t\\t\\tif (unique.contains(ch)){\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tunique.add(ch);\\n\\t\\t\\t\\t\\thashMap.get(ch).add(mask);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// System.out.println(hashMap);\\n\\t\\t\\tArrayList<Integer> res = new ArrayList<>();\\n\\t\\t\\tfor(String puzzle:puzzles){\\n\\t\\t\\t\\tint pmask=0;\\n\\t\\t\\t\\tfor (char ch:puzzle.toCharArray()){\\n\\t\\t\\t\\t\\tint bit=ch-\\'a\\';\\n\\t\\t\\t\\t\\tpmask = pmask|(1<<bit);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchar fch = puzzle.charAt(0);\\n\\t\\t\\t\\tArrayList<Integer> wordsToCheck = hashMap.get(fch);\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tfor (int wmask:wordsToCheck){\\n\\t\\t\\t\\t\\tif ((wmask & pmask)==wmask){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres.add(count);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\n\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1167260,
                "title": "go-bitmap-60ms",
                "content": "```\\nfunc findNumOfValidWords(words []string, puzzles []string) []int {\\n    freqWords := make(map[int]int)\\n    // Count how many words are represented by a specific bitmask\\n    for _, word := range words {\\n        // get mask for each word\\n        bs := bits(word) \\n        if _, ok := freqWords[bs]; !ok {\\n            freqWords[bs] = 1\\n        } else {\\n            freqWords[bs] += 1\\n        }\\n    }\\n\\n    result := make([]int, len(puzzles))\\n    for i, puzzle := range puzzles {\\n        // get mask for puzzle\\n        mask := bits(puzzle)\\n        num := 0 // number of words matched in a puzzle\\n        \\n        // set first char bit\\n        fb := 1 << (puzzle[0] - \\'a\\')\\n  \\n        // Iterate subsets of current puzzle\\'s character set\\n        // cur = (cur - 1) & mask runs through (0..(1<<N)) & mask\\n        for cur := mask;cur != 0;cur = ((cur-1) & mask) {\\n            if (cur & fb) == 0 {\\n                continue\\n            }\\n            if v, ok := freqWords[cur]; ok {\\n                num += v\\n            }\\n        }\\n        result[i] = num\\n    }\\n    return result\\n}\\n\\n\\nfunc bits(s string) int {\\n    var bits int\\n    for _, l := range s {\\n        // set the bit in the mask\\n        bits |= 1 << (l - \\'a\\')\\n    }\\n    return bits\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfunc findNumOfValidWords(words []string, puzzles []string) []int {\\n    freqWords := make(map[int]int)\\n    // Count how many words are represented by a specific bitmask\\n    for _, word := range words {\\n        // get mask for each word\\n        bs := bits(word) \\n        if _, ok := freqWords[bs]; !ok {\\n            freqWords[bs] = 1\\n        } else {\\n            freqWords[bs] += 1\\n        }\\n    }\\n\\n    result := make([]int, len(puzzles))\\n    for i, puzzle := range puzzles {\\n        // get mask for puzzle\\n        mask := bits(puzzle)\\n        num := 0 // number of words matched in a puzzle\\n        \\n        // set first char bit\\n        fb := 1 << (puzzle[0] - \\'a\\')\\n  \\n        // Iterate subsets of current puzzle\\'s character set\\n        // cur = (cur - 1) & mask runs through (0..(1<<N)) & mask\\n        for cur := mask;cur != 0;cur = ((cur-1) & mask) {\\n            if (cur & fb) == 0 {\\n                continue\\n            }\\n            if v, ok := freqWords[cur]; ok {\\n                num += v\\n            }\\n        }\\n        result[i] = num\\n    }\\n    return result\\n}\\n\\n\\nfunc bits(s string) int {\\n    var bits int\\n    for _, l := range s {\\n        // set the bit in the mask\\n        bits |= 1 << (l - \\'a\\')\\n    }\\n    return bits\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1134963,
                "title": "java-easy-implementation-using-map-and-bit",
                "content": "class Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\t\\n        HashMap<Character,List<Integer>> map=new HashMap<>();\\n    \\n        for(String word:words)\\n        {\\n            int value=0;\\n            HashSet<Character>set=new HashSet<>();\\n            for(char temp:word.toCharArray())\\n            {\\n                value=value | 1<<(temp-\\'a\\');\\n                set.add(temp);\\n            }\\n            for(Character temp:set)\\n                map.computeIfAbsent(temp,v->new ArrayList<>()).add(value);\\n        }\\n        \\n        List<Integer> ans=new ArrayList<>();\\n        for(String word:puzzles)\\n        {\\n            int count=0;\\n            int bitmap=findBitMap(word);\\n            List<Integer> list=map.get(word.charAt(0));\\n            if(list==null)\\n            {\\n                ans.add(0);\\n                continue;\\n            }\\n            for(Integer wordsBitMap:list)\\n                if( (bitmap & wordsBitMap)==wordsBitMap)\\n                    count++;\\n            ans.add(count);   \\n        }\\n        return ans;\\n    }\\n    \\n    public int findBitMap(String word)\\n    {\\n        int value=0;\\n        for(char temp:word.toCharArray())    \\n                value=value | 1<<(temp-\\'a\\');\\n                \\n        \\n        return value;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\t\\n        HashMap<Character,List<Integer>> map=new HashMap<>();\\n    \\n        for(String word:words)\\n        {\\n            int value=0;\\n            HashSet<Character>set=new HashSet<>();\\n            for(char temp:word.toCharArray())\\n            {\\n                value=value | 1<<(temp-\\'a\\');\\n                set.add(temp);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 963116,
                "title": "c-bit-manipulation-easy",
                "content": "class Solution {\\npublic:\\n    \\n    // Two ways are there to solve this question\\n    // 1. Take every element of the puzzle, get the map of all the characters in it and simultaneously check for the those characters in list words\\n    // 2. Store the mask obtained from the list words in unordered_map. Take each string from the list puzzles, prepare the temporary mask for all the possible combination and check for that particular mask in unordered_map.\\n    \\n    \\n    // Since According to the given constraint as the puzzles[i] length is fixed=7. We can easily choose the 2nd option. As this is going to reduce the time and space complexity.\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int,int>mp;\\n        int Mod=pow(2,6);          // Combination start point. As the first element must be in the word list.\\n        for(int i=0;i<words.size();i++){\\n            int mask=0;\\n            for(int j=0;j<words[i].length();j++){\\n                mask|=(1<<(words[i][j]-\\'a\\'));\\n            }\\n            mp[mask]++;                                 // Adding the prepared mask in the unordered_map\\n        }\\n        vector<int>ans(puzzles.size(),0);\\n        for(int i=0;i<puzzles.size();i++){\\n            int count=0;\\n            for(int j=Mod;j<(1<<7);j++){                // Going for all the possible combination in the list puzzles \\n                int tmask=0;  \\n                for(int k=0;k<7;k++){\\n                    if((j>>k)&1){\\n                        int index=7-k-1;\\n                        tmask|=(1<<(puzzles[i][index]-\\'a\\'));     // preparing the temporary mask;\\n                    }\\n                }\\n                if(mp.find(tmask)!=mp.end()){\\n                    count+=mp[tmask];\\n                }\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // Two ways are there to solve this question\\n    // 1. Take every element of the puzzle, get the map of all the characters in it and simultaneously check for the those characters in list words\\n    // 2. Store the mask obtained from the list words in unordered_map. Take each string from the list puzzles, prepare the temporary mask for all the possible combination and check for that particular mask in unordered_map.\\n    \\n    \\n    // Since According to the given constraint as the puzzles[i] length is fixed=7. We can easily choose the 2nd option. As this is going to reduce the time and space complexity.\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int,int>mp;\\n        int Mod=pow(2,6);          // Combination start point. As the first element must be in the word list.\\n        for(int i=0;i<words.size();i++){\\n            int mask=0;\\n            for(int j=0;j<words[i].length();j++){\\n                mask|=(1<<(words[i][j]-\\'a\\'));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 897658,
                "title": "c-easy-submask-enumneration-2-n-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        const int N = 26;\\n        int n = words.size();\\n        int m = puzzles.size();\\n        \\n        auto getmask = [&](string s){\\n            int ans = 0;\\n            for(char c : s){\\n                ans |= (1 << (c-\\'a\\'));\\n            }\\n            return ans;\\n        };\\n        vector<int> cnt(1 << N,0);\\n        for(string s : words){ \\n            cnt[getmask(s)]++;\\n        }\\n        vector<int> fans(m,0);\\n        for(int i = 0;i<m;i++){\\n            int ans = 0;\\n            int mask = getmask(puzzles[i]) ;\\n            for(int s = mask;s > 0;s=(s-1)&mask){\\n                int first=  (1 << (puzzles[i][0] - \\'a\\'));\\n                if( (s & first) > 0)\\n                    ans += cnt[s];\\n            }\\n            fans[i] = ans;\\n        }\\n        return fans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        const int N = 26;\\n        int n = words.size();\\n        int m = puzzles.size();\\n        \\n        auto getmask = [&](string s){\\n            int ans = 0;\\n            for(char c : s){\\n                ans |= (1 << (c-\\'a\\'));\\n            }\\n            return ans;\\n        };\\n        vector<int> cnt(1 << N,0);\\n        for(string s : words){ \\n            cnt[getmask(s)]++;\\n        }\\n        vector<int> fans(m,0);\\n        for(int i = 0;i<m;i++){\\n            int ans = 0;\\n            int mask = getmask(puzzles[i]) ;\\n            for(int s = mask;s > 0;s=(s-1)&mask){\\n                int first=  (1 << (puzzles[i][0] - \\'a\\'));\\n                if( (s & first) > 0)\\n                    ans += cnt[s];\\n            }\\n            fans[i] = ans;\\n        }\\n        return fans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671763,
                "title": "c-solution-hashmap-bitmanipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int,int> mp;\\n        for(auto w:words){\\n            int mask=0;\\n            for(auto a:w){\\n                mask|=(1<<(a-\\'a\\'));\\n            }\\n            mp[mask]++;\\n        }\\n        vector<int> ans;\\n        for(auto p:puzzles){\\n            int su=0;\\n            for(auto a:p){\\n                su|=(1<<(a-\\'a\\'));\\n            }\\n            int mas=su;\\n            int first=(1<<(p[0]-\\'a\\'));\\n            int co=0;\\n            while(1){\\n                if(((su & first)==first) && mp.find(su)!=mp.end()){\\n                    co+=mp[su];\\n                }\\n                if(su==0){\\n                    break;\\n                }\\n                su=(su-1)&mas;\\n            }\\n            ans.push_back(co);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int,int> mp;\\n        for(auto w:words){\\n            int mask=0;\\n            for(auto a:w){\\n                mask|=(1<<(a-\\'a\\'));\\n            }\\n            mp[mask]++;\\n        }\\n        vector<int> ans;\\n        for(auto p:puzzles){\\n            int su=0;\\n            for(auto a:p){\\n                su|=(1<<(a-\\'a\\'));\\n            }\\n            int mas=su;\\n            int first=(1<<(p[0]-\\'a\\'));\\n            int co=0;\\n            while(1){\\n                if(((su & first)==first) && mp.find(su)!=mp.end()){\\n                    co+=mp[su];\\n                }\\n                if(su==0){\\n                    break;\\n                }\\n                su=(su-1)&mas;\\n            }\\n            ans.push_back(co);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646552,
                "title": "c-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n\\t\\t\\tunordered_map<int,int> Map;\\n\\t\\t\\tfor(auto& word:words)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mask=0;\\n\\t\\t\\t\\tfor(auto& ch:word)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmask|= (1<<(ch-\\'a\\'));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tMap[mask]+=1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tfor(auto& puzzle:puzzles)\\n\\t\\t\\t{\\n\\n\\t\\t\\t\\tint len=puzzle.size()-1;\\n\\n\\t\\t\\t\\tint count=0;\\n\\t\\t\\t\\tfor(int i=0;i<(1<<len);i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t int mask = (1<<(puzzle[0]-\\'a\\'));\\n\\t\\t\\t\\t\\t\\tfor(int j=0;j<len;j++)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tif((i & (1<<j)))\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tmask|= (1<<(puzzle[j+1]-\\'a\\'));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif(Map.count(mask))\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tcount+=Map[mask];\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans.push_back(count);\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n\\t\\t\\tunordered_map<int,int> Map;\\n\\t\\t\\tfor(auto& word:words)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint mask=0;\\n\\t\\t\\t\\tfor(auto& ch:word)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tmask|= (1<<(ch-\\'a\\'));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 550814,
                "title": "java-use-bit-hash",
                "content": "Please see the comment to avoid TLE.\\n```\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer> res = new ArrayList<>();\\n        if (words == null || puzzles == null || words.length == 0 || puzzles.length == 0) return res;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (String w : words) {\\n            int mask = 0;\\n            for (char c : w.toCharArray()) {\\n                mask |= 1 << (c - \\'a\\');\\n            }\\n            map.put(mask,map.getOrDefault(mask, 0) + 1);\\n        }\\n        for (String p : puzzles) {\\n            int cnt = 0, mask = 0;\\n            for (char c : p.toCharArray()) {\\n                mask |= 1 << (c - \\'a\\');\\n            }\\n            int first = 1 << (p.charAt(0) - \\'a\\'), sub = mask;\\n            //the following codde will TLE\\n            // for (int ws : map.keySet()) {\\n            //     if ((ws & first) == first && (ws & mask) == ws) {\\n            //         cnt += map.get(ws);\\n            //     }\\n            // }\\n            while (sub > 0) {\\n                if ((sub & first) == first) {\\n                    cnt += map.getOrDefault(sub, 0);\\n                }\\n                int prev = sub;\\n                while (sub > 0 && sub == prev) {\\n                    sub = (sub - 1) & mask;\\n                }\\n            }\\n            res.add(cnt);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer> res = new ArrayList<>();\\n        if (words == null || puzzles == null || words.length == 0 || puzzles.length == 0) return res;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (String w : words) {\\n            int mask = 0;\\n            for (char c : w.toCharArray()) {\\n                mask |= 1 << (c - \\'a\\');\\n            }\\n            map.put(mask,map.getOrDefault(mask, 0) + 1);\\n        }\\n        for (String p : puzzles) {\\n            int cnt = 0, mask = 0;\\n            for (char c : p.toCharArray()) {\\n                mask |= 1 << (c - \\'a\\');\\n            }\\n            int first = 1 << (p.charAt(0) - \\'a\\'), sub = mask;\\n            //the following codde will TLE\\n            // for (int ws : map.keySet()) {\\n            //     if ((ws & first) == first && (ws & mask) == ws) {\\n            //         cnt += map.get(ws);\\n            //     }\\n            // }\\n            while (sub > 0) {\\n                if ((sub & first) == first) {\\n                    cnt += map.getOrDefault(sub, 0);\\n                }\\n                int prev = sub;\\n                while (sub > 0 && sub == prev) {\\n                    sub = (sub - 1) & mask;\\n                }\\n            }\\n            res.add(cnt);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548266,
                "title": "java-bitmask-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer>res=new ArrayList<>();\\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(String w:words){\\n            int code=encode(w);\\n            if(map.containsKey(code)){\\n                map.put(code,map.get(code)+1);\\n            }else{\\n                map.put(code,1);\\n            }\\n        }\\n\\n        for(int i=0;i<puzzles.length;i++){\\n            int sum=0;\\n            String puzzle=puzzles[i];\\n            Set<Integer>set=new HashSet<>();\\n            List<Integer>list=new ArrayList<>();\\n            for(int k=0;k<puzzle.length();k++){\\n                set.add((puzzle.charAt(k)-\\'a\\'));\\n            }\\n            generate(new ArrayList<>(set),0,0,list);\\n            for(int n:list){\\n                if(map.containsKey(n)){\\n                    int first=puzzle.charAt(0)-\\'a\\';\\n                    first=1<<first;\\n                    if((n&first)!=0){\\n                        sum+=map.get(n);\\n                    }\\n                }\\n            }\\n            res.add(sum);\\n        }\\n        return res;\\n    }\\n    \\n    public void generate(List<Integer>nums,int index,int n,List<Integer>list){\\n        if(index>=nums.size()){\\n            list.add(n);\\n            return;\\n        }\\n        int pos=nums.get(index);\\n        int copyn1=n;\\n        int copyn2=n;\\n        copyn1=copyn1|(1<<pos);\\n        generate(nums,index+1,copyn1,list);\\n        generate(nums,index+1,copyn2,list);\\n    }\\n    \\n    public int encode(String s){\\n        int res=0;\\n        for(int i=0;i<s.length();i++){\\n            int pos=s.charAt(i)-\\'a\\';\\n            res=res|(1<<pos);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer>res=new ArrayList<>();\\n        Map<Integer,Integer>map=new HashMap<>();\\n        for(String w:words){\\n            int code=encode(w);\\n            if(map.containsKey(code)){\\n                map.put(code,map.get(code)+1);\\n            }else{\\n                map.put(code,1);\\n            }\\n        }\\n\\n        for(int i=0;i<puzzles.length;i++){\\n            int sum=0;\\n            String puzzle=puzzles[i];\\n            Set<Integer>set=new HashSet<>();\\n            List<Integer>list=new ArrayList<>();\\n            for(int k=0;k<puzzle.length();k++){\\n                set.add((puzzle.charAt(k)-\\'a\\'));\\n            }\\n            generate(new ArrayList<>(set),0,0,list);\\n            for(int n:list){\\n                if(map.containsKey(n)){\\n                    int first=puzzle.charAt(0)-\\'a\\';\\n                    first=1<<first;\\n                    if((n&first)!=0){\\n                        sum+=map.get(n);\\n                    }\\n                }\\n            }\\n            res.add(sum);\\n        }\\n        return res;\\n    }\\n    \\n    public void generate(List<Integer>nums,int index,int n,List<Integer>list){\\n        if(index>=nums.size()){\\n            list.add(n);\\n            return;\\n        }\\n        int pos=nums.get(index);\\n        int copyn1=n;\\n        int copyn2=n;\\n        copyn1=copyn1|(1<<pos);\\n        generate(nums,index+1,copyn1,list);\\n        generate(nums,index+1,copyn2,list);\\n    }\\n    \\n    public int encode(String s){\\n        int res=0;\\n        for(int i=0;i<s.length();i++){\\n            int pos=s.charAt(i)-\\'a\\';\\n            res=res|(1<<pos);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501501,
                "title": "concise-trie-solution-with-hashmap-counter-to-handle-duplicate",
                "content": "```Scala\\n  object Solution {\\n\\n    def findNumOfValidWords(words: Array[String], puzzles: Array[String]): List[Int] = {\\n\\n      import scala.collection.mutable.Map\\n      class Node(_v: Char) {\\n        val v = _v\\n        val children = Map[Char, Node]()\\n        var word = \"\"\\n      }\\n\\n      val countMap = Map[String, Int]()\\n      words.foreach(w => countMap.put(w, countMap.getOrElse(w, 0) + 1))\\n\\n      def f(root: Node, set: Set[Char], fc: Char): Int = {\\n        var counter = 0\\n\\n        def g(root: Node, set: Set[Char], fc: Char, hasMet: Boolean): Unit = {\\n          if (root.v != \\' \\' && !set.contains(root.v)) return\\n          val newHasMet = if (root.v == fc) true else hasMet\\n          if (root.word.length > 0 && newHasMet) counter += countMap(root.word)\\n          for (c <- root.children.keySet) g(root.children(c), set, fc, newHasMet)\\n        }\\n\\n        g(root, set, fc, false)\\n        counter\\n      }\\n\\n      val root = new Node(\\' \\')\\n      words.foreach(w => {\\n        var runner = root\\n        for (i <- 0 until w.length) {\\n          if (!runner.children.contains(w.charAt(i))) runner.children.put(w.charAt(i), new Node(w.charAt(i)))\\n          runner = runner.children(w.charAt(i))\\n          if (i == w.length - 1) runner.word = w\\n        }\\n      })\\n      puzzles.map { p => f(root, p.toCharArray.toSet, p charAt 0) }.toList\\n    }\\n  }\\n\\n```",
                "solutionTags": [],
                "code": "```Scala\\n  object Solution {\\n\\n    def findNumOfValidWords(words: Array[String], puzzles: Array[String]): List[Int] = {\\n\\n      import scala.collection.mutable.Map\\n      class Node(_v: Char) {\\n        val v = _v\\n        val children = Map[Char, Node]()\\n        var word = \"\"\\n      }\\n\\n      val countMap = Map[String, Int]()\\n      words.foreach(w => countMap.put(w, countMap.getOrElse(w, 0) + 1))\\n\\n      def f(root: Node, set: Set[Char], fc: Char): Int = {\\n        var counter = 0\\n\\n        def g(root: Node, set: Set[Char], fc: Char, hasMet: Boolean): Unit = {\\n          if (root.v != \\' \\' && !set.contains(root.v)) return\\n          val newHasMet = if (root.v == fc) true else hasMet\\n          if (root.word.length > 0 && newHasMet) counter += countMap(root.word)\\n          for (c <- root.children.keySet) g(root.children(c), set, fc, newHasMet)\\n        }\\n\\n        g(root, set, fc, false)\\n        counter\\n      }\\n\\n      val root = new Node(\\' \\')\\n      words.foreach(w => {\\n        var runner = root\\n        for (i <- 0 until w.length) {\\n          if (!runner.children.contains(w.charAt(i))) runner.children.put(w.charAt(i), new Node(w.charAt(i)))\\n          runner = runner.children(w.charAt(i))\\n          if (i == w.length - 1) runner.word = w\\n        }\\n      })\\n      puzzles.map { p => f(root, p.toCharArray.toSet, p charAt 0) }.toList\\n    }\\n  }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476316,
                "title": "concise-java-backtrack-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        HashMap<Integer, Integer> counter = new HashMap<>();\\n        for(String s: words){\\n            int temp = 0;\\n            for(char c: s.toCharArray())\\n                temp |= (1 << (c - \\'a\\'));\\n            counter.put(temp, counter.getOrDefault(temp, 0) + 1);\\n        }\\n        List<Integer> res = new ArrayList<Integer>();\\n        for(String s : puzzles)\\n            res.add(backtrack(s, counter, 1, 1 << (s.charAt(0) - \\'a\\')));\\n        return res;\\n    }\\n    \\n    public int backtrack(String s, HashMap<Integer, Integer> counter, int level, int path){\\n        if(level == 7) return counter.getOrDefault(path, 0);\\n        return backtrack(s, counter, level + 1, path | 1 << (s.charAt(level) - \\'a\\')) + backtrack(s,counter, level + 1, path);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        HashMap<Integer, Integer> counter = new HashMap<>();\\n        for(String s: words){\\n            int temp = 0;\\n            for(char c: s.toCharArray())\\n                temp |= (1 << (c - \\'a\\'));\\n            counter.put(temp, counter.getOrDefault(temp, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 374992,
                "title": "bit-manipulation-javascript-solution-1116-ms",
                "content": "Original idea with sets failed hard, but bit manipulation works pretty good (memory usage should be improved for sure):\\n```\\nvar findNumOfValidWords = function(words, puzzles) {\\n    var aCharCode = \"a\".charCodeAt();\\n    var puzzlesLetters = new Array(puzzles.length);\\n    var firstLetter = new Array(puzzles.length);\\n    for (var i = 0; i < puzzles.length; i++) {\\n        puzzlesLetters[i] = firstLetter[i] = 1 << (puzzles[i][0].charCodeAt() - aCharCode);\\n        for (var j = 1; j < puzzles[i].length; j++) {\\n            puzzlesLetters[i] |= 1 << (puzzles[i][j].charCodeAt() - aCharCode);\\n        }\\n    }\\n    \\n    var result = new Array(puzzles.length).fill(0);\\n    var wordsLetters;\\n    for (var i = 0; i < words.length; i++) {\\n        wordsLetters = 0;\\n        for (var j = 0; j < words[i].length; j++) {\\n            wordsLetters |= 1 << (words[i][j].charCodeAt() - aCharCode);\\n        }\\n        \\n        for (var j = 0; j < puzzles.length; j++) {\\n            if ((puzzlesLetters[j] & wordsLetters) === wordsLetters && (firstLetter[j] & wordsLetters) === firstLetter[j]) {\\n                result[j]++;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findNumOfValidWords = function(words, puzzles) {\\n    var aCharCode = \"a\".charCodeAt();\\n    var puzzlesLetters = new Array(puzzles.length);\\n    var firstLetter = new Array(puzzles.length);\\n    for (var i = 0; i < puzzles.length; i++) {\\n        puzzlesLetters[i] = firstLetter[i] = 1 << (puzzles[i][0].charCodeAt() - aCharCode);\\n        for (var j = 1; j < puzzles[i].length; j++) {\\n            puzzlesLetters[i] |= 1 << (puzzles[i][j].charCodeAt() - aCharCode);\\n        }\\n    }\\n    \\n    var result = new Array(puzzles.length).fill(0);\\n    var wordsLetters;\\n    for (var i = 0; i < words.length; i++) {\\n        wordsLetters = 0;\\n        for (var j = 0; j < words[i].length; j++) {\\n            wordsLetters |= 1 << (words[i][j].charCodeAt() - aCharCode);\\n        }\\n        \\n        for (var j = 0; j < puzzles.length; j++) {\\n            if ((puzzlesLetters[j] & wordsLetters) === wordsLetters && (firstLetter[j] & wordsLetters) === firstLetter[j]) {\\n                result[j]++;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374712,
                "title": "c-solution-using-bitmask-and-unordered-map-key-idea",
                "content": "There are few things which this questions wants us to implement:\\n* As we only care about the distinct letters present in word not their order. There can be atmost 26 letters are present . And 26 letters can be represented using 32 bit integer .\\n* Use unordered_map<int, int> to store these words , because many words can have same integer representation .\\n* Initially I was checking all valid words with each puzzle but getting the TLE error .\\n* Most important and strange thing here is that we have to use the fact that each puzzle[i] has only 7 disinct letters in it.\\n* there are atmost 2^6 = 64 possible valid words for each puzzle[i].\\n\\nBelow are few helper function, not the whole program,  which you can use if like :)\\n```\\n/*\\n    Convert string to bitmask .     ex : \"bbbd\"  - \"1010\"\\n    */\\n    uint32_t convertToBitMask(string & s){\\n        uint32_t x = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            x = x | (1 << (s[i] - \\'a\\'));\\n        }\\n        return x;\\n    }\\n    \\n    /*\\n    All subsets .\\n    */\\n    void getSubsets(vector<string> & subsets, string & s, int i){\\n        if(i == s.size()){\\n            return ;\\n        }\\n        int n = subsets.size();\\n        string sub;\\n        for(int j = 0; j < n; j++){\\n            sub = subsets[j] + s[i];\\n            subsets.push_back(sub);\\n        }\\n        getSubsets(subsets, s, i + 1);\\n    }\\n\\t\\n\\t/*\\n\\tConvert each word to its bit representation and save in unordered_map . \\n\\t*/\\n\\tvoid charTable(unordered_map<uint32_t, int> & wo, vector<string>& words){\\n        for(int i = 0; i < words.size(); i++){\\n            uint32_t x = convertToBitMask(words[i]);\\n            wo[x] += 1;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\n/*\\n    Convert string to bitmask .     ex : \"bbbd\"  - \"1010\"\\n    */\\n    uint32_t convertToBitMask(string & s){\\n        uint32_t x = 0;\\n        for(int i = 0; i < s.size(); i++){\\n            x = x | (1 << (s[i] - \\'a\\'));\\n        }\\n        return x;\\n    }\\n    \\n    /*\\n    All subsets .\\n    */\\n    void getSubsets(vector<string> & subsets, string & s, int i){\\n        if(i == s.size()){\\n            return ;\\n        }\\n        int n = subsets.size();\\n        string sub;\\n        for(int j = 0; j < n; j++){\\n            sub = subsets[j] + s[i];\\n            subsets.push_back(sub);\\n        }\\n        getSubsets(subsets, s, i + 1);\\n    }\\n\\t\\n\\t/*\\n\\tConvert each word to its bit representation and save in unordered_map . \\n\\t*/\\n\\tvoid charTable(unordered_map<uint32_t, int> & wo, vector<string>& words){\\n        for(int i = 0; i < words.size(); i++){\\n            uint32_t x = convertToBitMask(words[i]);\\n            wo[x] += 1;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 373823,
                "title": "c-hashmap-100-solution",
                "content": "Hey there, if you have never used similar bitmasking before this can look a bit overwhelming. I started of with this blog https://www.hackerearth.com/practice/algorithms/dynamic-programming/bit-masking/tutorial/. I found this question to be on the easier side once you understand this technique. Have a look at my code :-\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> findNumOfValidWords(vector<string>& a, vector<string>& b) {\\n        unordered_map<int, int> hash;\\n        for(int i = 0; i<a.size(); i++){\\n            int mask = 0;\\n            for(auto& c : a[i]){\\n                mask = mask|(1<<(c-\\'a\\'));\\n            }\\n            if(!hash.count(mask)) hash[mask] = 1;\\n            else hash[mask]++;\\n        }\\n        vector<int> ans;\\n        \\n        for(auto& p : b){\\n        int total = 0;   \\n            unordered_map<int, int> map;\\n            int len = p.size();\\n            \\n            for(int i = 0; i<pow(2, len); i++){\\n                if(i&1){\\n                    int mask = 0;\\n                    for(int k = 0; k<len; k++){\\n                        if(i&(1<<k)){\\n                            mask = (mask|1<<(p[k]-\\'a\\'));\\n                            if(hash.count(mask) & !map.count(mask)) {\\n                                map[mask] = hash[mask];\\n                            }\\n                        }\\n                    }\\n                }    \\n            }\\n        for(auto it = map.begin(); it!= map.end(); it++){\\n            total+=it->second;\\n        }\\n            ans.push_back(total);\\n    }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<int> findNumOfValidWords(vector<string>& a, vector<string>& b) {\\n        unordered_map<int, int> hash;\\n        for(int i = 0; i<a.size(); i++){\\n            int mask = 0;\\n            for(auto& c : a[i]){\\n                mask = mask|(1<<(c-\\'a\\'));\\n            }\\n            if(!hash.count(mask)) hash[mask] = 1;\\n            else hash[mask]++;\\n        }\\n        vector<int> ans;\\n        \\n        for(auto& p : b){\\n        int total = 0;   \\n            unordered_map<int, int> map;\\n            int len = p.size();\\n            \\n            for(int i = 0; i<pow(2, len); i++){\\n                if(i&1){\\n                    int mask = 0;\\n                    for(int k = 0; k<len; k++){\\n                        if(i&(1<<k)){\\n                            mask = (mask|1<<(p[k]-\\'a\\'));\\n                            if(hash.count(mask) & !map.count(mask)) {\\n                                map[mask] = hash[mask];\\n                            }\\n                        }\\n                    }\\n                }    \\n            }\\n        for(auto it = map.begin(); it!= map.end(); it++){\\n            total+=it->second;\\n        }\\n            ans.push_back(total);\\n    }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373668,
                "title": "use-trie-tree",
                "content": "```\\nclass TrieNode:\\n    def __init__(self, s=\\'\\'):\\n        self.s = s\\n        self.n = 0\\n        self.child = {}\\nclass Solution:\\n    def findNumOfValidWords(self, words: [str], puzzles: [str]) -> [int]:\\n        wl = map(lambda  i : sorted(set(i)) , words )\\n        t = TrieNode()\\n        for w in wl:\\n            t1 = t\\n            for c in w:\\n                if c not in t1.child:\\n                    t1.child[c] = TrieNode(c)\\n                t1 = t1.child[c]\\n            t1.n +=1\\n        ans = []\\n        for pz in puzzles:\\n            a = 0\\n            st = list( [i, 1 if i.s ==pz[0] else 0] for i in  t.child.values() if i.s in pz )\\n            while len(st)>0:\\n                p = st.pop()\\n                if p[0].s in pz:\\n                    st += list( [i, 1 if i.s ==pz[0] else p[1]] for i in  p[0].child.values() if i.s in pz)\\n                    if p[1] ==1 :\\n                        a += p[0].n\\n            ans.append(a)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self, s=\\'\\'):\\n        self.s = s\\n        self.n = 0\\n        self.child = {}\\nclass Solution:\\n    def findNumOfValidWords(self, words: [str], puzzles: [str]) -> [int]:\\n        wl = map(lambda  i : sorted(set(i)) , words )\\n        t = TrieNode()\\n        for w in wl:\\n            t1 = t\\n            for c in w:\\n                if c not in t1.child:\\n                    t1.child[c] = TrieNode(c)\\n                t1 = t1.child[c]\\n            t1.n +=1\\n        ans = []\\n        for pz in puzzles:\\n            a = 0\\n            st = list( [i, 1 if i.s ==pz[0] else 0] for i in  t.child.values() if i.s in pz )\\n            while len(st)>0:\\n                p = st.pop()\\n                if p[0].s in pz:\\n                    st += list( [i, 1 if i.s ==pz[0] else p[1]] for i in  p[0].child.values() if i.s in pz)\\n                    if p[1] ==1 :\\n                        a += p[0].n\\n            ans.append(a)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372725,
                "title": "python-efficient-enumeration-of-submasks-of-puzzle",
                "content": "convert each ```word``` into a 26 bit mask - note that we could remove all words with >7 unique characters here. each word/mask worth 1 point.\\n\\nconvert ```puzzle``` into a 26 bit mask and enumerate all submasks. there are at most ```2 ** 7``` submasks. this way of enumerating submasks is efficient using only 2 operations. read more about it here: https://cp-algorithms.com/algebra/all-submasks.html\\n\\nalso if a submask is missing the first letter of the puzzle we can ignore it\\n\\n```\\ndef findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n    scores = collections.Counter(reduce(lambda s, c: s | 1 << (ord(c) - ord(\\'a\\')), w, 0) for w in words)\\n    ans = []\\n    for p in puzzles:\\n        score = 0\\n        required_bit = 1 << (ord(p[0]) - ord(\\'a\\'))\\n        mask = submask = reduce(lambda s, c: s | 1 << (ord(c) - ord(\\'a\\')), p, 0)\\n        # enumerate all masks in descending order without repetion\\n        while submask:\\n            if submask & required_bit:\\n                score += scores[submask]\\n            submask = (submask - 1) & mask\\n        ans.append(score)\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```word```\n```puzzle```\n```2 ** 7```\n```\\ndef findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n    scores = collections.Counter(reduce(lambda s, c: s | 1 << (ord(c) - ord(\\'a\\')), w, 0) for w in words)\\n    ans = []\\n    for p in puzzles:\\n        score = 0\\n        required_bit = 1 << (ord(p[0]) - ord(\\'a\\'))\\n        mask = submask = reduce(lambda s, c: s | 1 << (ord(c) - ord(\\'a\\')), p, 0)\\n        # enumerate all masks in descending order without repetion\\n        while submask:\\n            if submask & required_bit:\\n                score += scores[submask]\\n            submask = (submask - 1) & mask\\n        ans.append(score)\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 372336,
                "title": "c-subset-solution-o-2-7-n-try-to-explain-neal-wu-s-great-thought",
                "content": "neal_wu is always the top player in both codeforces and leetcode. He used the *idea of # of combinations in subset* to solve this problem, and as a great hint for me to finally AC after numbers of TLE.\\n\\nHere is how it works\\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) \\n    {\\n        vector<int> freq(1 << 26, 0); // store the combination if all possible(since how character distributed in 26 alphabets is kind of subset problem, each character we can either pick it or not\\n\\n        for (string &word : words) \\n        {\\n            int mask = 0;\\n            for (char c : word)\\n            {\\n                mask |= 1 << (c - \\'a\\'); // construct the subset distribution over one word\\n            }\\n            freq[mask]++; // count the occurance of \"such kind\" of subset\\n        }\\n\\n        vector<int> answer;\\n        for (string &puzzle : puzzles) \\n        {\\n            int mask = 0;\\n            for (char c : puzzle)\\n            {\\n                mask |= 1 << (c - \\'a\\'); // construct the subset distribution over one puzzle\\n            }\\n\\n            int first = puzzle[0] - \\'a\\';\\n            int sub = mask;\\n            int total = 0;\\n\\t\\t\\t\\n\\t\\t\\t/* since there are up to # mask of subset, e.g. 7 for abc (111), then we can count down to see what word can be formed from puzzle \"abc\" \\n\\t\\t\\t111 ---> cba\\n\\t\\t\\t110 ---> cb\\n\\t\\t\\t101 ---> ca\\n\\t\\t\\t100 ---> c\\n\\t\\t\\t011 ---> ba\\n\\t\\t\\t010 ---> b\\n\\t\\t\\t001 ---> a\\n\\t\\t\\t*/\\n            while(1) // important and brilliant part \\n            {\\n                if (sub >> first & 1) // shift to the first char, ex if first char of puzzle is b, then first = 1\\n                {\\n                    total += freq[sub]; // for sub , ex: cba --->  (111 >> 1) & 1, this means count all the occurance of 111 since it \"starts with b\"\\n                }\\n\\n                if (sub == 0) // break if we have used out all subset combinations\\n                {\\n                    break;\\n                }\\n                sub = (sub - 1) & mask; // decrement by one to find next subset\\n            }\\n            answer.push_back(total); // push the answer\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\n\\n* Analysis:\\n\\t* Time complexity O(2 ^ 7 * N) or O(max(sum of len(all(words)), 2 * 7 * len(puzzles)) maybe?\\n\\t* Space complexity O(2^26)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) \\n    {\\n        vector<int> freq(1 << 26, 0); // store the combination if all possible(since how character distributed in 26 alphabets is kind of subset problem, each character we can either pick it or not\\n\\n        for (string &word : words) \\n        {\\n            int mask = 0;\\n            for (char c : word)\\n            {\\n                mask |= 1 << (c - \\'a\\'); // construct the subset distribution over one word\\n            }\\n            freq[mask]++; // count the occurance of \"such kind\" of subset\\n        }\\n\\n        vector<int> answer;\\n        for (string &puzzle : puzzles) \\n        {\\n            int mask = 0;\\n            for (char c : puzzle)\\n            {\\n                mask |= 1 << (c - \\'a\\'); // construct the subset distribution over one puzzle\\n            }\\n\\n            int first = puzzle[0] - \\'a\\';\\n            int sub = mask;\\n            int total = 0;\\n\\t\\t\\t\\n\\t\\t\\t/* since there are up to # mask of subset, e.g. 7 for abc (111), then we can count down to see what word can be formed from puzzle \"abc\" \\n\\t\\t\\t111 ---> cba\\n\\t\\t\\t110 ---> cb\\n\\t\\t\\t101 ---> ca\\n\\t\\t\\t100 ---> c\\n\\t\\t\\t011 ---> ba\\n\\t\\t\\t010 ---> b\\n\\t\\t\\t001 ---> a\\n\\t\\t\\t*/\\n            while(1) // important and brilliant part \\n            {\\n                if (sub >> first & 1) // shift to the first char, ex if first char of puzzle is b, then first = 1\\n                {\\n                    total += freq[sub]; // for sub , ex: cba --->  (111 >> 1) & 1, this means count all the occurance of 111 since it \"starts with b\"\\n                }\\n\\n                if (sub == 0) // break if we have used out all subset combinations\\n                {\\n                    break;\\n                }\\n                sub = (sub - 1) & mask; // decrement by one to find next subset\\n            }\\n            answer.push_back(total); // push the answer\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372227,
                "title": "detailed-c-bit-set-hash-map-and-backtracking-140ms-100-time-100-space",
                "content": "**Basic idea**\\nIf we convert words and puzzles into char sets, the problem is equivalent to: **find all word sets that are subsets of a puzzle set**.\\n\\nWe don\\'t have to check every word against every puzzle. Since the puzzle length is fixed to 7, we can iterate over every subset of the puzzle and find how many times the subset pattern occurs in given words (which can be computed in advance).\\n\\nFixing the first character, the total number of possible subsets of a puzzle is 2^6=256. Thus the complexity for checking a puzzle is O(1) instead of O(M). \\n\\n**Key points:**\\n1. use an integer as a bit set to mark a unique word pattern (you can also use std::bitset)\\n2. use a hash map to count how many times a word pattern occurs\\n3. use backtracking to get all possible subsets of a puzzle\\n\\n**Complexity:**\\n* Counting occurence of word patterns: O(M)\\n* Checking puzzles: O(256 * N) = O(N)\\n* Total complexity: O(M + N)\\n\\n``` c++\\nclass Solution {\\npublic:\\n    inline void setBit(int& bits, int pos) {\\n        bits |= 1 << pos;\\n    }\\n    \\n    const int checkSubset(int& bits, int pos, const string& s, const unordered_map<int, int>& wordSets) {\\n        if (pos == s.size()) {\\n            auto found = wordSets.find(bits);\\n            return found != wordSets.end() ? found->second : 0;\\n        }\\n        int tmp = bits;\\n        \\n        // check with the bit unset\\n        int res = checkSubset(bits, pos + 1, s, wordSets);\\n        \\n        // check with the bit set\\n        setBit(bits, s[pos] - \\'a\\');\\n        res += checkSubset(bits, pos + 1, s, wordSets);\\n        \\n        // reset\\n        bits = tmp;\\n        return res;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> res;\\n        res.reserve(puzzles.size());\\n        \\n        // build bit sets\\n        unordered_map<int, int> wordSets;\\n        for (const auto& word: words) {\\n            int bits = 0;\\n            for (char c: word) {\\n                setBit(bits, c - \\'a\\');\\n            }\\n            wordSets[bits]++;\\n        }\\n        \\n        for (const auto& puzzle: puzzles) {\\n            // the first bit is always set\\n            int bits = 0;\\n            setBit(bits, puzzle[0] - \\'a\\');\\n            \\n            // collect occurences for all possible subsets\\n            int cnt = checkSubset(bits, 1, puzzle, wordSets);\\n            \\n            res.push_back(cnt);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "``` c++\\nclass Solution {\\npublic:\\n    inline void setBit(int& bits, int pos) {\\n        bits |= 1 << pos;\\n    }\\n    \\n    const int checkSubset(int& bits, int pos, const string& s, const unordered_map<int, int>& wordSets) {\\n        if (pos == s.size()) {\\n            auto found = wordSets.find(bits);\\n            return found != wordSets.end() ? found->second : 0;\\n        }\\n        int tmp = bits;\\n        \\n        // check with the bit unset\\n        int res = checkSubset(bits, pos + 1, s, wordSets);\\n        \\n        // check with the bit set\\n        setBit(bits, s[pos] - \\'a\\');\\n        res += checkSubset(bits, pos + 1, s, wordSets);\\n        \\n        // reset\\n        bits = tmp;\\n        return res;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> res;\\n        res.reserve(puzzles.size());\\n        \\n        // build bit sets\\n        unordered_map<int, int> wordSets;\\n        for (const auto& word: words) {\\n            int bits = 0;\\n            for (char c: word) {\\n                setBit(bits, c - \\'a\\');\\n            }\\n            wordSets[bits]++;\\n        }\\n        \\n        for (const auto& puzzle: puzzles) {\\n            // the first bit is always set\\n            int bits = 0;\\n            setBit(bits, puzzle[0] - \\'a\\');\\n            \\n            // collect occurences for all possible subsets\\n            int cnt = checkSubset(bits, 1, puzzle, wordSets);\\n            \\n            res.push_back(cnt);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372212,
                "title": "c-solution-map-bitwise-enumeration",
                "content": "```C++\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> puzzleset;\\n    map<ll, ll> wordset;\\n    ll d[26];\\n    int getones(ll n){\\n        int bits = 0;\\n        while(n!=0){\\n            if(n&1 == 1) bits++;\\n            n = n >> 1;\\n        }\\n        return bits;\\n    }\\n    ll getnum(string &s, int n){\\n        ll sum = 0;\\n        int len = s.length();\\n        int i = 0;\\n        while(n!=0){\\n            if(n&1 == 1){\\n                sum |= d[s[len-i-1]-\\'a\\'];\\n            }\\n            i++;\\n            n = n>>1;\\n        }\\n        return sum;\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> result;\\n        for(int i = 0; i < 26; i++){\\n            d[i] = (1<<i);\\n        }\\n        for(int i = 0; i < words.size(); i++){\\n            ll sum = 0;\\n            for(int j = 0; j < words[i].length(); j++){\\n                sum |= d[words[i][j]-\\'a\\'];\\n            }\\n            if(getones(sum) <= 7){\\n                if(wordset.find(sum) == wordset.end()) wordset[sum] = 1;\\n                else  wordset[sum]++;\\n            }\\n            \\n        }\\n         for(int i = 0; i < puzzles.size(); i++){\\n            ll sum = 0;\\n            for(int j = 0; j < puzzles[i].length(); j++){\\n                sum |= d[puzzles[i][j]-\\'a\\'];\\n            }\\n           \\n            puzzleset.push_back(sum);\\n        }\\n        \\n        \\n        for(int i = 0; i < puzzleset.size(); i++){\\n            int sum = 0;\\n            string str = puzzles[i];\\n            // list different situation on 6 bits\\n            for(int j = 0; j < (1<<6); j++){\\n                ll x = getnum(str, j) | d[str[0]-\\'a\\'];\\n                if(wordset.find(x) != wordset.end()) sum+=wordset[x];\\n            }\\n            result.push_back(sum);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> puzzleset;\\n    map<ll, ll> wordset;\\n    ll d[26];\\n    int getones(ll n){\\n        int bits = 0;\\n        while(n!=0){\\n            if(n&1 == 1) bits++;\\n            n = n >> 1;\\n        }\\n        return bits;\\n    }\\n    ll getnum(string &s, int n){\\n        ll sum = 0;\\n        int len = s.length();\\n        int i = 0;\\n        while(n!=0){\\n            if(n&1 == 1){\\n                sum |= d[s[len-i-1]-\\'a\\'];\\n            }\\n            i++;\\n            n = n>>1;\\n        }\\n        return sum;\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> result;\\n        for(int i = 0; i < 26; i++){\\n            d[i] = (1<<i);\\n        }\\n        for(int i = 0; i < words.size(); i++){\\n            ll sum = 0;\\n            for(int j = 0; j < words[i].length(); j++){\\n                sum |= d[words[i][j]-\\'a\\'];\\n            }\\n            if(getones(sum) <= 7){\\n                if(wordset.find(sum) == wordset.end()) wordset[sum] = 1;\\n                else  wordset[sum]++;\\n            }\\n            \\n        }\\n         for(int i = 0; i < puzzles.size(); i++){\\n            ll sum = 0;\\n            for(int j = 0; j < puzzles[i].length(); j++){\\n                sum |= d[puzzles[i][j]-\\'a\\'];\\n            }\\n           \\n            puzzleset.push_back(sum);\\n        }\\n        \\n        \\n        for(int i = 0; i < puzzleset.size(); i++){\\n            int sum = 0;\\n            string str = puzzles[i];\\n            // list different situation on 6 bits\\n            for(int j = 0; j < (1<<6); j++){\\n                ll x = getnum(str, j) | d[str[0]-\\'a\\'];\\n                if(wordset.find(x) != wordset.end()) sum+=wordset[x];\\n            }\\n            result.push_back(sum);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372203,
                "title": "java-solution-189ms-finally-i-realized-only-2-6-checks-are-necessary-for-each-puzzle",
                "content": "It seems that I got TLE in JAVA during the contest because I failed to take advantage of the fixed length of puzzles.\\n\\nDuring the contest I got TLE for my first submission, where I just used bitwise operation for up to` (words.length * puzzles.length)` times, and the fixed length of puzzles was only used to rule out those words containing more than 7 different characters.\\n\\nAnd it was after reading [this post](https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/discuss/371876/Detailed-Explanation-using-Trie-O(word_length-+-100*puzzle_length)) (by Just__a__Visitor) when I realized even `7!` is a constant number which can be much smaller than `words.length` in the worst case, and this condition of fixed puzzle length should really be made good use of. Then I modified the solution so that for each puzzle we only make `2**6` checks, instead of `words.length` checks.\\n\\nTo further explain this idea, if a word is like \"aacd\", the pattern would be 0000001101, with the three ones from right representing \\'a\\', \\'c\\' and \\'d\\' respectively. And for a puzzle like \"abcdefg\", we will check each of the sub-patterns containing the first character \\'a\\' and any zero to six characters from `{\\'b\\', \\'c\\', \\'d\\', \\'e\\', \\'f\\', \\'g\\'}`.\\n\\nPlease forgive me for my ugly usage of both English and Java. And if there are any mistakes in this post please kindly point out so that I won\\'t mislead anyone else.\\n\\n```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\n\\nclass Solution {\\n\\n    private static int[] masks;\\n    static {\\n        masks = new int[26];\\n        masks[0] = 1;\\n        for (int i = 1; i < 26; i++)\\n            masks[i] = masks[i - 1] << 1;\\n    }\\n\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        HashMap<Integer, Integer> wordPattern = new HashMap<>();\\n        for (String w : words) {\\n            int pat = getPattern(w);\\n            if (pat > 0) wordPattern.put(pat, wordPattern.getOrDefault(pat, 0) + 1);\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (String puz : puzzles) {\\n            int cnt = 0;\\n            ArrayList<Integer> subPatterns = getAllSubPatterns(puz);\\n            for (int subPat : subPatterns)\\n                cnt += wordPattern.getOrDefault(subPat, 0);\\n            ans.add(cnt);\\n        }\\n        return ans;\\n    }\\n\\n    private ArrayList<Integer> getAllSubPatterns(String s) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0; i < (1 << 6); i++) {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s.charAt(0));\\n            for (int k = 0; k < 6; k++)\\n                if ((i & masks[k]) != 0)\\n                    sb.append(s.charAt(k + 1));\\n\\n            ans.add(getPattern(sb.toString()));\\n        }\\n        return ans;\\n    }\\n\\n    private int getPattern(String s) {\\n        boolean[] contain = new boolean[26];\\n        for (char c : s.toCharArray()) contain[c - \\'a\\'] = true;\\n        int ans = 0;\\n        int cnt = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (contain[i]) {\\n                cnt++;\\n                ans |= masks[i];\\n            }\\n        }\\n        if (cnt <= 7) return ans;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\n\\nclass Solution {\\n\\n    private static int[] masks;\\n    static {\\n        masks = new int[26];\\n        masks[0] = 1;\\n        for (int i = 1; i < 26; i++)\\n            masks[i] = masks[i - 1] << 1;\\n    }\\n\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        \\n        HashMap<Integer, Integer> wordPattern = new HashMap<>();\\n        for (String w : words) {\\n            int pat = getPattern(w);\\n            if (pat > 0) wordPattern.put(pat, wordPattern.getOrDefault(pat, 0) + 1);\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (String puz : puzzles) {\\n            int cnt = 0;\\n            ArrayList<Integer> subPatterns = getAllSubPatterns(puz);\\n            for (int subPat : subPatterns)\\n                cnt += wordPattern.getOrDefault(subPat, 0);\\n            ans.add(cnt);\\n        }\\n        return ans;\\n    }\\n\\n    private ArrayList<Integer> getAllSubPatterns(String s) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0; i < (1 << 6); i++) {\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s.charAt(0));\\n            for (int k = 0; k < 6; k++)\\n                if ((i & masks[k]) != 0)\\n                    sb.append(s.charAt(k + 1));\\n\\n            ans.add(getPattern(sb.toString()));\\n        }\\n        return ans;\\n    }\\n\\n    private int getPattern(String s) {\\n        boolean[] contain = new boolean[26];\\n        for (char c : s.toCharArray()) contain[c - \\'a\\'] = true;\\n        int ans = 0;\\n        int cnt = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (contain[i]) {\\n                cnt++;\\n                ans |= masks[i];\\n            }\\n        }\\n        if (cnt <= 7) return ans;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 372133,
                "title": "c-bit-manipulation-with-explanation",
                "content": "**BIT MANIPULATION SOLUTION**\\n\\n\\ncomplexity O(puzzles.size()* (2^6) ) ie  O(10^4 * 2^6)\\n\\nfirst of all store the all mask for the all word words in a hash table\\n\\n**1) step 1**\\n```\\n\\nmap<int,int>mymap; //declare the hash table \\n\\n for(int i=0;i<words.size();i++){\\n            long long x=0;\\n            for(int j=0;j<words[i].size();j++){\\n\\t\\t\\t// 0 th bit for \\'a\\', 1st for \\'b\\' ... and so on\\n                int m=words[i][j]-\\'a\\'; // finding the position of the alphabet \\n                x|=(1<<m);   // setting mth bit to 1\\n            }\\n            mymap[x]++; // we are storing the count  mask of each word\\n       }\\n```\\n2 ) **step 2**\\na) traverse each puzzle in **puzzles** array \\nb) store the first charcter of puzzle*\\nc) sort the puzzle* to find out the number of unique character in puzzle except the first character stored  (one can use set also) \\nd) new string formed will be of length atmost 6 (why)? **let us call new string formed as k**\\n......because we are not considering the first character\\ne)  so there are 2^(size(k)), \\nf) loop from 0 to 2^(size(k)) check which bit is set and add the bit of corresponding charcter in the new string  to our mask  (same as number of possible subset) https://www.hackerearth.com/practice/notes/bit-manipulation/ (check this)\\ng) now according the question the first charcter of puzzle must be there in word hence for each combination from above add the bit corresponding to first character to the mask!!\\nh) find the count of this mask from hash table created in step one\\n```\\n vector<int>solution; // to store the count\\n \\n\\t  for(int j=0;j<puzzles.size();j++){  // puzzle in puzzles\\n            int count=0;                          \\n            int m=puzzles[j][0]-\\'a\\';   // storing the first character\\n            sort(puzzles[j].begin(),puzzles[j].end());  // sort the puzzle\\n            string k=\"\";                            // creating new string with unique character\\n            int m1=0;\\n            \\n            while(m1<puzzles[j].size()){\\n                char pre=puzzles[j][m1];\\n                int l=m1;\\n                \\n                while(l<puzzles[j].size() && puzzles[j][l]==pre){  \\n                    l++;\\n                }\\n                if((pre-\\'a\\')!=m)  // we are no considering the first character hence leave this case\\n                    k+=(string(1,pre));\\n                m1=l;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t for(long long i=0;i<(1<<k.length());i++){\\n                \\n                long long j=(1<<m); // adding the first character to our mask\\n                \\n                for(int k1=0;k1<k.length();k1++){\\n                    if((i&(1<<k1))!=0){  // cheking if k1 bit is set\\n                        j|=(1<<(k[k1]-\\'a\\')); // adding the bit correspondin to k[k1] character\\n                    }\\n                }\\n                \\n                count+=mymap[j]; // finding the count;\\n                \\n            }\\n            \\n            solution.push_back(count); return the answer\\n           \\n```\\n\\n\\n\\n\\nFULL SOLUTION\\n```\\nclass Solution {\\n    map<long long,int>mymap;\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        for(int i=0;i<words.size();i++){\\n            long long x=0;\\n            for(int j=0;j<words[i].size();j++){\\n                int m=words[i][j]-\\'a\\';\\n                x|=(1<<m);\\n            }\\n        \\n            mymap[x]++;\\n        }\\n        \\n        vector<int>solution;\\n        for(int j=0;j<puzzles.size();j++){\\n            int count=0;\\n            int m=puzzles[j][0]-\\'a\\';\\n            sort(puzzles[j].begin(),puzzles[j].end());\\n            string k=\"\";\\n            int m1=0;\\n            \\n            while(m1<puzzles[j].size()){\\n                char pre=puzzles[j][m1];\\n                int l=m1;\\n                \\n                while(l<puzzles[j].size() && puzzles[j][l]==pre){\\n                    l++;\\n                }\\n                if((pre-\\'a\\')!=m)\\n                    k+=(string(1,pre));\\n                m1=l;\\n            }\\n            \\n            \\n            \\n            for(long long i=0;i<(1<<k.length());i++){\\n                \\n                long long j=(1<<m);\\n                \\n                for(int k1=0;k1<k.length();k1++){\\n                    if((i&(1<<k1))!=0){\\n                        j|=(1<<(k[k1]-\\'a\\'));\\n                    }\\n                }\\n                \\n                count+=mymap[j];\\n                \\n            }\\n            \\n            solution.push_back(count);\\n        }\\n        \\n        return solution;\\n        \\n    }\\n};\\'\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nmap<int,int>mymap; //declare the hash table \\n\\n for(int i=0;i<words.size();i++){\\n            long long x=0;\\n            for(int j=0;j<words[i].size();j++){\\n\\t\\t\\t// 0 th bit for \\'a\\', 1st for \\'b\\' ... and so on\\n                int m=words[i][j]-\\'a\\'; // finding the position of the alphabet \\n                x|=(1<<m);   // setting mth bit to 1\\n            }\\n            mymap[x]++; // we are storing the count  mask of each word\\n       }\\n```\n```\\n vector<int>solution; // to store the count\\n \\n\\t  for(int j=0;j<puzzles.size();j++){  // puzzle in puzzles\\n            int count=0;                          \\n            int m=puzzles[j][0]-\\'a\\';   // storing the first character\\n            sort(puzzles[j].begin(),puzzles[j].end());  // sort the puzzle\\n            string k=\"\";                            // creating new string with unique character\\n            int m1=0;\\n            \\n            while(m1<puzzles[j].size()){\\n                char pre=puzzles[j][m1];\\n                int l=m1;\\n                \\n                while(l<puzzles[j].size() && puzzles[j][l]==pre){  \\n                    l++;\\n                }\\n                if((pre-\\'a\\')!=m)  // we are no considering the first character hence leave this case\\n                    k+=(string(1,pre));\\n                m1=l;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t for(long long i=0;i<(1<<k.length());i++){\\n                \\n                long long j=(1<<m); // adding the first character to our mask\\n                \\n                for(int k1=0;k1<k.length();k1++){\\n                    if((i&(1<<k1))!=0){  // cheking if k1 bit is set\\n                        j|=(1<<(k[k1]-\\'a\\')); // adding the bit correspondin to k[k1] character\\n                    }\\n                }\\n                \\n                count+=mymap[j]; // finding the count;\\n                \\n            }\\n            \\n            solution.push_back(count); return the answer\\n           \\n```\n```\\nclass Solution {\\n    map<long long,int>mymap;\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        for(int i=0;i<words.size();i++){\\n            long long x=0;\\n            for(int j=0;j<words[i].size();j++){\\n                int m=words[i][j]-\\'a\\';\\n                x|=(1<<m);\\n            }\\n        \\n            mymap[x]++;\\n        }\\n        \\n        vector<int>solution;\\n        for(int j=0;j<puzzles.size();j++){\\n            int count=0;\\n            int m=puzzles[j][0]-\\'a\\';\\n            sort(puzzles[j].begin(),puzzles[j].end());\\n            string k=\"\";\\n            int m1=0;\\n            \\n            while(m1<puzzles[j].size()){\\n                char pre=puzzles[j][m1];\\n                int l=m1;\\n                \\n                while(l<puzzles[j].size() && puzzles[j][l]==pre){\\n                    l++;\\n                }\\n                if((pre-\\'a\\')!=m)\\n                    k+=(string(1,pre));\\n                m1=l;\\n            }\\n            \\n            \\n            \\n            for(long long i=0;i<(1<<k.length());i++){\\n                \\n                long long j=(1<<m);\\n                \\n                for(int k1=0;k1<k.length();k1++){\\n                    if((i&(1<<k1))!=0){\\n                        j|=(1<<(k[k1]-\\'a\\'));\\n                    }\\n                }\\n                \\n                count+=mymap[j];\\n                \\n            }\\n            \\n            solution.push_back(count);\\n        }\\n        \\n        return solution;\\n        \\n    }\\n};\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371980,
                "title": "auto-boxing-in-java-is-so-slow-try-for-yourself",
                "content": "Is it the problem of auto-boxing or arraylist auto-expanding?\\n```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        int[] convertedWords = new int[words.length];\\n\\n        for (int i = 0; i < words.length; i++) {\\n            int chars = 0;\\n            for (int j = 0; j < words[i].length(); j++) {\\n                chars |= 1 << (words[i].charAt(j) - \\'a\\');\\n            }\\n            convertedWords[i] = chars;\\n        }\\n        \\n        List<Integer> res = new ArrayList<>(puzzles.length);\\n        for (String puzzle : puzzles) {\\n            char first = puzzle.charAt(0);\\n            int chars = 0;\\n            for (int i = 0; i < puzzle.length(); i++) {\\n                chars |= 1 << (puzzle.charAt(i) - \\'a\\');\\n            }\\n            int num = 0;\\n            int firstMask = 1 << first - \\'a\\';\\n            for (int word : convertedWords) {\\n                if ((word & chars) == word && (firstMask & word) == firstMask) {\\n                    num++;\\n                }\\n            }\\n            \\n            res.add(num);\\n        }\\n        return res;\\n    }\\n}\\n```\\nThe code will pass.\\nChange the `convertedWords` to `List<Integer>` and everything else remain the same will TLE.\\n```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer> convertedWords = new ArrayList<>();\\n\\n        for (int i = 0; i < words.length; i++) {\\n            int chars = 0;\\n            for (int j = 0; j < words[i].length(); j++) {\\n                chars |= 1 << (words[i].charAt(j) - \\'a\\');\\n            }\\n            convertedWords.add(chars);\\n        }\\n        \\n        List<Integer> res = new ArrayList<>(puzzles.length);\\n        for (String puzzle : puzzles) {\\n            char first = puzzle.charAt(0);\\n            int chars = 0;\\n            for (int i = 0; i < puzzle.length(); i++) {\\n                chars |= 1 << (puzzle.charAt(i) - \\'a\\');\\n            }\\n            int num = 0;\\n            int firstMask = 1 << first - \\'a\\';\\n            for (int word : convertedWords) {\\n                if ((word & chars) == word && (firstMask & word) == firstMask) {\\n                    num++;\\n                }\\n            }\\n            \\n            res.add(num);\\n        }\\n        return res;\\n    }\\n}\\n```\\nAlso tried giving it a initial length with `List<Integer> convertedWords = new ArrayList<>(words.length);` and no luck.\\nAnyone could explain the cause?\\nI\\'m aware this is most-optimized brute froce and there\\'s certainly better ways to solve the problem. Just curious of the reason it\\'s behaving so differently.\\n\\nAnd also, trying to filter out any word more than 7 unique characters using set/bit manipulation will fail when using `List<Integer>`.  If using `int[]` and put dummy values in invalid places like `-1`, the code would work.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        int[] convertedWords = new int[words.length];\\n\\n        for (int i = 0; i < words.length; i++) {\\n            int chars = 0;\\n            for (int j = 0; j < words[i].length(); j++) {\\n                chars |= 1 << (words[i].charAt(j) - \\'a\\');\\n            }\\n            convertedWords[i] = chars;\\n        }\\n        \\n        List<Integer> res = new ArrayList<>(puzzles.length);\\n        for (String puzzle : puzzles) {\\n            char first = puzzle.charAt(0);\\n            int chars = 0;\\n            for (int i = 0; i < puzzle.length(); i++) {\\n                chars |= 1 << (puzzle.charAt(i) - \\'a\\');\\n            }\\n            int num = 0;\\n            int firstMask = 1 << first - \\'a\\';\\n            for (int word : convertedWords) {\\n                if ((word & chars) == word && (firstMask & word) == firstMask) {\\n                    num++;\\n                }\\n            }\\n            \\n            res.add(num);\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer> convertedWords = new ArrayList<>();\\n\\n        for (int i = 0; i < words.length; i++) {\\n            int chars = 0;\\n            for (int j = 0; j < words[i].length(); j++) {\\n                chars |= 1 << (words[i].charAt(j) - \\'a\\');\\n            }\\n            convertedWords.add(chars);\\n        }\\n        \\n        List<Integer> res = new ArrayList<>(puzzles.length);\\n        for (String puzzle : puzzles) {\\n            char first = puzzle.charAt(0);\\n            int chars = 0;\\n            for (int i = 0; i < puzzle.length(); i++) {\\n                chars |= 1 << (puzzle.charAt(i) - \\'a\\');\\n            }\\n            int num = 0;\\n            int firstMask = 1 << first - \\'a\\';\\n            for (int word : convertedWords) {\\n                if ((word & chars) == word && (firstMask & word) == firstMask) {\\n                    num++;\\n                }\\n            }\\n            \\n            res.add(num);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371899,
                "title": "c-convert-words-puzzle-to-bitwise-value-9-10-pass-stuck-due-to-tle",
                "content": "I must admit i considerd myself a genius to think of the bitwise solution during the contest :P.\\nHowever, my solution fails to pass the last TC(due to Time Limit Exceed).\\n\\nIf possible, can someone help me optimise this solution further?\\n\\nThank you for your help in advance :)\\n\\nLink to TLE case : https://leetcode.com/submissions/detail/256682636/testcase/\\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> w(words.size(), 0);\\n        vector<int> res(puzzles.size(), 0);\\n        int t;\\n        for(int i = 0; i < words.size(); i++){\\n            int val = 0;\\n            for(int j = 0; j < words[i].size(); j++){\\n                t = words[i][j]-\\'a\\';\\n                val = val | 1<<t;\\n            }\\n            w[i] = val;\\n        }\\n        for(int i = 0; i < puzzles.size(); i++){\\n            int val = 0;\\n            for(int j = 0; j < puzzles[i].size(); j++){\\n                t = puzzles[i][j]-\\'a\\';\\n                val = val | 1<<t;\\n            }\\n            t = puzzles[i][0]-\\'a\\';\\n            int count = 0;\\n            for(int j = 0; j < w.size(); j++){\\n                if((((1<<t)&w[j]) != 0) && ((w[j]&val) == w[j])){\\n                    count++;\\n                }\\n            }\\n            res[i] = count;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> w(words.size(), 0);\\n        vector<int> res(puzzles.size(), 0);\\n        int t;\\n        for(int i = 0; i < words.size(); i++){\\n            int val = 0;\\n            for(int j = 0; j < words[i].size(); j++){\\n                t = words[i][j]-\\'a\\';\\n                val = val | 1<<t;\\n            }\\n            w[i] = val;\\n        }\\n        for(int i = 0; i < puzzles.size(); i++){\\n            int val = 0;\\n            for(int j = 0; j < puzzles[i].size(); j++){\\n                t = puzzles[i][j]-\\'a\\';\\n                val = val | 1<<t;\\n            }\\n            t = puzzles[i][0]-\\'a\\';\\n            int count = 0;\\n            for(int j = 0; j < w.size(); j++){\\n                if((((1<<t)&w[j]) != 0) && ((w[j]&val) == w[j])){\\n                    count++;\\n                }\\n            }\\n            res[i] = count;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 371842,
                "title": "c-bitwise-operation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> f(const string& s){\\n        int a[26] = {};\\n        for(auto ch:s){\\n            a[ch-\\'a\\'] = 1;\\n        }\\n        vector<int> tmp;\\n        for(int i = 0;i<26;i++){\\n            if(a[i]){\\n                tmp.push_back(i);\\n            }\\n        }\\n        int upper = (int)pow(2,tmp.size()) - 1;\\n        vector<int> ret;\\n        for(int i = 1;i<=upper;i++){\\n            int t = i;\\n            int b = 0;\\n            int j = 0;\\n            for(int j = 0;j<tmp.size();j++){\\n                if(t&1){\\n                    b |= (1<<tmp[j]);\\n                }\\n                t >>= 1;\\n            }\\n            ret.push_back(b);\\n        }\\n        return ret;\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<unordered_map<int,int>> dp(26);\\n        for(auto& s: words){\\n            int t = 0;\\n            bool tmp[26] ={};\\n            for(auto ch :s){\\n                t |= 1<<(ch - \\'a\\');\\n                tmp[ch - \\'a\\'] = true; \\n            }\\n            for(int i = 0;i<26;i++){\\n                if(tmp[i]){\\n                    dp[i][t]++;\\n                }\\n            }\\n        }\\n        vector<int> ret;\\n        vector<unordered_map<int,int>> ans(26);\\n        for(auto& s:puzzles){\\n            int k = 0;\\n            for(auto ch:s){\\n                k |= 1<<(ch-\\'a\\');\\n            }\\n            if(ans[s[0]-\\'a\\'].count(k)){\\n                ret.push_back(ans[s[0]-\\'a\\'][k]);\\n                continue;\\n            }\\n            int tmp = 0;\\n            auto a = f(s);\\n            for(int n : a){\\n                if(dp[s[0]-\\'a\\'].count(n)){\\n                    tmp += dp[s[0]-\\'a\\'][n];\\n                }\\n            }\\n            /*for(auto& x:dp[s[0]-\\'a\\']){\\n                if(((k^x.first)&x.first) == 0){\\n                    tmp += x.second;\\n                }\\n            }*/\\n            ret.push_back(tmp);\\n            ans[s[0]-\\'a\\'][k] = tmp;\\n        }\\n        return ret;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> f(const string& s){\\n        int a[26] = {};\\n        for(auto ch:s){\\n            a[ch-\\'a\\'] = 1;\\n        }\\n        vector<int> tmp;\\n        for(int i = 0;i<26;i++){\\n            if(a[i]){\\n                tmp.push_back(i);\\n            }\\n        }\\n        int upper = (int)pow(2,tmp.size()) - 1;\\n        vector<int> ret;\\n        for(int i = 1;i<=upper;i++){\\n            int t = i;\\n            int b = 0;\\n            int j = 0;\\n            for(int j = 0;j<tmp.size();j++){\\n                if(t&1){\\n                    b |= (1<<tmp[j]);\\n                }\\n                t >>= 1;\\n            }\\n            ret.push_back(b);\\n        }\\n        return ret;\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<unordered_map<int,int>> dp(26);\\n        for(auto& s: words){\\n            int t = 0;\\n            bool tmp[26] ={};\\n            for(auto ch :s){\\n                t |= 1<<(ch - \\'a\\');\\n                tmp[ch - \\'a\\'] = true; \\n            }\\n            for(int i = 0;i<26;i++){\\n                if(tmp[i]){\\n                    dp[i][t]++;\\n                }\\n            }\\n        }\\n        vector<int> ret;\\n        vector<unordered_map<int,int>> ans(26);\\n        for(auto& s:puzzles){\\n            int k = 0;\\n            for(auto ch:s){\\n                k |= 1<<(ch-\\'a\\');\\n            }\\n            if(ans[s[0]-\\'a\\'].count(k)){\\n                ret.push_back(ans[s[0]-\\'a\\'][k]);\\n                continue;\\n            }\\n            int tmp = 0;\\n            auto a = f(s);\\n            for(int n : a){\\n                if(dp[s[0]-\\'a\\'].count(n)){\\n                    tmp += dp[s[0]-\\'a\\'][n];\\n                }\\n            }\\n            /*for(auto& x:dp[s[0]-\\'a\\']){\\n                if(((k^x.first)&x.first) == 0){\\n                    tmp += x.second;\\n                }\\n            }*/\\n            ret.push_back(tmp);\\n            ans[s[0]-\\'a\\'][k] = tmp;\\n        }\\n        return ret;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064032,
                "title": "enumeration-of-submask-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> wordMasks; \\n        vector<int> ans; \\n        for (const string& word : words) {\\n            int mask = 0;\\n            for (char c : word) {\\n                mask |= (1 << (c - \\'a\\'));\\n            }\\n            wordMasks[mask]++;\\n        }\\n\\n        for (const string& puzzle : puzzles) {\\n            int puzzleMask = 0;\\n            for (char c : puzzle) {\\n                puzzleMask |= (1 << (c - \\'a\\'));\\n            }\\n\\n            int firstCharMask = (1 << (puzzle[0] - \\'a\\'));\\n            int subsetMask = puzzleMask;\\n\\n            int totalValidWords = 0;\\n            while (subsetMask > 0) {\\n                if ((subsetMask & firstCharMask) && wordMasks.count(subsetMask)) {\\n                    totalValidWords += wordMasks[subsetMask];\\n                }\\n                subsetMask = (subsetMask - 1) & puzzleMask; \\n            }\\n\\n            ans.push_back(totalValidWords);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> wordMasks; \\n        vector<int> ans; \\n        for (const string& word : words) {\\n            int mask = 0;\\n            for (char c : word) {\\n                mask |= (1 << (c - \\'a\\'));\\n            }\\n            wordMasks[mask]++;\\n        }\\n\\n        for (const string& puzzle : puzzles) {\\n            int puzzleMask = 0;\\n            for (char c : puzzle) {\\n                puzzleMask |= (1 << (c - \\'a\\'));\\n            }\\n\\n            int firstCharMask = (1 << (puzzle[0] - \\'a\\'));\\n            int subsetMask = puzzleMask;\\n\\n            int totalValidWords = 0;\\n            while (subsetMask > 0) {\\n                if ((subsetMask & firstCharMask) && wordMasks.count(subsetMask)) {\\n                    totalValidWords += wordMasks[subsetMask];\\n                }\\n                subsetMask = (subsetMask - 1) & puzzleMask; \\n            }\\n\\n            ans.push_back(totalValidWords);\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709262,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*2^m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def findNumOfValidWords(words: Array[String], puzzles: Array[String]): List[Int] = {\\n      val wordMap = words.foldLeft(scala.collection.immutable.Map.empty[Int, Int].withDefaultValue(0)){(map, word) =>\\n        val bitmask = word.foldLeft(0)((bitmask, char)=>bitmask | (1 << (char - \\'a\\')))\\n        map.updated(bitmask, map(bitmask) + 1)\\n      }\\n\\n      def generateSubsets(puzzle: String, index: Int, bitmask: Int): Int =\\n        if (index == puzzle.length) wordMap(bitmask)\\n        else generateSubsets(puzzle, index + 1, bitmask | (1 << (puzzle(index) - \\'a\\'))) + generateSubsets(puzzle, index + 1, bitmask)\\n\\n      puzzles.map(puzzle => generateSubsets(puzzle, 1, 1 << (puzzle(0) - \\'a\\'))).toList\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def findNumOfValidWords(words: Array[String], puzzles: Array[String]): List[Int] = {\\n      val wordMap = words.foldLeft(scala.collection.immutable.Map.empty[Int, Int].withDefaultValue(0)){(map, word) =>\\n        val bitmask = word.foldLeft(0)((bitmask, char)=>bitmask | (1 << (char - \\'a\\')))\\n        map.updated(bitmask, map(bitmask) + 1)\\n      }\\n\\n      def generateSubsets(puzzle: String, index: Int, bitmask: Int): Int =\\n        if (index == puzzle.length) wordMap(bitmask)\\n        else generateSubsets(puzzle, index + 1, bitmask | (1 << (puzzle(index) - \\'a\\'))) + generateSubsets(puzzle, index + 1, bitmask)\\n\\n      puzzles.map(puzzle => generateSubsets(puzzle, 1, 1 << (puzzle(0) - \\'a\\'))).toList\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3642910,
                "title": "c-bit-manipulation-clean-solution",
                "content": "**Read comments to understand the Code**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<char,vector<int>> mp; // <char,{ word_bitmask starting with char}>\\n        \\n        for(int i=0;i<words.size();i++){\\n            int bit_mask = 0; // generating bit_mask of a word\\n            for(char c : words[i]){\\n                int x = c-\\'a\\';\\n                bit_mask = ( bit_mask | (1<<x));\\n            }\\n            set<char> st; // to make sure same words should not be repeated\\n            for(char c : words[i]){\\n                if(st.find(c) == st.end()){\\n                    mp[c].push_back(bit_mask);\\n                    st.insert(c);\\n                }\\n            }\\n        }\\n        \\n        int n = puzzles.size();\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            int puzzle_mask = 0; // generating bit_mask of a puzzle\\n            for(char c : puzzles[i]){\\n                int x = c - \\'a\\';\\n                puzzle_mask = (puzzle_mask | (1<<x));\\n            }\\n            char first_char = puzzles[i][0]; // by this we can satisfy first condition and even we don\\'t have to iterate all words\\n            int count = 0;\\n            // here we will we iterating only those words which starts with first char of puzzle\\n            for(int word_mask : mp[first_char]){\\n                if( (puzzle_mask & word_mask) == word_mask ){\\n                    count++;\\n                }\\n            }\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<char,vector<int>> mp; // <char,{ word_bitmask starting with char}>\\n        \\n        for(int i=0;i<words.size();i++){\\n            int bit_mask = 0; // generating bit_mask of a word\\n            for(char c : words[i]){\\n                int x = c-\\'a\\';\\n                bit_mask = ( bit_mask | (1<<x));\\n            }\\n            set<char> st; // to make sure same words should not be repeated\\n            for(char c : words[i]){\\n                if(st.find(c) == st.end()){\\n                    mp[c].push_back(bit_mask);\\n                    st.insert(c);\\n                }\\n            }\\n        }\\n        \\n        int n = puzzles.size();\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            int puzzle_mask = 0; // generating bit_mask of a puzzle\\n            for(char c : puzzles[i]){\\n                int x = c - \\'a\\';\\n                puzzle_mask = (puzzle_mask | (1<<x));\\n            }\\n            char first_char = puzzles[i][0]; // by this we can satisfy first condition and even we don\\'t have to iterate all words\\n            int count = 0;\\n            // here we will we iterating only those words which starts with first char of puzzle\\n            for(int word_mask : mp[first_char]){\\n                if( (puzzle_mask & word_mask) == word_mask ){\\n                    count++;\\n                }\\n            }\\n            ans[i] = count;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628939,
                "title": "python-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(64*M log(N))\\n-  where M:- 10^4 and N:- 10^5\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        l=[]\\n        for i in range(len(words)):\\n            s=0\\n            for j in words[i]:\\n                s=s|(1<<(ord(j))-97)\\n            l+=[s]\\n        l.sort()\\n        ans=[]\\n        for i in range(len(puzzles)):\\n            s=0\\n            l1=[]\\n            for j in puzzles[i]:\\n                s=s|(1<<(ord(j))-97)\\n                l1+=[ord(j)-97]\\n            b1=bisect.bisect_right(l,2**l1[0]-1)\\n            b2=bisect.bisect_left(l,2**l1[0]+1)\\n            c=b2-b1\\n            a=l1.pop(0)\\n            for k in range(1,2**(len(l1))):\\n                s1=2**a\\n                count=0\\n                while k!=0:\\n                    if k&1!=0:\\n                        s1+=2**l1[count]\\n                    k=k>>1\\n                    count+=1\\n                b1=bisect.bisect_right(l,s1-1)\\n                b2=bisect.bisect_left(l,s1+1)\\n                c+=b2-b1\\n            ans+=[c]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Binary Search",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        l=[]\\n        for i in range(len(words)):\\n            s=0\\n            for j in words[i]:\\n                s=s|(1<<(ord(j))-97)\\n            l+=[s]\\n        l.sort()\\n        ans=[]\\n        for i in range(len(puzzles)):\\n            s=0\\n            l1=[]\\n            for j in puzzles[i]:\\n                s=s|(1<<(ord(j))-97)\\n                l1+=[ord(j)-97]\\n            b1=bisect.bisect_right(l,2**l1[0]-1)\\n            b2=bisect.bisect_left(l,2**l1[0]+1)\\n            c=b2-b1\\n            a=l1.pop(0)\\n            for k in range(1,2**(len(l1))):\\n                s1=2**a\\n                count=0\\n                while k!=0:\\n                    if k&1!=0:\\n                        s1+=2**l1[count]\\n                    k=k>>1\\n                    count+=1\\n                b1=bisect.bisect_right(l,s1-1)\\n                b2=bisect.bisect_left(l,s1+1)\\n                c+=b2-b1\\n            ans+=[c]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613086,
                "title": "c-bit-masking-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        unordered_map<int,int>mp;\\n        for(auto x:words)\\n        {\\n            int mask=0;\\n            for(int i=0;i<x.size();i++)\\n            {\\n                mask=mask|(1<<(x[i]-\\'a\\'));\\n            }\\n            mp[mask]++;\\n        }\\n        int n=puzzles.size();\\n        vector<int>ans(n,0);\\n        int i=0;\\n        for(auto x:puzzles)\\n        {    \\n            \\n            int mask=0;\\n            int ct=0;\\n            for(int i=0;i<x.size();i++)\\n            {\\n                mask=mask|(1<<(x[i]-\\'a\\'));\\n            }\\n            int res=1<<(x[0]-\\'a\\');\\n            int temp=mask;\\n            while(temp>0)\\n            {\\n                if(temp&res) \\n                {\\n                    ct+=mp[temp];\\n                }\\n               // now to check fro the next closest possible set bit arrangement\\n               temp=(temp-1)&mask;\\n            }\\n            ans[i]=ct;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        unordered_map<int,int>mp;\\n        for(auto x:words)\\n        {\\n            int mask=0;\\n            for(int i=0;i<x.size();i++)\\n            {\\n                mask=mask|(1<<(x[i]-\\'a\\'));\\n            }\\n            mp[mask]++;\\n        }\\n        int n=puzzles.size();\\n        vector<int>ans(n,0);\\n        int i=0;\\n        for(auto x:puzzles)\\n        {    \\n            \\n            int mask=0;\\n            int ct=0;\\n            for(int i=0;i<x.size();i++)\\n            {\\n                mask=mask|(1<<(x[i]-\\'a\\'));\\n            }\\n            int res=1<<(x[0]-\\'a\\');\\n            int temp=mask;\\n            while(temp>0)\\n            {\\n                if(temp&res) \\n                {\\n                    ct+=mp[temp];\\n                }\\n               // now to check fro the next closest possible set bit arrangement\\n               temp=(temp-1)&mask;\\n            }\\n            ans[i]=ct;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566629,
                "title": "easy-to-understand-trie-approach-dfs",
                "content": "\\n```\\nclass Node{\\npublic:\\n      Node *child[26];\\n      int cnt;\\n      Node (){\\n           cnt=0;\\n           for(int i =0;i<26;i++){\\n               child[i]=NULL;\\n           }\\n      }\\n};\\nclass Trie {\\npublic:\\n    Node *root;\\n    Trie() {\\n        root=new Node();\\n    }\\n    \\n    void insert(string word) {\\n        Node * temp=root;\\n        for(char i:word){\\n            if(temp->child[i-\\'a\\']==NULL){\\n                temp->child[i-\\'a\\']=new Node();\\n            }\\n            temp=temp->child[i-\\'a\\'];\\n        }\\n        temp->cnt++;\\n    }\\n    int helper(string str){\\n        int cnt=0;\\n        vector<int>valid(26,0);\\n        for(char i:str)valid[i-\\'a\\']=1;\\n        int flag=0;\\n        search(valid,cnt,root,str[0],flag);\\n        return cnt;\\n    }\\n    void search(vector<int>valid,int &cnt,Node *temp,char vchar,int flag){\\n        if(flag==1)cnt+=temp->cnt;\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            if(valid[i-\\'a\\']==1 && temp->child[i-\\'a\\']!=NULL){\\n                if(i==vchar)flag=1;\\n                search(valid,cnt,temp->child[i-\\'a\\'],vchar,flag);\\n                if(i==vchar)flag=0;\\n            }\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        Trie *trie=new Trie();\\n        vector<int>ans;\\n        for(string i:words){\\n            set<char>sett(i.begin(),i.end());\\n            string temp=\"\";\\n            for(auto i:sett)temp+=i;\\n            trie->insert(temp);\\n        }\\n        for(string i:puzzles){\\n            ans.push_back(trie->helper(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Node{\\npublic:\\n      Node *child[26];\\n      int cnt;\\n      Node (){\\n           cnt=0;\\n           for(int i =0;i<26;i++){\\n               child[i]=NULL;\\n           }\\n      }\\n};\\nclass Trie {\\npublic:\\n    Node *root;\\n    Trie() {\\n        root=new Node();\\n    }\\n    \\n    void insert(string word) {\\n        Node * temp=root;\\n        for(char i:word){\\n            if(temp->child[i-\\'a\\']==NULL){\\n                temp->child[i-\\'a\\']=new Node();\\n            }\\n            temp=temp->child[i-\\'a\\'];\\n        }\\n        temp->cnt++;\\n    }\\n    int helper(string str){\\n        int cnt=0;\\n        vector<int>valid(26,0);\\n        for(char i:str)valid[i-\\'a\\']=1;\\n        int flag=0;\\n        search(valid,cnt,root,str[0],flag);\\n        return cnt;\\n    }\\n    void search(vector<int>valid,int &cnt,Node *temp,char vchar,int flag){\\n        if(flag==1)cnt+=temp->cnt;\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            if(valid[i-\\'a\\']==1 && temp->child[i-\\'a\\']!=NULL){\\n                if(i==vchar)flag=1;\\n                search(valid,cnt,temp->child[i-\\'a\\'],vchar,flag);\\n                if(i==vchar)flag=0;\\n            }\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        Trie *trie=new Trie();\\n        vector<int>ans;\\n        for(string i:words){\\n            set<char>sett(i.begin(),i.end());\\n            string temp=\"\";\\n            for(auto i:sett)temp+=i;\\n            trie->insert(temp);\\n        }\\n        for(string i:puzzles){\\n            ans.push_back(trie->helper(i));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473732,
                "title": "c-trie-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstruct Node{\\n    Node* links[2];\\n    int cnt=0;\\n    bool isContains(int ind)\\n    {\\n        return links[ind]!=NULL;\\n    }\\n    void put(int ind,Node* node)\\n    {\\n        links[ind]=node;\\n    }\\n    Node* get(int ind)\\n    {\\n        return links[ind];\\n    }\\n    void incCount()\\n    {\\n        cnt++;\\n    }\\n    int count()\\n    {\\n        return cnt;\\n    }\\n};\\nclass Trie{\\n    public:\\n    Node* root;\\n    Trie()\\n    {\\n      root=new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node* node=root;\\n        for (int i=25;i>=0;i--)\\n        {\\n            int bit=((num>>i)&1);\\n            if (!node->isContains(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n            node->incCount();\\n        }\\n    }\\n    int getCount(Node* root)\\n    {\\n        if (root==NULL) return 0;\\n        return root->count();\\n    }\\n    int rec(Node* root,int cur,int ind,int val)\\n    {\\n        if (root==NULL) return 0;\\n        if (ind==-1) return getCount(root);\\n        int bit=((cur>>ind)&1);\\n        if (val==ind)\\n        {\\n            return rec(root->get(1),cur,ind-1,val);\\n        }\\n        else if (bit==1)\\n        {\\n            return rec(root->get(1),cur,ind-1,val)+rec(root->get(0),cur,ind-1,val);\\n        }   \\n        else return rec (root->get(0),cur,ind-1,val);     \\n    }\\n};\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) \\n    {\\n        vector<int>ans;\\n        Trie * trie=new Trie();\\n        for (auto it: words)\\n        {\\n            int num=0;\\n            for (int i=0;i<it.size();i++)\\n            {\\n                int temp=it[i]-\\'a\\';\\n                num|=(1<<temp);\\n            }\\n             trie->insert(num);\\n        }\\n        for (auto it: puzzles)\\n        {\\n           int val=it[0]-\\'a\\';\\n           int num=0;\\n           for (int i=0;i<it.size();i++)\\n           {\\n             num|=(1<<(it[i]-\\'a\\'));\\n           }\\n            ans.push_back(trie->rec(trie->root,num,25,val));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstruct Node{\\n    Node* links[2];\\n    int cnt=0;\\n    bool isContains(int ind)\\n    {\\n        return links[ind]!=NULL;\\n    }\\n    void put(int ind,Node* node)\\n    {\\n        links[ind]=node;\\n    }\\n    Node* get(int ind)\\n    {\\n        return links[ind];\\n    }\\n    void incCount()\\n    {\\n        cnt++;\\n    }\\n    int count()\\n    {\\n        return cnt;\\n    }\\n};\\nclass Trie{\\n    public:\\n    Node* root;\\n    Trie()\\n    {\\n      root=new Node();\\n    }\\n    void insert(int num)\\n    {\\n        Node* node=root;\\n        for (int i=25;i>=0;i--)\\n        {\\n            int bit=((num>>i)&1);\\n            if (!node->isContains(bit))\\n            {\\n                node->put(bit,new Node());\\n            }\\n            node=node->get(bit);\\n            node->incCount();\\n        }\\n    }\\n    int getCount(Node* root)\\n    {\\n        if (root==NULL) return 0;\\n        return root->count();\\n    }\\n    int rec(Node* root,int cur,int ind,int val)\\n    {\\n        if (root==NULL) return 0;\\n        if (ind==-1) return getCount(root);\\n        int bit=((cur>>ind)&1);\\n        if (val==ind)\\n        {\\n            return rec(root->get(1),cur,ind-1,val);\\n        }\\n        else if (bit==1)\\n        {\\n            return rec(root->get(1),cur,ind-1,val)+rec(root->get(0),cur,ind-1,val);\\n        }   \\n        else return rec (root->get(0),cur,ind-1,val);     \\n    }\\n};\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) \\n    {\\n        vector<int>ans;\\n        Trie * trie=new Trie();\\n        for (auto it: words)\\n        {\\n            int num=0;\\n            for (int i=0;i<it.size();i++)\\n            {\\n                int temp=it[i]-\\'a\\';\\n                num|=(1<<temp);\\n            }\\n             trie->insert(num);\\n        }\\n        for (auto it: puzzles)\\n        {\\n           int val=it[0]-\\'a\\';\\n           int num=0;\\n           for (int i=0;i<it.size();i++)\\n           {\\n             num|=(1<<(it[i]-\\'a\\'));\\n           }\\n            ans.push_back(trie->rec(trie->root,num,25,val));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435607,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n     List<Integer>l=new ArrayList<>();\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n       \\n        for(String wd:words){\\n            int mask=0;\\n            for(int i=0;i<wd.length();i++){\\n              mask|=(1<<wd.charAt(i)-\\'a\\');\\n            }\\n            hm.put(mask,hm.getOrDefault(mask,0)+1);\\n            }\\n        ArrayList<Integer>res=new ArrayList<>();\\n        for(String puzz:puzzles){\\n            int pmsk=0;\\n          for(int i=0;i<puzz.length();i++){\\n              int bit=puzz.charAt(i)-\\'a\\';\\n              pmsk=pmsk|((1<<bit));\\n          }\\n           int psub=pmsk;\\n            int ct=0;\\n           int firs=1<<(puzz.charAt(0)-\\'a\\');\\n            while(true){\\n                if((psub &firs)==firs && hm.containsKey(psub)){\\n                    ct+=hm.get(psub);\\n                }\\n                if(psub==0)break;\\n                    psub=(psub-1) &pmsk;\\n            }\\n            l.add(ct);\\n        }\\n        return l;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n     List<Integer>l=new ArrayList<>();\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n       \\n        for(String wd:words){\\n            int mask=0;\\n            for(int i=0;i<wd.length();i++){\\n              mask|=(1<<wd.charAt(i)-\\'a\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3303647,
                "title": "c-dfs-backtracking-unordered-map-char-unordered-map-string-int",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(unordered_map<char, unordered_map<string, int>>& m,\\n            string& cur, int i, string& s, char& key){\\n        if (i == s.size()) return 0;\\n        cur += s[i];\\n        int ans = 0;\\n        if (m[key].find(cur) != m[key].end()) ans += m[key][cur];\\n        ans += dfs(m, cur, i + 1, s, key);\\n        cur.pop_back();\\n        ans += dfs(m, cur, i + 1, s, key);\\n        return ans;\\n    }\\n    // 1) for each word\\n    // insert its hashmap into all the possible characters of its hashmap\\n    // 2) for each puzzle\\n    // search for each subsequence that starts with its key\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<char, unordered_map<string, int>> m;\\n        vector<int> ans;\\n        for (auto& s : words){\\n            vector<bool> freq(26);\\n            for (auto& c : s) freq[c - \\'a\\'] = true;\\n            string key = \"\";\\n            for (int i = 0; i < freq.size(); ++i)\\n                if (freq[i]) key += i + \\'a\\';\\n            for (int i = 0; i < freq.size(); ++i)\\n                if (freq[i]) ++m[i + \\'a\\'][key];\\n        }\\n        for (auto& s : puzzles){\\n            char key = s[0];\\n            sort(s.begin(), s.end());          \\n            string cur = \"\";\\n            ans.push_back(dfs(m, cur, 0, s, key));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(unordered_map<char, unordered_map<string, int>>& m,\\n            string& cur, int i, string& s, char& key){\\n        if (i == s.size()) return 0;\\n        cur += s[i];\\n        int ans = 0;\\n        if (m[key].find(cur) != m[key].end()) ans += m[key][cur];\\n        ans += dfs(m, cur, i + 1, s, key);\\n        cur.pop_back();\\n        ans += dfs(m, cur, i + 1, s, key);\\n        return ans;\\n    }\\n    // 1) for each word\\n    // insert its hashmap into all the possible characters of its hashmap\\n    // 2) for each puzzle\\n    // search for each subsequence that starts with its key\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<char, unordered_map<string, int>> m;\\n        vector<int> ans;\\n        for (auto& s : words){\\n            vector<bool> freq(26);\\n            for (auto& c : s) freq[c - \\'a\\'] = true;\\n            string key = \"\";\\n            for (int i = 0; i < freq.size(); ++i)\\n                if (freq[i]) key += i + \\'a\\';\\n            for (int i = 0; i < freq.size(); ++i)\\n                if (freq[i]) ++m[i + \\'a\\'][key];\\n        }\\n        for (auto& s : puzzles){\\n            char key = s[0];\\n            sort(s.begin(), s.end());          \\n            string cur = \"\";\\n            ans.push_back(dfs(m, cur, 0, s, key));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235996,
                "title": "665-ms",
                "content": "```ruby\\ndef find_num_of_valid_words w, q\\n    h = Hash.new 0\\n    w.each do | w |\\n        k = 0\\n        w.bytes.each do\\n            k |= 1 << (_1 - 97)\\n        end\\n        h[k] += 1\\n    end\\n    q.map do | s |\\n        x = s.bytes\\n        k = [1 << (x.shift - 97)]\\n        until x.empty?\\n            d = 1 << (x.shift - 97)\\n            k.size.times do\\n                k << (k[_1] | d)\\n            end\\n        end\\n        k.sum { h[_1] }\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef find_num_of_valid_words w, q\\n    h = Hash.new 0\\n    w.each do | w |\\n        k = 0\\n        w.bytes.each do\\n            k |= 1 << (_1 - 97)\\n        end\\n        h[k] += 1\\n    end\\n    q.map do | s |\\n        x = s.bytes\\n        k = [1 << (x.shift - 97)]\\n        until x.empty?\\n            d = 1 << (x.shift - 97)\\n            k.size.times do\\n                k << (k[_1] | d)\\n            end\\n        end\\n        k.sum { h[_1] }\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3148206,
                "title": "java-bit-masking-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer> ans = new ArrayList<>();\\n        HashMap<Integer , Integer> maskToCount = new HashMap<>();\\n        HashMap<Character , HashSet<Integer>> map = new HashMap<>();\\n        for(int i = 0 ; i < 26 ; i++){\\n            map.put((char)(i+\\'a\\') , new HashSet<>());\\n        }\\n        for(int i = 0 ; i < words.length ; i++){\\n            int mask = 0;\\n            for(int j = 0 ; j < words[i].length() ; j++){\\n                char ele = words[i].charAt(j);\\n                int tempMask = (1 << (int)(ele - \\'a\\'));\\n                mask = mask | tempMask;\\n            }\\n            maskToCount.put(mask , maskToCount.getOrDefault(mask , 0) + 1);\\n            for(int j = 0 ; j < words[i].length() ; j++){\\n                char c = words[i].charAt(j);\\n                map.get(c).add(mask);\\n            }\\n        }\\n        for(int i = 0 ; i < puzzles.length ; i++){\\n            int curMask = 0;\\n            for(int j = 0 ; j < puzzles[i].length() ; j++){\\n                char ele = puzzles[i].charAt(j);\\n                curMask = curMask | (1 << (int)(ele - \\'a\\'));\\n            }\\n            int count = 0;\\n            for(int ele : map.get(puzzles[i].charAt(0))){\\n                if((ele & curMask) == ele) {\\n                    count += maskToCount.getOrDefault(ele , 0);\\n                }\\n            }\\n            ans.add(count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer> ans = new ArrayList<>();\\n        HashMap<Integer , Integer> maskToCount = new HashMap<>();\\n        HashMap<Character , HashSet<Integer>> map = new HashMap<>();\\n        for(int i = 0 ; i < 26 ; i++){\\n            map.put((char)(i+\\'a\\') , new HashSet<>());\\n        }\\n        for(int i = 0 ; i < words.length ; i++){\\n            int mask = 0;\\n            for(int j = 0 ; j < words[i].length() ; j++){\\n                char ele = words[i].charAt(j);\\n                int tempMask = (1 << (int)(ele - \\'a\\'));\\n                mask = mask | tempMask;\\n            }\\n            maskToCount.put(mask , maskToCount.getOrDefault(mask , 0) + 1);\\n            for(int j = 0 ; j < words[i].length() ; j++){\\n                char c = words[i].charAt(j);\\n                map.get(c).add(mask);\\n            }\\n        }\\n        for(int i = 0 ; i < puzzles.length ; i++){\\n            int curMask = 0;\\n            for(int j = 0 ; j < puzzles[i].length() ; j++){\\n                char ele = puzzles[i].charAt(j);\\n                curMask = curMask | (1 << (int)(ele - \\'a\\'));\\n            }\\n            int count = 0;\\n            for(int ele : map.get(puzzles[i].charAt(0))){\\n                if((ele & curMask) == ele) {\\n                    count += maskToCount.getOrDefault(ele , 0);\\n                }\\n            }\\n            ans.add(count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098331,
                "title": "without-trie-bit-manipulation-dfs-cpp-faster",
                "content": "# Intuition\\n\\n1) store bitsmasks of each word in map\\n2) find bitmask of puzzle and try to generate all sub puzzles \\n3) sum all freq of sub puzzles\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(int i,long long curr, long long mask,unordered_map<long long,int>& temp,long long& count,int first){\\n\\n        if(i>25) return  ;\\n        \\n        bool isSet = (mask&(1<<i));\\n\\n        solve(i+1,curr,mask,temp,count,first);\\n\\n        if(isSet && (i!=first) ) {\\n            \\n            curr|=(1<<i);\\n            \\n            count+= temp[curr];\\n\\n            solve(i+1,curr,mask,temp,count,first);\\n\\n        }\\n\\n\\n    }\\n\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        unordered_map<long long,int> freq ;\\n\\n        vector<int> ans ;\\n\\n        for(auto word:words){\\n\\n            long long mask = 0;\\n\\n            for(auto ch:word) mask|=(1<<(ch-\\'a\\'));\\n\\n            freq[mask]++; \\n\\n        }\\n\\n        for(auto word:puzzles){\\n            \\n            // set bits can be zero or one \\n            long long mask = 0 ,count =0 ,curr=0;\\n\\n            for(auto ch:word) mask|=(1<<(ch-\\'a\\'));\\n\\n            curr|=(1<<(word[0]-\\'a\\'));\\n\\n            count+= freq[curr];\\n\\n            solve(0,curr,mask,freq,count,word[0]-\\'a\\');\\n\\n            ans.push_back(count);\\n\\n        }\\n\\n        return ans; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(int i,long long curr, long long mask,unordered_map<long long,int>& temp,long long& count,int first){\\n\\n        if(i>25) return  ;\\n        \\n        bool isSet = (mask&(1<<i));\\n\\n        solve(i+1,curr,mask,temp,count,first);\\n\\n        if(isSet && (i!=first) ) {\\n            \\n            curr|=(1<<i);\\n            \\n            count+= temp[curr];\\n\\n            solve(i+1,curr,mask,temp,count,first);\\n\\n        }\\n\\n\\n    }\\n\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        unordered_map<long long,int> freq ;\\n\\n        vector<int> ans ;\\n\\n        for(auto word:words){\\n\\n            long long mask = 0;\\n\\n            for(auto ch:word) mask|=(1<<(ch-\\'a\\'));\\n\\n            freq[mask]++; \\n\\n        }\\n\\n        for(auto word:puzzles){\\n            \\n            // set bits can be zero or one \\n            long long mask = 0 ,count =0 ,curr=0;\\n\\n            for(auto ch:word) mask|=(1<<(ch-\\'a\\'));\\n\\n            curr|=(1<<(word[0]-\\'a\\'));\\n\\n            count+= freq[curr];\\n\\n            solve(0,curr,mask,freq,count,word[0]-\\'a\\');\\n\\n            ans.push_back(count);\\n\\n        }\\n\\n        return ans; \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098322,
                "title": "without-trie-bit-manipulation-dfs-cpp-faster",
                "content": "# Intuition\\n\\n1) store bitsmasks of each word in map\\n2) find bitmask of puzzle and try to generate all sub puzzles \\n3) sum all freq of sub puzzles\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(int i,long long curr, long long mask,unordered_map<long long,int>& temp,long long& count,int first){\\n\\n        if(i>25) return  ;\\n        \\n        bool isSet = (mask&(1<<i));\\n\\n        solve(i+1,curr,mask,temp,count,first);\\n\\n        if(isSet && (i!=first) ) {\\n            \\n            curr|=(1<<i);\\n            \\n            count+= temp[curr];\\n\\n            solve(i+1,curr,mask,temp,count,first);\\n\\n        }\\n\\n\\n    }\\n\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        unordered_map<long long,int> freq ;\\n\\n        vector<int> ans ;\\n\\n        for(auto word:words){\\n\\n            long long mask = 0;\\n\\n            for(auto ch:word) mask|=(1<<(ch-\\'a\\'));\\n\\n            freq[mask]++; \\n\\n        }\\n\\n        for(auto word:puzzles){\\n            \\n            // set bits can be zero or one \\n            long long mask = 0 ,count =0 ,curr=0;\\n\\n            for(auto ch:word) mask|=(1<<(ch-\\'a\\'));\\n\\n            curr|=(1<<(word[0]-\\'a\\'));\\n\\n            count+= freq[curr];\\n\\n            solve(0,curr,mask,freq,count,word[0]-\\'a\\');\\n\\n            ans.push_back(count);\\n\\n        }\\n\\n        return ans; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void solve(int i,long long curr, long long mask,unordered_map<long long,int>& temp,long long& count,int first){\\n\\n        if(i>25) return  ;\\n        \\n        bool isSet = (mask&(1<<i));\\n\\n        solve(i+1,curr,mask,temp,count,first);\\n\\n        if(isSet && (i!=first) ) {\\n            \\n            curr|=(1<<i);\\n            \\n            count+= temp[curr];\\n\\n            solve(i+1,curr,mask,temp,count,first);\\n\\n        }\\n\\n\\n    }\\n\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        unordered_map<long long,int> freq ;\\n\\n        vector<int> ans ;\\n\\n        for(auto word:words){\\n\\n            long long mask = 0;\\n\\n            for(auto ch:word) mask|=(1<<(ch-\\'a\\'));\\n\\n            freq[mask]++; \\n\\n        }\\n\\n        for(auto word:puzzles){\\n            \\n            // set bits can be zero or one \\n            long long mask = 0 ,count =0 ,curr=0;\\n\\n            for(auto ch:word) mask|=(1<<(ch-\\'a\\'));\\n\\n            curr|=(1<<(word[0]-\\'a\\'));\\n\\n            count+= freq[curr];\\n\\n            solve(0,curr,mask,freq,count,word[0]-\\'a\\');\\n\\n            ans.push_back(count);\\n\\n        }\\n\\n        return ans; \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031460,
                "title": "java-bitmask",
                "content": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        int n = words.length;\\n        int m = puzzles.length;\\n        List<Integer> result = new ArrayList<>();\\n        \\n        // map of bit vs count of numbers which has that bit as set\\n        Map<Integer, Map<Integer, Integer>> bitMap = new HashMap<>();\\n        for(String s: words) {\\n            int map[] = new int[26];\\n            for(char c: s.toCharArray()) {\\n                map[c-\\'a\\'] = 1;              \\n            }\\n            \\n            int number = 0;\\n            for(int i = 0; i<26; i++) {\\n                if(map[i] > 0)\\n                    number = (number | (1<<i));\\n            }\\n            \\n            for(int i = 0; i<26; i++) {\\n                if(map[i] > 0) {\\n                    bitMap.putIfAbsent(i, new HashMap<>());\\n                    bitMap.get(i).put(number, bitMap.get(i).getOrDefault(number, 0) + 1);\\n                }\\n            }\\n        }\\n        \\n        // valid word for each puzzle would be one among the set bit combinations\\n        // of the number represented by the word.\\n        for(int i = 0; i<m; i++) {\\n            int currResult = 0;\\n            List<Integer> numberCombinations = new ArrayList<>();\\n            solve(0, puzzles[i], 0, numberCombinations);\\n            int firstLetterBit = puzzles[i].charAt(0) - \\'a\\';\\n            Map<Integer, Integer> numbers = bitMap.get(firstLetterBit);\\n            \\n            if(numbers == null) {\\n                result.add(currResult);\\n                continue;\\n            }\\n            \\n            for(int number: numberCombinations)\\n                currResult += numbers.getOrDefault(number, 0);\\n            \\n            result.add(currResult);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // O(2^7)\\n    void solve(int idx, String word, int number, List<Integer> result) {\\n        if(idx >= word.length()) {\\n            if(number > 0)\\n                result.add(number);\\n            \\n            return;\\n        }\\n        \\n        // dont set the bit by the current index\\n        solve(idx + 1, word, number, result);\\n        // Set the bit by the current index\\n        int bit = word.charAt(idx) - \\'a\\';\\n        solve(idx + 1, word, number | (1<<bit), result);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        int n = words.length;\\n        int m = puzzles.length;\\n        List<Integer> result = new ArrayList<>();\\n        \\n        // map of bit vs count of numbers which has that bit as set\\n        Map<Integer, Map<Integer, Integer>> bitMap = new HashMap<>();\\n        for(String s: words) {\\n            int map[] = new int[26];\\n            for(char c: s.toCharArray()) {\\n                map[c-\\'a\\'] = 1;              \\n            }\\n            \\n            int number = 0;\\n            for(int i = 0; i<26; i++) {\\n                if(map[i] > 0)\\n                    number = (number | (1<<i));\\n            }\\n            \\n            for(int i = 0; i<26; i++) {\\n                if(map[i] > 0) {\\n                    bitMap.putIfAbsent(i, new HashMap<>());\\n                    bitMap.get(i).put(number, bitMap.get(i).getOrDefault(number, 0) + 1);\\n                }\\n            }\\n        }\\n        \\n        // valid word for each puzzle would be one among the set bit combinations\\n        // of the number represented by the word.\\n        for(int i = 0; i<m; i++) {\\n            int currResult = 0;\\n            List<Integer> numberCombinations = new ArrayList<>();\\n            solve(0, puzzles[i], 0, numberCombinations);\\n            int firstLetterBit = puzzles[i].charAt(0) - \\'a\\';\\n            Map<Integer, Integer> numbers = bitMap.get(firstLetterBit);\\n            \\n            if(numbers == null) {\\n                result.add(currResult);\\n                continue;\\n            }\\n            \\n            for(int number: numberCombinations)\\n                currResult += numbers.getOrDefault(number, 0);\\n            \\n            result.add(currResult);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // O(2^7)\\n    void solve(int idx, String word, int number, List<Integer> result) {\\n        if(idx >= word.length()) {\\n            if(number > 0)\\n                result.add(number);\\n            \\n            return;\\n        }\\n        \\n        // dont set the bit by the current index\\n        solve(idx + 1, word, number, result);\\n        // Set the bit by the current index\\n        int bit = word.charAt(idx) - \\'a\\';\\n        solve(idx + 1, word, number | (1<<bit), result);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019735,
                "title": "without-bitmasking-and-trie-optimization-python-3",
                "content": "# Code\\n```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n\\n        words = [\"\".join(sorted(set(w))) for w in words]\\n        ct = Counter(words)\\n        words = [set(w) for w in list(set(words))]\\n\\n        dt = defaultdict(lambda: [])\\n        for ws in words:\\n            for c in list(ws):\\n                dt[c].append(ws)\\n\\n        res = []\\n        for p in puzzles:\\n            t = 0\\n            ps = set(p)\\n            for ws in dt[p[0]]:\\n                if ws.issubset(ps):\\n                    t += ct[\"\".join(sorted(list(ws)))] \\n            res.append(t)\\n        \\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n\\n        words = [\"\".join(sorted(set(w))) for w in words]\\n        ct = Counter(words)\\n        words = [set(w) for w in list(set(words))]\\n\\n        dt = defaultdict(lambda: [])\\n        for ws in words:\\n            for c in list(ws):\\n                dt[c].append(ws)\\n\\n        res = []\\n        for p in puzzles:\\n            t = 0\\n            ps = set(p)\\n            for ws in dt[p[0]]:\\n                if ws.issubset(ps):\\n                    t += ct[\"\".join(sorted(list(ws)))] \\n            res.append(t)\\n        \\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008116,
                "title": "clean-trie-dfs-based-implementation",
                "content": "\\n\\n# Code\\n```\\nstruct Trie{\\n    Trie* links[26];\\n    int end;\\n    Trie(){\\n        for(int i=0;i<26;i++) links[i]=NULL;\\n        end=0;\\n    }\\n};\\n\\nvoid insert(Trie* root,string &word){\\n    int n=word.length();\\n    for(auto &ch:word){\\n        int idx=ch-\\'a\\';\\n        if(root->links[idx]==NULL){\\n            root->links[idx] = new Trie();\\n        }\\n        root = root->links[idx];\\n    }\\n    root->end++;\\n}\\nchar first_ch;\\nint search(Trie *root, string &word,bool seen){\\n    int count=0;\\n    if(seen) count+=root->end;\\n    for(auto &ch:word){\\n        int idx = ch-\\'a\\';\\n        if(ch==first_ch and root->links[idx]!=NULL){\\n            // cout<<first_ch<<endl;\\n            count += search(root->links[idx],word,true);\\n        }\\n        else if(root->links[idx]!=NULL){\\n            count += search(root->links[idx],word,seen);\\n        }\\n    }\\n    return count;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        Trie* root = new Trie(); \\n        for(auto &w:words){\\n            unordered_set<int> s(w.begin(),w.end());\\n            string tmp=\"\";\\n            for(auto &it:s) tmp.push_back(it);\\n            insert(root,tmp);\\n        }\\n        vector<int> res;\\n        for(auto &p:puzzles){\\n            first_ch = p[0];\\n            int ans = search(root,p,false);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct Trie{\\n    Trie* links[26];\\n    int end;\\n    Trie(){\\n        for(int i=0;i<26;i++) links[i]=NULL;\\n        end=0;\\n    }\\n};\\n\\nvoid insert(Trie* root,string &word){\\n    int n=word.length();\\n    for(auto &ch:word){\\n        int idx=ch-\\'a\\';\\n        if(root->links[idx]==NULL){\\n            root->links[idx] = new Trie();\\n        }\\n        root = root->links[idx];\\n    }\\n    root->end++;\\n}\\nchar first_ch;\\nint search(Trie *root, string &word,bool seen){\\n    int count=0;\\n    if(seen) count+=root->end;\\n    for(auto &ch:word){\\n        int idx = ch-\\'a\\';\\n        if(ch==first_ch and root->links[idx]!=NULL){\\n            // cout<<first_ch<<endl;\\n            count += search(root->links[idx],word,true);\\n        }\\n        else if(root->links[idx]!=NULL){\\n            count += search(root->links[idx],word,seen);\\n        }\\n    }\\n    return count;\\n}\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        Trie* root = new Trie(); \\n        for(auto &w:words){\\n            unordered_set<int> s(w.begin(),w.end());\\n            string tmp=\"\";\\n            for(auto &it:s) tmp.push_back(it);\\n            insert(root,tmp);\\n        }\\n        vector<int> res;\\n        for(auto &p:puzzles){\\n            first_ch = p[0];\\n            int ans = search(root,p,false);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2924542,
                "title": "python-bitmasking-solution-faster-than-95",
                "content": "# Code\\n```\\nclass Solution:\\n    def getWordMask(self, word: str) -> int:\\n        bitmask = 0\\n        for char in word:\\n            bitmask |= 1 << ord(char) - ord(\\'a\\')\\n        return bitmask\\n    \\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        maskFreq, res = defaultdict(int), []\\n        for word in words:\\n            maskFreq[self.getWordMask(word)] += 1\\n        for puzzle in puzzles:\\n            mask = self.getWordMask(puzzle)\\n            submask, first, curr = mask, 1 << ord(puzzle[0]) - ord(\\'a\\'), 0\\n            while submask:\\n                if submask & first:\\n                    curr += maskFreq[submask]\\n                submask = (submask - 1) & mask\\n            res.append(curr)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def getWordMask(self, word: str) -> int:\\n        bitmask = 0\\n        for char in word:\\n            bitmask |= 1 << ord(char) - ord(\\'a\\')\\n        return bitmask\\n    \\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        maskFreq, res = defaultdict(int), []\\n        for word in words:\\n            maskFreq[self.getWordMask(word)] += 1\\n        for puzzle in puzzles:\\n            mask = self.getWordMask(puzzle)\\n            submask, first, curr = mask, 1 << ord(puzzle[0]) - ord(\\'a\\'), 0\\n            while submask:\\n                if submask & first:\\n                    curr += maskFreq[submask]\\n                submask = (submask - 1) & mask\\n            res.append(curr)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832934,
                "title": "javascript-bit-manipulation",
                "content": "\\n```\\n/**\\n * @param {string[]} words\\n * @param {string[]} puzzles\\n * @return {number[]}\\n */\\n\\nvar findNumOfValidWords = function(words, puzzles) {\\n  let count = [];\\n  let wordsLetterMap = new Array(words.length).fill(0);\\n  \\n  for(let i = 0; i < words.length; i++){\\n      for (letter of words[i]){\\n          let index = letter.charCodeAt(0)-97;\\n          wordsLetterMap[i] |= (1 << (26-index)); \\n      }\\n  }\\n  let puzzlesLetterMap = new Array(puzzles.length).fill(0);\\n  for(let i = 0; i < puzzles.length; i++){\\n      for (letter of puzzles[i]){\\n          let index = letter.charCodeAt(0)-97;\\n          puzzlesLetterMap[i] |= (1 << (26-index));\\n      }\\n  }\\n\\n  for(let i = 0; i < puzzles.length; i++){\\n    let currentCount = 0;\\n    for(let j = 0; j < words.length; j++){\\n        let index = puzzles[i].charCodeAt(0)-97;\\n        if((wordsLetterMap[j] & (1 << (26-index))) && \\n        ((wordsLetterMap[j] & puzzlesLetterMap[i]) == wordsLetterMap[j])){\\n            currentCount++;\\n        }\\n    }\\n    count.push(currentCount);\\n}\\n\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string[]} puzzles\\n * @return {number[]}\\n */\\n\\nvar findNumOfValidWords = function(words, puzzles) {\\n  let count = [];\\n  let wordsLetterMap = new Array(words.length).fill(0);\\n  \\n  for(let i = 0; i < words.length; i++){\\n      for (letter of words[i]){\\n          let index = letter.charCodeAt(0)-97;\\n          wordsLetterMap[i] |= (1 << (26-index)); \\n      }\\n  }\\n  let puzzlesLetterMap = new Array(puzzles.length).fill(0);\\n  for(let i = 0; i < puzzles.length; i++){\\n      for (letter of puzzles[i]){\\n          let index = letter.charCodeAt(0)-97;\\n          puzzlesLetterMap[i] |= (1 << (26-index));\\n      }\\n  }\\n\\n  for(let i = 0; i < puzzles.length; i++){\\n    let currentCount = 0;\\n    for(let j = 0; j < words.length; j++){\\n        let index = puzzles[i].charCodeAt(0)-97;\\n        if((wordsLetterMap[j] & (1 << (26-index))) && \\n        ((wordsLetterMap[j] & puzzlesLetterMap[i]) == wordsLetterMap[j])){\\n            currentCount++;\\n        }\\n    }\\n    count.push(currentCount);\\n}\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828649,
                "title": "javascript-simple-trie-solution-without-bit-manipulation-using-hash-to-reduce-trie-size",
                "content": "As we are only interested in distinct characters in the word, let\\'s just skip them. It helps to reduce size of the trie. But you may face an issue that different words are the same in trie.\\nf.ex.**aba**, would be the same as **ab** (as we are going to skip last **a** in the first word).\\nTo make it works let\\'s count same words in the trie by adding additional property **_count** into the trie\\'s node\\n\\nHere is the my solution\\n\\n```\\nvar findNumOfValidWords = function(words, puzzles) {\\n    const n = words.length;\\n    const m = puzzles.length;\\n    const trie = {};\\n    const result = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        const hash = {};\\n        const word = words[i];\\n        \\n        let node = trie;\\n        for (let j = 0; j < word.length; j++) {\\n            if (hash[word[j]]) continue;\\n            hash[word[j]] = true;\\n            if (!node[word[j]]) node[word[j]] = {};\\n            node = node[word[j]];\\n        }\\n        \\n        node._count = (node._count || 0) + 1;\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        result[i] = 0;\\n        dfs(trie, i, false);\\n    }\\n    \\n    return result;\\n    \\n    function dfs(node, i, firstExist) {\\n        if (node._count && firstExist) {\\n            result[i] += node._count;\\n        }\\n        \\n        const puzzle = puzzles[i];\\n        \\n        for (let j = 0; j < puzzle.length; j++) {\\n            if (node[puzzle[j]]) dfs(node[puzzle[j]], i, firstExist || !j);\\n        }\\n    }\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "As we are only interested in distinct characters in the word, let\\'s just skip them. It helps to reduce size of the trie. But you may face an issue that different words are the same in trie.\\nf.ex.**aba**, would be the same as **ab** (as we are going to skip last **a** in the first word).\\nTo make it works let\\'s count same words in the trie by adding additional property **_count** into the trie\\'s node\\n\\nHere is the my solution\\n\\n```\\nvar findNumOfValidWords = function(words, puzzles) {\\n    const n = words.length;\\n    const m = puzzles.length;\\n    const trie = {};\\n    const result = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        const hash = {};\\n        const word = words[i];\\n        \\n        let node = trie;\\n        for (let j = 0; j < word.length; j++) {\\n            if (hash[word[j]]) continue;\\n            hash[word[j]] = true;\\n            if (!node[word[j]]) node[word[j]] = {};\\n            node = node[word[j]];\\n        }\\n        \\n        node._count = (node._count || 0) + 1;\\n    }\\n    \\n    for (let i = 0; i < m; i++) {\\n        result[i] = 0;\\n        dfs(trie, i, false);\\n    }\\n    \\n    return result;\\n    \\n    function dfs(node, i, firstExist) {\\n        if (node._count && firstExist) {\\n            result[i] += node._count;\\n        }\\n        \\n        const puzzle = puzzles[i];\\n        \\n        for (let j = 0; j < puzzle.length; j++) {\\n            if (node[puzzle[j]]) dfs(node[puzzle[j]], i, firstExist || !j);\\n        }\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2684345,
                "title": "c-easy-to-understand-and-debug",
                "content": "> class Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& W, vector<string>& P) {\\n        unordered_map<int, int> mp;         // { bitmask : frequency }\\n        vector<int> ans(size(P));\\n\\t\\t// following function returns bitmask of a string\\n        auto getBitmask = [](string& s) {\\n            int bitmask = 0;\\n            for(auto c : s) bitmask |= 1 << c-\\'a\\';\\n            return bitmask;\\n        };\\n\\t\\t// generating bitmask for each word and filling in hashmap\\n        for(auto& word : W)  mp[getBitmask(word)]++;\\n\\t\\t// generate bitmask for each puzzle and enumerate over its subset\\n        for(int i = 0; auto& puzzle : P) {\\n            int mask = getBitmask(puzzle), cnt = 0, firstLetter = 1 << puzzle[0]-\\'a\\';\\n            for(int submask = mask; submask; submask = (submask - 1) & mask)    // https://cp-algorithms.com/algebra/all-submasks.html\\n                if(submask & firstLetter)    // ensure 1st letter is present in submask to satisfy condition-1\\n                    cnt += mp[submask];      // add count of words having same bitmask as submask\\n            ans[i++] = cnt;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& W, vector<string>& P) {\\n        unordered_map<int, int> mp;         // { bitmask : frequency }",
                "codeTag": "Java"
            },
            {
                "id": 2624615,
                "title": "hashtable-bit-masking-in-python3",
                "content": "```\\nclass Solution:\\n    def gen_combinations(self, word):\\n        if not word:\\n            yield 0\\n        else:\\n            c = word.pop()\\n            for v in self.gen_combinations(word):\\n                yield v\\n                yield v | (1 << (ord(c) - ord(\\'a\\')))\\n            \\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        table = defaultdict(Counter)\\n        for w in words:\\n            chars = set(list(w)) \\n            if len(chars) > 7:\\n                continue\\n            h = reduce(operator.or_, [1 << (ord(c) - ord(\\'a\\')) for c in chars], 0)\\n            for c in chars:\\n                table[c][h] += 1\\n        for i, p in enumerate(puzzles):\\n            puzzles[i] = sum(table[p[0]][h] for h in self.gen_combinations(list(p)))\\n        return puzzles\\n",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def gen_combinations(self, word):\\n        if not word:\\n            yield 0\\n        else:\\n            c = word.pop()\\n            for v in self.gen_combinations(word):\\n                yield v\\n                yield v | (1 << (ord(c) - ord(\\'a\\')))\\n            \\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        table = defaultdict(Counter)\\n        for w in words:\\n            chars = set(list(w)) \\n            if len(chars) > 7:\\n                continue\\n            h = reduce(operator.or_, [1 << (ord(c) - ord(\\'a\\')) for c in chars], 0)\\n            for c in chars:\\n                table[c][h] += 1\\n        for i, p in enumerate(puzzles):\\n            puzzles[i] = sum(table[p[0]][h] for h in self.gen_combinations(list(p)))\\n        return puzzles\\n",
                "codeTag": "Java"
            },
            {
                "id": 2552894,
                "title": "easy-short-clean-efficient-code-2-approaches",
                "content": "**using bitmask iteration (submasking):**\\n```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    unordered_map<ll,ll>ump;\\n    ll func(const string& s) {\\n        ll ans = ump[1<<(s[0]-\\'a\\')], sz = s.size(), mask = bm(s.substr(1));\\n        for (ll sm = mask;sm > 0;sm = (sm - 1) & mask) {\\n            ans += ump[sm | (1 << (s[0] - \\'a\\'))];\\n        }\\n        return ans;\\n    }\\n    ll bm(const string& s) {\\n        ll ans = 0;\\n        for (char ch : s) {\\n            ans |= 1 << (ch - \\'a\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& w, vector<string>& p) {\\n        for (string s : w) {\\n            ++ump[bm(s)];\\n        }\\n        vi(int)res(p.size());\\n        for (ll i = 0;i < p.size();++i) {\\n            res[i] = func(p[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**by manually making brute force combinations:**\\n```\\nclass Solution {\\n    typedef long long ll;\\n    typedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\n    const ll mod = 1e9 + 7;\\n    const char nl = \\'\\\\n\\';\\npublic:\\n    unordered_map<ll,ll>ump;\\n    ll func(const string& s) {\\n        ll ans = 0, sz = s.size();\\n        for (ll mask = 0;mask < (1 << sz);mask += 2) {\\n            ll actual = 1 << (s[0] - \\'a\\');\\n            for (ll i = 0;i < sz;++i) {\\n                if ((mask >> i) & 1) {\\n                    actual |= 1 << (s[i] - \\'a\\');\\n                }\\n            }\\n            ans += ump[actual];\\n        }\\n        return ans;\\n    }\\n    ll bm(const string& s) {\\n        ll ans = 0;\\n        for (char ch : s) {\\n            ans |= 1 << (ch - \\'a\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& w, vector<string>& p) {\\n        for (string s : w) {\\n            ++ump[bm(s)];\\n        }\\n        vi(int)res(p.size());\\n        for (ll i = 0;i < p.size();++i) {\\n            res[i] = func(p[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    unordered_map<ll,ll>ump;\\n    ll func(const string& s) {\\n        ll ans = ump[1<<(s[0]-\\'a\\')], sz = s.size(), mask = bm(s.substr(1));\\n        for (ll sm = mask;sm > 0;sm = (sm - 1) & mask) {\\n            ans += ump[sm | (1 << (s[0] - \\'a\\'))];\\n        }\\n        return ans;\\n    }\\n    ll bm(const string& s) {\\n        ll ans = 0;\\n        for (char ch : s) {\\n            ans |= 1 << (ch - \\'a\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& w, vector<string>& p) {\\n        for (string s : w) {\\n            ++ump[bm(s)];\\n        }\\n        vi(int)res(p.size());\\n        for (ll i = 0;i < p.size();++i) {\\n            res[i] = func(p[i]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    typedef long long ll;\\n    typedef pair<ll, ll> pi;\\n#define vi(x) vector<x>\\n#define pb push_back\\n    const ll mod = 1e9 + 7;\\n    const char nl = \\'\\\\n\\';\\npublic:\\n    unordered_map<ll,ll>ump;\\n    ll func(const string& s) {\\n        ll ans = 0, sz = s.size();\\n        for (ll mask = 0;mask < (1 << sz);mask += 2) {\\n            ll actual = 1 << (s[0] - \\'a\\');\\n            for (ll i = 0;i < sz;++i) {\\n                if ((mask >> i) & 1) {\\n                    actual |= 1 << (s[i] - \\'a\\');\\n                }\\n            }\\n            ans += ump[actual];\\n        }\\n        return ans;\\n    }\\n    ll bm(const string& s) {\\n        ll ans = 0;\\n        for (char ch : s) {\\n            ans |= 1 << (ch - \\'a\\');\\n        }\\n        return ans;\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& w, vector<string>& p) {\\n        for (string s : w) {\\n            ++ump[bm(s)];\\n        }\\n        vi(int)res(p.size());\\n        for (ll i = 0;i < p.size();++i) {\\n            res[i] = func(p[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535215,
                "title": "bit-mainpulation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& p) {\\n        unordered_map<int,int> mp;\\n        for(auto &word : words){\\n            int mask = 0;\\n            for(auto &ch : word) mask |= 1<<(ch-\\'a\\');\\n            mp[mask]++;\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto &word : p){\\n            int mask = 0;\\n            for(auto &ch : word) mask |= 1<<(ch - \\'a\\');\\n            int firstPos = 1<<(word[0]-\\'a\\'), cnt = 0;\\n            \\n            // this trick is just mind blowing\\n            for(int submask = mask;submask; submask = (submask-1)&mask)\\n                if(submask & firstPos) cnt+=mp[submask];\\n            \\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& p) {\\n        unordered_map<int,int> mp;\\n        for(auto &word : words){\\n            int mask = 0;\\n            for(auto &ch : word) mask |= 1<<(ch-\\'a\\');\\n            mp[mask]++;\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto &word : p){\\n            int mask = 0;\\n            for(auto &ch : word) mask |= 1<<(ch - \\'a\\');\\n            int firstPos = 1<<(word[0]-\\'a\\'), cnt = 0;\\n            \\n            // this trick is just mind blowing\\n            for(int submask = mask;submask; submask = (submask-1)&mask)\\n                if(submask & firstPos) cnt+=mp[submask];\\n            \\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2516656,
                "title": "c-bit-masking-and-map",
                "content": "```\\n//Time complexity: O(max(len(puzzles) * 2^max(len(puzzles[i]))) , word.length * words[i].length)\\n//Space complexity: O(words.length)\\n\\nclass Solution {\\npublic:\\n    \\n    int makeMask(string s)\\n    {\\n        int mask = 0;\\n        \\n        for(const char&c:s)\\n            mask|=(1<<(c-\\'a\\'));\\n        \\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        //This maps the mask of the string -> frequency of the mask\\n        unordered_map<int,int> ump;\\n        \\n        vector<int> result;\\n        \\n        for(const string&s:words)\\n            ump[makeMask(s)]++;\\n        \\n        for(const string&s:puzzles){\\n            int firstLetter = 1<<(s[0]-\\'a\\'); // This is the first condition\\n            string temp = s.substr(1);\\n            \\n            int mask = makeMask(temp);\\n            //This is to handle the edge case\\n            int curAns = ump[firstLetter];\\n            \\n            //We are generating all the submask of the puzzle\\n            //A word is valid if mask (word) = submask(puzzle[i]) \\n            //And word[0] = puzzle[0]\\n            //We find all valid word\\n            for(int submask = mask;submask>0;submask=(submask-1)&mask)\\n                curAns+= ump[firstLetter | submask];\\n            \\n            result.push_back(curAns);\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//Time complexity: O(max(len(puzzles) * 2^max(len(puzzles[i]))) , word.length * words[i].length)\\n//Space complexity: O(words.length)\\n\\nclass Solution {\\npublic:\\n    \\n    int makeMask(string s)\\n    {\\n        int mask = 0;\\n        \\n        for(const char&c:s)\\n            mask|=(1<<(c-\\'a\\'));\\n        \\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        //This maps the mask of the string -> frequency of the mask\\n        unordered_map<int,int> ump;\\n        \\n        vector<int> result;\\n        \\n        for(const string&s:words)\\n            ump[makeMask(s)]++;\\n        \\n        for(const string&s:puzzles){\\n            int firstLetter = 1<<(s[0]-\\'a\\'); // This is the first condition\\n            string temp = s.substr(1);\\n            \\n            int mask = makeMask(temp);\\n            //This is to handle the edge case\\n            int curAns = ump[firstLetter];\\n            \\n            //We are generating all the submask of the puzzle\\n            //A word is valid if mask (word) = submask(puzzle[i]) \\n            //And word[0] = puzzle[0]\\n            //We find all valid word\\n            for(int submask = mask;submask>0;submask=(submask-1)&mask)\\n                curAns+= ump[firstLetter | submask];\\n            \\n            result.push_back(curAns);\\n            \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513560,
                "title": "getting-tle-after-passing-9-11-testcases",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> char_mask(26);\\n        for(int i=0;i<26;i++){\\n            char_mask[i]=(1<<i);\\n        }\\n        vector<vector<int>> mp(26);\\n        for(int i=0;i<words.size();i++){\\n            int temp=0;\\n            for(int j=0;j<words[i].size();j++){\\n                temp|=(char_mask[words[i][j]-\\'a\\']);\\n            }\\n            for(int k=0;k<26;k++){\\n                if(temp&(1<<k))\\n                    mp[k].push_back(temp);\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<puzzles.size();i++){\\n            int temp=0;\\n            for(int j=0;j<puzzles[i].size();j++){\\n                temp|=char_mask[puzzles[i][j]-\\'a\\'];\\n            }\\n            int cnt=0;\\n            int ind=puzzles[i][0]-\\'a\\';\\n            for(int j=0;j<mp[ind].size();j++){\\n                int new_mask=mp[ind][j]&temp;\\n                if(mp[ind][j]==new_mask)\\n                    cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nCan anyone tell how could this code be further optimized to pass all the testcases?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vector<int> char_mask(26);\\n        for(int i=0;i<26;i++){\\n            char_mask[i]=(1<<i);\\n        }\\n        vector<vector<int>> mp(26);\\n        for(int i=0;i<words.size();i++){\\n            int temp=0;\\n            for(int j=0;j<words[i].size();j++){\\n                temp|=(char_mask[words[i][j]-\\'a\\']);\\n            }\\n            for(int k=0;k<26;k++){\\n                if(temp&(1<<k))\\n                    mp[k].push_back(temp);\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<puzzles.size();i++){\\n            int temp=0;\\n            for(int j=0;j<puzzles[i].size();j++){\\n                temp|=char_mask[puzzles[i][j]-\\'a\\'];\\n            }\\n            int cnt=0;\\n            int ind=puzzles[i][0]-\\'a\\';\\n            for(int j=0;j<mp[ind].size();j++){\\n                int new_mask=mp[ind][j]&temp;\\n                if(mp[ind][j]==new_mask)\\n                    cnt++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420332,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    vector<int> res;\\n    \\n    unordered_map<int,int> mp;\\n    \\n    int mask_word(string st)\\n    {\\n        int mask = 0;\\n        \\n        for(auto x: st)\\n        {\\n            mask = mask | 1 << (x-\\'a\\');\\n        }\\n        \\n        return mask;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        \\n        \\n        for(auto x: words)\\n        {\\n            int tmp = mask_word(x);\\n            \\n            mp[tmp]++;\\n        }\\n        \\n        for(auto word : puzzles)\\n        {\\n            int mask = mask_word(word), sub_mask = mask, first = (1 <<word[0]-\\'a\\'), cur = 0;\\n            \\n            while(sub_mask)\\n            {\\n                if(sub_mask & first)\\n                {\\n                    cur += mp[sub_mask];\\n                }\\n                \\n                sub_mask = (sub_mask-1) & mask;\\n            }\\n            \\n            res.push_back(cur);\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int> res;\\n    \\n    unordered_map<int,int> mp;\\n    \\n    int mask_word(string st)\\n    {\\n        int mask = 0;\\n        \\n        for(auto x: st)\\n        {\\n            mask = mask | 1 << (x-\\'a\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2291814,
                "title": "c-bitmask-generating-mask-subset",
                "content": "```\\nauto __speed_up = [](){\\n    ios::sync_with_stdio(0);    \\n    cin.tie(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        int n = words.size();\\n        unordered_map<int,int> tab;\\n        tab.reserve(n);\\n        for (int i = 0; i < n; i++) {\\n            int hash = 0;\\n            for (char c : words[i])\\n                hash |= 1 << (c - \\'a\\');\\n            tab[hash]++;\\n        }\\n        \\n        vector<int> out;\\n        out.reserve(puzzles.size());\\n        for (const string& str : puzzles) {\\n            int hash = 0;\\n            for (char c : str)\\n                hash |= 1 << (c - \\'a\\');\\n            // not counting the first letter\\n            // there are only 2^6 (=64) possibilities\\n            int sum = 0;\\n            int mask = 1 << (str.front() - \\'a\\'); // first letter\\n            for (int sub_hash = hash; sub_hash > 0; sub_hash = (sub_hash - 1) & hash) {\\n                if (!(sub_hash & mask)) continue; // cannot miss that letter\\n                // sorry, I don\\'t know how to reduce from 2^7 to 2^6\\n                auto it = tab.find(sub_hash);\\n                sum += it == tab.end() ? 0 : it->second;\\n            }\\n            out.push_back(sum);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto __speed_up = [](){\\n    ios::sync_with_stdio(0);    \\n    cin.tie(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        int n = words.size();\\n        unordered_map<int,int> tab;\\n        tab.reserve(n);\\n        for (int i = 0; i < n; i++) {\\n            int hash = 0;\\n            for (char c : words[i])\\n                hash |= 1 << (c - \\'a\\');\\n            tab[hash]++;\\n        }\\n        \\n        vector<int> out;\\n        out.reserve(puzzles.size());\\n        for (const string& str : puzzles) {\\n            int hash = 0;\\n            for (char c : str)\\n                hash |= 1 << (c - \\'a\\');\\n            // not counting the first letter\\n            // there are only 2^6 (=64) possibilities\\n            int sum = 0;\\n            int mask = 1 << (str.front() - \\'a\\'); // first letter\\n            for (int sub_hash = hash; sub_hash > 0; sub_hash = (sub_hash - 1) & hash) {\\n                if (!(sub_hash & mask)) continue; // cannot miss that letter\\n                // sorry, I don\\'t know how to reduce from 2^7 to 2^6\\n                auto it = tab.find(sub_hash);\\n                sum += it == tab.end() ? 0 : it->second;\\n            }\\n            out.push_back(sum);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270902,
                "title": "golang-bitmask-easy-solution",
                "content": "```\\nfunc findNumOfValidWords(w []string, p []string) []int {\\n    bw := make(map[int]int, len(w))\\n\\tch := [26]map[int]struct{}{}\\n    for i := range ch { ch[i] = make(map[int]struct{}) }\\n\\tfor i := range w {\\n\\t\\tm := 0\\n\\t\\tfor j := range w[i] { m |= 1 << (w[i][j] - 97) }\\n\\t\\tbw[m] += 1\\n\\t\\tfor j := range w[i] { ch[(w[i][j] - 97)][m] = struct{}{} }\\n\\t}\\n\\n\\tr := make([]int, len(p))\\n\\tfor i := range p {\\n\\t\\tpm := 0\\n\\t\\tfor j := range p[i] { pm |= 1 << (p[i][j] - 97) }\\n\\t\\tc := 0\\n\\t\\tfor wm := range ch[p[i][0] - 97] {\\n\\t\\t\\tif wm&pm == wm { c += bw[wm] }\\n\\t\\t}\\n\\t\\tr[i] = c\\n\\t}\\n\\treturn r\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc findNumOfValidWords(w []string, p []string) []int {\\n    bw := make(map[int]int, len(w))\\n\\tch := [26]map[int]struct{}{}\\n    for i := range ch { ch[i] = make(map[int]struct{}) }\\n\\tfor i := range w {\\n\\t\\tm := 0\\n\\t\\tfor j := range w[i] { m |= 1 << (w[i][j] - 97) }\\n\\t\\tbw[m] += 1\\n\\t\\tfor j := range w[i] { ch[(w[i][j] - 97)][m] = struct{}{} }\\n\\t}\\n\\n\\tr := make([]int, len(p))\\n\\tfor i := range p {\\n\\t\\tpm := 0\\n\\t\\tfor j := range p[i] { pm |= 1 << (p[i][j] - 97) }\\n\\t\\tc := 0\\n\\t\\tfor wm := range ch[p[i][0] - 97] {\\n\\t\\t\\tif wm&pm == wm { c += bw[wm] }\\n\\t\\t}\\n\\t\\tr[i] = c\\n\\t}\\n\\treturn r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2219369,
                "title": "python-trie",
                "content": "```\\nclass trie:\\n    def __init__(self):\\n        self.child=defaultdict(trie)\\n        self.count=0\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        root=trie()\\n        def build(s):\\n            r=root\\n            for i in s:\\n                r=r.child[i]\\n            r.count+=1\\n        for i in words:\\n            build(\"\".join(sorted(set(i))))\\n        def f(r,s,first,i):\\n            if i==len(s):\\n                return r.count\\n            ans=f(r.child[s[i]],s,first,i+1)\\n            if s[i]!=first:\\n                ans+=f(r,s,first,i+1)\\n            return ans\\n        return [f(root,\"\".join(sorted(set(i))),i[0],0) for i in puzzles]\\n```",
                "solutionTags": [],
                "code": "```\\nclass trie:\\n    def __init__(self):\\n        self.child=defaultdict(trie)\\n        self.count=0\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        root=trie()\\n        def build(s):\\n            r=root\\n            for i in s:\\n                r=r.child[i]\\n            r.count+=1\\n        for i in words:\\n            build(\"\".join(sorted(set(i))))\\n        def f(r,s,first,i):\\n            if i==len(s):\\n                return r.count\\n            ans=f(r.child[s[i]],s,first,i+1)\\n            if s[i]!=first:\\n                ans+=f(r,s,first,i+1)\\n            return ans\\n        return [f(root,\"\".join(sorted(set(i))),i[0],0) for i in puzzles]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2171626,
                "title": "bitmask-recursion",
                "content": "```cpp\\nunordered_map<int, int> vis;\\n\\nstring *s;\\nint msk;\\nint on;\\nint *ret;\\n\\ninline void dfs() {\\n    if (on == 7) {\\n        (*ret) += vis.count(msk) ? vis[msk]: 0;\\n    } else {\\n        on ++;\\n        dfs();\\n        on --;\\n        \\n        msk |= (1 << ((*s)[on] - \\'a\\'));\\n        on ++;\\n        dfs();\\n        on --;\\n        msk &= (~(1 << ((*s)[on] - \\'a\\')));\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vis.clear();\\n        for (auto &s : words) {\\n            msk = 0;\\n            for (auto c: s) {\\n                msk |= (1 << (c - \\'a\\'));\\n            }\\n            vis[msk] ++;\\n        }\\n        vector<int> ans(puzzles.size());\\n        for (int i = 0, N = puzzles.size(); i < N; i ++) {\\n            s = &puzzles[i];\\n            msk = (1 << (puzzles[i][0] - \\'a\\'));\\n            on = 1;\\n            ret = &ans[i];\\n            dfs();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nunordered_map<int, int> vis;\\n\\nstring *s;\\nint msk;\\nint on;\\nint *ret;\\n\\ninline void dfs() {\\n    if (on == 7) {\\n        (*ret) += vis.count(msk) ? vis[msk]: 0;\\n    } else {\\n        on ++;\\n        dfs();\\n        on --;\\n        \\n        msk |= (1 << ((*s)[on] - \\'a\\'));\\n        on ++;\\n        dfs();\\n        on --;\\n        msk &= (~(1 << ((*s)[on] - \\'a\\')));\\n    }\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        vis.clear();\\n        for (auto &s : words) {\\n            msk = 0;\\n            for (auto c: s) {\\n                msk |= (1 << (c - \\'a\\'));\\n            }\\n            vis[msk] ++;\\n        }\\n        vector<int> ans(puzzles.size());\\n        for (int i = 0, N = puzzles.size(); i < N; i ++) {\\n            s = &puzzles[i];\\n            msk = (1 << (puzzles[i][0] - \\'a\\'));\\n            on = 1;\\n            ret = &ans[i];\\n            dfs();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1835926,
                "title": "golang-bitmask-dfs-solution-beat-100",
                "content": "```go\\nfunc findNumOfValidWords(words []string, puzzles []string) []int {\\n\\thash := make(map[int]int)\\n\\tfor _, word := range words {\\n\\t\\tbitmask := 0\\n\\t\\tfor _, c := range word {\\n\\t\\t\\tbitmask |= 0x1<<(c-\\'a\\')\\n\\t\\t}\\n\\t\\thash[bitmask]++\\n\\t}\\n\\tresult := make([]int, len(puzzles))\\n\\tfor resIndex, puzzle := range puzzles {\\n\\t\\tbase := 0x1<<(puzzle[0]-\\'a\\')\\n\\t\\tfootprint := make([]bool, 26)\\n\\t\\tfootprint[puzzle[0]-\\'a\\'] = true\\n\\t\\textend := make([]int, 0, 6)\\n\\t\\tfor i := 1; i < len(puzzle); i++ {\\n\\t\\t\\tif footprint[puzzle[i]-\\'a\\'] == true {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfootprint[puzzle[i]-\\'a\\'] = true\\n\\t\\t\\textend = append(extend, int(puzzle[i]-\\'a\\'))\\n\\t\\t}\\n\\t\\tresult[resIndex] = dfs(hash, base, extend, 0)\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(hash map[int]int, currBitmask int, extend []int, index int) int {\\n\\tif index == len(extend) {\\n\\t\\treturn hash[currBitmask]\\n\\t}\\n\\tvalue := 0\\n\\tvalue += dfs(hash, currBitmask, extend, index+1)\\n\\tvalue += dfs(hash, currBitmask|(0x1<<extend[index]), extend, index+1)\\n\\treturn value\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```go\\nfunc findNumOfValidWords(words []string, puzzles []string) []int {\\n\\thash := make(map[int]int)\\n\\tfor _, word := range words {\\n\\t\\tbitmask := 0\\n\\t\\tfor _, c := range word {\\n\\t\\t\\tbitmask |= 0x1<<(c-\\'a\\')\\n\\t\\t}\\n\\t\\thash[bitmask]++\\n\\t}\\n\\tresult := make([]int, len(puzzles))\\n\\tfor resIndex, puzzle := range puzzles {\\n\\t\\tbase := 0x1<<(puzzle[0]-\\'a\\')\\n\\t\\tfootprint := make([]bool, 26)\\n\\t\\tfootprint[puzzle[0]-\\'a\\'] = true\\n\\t\\textend := make([]int, 0, 6)\\n\\t\\tfor i := 1; i < len(puzzle); i++ {\\n\\t\\t\\tif footprint[puzzle[i]-\\'a\\'] == true {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tfootprint[puzzle[i]-\\'a\\'] = true\\n\\t\\t\\textend = append(extend, int(puzzle[i]-\\'a\\'))\\n\\t\\t}\\n\\t\\tresult[resIndex] = dfs(hash, base, extend, 0)\\n\\t}\\n\\treturn result\\n}\\n\\nfunc dfs(hash map[int]int, currBitmask int, extend []int, index int) int {\\n\\tif index == len(extend) {\\n\\t\\treturn hash[currBitmask]\\n\\t}\\n\\tvalue := 0\\n\\tvalue += dfs(hash, currBitmask, extend, index+1)\\n\\tvalue += dfs(hash, currBitmask|(0x1<<extend[index]), extend, index+1)\\n\\treturn value\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1791448,
                "title": "java-solution-full-explanation-easy-to-understand",
                "content": "# Approach:\\n1. ) We create hashmap of all the word-masks and it\\'s frequency.\\n\\n**To find the no. of words that are valid for a puzzle:-**\\n*  According to the question , the maximum length of a puzzle = 7,\\n* We exploit the fact that the length of the puzzle is only 7.\\n* Therefore , maximum possible combinations of given puzzle-mask  = 2^7\\n* Valid word-masks will be among these 2^7 only.\\n*  Therefore , we iterate through a puzzle\\'s 2^7 combinations , to check which of them make valid words. We keep a count of these valid words and at the end , we add the count value into the final answer arrayList. **In this way. we calculate the count of valid words for ith puzzle**.\\n\\n2.)We repeat this process for finding out count of valid words for all puzzles\\n\\n**NOTE:**\\n**All valid word-masks are subsequences of the given puzzle-mask**\\n\\n3.)* With respect to a given **puzzle** string, a **word is valid** if both the following conditions are  satisfied : - \\n       1. word contains the first letter of puzzle.\\n       2. For each letter in word, that letter is in puzzle.\\n* **How to check if a word contains the first letter of the puzzle ? **\\n           1.       We create bit- masks of the first charcter of puzzle and word.\\n                     Eg-   word-mask : 0 1 0 0 1 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        0th char of puzzle-mask : 0 0 1 0 0 0\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tWord-mask & puzzle-mask = 0 0 0 0 0 0 , \\n\\t\\tso the 1st char of the given  puzzle is not present in\\tthe word.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n2. If the bitwise AND of two masks = ( first char of puzzle mask )\\t, then , word contains the first letter of the given puzzle ,  else , word does not contain the first letter of the given puzzle.\\n\\n * **How to check if a puzzle contains all  letters of a word ?**\\n         We check if the map contains the puzzle-mask. If it does ,  then it is a valid word\\n\\t\\t\\t\\t \\n**Therefore, to check valid words ith puzzle-mask , we iterate through all of it\\'s subseq-mask . So, every sub-mask is a potential valid word .\\nWe do the first char check and all letters check , and if both satisfy , then we can say that any sub-mask is a valid word-mask and we add freq of the word-mask in the count variable.**\\n\\n# Code:\\n```\\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) \\n    {\\n        List<Integer> ans = new ArrayList<>();\\n    \\tHashMap<Integer,Integer> map = new HashMap<>();\\n\\t\\t\\t// creating the hashmap\\n    \\tfor(int i=0;i<words.length;i++)\\n    \\t{\\n    \\t\\tint wordmask = createMask(words[i]);\\n    \\t\\tif(map.containsKey(wordmask))\\n    \\t\\t{\\n    \\t\\t\\tint oldfreq = map.get(wordmask);\\n    \\t\\t\\tint newfreq = oldfreq+1;\\n    \\t\\t\\tmap.put(wordmask,newfreq);\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tmap.put(wordmask,1);\\n    \\t\\t}\\n    \\t}\\n    \\t// finding count of valid words for all puzzles\\n    \\tfor(int i=0;i<puzzles.length;i++)\\n    \\t{\\n    \\t\\tint puzzlemask = createMask(puzzles[i]); //creating bit-mask of ith puzzle\\n    \\t\\t//finding combinations of puzzlemask that match with a word\\n    \\t\\tchar firstChar = puzzles[i].charAt(0);\\n    \\t\\tint first = 1 << (firstChar - \\'a\\'); // first char mask\\n    \\t\\tint sub = puzzlemask;\\n    \\t\\tint count=0;\\n    \\t\\twhile(sub!=0)\\n    \\t\\t{\\n    \\t\\t\\tboolean _1stCharPresent = ((sub & first)==first)?true:false;\\n    \\t\\t\\tboolean wordvalid = map.containsKey(sub); // when a combination of ith puzzle is present as word in the map\\n    \\t\\t\\tif(_1stCharPresent==true && wordvalid==true)\\n    \\t\\t\\t\\tcount += map.get(sub); // add freq of the word\\n    \\t\\t\\t\\n    \\t\\t\\tsub = (sub-1) & puzzlemask; //get to th next substring\\n    \\t\\t}\\n    \\t\\tans.add(count);\\n    \\t}\\n    \\treturn ans;\\n    }\\n    \\n\\tprivate  int createMask(String str)\\n\\t{\\n\\t\\tint mask = 0;\\n\\t\\tfor(int i=0;i<str.length();i++)\\n\\t\\t{\\n\\t\\t\\tint bit = str.charAt(i)-\\'a\\';\\n\\t\\t\\tmask = (mask | (1 << bit));\\n\\t\\t}\\n\\t\\treturn mask;\\n\\t}\\n```\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) \\n    {\\n        List<Integer> ans = new ArrayList<>();\\n    \\tHashMap<Integer,Integer> map = new HashMap<>();\\n\\t\\t\\t// creating the hashmap\\n    \\tfor(int i=0;i<words.length;i++)\\n    \\t{\\n    \\t\\tint wordmask = createMask(words[i]);\\n    \\t\\tif(map.containsKey(wordmask))\\n    \\t\\t{\\n    \\t\\t\\tint oldfreq = map.get(wordmask);\\n    \\t\\t\\tint newfreq = oldfreq+1;\\n    \\t\\t\\tmap.put(wordmask,newfreq);\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\tmap.put(wordmask,1);\\n    \\t\\t}\\n    \\t}\\n    \\t// finding count of valid words for all puzzles\\n    \\tfor(int i=0;i<puzzles.length;i++)\\n    \\t{\\n    \\t\\tint puzzlemask = createMask(puzzles[i]); //creating bit-mask of ith puzzle\\n    \\t\\t//finding combinations of puzzlemask that match with a word\\n    \\t\\tchar firstChar = puzzles[i].charAt(0);\\n    \\t\\tint first = 1 << (firstChar - \\'a\\'); // first char mask\\n    \\t\\tint sub = puzzlemask;\\n    \\t\\tint count=0;\\n    \\t\\twhile(sub!=0)\\n    \\t\\t{\\n    \\t\\t\\tboolean _1stCharPresent = ((sub & first)==first)?true:false;\\n    \\t\\t\\tboolean wordvalid = map.containsKey(sub); // when a combination of ith puzzle is present as word in the map\\n    \\t\\t\\tif(_1stCharPresent==true && wordvalid==true)\\n    \\t\\t\\t\\tcount += map.get(sub); // add freq of the word\\n    \\t\\t\\t\\n    \\t\\t\\tsub = (sub-1) & puzzlemask; //get to th next substring\\n    \\t\\t}\\n    \\t\\tans.add(count);\\n    \\t}\\n    \\treturn ans;\\n    }\\n    \\n\\tprivate  int createMask(String str)\\n\\t{\\n\\t\\tint mask = 0;\\n\\t\\tfor(int i=0;i<str.length();i++)\\n\\t\\t{\\n\\t\\t\\tint bit = str.charAt(i)-\\'a\\';\\n\\t\\t\\tmask = (mask | (1 << bit));\\n\\t\\t}\\n\\t\\treturn mask;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1723359,
                "title": "c-solution-using-trie",
                "content": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        vector<int> index;\\n        TrieNode* child[26];\\n        TrieNode(){\\n            for(int i = 0; i < 26; i++){\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n    void insert(TrieNode* root, string &s, int &ind){\\n        \\n        vector<int> alpha(26, 0);\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            alpha[s[i] - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++){\\n            if(alpha[i] == 0) continue;\\n            if(root -> child[i] == NULL){\\n                root -> child[i] = new TrieNode();\\n            }\\n            root = root -> child[i];\\n        }\\n        (root -> index).push_back(ind);\\n    }\\n    void solve(TrieNode* root, char &firstchar, int &count, bool &flag, vector<int> &alpha, vector<string> &words){\\n        \\n        if((root -> index).size() != 0){\\n            if(flag){\\n                count += (root -> index).size();\\n            }   \\n        }\\n        for(int i = 0; i < 26; i++){\\n            if(root -> child[i] != NULL){\\n                if(alpha[i]){\\n                    if(firstchar - \\'a\\' == i && !flag){\\n                        flag = true;\\n                        solve(root -> child[i], firstchar, count, flag, alpha, words);\\n                        flag = false;\\n                    }\\n                    else{\\n                        solve(root -> child[i], firstchar, count, flag, alpha, words);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        TrieNode* root = new TrieNode();\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            insert(root, words[i], i);\\n        }\\n        \\n        vector<int> res;\\n        for(int i = 0; i < puzzles.size(); i++){\\n            vector<int> alpha(26, 0);\\n            for(int j = 0; j < puzzles[i].size(); j++){\\n                alpha[puzzles[i][j] - \\'a\\']++;\\n            }\\n            int count = 0;\\n            bool flag = false;\\n            solve(root, puzzles[i][0], count, flag, alpha, words);\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TrieNode{\\n        vector<int> index;\\n        TrieNode* child[26];\\n        TrieNode(){\\n            for(int i = 0; i < 26; i++){\\n                child[i] = NULL;\\n            }\\n        }\\n    };\\n    void insert(TrieNode* root, string &s, int &ind){\\n        \\n        vector<int> alpha(26, 0);\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            alpha[s[i] - \\'a\\']++;\\n        }\\n        for(int i = 0; i < 26; i++){\\n            if(alpha[i] == 0) continue;\\n            if(root -> child[i] == NULL){\\n                root -> child[i] = new TrieNode();\\n            }\\n            root = root -> child[i];\\n        }\\n        (root -> index).push_back(ind);\\n    }\\n    void solve(TrieNode* root, char &firstchar, int &count, bool &flag, vector<int> &alpha, vector<string> &words){\\n        \\n        if((root -> index).size() != 0){\\n            if(flag){\\n                count += (root -> index).size();\\n            }   \\n        }\\n        for(int i = 0; i < 26; i++){\\n            if(root -> child[i] != NULL){\\n                if(alpha[i]){\\n                    if(firstchar - \\'a\\' == i && !flag){\\n                        flag = true;\\n                        solve(root -> child[i], firstchar, count, flag, alpha, words);\\n                        flag = false;\\n                    }\\n                    else{\\n                        solve(root -> child[i], firstchar, count, flag, alpha, words);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        TrieNode* root = new TrieNode();\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            insert(root, words[i], i);\\n        }\\n        \\n        vector<int> res;\\n        for(int i = 0; i < puzzles.size(); i++){\\n            vector<int> alpha(26, 0);\\n            for(int j = 0; j < puzzles[i].size(); j++){\\n                alpha[puzzles[i][j] - \\'a\\']++;\\n            }\\n            int count = 0;\\n            bool flag = false;\\n            solve(root, puzzles[i][0], count, flag, alpha, words);\\n            res.push_back(count);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685315,
                "title": "python-bit-manipulation-hashing",
                "content": "```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        look_up=collections.defaultdict(int)\\n        def get_mask(word):\\n            mask=0\\n            for c in word:\\n                mask |= 1<<(ord(c)-ord(\\'a\\'))\\n            return mask\\n        for word in words:\\n            mask=get_mask(word)\\n            look_up[mask]+=1\\n        ans=[]\\n        def solve(puzzle_idx,mask,c_idx):\\n            if c_idx==len(puzzles[puzzle_idx]):\\n                ans[-1]+=look_up[mask]\\n                return\\n            #take this c_idx\\n            solve(puzzle_idx,mask | 1<<(ord(puzzles[puzzle_idx][c_idx])-ord(\\'a\\')),c_idx+1)\\n            #dont take this c_idx\\n            solve(puzzle_idx,mask,c_idx+1)\\n        for i,puzzle in enumerate(puzzles):\\n            ans.append(0)\\n            solve(i,1<<(ord(puzzle[0])-ord(\\'a\\')),1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        look_up=collections.defaultdict(int)\\n        def get_mask(word):\\n            mask=0\\n            for c in word:\\n                mask |= 1<<(ord(c)-ord(\\'a\\'))\\n            return mask\\n        for word in words:\\n            mask=get_mask(word)\\n            look_up[mask]+=1\\n        ans=[]\\n        def solve(puzzle_idx,mask,c_idx):\\n            if c_idx==len(puzzles[puzzle_idx]):\\n                ans[-1]+=look_up[mask]\\n                return\\n            #take this c_idx\\n            solve(puzzle_idx,mask | 1<<(ord(puzzles[puzzle_idx][c_idx])-ord(\\'a\\')),c_idx+1)\\n            #dont take this c_idx\\n            solve(puzzle_idx,mask,c_idx+1)\\n        for i,puzzle in enumerate(puzzles):\\n            ans.append(0)\\n            solve(i,1<<(ord(puzzle[0])-ord(\\'a\\')),1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679765,
                "title": "java-bitmask-solution",
                "content": "~~~java\\n\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer> result = new ArrayList<>();\\n        if (puzzles == null || puzzles.length == 0) {\\n            return result;\\n        } else if (words == null || words.length == 0) {\\n            for (int i = 0; i < puzzles.length; i++) {\\n                result.add(0);\\n            }\\n            return result;\\n        }\\n        \\n        int[] puzzleBits = new int[puzzles.length];\\n        Map<Integer, Integer> wordBitCnt = new HashMap<>();\\n        for (int i = 0; i < puzzles.length; i++) {\\n            puzzleBits[i] = stringToBit(puzzles[i]);\\n        }\\n        for (int i = 0; i < words.length; i++) {\\n            int wordBit = stringToBit(words[i]);\\n            wordBitCnt.put(wordBit, wordBitCnt.getOrDefault(wordBit, 0) + 1);\\n        }\\n        \\n        for (int i = 0; i < puzzles.length; i++) {\\n            int count = 0;\\n            for (int wordBit : wordBitCnt.keySet()) {\\n                if ((wordBit & (1 << (puzzles[i].charAt(0) - \\'a\\'))) == 0) {\\n                    continue;\\n                }\\n                if (((~puzzleBits[i]) & wordBit) == 0) {\\n                    count += wordBitCnt.get(wordBit);\\n                }\\n            }\\n            result.add(count);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int stringToBit(String s) {\\n        int result = 0;\\n        for (char c : s.toCharArray()) {\\n            result |= (1 << (c - \\'a\\'));\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer> result = new ArrayList<>();\\n        if (puzzles == null || puzzles.length == 0) {\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1664002,
                "title": "c-bitmasking-hashmap",
                "content": "[C++] Bitmasking + hashmap \\nApproach 1: Compact version of Approach 2 [1][2]\\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> maskCnt;\\n        for(const auto& w: words) ++maskCnt[bitmask(w)];   \\n        vector<int> ans(puzzles.size(), 0);                                      \\n        for(int i = 0; i < puzzles.size(); i++){\\n            int mask, subMask = mask = bitmask(puzzles[i]), first = bitmask(puzzles[i].substr(0,1));\\n            do{                \\n                if( (first & subMask) == first  && maskCnt.count(subMask)) ans[i] += maskCnt[subMask]; //ok                \\n            }while(subMask = (subMask - 1) & mask);            \\n        }\\n        return ans;        \\n    }\\n    \\nprivate:\\n    int bitmask(const string& word, int mask = 0){        \\n        for(auto c: word) mask |=  (1 << (c - \\'a\\'));\\n        return mask;\\n    }\\n};\\n```\\n\\nApproach 2: Compact version of Approach 2\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> maskCnt;\\n        for(const auto& w: words)\\n            ++maskCnt[bitmask(w)];        \\n        \\n        vector<int> ans;\\n        for(const auto& p: puzzles){                                 \\n            int mask, subMask = mask = bitmask(p), first = bitmask(p.substr(0,1)), cnt = 0;\\n            while(subMask){\\n                //if( (first & subMask == first)  && maskCnt.count(subMask)) cnt += maskCnt[subMask]; // WRONG. \\n                if(   (first & subMask) == first  && maskCnt.count(subMask)) cnt += maskCnt[subMask]; //ok\\n                subMask = (subMask - 1) & mask;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;        \\n    }\\n    \\nprivate:\\n    int bitmask(const string& word){\\n        int mask = 0;\\n        for(auto c: word) mask |=  (1 << (c - \\'a\\'));\\n        return mask;\\n    }\\n};\\n```\\n\\nApproach 3: More natural style\\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> freqs;\\n        for(auto& w: words) ++freqs[bitmask(w)];\\n        \\n        vector<int> ans(puzzles.size(), 0);\\n        for(int i = 0; i < puzzles.size(); i++){\\n            int mask = bitmask(puzzles[i]);\\n            int subMask = mask, first = bitmask(puzzles[i].substr(0, 1));\\n            while(subMask){\\n                if((subMask & first) == first && freqs.count(subMask)) ans[i]+= freqs[subMask];\\n                subMask = (subMask - 1) & mask;\\n            }\\n        }\\n        return ans;        \\n    }\\n    \\nprivate:\\n    int bitmask(const string& word){\\n        int mask = 0;\\n        for(auto c: word) mask |= 1 << (c - \\'a\\');\\n        return mask;\\n    }\\n};\\n```\\n\\n\\nReference:\\n[1] https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/solution/\\n[2] https://zxi.mytechroad.com/blog/?s=1178\\n",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> maskCnt;\\n        for(const auto& w: words) ++maskCnt[bitmask(w)];   \\n        vector<int> ans(puzzles.size(), 0);                                      \\n        for(int i = 0; i < puzzles.size(); i++){\\n            int mask, subMask = mask = bitmask(puzzles[i]), first = bitmask(puzzles[i].substr(0,1));\\n            do{                \\n                if( (first & subMask) == first  && maskCnt.count(subMask)) ans[i] += maskCnt[subMask]; //ok                \\n            }while(subMask = (subMask - 1) & mask);            \\n        }\\n        return ans;        \\n    }\\n    \\nprivate:\\n    int bitmask(const string& word, int mask = 0){        \\n        for(auto c: word) mask |=  (1 << (c - \\'a\\'));\\n        return mask;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> maskCnt;\\n        for(const auto& w: words)\\n            ++maskCnt[bitmask(w)];        \\n        \\n        vector<int> ans;\\n        for(const auto& p: puzzles){                                 \\n            int mask, subMask = mask = bitmask(p), first = bitmask(p.substr(0,1)), cnt = 0;\\n            while(subMask){\\n                //if( (first & subMask == first)  && maskCnt.count(subMask)) cnt += maskCnt[subMask]; // WRONG. \\n                if(   (first & subMask) == first  && maskCnt.count(subMask)) cnt += maskCnt[subMask]; //ok\\n                subMask = (subMask - 1) & mask;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;        \\n    }\\n    \\nprivate:\\n    int bitmask(const string& word){\\n        int mask = 0;\\n        for(auto c: word) mask |=  (1 << (c - \\'a\\'));\\n        return mask;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> freqs;\\n        for(auto& w: words) ++freqs[bitmask(w)];\\n        \\n        vector<int> ans(puzzles.size(), 0);\\n        for(int i = 0; i < puzzles.size(); i++){\\n            int mask = bitmask(puzzles[i]);\\n            int subMask = mask, first = bitmask(puzzles[i].substr(0, 1));\\n            while(subMask){\\n                if((subMask & first) == first && freqs.count(subMask)) ans[i]+= freqs[subMask];\\n                subMask = (subMask - 1) & mask;\\n            }\\n        }\\n        return ans;        \\n    }\\n    \\nprivate:\\n    int bitmask(const string& word){\\n        int mask = 0;\\n        for(auto c: word) mask |= 1 << (c - \\'a\\');\\n        return mask;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573870,
                "title": "python-easy-solution-using-combinations-and-dictionaries",
                "content": "Intuition:-\\nTotal possible combinations from 1 puzzle word=> 1 * 2^6 = 32 \\nStarting word should be present, so there will bw total 2 ^ (length -1) possible combinations.\\nTime Complexity = O(len(puzzle array)*(2^6) +   len(words)  )\\n\\n\\n\\n\\n\\n    class Solution:\\n\\t\\tdef findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n\\t\\t\\tdic = Counter()\\n\\t\\t\\tfor i in words:\\n\\t\\t\\t\\ttemp = tuple(sorted(set(i)))\\n\\t\\t\\t\\tdic[temp] += 1\\n\\n\\t\\t\\tdef combinations(a):\\n\\t\\t\\t\\tans = []\\n\\t\\t\\t\\tstack = [a[0]]\\n\\t\\t\\t\\tdef rec(i):\\n\\t\\t\\t\\t\\tif i == len(a):\\n\\t\\t\\t\\t\\t\\tans.append(tuple(sorted(stack)))\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tstack.append(a[i])\\n\\t\\t\\t\\t\\trec(i+1)\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t\\trec(i+1)\\n\\t\\t\\t\\trec(1)\\n\\t\\t\\t\\treturn ans\\n\\n\\n\\t\\t\\tanswer = []\\n\\t\\t\\tfor i in puzzles:\\n\\t\\t\\t\\tcomb =  combinations(i)\\n\\t\\t\\t\\ttemp = 0 \\n\\t\\t\\t\\tfor j in comb:\\n\\t\\t\\t\\t\\ttemp += dic[j]\\n\\t\\t\\t\\tanswer.append(temp)\\n\\t\\t\\treturn answer",
                "solutionTags": [
                    "Python",
                    "Combinatorics"
                ],
                "code": "Intuition:-\\nTotal possible combinations from 1 puzzle word=> 1 * 2^6 = 32 \\nStarting word should be present, so there will bw total 2 ^ (length -1) possible combinations.\\nTime Complexity = O(len(puzzle array)*(2^6) +   len(words)  )\\n\\n\\n\\n\\n\\n    class Solution:\\n\\t\\tdef findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n\\t\\t\\tdic = Counter()\\n\\t\\t\\tfor i in words:\\n\\t\\t\\t\\ttemp = tuple(sorted(set(i)))\\n\\t\\t\\t\\tdic[temp] += 1\\n\\n\\t\\t\\tdef combinations(a):\\n\\t\\t\\t\\tans = []\\n\\t\\t\\t\\tstack = [a[0]]\\n\\t\\t\\t\\tdef rec(i):\\n\\t\\t\\t\\t\\tif i == len(a):\\n\\t\\t\\t\\t\\t\\tans.append(tuple(sorted(stack)))\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tstack.append(a[i])\\n\\t\\t\\t\\t\\trec(i+1)\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t\\trec(i+1)\\n\\t\\t\\t\\trec(1)\\n\\t\\t\\t\\treturn ans\\n\\n\\n\\t\\t\\tanswer = []\\n\\t\\t\\tfor i in puzzles:\\n\\t\\t\\t\\tcomb =  combinations(i)\\n\\t\\t\\t\\ttemp = 0 \\n\\t\\t\\t\\tfor j in comb:\\n\\t\\t\\t\\t\\ttemp += dic[j]\\n\\t\\t\\t\\tanswer.append(temp)\\n\\t\\t\\treturn answer",
                "codeTag": "Java"
            },
            {
                "id": 1570458,
                "title": "golang-trie-solution",
                "content": "```\\nvar ans []int\\ntype trieNode struct {\\n\\tcnt int\\n\\tnext map[byte]*trieNode\\n}\\n\\ntype Trie struct {\\n\\t_tr trieNode\\n}\\n\\nfunc TrieConstructor() Trie {\\n\\treturn Trie{trieNode{0, make(map[byte]*trieNode)}}\\n}\\n\\nfunc (this *Trie) Insert(word string)  {\\n\\tif word == \"\" {return}\\n\\n\\tp := &this._tr\\n\\tfor i := 0; i < len(word); i++ {\\n\\t\\tif p.next[word[i]] == nil {\\n\\t\\t\\tp.next[word[i]] = &trieNode{0, make(map[byte]*trieNode)}\\n\\t\\t}\\n\\n\\t\\tp = p.next[word[i]]\\n\\t}\\n\\n\\tp.cnt ++\\n}\\n\\nfunc (this *Trie) _Search(puzzle map[byte]struct{}, p *trieNode, head bool, idx int, fc byte) {\\n\\tif p.cnt > 0 && head {ans[idx] += p.cnt}\\n\\n\\tfor k, v := range p.next {\\n\\t\\tif _, exist := puzzle[k]; exist {\\n\\t\\t\\tthis._Search(puzzle, v, head || k == fc, idx, fc)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *Trie) Search(puzzle string, idx int) {\\n\\tp := &this._tr\\n\\tm := make(map[byte]struct{})\\n\\tfor i := 0; i < len(puzzle); i++ {m[puzzle[i]] = struct{}{}}\\n\\n\\tthis._Search(m, p, false, idx, puzzle[0])\\n}\\n\\nfunc findNumOfValidWords(words []string, puzzles []string) []int {\\n\\tans = make([]int, len(puzzles))\\n\\n\\ttr := TrieConstructor()\\n\\tfor i := 0; i < len(words); i++ {\\n\\t\\tss := []byte(words[i])\\n\\n\\t\\tsort.Slice(ss, func(i, j int) bool {\\n\\t\\t\\treturn ss[i] < ss[j]\\n\\t\\t})\\n\\n\\t\\tb := make([]byte, 0, len(ss))\\n\\t\\tb = append(b, ss[0])\\n\\t\\tfor j := 1; j < len(ss); j++ {\\n\\t\\t\\tif ss[j] == ss[j - 1] {continue}\\n\\t\\t\\tb = append(b, ss[j])\\n\\t\\t}\\n\\t\\tif len(b) > 7 {continue}\\n\\n\\t\\ttr.Insert(string(b))\\n\\t}\\n\\n\\tfor i := 0; i < len(puzzles); i++ {\\n\\t\\ttr.Search(puzzles[i], i)\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar ans []int\\ntype trieNode struct {\\n\\tcnt int\\n\\tnext map[byte]*trieNode\\n}\\n\\ntype Trie struct {\\n\\t_tr trieNode\\n}\\n\\nfunc TrieConstructor() Trie {\\n\\treturn Trie{trieNode{0, make(map[byte]*trieNode)}}\\n}\\n\\nfunc (this *Trie) Insert(word string)  {\\n\\tif word == \"\" {return}\\n\\n\\tp := &this._tr\\n\\tfor i := 0; i < len(word); i++ {\\n\\t\\tif p.next[word[i]] == nil {\\n\\t\\t\\tp.next[word[i]] = &trieNode{0, make(map[byte]*trieNode)}\\n\\t\\t}\\n\\n\\t\\tp = p.next[word[i]]\\n\\t}\\n\\n\\tp.cnt ++\\n}\\n\\nfunc (this *Trie) _Search(puzzle map[byte]struct{}, p *trieNode, head bool, idx int, fc byte) {\\n\\tif p.cnt > 0 && head {ans[idx] += p.cnt}\\n\\n\\tfor k, v := range p.next {\\n\\t\\tif _, exist := puzzle[k]; exist {\\n\\t\\t\\tthis._Search(puzzle, v, head || k == fc, idx, fc)\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *Trie) Search(puzzle string, idx int) {\\n\\tp := &this._tr\\n\\tm := make(map[byte]struct{})\\n\\tfor i := 0; i < len(puzzle); i++ {m[puzzle[i]] = struct{}{}}\\n\\n\\tthis._Search(m, p, false, idx, puzzle[0])\\n}\\n\\nfunc findNumOfValidWords(words []string, puzzles []string) []int {\\n\\tans = make([]int, len(puzzles))\\n\\n\\ttr := TrieConstructor()\\n\\tfor i := 0; i < len(words); i++ {\\n\\t\\tss := []byte(words[i])\\n\\n\\t\\tsort.Slice(ss, func(i, j int) bool {\\n\\t\\t\\treturn ss[i] < ss[j]\\n\\t\\t})\\n\\n\\t\\tb := make([]byte, 0, len(ss))\\n\\t\\tb = append(b, ss[0])\\n\\t\\tfor j := 1; j < len(ss); j++ {\\n\\t\\t\\tif ss[j] == ss[j - 1] {continue}\\n\\t\\t\\tb = append(b, ss[j])\\n\\t\\t}\\n\\t\\tif len(b) > 7 {continue}\\n\\n\\t\\ttr.Insert(string(b))\\n\\t}\\n\\n\\tfor i := 0; i < len(puzzles); i++ {\\n\\t\\ttr.Search(puzzles[i], i)\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1569935,
                "title": "java-bitmapping",
                "content": "```java\\nprivate static final int N_ABC = 26;\\n    \\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\n\\tlong[] mWords = map(words, false);\\n\\tlong[] mPuzzles = map(puzzles, true);\\n\\n\\tList<Integer> r = new LinkedList<>();\\n\\tfor (long puzzle: mPuzzles) {\\n\\t\\tint k = 0;\\n\\t\\tfor (long word: mWords) {\\n\\t\\t\\tif((puzzle & word) == word &&\\n\\t\\t\\t   ((puzzle >>> N_ABC) & word) == (puzzle >>> N_ABC)) k++;           \\n\\t\\t}\\n\\t\\tr.add(k);\\n\\t}    \\n\\treturn r;\\n}\\n\\nprivate long[] map (String[] a, boolean isFirst) {\\n\\tlong[] mask = new long[a.length];\\n\\tfor (int i = 0; i < a.length; i++) {\\n\\t\\tif(isFirst) mask[i] |= (1L << (a[i].charAt(0) - \\'a\\' + N_ABC));\\n\\t\\tfor (int j = 0; j < a[i].length(); j++) {\\n\\t\\t\\tmask[i] |= (1L << a[i].charAt(j) - \\'a\\');\\n\\t\\t}\\n\\t}\\n\\treturn mask;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nprivate static final int N_ABC = 26;\\n    \\npublic List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n\\n\\tlong[] mWords = map(words, false);\\n\\tlong[] mPuzzles = map(puzzles, true);\\n\\n\\tList<Integer> r = new LinkedList<>();\\n\\tfor (long puzzle: mPuzzles) {\\n\\t\\tint k = 0;\\n\\t\\tfor (long word: mWords) {\\n\\t\\t\\tif((puzzle & word) == word &&\\n\\t\\t\\t   ((puzzle >>> N_ABC) & word) == (puzzle >>> N_ABC)) k++;           \\n\\t\\t}\\n\\t\\tr.add(k);\\n\\t}    \\n\\treturn r;\\n}\\n\\nprivate long[] map (String[] a, boolean isFirst) {\\n\\tlong[] mask = new long[a.length];\\n\\tfor (int i = 0; i < a.length; i++) {\\n\\t\\tif(isFirst) mask[i] |= (1L << (a[i].charAt(0) - \\'a\\' + N_ABC));\\n\\t\\tfor (int j = 0; j < a[i].length(); j++) {\\n\\t\\t\\tmask[i] |= (1L << a[i].charAt(j) - \\'a\\');\\n\\t\\t}\\n\\t}\\n\\treturn mask;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1569637,
                "title": "tle-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalidWord(unordered_map<char,int>& puzzlemap, char firstLetterOfPuzzle, string& word){\\n        int n=word.length();\\n        bool isFirstLetterOfPuzzlePresent=false;\\n        for(int i=0;i<n;i++){\\n            if(firstLetterOfPuzzle==word[i]){\\n                isFirstLetterOfPuzzlePresent=true;\\n            }\\n            if(puzzlemap[word[i]]<=0){\\n                return false;\\n            }\\n        }\\n        return isFirstLetterOfPuzzlePresent;\\n    }\\n    \\n    int compute(string& puzzle, vector<string>& words,int m){\\n        unordered_map<char,int> map;\\n        int n=7;\\n        for(int i=0;i<n;i++){\\n            map[puzzle[i]]++;\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            if(isvalidWord(map,puzzle[0],words[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        int n=puzzles.size();\\n        int m=words.size();\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            res.push_back(compute(puzzles[i],words,m));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalidWord(unordered_map<char,int>& puzzlemap, char firstLetterOfPuzzle, string& word){\\n        int n=word.length();\\n        bool isFirstLetterOfPuzzlePresent=false;\\n        for(int i=0;i<n;i++){\\n            if(firstLetterOfPuzzle==word[i]){\\n                isFirstLetterOfPuzzlePresent=true;\\n            }\\n            if(puzzlemap[word[i]]<=0){\\n                return false;\\n            }\\n        }\\n        return isFirstLetterOfPuzzlePresent;\\n    }\\n    \\n    int compute(string& puzzle, vector<string>& words,int m){\\n        unordered_map<char,int> map;\\n        int n=7;\\n        for(int i=0;i<n;i++){\\n            map[puzzle[i]]++;\\n        }\\n        int count=0;\\n        for(int i=0;i<m;i++){\\n            if(isvalidWord(map,puzzle[0],words[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        int n=puzzles.size();\\n        int m=words.size();\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            res.push_back(compute(puzzles[i],words,m));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569431,
                "title": "easy-understandable-using-o-n-50-m-128",
                "content": "```\\nclass Solution \\n{\\n  \\n   \\n    public static int convertMask(HashSet<Character> set)\\n    {\\n        int mask=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(set.contains((char)(i+97)))\\n            {\\n                mask=mask|(1<<i);\\n            }\\n        }\\n        // System.out.println(mask+\" \"+set);\\n        return mask;\\n    }\\n    \\n    \\n        \\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) \\n    {\\n        long startTime = System.currentTimeMillis();\\n         int n=words.length;\\n        int word[]=new int[n];\\n                      int len[]=new int[n];\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char ch[]=words[i].toCharArray();\\n            int n1=ch.length;\\n            HashSet<Character> set=new HashSet<Character>();\\n            for(int j=0;j<n1;j++)\\n            {\\n                set.add(ch[j]);\\n            }\\n            len[i]=set.size();\\n            int p=convertMask(set);\\n            word[i]=p;\\n            map.put(p,map.getOrDefault(p,0)+1);\\n        }\\n        \\n      int m=puzzles.length;\\n        int ipuz[]=new int[m];\\n        List<Integer> arr=new ArrayList<Integer>();\\n         for(int i=0;i<m;i++)\\n        {\\n            char ch[]=puzzles[i].toCharArray();\\n            int n1=ch.length;\\n            HashSet<Character> set=new HashSet<Character>();\\n            for(int j=0;j<n1;j++)\\n            {\\n                set.add(ch[j]);\\n            }\\n            int mask1=convertMask(set);\\n            int s=mask1;\\n             int t=ch[0]-\\'a\\';\\n             int subm=1<<t;\\n             int sum=0;\\n            while(s>0)\\n            {\\n                if((s&subm)!=0)\\n                {\\n                    if(map.containsKey(s))\\n                    {\\n                        sum+=map.get(s);\\n                    }\\n                }\\n                s=(s-1)&mask1;\\n            }\\n          arr.add(sum);\\n        }\\n       \\n        long endTime = System.currentTimeMillis();\\n        System.out.print(\"time taken:  \"+(endTime-startTime));\\n        return arr;\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\nusing all submatises\\nsuppose u have abd 1011-11\\nother one can be 10&11- 1010 bd \\nother one can be 9&11- 1001 ad\\nother one can be 8&11- 1000 d\\nother one can be 7&11-0011 ab\\nso u put all word mask in the hashmap and count there frequency  and find the resultant value using the puzzle mask\\n\\n```\\n  while(s>0)\\n            {\\n                if((s&subm)!=0)\\n                {\\n                    if(map.containsKey(s))\\n                    {\\n                        sum+=map.get(s);\\n                    }\\n                }\\n                s=(s-1)&mask1;\\n            }\\n        \\n```\\n**PLS UPVOTE MY SOLUTION**",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution \\n{\\n  \\n   \\n    public static int convertMask(HashSet<Character> set)\\n    {\\n        int mask=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(set.contains((char)(i+97)))\\n            {\\n                mask=mask|(1<<i);\\n            }\\n        }\\n        // System.out.println(mask+\" \"+set);\\n        return mask;\\n    }\\n    \\n    \\n        \\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) \\n    {\\n        long startTime = System.currentTimeMillis();\\n         int n=words.length;\\n        int word[]=new int[n];\\n                      int len[]=new int[n];\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            char ch[]=words[i].toCharArray();\\n            int n1=ch.length;\\n            HashSet<Character> set=new HashSet<Character>();\\n            for(int j=0;j<n1;j++)\\n            {\\n                set.add(ch[j]);\\n            }\\n            len[i]=set.size();\\n            int p=convertMask(set);\\n            word[i]=p;\\n            map.put(p,map.getOrDefault(p,0)+1);\\n        }\\n        \\n      int m=puzzles.length;\\n        int ipuz[]=new int[m];\\n        List<Integer> arr=new ArrayList<Integer>();\\n         for(int i=0;i<m;i++)\\n        {\\n            char ch[]=puzzles[i].toCharArray();\\n            int n1=ch.length;\\n            HashSet<Character> set=new HashSet<Character>();\\n            for(int j=0;j<n1;j++)\\n            {\\n                set.add(ch[j]);\\n            }\\n            int mask1=convertMask(set);\\n            int s=mask1;\\n             int t=ch[0]-\\'a\\';\\n             int subm=1<<t;\\n             int sum=0;\\n            while(s>0)\\n            {\\n                if((s&subm)!=0)\\n                {\\n                    if(map.containsKey(s))\\n                    {\\n                        sum+=map.get(s);\\n                    }\\n                }\\n                s=(s-1)&mask1;\\n            }\\n          arr.add(sum);\\n        }\\n       \\n        long endTime = System.currentTimeMillis();\\n        System.out.print(\"time taken:  \"+(endTime-startTime));\\n        return arr;\\n    }\\n}\\n```\n```\\n  while(s>0)\\n            {\\n                if((s&subm)!=0)\\n                {\\n                    if(map.containsKey(s))\\n                    {\\n                        sum+=map.get(s);\\n                    }\\n                }\\n                s=(s-1)&mask1;\\n            }\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569200,
                "title": "python-straightforward-solution-hash-bit-mask-faster-than-98",
                "content": "\\tclass Solution(object):\\n\\t\\tdef findNumOfValidWords(self, words, puzzles):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type words: List[str]\\n\\t\\t\\t:type puzzles: List[str]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdef bit_mask(word):\\n\\t\\t\\t\\tmask = 0\\n\\t\\t\\t\\tfor ch in word: \\n\\t\\t\\t\\t\\tmask |= 1 << (ord(ch) - ord(\\'a\\'))\\n\\t\\t\\t\\treturn mask    \\n\\n\\t\\t\\tfrom collections import defaultdict\\n\\t\\t\\tfreq = defaultdict(int)\\n\\t\\t\\tfor word in words: \\n\\t\\t\\t\\tfreq[bit_mask(word)] += 1\\n\\n\\t\\t\\tres = list()\\n\\t\\t\\tfor puzzle in puzzles:  \\n\\t\\t\\t\\tmask = 0\\n\\t\\t\\t\\tfor ch in puzzle:\\n\\t\\t\\t\\t\\tmask |= 1 << (ord(ch) - ord(\\'a\\'))\\n\\t\\t\\t\\tfirst = ord(puzzle[0]) - ord(\\'a\\')\\n\\t\\t\\t\\ttotal = 0\\n\\t\\t\\t\\tcurr = mask\\n\\n\\t\\t\\t\\twhile curr: \\n\\t\\t\\t\\t\\t# print(curr)        \\n\\t\\t\\t\\t\\tif ((curr >> first) & 1):\\n\\t\\t\\t\\t\\t\\ttotal += freq[curr]\\n\\t\\t\\t\\t\\tcurr = (curr-1) & mask   \\n\\t\\t\\t\\tres.append(total)\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef findNumOfValidWords(self, words, puzzles):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type words: List[str]\\n\\t\\t\\t:type puzzles: List[str]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdef bit_mask(word):\\n\\t\\t\\t\\tmask = 0\\n\\t\\t\\t\\tfor ch in word: \\n\\t\\t\\t\\t\\tmask |= 1 << (ord(ch) - ord(\\'a\\'))\\n\\t\\t\\t\\treturn mask    \\n\\n\\t\\t\\tfrom collections import defaultdict\\n\\t\\t\\tfreq = defaultdict(int)\\n\\t\\t\\tfor word in words: \\n\\t\\t\\t\\tfreq[bit_mask(word)] += 1\\n\\n\\t\\t\\tres = list()\\n\\t\\t\\tfor puzzle in puzzles:  \\n\\t\\t\\t\\tmask = 0\\n\\t\\t\\t\\tfor ch in puzzle:\\n\\t\\t\\t\\t\\tmask |= 1 << (ord(ch) - ord(\\'a\\'))\\n\\t\\t\\t\\tfirst = ord(puzzle[0]) - ord(\\'a\\')\\n\\t\\t\\t\\ttotal = 0\\n\\t\\t\\t\\tcurr = mask\\n\\n\\t\\t\\t\\twhile curr: \\n\\t\\t\\t\\t\\t# print(curr)        \\n\\t\\t\\t\\t\\tif ((curr >> first) & 1):\\n\\t\\t\\t\\t\\t\\ttotal += freq[curr]\\n\\t\\t\\t\\t\\tcurr = (curr-1) & mask   \\n\\t\\t\\t\\tres.append(total)\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 1569161,
                "title": "c-example",
                "content": "```\\n#include <map>\\n\\nclass Solution\\n{\\npublic:\\n    int compute(const string & word)\\n    {\\n        int bit = 0;\\n        \\n        for (int i = 0; i < word.length(); ++i)\\n        {\\n            char c = word[i];\\n            \\n            int tmp = 1;\\n            tmp = tmp << (c - \\'a\\');\\n            \\n            bit |= tmp;\\n        }\\n        \\n        return bit;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string> & words, vector<string> & puzzles)\\n    {\\n        /*\\n        int x = 0000 1000 1000 0000; // word\\n        int y = 0000 1100 1000 0000; // puzzle\\n        \\n        int z = 0000 0100 0000 0000;\\n        \\n        x & y >> ? == 1;\\n        z & x == 0;\\n        \\n        int 4 bytes = 32 bits;\\n        */\\n        \\n        unordered_map<int, int> wbit;\\n        \\n        for (int i = 0; i < words.size(); ++i)\\n        {\\n            wbit[compute(words[i])]++;\\n        }\\n        \\n        vector<int> pbit;\\n        pbit.resize(puzzles.size());\\n        \\n        for (int i = 0; i < puzzles.size(); ++i)\\n        {\\n            pbit[i] = compute(puzzles[i]);\\n        }\\n        \\n        vector<int> result;\\n        result.resize(puzzles.size());\\n        \\n        for (int i = 0; i < result.size(); ++i)\\n        {\\n            int p = pbit[i];\\n            \\n            int m = 1;\\n            m = m << (puzzles[i][0] - \\'a\\');\\n            \\n            /*\\n            for (unordered_map<int, int>::const_iterator ci = wbit.begin();\\n                    ci != wbit.end(); ++ci)\\n            {\\n                int w = ci->first;\\n                \\n                cout << \"---\" << endl;\\n                cout << p << endl;\\n                cout << m << endl;\\n                cout << w << endl;\\n                cout << \"---\" << endl;\\n                cout << (m & w) << endl;\\n                cout << (p ^ w) << endl;\\n                cout << ((p ^ w) & w) << endl;\\n                cout << \"---\" << endl;\\n                cout << ((m & w) > 0 && ((p ^ w) & w) == 0) << endl;\\n                cout << \"---\" << endl;\\n                \\n                if ((m & w) > 0 &&\\n                    ((p ^ w) & w) == 0)\\n                {\\n                    result[i] += ci->second;\\n                }\\n            }\\n            */\\n            \\n            /*\\n            1101 <- p\\n            1100\\n            1011 -> 1001\\n            1000\\n            0111 -> 0101\\n            0100\\n            0011 -> 0001\\n            0000 x\\n            */\\n            for (int sub = p; sub; sub = (sub - 1) & p)\\n            {\\n                if ((sub & m) > 0)\\n                {\\n                    result[i] += wbit[sub];\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <map>\\n\\nclass Solution\\n{\\npublic:\\n    int compute(const string & word)\\n    {\\n        int bit = 0;\\n        \\n        for (int i = 0; i < word.length(); ++i)\\n        {\\n            char c = word[i];\\n            \\n            int tmp = 1;\\n            tmp = tmp << (c - \\'a\\');\\n            \\n            bit |= tmp;\\n        }\\n        \\n        return bit;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string> & words, vector<string> & puzzles)\\n    {\\n        /*\\n        int x = 0000 1000 1000 0000; // word\\n        int y = 0000 1100 1000 0000; // puzzle\\n        \\n        int z = 0000 0100 0000 0000;\\n        \\n        x & y >> ? == 1;\\n        z & x == 0;\\n        \\n        int 4 bytes = 32 bits;\\n        */\\n        \\n        unordered_map<int, int> wbit;\\n        \\n        for (int i = 0; i < words.size(); ++i)\\n        {\\n            wbit[compute(words[i])]++;\\n        }\\n        \\n        vector<int> pbit;\\n        pbit.resize(puzzles.size());\\n        \\n        for (int i = 0; i < puzzles.size(); ++i)\\n        {\\n            pbit[i] = compute(puzzles[i]);\\n        }\\n        \\n        vector<int> result;\\n        result.resize(puzzles.size());\\n        \\n        for (int i = 0; i < result.size(); ++i)\\n        {\\n            int p = pbit[i];\\n            \\n            int m = 1;\\n            m = m << (puzzles[i][0] - \\'a\\');\\n            \\n            /*\\n            for (unordered_map<int, int>::const_iterator ci = wbit.begin();\\n                    ci != wbit.end(); ++ci)\\n            {\\n                int w = ci->first;\\n                \\n                cout << \"---\" << endl;\\n                cout << p << endl;\\n                cout << m << endl;\\n                cout << w << endl;\\n                cout << \"---\" << endl;\\n                cout << (m & w) << endl;\\n                cout << (p ^ w) << endl;\\n                cout << ((p ^ w) & w) << endl;\\n                cout << \"---\" << endl;\\n                cout << ((m & w) > 0 && ((p ^ w) & w) == 0) << endl;\\n                cout << \"---\" << endl;\\n                \\n                if ((m & w) > 0 &&\\n                    ((p ^ w) & w) == 0)\\n                {\\n                    result[i] += ci->second;\\n                }\\n            }\\n            */\\n            \\n            /*\\n            1101 <- p\\n            1100\\n            1011 -> 1001\\n            1000\\n            0111 -> 0101\\n            0100\\n            0011 -> 0001\\n            0000 x\\n            */\\n            for (int sub = p; sub; sub = (sub - 1) & p)\\n            {\\n                if ((sub & m) > 0)\\n                {\\n                    result[i] += wbit[sub];\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1569024,
                "title": "javascript-trie",
                "content": "The algorithm uses Trie class\\n* `Trie()` Initializes the trie object\\n* `void insert(String word)` Inserts the word into the trie\\n\\nSteps\\n* Build the trie. \\nEach word should have at max 7 distinct characters.\\nSort the word before inserting into the trie.\\n* Iterate over the puzzles and count the amount of valid words\\n\\n\\n```\\nvar findNumOfValidWords = function(words, puzzles) {\\n    \\n\\t// build the trie\\n    const wordsTrie = getWordsTrie(words);\\n\\n    const output = [];\\n    const m = puzzles.length;\\n\\t\\n    for (let i = 0; i < m; i++) {\\n\\t\\t// count the amount of valid words\\n        const count = dfs(wordsTrie.root, puzzles[i], false);\\n\\n        output.push(count);\\n    }\\n    \\n    return output;\\n};\\n\\nfunction getWordsTrie(words) {\\n    const MAX_LETTERS = 7;\\n\\t\\n    const wordsTrie = new Trie();\\n    const m = words.length;\\n\\t\\n    for (let i = 0; i < m; i++) {\\n        let count = 0;\\n        const hash = {};\\n        const n = words[i].length;\\n\\n        for (let j = 0; j < n; j++) {\\n            const letter = words[i][j];\\n\\n            if (!hash[letter]) {\\n                hash[letter] = true;\\n                count++;\\n\\n                if (count > MAX_LETTERS) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        wordsTrie.insert(Object.keys(hash).sort());\\n    }\\n\\n    return wordsTrie;\\n}\\n\\nfunction dfs(node, puzzle, hasFirstLetter) {\\n    const n = puzzle.length;\\n    let count = 0;\\n\\n    for (let j = 0; j < n; j++) {\\n        const letter = puzzle[j];\\n\\t\\t\\n        if (!node.children[letter]) {\\n            continue;\\n        }\\n\\n        if (hasFirstLetter ||  (puzzle[0] === letter)) {\\n            count += node.children[letter].numberOfWords;\\n        }\\n\\n        count += dfs(node.children[letter], puzzle, (hasFirstLetter ||  (puzzle[0] === letter)));\\n    }\\n\\n    return count;\\n}\\n\\nvar Trie = function Trie() {\\n    this.root = {\\n        children: {},\\n        numberOfWords: 0\\n    };\\n};\\n\\nTrie.prototype.insert = function(word) {\\n    let node = this.root;\\n    const l = word.length;\\n\\t\\n    for (let i = 0; i < l; i++) {\\n        const letter = word[i];\\n\\n        if (!node.children[letter]) {\\n            node.children[letter] = {\\n                children: {},\\n                numberOfWords: 0\\n            }\\n        }\\n\\n        node = node.children[letter];\\n    }\\n\\n    node.numberOfWords++;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar findNumOfValidWords = function(words, puzzles) {\\n    \\n\\t// build the trie\\n    const wordsTrie = getWordsTrie(words);\\n\\n    const output = [];\\n    const m = puzzles.length;\\n\\t\\n    for (let i = 0; i < m; i++) {\\n\\t\\t// count the amount of valid words\\n        const count = dfs(wordsTrie.root, puzzles[i], false);\\n\\n        output.push(count);\\n    }\\n    \\n    return output;\\n};\\n\\nfunction getWordsTrie(words) {\\n    const MAX_LETTERS = 7;\\n\\t\\n    const wordsTrie = new Trie();\\n    const m = words.length;\\n\\t\\n    for (let i = 0; i < m; i++) {\\n        let count = 0;\\n        const hash = {};\\n        const n = words[i].length;\\n\\n        for (let j = 0; j < n; j++) {\\n            const letter = words[i][j];\\n\\n            if (!hash[letter]) {\\n                hash[letter] = true;\\n                count++;\\n\\n                if (count > MAX_LETTERS) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        wordsTrie.insert(Object.keys(hash).sort());\\n    }\\n\\n    return wordsTrie;\\n}\\n\\nfunction dfs(node, puzzle, hasFirstLetter) {\\n    const n = puzzle.length;\\n    let count = 0;\\n\\n    for (let j = 0; j < n; j++) {\\n        const letter = puzzle[j];\\n\\t\\t\\n        if (!node.children[letter]) {\\n            continue;\\n        }\\n\\n        if (hasFirstLetter ||  (puzzle[0] === letter)) {\\n            count += node.children[letter].numberOfWords;\\n        }\\n\\n        count += dfs(node.children[letter], puzzle, (hasFirstLetter ||  (puzzle[0] === letter)));\\n    }\\n\\n    return count;\\n}\\n\\nvar Trie = function Trie() {\\n    this.root = {\\n        children: {},\\n        numberOfWords: 0\\n    };\\n};\\n\\nTrie.prototype.insert = function(word) {\\n    let node = this.root;\\n    const l = word.length;\\n\\t\\n    for (let i = 0; i < l; i++) {\\n        const letter = word[i];\\n\\n        if (!node.children[letter]) {\\n            node.children[letter] = {\\n                children: {},\\n                numberOfWords: 0\\n            }\\n        }\\n\\n        node = node.children[letter];\\n    }\\n\\n    node.numberOfWords++;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568911,
                "title": "java-easy-solution-hashmap-bit-masking",
                "content": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer> res=new ArrayList<>();\\n        /*\\n        for each puzzle-> \\n        5*10^6 to process words\\n        7 * 10^4 operations to process puzzles\\n        10^11 operations\\n        */\\n        /*\\n        HashMap of character and words containing that character\\n        */\\n        HashMap<Character,ArrayList<Integer>> map=new HashMap<>();\\n        for(int i=0;i<26;i++){\\n            map.put((char)(i+\\'a\\'),new ArrayList<>());\\n        }\\n        \\n        for(String word:words){\\n            int mask=createMask(word);\\n            Set<Character> set=new HashSet<>();\\n            for(char c: word.toCharArray()){\\n                if(!set.contains(c)){\\n                    set.add(c);\\n                    map.get(c).add(mask);\\n                }\\n            }\\n        }\\n        for(String puzzle:puzzles){\\n            int pmask=createMask(puzzle);\\n            int c=0;\\n            for(int wmask:map.get(puzzle.charAt(0))){\\n                if((pmask & wmask ) == wmask) c++;\\n            }\\n            res.add(c);\\n        }\\n        return res;\\n    }\\n    int createMask(String s){\\n        int mask=0;\\n        for(char c: s.toCharArray()){\\n            int bit=c-\\'a\\';\\n            mask=mask | ((1<<bit));\\n        }\\n        return mask;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        List<Integer> res=new ArrayList<>();\\n        /*\\n        for each puzzle-> \\n        5*10^6 to process words\\n        7 * 10^4 operations to process puzzles\\n        10^11 operations\\n        */\\n        /*\\n        HashMap of character and words containing that character\\n        */\\n        HashMap<Character,ArrayList<Integer>> map=new HashMap<>();\\n        for(int i=0;i<26;i++){\\n            map.put((char)(i+\\'a\\'),new ArrayList<>());\\n        }\\n        \\n        for(String word:words){\\n            int mask=createMask(word);\\n            Set<Character> set=new HashSet<>();\\n            for(char c: word.toCharArray()){\\n                if(!set.contains(c)){\\n                    set.add(c);\\n                    map.get(c).add(mask);\\n                }\\n            }\\n        }\\n        for(String puzzle:puzzles){\\n            int pmask=createMask(puzzle);\\n            int c=0;\\n            for(int wmask:map.get(puzzle.charAt(0))){\\n                if((pmask & wmask ) == wmask) c++;\\n            }\\n            res.add(c);\\n        }\\n        return res;\\n    }\\n    int createMask(String s){\\n        int mask=0;\\n        for(char c: s.toCharArray()){\\n            int bit=c-\\'a\\';\\n            mask=mask | ((1<<bit));\\n        }\\n        return mask;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568885,
                "title": "javascript-hashing-bitmask",
                "content": "```javascript\\nconst A_CHAR_CODE = 97;\\n\\n/**\\n * @param {string[]} words\\n * @param {string[]} puzzles\\n * @return {number[]}\\n */\\nvar findNumOfValidWords = function(words, puzzles) {\\n    const wordCount = new Map();\\n    \\n    for (word of words) {\\n        const mask = bitmask(word);\\n        \\n        if (wordCount.has(mask)) {\\n            wordCount.set(mask, wordCount.get(mask) + 1);\\n        } else {\\n            wordCount.set(mask, 1);\\n        }\\n    }\\n    \\n    const result = [];\\n    \\n    for (const puzzle of puzzles) {\\n        const first = 1 << (puzzle.charCodeAt(0) - A_CHAR_CODE);\\n        let count = wordCount.get(first) || 0;\\n        const mask = bitmask(puzzle.substring(1));\\n        let submask = mask;\\n        \\n        while (submask > 0) {\\n            count += wordCount.get(submask | first) || 0;\\n            submask = (submask - 1) & mask;\\n        }\\n        \\n        result.push(count);\\n    }\\n    \\n    return result;\\n};\\n\\nfunction bitmask(word) {\\n    let mask = 0;\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        mask |= (1 << (word.charCodeAt(i) - A_CHAR_CODE));\\n    }\\n    \\n    return mask;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bitmask"
                ],
                "code": "```javascript\\nconst A_CHAR_CODE = 97;\\n\\n/**\\n * @param {string[]} words\\n * @param {string[]} puzzles\\n * @return {number[]}\\n */\\nvar findNumOfValidWords = function(words, puzzles) {\\n    const wordCount = new Map();\\n    \\n    for (word of words) {\\n        const mask = bitmask(word);\\n        \\n        if (wordCount.has(mask)) {\\n            wordCount.set(mask, wordCount.get(mask) + 1);\\n        } else {\\n            wordCount.set(mask, 1);\\n        }\\n    }\\n    \\n    const result = [];\\n    \\n    for (const puzzle of puzzles) {\\n        const first = 1 << (puzzle.charCodeAt(0) - A_CHAR_CODE);\\n        let count = wordCount.get(first) || 0;\\n        const mask = bitmask(puzzle.substring(1));\\n        let submask = mask;\\n        \\n        while (submask > 0) {\\n            count += wordCount.get(submask | first) || 0;\\n            submask = (submask - 1) & mask;\\n        }\\n        \\n        result.push(count);\\n    }\\n    \\n    return result;\\n};\\n\\nfunction bitmask(word) {\\n    let mask = 0;\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        mask |= (1 << (word.charCodeAt(i) - A_CHAR_CODE));\\n    }\\n    \\n    return mask;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568860,
                "title": "haskell-solution",
                "content": "This problem was a lot of fun to solve. Here is my solution in Haskell. Still waiting for Haskell support on this site!\\n\\n```\\n{- | A useful combinator for composing functions of 1 and 2 arguments\\nrespectively. Named after the atop pattern of APL.\\n-}\\natop :: (c -> c\\') -> (a -> b -> c) -> a -> b -> c\\'\\natop f g x y = f $ g x y\\n\\n-- | Whether all elements of a list are also elements of another list.\\nallElem :: (Eq a) => [a] -> [a] -> Bool\\nallElem elems list = and $ map (flip elem list) elems\\n\\n-- | Whether an argument matches all of a list of predicates.\\nmeetsAll :: [a -> Bool] -> a -> Bool\\nmeetsAll = and `atop` sequence\\n\\n-- | Whether a word is valid with respect to a puzzle.\\nisValid :: String  -- ^ puzzle\\n        -> String  -- ^ word\\n        -> Bool\\nisValid \"\"               = const False\\nisValid puzzle@(first:_) = meetsAll\\n  [ elem first\\n  , flip allElem puzzle\\n  ]\\n  \\n-- | How many elements match the predicate?\\ncountMatches :: (a -> Bool) -> [a] -> Int\\ncountMatches = length `atop` filter\\n\\nanswer :: [String]  -- ^ puzzles\\n       -> [String]  -- ^ words\\n       -> [Int]\\nanswer = sequence . map (countMatches . isValid)\\n\\n```",
                "solutionTags": [],
                "code": "```\\n{- | A useful combinator for composing functions of 1 and 2 arguments\\nrespectively. Named after the atop pattern of APL.\\n-}\\natop :: (c -> c\\') -> (a -> b -> c) -> a -> b -> c\\'\\natop f g x y = f $ g x y\\n\\n-- | Whether all elements of a list are also elements of another list.\\nallElem :: (Eq a) => [a] -> [a] -> Bool\\nallElem elems list = and $ map (flip elem list) elems\\n\\n-- | Whether an argument matches all of a list of predicates.\\nmeetsAll :: [a -> Bool] -> a -> Bool\\nmeetsAll = and `atop` sequence\\n\\n-- | Whether a word is valid with respect to a puzzle.\\nisValid :: String  -- ^ puzzle\\n        -> String  -- ^ word\\n        -> Bool\\nisValid \"\"               = const False\\nisValid puzzle@(first:_) = meetsAll\\n  [ elem first\\n  , flip allElem puzzle\\n  ]\\n  \\n-- | How many elements match the predicate?\\ncountMatches :: (a -> Bool) -> [a] -> Int\\ncountMatches = length `atop` filter\\n\\nanswer :: [String]  -- ^ puzzles\\n       -> [String]  -- ^ words\\n       -> [Int]\\nanswer = sequence . map (countMatches . isValid)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568852,
                "title": "swift-using-bitmask",
                "content": "```\\nclass Solution {\\n    func findNumOfValidWords(_ words: [String], _ puzzles: [String]) -> [Int] {\\n        // N is length of the words, L1 is the average length of words\\n        // M is the length of the puzzles, L2 is the average length of puzzles\\n        \\n        // Build the map.\\n        var map = [Int: Int]()\\n        for word in words{ // O(N * L1)\\n            // Transform it into a bitmask of its characters.\\n            let n = word.bitmask\\n            map[n, default: 0] += 1\\n        }\\n        \\n        func countOfValidWords(for puzzle: String) -> Int {            \\n            // Iterate over every possible submask containing the first letter in puzzle (puzzle[i][0]). \\n            // A word is valid for a puzzle if its bitmask matches one of the puzzle\\'s submasks.\\n            let firstBitmask = String(puzzle.first!).bitmask\\n            var submasks = [Int]()\\n            \\n            for submask in map.keys {\\n                if firstBitmask & submask > 0 {\\n                    submasks.append(submask)\\n                }\\n            }\\n            \\n            let mask = String(puzzle.dropFirst()).bitmask\\n            var submask = mask\\n            var count = map[firstBitmask] ?? 0\\n            while submask > 0 {\\n                let key = submask | firstBitmask\\n                count += map[key] ?? 0\\n                submask = (submask - 1) & mask\\n            }\\n            \\n            return count\\n        }\\n        \\n        var res = [Int]()\\n        \\n        // Find all counts of each puzzles\\n        for p in puzzles { // O(M)\\n            let count = countOfValidWords(for: p) // O(L2)\\n            res.append(count)\\n        }\\n        return res\\n    }\\n}\\n\\nextension String {\\n    var bitmask: Int {\\n        return Array(self).reduce(0, { r, ch in\\n            let bit = ch.asciiValue! - Character(\"a\").asciiValue!\\n            return r | (1 << bit)\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    func findNumOfValidWords(_ words: [String], _ puzzles: [String]) -> [Int] {\\n        // N is length of the words, L1 is the average length of words\\n        // M is the length of the puzzles, L2 is the average length of puzzles\\n        \\n        // Build the map.\\n        var map = [Int: Int]()\\n        for word in words{ // O(N * L1)\\n            // Transform it into a bitmask of its characters.\\n            let n = word.bitmask\\n            map[n, default: 0] += 1\\n        }\\n        \\n        func countOfValidWords(for puzzle: String) -> Int {            \\n            // Iterate over every possible submask containing the first letter in puzzle (puzzle[i][0]). \\n            // A word is valid for a puzzle if its bitmask matches one of the puzzle\\'s submasks.\\n            let firstBitmask = String(puzzle.first!).bitmask\\n            var submasks = [Int]()\\n            \\n            for submask in map.keys {\\n                if firstBitmask & submask > 0 {\\n                    submasks.append(submask)\\n                }\\n            }\\n            \\n            let mask = String(puzzle.dropFirst()).bitmask\\n            var submask = mask\\n            var count = map[firstBitmask] ?? 0\\n            while submask > 0 {\\n                let key = submask | firstBitmask\\n                count += map[key] ?? 0\\n                submask = (submask - 1) & mask\\n            }\\n            \\n            return count\\n        }\\n        \\n        var res = [Int]()\\n        \\n        // Find all counts of each puzzles\\n        for p in puzzles { // O(M)\\n            let count = countOfValidWords(for: p) // O(L2)\\n            res.append(count)\\n        }\\n        return res\\n    }\\n}\\n\\nextension String {\\n    var bitmask: Int {\\n        return Array(self).reduce(0, { r, ch in\\n            let bit = ch.asciiValue! - Character(\"a\").asciiValue!\\n            return r | (1 << bit)\\n        })\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568810,
                "title": "c-hashing-modular-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int createBitMask(string &s) {\\n        int mask = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            int bit = s[i]-\\'a\\';\\n            mask = mask | (1<<bit);\\n        }\\n        \\n        return mask;\\n    }\\n    \\n    // vector<int> subsets;\\n    vector<int> result;\\n    unordered_map<int,int> wordsMaskHashMap;\\n    int index = 0;\\n    void createSubsets(int mask, int firstLetterBit, int currentMask, int bit) {\\n        if(bit==26) {\\n            // subsets.push_back(currentMask);\\n            \\n            result[index] += wordsMaskHashMap[currentMask];\\n            \\n            return;\\n        }\\n        \\n        if( (mask&(1<<bit)) == 0) {\\n            createSubsets(mask, firstLetterBit, currentMask, bit+1);\\n        }\\n        else {\\n            int nextMask;\\n            \\n            //set it once\\n            nextMask = currentMask | (1<<bit);\\n            createSubsets(mask, firstLetterBit, nextMask, bit+1);\\n            \\n            //unset it once\\n            if(bit!=firstLetterBit) {\\n                nextMask = currentMask;\\n                createSubsets(mask, firstLetterBit, nextMask, bit+1);\\n            }\\n        }\\n    }\\n    \\n    void printMask(int mask) {\\n        while(mask>0) {\\n            cout<<(mask&1);\\n            mask = mask>>1;\\n        }\\n        cout<<endl;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        int n = puzzles.size();\\n        result = vector<int>(n, 0);\\n        \\n        \\n        for (auto &word : words) {\\n            int mask = createBitMask(word);\\n            wordsMaskHashMap[mask]++;\\n        }\\n        \\n        for (auto &puzzle : puzzles) {\\n            int mask = createBitMask(puzzle);\\n            \\n            int currentMask = 0;\\n            // subsets = vector<int>(); \\n            createSubsets(mask, puzzle[0]-\\'a\\', currentMask, 0);\\n\\n            //no neeed to build and store subsets\\n            // for( auto subset : subsets ) {\\n            //     result[i] += wordsMaskHashMap[subset];\\n                // printMask(mask);\\n            // }\\n            \\n            index++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int createBitMask(string &s) {\\n        int mask = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            int bit = s[i]-\\'a\\';\\n            mask = mask | (1<<bit);\\n        }\\n        \\n        return mask;\\n    }\\n    \\n    // vector<int> subsets;\\n    vector<int> result;\\n    unordered_map<int,int> wordsMaskHashMap;\\n    int index = 0;\\n    void createSubsets(int mask, int firstLetterBit, int currentMask, int bit) {\\n        if(bit==26) {\\n            // subsets.push_back(currentMask);\\n            \\n            result[index] += wordsMaskHashMap[currentMask];\\n            \\n            return;\\n        }\\n        \\n        if( (mask&(1<<bit)) == 0) {\\n            createSubsets(mask, firstLetterBit, currentMask, bit+1);\\n        }\\n        else {\\n            int nextMask;\\n            \\n            //set it once\\n            nextMask = currentMask | (1<<bit);\\n            createSubsets(mask, firstLetterBit, nextMask, bit+1);\\n            \\n            //unset it once\\n            if(bit!=firstLetterBit) {\\n                nextMask = currentMask;\\n                createSubsets(mask, firstLetterBit, nextMask, bit+1);\\n            }\\n        }\\n    }\\n    \\n    void printMask(int mask) {\\n        while(mask>0) {\\n            cout<<(mask&1);\\n            mask = mask>>1;\\n        }\\n        cout<<endl;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        int n = puzzles.size();\\n        result = vector<int>(n, 0);\\n        \\n        \\n        for (auto &word : words) {\\n            int mask = createBitMask(word);\\n            wordsMaskHashMap[mask]++;\\n        }\\n        \\n        for (auto &puzzle : puzzles) {\\n            int mask = createBitMask(puzzle);\\n            \\n            int currentMask = 0;\\n            // subsets = vector<int>(); \\n            createSubsets(mask, puzzle[0]-\\'a\\', currentMask, 0);\\n\\n            //no neeed to build and store subsets\\n            // for( auto subset : subsets ) {\\n            //     result[i] += wordsMaskHashMap[subset];\\n                // printMask(mask);\\n            // }\\n            \\n            index++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1568765,
                "title": "javascript-solution-using-map-and-bit-masking",
                "content": "The idea here is we have created a map with 26 alphabets letters. And we just get the mask value of words  using get mask method.\\nSuppose the word is\\nword=\\'abcfg\\';\\n1100111\\ngfedcba\\nwe will just set the bit of that particular index (from right to left a-z)\\n```\\nfunction getMask(word){\\n    let mask=0;\\n    const charCode=\\'a\\'.charCodeAt(0);\\n    for(let i=0;i<word.length;i++){\\n        mask|=(1 << word.charCodeAt(i)-charCode);\\n    }\\n    return mask;\\n}\\nvar findNumOfValidWords = function(words, puzzles) {\\n    let charMap= new Map();\\n    let answer=[];\\n    const charCode=\\'a\\'.charCodeAt(0);\\n    for(let i=0;i<26;i++){\\n        charMap.set(String.fromCodePoint(charCode+i),new Array());\\n    }\\n    for(const word of words){\\n        let uniqueCharWord=Array.from(new Set(word)).join(\\'\\');\\n        let mask=getMask(uniqueCharWord);\\n        for(let i=0;i<uniqueCharWord.length;i++){\\n            charMap.get(uniqueCharWord[i]).push(mask);\\n        }\\n    }\\n    for(const puzzle of puzzles){\\n        let puzzleMask=getMask(puzzle);\\n        let wordsToCheck=charMap.get(puzzle.charAt(0));\\n        let count=0;\\n        for(const wordMask of wordsToCheck){\\n            let res=(wordMask & puzzleMask);\\n            if((wordMask & puzzleMask) === wordMask)\\n                count++;\\n        }\\n        answer.push(count);\\n    }\\n    return answer;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction getMask(word){\\n    let mask=0;\\n    const charCode=\\'a\\'.charCodeAt(0);\\n    for(let i=0;i<word.length;i++){\\n        mask|=(1 << word.charCodeAt(i)-charCode);\\n    }\\n    return mask;\\n}\\nvar findNumOfValidWords = function(words, puzzles) {\\n    let charMap= new Map();\\n    let answer=[];\\n    const charCode=\\'a\\'.charCodeAt(0);\\n    for(let i=0;i<26;i++){\\n        charMap.set(String.fromCodePoint(charCode+i),new Array());\\n    }\\n    for(const word of words){\\n        let uniqueCharWord=Array.from(new Set(word)).join(\\'\\');\\n        let mask=getMask(uniqueCharWord);\\n        for(let i=0;i<uniqueCharWord.length;i++){\\n            charMap.get(uniqueCharWord[i]).push(mask);\\n        }\\n    }\\n    for(const puzzle of puzzles){\\n        let puzzleMask=getMask(puzzle);\\n        let wordsToCheck=charMap.get(puzzle.charAt(0));\\n        let count=0;\\n        for(const wordMask of wordsToCheck){\\n            let res=(wordMask & puzzleMask);\\n            if((wordMask & puzzleMask) === wordMask)\\n                count++;\\n        }\\n        answer.push(count);\\n    }\\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1568656,
                "title": "c-bitmask",
                "content": "Approach 1: Bitmask [1][2]\\n\\nPreprocessing:\\nCompress each word to a bit map, and compute the frequency of each bit map.\\n**Since there are at most |words| bitmaps while its value ranging from 0 to 2^26, thus it\\u2019s better to use a hashtable instead of an array.**\\n\\nQuery:\\nUse the same way to compress a puzzle into a bit map.\\nTry all subsets (at most 2^7=128) of the puzzle (the bit of the first character is a must), and check how many words match each subset.\\n\\nwords = [\\u201Caaaa\\u201D,\\u201Dasas\\u201D,\\u201Dable\\u201D,\\u201Dability\\u201D,\\u201Dactt\\u201D,\\u201Dactor\\u201D,\\u201Daccess\\u201D],\\npuzzle = \\u201Cabslute\\u201D\\nbitmap(\\u201Caaaa\\u201D) = {0}\\nbitmap(\\u201Casas\\u201D) = {0, 18}\\nbitmap(\\u201Cable\\u201D) = {0,1,4,11}\\nbitmap(\\u201Cactt\\u201D) = {0, 2, 19}\\nbitmap(\\u201Cactor\\u201D) = {0, 2, 14, 17, 19}\\nbitmap(\\u201Caccess\\u201D) = {0, 2, 4, 18}\\n\\nbitmap(\\u201Cabslute\\u201D) = {0, 1, 4, 11, 18, 19, 20}\\n\\nTime complexity: O(sum(len(w_i)) + |puzzles|)\\nSpace complexity: O(|words|)\\n\\nObservation: How \" sub = (sub - 1) & mask\" behaves:\\nPuzzle:[\\'cba\\']\\ncba has following 2^3 = 8 states/sub-mask:\\n111\\n110\\n101\\n100\\n011\\n010\\n001\\n000\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> maskCnt;\\n        for(const auto& w: words){\\n            int mask=0;\\n            for(char c: w) mask |= 1 << (c -\\'a\\');\\n            ++maskCnt[mask];\\n        }\\n        \\n        vector<int> ans;\\n        for(const auto& p: puzzles){\\n            int mask = 0;\\n            for(char c: p) mask |= 1 << (c -\\'a\\');\\n            int subMask = mask, first = 1 << (p[0] -\\'a\\'), cnt = 0;\\n            while(subMask){\\n                //if( (first & subMask == first)  && maskCnt.count(subMask)) cnt += maskCnt[subMask]; // WRONG. \\n                if(   (first & subMask) == first  && maskCnt.count(subMask)) cnt += maskCnt[subMask]; //ok\\n                subMask = (subMask - 1) & mask;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;        \\n    }\\n};\\n```\\nReference:\\n[1] https://www.cnblogs.com/grandyang/p/15096521.html\\n[2] https://zxi.mytechroad.com/blog/hashtable/leetcode-1178-number-of-valid-words-for-each-puzzle/",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        unordered_map<int, int> maskCnt;\\n        for(const auto& w: words){\\n            int mask=0;\\n            for(char c: w) mask |= 1 << (c -\\'a\\');\\n            ++maskCnt[mask];\\n        }\\n        \\n        vector<int> ans;\\n        for(const auto& p: puzzles){\\n            int mask = 0;\\n            for(char c: p) mask |= 1 << (c -\\'a\\');\\n            int subMask = mask, first = 1 << (p[0] -\\'a\\'), cnt = 0;\\n            while(subMask){\\n                //if( (first & subMask == first)  && maskCnt.count(subMask)) cnt += maskCnt[subMask]; // WRONG. \\n                if(   (first & subMask) == first  && maskCnt.count(subMask)) cnt += maskCnt[subMask]; //ok\\n                subMask = (subMask - 1) & mask;\\n            }\\n            ans.push_back(cnt);\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568644,
                "title": "scala-bitmasking",
                "content": "```\\nobject Solution {\\n    val maskWord = (word : String) => word\\n                                        .map(c => 1 << c - \\'a\\')\\n                                        .reduce(_ | _)\\n    \\n    def findNumOfValidWords(words: Array[String], puzzles: Array[String]): List[Int] = {\\n        val wordMask = words\\n                        .map(maskWord)\\n        \\n        val ans = puzzles.map(puzzle => {\\n            val puzzleMask = maskWord(puzzle)\\n            val firstPuzzleCharMask = 1 << (puzzle(0) - \\'a\\')\\n            wordMask\\n            .count(word => {\\n                (word & firstPuzzleCharMask)==firstPuzzleCharMask && \\n                ((puzzleMask & word) == word)\\n            })\\n        })\\n        \\n        ans.toList\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n    val maskWord = (word : String) => word\\n                                        .map(c => 1 << c - \\'a\\')\\n                                        .reduce(_ | _)\\n    \\n    def findNumOfValidWords(words: Array[String], puzzles: Array[String]): List[Int] = {\\n        val wordMask = words\\n                        .map(maskWord)\\n        \\n        val ans = puzzles.map(puzzle => {\\n            val puzzleMask = maskWord(puzzle)\\n            val firstPuzzleCharMask = 1 << (puzzle(0) - \\'a\\')\\n            wordMask\\n            .count(word => {\\n                (word & firstPuzzleCharMask)==firstPuzzleCharMask && \\n                ((puzzleMask & word) == word)\\n            })\\n        })\\n        \\n        ans.toList\\n    }\\n}",
                "codeTag": "Python3"
            },
            {
                "id": 1568602,
                "title": "a-solution-that-times-out-c",
                "content": "I suppose this naive coding isnt salvagable. Still putting it out there if anyone has any suggestions.\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& W, vector<string>& S) {\\n        \\n        vector<int> l(26,-1);\\n        vector<vector<int>>L(S.size(),l);\\n        vector<vector<int>>R(W.size(),l);\\n        bool Is=true, Is2=true;\\n\\n\\n        for(int i=0;i<S.size();i++)\\n        {\\n            for(int j=0;j<S[i].size();j++)\\n            {\\n                L[i][S[i][j]-\\'a\\']=1;\\n            }\\n        }\\n\\n        for(int i=0;i<W.size();i++)\\n        {\\n            for(int j=0;j<W[i].size();j++)\\n            {\\n                R[i][int(W[i][j]-\\'a\\')]=1;\\n            }\\n        }\\n\\n        \\n        vector<int> ret(S.size(),0);\\n        \\n        for(int i=0;i<S.size();i++)\\n        {\\n            for(int j=0;j<W.size();j++)\\n            {\\n                Is=true; Is2=true;\\n                for(int q=0;q<26;q++) if(L[i][q]==-1&&R[j][q]==1) Is=false;\\n                if(R[j][S[i][0]-\\'a\\']!=1) Is2=false;\\n                if(Is&&Is2) ret[i]++;\\n            }\\n        }\\n        \\n        return(ret);\\n        \\n        \\n        \\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& W, vector<string>& S) {\\n        \\n        vector<int> l(26,-1);\\n        vector<vector<int>>L(S.size(),l);\\n        vector<vector<int>>R(W.size(),l);\\n        bool Is=true, Is2=true;\\n\\n\\n        for(int i=0;i<S.size();i++)\\n        {\\n            for(int j=0;j<S[i].size();j++)\\n            {\\n                L[i][S[i][j]-\\'a\\']=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1568600,
                "title": "java-bit-manipulation-hashmap",
                "content": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        Map<Character,ArrayList<Integer>> map = new HashMap<>();\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // Step 1 : Create bucket for all the 26 characters\\n        for(int i = 0;i<26;i++){\\n            map.put((char)(\\'a\\' + i),new ArrayList<>());\\n        }\\n        \\n        // Step 2 : Mask each word and store the bitmask correspondig to all letters that the word has.\\n        for(String word : words){\\n            int mask = 0;\\n            for(char ch : word.toCharArray()){\\n                int bit = ch - \\'a\\';\\n                mask = mask | (1 << bit);\\n            }\\n            Set<Character> set = new HashSet<>();\\n            for(char ch : word.toCharArray()){\\n                if(set.contains(ch))continue;\\n                set.add(ch);\\n                map.get(ch).add(mask);\\n            }\\n        }\\n        \\n        // Step 3 : For each of the puzzle , get the arraylist from map for that puzzle and check if ((bitmask(puzzle) & bitmask(word)) == bitmask(word))\\n        for(String puzzle : puzzles){\\n            int mask = 0;\\n            for(char ch : puzzle.toCharArray()){\\n                int bit = ch - \\'a\\';\\n                mask = mask | (1 << bit);\\n            }\\n            \\n            List<Integer> wordsToCheck = map.get(puzzle.charAt(0));\\n            int count = 0;\\n            for(int temp : wordsToCheck){\\n                if((mask & temp) == temp){\\n                    count++;\\n                }\\n            }\\n            \\n            res.add(count);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findNumOfValidWords(String[] words, String[] puzzles) {\\n        Map<Character,ArrayList<Integer>> map = new HashMap<>();\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // Step 1 : Create bucket for all the 26 characters\\n        for(int i = 0;i<26;i++){\\n            map.put((char)(\\'a\\' + i),new ArrayList<>());\\n        }\\n        \\n        // Step 2 : Mask each word and store the bitmask correspondig to all letters that the word has.\\n        for(String word : words){\\n            int mask = 0;\\n            for(char ch : word.toCharArray()){\\n                int bit = ch - \\'a\\';\\n                mask = mask | (1 << bit);\\n            }\\n            Set<Character> set = new HashSet<>();\\n            for(char ch : word.toCharArray()){\\n                if(set.contains(ch))continue;\\n                set.add(ch);\\n                map.get(ch).add(mask);\\n            }\\n        }\\n        \\n        // Step 3 : For each of the puzzle , get the arraylist from map for that puzzle and check if ((bitmask(puzzle) & bitmask(word)) == bitmask(word))\\n        for(String puzzle : puzzles){\\n            int mask = 0;\\n            for(char ch : puzzle.toCharArray()){\\n                int bit = ch - \\'a\\';\\n                mask = mask | (1 << bit);\\n            }\\n            \\n            List<Integer> wordsToCheck = map.get(puzzle.charAt(0));\\n            int count = 0;\\n            for(int temp : wordsToCheck){\\n                if((mask & temp) == temp){\\n                    count++;\\n                }\\n            }\\n            \\n            res.add(count);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568530,
                "title": "simple-ruby-3-liner-beats-100",
                "content": "```\\ndef find_num_of_valid_words(w, a, h={}, f=->t,a,s=a[0],n=a[1,7]{t ? s ? f[t,n] + f[t[s],n] : t[:x]||0 : 0})\\n  w.each{|w| (w=w.chars.uniq.sort).each{|s, t=(h[s]||={})| w.map{|c| t = t[c] ||= {x:0}}.last[:x]+=1 }}\\n  a.map{|m|f[h[m[0]], m.chars.sort]} end\\n  ```",
                "solutionTags": [],
                "code": "```\\ndef find_num_of_valid_words(w, a, h={}, f=->t,a,s=a[0],n=a[1,7]{t ? s ? f[t,n] + f[t[s],n] : t[:x]||0 : 0})\\n  w.each{|w| (w=w.chars.uniq.sort).each{|s, t=(h[s]||={})| w.map{|c| t = t[c] ||= {x:0}}.last[:x]+=1 }}\\n  a.map{|m|f[h[m[0]], m.chars.sort]} end\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 1568510,
                "title": "c-dictionary-nodes-easy-to-understand",
                "content": "```\\npublic class DictNode {\\n    public Dictionary<char,DictNode> Dict = new Dictionary<char,DictNode>();\\n    public int Count = 0;\\n}\\n\\npublic class Solution {\\n    public IList<int> FindNumOfValidWords(string[] words, string[] puzzles) {\\n        List<int> counts = new List<int>();\\n        \\n        DictNode root = new DictNode();\\n        foreach (string word in words) {\\n            List<char> chs = word.ToCharArray().ToList();\\n            chs.Sort();\\n            char prev = \\'\\\\0\\';\\n            DictNode prevNode = root;\\n            for (int i = 0; i < chs.Count; i++) {\\n                if (chs[i] != prev) {\\n                    prev = chs[i];\\n                    \\n                    if (!prevNode.Dict.ContainsKey(chs[i])) {\\n                        prevNode.Dict.Add(chs[i], new DictNode());\\n                    }\\n                    \\n                    prevNode = prevNode.Dict[chs[i]];\\n                }\\n                \\n                if (i == chs.Count - 1) {\\n                    prevNode.Count++;\\n                }\\n            }\\n        }\\n        \\n        foreach (string puzzle in puzzles) {\\n            counts.Add(DrillDown(root, puzzle, false));\\n        }\\n        \\n        return counts;\\n    }\\n    \\n    private int DrillDown(DictNode node, string puzzle, bool firstCharPresent) {\\n        int total = firstCharPresent ? node.Count : 0;\\n        foreach (KeyValuePair<char, DictNode> kvp in node.Dict) {\\n            if (puzzle.Contains(kvp.Key)) {\\n                if (puzzle[0] == kvp.Key) {\\n                    total += DrillDown(kvp.Value, puzzle, true);\\n                } else {\\n                    total += DrillDown(kvp.Value, puzzle, firstCharPresent);\\n                }\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class DictNode {\\n    public Dictionary<char,DictNode> Dict = new Dictionary<char,DictNode>();\\n    public int Count = 0;\\n}\\n\\npublic class Solution {\\n    public IList<int> FindNumOfValidWords(string[] words, string[] puzzles) {\\n        List<int> counts = new List<int>();\\n        \\n        DictNode root = new DictNode();\\n        foreach (string word in words) {\\n            List<char> chs = word.ToCharArray().ToList();\\n            chs.Sort();\\n            char prev = \\'\\\\0\\';\\n            DictNode prevNode = root;\\n            for (int i = 0; i < chs.Count; i++) {\\n                if (chs[i] != prev) {\\n                    prev = chs[i];\\n                    \\n                    if (!prevNode.Dict.ContainsKey(chs[i])) {\\n                        prevNode.Dict.Add(chs[i], new DictNode());\\n                    }\\n                    \\n                    prevNode = prevNode.Dict[chs[i]];\\n                }\\n                \\n                if (i == chs.Count - 1) {\\n                    prevNode.Count++;\\n                }\\n            }\\n        }\\n        \\n        foreach (string puzzle in puzzles) {\\n            counts.Add(DrillDown(root, puzzle, false));\\n        }\\n        \\n        return counts;\\n    }\\n    \\n    private int DrillDown(DictNode node, string puzzle, bool firstCharPresent) {\\n        int total = firstCharPresent ? node.Count : 0;\\n        foreach (KeyValuePair<char, DictNode> kvp in node.Dict) {\\n            if (puzzle.Contains(kvp.Key)) {\\n                if (puzzle[0] == kvp.Key) {\\n                    total += DrillDown(kvp.Value, puzzle, true);\\n                } else {\\n                    total += DrillDown(kvp.Value, puzzle, firstCharPresent);\\n                }\\n            }\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568506,
                "title": "c-bit-manipulation",
                "content": "class Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        unordered_map<char,vector<int>>mp;\\n        \\n        for(string word:words){\\n            \\n            int mask=0;\\n            \\n            for(char ch:word){\\n                \\n                int bit=ch-\\'a\\';\\n                mask=mask|(1<<bit);\\n                \\n            }\\n            \\n            set<char>st;\\n            \\n            for(char ch:word){\\n                \\n                if(st.find(ch)!=st.end()){\\n                    continue;\\n                }\\n                \\n                st.insert(ch);\\n                mp[ch].push_back(mask);\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        vector<int>result;\\n        \\n        for(string puzzle:puzzles){\\n            \\n            int pmask=0;\\n            \\n            for(char ch:puzzle){\\n                \\n                int bit=ch-\\'a\\';\\n                pmask=pmask|(1<<bit);\\n                \\n            }\\n            \\n            char fch=puzzle[0];\\n            \\n            vector<int>vec=mp[fch];\\n            \\n            int count=0;\\n            \\n            for(int i=0;i<vec.size();i++){\\n                \\n                if( ( vec[i] & pmask ) == vec[i]){\\n                    count++;\\n                }\\n                \\n            }\\n            \\n            result.push_back(count);\\n            \\n        }\\n        \\n        return result;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        unordered_map<char,vector<int>>mp;\\n        \\n        for(string word:words){\\n            \\n            int mask=0;\\n            \\n            for(char ch:word){\\n                \\n                int bit=ch-\\'a\\';\\n                mask=mask|(1<<bit);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1568501,
                "title": "using-string-encoding",
                "content": "class Solution {\\npublic:\\n    // Encoding all the puzzles and checking\\n        //   00000000000000001111000000 -> Puzzle \\n        // 1 00000000110000000011000000 -> incorrect \\n        // 2 00000000000000001001000000 -> correct\\n        // 3 00000000000000000000001100 -> incorrect -> a&b works \\n        \\n        // Two conditions -> first one is puzzle is superset of words, second is first char must be there. \\n    \\n        /* \\n        Solution: \\n            1. encoding all the 7 letter puzzle string into binary string -> \"1100000000000000000\" for ab \\n            2. storing each encoded string with a first letter -> in a pair \\n                vector<pair<char, string>> encode for the puzzle \\n            3. encode the words also \\n            4. if(word[encode[i].first - \\'a\\'] == 0) return false\\n            5. else fill all puzzle ones in the word \\n            6. if puzzle == word -> count[i]++\\n        */\\n    string Encode(string s){\\n        string ans = \"\";\\n        for(int i =0; i<26; i++)\\n            ans += \"0\";\\n        \\n        for(int i = 0; i<s.length(); i++){\\n            ans[s[i] - \\'a\\'] = \\'1\\';\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n\\n        vector<pair<char, string>> encodeP;\\n        vector<string> encodeW;\\n        vector<int> ans(puzzles.size(), 0);\\n        \\n        int i = 0;\\n        \\n        // Make Encoding \\n        while(i < puzzles.size() || i < words.size()){\\n            if(i < puzzles.size())\\n                encodeP.push_back(make_pair(puzzles[i][0], Encode(puzzles[i])));\\n            if(i < words.size())\\n                encodeW.push_back(Encode(words[i]));\\n            i++;\\n        }\\n        \\n        for(int j = 0; j<puzzles.size(); j++){\\n            int count = 0;\\n            string tempP = encodeP[j].second;\\n            char f = encodeP[j].first;\\n            vector<int> chars(7, 0);\\n            \\n            for(int ii = 0; ii<7; ii++){\\n                chars[ii] = puzzles[j][ii] - \\'a\\';\\n            }\\n            \\n            for(int k = 0; k < words.size(); k++){\\n                string tempW = encodeW[k];\\n                if(tempW[f - \\'a\\'] == \\'0\\')\\n                    continue;\\n                for(int jj = 0; jj<7; jj++){\\n                    tempW[chars[jj]] = \\'1\\';\\n                }\\n                if(tempW == tempP)\\n                    count++;\\n            }\\n            \\n            ans[j] = count;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // Encoding all the puzzles and checking\\n        //   00000000000000001111000000 -> Puzzle \\n        // 1 00000000110000000011000000 -> incorrect \\n        // 2 00000000000000001001000000 -> correct\\n        // 3 00000000000000000000001100 -> incorrect -> a&b works \\n        \\n        // Two conditions -> first one is puzzle is superset of words, second is first char must be there. \\n    \\n        /* \\n        Solution: \\n            1. encoding all the 7 letter puzzle string into binary string -> \"1100000000000000000\" for ab \\n            2. storing each encoded string with a first letter -> in a pair \\n                vector<pair<char, string>> encode for the puzzle \\n            3. encode the words also \\n            4. if(word[encode[i].first - \\'a\\'] == 0) return false\\n            5. else fill all puzzle ones in the word \\n            6. if puzzle == word -> count[i]++\\n        */\\n    string Encode(string s){\\n        string ans = \"\";\\n        for(int i =0; i<26; i++)\\n            ans += \"0\";\\n        \\n        for(int i = 0; i<s.length(); i++){\\n            ans[s[i] - \\'a\\'] = \\'1\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1568490,
                "title": "using-string-encoding",
                "content": "class Solution {\\npublic:\\n    // Encoding all the puzzles and checking\\n        //   00000000000000001111000000 -> Puzzle \\n        // 1 00000000110000000011000000 -> incorrect \\n        // 2 00000000000000001001000000 -> correct\\n        // 3 00000000000000000000001100 -> incorrect -> a&b works \\n        \\n        // Two conditions -> first one is puzzle is superset of words, second is first char must be there. \\n    \\n        /* \\n        Solution: \\n            1. encoding all the 7 letter puzzle string into binary string -> \"1100000000000000000\" for ab \\n            2. storing each encoded string with a first letter -> in a pair \\n                vector<pair<char, string>> encode for the puzzle \\n            3. encode the words also \\n            4. if(word[encode[i].first - \\'a\\'] == 0) return false\\n            5. else fill all puzzle ones in the word \\n            6. if puzzle == word -> count[i]++\\n        */\\n    string Encode(string s){\\n        string ans = \"\";\\n        for(int i =0; i<26; i++)\\n            ans += \"0\";\\n        \\n        for(int i = 0; i<s.length(); i++){\\n            ans[s[i] - \\'a\\'] = \\'1\\';\\n        }\\n        return ans;\\n    }\\n    \\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n\\n        vector<pair<char, string>> encodeP;\\n        vector<string> encodeW;\\n        vector<int> ans(puzzles.size(), 0);\\n        \\n        int i = 0;\\n        \\n        // Make Encoding \\n        while(i < puzzles.size() || i < words.size()){\\n            if(i < puzzles.size())\\n                encodeP.push_back(make_pair(puzzles[i][0], Encode(puzzles[i])));\\n            if(i < words.size())\\n                encodeW.push_back(Encode(words[i]));\\n            i++;\\n        }\\n        \\n        for(int j = 0; j<puzzles.size(); j++){\\n            int count = 0;\\n            string tempP = encodeP[j].second;\\n            char f = encodeP[j].first;\\n            vector<int> chars(7, 0);\\n            \\n            for(int ii = 0; ii<7; ii++){\\n                chars[ii] = puzzles[j][ii] - \\'a\\';\\n            }\\n            \\n            for(int k = 0; k < words.size(); k++){\\n                string tempW = encodeW[k];\\n                if(tempW[f - \\'a\\'] == \\'0\\')\\n                    continue;\\n                for(int jj = 0; jj<7; jj++){\\n                    tempW[chars[jj]] = \\'1\\';\\n                }\\n                if(tempW == tempP)\\n                    count++;\\n            }\\n            \\n            ans[j] = count;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    // Encoding all the puzzles and checking\\n        //   00000000000000001111000000 -> Puzzle \\n        // 1 00000000110000000011000000 -> incorrect \\n        // 2 00000000000000001001000000 -> correct\\n        // 3 00000000000000000000001100 -> incorrect -> a&b works \\n        \\n        // Two conditions -> first one is puzzle is superset of words, second is first char must be there. \\n    \\n        /* \\n        Solution: \\n            1. encoding all the 7 letter puzzle string into binary string -> \"1100000000000000000\" for ab \\n            2. storing each encoded string with a first letter -> in a pair \\n                vector<pair<char, string>> encode for the puzzle \\n            3. encode the words also \\n            4. if(word[encode[i].first - \\'a\\'] == 0) return false\\n            5. else fill all puzzle ones in the word \\n            6. if puzzle == word -> count[i]++\\n        */\\n    string Encode(string s){\\n        string ans = \"\";\\n        for(int i =0; i<26; i++)\\n            ans += \"0\";\\n        \\n        for(int i = 0; i<s.length(); i++){\\n            ans[s[i] - \\'a\\'] = \\'1\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1568401,
                "title": "python-98-faster-result-sing-frozen-set",
                "content": "\\'\\'\\'\\nPYTHON\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        m=collections.Counter(frozenset(w) for w in words)\\n        res=[]\\n        for p in puzzles:\\n            x=0\\n            st=[p[0]]\\n            for c in p[1:]:\\n                st+=[s+c for s in st]\\n            res.append(sum(m[frozenset(w)] for w in st))\\n        return res\\n\\'\\'\\'\\nPython",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "\\'\\'\\'\\nPYTHON\\nclass Solution:\\n    def findNumOfValidWords(self, words: List[str], puzzles: List[str]) -> List[int]:\\n        m=collections.Counter(frozenset(w) for w in words)\\n        res=[]\\n        for p in puzzles:\\n            x=0\\n            st=[p[0]]\\n            for c in p[1:]:\\n                st+=[s+c for s in st]\\n            res.append(sum(m[frozenset(w)] for w in st))\\n        return res\\n\\'\\'\\'\\nPython",
                "codeTag": "Java"
            },
            {
                "id": 1568382,
                "title": "c-solution-faster-than-100-less-memory-than-100",
                "content": "Took me a while to get this one right...\\n```\\ntypedef struct Node Node;\\n\\nstruct Node {\\n    unsigned int mask;\\n    int count;\\n    Node * left, * right;\\n};\\n\\nstatic Node *\\ninsert_node(Node * node, unsigned int mask)\\n{\\n    if (!node)\\n    {\\n        Node * new_node = malloc(sizeof(Node));\\n        new_node->mask = mask;\\n        new_node->count = 1;\\n        new_node->left = NULL;\\n        new_node->right = NULL;\\n        return new_node;\\n    }\\n    \\n    if (mask > node->mask)\\n        node->right = insert_node(node->right, mask);\\n    else if (mask < node->mask)\\n        node->left = insert_node(node->left, mask);\\n    else\\n        ++(node->count);\\n    \\n    return node;\\n}\\n\\nstatic Node *\\nsearch(Node * node, unsigned int mask)\\n{\\n    if (!node)\\n        return NULL;\\n    \\n    if (mask > node->mask)\\n        return search(node->right, mask);\\n    else if (mask < node->mask)\\n        return search(node->left, mask);\\n    else\\n        return node;\\n}\\n\\nstatic void\\ndelete_tree(Node * node)\\n{\\n    if (!node)\\n        return;\\n    \\n    delete_tree(node->left);\\n    delete_tree(node->right);\\n    free(node);\\n}\\n\\nint * \\nfindNumOfValidWords(char ** words, int wordsSize, char ** puzzles, int puzzlesSize, int * returnSize)\\n{\\n    int i, j, count, * result;\\n    unsigned int bit, mask, sub_mask;\\n    Node * word_tree = NULL;\\n    \\n    result = malloc(puzzlesSize * sizeof(int));\\n    \\n    for (i = 0; i < wordsSize; ++i)\\n    {\\n        mask = 0;\\n        count = 0;\\n        \\n        for (j = 0; j < strlen(words[i]); ++j)\\n        {\\n            bit = 1U << (unsigned)(words[i][j] - 97);\\n            \\n            if (bit & mask)\\n                continue;\\n            \\n            ++count;\\n            \\n            if (count > 7)\\n                break;\\n            \\n            mask |= bit;\\n        }\\n        \\n        if (count <= 7)\\n            word_tree = insert_node(word_tree, mask);\\n    }\\n    \\n    for (i = 0; i < puzzlesSize; ++i)\\n    {\\n        count = 0;\\n        bit = 1U << (unsigned)(puzzles[i][0] - 97);\\n        \\n        Node * word_node = search(word_tree, bit);\\n        \\n        if (word_node)\\n            count = word_node->count;\\n        \\n        mask = 0;\\n        \\n        for (j = 1; j < 7; ++j)\\n            mask |= 1U << (unsigned)(puzzles[i][j] - 97);\\n        \\n        for (sub_mask = mask; sub_mask; sub_mask = (sub_mask - 1) & mask)\\n        {\\n            word_node = search(word_tree, sub_mask | bit);\\n            if (word_node)\\n                count += word_node->count;\\n        }\\n        \\n        result[i] = count;\\n    }\\n    \\n    delete_tree(word_tree);\\n    *returnSize = puzzlesSize;\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct Node Node;\\n\\nstruct Node {\\n    unsigned int mask;\\n    int count;\\n    Node * left, * right;\\n};\\n\\nstatic Node *\\ninsert_node(Node * node, unsigned int mask)\\n{\\n    if (!node)\\n    {\\n        Node * new_node = malloc(sizeof(Node));\\n        new_node->mask = mask;\\n        new_node->count = 1;\\n        new_node->left = NULL;\\n        new_node->right = NULL;\\n        return new_node;\\n    }\\n    \\n    if (mask > node->mask)\\n        node->right = insert_node(node->right, mask);\\n    else if (mask < node->mask)\\n        node->left = insert_node(node->left, mask);\\n    else\\n        ++(node->count);\\n    \\n    return node;\\n}\\n\\nstatic Node *\\nsearch(Node * node, unsigned int mask)\\n{\\n    if (!node)\\n        return NULL;\\n    \\n    if (mask > node->mask)\\n        return search(node->right, mask);\\n    else if (mask < node->mask)\\n        return search(node->left, mask);\\n    else\\n        return node;\\n}\\n\\nstatic void\\ndelete_tree(Node * node)\\n{\\n    if (!node)\\n        return;\\n    \\n    delete_tree(node->left);\\n    delete_tree(node->right);\\n    free(node);\\n}\\n\\nint * \\nfindNumOfValidWords(char ** words, int wordsSize, char ** puzzles, int puzzlesSize, int * returnSize)\\n{\\n    int i, j, count, * result;\\n    unsigned int bit, mask, sub_mask;\\n    Node * word_tree = NULL;\\n    \\n    result = malloc(puzzlesSize * sizeof(int));\\n    \\n    for (i = 0; i < wordsSize; ++i)\\n    {\\n        mask = 0;\\n        count = 0;\\n        \\n        for (j = 0; j < strlen(words[i]); ++j)\\n        {\\n            bit = 1U << (unsigned)(words[i][j] - 97);\\n            \\n            if (bit & mask)\\n                continue;\\n            \\n            ++count;\\n            \\n            if (count > 7)\\n                break;\\n            \\n            mask |= bit;\\n        }\\n        \\n        if (count <= 7)\\n            word_tree = insert_node(word_tree, mask);\\n    }\\n    \\n    for (i = 0; i < puzzlesSize; ++i)\\n    {\\n        count = 0;\\n        bit = 1U << (unsigned)(puzzles[i][0] - 97);\\n        \\n        Node * word_node = search(word_tree, bit);\\n        \\n        if (word_node)\\n            count = word_node->count;\\n        \\n        mask = 0;\\n        \\n        for (j = 1; j < 7; ++j)\\n            mask |= 1U << (unsigned)(puzzles[i][j] - 97);\\n        \\n        for (sub_mask = mask; sub_mask; sub_mask = (sub_mask - 1) & mask)\\n        {\\n            word_node = search(word_tree, sub_mask | bit);\\n            if (word_node)\\n                count += word_node->count;\\n        }\\n        \\n        result[i] = count;\\n    }\\n    \\n    delete_tree(word_tree);\\n    *returnSize = puzzlesSize;\\n    return result;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1568380,
                "title": "hashing-bitmask-c",
                "content": "```\\n int cal(string word){\\n        \\n        int mask=0;\\n        \\n        for(auto x: word){\\n            mask|=(1<<(x -\\'a\\'));\\n        }\\n        \\n        return mask;\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        map<int,int> mp;\\n        vector<int> ans;\\n        for(auto x: words){\\n            mp[cal(x)]++;\\n        }\\n        \\n       for(auto x: puzzles){\\n           \\n           int mask=cal(x);\\n           int submask=mask;\\n           int an=0;\\n           int first=(1<<(x[0]-\\'a\\'));\\n           \\n           while(submask){\\n               \\n               if(submask&first){\\n                   an+=mp[submask];\\n               }\\n               submask=(submask - 1)&mask;\\n           }\\n           ans.push_back(an);\\n       }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n int cal(string word){\\n        \\n        int mask=0;\\n        \\n        for(auto x: word){\\n            mask|=(1<<(x -\\'a\\'));\\n        }\\n        \\n        return mask;\\n    }\\n    vector<int> findNumOfValidWords(vector<string>& words, vector<string>& puzzles) {\\n        \\n        map<int,int> mp;\\n        vector<int> ans;\\n        for(auto x: words){\\n            mp[cal(x)]++;\\n        }\\n        \\n       for(auto x: puzzles){\\n           \\n           int mask=cal(x);\\n           int submask=mask;\\n           int an=0;\\n           int first=(1<<(x[0]-\\'a\\'));\\n           \\n           while(submask){\\n               \\n               if(submask&first){\\n                   an+=mp[submask];\\n               }\\n               submask=(submask - 1)&mask;\\n           }\\n           ans.push_back(an);\\n       }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565178,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashing (Bitmask)\n\n  \n**Approach 2:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "11th Testcase is not passing, it is giving me tle."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE what the heck\\n```\\nvector<int> findNumOfValidWords(vector<string> &words, vector<string> &puzzles)\\n{\\n    vector<int> res;\\n    unordered_map<string, int> bitmask_words;\\n    unordered_map<string, int> bitmask_puzzles;\\n\\n    unordered_map<char, unordered_set<string>> mp;\\n\\n    for (int i = 0; i < puzzles.size(); i++)\\n    {\\n        int mask = 0;\\n        for (int j = 0; j < puzzles[i].size(); j++)\\n        {\\n            int idx = puzzles[i][j] - \\'a\\';\\n            int mask2 = 1 << idx;\\n            mask |= mask2;\\n        }\\n        bitmask_puzzles[puzzles[i]] = mask;\\n    }\\n\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        int mask = 0;\\n        for (int j = 0; j < words[i].size(); j++)\\n        {\\n            if (!mp[words[i][j]].count(words[i]))\\n                mp[words[i][j]].insert(words[i]);\\n            int idx = words[i][j] - \\'a\\';\\n            int mask2 = 1 << idx;\\n            mask |= mask2;\\n        }\\n        bitmask_words[words[i]] = mask;\\n    }\\n\\n    for (int i = 0; i < puzzles.size(); i++)\\n    {\\n        int cnt = 0, pmask = bitmask_puzzles[puzzles[i]];\\n        char ch = puzzles[i][0];\\n        for (auto it1 : mp[ch])\\n        {\\n            int wmask = bitmask_words[it1];\\n            if ((wmask & pmask) == wmask)\\n                cnt++;\\n        }\\n        res.push_back(cnt);\\n    }\\n    return res;\\n}"
                    }
                ]
            },
            {
                "id": 1843202,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashing (Bitmask)\n\n  \n**Approach 2:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "11th Testcase is not passing, it is giving me tle."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE what the heck\\n```\\nvector<int> findNumOfValidWords(vector<string> &words, vector<string> &puzzles)\\n{\\n    vector<int> res;\\n    unordered_map<string, int> bitmask_words;\\n    unordered_map<string, int> bitmask_puzzles;\\n\\n    unordered_map<char, unordered_set<string>> mp;\\n\\n    for (int i = 0; i < puzzles.size(); i++)\\n    {\\n        int mask = 0;\\n        for (int j = 0; j < puzzles[i].size(); j++)\\n        {\\n            int idx = puzzles[i][j] - \\'a\\';\\n            int mask2 = 1 << idx;\\n            mask |= mask2;\\n        }\\n        bitmask_puzzles[puzzles[i]] = mask;\\n    }\\n\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        int mask = 0;\\n        for (int j = 0; j < words[i].size(); j++)\\n        {\\n            if (!mp[words[i][j]].count(words[i]))\\n                mp[words[i][j]].insert(words[i]);\\n            int idx = words[i][j] - \\'a\\';\\n            int mask2 = 1 << idx;\\n            mask |= mask2;\\n        }\\n        bitmask_words[words[i]] = mask;\\n    }\\n\\n    for (int i = 0; i < puzzles.size(); i++)\\n    {\\n        int cnt = 0, pmask = bitmask_puzzles[puzzles[i]];\\n        char ch = puzzles[i][0];\\n        for (auto it1 : mp[ch])\\n        {\\n            int wmask = bitmask_words[it1];\\n            if ((wmask & pmask) == wmask)\\n                cnt++;\\n        }\\n        res.push_back(cnt);\\n    }\\n    return res;\\n}"
                    }
                ]
            },
            {
                "id": 1805442,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hashing (Bitmask)\n\n  \n**Approach 2:** Trie\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "11th Testcase is not passing, it is giving me tle."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE what the heck\\n```\\nvector<int> findNumOfValidWords(vector<string> &words, vector<string> &puzzles)\\n{\\n    vector<int> res;\\n    unordered_map<string, int> bitmask_words;\\n    unordered_map<string, int> bitmask_puzzles;\\n\\n    unordered_map<char, unordered_set<string>> mp;\\n\\n    for (int i = 0; i < puzzles.size(); i++)\\n    {\\n        int mask = 0;\\n        for (int j = 0; j < puzzles[i].size(); j++)\\n        {\\n            int idx = puzzles[i][j] - \\'a\\';\\n            int mask2 = 1 << idx;\\n            mask |= mask2;\\n        }\\n        bitmask_puzzles[puzzles[i]] = mask;\\n    }\\n\\n    for (int i = 0; i < words.size(); i++)\\n    {\\n        int mask = 0;\\n        for (int j = 0; j < words[i].size(); j++)\\n        {\\n            if (!mp[words[i][j]].count(words[i]))\\n                mp[words[i][j]].insert(words[i]);\\n            int idx = words[i][j] - \\'a\\';\\n            int mask2 = 1 << idx;\\n            mask |= mask2;\\n        }\\n        bitmask_words[words[i]] = mask;\\n    }\\n\\n    for (int i = 0; i < puzzles.size(); i++)\\n    {\\n        int cnt = 0, pmask = bitmask_puzzles[puzzles[i]];\\n        char ch = puzzles[i][0];\\n        for (auto it1 : mp[ch])\\n        {\\n            int wmask = bitmask_words[it1];\\n            if ((wmask & pmask) == wmask)\\n                cnt++;\\n        }\\n        res.push_back(cnt);\\n    }\\n    return res;\\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reformat Department Table",
        "question_content": "<p>Table: <code>Department</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| revenue     | int     |\n| month       | varchar |\n+-------------+---------+\nIn SQL,(id, month) is the primary key of this table.\nThe table has information about the revenue of each department per month.\nThe month has values in [&quot;Jan&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;].\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Reformat the table such that there is a department id column and a revenue column <strong>for each month</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nDepartment table:\n+------+---------+-------+\n| id   | revenue | month |\n+------+---------+-------+\n| 1    | 8000    | Jan   |\n| 2    | 9000    | Jan   |\n| 3    | 10000   | Feb   |\n| 1    | 7000    | Feb   |\n| 1    | 6000    | Mar   |\n+------+---------+-------+\n<strong>Output:</strong> \n+------+-------------+-------------+-------------+-----+-------------+\n| id   | Jan_Revenue | Feb_Revenue | Mar_Revenue | ... | Dec_Revenue |\n+------+-------------+-------------+-------------+-----+-------------+\n| 1    | 8000        | 7000        | 6000        | ... | null        |\n| 2    | 9000        | null        | null        | ... | null        |\n| 3    | null        | 10000       | null        | ... | null        |\n+------+-------------+-------------+-------------+-----+-------------+\n<strong>Explanation:</strong> The revenue from Apr to Dec is null.\nNote that the result table has 13 columns (1 for the department id + 12 for the months).\n</pre>\n",
        "solutions": [
            {
                "id": 376357,
                "title": "mysql-postgresql-solutions",
                "content": "```\\nselect id, \\n\\tsum(case when month = \\'jan\\' then revenue else null end) as Jan_Revenue,\\n\\tsum(case when month = \\'feb\\' then revenue else null end) as Feb_Revenue,\\n\\tsum(case when month = \\'mar\\' then revenue else null end) as Mar_Revenue,\\n\\tsum(case when month = \\'apr\\' then revenue else null end) as Apr_Revenue,\\n\\tsum(case when month = \\'may\\' then revenue else null end) as May_Revenue,\\n\\tsum(case when month = \\'jun\\' then revenue else null end) as Jun_Revenue,\\n\\tsum(case when month = \\'jul\\' then revenue else null end) as Jul_Revenue,\\n\\tsum(case when month = \\'aug\\' then revenue else null end) as Aug_Revenue,\\n\\tsum(case when month = \\'sep\\' then revenue else null end) as Sep_Revenue,\\n\\tsum(case when month = \\'oct\\' then revenue else null end) as Oct_Revenue,\\n\\tsum(case when month = \\'nov\\' then revenue else null end) as Nov_Revenue,\\n\\tsum(case when month = \\'dec\\' then revenue else null end) as Dec_Revenue\\nfrom department\\ngroup by id\\norder by id\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, \\n\\tsum(case when month = \\'jan\\' then revenue else null end) as Jan_Revenue,\\n\\tsum(case when month = \\'feb\\' then revenue else null end) as Feb_Revenue,\\n\\tsum(case when month = \\'mar\\' then revenue else null end) as Mar_Revenue,\\n\\tsum(case when month = \\'apr\\' then revenue else null end) as Apr_Revenue,\\n\\tsum(case when month = \\'may\\' then revenue else null end) as May_Revenue,\\n\\tsum(case when month = \\'jun\\' then revenue else null end) as Jun_Revenue,\\n\\tsum(case when month = \\'jul\\' then revenue else null end) as Jul_Revenue,\\n\\tsum(case when month = \\'aug\\' then revenue else null end) as Aug_Revenue,\\n\\tsum(case when month = \\'sep\\' then revenue else null end) as Sep_Revenue,\\n\\tsum(case when month = \\'oct\\' then revenue else null end) as Oct_Revenue,\\n\\tsum(case when month = \\'nov\\' then revenue else null end) as Nov_Revenue,\\n\\tsum(case when month = \\'dec\\' then revenue else null end) as Dec_Revenue\\nfrom department\\ngroup by id\\norder by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382960,
                "title": "mssql-multiple-joins-groupby-and-pivot-table-solutions",
                "content": "**Multiple left joins**\\n```\\n;WITH ids AS \\n(\\n    SELECT DISTINCT id FROM Department\\n)\\nSELECT \\n    ids.id, \\n    d_jan.revenue AS Jan_Revenue,\\n    d_feb.revenue AS Feb_Revenue,\\n    d_mar.revenue AS Mar_Revenue,\\n    d_apr.revenue AS Apr_Revenue,\\n    d_may.revenue AS May_Revenue,\\n    d_jun.revenue AS Jun_Revenue,\\n    d_jul.revenue AS Jul_Revenue,\\n    d_aug.revenue AS Aug_Revenue,\\n    d_sep.revenue AS Sep_Revenue,\\n    d_oct.revenue AS Oct_Revenue,\\n    d_nov.revenue AS Nov_Revenue,\\n    d_dec.revenue AS Dec_Revenue\\nFROM ids\\nLEFT JOIN Department d_jan ON d_jan.id = ids.id AND d_jan.month = \\'Jan\\'\\nLEFT JOIN Department d_feb ON d_feb.id = ids.id AND d_feb.month = \\'Feb\\'\\nLEFT JOIN Department d_mar ON d_mar.id = ids.id AND d_mar.month = \\'Mar\\'\\nLEFT JOIN Department d_apr ON d_apr.id = ids.id AND d_apr.month = \\'Apr\\'\\nLEFT JOIN Department d_may ON d_may.id = ids.id AND d_may.month = \\'May\\'\\nLEFT JOIN Department d_jun ON d_jun.id = ids.id AND d_jun.month = \\'Jun\\'\\nLEFT JOIN Department d_jul ON d_jul.id = ids.id AND d_jul.month = \\'Jul\\'\\nLEFT JOIN Department d_aug ON d_aug.id = ids.id AND d_aug.month = \\'Aug\\'\\nLEFT JOIN Department d_sep ON d_sep.id = ids.id AND d_sep.month = \\'Sep\\'\\nLEFT JOIN Department d_oct ON d_oct.id = ids.id AND d_oct.month = \\'Oct\\'\\nLEFT JOIN Department d_nov ON d_nov.id = ids.id AND d_nov.month = \\'Nov\\'\\nLEFT JOIN Department d_dec ON d_dec.id = ids.id AND d_dec.month = \\'Dec\\'\\n```\\n\\n\\n**Group by solution**\\n```\\nSELECT \\n    id, \\n    MAX(CASE WHEN month = \\'Jan\\' THEN revenue ELSE null END) AS Jan_Revenue,\\n    MAX(CASE WHEN month = \\'Feb\\' THEN revenue ELSE null END) AS Feb_Revenue,\\n    MAX(CASE WHEN month = \\'Mar\\' THEN revenue ELSE null END) AS Mar_Revenue,\\n    MAX(CASE WHEN month = \\'Apr\\' THEN revenue ELSE null END) AS Apr_Revenue,\\n    MAX(CASE WHEN month = \\'May\\' THEN revenue ELSE null END) AS May_Revenue,\\n    MAX(CASE WHEN month = \\'Jun\\' THEN revenue ELSE null END) AS Jun_Revenue,\\n    MAX(CASE WHEN month = \\'Jul\\' THEN revenue ELSE null END) AS Jul_Revenue,\\n    MAX(CASE WHEN month = \\'Aug\\' THEN revenue ELSE null END) AS Aug_Revenue,\\n    MAX(CASE WHEN month = \\'Sep\\' THEN revenue ELSE null END) AS Sep_Revenue,\\n    MAX(CASE WHEN month = \\'Oct\\' THEN revenue ELSE null END) AS Oct_Revenue,\\n    MAX(CASE WHEN month = \\'Nov\\' THEN revenue ELSE null END) AS Nov_Revenue,\\n    MAX(CASE WHEN month = \\'Dec\\' THEN revenue ELSE null END) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```\\n\\n\\n**Pivot table solution**\\n```\\nSELECT \\n    id,\\n    Jan AS Jan_Revenue,\\n    Feb AS Feb_Revenue, \\n    Mar AS Mar_Revenue, \\n    Apr AS Apr_Revenue,\\n    May AS May_Revenue,\\n    Jun AS Jun_Revenue,\\n    Jul AS Jul_Revenue,\\n    Aug AS Aug_Revenue,\\n    Sep AS Sep_Revenue,\\n    Oct AS Oct_Revenue,\\n    Nov AS Nov_Revenue,\\n    Dec AS Dec_Revenue\\nFROM Department\\nPIVOT \\n(\\n    MAX(revenue)\\n    FOR month IN (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)        \\n) AS MonthsRevenue\\n```\\n",
                "solutionTags": [],
                "code": "```\\n;WITH ids AS \\n(\\n    SELECT DISTINCT id FROM Department\\n)\\nSELECT \\n    ids.id, \\n    d_jan.revenue AS Jan_Revenue,\\n    d_feb.revenue AS Feb_Revenue,\\n    d_mar.revenue AS Mar_Revenue,\\n    d_apr.revenue AS Apr_Revenue,\\n    d_may.revenue AS May_Revenue,\\n    d_jun.revenue AS Jun_Revenue,\\n    d_jul.revenue AS Jul_Revenue,\\n    d_aug.revenue AS Aug_Revenue,\\n    d_sep.revenue AS Sep_Revenue,\\n    d_oct.revenue AS Oct_Revenue,\\n    d_nov.revenue AS Nov_Revenue,\\n    d_dec.revenue AS Dec_Revenue\\nFROM ids\\nLEFT JOIN Department d_jan ON d_jan.id = ids.id AND d_jan.month = \\'Jan\\'\\nLEFT JOIN Department d_feb ON d_feb.id = ids.id AND d_feb.month = \\'Feb\\'\\nLEFT JOIN Department d_mar ON d_mar.id = ids.id AND d_mar.month = \\'Mar\\'\\nLEFT JOIN Department d_apr ON d_apr.id = ids.id AND d_apr.month = \\'Apr\\'\\nLEFT JOIN Department d_may ON d_may.id = ids.id AND d_may.month = \\'May\\'\\nLEFT JOIN Department d_jun ON d_jun.id = ids.id AND d_jun.month = \\'Jun\\'\\nLEFT JOIN Department d_jul ON d_jul.id = ids.id AND d_jul.month = \\'Jul\\'\\nLEFT JOIN Department d_aug ON d_aug.id = ids.id AND d_aug.month = \\'Aug\\'\\nLEFT JOIN Department d_sep ON d_sep.id = ids.id AND d_sep.month = \\'Sep\\'\\nLEFT JOIN Department d_oct ON d_oct.id = ids.id AND d_oct.month = \\'Oct\\'\\nLEFT JOIN Department d_nov ON d_nov.id = ids.id AND d_nov.month = \\'Nov\\'\\nLEFT JOIN Department d_dec ON d_dec.id = ids.id AND d_dec.month = \\'Dec\\'\\n```\n```\\nSELECT \\n    id, \\n    MAX(CASE WHEN month = \\'Jan\\' THEN revenue ELSE null END) AS Jan_Revenue,\\n    MAX(CASE WHEN month = \\'Feb\\' THEN revenue ELSE null END) AS Feb_Revenue,\\n    MAX(CASE WHEN month = \\'Mar\\' THEN revenue ELSE null END) AS Mar_Revenue,\\n    MAX(CASE WHEN month = \\'Apr\\' THEN revenue ELSE null END) AS Apr_Revenue,\\n    MAX(CASE WHEN month = \\'May\\' THEN revenue ELSE null END) AS May_Revenue,\\n    MAX(CASE WHEN month = \\'Jun\\' THEN revenue ELSE null END) AS Jun_Revenue,\\n    MAX(CASE WHEN month = \\'Jul\\' THEN revenue ELSE null END) AS Jul_Revenue,\\n    MAX(CASE WHEN month = \\'Aug\\' THEN revenue ELSE null END) AS Aug_Revenue,\\n    MAX(CASE WHEN month = \\'Sep\\' THEN revenue ELSE null END) AS Sep_Revenue,\\n    MAX(CASE WHEN month = \\'Oct\\' THEN revenue ELSE null END) AS Oct_Revenue,\\n    MAX(CASE WHEN month = \\'Nov\\' THEN revenue ELSE null END) AS Nov_Revenue,\\n    MAX(CASE WHEN month = \\'Dec\\' THEN revenue ELSE null END) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```\n```\\nSELECT \\n    id,\\n    Jan AS Jan_Revenue,\\n    Feb AS Feb_Revenue, \\n    Mar AS Mar_Revenue, \\n    Apr AS Apr_Revenue,\\n    May AS May_Revenue,\\n    Jun AS Jun_Revenue,\\n    Jul AS Jul_Revenue,\\n    Aug AS Aug_Revenue,\\n    Sep AS Sep_Revenue,\\n    Oct AS Oct_Revenue,\\n    Nov AS Nov_Revenue,\\n    Dec AS Dec_Revenue\\nFROM Department\\nPIVOT \\n(\\n    MAX(revenue)\\n    FOR month IN (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)        \\n) AS MonthsRevenue\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376241,
                "title": "mysql-solution-with-381-ms-faster-than-100-00",
                "content": "```\\nSELECT \\n    id, \\n    sum( if( month = \\'Jan\\', revenue, null ) ) AS Jan_Revenue,\\n    sum( if( month = \\'Feb\\', revenue, null ) ) AS Feb_Revenue,\\n    sum( if( month = \\'Mar\\', revenue, null ) ) AS Mar_Revenue,\\n    sum( if( month = \\'Apr\\', revenue, null ) ) AS Apr_Revenue,\\n    sum( if( month = \\'May\\', revenue, null ) ) AS May_Revenue,\\n    sum( if( month = \\'Jun\\', revenue, null ) ) AS Jun_Revenue,\\n    sum( if( month = \\'Jul\\', revenue, null ) ) AS Jul_Revenue,\\n    sum( if( month = \\'Aug\\', revenue, null ) ) AS Aug_Revenue,\\n    sum( if( month = \\'Sep\\', revenue, null ) ) AS Sep_Revenue,\\n    sum( if( month = \\'Oct\\', revenue, null ) ) AS Oct_Revenue,\\n    sum( if( month = \\'Nov\\', revenue, null ) ) AS Nov_Revenue,\\n    sum( if( month = \\'Dec\\', revenue, null ) ) AS Dec_Revenue\\nFROM \\n    Department\\nGROUP BY \\n    id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    id, \\n    sum( if( month = \\'Jan\\', revenue, null ) ) AS Jan_Revenue,\\n    sum( if( month = \\'Feb\\', revenue, null ) ) AS Feb_Revenue,\\n    sum( if( month = \\'Mar\\', revenue, null ) ) AS Mar_Revenue,\\n    sum( if( month = \\'Apr\\', revenue, null ) ) AS Apr_Revenue,\\n    sum( if( month = \\'May\\', revenue, null ) ) AS May_Revenue,\\n    sum( if( month = \\'Jun\\', revenue, null ) ) AS Jun_Revenue,\\n    sum( if( month = \\'Jul\\', revenue, null ) ) AS Jul_Revenue,\\n    sum( if( month = \\'Aug\\', revenue, null ) ) AS Aug_Revenue,\\n    sum( if( month = \\'Sep\\', revenue, null ) ) AS Sep_Revenue,\\n    sum( if( month = \\'Oct\\', revenue, null ) ) AS Oct_Revenue,\\n    sum( if( month = \\'Nov\\', revenue, null ) ) AS Nov_Revenue,\\n    sum( if( month = \\'Dec\\', revenue, null ) ) AS Dec_Revenue\\nFROM \\n    Department\\nGROUP BY \\n    id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 977604,
                "title": "easy-mysql-100-faster",
                "content": "```\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id;\\n\\n\\n\\n//----------------------------------Upvote if u like the solution-------------------------------------------------------\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id;\\n\\n\\n\\n//----------------------------------Upvote if u like the solution-------------------------------------------------------\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2473482,
                "title": "fully-explained-super-easy",
                "content": "```\\n# SELECT IF(500<1000, \"YES\", \"NO\");\\n# It returns \"YES\" if the condition is TRUE, or \"NO\" if the condition is FALSE:\\n\\nSELECT Department.id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department \\nGROUP BY id;\\n```\\n**DO UPVOTE IF YOU LIKE MY SOLUTION :)**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# SELECT IF(500<1000, \"YES\", \"NO\");\\n# It returns \"YES\" if the condition is TRUE, or \"NO\" if the condition is FALSE:\\n\\nSELECT Department.id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department \\nGROUP BY id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1812493,
                "title": "simple-mysql-solution-using-if-and-sum",
                "content": "```\\nSELECT id,\\n       SUM(if(month = \\'Jan\\', revenue, null)) AS Jan_Revenue,\\n       SUM(if(month = \\'Feb\\', revenue, null)) AS Feb_Revenue,\\n       SUM(if(month = \\'Mar\\', revenue, null)) AS Mar_Revenue,\\n       SUM(if(month = \\'Apr\\', revenue, null)) AS Apr_Revenue,\\n       SUM(if(month = \\'May\\', revenue, null)) AS May_Revenue,\\n       SUM(if(month = \\'Jun\\', revenue, null)) AS Jun_Revenue,\\n       SUM(if(month = \\'Jul\\', revenue, null)) AS Jul_Revenue,\\n       SUM(if(month = \\'Aug\\', revenue, null)) AS Aug_Revenue,\\n       SUM(if(month = \\'Sep\\', revenue, null)) AS Sep_Revenue,\\n       SUM(if(month = \\'Oct\\', revenue, null)) AS Oct_Revenue,\\n       SUM(if(month = \\'Nov\\', revenue, null)) AS Nov_Revenue,\\n       SUM(if(month = \\'Dec\\', revenue, null)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```\\n\\n**IF()**\\n`IF(condition, if_true, if_false)`\\ncondition - If month is equal to the respective column (for Jan_revenue column it should be `month = \\'Jan\\'`)\\nif_true= return all the **list of values** with respect to the individual id, afterwards we will sum all the values in the next step.\\nif_false - Just return **NULL** id there is no revenure with respect to that ID and the month.\\n\\n**SUM()**\\nWe sum all the values of respective id per month and then return it in the front of that id in the respective month column.\\nSUM(will sum all the values under the conidtion in this bracket)\\n\\n**Why I have used Group By and SUM?**\\nFor same id, month value can be repeated. Sum function will add all those to display in single row as `group by id` is used ((not month).\\n\\nPlease **Upvote** if you like the solution.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT id,\\n       SUM(if(month = \\'Jan\\', revenue, null)) AS Jan_Revenue,\\n       SUM(if(month = \\'Feb\\', revenue, null)) AS Feb_Revenue,\\n       SUM(if(month = \\'Mar\\', revenue, null)) AS Mar_Revenue,\\n       SUM(if(month = \\'Apr\\', revenue, null)) AS Apr_Revenue,\\n       SUM(if(month = \\'May\\', revenue, null)) AS May_Revenue,\\n       SUM(if(month = \\'Jun\\', revenue, null)) AS Jun_Revenue,\\n       SUM(if(month = \\'Jul\\', revenue, null)) AS Jul_Revenue,\\n       SUM(if(month = \\'Aug\\', revenue, null)) AS Aug_Revenue,\\n       SUM(if(month = \\'Sep\\', revenue, null)) AS Sep_Revenue,\\n       SUM(if(month = \\'Oct\\', revenue, null)) AS Oct_Revenue,\\n       SUM(if(month = \\'Nov\\', revenue, null)) AS Nov_Revenue,\\n       SUM(if(month = \\'Dec\\', revenue, null)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538980,
                "title": "mysql-case-when-solution",
                "content": "```\\nselect id,\\nsum(case when month = \"Jan\" then revenue else NULL end) as Jan_Revenue,\\nsum(case when month = \"Feb\" then revenue else NULL end) as Feb_Revenue,\\nsum(case when month = \"Mar\" then revenue else NULL end) as Mar_Revenue,\\nsum(case when month = \"Apr\" then revenue else NULL end) as Apr_Revenue,\\nsum(case when month = \"May\" then revenue else NULL end) as May_Revenue,\\nsum(case when month = \"Jun\" then revenue else NULL end) as Jun_Revenue,\\nsum(case when month = \"Jul\" then revenue else NULL end) as Jul_Revenue,\\nsum(case when month = \"Aug\" then revenue else NULL end) as Aug_Revenue,\\nsum(case when month = \"Sep\" then revenue else NULL end) as Sep_Revenue,\\nsum(case when month = \"Oct\" then revenue else NULL end) as Oct_Revenue,\\nsum(case when month = \"Nov\" then revenue else NULL end) as Nov_Revenue,\\nsum(case when month = \"Dec\" then revenue else NULL end) as Dec_Revenue\\nfrom Department \\ngroup by id\\norder by id\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect id,\\nsum(case when month = \"Jan\" then revenue else NULL end) as Jan_Revenue,\\nsum(case when month = \"Feb\" then revenue else NULL end) as Feb_Revenue,\\nsum(case when month = \"Mar\" then revenue else NULL end) as Mar_Revenue,\\nsum(case when month = \"Apr\" then revenue else NULL end) as Apr_Revenue,\\nsum(case when month = \"May\" then revenue else NULL end) as May_Revenue,\\nsum(case when month = \"Jun\" then revenue else NULL end) as Jun_Revenue,\\nsum(case when month = \"Jul\" then revenue else NULL end) as Jul_Revenue,\\nsum(case when month = \"Aug\" then revenue else NULL end) as Aug_Revenue,\\nsum(case when month = \"Sep\" then revenue else NULL end) as Sep_Revenue,\\nsum(case when month = \"Oct\" then revenue else NULL end) as Oct_Revenue,\\nsum(case when month = \"Nov\" then revenue else NULL end) as Nov_Revenue,\\nsum(case when month = \"Dec\" then revenue else NULL end) as Dec_Revenue\\nfrom Department \\ngroup by id\\norder by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643940,
                "title": "mysql-solution-using-group-by-and-case-when-with-explanation",
                "content": "```\\nSELECT id,\\nMIN(CASE WHEN month = \\'Jan\\' THEN revenue END) AS Jan_Revenue,\\nMIN(CASE WHEN month = \\'Feb\\' THEN revenue END) AS Feb_Revenue,\\nMIN(CASE WHEN month = \\'Mar\\' THEN revenue END) AS Mar_Revenue,\\nMIN(CASE WHEN month = \\'Apr\\' THEN revenue END) AS Apr_Revenue,\\nMIN(CASE WHEN month = \\'May\\' THEN revenue END) AS May_Revenue,\\nMIN(CASE WHEN month = \\'Jun\\' THEN revenue END) AS Jun_Revenue,\\nMIN(CASE WHEN month = \\'Jul\\' THEN revenue END) AS Jul_Revenue,\\nMIN(CASE WHEN month = \\'Aug\\' THEN revenue END) AS Aug_Revenue,\\nMIN(CASE WHEN month = \\'Sep\\' THEN revenue END) AS Sep_Revenue,\\nMIN(CASE WHEN month = \\'Oct\\' THEN revenue END) AS Oct_Revenue,\\nMIN(CASE WHEN month = \\'Nov\\' THEN revenue END) AS Nov_Revenue,\\nMIN(CASE WHEN month = \\'Dec\\' THEN revenue END) AS Dec_Revenue\\n\\nFROM Department\\nGROUP BY Id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id,\\nMIN(CASE WHEN month = \\'Jan\\' THEN revenue END) AS Jan_Revenue,\\nMIN(CASE WHEN month = \\'Feb\\' THEN revenue END) AS Feb_Revenue,\\nMIN(CASE WHEN month = \\'Mar\\' THEN revenue END) AS Mar_Revenue,\\nMIN(CASE WHEN month = \\'Apr\\' THEN revenue END) AS Apr_Revenue,\\nMIN(CASE WHEN month = \\'May\\' THEN revenue END) AS May_Revenue,\\nMIN(CASE WHEN month = \\'Jun\\' THEN revenue END) AS Jun_Revenue,\\nMIN(CASE WHEN month = \\'Jul\\' THEN revenue END) AS Jul_Revenue,\\nMIN(CASE WHEN month = \\'Aug\\' THEN revenue END) AS Aug_Revenue,\\nMIN(CASE WHEN month = \\'Sep\\' THEN revenue END) AS Sep_Revenue,\\nMIN(CASE WHEN month = \\'Oct\\' THEN revenue END) AS Oct_Revenue,\\nMIN(CASE WHEN month = \\'Nov\\' THEN revenue END) AS Nov_Revenue,\\nMIN(CASE WHEN month = \\'Dec\\' THEN revenue END) AS Dec_Revenue\\n\\nFROM Department\\nGROUP BY Id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488673,
                "title": "mssql-solution-using-group-by",
                "content": "```\\nselect id, \\nsum(case month when \\'Jan\\' then revenue else Null end) as Jan_Revenue, \\nsum(case month when \\'Feb\\' then revenue else Null end) as Feb_Revenue,\\nsum(case month when \\'Mar\\' then revenue else Null end) as Mar_Revenue,\\nsum(case month when \\'Apr\\' then revenue else Null end) as Apr_Revenue,\\nsum(case month when \\'May\\' then revenue else Null end) as May_Revenue,\\nsum(case month when \\'Jun\\' then revenue else Null end) as Jun_Revenue,\\nsum(case month when \\'Jul\\' then revenue else Null end) as Jul_Revenue,\\nsum(case month when \\'Aug\\' then revenue else Null end) as Aug_Revenue,\\nsum(case month when \\'Sep\\' then revenue else Null end) as Sep_Revenue,\\nsum(case month when \\'Oct\\' then revenue else Null end) as Oct_Revenue,\\nsum(case month when \\'Nov\\' then revenue else Null end) as Nov_Revenue,\\nsum(case month when \\'Dec\\' then revenue else Null end) as Dec_Revenue\\nfrom Department\\ngroup by id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect id, \\nsum(case month when \\'Jan\\' then revenue else Null end) as Jan_Revenue, \\nsum(case month when \\'Feb\\' then revenue else Null end) as Feb_Revenue,\\nsum(case month when \\'Mar\\' then revenue else Null end) as Mar_Revenue,\\nsum(case month when \\'Apr\\' then revenue else Null end) as Apr_Revenue,\\nsum(case month when \\'May\\' then revenue else Null end) as May_Revenue,\\nsum(case month when \\'Jun\\' then revenue else Null end) as Jun_Revenue,\\nsum(case month when \\'Jul\\' then revenue else Null end) as Jul_Revenue,\\nsum(case month when \\'Aug\\' then revenue else Null end) as Aug_Revenue,\\nsum(case month when \\'Sep\\' then revenue else Null end) as Sep_Revenue,\\nsum(case month when \\'Oct\\' then revenue else Null end) as Oct_Revenue,\\nsum(case month when \\'Nov\\' then revenue else Null end) as Nov_Revenue,\\nsum(case month when \\'Dec\\' then revenue else Null end) as Dec_Revenue\\nfrom Department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1677683,
                "title": "simple-case-statement",
                "content": "\\'\\'\\'\\nselect id,\\n        sum(case when month= \\'Jan\\' then  revenue else null end) as Jan_revenue,\\n        sum(case when month= \\'Feb\\' then  revenue else null end) as Feb_revenue,\\n        sum(case when month= \\'Mar\\' then  revenue else null end) as Mar_revenue,\\n        sum(case when month= \\'Apr\\' then  revenue else null end) as Apr_revenue,\\n        sum(case when month= \\'May\\' then  revenue else null end) as May_revenue,\\n        sum(case when month= \\'Jun\\' then  revenue else null end) as Jun_revenue,\\n        sum(case when month= \\'Jul\\' then  revenue else null end) as Jul_revenue,\\n        sum(case when month= \\'Aug\\' then  revenue else null end) as Aug_revenue,\\n        sum(case when month= \\'Sep\\' then  revenue else null end) as Sep_revenue,\\n        sum(case when month= \\'Oct\\' then  revenue else null end) as Oct_revenue,\\n        sum(case when month= \\'Nov\\' then  revenue else null end) as Nov_revenue,\\n        sum(case when month= \\'Dec\\' then  revenue else null end) as Dec_revenue\\nfrom department\\ngroup by id\\n\\'\\'\\'\\nWill have to use sum bcz same id with differnt month revenue would be in differnt rows. so summing would make id annual revenue in one row.",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nselect id,\\n        sum(case when month= \\'Jan\\' then  revenue else null end) as Jan_revenue,\\n        sum(case when month= \\'Feb\\' then  revenue else null end) as Feb_revenue,\\n        sum(case when month= \\'Mar\\' then  revenue else null end) as Mar_revenue,\\n        sum(case when month= \\'Apr\\' then  revenue else null end) as Apr_revenue,\\n        sum(case when month= \\'May\\' then  revenue else null end) as May_revenue,\\n        sum(case when month= \\'Jun\\' then  revenue else null end) as Jun_revenue,\\n        sum(case when month= \\'Jul\\' then  revenue else null end) as Jul_revenue,\\n        sum(case when month= \\'Aug\\' then  revenue else null end) as Aug_revenue,\\n        sum(case when month= \\'Sep\\' then  revenue else null end) as Sep_revenue,\\n        sum(case when month= \\'Oct\\' then  revenue else null end) as Oct_revenue,\\n        sum(case when month= \\'Nov\\' then  revenue else null end) as Nov_revenue,\\n        sum(case when month= \\'Dec\\' then  revenue else null end) as Dec_revenue\\nfrom department\\ngroup by id\\n\\'\\'\\'\\nWill have to use sum bcz same id with differnt month revenue would be in differnt rows. so summing would make id annual revenue in one row.",
                "codeTag": "Unknown"
            },
            {
                "id": 1593183,
                "title": "very-easy-oracle-pivot-solution",
                "content": "```\\nSELECT *\\n  FROM department\\n       PIVOT (SUM (revenue)\\n             Revenue\\n             FOR month\\n             IN (\\'Jan\\' Jan,\\n                \\'Feb\\' Feb,\\n                \\'Mar\\' Mar,\\n                \\'Apr\\' Apr,\\n                \\'May\\' May,\\n                \\'Jun\\' Jun,\\n                \\'Jul\\' Jul,\\n                \\'Aug\\' Aug,\\n                \\'Sep\\' Sep,\\n                \\'Oct\\' Oct,\\n                \\'Nov\\' Nov,\\n                \\'Dec\\' Dec));\\n````",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT *\\n  FROM department\\n       PIVOT (SUM (revenue)\\n             Revenue\\n             FOR month\\n             IN (\\'Jan\\' Jan,\\n                \\'Feb\\' Feb,\\n                \\'Mar\\' Mar,\\n                \\'Apr\\' Apr,\\n                \\'May\\' May,\\n                \\'Jun\\' Jun,\\n                \\'Jul\\' Jul,\\n                \\'Aug\\' Aug,\\n                \\'Sep\\' Sep,\\n                \\'Oct\\' Oct,\\n                \\'Nov\\' Nov,\\n                \\'Dec\\' Dec));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1230180,
                "title": "using-mssql-pivot-operator",
                "content": "```\\nselect id, Jan as Jan_Revenue,Feb as Feb_Revenue,Mar as Mar_Revenue,Apr as Apr_Revenue,May as May_Revenue,Jun as Jun_Revenue,Jul as Jul_Revenue,Aug as Aug_Revenue, Sep as Sep_Revenue,Oct as Oct_Revenue,Nov as Nov_Revenue,Dec as Dec_Revenue\\nfrom department\\nPIVOT \\n(\\n    sum(revenue)\\n    for month\\n    in ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n)\\nas PivotTable",
                "solutionTags": [],
                "code": "```\\nselect id, Jan as Jan_Revenue,Feb as Feb_Revenue,Mar as Mar_Revenue,Apr as Apr_Revenue,May as May_Revenue,Jun as Jun_Revenue,Jul as Jul_Revenue,Aug as Aug_Revenue, Sep as Sep_Revenue,Oct as Oct_Revenue,Nov as Nov_Revenue,Dec as Dec_Revenue\\nfrom department\\nPIVOT \\n(\\n    sum(revenue)\\n    for month\\n    in ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n)\\nas PivotTable",
                "codeTag": "Unknown"
            },
            {
                "id": 798034,
                "title": "mysql-faster-than-81-case-when",
                "content": "```\\nselect id,\\nsum(case when month = \\'Jan\\' then revenue else null end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue else null end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue else null end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue else null end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue else null end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue else null end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue else null end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue else null end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue else null end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue else null end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue else null end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue else null end) as Dec_Revenue\\n\\nfrom department\\ngroup by id",
                "solutionTags": [],
                "code": "```\\nselect id,\\nsum(case when month = \\'Jan\\' then revenue else null end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue else null end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue else null end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue else null end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue else null end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue else null end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue else null end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue else null end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue else null end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue else null end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue else null end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue else null end) as Dec_Revenue\\n\\nfrom department\\ngroup by id",
                "codeTag": "Unknown"
            },
            {
                "id": 1074373,
                "title": "mysql-easy-sol-0-memory-and-faster-than-92",
                "content": "```\\nselect id, \\nsum(if(month = \\'Jan\\', revenue, NULL)) as Jan_Revenue,\\nsum(if(month = \\'Feb\\', revenue, NULL)) as Feb_Revenue,\\nsum(if(month = \\'Mar\\', revenue, NULL)) as Mar_Revenue,\\nsum(if(month = \\'Apr\\', revenue, NULL)) as Apr_Revenue,\\nsum(if(month = \\'May\\', revenue, NULL)) as May_Revenue,\\nsum(if(month = \\'Jun\\', revenue, NULL)) as Jun_Revenue,\\nsum(if(month = \\'Jul\\', revenue, NULL)) as Jul_Revenue,\\nsum(if(month = \\'Aug\\', revenue, NULL)) as Aug_Revenue,\\nsum(if(month = \\'Sep\\', revenue, NULL)) as Sep_Revenue,\\nsum(if(month = \\'Oct\\', revenue, NULL)) as Oct_Revenue,\\nsum(if(month = \\'Nov\\', revenue, NULL)) as Nov_Revenue,\\nsum(if(month = \\'Dec\\', revenue, NULL)) as Dec_Revenue\\nfrom Department d \\ngroup by id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect id, \\nsum(if(month = \\'Jan\\', revenue, NULL)) as Jan_Revenue,\\nsum(if(month = \\'Feb\\', revenue, NULL)) as Feb_Revenue,\\nsum(if(month = \\'Mar\\', revenue, NULL)) as Mar_Revenue,\\nsum(if(month = \\'Apr\\', revenue, NULL)) as Apr_Revenue,\\nsum(if(month = \\'May\\', revenue, NULL)) as May_Revenue,\\nsum(if(month = \\'Jun\\', revenue, NULL)) as Jun_Revenue,\\nsum(if(month = \\'Jul\\', revenue, NULL)) as Jul_Revenue,\\nsum(if(month = \\'Aug\\', revenue, NULL)) as Aug_Revenue,\\nsum(if(month = \\'Sep\\', revenue, NULL)) as Sep_Revenue,\\nsum(if(month = \\'Oct\\', revenue, NULL)) as Oct_Revenue,\\nsum(if(month = \\'Nov\\', revenue, NULL)) as Nov_Revenue,\\nsum(if(month = \\'Dec\\', revenue, NULL)) as Dec_Revenue\\nfrom Department d \\ngroup by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561337,
                "title": "mysql-easy-solution",
                "content": "```\\nSELECT id,\\nMAX(CASE WHEN month=\\'Jan\\' then revenue else null end) Jan_Revenue,\\nMAX(CASE WHEN month=\\'Feb\\' then revenue else null end) Feb_Revenue,\\nMAX(CASE WHEN month=\\'Mar\\' then revenue else null end) Mar_Revenue,\\nMAX(CASE WHEN month=\\'Apr\\' then revenue else null end) Apr_Revenue,\\nMAX(CASE WHEN month=\\'May\\' then revenue else null end) May_Revenue,\\nMAX(CASE WHEN month=\\'Jun\\' then revenue else null end) Jun_Revenue,\\nMAX(CASE WHEN month=\\'Jul\\' then revenue else null end) Jul_Revenue,\\nMAX(CASE WHEN month=\\'Aug\\' then revenue else null end) Aug_Revenue,\\nMAX(CASE WHEN month=\\'Sep\\' then revenue else null end) Sep_Revenue,\\nMAX(CASE WHEN month=\\'Oct\\' then revenue else null end) Oct_Revenue,\\nMAX(CASE WHEN month=\\'Nov\\' then revenue else null end) Nov_Revenue,\\nMAX(CASE WHEN month=\\'Dec\\' then revenue else null end) Dec_Revenue\\nFrom\\nDepartment\\nGroup By id\\n",
                "solutionTags": [],
                "code": "```\\nSELECT id,\\nMAX(CASE WHEN month=\\'Jan\\' then revenue else null end) Jan_Revenue,\\nMAX(CASE WHEN month=\\'Feb\\' then revenue else null end) Feb_Revenue,\\nMAX(CASE WHEN month=\\'Mar\\' then revenue else null end) Mar_Revenue,\\nMAX(CASE WHEN month=\\'Apr\\' then revenue else null end) Apr_Revenue,\\nMAX(CASE WHEN month=\\'May\\' then revenue else null end) May_Revenue,\\nMAX(CASE WHEN month=\\'Jun\\' then revenue else null end) Jun_Revenue,\\nMAX(CASE WHEN month=\\'Jul\\' then revenue else null end) Jul_Revenue,\\nMAX(CASE WHEN month=\\'Aug\\' then revenue else null end) Aug_Revenue,\\nMAX(CASE WHEN month=\\'Sep\\' then revenue else null end) Sep_Revenue,\\nMAX(CASE WHEN month=\\'Oct\\' then revenue else null end) Oct_Revenue,\\nMAX(CASE WHEN month=\\'Nov\\' then revenue else null end) Nov_Revenue,\\nMAX(CASE WHEN month=\\'Dec\\' then revenue else null end) Dec_Revenue\\nFrom\\nDepartment\\nGroup By id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1519704,
                "title": "pivot",
                "content": "```\\n/* Write your T-SQL query statement below */\\nSELECT id, Jan AS Jan_Revenue, Feb AS Feb_Revenue, Mar AS Mar_Revenue,\\n    Apr AS Apr_Revenue, May AS May_Revenue, Jun AS Jun_Revenue,\\n    Jul AS Jul_Revenue, Aug AS Aug_Revenue, Sep AS Sep_Revenue,\\n    Oct AS Oct_Revenue, Nov AS Nov_Revenue, Dec AS Dec_Revenue\\nFROM Department\\nPIVOT(\\n    SUM(revenue) FOR month \\n    IN (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)\\n) AS PivotDepartment\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT id, Jan AS Jan_Revenue, Feb AS Feb_Revenue, Mar AS Mar_Revenue,\\n    Apr AS Apr_Revenue, May AS May_Revenue, Jun AS Jun_Revenue,\\n    Jul AS Jul_Revenue, Aug AS Aug_Revenue, Sep AS Sep_Revenue,\\n    Oct AS Oct_Revenue, Nov AS Nov_Revenue, Dec AS Dec_Revenue\\nFROM Department\\nPIVOT(\\n    SUM(revenue) FOR month \\n    IN (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)\\n) AS PivotDepartment\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535266,
                "title": "clean-simple",
                "content": "```\\nSELECT\\n    id,\\n    MAX (CASE WHEN month = \\'Jan\\' THEN revenue ELSE NULL END) \"Jan_Revenue\",\\n    MAX (CASE WHEN month = \\'Feb\\' THEN revenue ELSE NULL END) \"Feb_Revenue\",\\n    MAX (CASE WHEN month = \\'Mar\\' THEN revenue ELSE NULL END) \"Mar_Revenue\",\\n    MAX (CASE WHEN month = \\'Apr\\' THEN revenue ELSE NULL END) \"Apr_Revenue\",\\n    MAX (CASE WHEN month = \\'May\\' THEN revenue ELSE NULL END) \"May_Revenue\",\\n    MAX (CASE WHEN month = \\'Jun\\' THEN revenue ELSE NULL END) \"Jun_Revenue\",\\n    MAX (CASE WHEN month = \\'Jul\\' THEN revenue ELSE NULL END) \"Jul_Revenue\",\\n    MAX (CASE WHEN month = \\'Aug\\' THEN revenue ELSE NULL END) \"Aug_Revenue\",\\n    MAX (CASE WHEN month = \\'Sep\\' THEN revenue ELSE NULL END) \"Sep_Revenue\",\\n    MAX (CASE WHEN month = \\'Oct\\' THEN revenue ELSE NULL END) \"Oct_Revenue\",\\n    MAX (CASE WHEN month = \\'Nov\\' THEN revenue ELSE NULL END) \"Nov_Revenue\",\\n    MAX (CASE WHEN month = \\'Dec\\' THEN revenue ELSE NULL END) \"Dec_Revenue\"\\nFROM\\n    Department\\nGROUP BY\\n    id\\nORDER BY\\n    1;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    id,\\n    MAX (CASE WHEN month = \\'Jan\\' THEN revenue ELSE NULL END) \"Jan_Revenue\",\\n    MAX (CASE WHEN month = \\'Feb\\' THEN revenue ELSE NULL END) \"Feb_Revenue\",\\n    MAX (CASE WHEN month = \\'Mar\\' THEN revenue ELSE NULL END) \"Mar_Revenue\",\\n    MAX (CASE WHEN month = \\'Apr\\' THEN revenue ELSE NULL END) \"Apr_Revenue\",\\n    MAX (CASE WHEN month = \\'May\\' THEN revenue ELSE NULL END) \"May_Revenue\",\\n    MAX (CASE WHEN month = \\'Jun\\' THEN revenue ELSE NULL END) \"Jun_Revenue\",\\n    MAX (CASE WHEN month = \\'Jul\\' THEN revenue ELSE NULL END) \"Jul_Revenue\",\\n    MAX (CASE WHEN month = \\'Aug\\' THEN revenue ELSE NULL END) \"Aug_Revenue\",\\n    MAX (CASE WHEN month = \\'Sep\\' THEN revenue ELSE NULL END) \"Sep_Revenue\",\\n    MAX (CASE WHEN month = \\'Oct\\' THEN revenue ELSE NULL END) \"Oct_Revenue\",\\n    MAX (CASE WHEN month = \\'Nov\\' THEN revenue ELSE NULL END) \"Nov_Revenue\",\\n    MAX (CASE WHEN month = \\'Dec\\' THEN revenue ELSE NULL END) \"Dec_Revenue\"\\nFROM\\n    Department\\nGROUP BY\\n    id\\nORDER BY\\n    1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433524,
                "title": "super-easy",
                "content": "```\\nselect Department.id, \\nSUM(CASE WHEN Department.month  =\\'Jan\\' THEN Department.revenue END) as Jan_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Feb\\' THEN Department.revenue  END) AS Feb_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Mar\\' THEN Department.revenue  END) AS Mar_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Apr\\' THEN Department.revenue  END) AS Apr_Revenue,\\nSUM(CASE WHEN Department.month  =\\'May\\' THEN Department.revenue  END) AS May_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Jun\\' THEN Department.revenue  END) AS Jun_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Jul\\' THEN Department.revenue  END) AS Jul_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Aug\\' THEN Department.revenue  END) AS Aug_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Sep\\' THEN Department.revenue  END) AS Sep_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Oct\\' THEN Department.revenue  END) AS Oct_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Nov\\' THEN Department.revenue  END) AS Nov_Revenue,\\nSum(CASE WHEN Department.month  =\\'Dec\\' THEN Department.revenue  END) AS Dec_Revenue From Department\\nGROUP BY Department.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect Department.id, \\nSUM(CASE WHEN Department.month  =\\'Jan\\' THEN Department.revenue END) as Jan_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Feb\\' THEN Department.revenue  END) AS Feb_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Mar\\' THEN Department.revenue  END) AS Mar_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Apr\\' THEN Department.revenue  END) AS Apr_Revenue,\\nSUM(CASE WHEN Department.month  =\\'May\\' THEN Department.revenue  END) AS May_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Jun\\' THEN Department.revenue  END) AS Jun_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Jul\\' THEN Department.revenue  END) AS Jul_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Aug\\' THEN Department.revenue  END) AS Aug_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Sep\\' THEN Department.revenue  END) AS Sep_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Oct\\' THEN Department.revenue  END) AS Oct_Revenue,\\nSUM(CASE WHEN Department.month  =\\'Nov\\' THEN Department.revenue  END) AS Nov_Revenue,\\nSum(CASE WHEN Department.month  =\\'Dec\\' THEN Department.revenue  END) AS Dec_Revenue From Department\\nGROUP BY Department.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2690123,
                "title": "ms-sql-server-simple-pivot-solution",
                "content": "\\n```\\nSELECT *\\nFROM (\\n    SELECT id, CONCAT(month,\\'_Revenue\\') col_name, revenue\\n    FROM Department\\n) as Dpt\\nPIVOT (\\n    SUM(revenue)\\n    FOR col_name IN (\"Jan_Revenue\", \"Feb_Revenue\", \"Mar_Revenue\", \"Apr_Revenue\", \"May_Revenue\", \"Jun_Revenue\", \"Jul_Revenue\", \"Aug_Revenue\", \"Sep_Revenue\", \"Oct_Revenue\", \"Nov_Revenue\", \"Dec_Revenue\")\\n) pivot_table\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT *\\nFROM (\\n    SELECT id, CONCAT(month,\\'_Revenue\\') col_name, revenue\\n    FROM Department\\n) as Dpt\\nPIVOT (\\n    SUM(revenue)\\n    FOR col_name IN (\"Jan_Revenue\", \"Feb_Revenue\", \"Mar_Revenue\", \"Apr_Revenue\", \"May_Revenue\", \"Jun_Revenue\", \"Jul_Revenue\", \"Aug_Revenue\", \"Sep_Revenue\", \"Oct_Revenue\", \"Nov_Revenue\", \"Dec_Revenue\")\\n) pivot_table\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2546840,
                "title": "1179-reformat-department-table",
                "content": "```\\nSELECT id,\\nSUM(CASE WHEN month = \\'Jan\\' THEN revenue END) AS Jan_Revenue,\\nSUM(CASE WHEN month = \\'Feb\\' THEN revenue END) AS Feb_Revenue,\\nSUM(CASE WHEN month = \\'Mar\\' THEN revenue END) AS Mar_Revenue,\\nSUM(CASE WHEN month = \\'Apr\\' THEN revenue END) AS Apr_Revenue,\\nSUM(CASE WHEN month = \\'May\\' THEN revenue END) AS May_Revenue,\\nSUM(CASE WHEN month = \\'Jun\\' THEN revenue END) AS Jun_Revenue,\\nSUM(CASE WHEN month = \\'Jul\\' THEN revenue END) AS Jul_Revenue,\\nSUM(CASE WHEN month = \\'Aug\\' THEN revenue END) AS Aug_Revenue,\\nSUM(CASE WHEN month = \\'Sep\\' THEN revenue END) AS Sep_Revenue,\\nSUM(CASE WHEN month = \\'Oct\\' THEN revenue END) AS Oct_Revenue,\\nSUM(CASE WHEN month = \\'Nov\\' THEN revenue END) AS Nov_Revenue,\\nSUM(CASE WHEN month = \\'Dec\\' THEN revenue END) AS Dec_Revenue \\nFROM Department\\nGROUP BY id",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT id,\\nSUM(CASE WHEN month = \\'Jan\\' THEN revenue END) AS Jan_Revenue,\\nSUM(CASE WHEN month = \\'Feb\\' THEN revenue END) AS Feb_Revenue,\\nSUM(CASE WHEN month = \\'Mar\\' THEN revenue END) AS Mar_Revenue,\\nSUM(CASE WHEN month = \\'Apr\\' THEN revenue END) AS Apr_Revenue,\\nSUM(CASE WHEN month = \\'May\\' THEN revenue END) AS May_Revenue,\\nSUM(CASE WHEN month = \\'Jun\\' THEN revenue END) AS Jun_Revenue,\\nSUM(CASE WHEN month = \\'Jul\\' THEN revenue END) AS Jul_Revenue,\\nSUM(CASE WHEN month = \\'Aug\\' THEN revenue END) AS Aug_Revenue,\\nSUM(CASE WHEN month = \\'Sep\\' THEN revenue END) AS Sep_Revenue,\\nSUM(CASE WHEN month = \\'Oct\\' THEN revenue END) AS Oct_Revenue,\\nSUM(CASE WHEN month = \\'Nov\\' THEN revenue END) AS Nov_Revenue,\\nSUM(CASE WHEN month = \\'Dec\\' THEN revenue END) AS Dec_Revenue \\nFROM Department\\nGROUP BY id",
                "codeTag": "Unknown"
            },
            {
                "id": 1613958,
                "title": "simple-if-else",
                "content": "```\\nselect\\n    id,\\n    min(if(month = \\'Jan\\', revenue, null)) as Jan_Revenue,\\n    min(if(month = \\'Feb\\', revenue, null)) as Feb_Revenue,\\n    min(if(month = \\'Mar\\', revenue, null)) as Mar_Revenue,\\n    min(if(month = \\'Apr\\', revenue, null)) as Apr_Revenue,\\n    min(if(month = \\'May\\', revenue, null)) as May_Revenue,\\n    min(if(month = \\'Jun\\', revenue, null)) as Jun_Revenue,\\n    min(if(month = \\'Jul\\', revenue, null)) as Jul_Revenue,\\n    min(if(month = \\'Aug\\', revenue, null)) as Aug_Revenue,\\n    min(if(month = \\'Sep\\', revenue, null)) as Sep_Revenue,\\n    min(if(month = \\'Oct\\', revenue, null)) as Oct_Revenue,\\n    min(if(month = \\'Nov\\', revenue, null)) as Nov_Revenue,\\n    min(if(month = \\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom \\nDepartment\\ngroup by id\\norder by id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    id,\\n    min(if(month = \\'Jan\\', revenue, null)) as Jan_Revenue,\\n    min(if(month = \\'Feb\\', revenue, null)) as Feb_Revenue,\\n    min(if(month = \\'Mar\\', revenue, null)) as Mar_Revenue,\\n    min(if(month = \\'Apr\\', revenue, null)) as Apr_Revenue,\\n    min(if(month = \\'May\\', revenue, null)) as May_Revenue,\\n    min(if(month = \\'Jun\\', revenue, null)) as Jun_Revenue,\\n    min(if(month = \\'Jul\\', revenue, null)) as Jul_Revenue,\\n    min(if(month = \\'Aug\\', revenue, null)) as Aug_Revenue,\\n    min(if(month = \\'Sep\\', revenue, null)) as Sep_Revenue,\\n    min(if(month = \\'Oct\\', revenue, null)) as Oct_Revenue,\\n    min(if(month = \\'Nov\\', revenue, null)) as Nov_Revenue,\\n    min(if(month = \\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom \\nDepartment\\ngroup by id\\norder by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1293216,
                "title": "88-faster-mysql",
                "content": "\\n```\\nSELECT id,\\nsum(IF(month=\\'Jan\\', revenue, null)) AS Jan_Revenue,\\nsum(IF(month=\\'Feb\\', revenue, null)) AS Feb_Revenue,\\nsum(IF(month=\"Mar\", revenue, null)) AS Mar_Revenue,\\nsum(IF(month=\"Apr\", revenue, null)) AS Apr_Revenue,\\nsum(IF(month=\"May\", revenue, null)) AS May_Revenue,\\nsum(IF(month=\"Jun\", revenue, null)) AS Jun_Revenue,\\nsum(IF(month=\"Jul\", revenue, null)) AS Jul_Revenue,\\nsum(IF(month=\"Aug\", revenue, null)) AS Aug_Revenue,\\nsum(IF(month=\"Sep\", revenue, null)) AS Sep_Revenue,\\nsum(IF(month=\"Oct\", revenue, null)) AS Oct_Revenue,\\nsum(IF(month=\"Nov\", revenue, null)) AS Nov_Revenue,\\nsum(IF(month=\"Dec\", revenue, null)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id,\\nsum(IF(month=\\'Jan\\', revenue, null)) AS Jan_Revenue,\\nsum(IF(month=\\'Feb\\', revenue, null)) AS Feb_Revenue,\\nsum(IF(month=\"Mar\", revenue, null)) AS Mar_Revenue,\\nsum(IF(month=\"Apr\", revenue, null)) AS Apr_Revenue,\\nsum(IF(month=\"May\", revenue, null)) AS May_Revenue,\\nsum(IF(month=\"Jun\", revenue, null)) AS Jun_Revenue,\\nsum(IF(month=\"Jul\", revenue, null)) AS Jul_Revenue,\\nsum(IF(month=\"Aug\", revenue, null)) AS Aug_Revenue,\\nsum(IF(month=\"Sep\", revenue, null)) AS Sep_Revenue,\\nsum(IF(month=\"Oct\", revenue, null)) AS Oct_Revenue,\\nsum(IF(month=\"Nov\", revenue, null)) AS Nov_Revenue,\\nsum(IF(month=\"Dec\", revenue, null)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203993,
                "title": "mssql-case-solution",
                "content": "Base Solution. COuld have used a pivot too.\\n```\\nSelect\\nID\\n, sum(Case When Month = \\'Jan\\' Then Revenue End) as Jan_Revenue\\n, sum(Case When Month = \\'Feb\\' Then Revenue End) as Feb_Revenue\\n, sum(Case When Month = \\'Mar\\' Then Revenue End) as Mar_Revenue\\n, sum(Case When Month = \\'Apr\\' Then Revenue End) as Apr_Revenue\\n, sum(Case When Month = \\'May\\' Then Revenue End) as May_Revenue\\n, sum(Case When Month = \\'Jun\\' Then Revenue End) as Jun_Revenue\\n, sum(Case When Month = \\'Jul\\' Then Revenue End) as Jul_Revenue\\n, sum(Case When Month = \\'Aug\\' Then Revenue End) as Aug_Revenue\\n, sum(Case When Month = \\'Sep\\' Then Revenue End) as Sep_Revenue\\n, sum(Case When Month = \\'Oct\\' Then Revenue End) as Oct_Revenue\\n, sum(Case When Month = \\'Nov\\' Then Revenue End) as Nov_Revenue\\n, sum(Case When Month = \\'Dec\\' Then Revenue End) as Dec_Revenue\\nFrom Department\\nGroup By ID\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSelect\\nID\\n, sum(Case When Month = \\'Jan\\' Then Revenue End) as Jan_Revenue\\n, sum(Case When Month = \\'Feb\\' Then Revenue End) as Feb_Revenue\\n, sum(Case When Month = \\'Mar\\' Then Revenue End) as Mar_Revenue\\n, sum(Case When Month = \\'Apr\\' Then Revenue End) as Apr_Revenue\\n, sum(Case When Month = \\'May\\' Then Revenue End) as May_Revenue\\n, sum(Case When Month = \\'Jun\\' Then Revenue End) as Jun_Revenue\\n, sum(Case When Month = \\'Jul\\' Then Revenue End) as Jul_Revenue\\n, sum(Case When Month = \\'Aug\\' Then Revenue End) as Aug_Revenue\\n, sum(Case When Month = \\'Sep\\' Then Revenue End) as Sep_Revenue\\n, sum(Case When Month = \\'Oct\\' Then Revenue End) as Oct_Revenue\\n, sum(Case When Month = \\'Nov\\' Then Revenue End) as Nov_Revenue\\n, sum(Case When Month = \\'Dec\\' Then Revenue End) as Dec_Revenue\\nFrom Department\\nGroup By ID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 706747,
                "title": "using-case-when-group-by-mysql-solution",
                "content": "```\\nselect id,\\n   sum(case when month = \\'Jan\\' then revenue else null end) as \"Jan_Revenue\",\\n    sum(case when month = \\'Feb\\' then revenue else null end)as \"Feb_Revenue\",\\n    sum(case when month = \\'Mar\\' then revenue else null end) as \"Mar_Revenue\",\\n    sum(case when month = \\'Apr\\' then revenue else null end) as \"Apr_Revenue\",\\n    sum(case when month = \\'May\\' then revenue else null end) as \"May_Revenue\",\\n    sum(case when month = \\'Jun\\' then revenue else null end) as \"Jun_Revenue\",\\n    sum(case when month = \\'Jul\\' then revenue else null end) as \"Jul_Revenue\",\\n    sum(case when month = \\'Aug\\' then revenue else null end) as \"Aug_Revenue\",\\n    sum(case when month = \\'Sep\\' then revenue else null end) as \"Sep_Revenue\",\\n    sum(case when month = \\'Oct\\' then revenue else null end) as \"Oct_Revenue\",\\n    sum(case when month = \\'Nov\\' then revenue else null end) as \"Nov_Revenue\",\\n    sum(case when month = \\'Dec\\' then revenue else null end) as \"Dec_Revenue\"\\nfrom department\\ngroup by id\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,\\n   sum(case when month = \\'Jan\\' then revenue else null end) as \"Jan_Revenue\",\\n    sum(case when month = \\'Feb\\' then revenue else null end)as \"Feb_Revenue\",\\n    sum(case when month = \\'Mar\\' then revenue else null end) as \"Mar_Revenue\",\\n    sum(case when month = \\'Apr\\' then revenue else null end) as \"Apr_Revenue\",\\n    sum(case when month = \\'May\\' then revenue else null end) as \"May_Revenue\",\\n    sum(case when month = \\'Jun\\' then revenue else null end) as \"Jun_Revenue\",\\n    sum(case when month = \\'Jul\\' then revenue else null end) as \"Jul_Revenue\",\\n    sum(case when month = \\'Aug\\' then revenue else null end) as \"Aug_Revenue\",\\n    sum(case when month = \\'Sep\\' then revenue else null end) as \"Sep_Revenue\",\\n    sum(case when month = \\'Oct\\' then revenue else null end) as \"Oct_Revenue\",\\n    sum(case when month = \\'Nov\\' then revenue else null end) as \"Nov_Revenue\",\\n    sum(case when month = \\'Dec\\' then revenue else null end) as \"Dec_Revenue\"\\nfrom department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399631,
                "title": "mysql-solution-with-case-when",
                "content": "select id, \\n\\tsum(case when month = \\'Jan\\' then revenue else null end) as Jan_Revenue,\\n\\tsum(case when month = \\'Feb\\' then revenue else null end) as Feb_Revenue,\\n\\tsum(case when month = \\'Mar\\' then revenue else null end) as Mar_Revenue,\\n\\tsum(case when month = \\'Apr\\' then revenue else null end) as Apr_Revenue,\\n\\tsum(case when month = \\'May\\' then revenue else null end) as May_Revenue,\\n\\tsum(case when month = \\'Jun\\' then revenue else null end) as Jun_Revenue,\\n\\tsum(case when month = \\'Jul\\' then revenue else null end) as Jul_Revenue,\\n\\tsum(case when month = \\'Aug\\' then revenue else null end) as Aug_Revenue,\\n\\tsum(case when month = \\'Sep\\' then revenue else null end) as Sep_Revenue,\\n\\tsum(case when month = \\'Oct\\' then revenue else null end) as Oct_Revenue,\\n\\tsum(case when month = \\'Nov\\' then revenue else null end) as Nov_Revenue,\\n\\tsum(case when month = \\'Dec\\' then revenue else null end) as Dec_Revenue\\nfrom department\\ngroup by id\\norder by id",
                "solutionTags": [],
                "code": "select id, \\n\\tsum(case when month = \\'Jan\\' then revenue else null end) as Jan_Revenue,\\n\\tsum(case when month = \\'Feb\\' then revenue else null end) as Feb_Revenue,\\n\\tsum(case when month = \\'Mar\\' then revenue else null end) as Mar_Revenue,\\n\\tsum(case when month = \\'Apr\\' then revenue else null end) as Apr_Revenue,\\n\\tsum(case when month = \\'May\\' then revenue else null end) as May_Revenue,\\n\\tsum(case when month = \\'Jun\\' then revenue else null end) as Jun_Revenue,\\n\\tsum(case when month = \\'Jul\\' then revenue else null end) as Jul_Revenue,\\n\\tsum(case when month = \\'Aug\\' then revenue else null end) as Aug_Revenue,\\n\\tsum(case when month = \\'Sep\\' then revenue else null end) as Sep_Revenue,\\n\\tsum(case when month = \\'Oct\\' then revenue else null end) as Oct_Revenue,\\n\\tsum(case when month = \\'Nov\\' then revenue else null end) as Nov_Revenue,\\n\\tsum(case when month = \\'Dec\\' then revenue else null end) as Dec_Revenue\\nfrom department\\ngroup by id\\norder by id",
                "codeTag": "Unknown"
            },
            {
                "id": 3201746,
                "title": "easiest-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect id, \\n\\tsum(case when month = \\'jan\\' then revenue else null end) as Jan_Revenue,\\n\\tsum(case when month = \\'feb\\' then revenue else null end) as Feb_Revenue,\\n\\tsum(case when month = \\'mar\\' then revenue else null end) as Mar_Revenue,\\n\\tsum(case when month = \\'apr\\' then revenue else null end) as Apr_Revenue,\\n\\tsum(case when month = \\'may\\' then revenue else null end) as May_Revenue,\\n\\tsum(case when month = \\'jun\\' then revenue else null end) as Jun_Revenue,\\n\\tsum(case when month = \\'jul\\' then revenue else null end) as Jul_Revenue,\\n\\tsum(case when month = \\'aug\\' then revenue else null end) as Aug_Revenue,\\n\\tsum(case when month = \\'sep\\' then revenue else null end) as Sep_Revenue,\\n\\tsum(case when month = \\'oct\\' then revenue else null end) as Oct_Revenue,\\n\\tsum(case when month = \\'nov\\' then revenue else null end) as Nov_Revenue,\\n\\tsum(case when month = \\'dec\\' then revenue else null end) as Dec_Revenue\\nfrom department\\ngroup by id\\norder by id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect id, \\n\\tsum(case when month = \\'jan\\' then revenue else null end) as Jan_Revenue,\\n\\tsum(case when month = \\'feb\\' then revenue else null end) as Feb_Revenue,\\n\\tsum(case when month = \\'mar\\' then revenue else null end) as Mar_Revenue,\\n\\tsum(case when month = \\'apr\\' then revenue else null end) as Apr_Revenue,\\n\\tsum(case when month = \\'may\\' then revenue else null end) as May_Revenue,\\n\\tsum(case when month = \\'jun\\' then revenue else null end) as Jun_Revenue,\\n\\tsum(case when month = \\'jul\\' then revenue else null end) as Jul_Revenue,\\n\\tsum(case when month = \\'aug\\' then revenue else null end) as Aug_Revenue,\\n\\tsum(case when month = \\'sep\\' then revenue else null end) as Sep_Revenue,\\n\\tsum(case when month = \\'oct\\' then revenue else null end) as Oct_Revenue,\\n\\tsum(case when month = \\'nov\\' then revenue else null end) as Nov_Revenue,\\n\\tsum(case when month = \\'dec\\' then revenue else null end) as Dec_Revenue\\nfrom department\\ngroup by id\\norder by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2510915,
                "title": "mysql-beginner-level-easy-to-understand-simple-short-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n*====================================================================*\\n\\u2705 **MySQL Code :**\\n```\\nSelect id, \\n\\tSUM(CASE WHEN month = \\'jan\\' THEN revenue ELSE null END) AS Jan_Revenue,\\n\\tSUM(CASE WHEN month = \\'feb\\' THEN revenue ELSE null END) AS Feb_Revenue,\\n\\tSUM(CASE WHEN month = \\'mar\\' THEN revenue ELSE null END) AS Mar_Revenue,\\n\\tSUM(CASE WHEN month = \\'apr\\' THEN revenue ELSE null END) AS Apr_Revenue,\\n\\tSUM(CASE WHEN month = \\'may\\' THEN revenue ELSE null END) AS May_Revenue,\\n\\tSUM(CASE WHEN month = \\'jun\\' THEN revenue ELSE null END) AS Jun_Revenue,\\n\\tSUM(CASE WHEN month = \\'jul\\' THEN revenue ELSE null END) AS Jul_Revenue,\\n\\tSUM(CASE WHEN month = \\'aug\\' THEN revenue ELSE null END) AS Aug_Revenue,\\n\\tSUM(CASE WHEN month = \\'sep\\' THEN revenue ELSE null END) AS Sep_Revenue,\\n\\tSUM(CASE WHEN month = \\'oct\\' THEN revenue ELSE null END) AS Oct_Revenue,\\n\\tSUM(CASE WHEN month = \\'nov\\' THEN revenue ELSE null END) AS Nov_Revenue,\\n\\tSUM(CASE WHEN month = \\'dec\\' THEN revenue ELSE null END) AS Dec_Revenue\\nFROM department\\nGROUP BY id\\nORDER BY id\\n```\\n**Runtime:** 743 ms\\n**Memory Usage:**  0B\\n________________________________\\n__________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect id, \\n\\tSUM(CASE WHEN month = \\'jan\\' THEN revenue ELSE null END) AS Jan_Revenue,\\n\\tSUM(CASE WHEN month = \\'feb\\' THEN revenue ELSE null END) AS Feb_Revenue,\\n\\tSUM(CASE WHEN month = \\'mar\\' THEN revenue ELSE null END) AS Mar_Revenue,\\n\\tSUM(CASE WHEN month = \\'apr\\' THEN revenue ELSE null END) AS Apr_Revenue,\\n\\tSUM(CASE WHEN month = \\'may\\' THEN revenue ELSE null END) AS May_Revenue,\\n\\tSUM(CASE WHEN month = \\'jun\\' THEN revenue ELSE null END) AS Jun_Revenue,\\n\\tSUM(CASE WHEN month = \\'jul\\' THEN revenue ELSE null END) AS Jul_Revenue,\\n\\tSUM(CASE WHEN month = \\'aug\\' THEN revenue ELSE null END) AS Aug_Revenue,\\n\\tSUM(CASE WHEN month = \\'sep\\' THEN revenue ELSE null END) AS Sep_Revenue,\\n\\tSUM(CASE WHEN month = \\'oct\\' THEN revenue ELSE null END) AS Oct_Revenue,\\n\\tSUM(CASE WHEN month = \\'nov\\' THEN revenue ELSE null END) AS Nov_Revenue,\\n\\tSUM(CASE WHEN month = \\'dec\\' THEN revenue ELSE null END) AS Dec_Revenue\\nFROM department\\nGROUP BY id\\nORDER BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2363667,
                "title": "solution-mysql",
                "content": "```\\nselect\\n    id,\\n    sum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\n    sum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\n    sum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\n    sum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\n    sum(case when month = \\'May\\' then revenue end) as May_Revenue,\\n    sum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\n    sum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\n    sum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\n    sum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\n    sum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\n    sum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\n    sum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    id,\\n    sum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\n    sum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\n    sum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\n    sum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\n    sum(case when month = \\'May\\' then revenue end) as May_Revenue,\\n    sum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\n    sum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\n    sum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\n    sum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\n    sum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\n    sum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\n    sum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1761409,
                "title": "reformat-using-groupby-and-case-statements",
                "content": "\\n```\\nSELECT ID,\\nsum(case when month =\\'Jan\\' then revenue else NULL end) Jan_Revenue,\\nsum(case when month =\\'Feb\\' then revenue else NULL end) Feb_Revenue,\\nsum(case when month =\\'Mar\\' then revenue else NULL end) Mar_Revenue,\\nsum(case when month =\\'Apr\\' then revenue else NULL end) Apr_Revenue,\\nsum(case when month =\\'May\\' then revenue else NULL end) May_Revenue,\\nsum(case when month =\\'Jun\\' then revenue else NULL end) Jun_Revenue,\\nsum(case when month =\\'Jul\\' then revenue else NULL end) Jul_Revenue,\\nsum(case when month =\\'Aug\\' then revenue else NULL end) Aug_Revenue,\\nsum(case when month =\\'Sep\\' then revenue else NULL end) Sep_Revenue,\\nsum(case when month =\\'Oct\\' then revenue else NULL end) Oct_Revenue,\\nsum(case when month =\\'Nov\\' then revenue else NULL end) Nov_Revenue,\\nsum(case when month =\\'Dec\\' then revenue else NULL end) Dec_Revenue\\nFROM DEPARTMENT\\nGROUP BY ID;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT ID,\\nsum(case when month =\\'Jan\\' then revenue else NULL end) Jan_Revenue,\\nsum(case when month =\\'Feb\\' then revenue else NULL end) Feb_Revenue,\\nsum(case when month =\\'Mar\\' then revenue else NULL end) Mar_Revenue,\\nsum(case when month =\\'Apr\\' then revenue else NULL end) Apr_Revenue,\\nsum(case when month =\\'May\\' then revenue else NULL end) May_Revenue,\\nsum(case when month =\\'Jun\\' then revenue else NULL end) Jun_Revenue,\\nsum(case when month =\\'Jul\\' then revenue else NULL end) Jul_Revenue,\\nsum(case when month =\\'Aug\\' then revenue else NULL end) Aug_Revenue,\\nsum(case when month =\\'Sep\\' then revenue else NULL end) Sep_Revenue,\\nsum(case when month =\\'Oct\\' then revenue else NULL end) Oct_Revenue,\\nsum(case when month =\\'Nov\\' then revenue else NULL end) Nov_Revenue,\\nsum(case when month =\\'Dec\\' then revenue else NULL end) Dec_Revenue\\nFROM DEPARTMENT\\nGROUP BY ID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1455601,
                "title": "mysql-easy-faster",
                "content": "SELECT id,\\n    MAX(IF(month = \\'Jan\\', revenue, NULL)) as Jan_Revenue,\\n    MAX(IF(month = \\'Feb\\', revenue, NULL)) as Feb_Revenue,\\n    MAX(IF(month = \\'Mar\\', revenue, NULL)) as Mar_Revenue,\\n    MAX(IF(month = \\'Apr\\', revenue, NULL)) as Apr_Revenue,\\n    MAX(IF(month = \\'May\\', revenue, NULL)) as May_Revenue,\\n    MAX(IF(month = \\'Jun\\', revenue, NULL)) as Jun_Revenue,\\n    MAX(IF(month = \\'Jul\\', revenue, NULL)) as Jul_Revenue,\\n    MAX(IF(month = \\'Aug\\', revenue, NULL)) as Aug_Revenue,\\n    MAX(IF(month = \\'Sep\\', revenue, NULL)) as Sep_Revenue,\\n    MAX(IF(month = \\'Oct\\', revenue, NULL)) as Oct_Revenue,\\n    MAX(IF(month = \\'Nov\\', revenue, NULL)) as Nov_Revenue,\\n    MAX(IF(month = \\'Dec\\', revenue, NULL)) as Dec_Revenue\\nFROM Department\\ngroup by id",
                "solutionTags": [],
                "code": "SELECT id,\\n    MAX(IF(month = \\'Jan\\', revenue, NULL)) as Jan_Revenue,\\n    MAX(IF(month = \\'Feb\\', revenue, NULL)) as Feb_Revenue,\\n    MAX(IF(month = \\'Mar\\', revenue, NULL)) as Mar_Revenue,\\n    MAX(IF(month = \\'Apr\\', revenue, NULL)) as Apr_Revenue,\\n    MAX(IF(month = \\'May\\', revenue, NULL)) as May_Revenue,\\n    MAX(IF(month = \\'Jun\\', revenue, NULL)) as Jun_Revenue,\\n    MAX(IF(month = \\'Jul\\', revenue, NULL)) as Jul_Revenue,\\n    MAX(IF(month = \\'Aug\\', revenue, NULL)) as Aug_Revenue,\\n    MAX(IF(month = \\'Sep\\', revenue, NULL)) as Sep_Revenue,\\n    MAX(IF(month = \\'Oct\\', revenue, NULL)) as Oct_Revenue,\\n    MAX(IF(month = \\'Nov\\', revenue, NULL)) as Nov_Revenue,\\n    MAX(IF(month = \\'Dec\\', revenue, NULL)) as Dec_Revenue\\nFROM Department\\ngroup by id",
                "codeTag": "Unknown"
            },
            {
                "id": 545900,
                "title": "ms-sql-pivot",
                "content": "```\\nSELECT * FROM (SELECT revenue, month+\\'_Revenue\\' as m, id \\nFROM DEPARTMENT) t\\nPIVOT (\\n    SUM(revenue) \\n    for m in (\\n                    [Jan_Revenue],\\n                    [Feb_Revenue],\\n                    [Mar_Revenue],\\n                    [Apr_Revenue],\\n                    [May_Revenue],\\n                    [Jun_Revenue],\\n                    [Jul_Revenue],\\n                    [Aug_Revenue],\\n                    [Sep_Revenue],\\n                    [Oct_Revenue],\\n                    [Nov_Revenue],\\n                    [Dec_Revenue]\\n                 )\\n) as pivot_table\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT * FROM (SELECT revenue, month+\\'_Revenue\\' as m, id \\nFROM DEPARTMENT) t\\nPIVOT (\\n    SUM(revenue) \\n    for m in (\\n                    [Jan_Revenue],\\n                    [Feb_Revenue],\\n                    [Mar_Revenue],\\n                    [Apr_Revenue],\\n                    [May_Revenue],\\n                    [Jun_Revenue],\\n                    [Jul_Revenue],\\n                    [Aug_Revenue],\\n                    [Sep_Revenue],\\n                    [Oct_Revenue],\\n                    [Nov_Revenue],\\n                    [Dec_Revenue]\\n                 )\\n) as pivot_table\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381414,
                "title": "both-mysql-98-57-and-oracle-87-34-solutions",
                "content": "MySQL solution using SUM:\\n\\n```\\nselect id, \\n\\tsum(case when month = \\'jan\\' then revenue else null end) as Jan_Revenue,\\n\\tsum(case when month = \\'feb\\' then revenue else null end) as Feb_Revenue,\\n\\tsum(case when month = \\'mar\\' then revenue else null end) as Mar_Revenue,\\n\\tsum(case when month = \\'apr\\' then revenue else null end) as Apr_Revenue,\\n\\tsum(case when month = \\'may\\' then revenue else null end) as May_Revenue,\\n\\tsum(case when month = \\'jun\\' then revenue else null end) as Jun_Revenue,\\n\\tsum(case when month = \\'jul\\' then revenue else null end) as Jul_Revenue,\\n\\tsum(case when month = \\'aug\\' then revenue else null end) as Aug_Revenue,\\n\\tsum(case when month = \\'sep\\' then revenue else null end) as Sep_Revenue,\\n\\tsum(case when month = \\'oct\\' then revenue else null end) as Oct_Revenue,\\n\\tsum(case when month = \\'nov\\' then revenue else null end) as Nov_Revenue,\\n\\tsum(case when month = \\'dec\\' then revenue else null end) as Dec_Revenue\\nfrom department\\ngroup by id\\norder by id\\n```\\nOracle Solution using PIVOT:\\n\\n```\\nselect id,\\njan as jan_revenue,\\nfeb as feb_revenue,\\nmar as mar_revenue,\\napr as apr_revenue,\\nmay as may_Revenue,\\njun as jun_revenue,\\njul as jul_revenue,\\naug as aug_revenue,\\nsep as sep_revenue,\\noct as oct_revenue,\\nnov as nov_revenue,\\ndec as dec_revenue\\nfrom\\n(select id, revenue, month\\nfrom department) as src\\npivot\\n(min(revenue) \\nfor month in (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec) ) as pvt\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, \\n\\tsum(case when month = \\'jan\\' then revenue else null end) as Jan_Revenue,\\n\\tsum(case when month = \\'feb\\' then revenue else null end) as Feb_Revenue,\\n\\tsum(case when month = \\'mar\\' then revenue else null end) as Mar_Revenue,\\n\\tsum(case when month = \\'apr\\' then revenue else null end) as Apr_Revenue,\\n\\tsum(case when month = \\'may\\' then revenue else null end) as May_Revenue,\\n\\tsum(case when month = \\'jun\\' then revenue else null end) as Jun_Revenue,\\n\\tsum(case when month = \\'jul\\' then revenue else null end) as Jul_Revenue,\\n\\tsum(case when month = \\'aug\\' then revenue else null end) as Aug_Revenue,\\n\\tsum(case when month = \\'sep\\' then revenue else null end) as Sep_Revenue,\\n\\tsum(case when month = \\'oct\\' then revenue else null end) as Oct_Revenue,\\n\\tsum(case when month = \\'nov\\' then revenue else null end) as Nov_Revenue,\\n\\tsum(case when month = \\'dec\\' then revenue else null end) as Dec_Revenue\\nfrom department\\ngroup by id\\norder by id\\n```\n```\\nselect id,\\njan as jan_revenue,\\nfeb as feb_revenue,\\nmar as mar_revenue,\\napr as apr_revenue,\\nmay as may_Revenue,\\njun as jun_revenue,\\njul as jul_revenue,\\naug as aug_revenue,\\nsep as sep_revenue,\\noct as oct_revenue,\\nnov as nov_revenue,\\ndec as dec_revenue\\nfrom\\n(select id, revenue, month\\nfrom department) as src\\npivot\\n(min(revenue) \\nfor month in (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec) ) as pvt\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563289,
                "title": "simple-solution-with-pivot",
                "content": "**Upvote if you feel it easy :)**\\n\\nUsing PIVOT operator to convert month name in rows into columns\\n```\\nSELECT id, JAN AS Jan_Revenue,\\n    FEB AS Feb_Revenue, \\n    MAR AS Mar_Revenue, \\n    APR AS Apr_Revenue, \\n    MAY AS May_Revenue,\\n    JUN AS Jun_Revenue,\\n    JUL AS Jul_Revenue, \\n    AUG AS Aug_Revenue,\\n    SEP AS Sep_Revenue, \\n    OCT AS Oct_Revenue,\\n    NOV AS Nov_Revenue,\\n    DEC AS Dec_Revenue\\nFROM Department\\nPIVOT\\n(\\n    SUM(revenue)\\n    FOR month IN (JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV,DEC)\\n) P\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT id, JAN AS Jan_Revenue,\\n    FEB AS Feb_Revenue, \\n    MAR AS Mar_Revenue, \\n    APR AS Apr_Revenue, \\n    MAY AS May_Revenue,\\n    JUN AS Jun_Revenue,\\n    JUL AS Jul_Revenue, \\n    AUG AS Aug_Revenue,\\n    SEP AS Sep_Revenue, \\n    OCT AS Oct_Revenue,\\n    NOV AS Nov_Revenue,\\n    DEC AS Dec_Revenue\\nFROM Department\\nPIVOT\\n(\\n    SUM(revenue)\\n    FOR month IN (JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV,DEC)\\n) P\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 951839,
                "title": "mysql-case-function-optimal-usage",
                "content": "\\'\\'\\'\\nSELECT id,\\n    MAX(CASE WHEN month = \\'Jan\\' THEN revenue ELSE NULL END) AS Jan_Revenue,\\n    MAX(CASE WHEN month = \\'Feb\\' THEN revenue ELSE NULL END) AS Feb_Revenue,\\n    MAX(CASE WHEN month = \\'Mar\\' THEN revenue ELSE NULL END) AS Mar_Revenue,\\n    MAX(CASE WHEN month = \\'Apr\\' THEN revenue ELSE NULL END) AS Apr_Revenue,\\n    MAX(CASE WHEN month = \\'May\\' THEN revenue ELSE NULL END) AS May_Revenue,\\n    MAX(CASE WHEN month = \\'Jun\\' THEN revenue ELSE NULL END) AS Jun_Revenue,\\n    MAX(CASE WHEN month = \\'Jul\\' THEN revenue ELSE NULL END) AS Jul_Revenue,\\n    MAX(CASE WHEN month = \\'Aug\\' THEN revenue ELSE NULL END) AS Aug_Revenue,\\n    MAX(CASE WHEN month = \\'Sep\\' THEN revenue ELSE NULL END) AS Sep_Revenue,\\n    MAX(CASE WHEN month = \\'Oct\\' THEN revenue ELSE NULL END) AS Oct_Revenue,\\n    MAX(CASE WHEN month = \\'Nov\\' THEN revenue ELSE NULL END) AS Nov_Revenue,\\n    MAX(CASE WHEN month = \\'Dec\\' THEN revenue ELSE NULL END) AS Dec_Revenue\\nFROM Department\\nGROUP BY 1\\nORDER BY 1 ;\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nSELECT id,\\n    MAX(CASE WHEN month = \\'Jan\\' THEN revenue ELSE NULL END) AS Jan_Revenue,\\n    MAX(CASE WHEN month = \\'Feb\\' THEN revenue ELSE NULL END) AS Feb_Revenue,\\n    MAX(CASE WHEN month = \\'Mar\\' THEN revenue ELSE NULL END) AS Mar_Revenue,\\n    MAX(CASE WHEN month = \\'Apr\\' THEN revenue ELSE NULL END) AS Apr_Revenue,\\n    MAX(CASE WHEN month = \\'May\\' THEN revenue ELSE NULL END) AS May_Revenue,\\n    MAX(CASE WHEN month = \\'Jun\\' THEN revenue ELSE NULL END) AS Jun_Revenue,\\n    MAX(CASE WHEN month = \\'Jul\\' THEN revenue ELSE NULL END) AS Jul_Revenue,\\n    MAX(CASE WHEN month = \\'Aug\\' THEN revenue ELSE NULL END) AS Aug_Revenue,\\n    MAX(CASE WHEN month = \\'Sep\\' THEN revenue ELSE NULL END) AS Sep_Revenue,\\n    MAX(CASE WHEN month = \\'Oct\\' THEN revenue ELSE NULL END) AS Oct_Revenue,\\n    MAX(CASE WHEN month = \\'Nov\\' THEN revenue ELSE NULL END) AS Nov_Revenue,\\n    MAX(CASE WHEN month = \\'Dec\\' THEN revenue ELSE NULL END) AS Dec_Revenue\\nFROM Department\\nGROUP BY 1\\nORDER BY 1 ;\\n\\'\\'\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 522780,
                "title": "mssql-solution-easiest-way-without-pivot",
                "content": "```\\nselect id, max(case when month=\\'Jan\\' then revenue end) as \\'Jan_Revenue\\',\\nmax(case when month=\\'Feb\\' then revenue end) as \\'Feb_Revenue\\',\\nmax(case when month=\\'Mar\\' then revenue end) as \\'Mar_Revenue\\',\\nmax(case when month=\\'Apr\\' then revenue end) as \\'Apr_Revenue\\',\\nmax(case when month=\\'May\\' then revenue end) as \\'May_Revenue\\',\\nmax(case when month=\\'Jun\\' then revenue end) as \\'Jun_Revenue\\',\\nmax(case when month=\\'Jul\\' then revenue end) as \\'Jul_Revenue\\',\\nmax(case when month=\\'Aug\\' then revenue end) as \\'Aug_Revenue\\',\\nmax(case when month=\\'Sep\\' then revenue end) as \\'Sep_Revenue\\',\\nmax(case when month=\\'Oct\\' then revenue end) as \\'Oct_Revenue\\',\\nmax(case when month=\\'Nov\\' then revenue end) as \\'Nov_Revenue\\',\\nmax(case when month=\\'Dec\\' then revenue end) as \\'Dec_Revenue\\'\\nfrom department\\ngroup by id\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, max(case when month=\\'Jan\\' then revenue end) as \\'Jan_Revenue\\',\\nmax(case when month=\\'Feb\\' then revenue end) as \\'Feb_Revenue\\',\\nmax(case when month=\\'Mar\\' then revenue end) as \\'Mar_Revenue\\',\\nmax(case when month=\\'Apr\\' then revenue end) as \\'Apr_Revenue\\',\\nmax(case when month=\\'May\\' then revenue end) as \\'May_Revenue\\',\\nmax(case when month=\\'Jun\\' then revenue end) as \\'Jun_Revenue\\',\\nmax(case when month=\\'Jul\\' then revenue end) as \\'Jul_Revenue\\',\\nmax(case when month=\\'Aug\\' then revenue end) as \\'Aug_Revenue\\',\\nmax(case when month=\\'Sep\\' then revenue end) as \\'Sep_Revenue\\',\\nmax(case when month=\\'Oct\\' then revenue end) as \\'Oct_Revenue\\',\\nmax(case when month=\\'Nov\\' then revenue end) as \\'Nov_Revenue\\',\\nmax(case when month=\\'Dec\\' then revenue end) as \\'Dec_Revenue\\'\\nfrom department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459167,
                "title": "oracle-decode",
                "content": "If you are using Oracle, besides using sum(case when...), you can also use DECODE function. See code below:\\n\\nselect id,\\n      sum(decode(month, \\'Jan\\', revenue)) as Jan_revenue,\\n      sum(decode(month, \\'Feb\\', revenue)) as Feb_revenue,\\n      sum(decode(month, \\'Mar\\', revenue)) as Mar_revenue,\\n      sum(decode(month, \\'Apr\\', revenue)) as Apr_revenue,\\n      sum(decode(month, \\'May\\', revenue)) as May_revenue,\\n      sum(decode(month, \\'Jun\\', revenue)) as Jun_revenue,\\n      sum(decode(month, \\'Jul\\', revenue)) as Jul_revenue,\\n      sum(decode(month, \\'Aug\\', revenue)) as Aug_revenue,\\n      sum(decode(month, \\'Sep\\', revenue)) as Sep_revenue,\\n      sum(decode(month, \\'Oct\\', revenue)) as Oct_revenue,\\n      sum(decode(month, \\'Nov\\', revenue)) as Nov_revenue,\\n      sum(decode(month, \\'Dec\\', revenue)) as Dec_revenue\\n      from  Department group by id",
                "solutionTags": [],
                "code": "If you are using Oracle, besides using sum(case when...), you can also use DECODE function. See code below:\\n\\nselect id,\\n      sum(decode(month, \\'Jan\\', revenue)) as Jan_revenue,\\n      sum(decode(month, \\'Feb\\', revenue)) as Feb_revenue,\\n      sum(decode(month, \\'Mar\\', revenue)) as Mar_revenue,\\n      sum(decode(month, \\'Apr\\', revenue)) as Apr_revenue,\\n      sum(decode(month, \\'May\\', revenue)) as May_revenue,\\n      sum(decode(month, \\'Jun\\', revenue)) as Jun_revenue,\\n      sum(decode(month, \\'Jul\\', revenue)) as Jul_revenue,\\n      sum(decode(month, \\'Aug\\', revenue)) as Aug_revenue,\\n      sum(decode(month, \\'Sep\\', revenue)) as Sep_revenue,\\n      sum(decode(month, \\'Oct\\', revenue)) as Oct_revenue,\\n      sum(decode(month, \\'Nov\\', revenue)) as Nov_revenue,\\n      sum(decode(month, \\'Dec\\', revenue)) as Dec_revenue\\n      from  Department group by id",
                "codeTag": "Unknown"
            },
            {
                "id": 422383,
                "title": "mysql-easy-solution",
                "content": "easy to understand solution\\n\\n```\\nSELECT\\n    id,\\n    SUM(IF(month = \\'Jan\\', revenue, null)) AS Jan_Revenue,\\n    SUM(IF(month = \\'Feb\\', revenue, null)) AS Feb_Revenue,\\n    SUM(IF(month = \\'Mar\\', revenue, null)) AS Mar_Revenue,\\n    SUM(IF(month = \\'Apr\\', revenue, null)) AS Apr_Revenue,\\n    SUM(IF(month = \\'May\\', revenue, null)) AS May_Revenue,\\n    SUM(IF(month = \\'Jun\\', revenue, null)) AS Jun_Revenue,\\n    SUM(IF(month = \\'Jul\\', revenue, null)) AS Jul_Revenue,\\n    SUM(IF(month = \\'Aug\\', revenue, null)) AS Aug_Revenue,\\n    SUM(IF(month = \\'Sep\\', revenue, null)) AS Sep_Revenue,\\n    SUM(IF(month = \\'Oct\\', revenue, null)) AS Oct_Revenue,\\n    SUM(IF(month = \\'Nov\\', revenue, null)) AS Nov_Revenue,\\n    SUM(IF(month = \\'Dec\\', revenue, null)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    id,\\n    SUM(IF(month = \\'Jan\\', revenue, null)) AS Jan_Revenue,\\n    SUM(IF(month = \\'Feb\\', revenue, null)) AS Feb_Revenue,\\n    SUM(IF(month = \\'Mar\\', revenue, null)) AS Mar_Revenue,\\n    SUM(IF(month = \\'Apr\\', revenue, null)) AS Apr_Revenue,\\n    SUM(IF(month = \\'May\\', revenue, null)) AS May_Revenue,\\n    SUM(IF(month = \\'Jun\\', revenue, null)) AS Jun_Revenue,\\n    SUM(IF(month = \\'Jul\\', revenue, null)) AS Jul_Revenue,\\n    SUM(IF(month = \\'Aug\\', revenue, null)) AS Aug_Revenue,\\n    SUM(IF(month = \\'Sep\\', revenue, null)) AS Sep_Revenue,\\n    SUM(IF(month = \\'Oct\\', revenue, null)) AS Oct_Revenue,\\n    SUM(IF(month = \\'Nov\\', revenue, null)) AS Nov_Revenue,\\n    SUM(IF(month = \\'Dec\\', revenue, null)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540360,
                "title": "mysql-solution-for-reformat-department-table-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given SQL query aims to retrieve the monthly revenue for each department by summing the revenue for each month. It uses conditional aggregation and the GROUP BY clause to calculate the revenue for each department.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The query selects the department ID (id) and calculates the sum of revenue for each month using conditional aggregation.\\n1. The IF function is used to conditionally include the revenue value based on the month. If the month matches the specified month, the revenue is included; otherwise, it is set to null.\\n1. The revenue for each month is labeled with corresponding aliases (Jan_Revenue, Feb_Revenue, ..., Dec_Revenue).\\n1. The query groups the rows by department ID using the GROUP BY clause.\\n1. The result is a set of rows, where each row represents a department ID along with the monthly revenues.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the query depends on the size of the \"Department\" table, the number of distinct departments, and the efficiency of the database\\'s query execution plan. The query requires scanning the entire \"Department\" table, grouping the rows by department ID, and calculating the conditional sums for each month. The time complexity can vary, but it typically ranges from linear to quadratic based on the number of rows and the efficiency of index usage.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the query depends on the size of the result set, which is determined by the number of distinct departments in the \"Department\" table. The space required to store the result grows linearly with the number of departments.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\nid,\\nsum(if(month = \\'Jan\\', revenue, null)) as Jan_Revenue,\\nsum(if(month = \\'Feb\\', revenue, null)) as Feb_Revenue,\\nsum(if(month = \\'Mar\\', revenue, null)) as Mar_Revenue,\\nsum(if(month = \\'Apr\\', revenue, null)) as Apr_Revenue,\\nsum(if(month = \\'May\\', revenue, null)) as May_Revenue,\\nsum(if(month = \\'Jun\\', revenue, null)) as Jun_Revenue,\\nsum(if(month = \\'Jul\\', revenue, null)) as Jul_Revenue,\\nsum(if(month = \\'Aug\\', revenue, null)) as Aug_Revenue,\\nsum(if(month = \\'Sep\\', revenue, null)) as Sep_Revenue,\\nsum(if(month = \\'Oct\\', revenue, null)) as Oct_Revenue,\\nsum(if(month = \\'Nov\\', revenue, null)) as Nov_Revenue,\\nsum(if(month = \\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom Department\\ngroup by id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\nid,\\nsum(if(month = \\'Jan\\', revenue, null)) as Jan_Revenue,\\nsum(if(month = \\'Feb\\', revenue, null)) as Feb_Revenue,\\nsum(if(month = \\'Mar\\', revenue, null)) as Mar_Revenue,\\nsum(if(month = \\'Apr\\', revenue, null)) as Apr_Revenue,\\nsum(if(month = \\'May\\', revenue, null)) as May_Revenue,\\nsum(if(month = \\'Jun\\', revenue, null)) as Jun_Revenue,\\nsum(if(month = \\'Jul\\', revenue, null)) as Jul_Revenue,\\nsum(if(month = \\'Aug\\', revenue, null)) as Aug_Revenue,\\nsum(if(month = \\'Sep\\', revenue, null)) as Sep_Revenue,\\nsum(if(month = \\'Oct\\', revenue, null)) as Oct_Revenue,\\nsum(if(month = \\'Nov\\', revenue, null)) as Nov_Revenue,\\nsum(if(month = \\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom Department\\ngroup by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3429081,
                "title": "simple-solution-using-pivot",
                "content": "\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect id, Jan as Jan_Revenue,Feb as Feb_Revenue ,Mar as Mar_Revenue,Apr as Apr_Revenue\\n,May as May_Revenue,Jun as Jun_Revenue,Jul as Jul_Revenue,Aug as Aug_Revenue,Sep as Sep_Revenue,\\nOct as Oct_Revenue,  Nov as Nov_Revenue,Dec as Dec_Revenue from department\\nPivot\\n(\\nsum(revenue) for Month in (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec)\\n)As PT\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect id, Jan as Jan_Revenue,Feb as Feb_Revenue ,Mar as Mar_Revenue,Apr as Apr_Revenue\\n,May as May_Revenue,Jun as Jun_Revenue,Jul as Jul_Revenue,Aug as Aug_Revenue,Sep as Sep_Revenue,\\nOct as Oct_Revenue,  Nov as Nov_Revenue,Dec as Dec_Revenue from department\\nPivot\\n(\\nsum(revenue) for Month in (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec)\\n)As PT\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324058,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect id,\\nsum(if(month=\\'Jan\\', revenue, null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\', revenue, null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\', revenue, null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\', revenue, null)) as Apr_Revenue,\\nsum(if(month=\\'May\\', revenue, null)) as May_Revenue,\\nsum(if(month=\\'Jun\\', revenue, null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\', revenue, null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\', revenue, null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\', revenue, null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\', revenue, null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\', revenue, null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom Department \\ngroup by id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect id,\\nsum(if(month=\\'Jan\\', revenue, null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\', revenue, null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\', revenue, null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\', revenue, null)) as Apr_Revenue,\\nsum(if(month=\\'May\\', revenue, null)) as May_Revenue,\\nsum(if(month=\\'Jun\\', revenue, null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\', revenue, null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\', revenue, null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\', revenue, null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\', revenue, null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\', revenue, null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom Department \\ngroup by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2930772,
                "title": "using-pivot-function",
                "content": "\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n    *\\nFROM (SELECT id, \\n             revenue, \\n             CONCAT(month,\\'_Revenue\\') AS month\\n     FROM department) d\\nPIVOT(\\n    SUM(revenue)\\n    FOR month in ([Jan_Revenue],[Feb_Revenue],[Mar_Revenue],\\n                  [Apr_Revenue],[May_Revenue],[Jun_Revenue],\\n                  [Jul_Revenue],[Aug_Revenue],[Sep_Revenue],\\n                  [Oct_Revenue],[Nov_Revenue],[Dec_Revenue])\\n) AS P\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n    *\\nFROM (SELECT id, \\n             revenue, \\n             CONCAT(month,\\'_Revenue\\') AS month\\n     FROM department) d\\nPIVOT(\\n    SUM(revenue)\\n    FOR month in ([Jan_Revenue],[Feb_Revenue],[Mar_Revenue],\\n                  [Apr_Revenue],[May_Revenue],[Jun_Revenue],\\n                  [Jul_Revenue],[Aug_Revenue],[Sep_Revenue],\\n                  [Oct_Revenue],[Nov_Revenue],[Dec_Revenue])\\n) AS P\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497068,
                "title": "mysql-4-solutions-what-is-better",
                "content": "##### \\uD83D\\uDE4B\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F Hello, here are my solutions to the problem.\\n##### Please upvote to motivate me post future solutions. HAPPY CODING \\u2764\\uFE0F\\n##### Any suggestions and improvements are always welcome.\\n##### Solution 1: Sum, case, long, not good \\uD83E\\uDD26\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n##### \\u2705 Runtime: 855 ms, faster than 26.16% of MySQL.\\n```\\nselect\\n    id,\\n    sum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\n    sum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\n    sum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\n    sum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\n    sum(case when month = \\'May\\' then revenue end) as May_Revenue,\\n    sum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\n    sum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\n    sum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\n    sum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\n    sum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\n    sum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\n    sum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom department\\ngroup by 1\\n```\\n##### Solution 2: Max, case, faster \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n##### \\u2705 Runtime: 478 ms, faster than 82.81% of MySQL.\\n```\\nselect\\n    id,\\n    max(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\n    max(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\n    max(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\n    max(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\n    max(case when month = \\'May\\' then revenue end) as May_Revenue,\\n    max(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\n    max(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\n    max(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\n    max(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\n    max(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\n    max(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\n    max(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom department\\ngroup by 1\\n```\\n##### Solution 3: Sum, if, very fast \\uD83C\\uDFAF\\n##### \\u2705 Runtime: 944 ms, faster than 98.44% of MySQL.\\n```\\nselect \\n    id,\\n    sum(if(month=\\'Jan\\', revenue, null)) as Jan_Revenue,\\n    sum(if(month=\\'Feb\\', revenue, null)) as Feb_Revenue,\\n    sum(if(month=\\'Mar\\', revenue, null)) as Mar_Revenue,\\n    sum(if(month=\\'Apr\\', revenue, null)) as Apr_Revenue,\\n    sum(if(month=\\'May\\', revenue, null)) as May_Revenue,\\n    sum(if(month=\\'Jun\\', revenue, null)) as Jun_Revenue,\\n    sum(if(month=\\'Jul\\', revenue, null)) as Jul_Revenue,\\n    sum(if(month=\\'Aug\\', revenue, null)) as Aug_Revenue,\\n    sum(if(month=\\'Sep\\', revenue, null)) as Sep_Revenue,\\n    sum(if(month=\\'Oct\\', revenue, null)) as Oct_Revenue,\\n    sum(if(month=\\'Nov\\', revenue, null)) as Nov_Revenue,\\n    sum(if(month=\\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom department\\ngroup by 1\\n```\\n##### Solution 4: Max, if, very fast \\uD83C\\uDFAF\\n##### \\u2705 Runtime: 423 ms, faster than 97.35% of MySQL.\\n```\\nselect \\n    id,\\n    max(if(month=\\'Jan\\', revenue, null)) as Jan_Revenue,\\n    max(if(month=\\'Feb\\', revenue, null)) as Feb_Revenue,\\n    max(if(month=\\'Mar\\', revenue, null)) as Mar_Revenue,\\n    max(if(month=\\'Apr\\', revenue, null)) as Apr_Revenue,\\n    max(if(month=\\'May\\', revenue, null)) as May_Revenue,\\n    max(if(month=\\'Jun\\', revenue, null)) as Jun_Revenue,\\n    max(if(month=\\'Jul\\', revenue, null)) as Jul_Revenue,\\n    max(if(month=\\'Aug\\', revenue, null)) as Aug_Revenue,\\n    max(if(month=\\'Sep\\', revenue, null)) as Sep_Revenue,\\n    max(if(month=\\'Oct\\', revenue, null)) as Oct_Revenue,\\n    max(if(month=\\'Nov\\', revenue, null)) as Nov_Revenue,\\n    max(if(month=\\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom department\\ngroup by 1\\n```\\n##### I **resend submit** every time and have **different runtime** and really **don\\'t know what** solutiuon **is better** \\uD83E\\uDD37\\uD83C\\uDFFB\\u200D\\u2640\\uFE0F\\n##### If you like the solutions, please upvote \\uD83D\\uDD3C\\n##### For any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    id,\\n    sum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\n    sum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\n    sum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\n    sum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\n    sum(case when month = \\'May\\' then revenue end) as May_Revenue,\\n    sum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\n    sum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\n    sum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\n    sum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\n    sum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\n    sum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\n    sum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom department\\ngroup by 1\\n```\n```\\nselect\\n    id,\\n    max(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\n    max(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\n    max(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\n    max(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\n    max(case when month = \\'May\\' then revenue end) as May_Revenue,\\n    max(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\n    max(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\n    max(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\n    max(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\n    max(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\n    max(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\n    max(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom department\\ngroup by 1\\n```\n```\\nselect \\n    id,\\n    sum(if(month=\\'Jan\\', revenue, null)) as Jan_Revenue,\\n    sum(if(month=\\'Feb\\', revenue, null)) as Feb_Revenue,\\n    sum(if(month=\\'Mar\\', revenue, null)) as Mar_Revenue,\\n    sum(if(month=\\'Apr\\', revenue, null)) as Apr_Revenue,\\n    sum(if(month=\\'May\\', revenue, null)) as May_Revenue,\\n    sum(if(month=\\'Jun\\', revenue, null)) as Jun_Revenue,\\n    sum(if(month=\\'Jul\\', revenue, null)) as Jul_Revenue,\\n    sum(if(month=\\'Aug\\', revenue, null)) as Aug_Revenue,\\n    sum(if(month=\\'Sep\\', revenue, null)) as Sep_Revenue,\\n    sum(if(month=\\'Oct\\', revenue, null)) as Oct_Revenue,\\n    sum(if(month=\\'Nov\\', revenue, null)) as Nov_Revenue,\\n    sum(if(month=\\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom department\\ngroup by 1\\n```\n```\\nselect \\n    id,\\n    max(if(month=\\'Jan\\', revenue, null)) as Jan_Revenue,\\n    max(if(month=\\'Feb\\', revenue, null)) as Feb_Revenue,\\n    max(if(month=\\'Mar\\', revenue, null)) as Mar_Revenue,\\n    max(if(month=\\'Apr\\', revenue, null)) as Apr_Revenue,\\n    max(if(month=\\'May\\', revenue, null)) as May_Revenue,\\n    max(if(month=\\'Jun\\', revenue, null)) as Jun_Revenue,\\n    max(if(month=\\'Jul\\', revenue, null)) as Jul_Revenue,\\n    max(if(month=\\'Aug\\', revenue, null)) as Aug_Revenue,\\n    max(if(month=\\'Sep\\', revenue, null)) as Sep_Revenue,\\n    max(if(month=\\'Oct\\', revenue, null)) as Oct_Revenue,\\n    max(if(month=\\'Nov\\', revenue, null)) as Nov_Revenue,\\n    max(if(month=\\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom department\\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2211820,
                "title": "ms-sql-answer-for-beginner",
                "content": "``` SQL\\nSELECT T.id, \\n    ( SELECT revenue FROM Department WHERE month = \\'Jan\\' AND T.id = id) AS \\'Jan_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Feb\\' AND T.id = id) AS \\'Feb_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Mar\\' AND T.id = id) AS \\'Mar_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Apr\\' AND T.id = id) AS \\'Apr_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'May\\' AND T.id = id) AS \\'May_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Jun\\' AND T.id = id) AS \\'Jun_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Jul\\' AND T.id = id) AS \\'Jul_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Aug\\' AND T.id = id) AS \\'Aug_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Sep\\' AND T.id = id) AS \\'Sep_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Oct\\' AND T.id = id) AS \\'Oct_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Nov\\' AND T.id = id) AS \\'Nov_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Dec\\' AND T.id = id) AS \\'Dec_Revenue\\'\\nFROM (\\n    SELECT DISTINCT id\\n    FROM Department\\n) AS T;\\n```\\n\\n## Explain\\n\\n1. Get all non-duplicate id \\n\\n`SELECT DISTINCT id FROM Department`\\n\\n| id |\\n|----|\\n| 1  |\\n| 2  |\\n| 3  |\\n\\n2. Use subquery in `SELECT` to get `revenue` for each month\\n\\n``` SQL\\nSELECT \\n\\tT.id, \\n    ( SELECT revenue FROM Department WHERE month = \\'Jan\\' AND T.id = id) AS \\'Jan_Revenue\\'\\nFROM (\\n    SELECT DISTINCT id\\n    FROM Department\\n) AS T;\\n```\\n\\n| id | Jan_Revenue |\\n|----|-------------|\\n| 1  | 8000        |\\n| 2  | 9000        |\\n| 3  | null        |\\n\\n## Reference\\n\\n- [SQL Subquery](https://www.dofactory.com/sql/subquery#example)",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "``` SQL\\nSELECT T.id, \\n    ( SELECT revenue FROM Department WHERE month = \\'Jan\\' AND T.id = id) AS \\'Jan_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Feb\\' AND T.id = id) AS \\'Feb_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Mar\\' AND T.id = id) AS \\'Mar_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Apr\\' AND T.id = id) AS \\'Apr_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'May\\' AND T.id = id) AS \\'May_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Jun\\' AND T.id = id) AS \\'Jun_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Jul\\' AND T.id = id) AS \\'Jul_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Aug\\' AND T.id = id) AS \\'Aug_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Sep\\' AND T.id = id) AS \\'Sep_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Oct\\' AND T.id = id) AS \\'Oct_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Nov\\' AND T.id = id) AS \\'Nov_Revenue\\',\\n    ( SELECT revenue FROM Department WHERE month = \\'Dec\\' AND T.id = id) AS \\'Dec_Revenue\\'\\nFROM (\\n    SELECT DISTINCT id\\n    FROM Department\\n) AS T;\\n```\n``` SQL\\nSELECT \\n\\tT.id, \\n    ( SELECT revenue FROM Department WHERE month = \\'Jan\\' AND T.id = id) AS \\'Jan_Revenue\\'\\nFROM (\\n    SELECT DISTINCT id\\n    FROM Department\\n) AS T;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1958063,
                "title": "easy-ms-sql-solution-with-pivot-90-higher",
                "content": "select id,jan as Jan_Revenue , feb as Feb_Revenue , mar as Mar_Revenue , apr as Apr_Revenue\\n, may as May_Revenue , jun as Jun_Revenue , jul as Jul_Revenue , aug as Aug_Revenue ,\\nsep as Sep_Revenue, oct as Oct_Revenue , nov as Nov_Revenue , dec as Dec_Revenue \\nfrom department \\npivot \\n(sum(revenue)\\n  for month \\n  in ([jan],[feb],[mar], [apr], [may], [jun],[jul],[aug],[sep],[oct]\\n  ,[nov],[dec]\\n  \\n  )\\n  )\\n  as pvt",
                "solutionTags": [],
                "code": "select id,jan as Jan_Revenue , feb as Feb_Revenue , mar as Mar_Revenue , apr as Apr_Revenue\\n, may as May_Revenue , jun as Jun_Revenue , jul as Jul_Revenue , aug as Aug_Revenue ,\\nsep as Sep_Revenue, oct as Oct_Revenue , nov as Nov_Revenue , dec as Dec_Revenue \\nfrom department \\npivot \\n(sum(revenue)\\n  for month \\n  in ([jan],[feb],[mar], [apr], [may], [jun],[jul],[aug],[sep],[oct]\\n  ,[nov],[dec]\\n  \\n  )\\n  )\\n  as pvt",
                "codeTag": "Unknown"
            },
            {
                "id": 1896893,
                "title": "simple-mysql-solution-easy-to-understand",
                "content": "```\\nselect id, \\nSUM(IF(month = \"Jan\", revenue, null)) as Jan_revenue, \\nSUM(IF(month = \"Feb\", revenue, null)) as Feb_revenue,\\nSUM(IF(month = \"Mar\", revenue, null)) as Mar_revenue,\\nSUM(IF(month = \"Apr\", revenue, null)) as Apr_revenue,\\nSUM(IF(month = \"May\", revenue, null)) as May_revenue,\\nSUM(IF(month = \"Jun\", revenue, null)) as Jun_revenue,\\nSUM(IF(month = \"Jul\", revenue, null)) as Jul_revenue,\\nSUM(IF(month = \"Aug\", revenue, null)) as Aug_revenue,\\nSUM(IF(month = \"Sep\", revenue, null)) as Sep_revenue,\\nSUM(IF(month = \"Oct\", revenue, null)) as Oct_revenue,\\nSUM(IF(month = \"Nov\", revenue, null)) as Nov_revenue,\\nSUM(IF(month = \"Dec\", revenue, null)) as Dec_revenue\\nfrom department group by id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect id, \\nSUM(IF(month = \"Jan\", revenue, null)) as Jan_revenue, \\nSUM(IF(month = \"Feb\", revenue, null)) as Feb_revenue,\\nSUM(IF(month = \"Mar\", revenue, null)) as Mar_revenue,\\nSUM(IF(month = \"Apr\", revenue, null)) as Apr_revenue,\\nSUM(IF(month = \"May\", revenue, null)) as May_revenue,\\nSUM(IF(month = \"Jun\", revenue, null)) as Jun_revenue,\\nSUM(IF(month = \"Jul\", revenue, null)) as Jul_revenue,\\nSUM(IF(month = \"Aug\", revenue, null)) as Aug_revenue,\\nSUM(IF(month = \"Sep\", revenue, null)) as Sep_revenue,\\nSUM(IF(month = \"Oct\", revenue, null)) as Oct_revenue,\\nSUM(IF(month = \"Nov\", revenue, null)) as Nov_revenue,\\nSUM(IF(month = \"Dec\", revenue, null)) as Dec_revenue\\nfrom department group by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1007238,
                "title": "mysql-easy-solution",
                "content": "```\\nSELECT id, \\n    MAX(IF(month=\"Jan\", revenue, NULL)) AS Jan_Revenue, \\n    MAX(IF(month=\"Feb\", revenue, NULL)) AS Feb_Revenue, \\n    MAX(IF(month=\"Mar\", revenue, NULL)) AS Mar_Revenue,\\n    MAX(IF(month=\"Apr\", revenue, NULL)) AS Apr_Revenue,\\n    MAX(IF(month=\"May\", revenue, NULL)) AS May_Revenue,\\n    MAX(IF(month=\"Jun\", revenue, NULL)) AS Jun_Revenue,\\n    MAX(IF(month=\"Jul\", revenue, NULL)) AS Jul_Revenue,\\n    MAX(IF(month=\"Aug\", revenue, NULL)) AS Aug_Revenue,\\n    MAX(IF(month=\"Sep\", revenue, NULL)) AS Sep_Revenue,\\n    MAX(IF(month=\"Oct\", revenue, NULL)) AS Oct_Revenue,\\n    MAX(IF(month=\"Nov\", revenue, NULL)) AS Nov_Revenue,\\n    MAX(IF(month=\"Dec\", revenue, NULL)) AS Dec_Revenue\\n    \\nFROM Department\\nGROUP BY id\\nORDER BY id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT id, \\n    MAX(IF(month=\"Jan\", revenue, NULL)) AS Jan_Revenue, \\n    MAX(IF(month=\"Feb\", revenue, NULL)) AS Feb_Revenue, \\n    MAX(IF(month=\"Mar\", revenue, NULL)) AS Mar_Revenue,\\n    MAX(IF(month=\"Apr\", revenue, NULL)) AS Apr_Revenue,\\n    MAX(IF(month=\"May\", revenue, NULL)) AS May_Revenue,\\n    MAX(IF(month=\"Jun\", revenue, NULL)) AS Jun_Revenue,\\n    MAX(IF(month=\"Jul\", revenue, NULL)) AS Jul_Revenue,\\n    MAX(IF(month=\"Aug\", revenue, NULL)) AS Aug_Revenue,\\n    MAX(IF(month=\"Sep\", revenue, NULL)) AS Sep_Revenue,\\n    MAX(IF(month=\"Oct\", revenue, NULL)) AS Oct_Revenue,\\n    MAX(IF(month=\"Nov\", revenue, NULL)) AS Nov_Revenue,\\n    MAX(IF(month=\"Dec\", revenue, NULL)) AS Dec_Revenue\\n    \\nFROM Department\\nGROUP BY id\\nORDER BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947684,
                "title": "mysql-left-joins",
                "content": "Simply left joining every month\\n\\n```\\nselect \\nt0.id,\\nt1.revenue as Jan_Revenue,\\nt2.revenue as Feb_Revenue,\\nt3.revenue as Mar_Revenue,\\nt4.revenue as Apr_Revenue,\\nt5.revenue as May_Revenue,\\nt6.revenue as Jun_Revenue,\\nt7.revenue as Jul_Revenue,\\nt8.revenue as Aug_Revenue,\\nt9.revenue as Sep_Revenue,\\nt10.revenue as Oct_Revenue,\\nt11.revenue as Nov_Revenue,\\nt12.revenue as Dec_Revenue\\nfrom Department t0\\nleft join Department t1 on t0.id = t1.id and t1.month = \\'Jan\\'\\nleft join Department t2 on t0.id = t2.id and t2.month = \\'Feb\\'\\nleft join Department t3 on t0.id = t3.id and t3.month = \\'Mar\\'\\nleft join Department t4 on t0.id = t4.id and t4.month = \\'Apr\\'\\nleft join Department t5 on t0.id = t5.id and t5.month = \\'May\\'\\nleft join Department t6 on t0.id = t6.id and t6.month = \\'Jun\\'\\nleft join Department t7 on t0.id = t7.id and t7.month = \\'Jul\\'\\nleft join Department t8 on t0.id = t8.id and t8.month = \\'Aug\\'\\nleft join Department t9 on t0.id = t9.id and t9.month = \\'Sep\\'\\nleft join Department t10 on t0.id = t10.id and t10.month = \\'Oct\\'\\nleft join Department t11 on t0.id = t11.id and t11.month = \\'Nov\\'\\nleft join Department t12 on t0.id = t12.id and t12.month = \\'Dec\\'\\nGROUP BY t0.id\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\nt0.id,\\nt1.revenue as Jan_Revenue,\\nt2.revenue as Feb_Revenue,\\nt3.revenue as Mar_Revenue,\\nt4.revenue as Apr_Revenue,\\nt5.revenue as May_Revenue,\\nt6.revenue as Jun_Revenue,\\nt7.revenue as Jul_Revenue,\\nt8.revenue as Aug_Revenue,\\nt9.revenue as Sep_Revenue,\\nt10.revenue as Oct_Revenue,\\nt11.revenue as Nov_Revenue,\\nt12.revenue as Dec_Revenue\\nfrom Department t0\\nleft join Department t1 on t0.id = t1.id and t1.month = \\'Jan\\'\\nleft join Department t2 on t0.id = t2.id and t2.month = \\'Feb\\'\\nleft join Department t3 on t0.id = t3.id and t3.month = \\'Mar\\'\\nleft join Department t4 on t0.id = t4.id and t4.month = \\'Apr\\'\\nleft join Department t5 on t0.id = t5.id and t5.month = \\'May\\'\\nleft join Department t6 on t0.id = t6.id and t6.month = \\'Jun\\'\\nleft join Department t7 on t0.id = t7.id and t7.month = \\'Jul\\'\\nleft join Department t8 on t0.id = t8.id and t8.month = \\'Aug\\'\\nleft join Department t9 on t0.id = t9.id and t9.month = \\'Sep\\'\\nleft join Department t10 on t0.id = t10.id and t10.month = \\'Oct\\'\\nleft join Department t11 on t0.id = t11.id and t11.month = \\'Nov\\'\\nleft join Department t12 on t0.id = t12.id and t12.month = \\'Dec\\'\\nGROUP BY t0.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920315,
                "title": "ms-sql-pivot-table",
                "content": "```\\n/* Write your T-SQL query statement below */\\n\\nselect id, \\n       Jan as Jan_Revenue,\\n       Feb as Feb_Revenue,\\n       Mar as Mar_Revenue,\\n       Apr as Apr_Revenue,\\n       May as May_Revenue,\\n       Jun as Jun_Revenue,\\n       Jul as Jul_Revenue,\\n       Aug as Aug_Revenue,\\n       Sep as Sep_Revenue,\\n       Oct as Oct_Revenue,\\n       Nov as Nov_Revenue,\\n       Dec as Dec_Revenue\\nfrom (\\n    select id, revenue, month\\n    from department) as department\\npivot (\\n    sum(revenue) \\n    for month \\n    in (\\n        \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"\\n    ) \\n) as pivot_table\\norder by id\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect id, \\n       Jan as Jan_Revenue,\\n       Feb as Feb_Revenue,\\n       Mar as Mar_Revenue,\\n       Apr as Apr_Revenue,\\n       May as May_Revenue,\\n       Jun as Jun_Revenue,\\n       Jul as Jul_Revenue,\\n       Aug as Aug_Revenue,\\n       Sep as Sep_Revenue,\\n       Oct as Oct_Revenue,\\n       Nov as Nov_Revenue,\\n       Dec as Dec_Revenue\\nfrom (\\n    select id, revenue, month\\n    from department) as department\\npivot (\\n    sum(revenue) \\n    for month \\n    in (\\n        \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"\\n    ) \\n) as pivot_table\\norder by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846483,
                "title": "solution-using-case-and-group-by",
                "content": "```\\n# Write your MySQL query statement below\\n\\nselect id,\\nsum(case when month = \\'Jan\\' then revenue else null end) as \"Jan_Revenue\",\\nsum(case when month = \\'Feb\\' then revenue else null end) as \"Feb_Revenue\",\\nsum(case when month = \\'Mar\\' then revenue else null end) as \"Mar_Revenue\",\\nsum(case when month = \\'Apr\\' then revenue else null end) as \"Apr_Revenue\",\\nsum(case when month = \\'May\\' then revenue else null end) as \"May_Revenue\",\\nsum(case when month = \\'Jun\\' then revenue else null end) as \"Jun_Revenue\",\\nsum(case when month = \\'Jul\\' then revenue else null end) as \"Jul_Revenue\",\\nsum(case when month = \\'Aug\\' then revenue else null end) as \"Aug_Revenue\",\\nsum(case when month = \\'Sep\\' then revenue else null end) as \"Sep_Revenue\",\\nsum(case when month = \\'Oct\\' then revenue else null end) as \"Oct_Revenue\",\\nsum(case when month = \\'Nov\\' then revenue else null end) as \"Nov_Revenue\",\\nsum(case when month = \\'Dec\\' then revenue else null end) as \"Dec_Revenue\"\\n\\nfrom Department\\ngroup by id;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect id,\\nsum(case when month = \\'Jan\\' then revenue else null end) as \"Jan_Revenue\",\\nsum(case when month = \\'Feb\\' then revenue else null end) as \"Feb_Revenue\",\\nsum(case when month = \\'Mar\\' then revenue else null end) as \"Mar_Revenue\",\\nsum(case when month = \\'Apr\\' then revenue else null end) as \"Apr_Revenue\",\\nsum(case when month = \\'May\\' then revenue else null end) as \"May_Revenue\",\\nsum(case when month = \\'Jun\\' then revenue else null end) as \"Jun_Revenue\",\\nsum(case when month = \\'Jul\\' then revenue else null end) as \"Jul_Revenue\",\\nsum(case when month = \\'Aug\\' then revenue else null end) as \"Aug_Revenue\",\\nsum(case when month = \\'Sep\\' then revenue else null end) as \"Sep_Revenue\",\\nsum(case when month = \\'Oct\\' then revenue else null end) as \"Oct_Revenue\",\\nsum(case when month = \\'Nov\\' then revenue else null end) as \"Nov_Revenue\",\\nsum(case when month = \\'Dec\\' then revenue else null end) as \"Dec_Revenue\"\\n\\nfrom Department\\ngroup by id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 759781,
                "title": "pivot-table",
                "content": "```sql\\nselect id\\n      ,Jan as Jan_Revenue\\n      ,Feb as Feb_Revenue\\n\\t  ,Mar as Mar_Revenue\\n\\t  ,Apr as Apr_Revenue\\n\\t  ,May as May_Revenue\\n\\t  ,Jun as Jun_Revenue\\n\\t  ,Jul as Jul_Revenue\\n\\t  ,Aug as Aug_Revenue\\n\\t  ,Sep as Sep_Revenue\\n\\t  ,Oct as Oct_Revenue\\n\\t  ,Nov as Nov_Revenue\\n\\t  ,Dec as Dec_Revenue\\nfrom\\n(\\nselect id,revenue,month from Department\\n) t\\npivot \\n(max(revenue)\\n for month in ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) p\\n```",
                "solutionTags": [],
                "code": "```sql\\nselect id\\n      ,Jan as Jan_Revenue\\n      ,Feb as Feb_Revenue\\n\\t  ,Mar as Mar_Revenue\\n\\t  ,Apr as Apr_Revenue\\n\\t  ,May as May_Revenue\\n\\t  ,Jun as Jun_Revenue\\n\\t  ,Jul as Jul_Revenue\\n\\t  ,Aug as Aug_Revenue\\n\\t  ,Sep as Sep_Revenue\\n\\t  ,Oct as Oct_Revenue\\n\\t  ,Nov as Nov_Revenue\\n\\t  ,Dec as Dec_Revenue\\nfrom\\n(\\nselect id,revenue,month from Department\\n) t\\npivot \\n(max(revenue)\\n for month in ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) p\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 733382,
                "title": "mysql-max-groupby",
                "content": "```\\nselect id,\\nmax(case when month = \"Jan\" then revenue else null end) as Jan_revenue,\\nmax(case when month = \"Feb\" then revenue else null end) as Feb_revenue,\\nmax(case when month = \"Mar\" then revenue else null end) as Mar_revenue,\\nmax(case when month = \"Apr\" then revenue else null end) as Apr_revenue,\\nmax(case when month = \"May\" then revenue else null end) as May_revenue,\\nmax(case when month = \"Jun\" then revenue else null end) as Jun_revenue,\\nmax(case when month = \"Jul\" then revenue else null end) as Jul_revenue,\\nmax(case when month = \"Aug\" then revenue else null end) as Aug_revenue,\\nmax(case when month = \"Sep\" then revenue else null end) as Sep_revenue,\\nmax(case when month = \"Oct\" then revenue else null end) as Oct_revenue,\\nmax(case when month = \"Nov\" then revenue else null end) as Nov_revenue,\\nmax(case when month = \"Dec\" then revenue else null end) as Dec_revenue\\nfrom department\\ngroup by id\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,\\nmax(case when month = \"Jan\" then revenue else null end) as Jan_revenue,\\nmax(case when month = \"Feb\" then revenue else null end) as Feb_revenue,\\nmax(case when month = \"Mar\" then revenue else null end) as Mar_revenue,\\nmax(case when month = \"Apr\" then revenue else null end) as Apr_revenue,\\nmax(case when month = \"May\" then revenue else null end) as May_revenue,\\nmax(case when month = \"Jun\" then revenue else null end) as Jun_revenue,\\nmax(case when month = \"Jul\" then revenue else null end) as Jul_revenue,\\nmax(case when month = \"Aug\" then revenue else null end) as Aug_revenue,\\nmax(case when month = \"Sep\" then revenue else null end) as Sep_revenue,\\nmax(case when month = \"Oct\" then revenue else null end) as Oct_revenue,\\nmax(case when month = \"Nov\" then revenue else null end) as Nov_revenue,\\nmax(case when month = \"Dec\" then revenue else null end) as Dec_revenue\\nfrom department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545712,
                "title": "mysql-easy-solution",
                "content": "```\\nSELECT d.id as \\'id\\',\\n      d1.revenue as \\'Jan_Revenue\\',\\n      d2.revenue as \\'feb_Revenue\\',\\n      d3.revenue as \\'Mar_Revenue\\',\\n      d4.revenue as \\'Apr_Revenue\\',\\n      d5.revenue as \\'May_Revenue\\',\\n      d6.revenue as \\'Jun_Revenue\\',\\n      d7.revenue as \\'Jul_Revenue\\',\\n      d8.revenue as \\'Aug_Revenue\\',\\n      d9.revenue as \\'Sep_Revenue\\',\\n      d10.revenue as \\'Oct_Revenue\\',\\n      d11.revenue as \\'Nov_Revenue\\',\\n      d12.revenue as \\'Dec_Revenue\\'\\nFROM Department d\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Jan\\') d1 on d1.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Feb\\') d2 on d2.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Mar\\') d3 on d3.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Apr\\') d4 on d4.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'May\\') d5 on d5.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Jun\\') d6 on d6.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Jul\\') d7 on d7.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Aug\\') d8 on d8.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Sep\\') d9 on d9.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Oct\\') d10 on d10.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Nov\\') d11 on d11.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Dec\\') d12 on d12.id = d.id\\nGROUP BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT d.id as \\'id\\',\\n      d1.revenue as \\'Jan_Revenue\\',\\n      d2.revenue as \\'feb_Revenue\\',\\n      d3.revenue as \\'Mar_Revenue\\',\\n      d4.revenue as \\'Apr_Revenue\\',\\n      d5.revenue as \\'May_Revenue\\',\\n      d6.revenue as \\'Jun_Revenue\\',\\n      d7.revenue as \\'Jul_Revenue\\',\\n      d8.revenue as \\'Aug_Revenue\\',\\n      d9.revenue as \\'Sep_Revenue\\',\\n      d10.revenue as \\'Oct_Revenue\\',\\n      d11.revenue as \\'Nov_Revenue\\',\\n      d12.revenue as \\'Dec_Revenue\\'\\nFROM Department d\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Jan\\') d1 on d1.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Feb\\') d2 on d2.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Mar\\') d3 on d3.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Apr\\') d4 on d4.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'May\\') d5 on d5.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Jun\\') d6 on d6.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Jul\\') d7 on d7.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Aug\\') d8 on d8.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Sep\\') d9 on d9.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Oct\\') d10 on d10.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Nov\\') d11 on d11.id = d.id\\nLEFT JOIN (SELECT * FROM Department WHERE month = \\'Dec\\') d12 on d12.id = d.id\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378001,
                "title": "ms-sql-complicated-solution",
                "content": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT id as id,\\nJan as Jan_Revenue,\\nFeb as Feb_Revenue,\\nMar as Mar_Revenue,\\nApr as Apr_Revenue,\\nMay as May_Revenue,\\nJun as Jun_Revenue,\\nJul as Jul_Revenue,\\nAug as Aug_Revenue,\\nSep as Sep_Revenue,\\nOct as Oct_Revenue,\\nNov as Nov_Revenue,\\nDec as Dec_Revenue\\nFROM (\\nSELECT id, month, revenue\\nFROM Department\\n) AS SOURCETABLE PIVOT (\\n    AVG(revenue)\\nFOR month IN ([Jan],\\n        [Feb],\\n        [Mar],\\n        [Apr],\\n        [May],\\n        [Jun],\\n        [Jul] ,\\n        [Aug] ,\\n        [Sep] ,\\n        [Oct] ,\\n        [Nov] ,\\n        [Dec] )) AS PIVOT_TABLE\\n    \\n\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT id as id,\\nJan as Jan_Revenue,\\nFeb as Feb_Revenue,\\nMar as Mar_Revenue,\\nApr as Apr_Revenue,\\nMay as May_Revenue,\\nJun as Jun_Revenue,\\nJul as Jul_Revenue,\\nAug as Aug_Revenue,\\nSep as Sep_Revenue,\\nOct as Oct_Revenue,\\nNov as Nov_Revenue,\\nDec as Dec_Revenue\\nFROM (\\nSELECT id, month, revenue\\nFROM Department\\n) AS SOURCETABLE PIVOT (\\n    AVG(revenue)\\nFOR month IN ([Jan],\\n        [Feb],\\n        [Mar],\\n        [Apr],\\n        [May],\\n        [Jun],\\n        [Jul] ,\\n        [Aug] ,\\n        [Sep] ,\\n        [Oct] ,\\n        [Nov] ,\\n        [Dec] )) AS PIVOT_TABLE\\n    \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609112,
                "title": "easy-mysql-solution-select-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect id,\\nsum(case when month=\"Jan\" then revenue else null end) as Jan_Revenue,\\nsum(case when month=\"Feb\" then revenue else null end) as Feb_Revenue,\\nsum(case when month=\"Mar\" then revenue else null end) as Mar_Revenue,\\nsum(case when month=\"Apr\" then revenue else null end) as Apr_Revenue,\\nsum(case when month=\"May\" then revenue else null end) as May_Revenue,\\nsum(case when month=\"Jun\" then revenue else null end) as Jun_Revenue,\\nsum(case when month=\"Jul\" then revenue else null end) as Jul_Revenue,\\nsum(case when month=\"Aug\" then revenue else null end) as Aug_Revenue,\\nsum(case when month=\"Sep\" then revenue else null end) as Sep_Revenue,\\nsum(case when month=\"Oct\" then revenue else null end) as Oct_Revenue,\\nsum(case when month=\"Nov\" then revenue else null end) as Nov_Revenue,\\nsum(case when month=\"Dec\" then revenue else null end) as Dec_Revenue\\nfrom Department group by id order by id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect id,\\nsum(case when month=\"Jan\" then revenue else null end) as Jan_Revenue,\\nsum(case when month=\"Feb\" then revenue else null end) as Feb_Revenue,\\nsum(case when month=\"Mar\" then revenue else null end) as Mar_Revenue,\\nsum(case when month=\"Apr\" then revenue else null end) as Apr_Revenue,\\nsum(case when month=\"May\" then revenue else null end) as May_Revenue,\\nsum(case when month=\"Jun\" then revenue else null end) as Jun_Revenue,\\nsum(case when month=\"Jul\" then revenue else null end) as Jul_Revenue,\\nsum(case when month=\"Aug\" then revenue else null end) as Aug_Revenue,\\nsum(case when month=\"Sep\" then revenue else null end) as Sep_Revenue,\\nsum(case when month=\"Oct\" then revenue else null end) as Oct_Revenue,\\nsum(case when month=\"Nov\" then revenue else null end) as Nov_Revenue,\\nsum(case when month=\"Dec\" then revenue else null end) as Dec_Revenue\\nfrom Department group by id order by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2924525,
                "title": "reformat-department-table-level-solution-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect id,\\n    sum(case `month` when \\'Jan\\' then revenue end) as Jan_Revenue,\\n    sum(case `month` when \\'Feb\\' then revenue end) as Feb_Revenue,\\n    sum(case `month` when \\'Mar\\' then revenue end) as Mar_Revenue,\\n    sum(case `month` when \\'Apr\\' then revenue end) as Apr_Revenue,\\n    sum(case `month` when \\'May\\' then revenue end) as May_Revenue,\\n    sum(case `month` when \\'Jun\\' then revenue end) as Jun_Revenue,\\n    sum(case `month` when \\'Jul\\' then revenue end) as Jul_Revenue,\\n    sum(case `month` when \\'Aug\\' then revenue end) as Aug_Revenue,\\n    sum(case `month` when \\'Sep\\' then revenue end) as Sep_Revenue,\\n    sum(case `month` when \\'Oct\\' then revenue end) as Oct_Revenue,\\n    sum(case `month` when \\'Nov\\' then revenue end) as Nov_Revenue,\\n    sum(case `month` when \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department group by id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect id,\\n    sum(case `month` when \\'Jan\\' then revenue end) as Jan_Revenue,\\n    sum(case `month` when \\'Feb\\' then revenue end) as Feb_Revenue,\\n    sum(case `month` when \\'Mar\\' then revenue end) as Mar_Revenue,\\n    sum(case `month` when \\'Apr\\' then revenue end) as Apr_Revenue,\\n    sum(case `month` when \\'May\\' then revenue end) as May_Revenue,\\n    sum(case `month` when \\'Jun\\' then revenue end) as Jun_Revenue,\\n    sum(case `month` when \\'Jul\\' then revenue end) as Jul_Revenue,\\n    sum(case `month` when \\'Aug\\' then revenue end) as Aug_Revenue,\\n    sum(case `month` when \\'Sep\\' then revenue end) as Sep_Revenue,\\n    sum(case `month` when \\'Oct\\' then revenue end) as Oct_Revenue,\\n    sum(case `month` when \\'Nov\\' then revenue end) as Nov_Revenue,\\n    sum(case `month` when \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department group by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2850042,
                "title": "very-very-simple-mysql-solution-easy-to-undersyand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect id,sum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,sum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,sum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,sum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,sum(if(month=\\'May\\',revenue,null)) as May_Revenue,sum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,sum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,sum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,sum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,sum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,sum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,sum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue from Department group by id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect id,sum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,sum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,sum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,sum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,sum(if(month=\\'May\\',revenue,null)) as May_Revenue,sum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,sum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,sum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,sum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,sum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,sum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,sum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue from Department group by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2310743,
                "title": "simple-and-faster-solution",
                "content": "# Write your MySQL query statement below\\nSELECT id, SUM(CASE WHEN month=\\'Jan\\' THEN revenue ELSE NULL END) AS \"Jan_Revenue\",\\nSUM(CASE WHEN month=\\'Feb\\' THEN revenue ELSE NULL END) AS \"Feb_Revenue\",\\nSUM(CASE WHEN month=\\'Mar\\' THEN revenue ELSE NULL END) AS \"Mar_Revenue\",\\nSUM(CASE WHEN month=\\'Apr\\' THEN revenue ELSE NULL  END) AS \"Apr_Revenue\",\\nSUM(CASE WHEN month=\\'May\\' THEN revenue ELSE NULL END) AS \"May_Revenue\",\\nSUM(CASE WHEN month=\\'Jun\\' THEN revenue ELSE NULL END) AS \"Jun_Revenue\",\\nSUM(CASE WHEN month=\\'Jul\\' THEN revenue ELSE NULL END) AS \"Jul_Revenue\",\\nSUM(CASE WHEN month=\\'Aug\\' THEN revenue ELSE NULL END) AS \"Aug_Revenue\",\\nSUM(CASE WHEN month=\\'Sep\\' THEN revenue ELSE NULL END) AS \"Sep_Revenue\",\\nSUM(CASE WHEN month=\\'Oct\\' THEN revenue ELSE NULL END) AS \"Oct_Revenue\",\\nSUM(CASE WHEN month=\\'Nov\\' THEN revenue ELSE NULL END) AS \"Nov_Revenue\",\\nSUM(CASE WHEN month=\\'Dec\\' THEN revenue ELSE NULL END) AS \"Dec_Revenue\"\\nFROM Department\\nGROUP BY 1",
                "solutionTags": [],
                "code": "# Write your MySQL query statement below\\nSELECT id, SUM(CASE WHEN month=\\'Jan\\' THEN revenue ELSE NULL END) AS \"Jan_Revenue\",\\nSUM(CASE WHEN month=\\'Feb\\' THEN revenue ELSE NULL END) AS \"Feb_Revenue\",\\nSUM(CASE WHEN month=\\'Mar\\' THEN revenue ELSE NULL END) AS \"Mar_Revenue\",\\nSUM(CASE WHEN month=\\'Apr\\' THEN revenue ELSE NULL  END) AS \"Apr_Revenue\",\\nSUM(CASE WHEN month=\\'May\\' THEN revenue ELSE NULL END) AS \"May_Revenue\",\\nSUM(CASE WHEN month=\\'Jun\\' THEN revenue ELSE NULL END) AS \"Jun_Revenue\",\\nSUM(CASE WHEN month=\\'Jul\\' THEN revenue ELSE NULL END) AS \"Jul_Revenue\",\\nSUM(CASE WHEN month=\\'Aug\\' THEN revenue ELSE NULL END) AS \"Aug_Revenue\",\\nSUM(CASE WHEN month=\\'Sep\\' THEN revenue ELSE NULL END) AS \"Sep_Revenue\",\\nSUM(CASE WHEN month=\\'Oct\\' THEN revenue ELSE NULL END) AS \"Oct_Revenue\",\\nSUM(CASE WHEN month=\\'Nov\\' THEN revenue ELSE NULL END) AS \"Nov_Revenue\",\\nSUM(CASE WHEN month=\\'Dec\\' THEN revenue ELSE NULL END) AS \"Dec_Revenue\"\\nFROM Department\\nGROUP BY 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2258940,
                "title": "simple-approach-sum-if-as",
                "content": "select id,\\nSUM(IF(month=\\'Jan\\',revenue,NULL))AS \\'Jan_Revenue\\',\\nSUM(IF(month=\\'Feb\\',revenue,NULL))AS \\'Feb_Revenue\\',\\nSUM(IF(month=\\'Mar\\',revenue,NULL))AS \\'Mar_Revenue\\',\\nSUM(IF(month=\\'Apr\\',revenue,NULL))AS \\'Apr_Revenue\\',\\nSUM(IF(month=\\'May\\',revenue,NULL))AS \\'May_Revenue\\',\\nSUM(IF(month=\\'Jun\\',revenue,NULL))AS \\'Jun_Revenue\\',\\nSUM(IF(month=\\'Jul\\',revenue,NULL))AS \\'Jul_Revenue\\',\\nSUM(IF(month=\\'Aug\\',revenue,NULL))AS \\'Aug_Revenue\\',\\nSUM(IF(month=\\'Sep\\',revenue,NULL))AS \\'Sep_Revenue\\',\\nSUM(IF(month=\\'Oct\\',revenue,NULL))AS \\'Oct_Revenue\\',\\nSUM(IF(month=\\'Nov\\',revenue,NULL))AS \\'Nov_Revenue\\',\\nSUM(IF(month=\\'Dec\\',revenue,NULL))AS \\'Dec_Revenue\\'\\nfrom Department\\ngroup by id",
                "solutionTags": [],
                "code": "select id,\\nSUM(IF(month=\\'Jan\\',revenue,NULL))AS \\'Jan_Revenue\\',\\nSUM(IF(month=\\'Feb\\',revenue,NULL))AS \\'Feb_Revenue\\',\\nSUM(IF(month=\\'Mar\\',revenue,NULL))AS \\'Mar_Revenue\\',\\nSUM(IF(month=\\'Apr\\',revenue,NULL))AS \\'Apr_Revenue\\',\\nSUM(IF(month=\\'May\\',revenue,NULL))AS \\'May_Revenue\\',\\nSUM(IF(month=\\'Jun\\',revenue,NULL))AS \\'Jun_Revenue\\',\\nSUM(IF(month=\\'Jul\\',revenue,NULL))AS \\'Jul_Revenue\\',\\nSUM(IF(month=\\'Aug\\',revenue,NULL))AS \\'Aug_Revenue\\',\\nSUM(IF(month=\\'Sep\\',revenue,NULL))AS \\'Sep_Revenue\\',\\nSUM(IF(month=\\'Oct\\',revenue,NULL))AS \\'Oct_Revenue\\',\\nSUM(IF(month=\\'Nov\\',revenue,NULL))AS \\'Nov_Revenue\\',\\nSUM(IF(month=\\'Dec\\',revenue,NULL))AS \\'Dec_Revenue\\'\\nfrom Department\\ngroup by id",
                "codeTag": "Unknown"
            },
            {
                "id": 2190863,
                "title": "ms-sql-server-easy-solution-with-iif",
                "content": "```\\n/* Write your T-SQL query statement below */\\nSELECT id, \\nSUM(IIF (month = \\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IIF (month = \\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IIF (month = \\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IIF (month = \\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IIF (month = \\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IIF (month = \\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IIF (month = \\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IIF (month = \\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IIF (month = \\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IIF (month = \\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IIF (month = \\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IIF (month = \\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM\\nDepartment\\nGROUP BY id",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT id, \\nSUM(IIF (month = \\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IIF (month = \\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IIF (month = \\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IIF (month = \\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IIF (month = \\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IIF (month = \\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IIF (month = \\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IIF (month = \\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IIF (month = \\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IIF (month = \\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IIF (month = \\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IIF (month = \\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM\\nDepartment\\nGROUP BY id",
                "codeTag": "Unknown"
            },
            {
                "id": 2094784,
                "title": "mysql-sum-if-simple-solution",
                "content": "```\\nselect id, \\nSum(if(month=\\'jan\\',revenue,Null)) as Jan_Revenue,\\nSum(if(month=\\'feb\\',revenue,Null)) as Feb_Revenue,\\nSum(if(month=\\'mar\\',revenue,Null)) as Mar_Revenue,\\nSum(if(month=\\'apr\\',revenue,Null)) as Apr_Revenue,\\nSum(if(month=\\'may\\',revenue,Null)) as May_Revenue,\\nSum(if(month=\\'jun\\',revenue,Null)) as Jun_Revenue,\\nSum(if(month=\\'jul\\',revenue,Null)) as Jul_Revenue,\\nSum(if(month=\\'aug\\',revenue,Null)) as Aug_Revenue,\\nSum(if(month=\\'sep\\',revenue,Null)) as Sep_Revenue,\\nSum(if(month=\\'oct\\',revenue,Null)) as Oct_Revenue,\\nSum(if(month=\\'nov\\',revenue,Null)) as Nov_Revenue,\\nSum(if(month=\\'dec\\',revenue,Null)) as Dec_Revenue\\nfrom department\\ngroup by id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect id, \\nSum(if(month=\\'jan\\',revenue,Null)) as Jan_Revenue,\\nSum(if(month=\\'feb\\',revenue,Null)) as Feb_Revenue,\\nSum(if(month=\\'mar\\',revenue,Null)) as Mar_Revenue,\\nSum(if(month=\\'apr\\',revenue,Null)) as Apr_Revenue,\\nSum(if(month=\\'may\\',revenue,Null)) as May_Revenue,\\nSum(if(month=\\'jun\\',revenue,Null)) as Jun_Revenue,\\nSum(if(month=\\'jul\\',revenue,Null)) as Jul_Revenue,\\nSum(if(month=\\'aug\\',revenue,Null)) as Aug_Revenue,\\nSum(if(month=\\'sep\\',revenue,Null)) as Sep_Revenue,\\nSum(if(month=\\'oct\\',revenue,Null)) as Oct_Revenue,\\nSum(if(month=\\'nov\\',revenue,Null)) as Nov_Revenue,\\nSum(if(month=\\'dec\\',revenue,Null)) as Dec_Revenue\\nfrom department\\ngroup by id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978380,
                "title": "mysql-solution-2-approaches",
                "content": "```\\n# Write your MySQL query statement below\\n\\n# Solution 1\\n\\nSELECT\\nid,\\nSUM(CASE WHEN month = \\'Jan\\' THEN revenue ELSE NULL END) AS Jan_Revenue,\\nSUM(CASE WHEN month = \\'Feb\\' THEN revenue ELSE NULL END) AS Feb_Revenue,\\nSUM(CASE WHEN month = \\'Mar\\' THEN revenue ELSE NULL END) AS Mar_Revenue,\\nSUM(CASE WHEN month = \\'Apr\\' THEN revenue ELSE NULL END) AS Apr_Revenue,\\nSUM(CASE WHEN month = \\'May\\' THEN revenue ELSE NULL END) AS May_Revenue,\\nSUM(CASE WHEN month = \\'Jun\\' THEN revenue ELSE NULL END) AS Jun_Revenue,\\nSUM(CASE WHEN month = \\'Jul\\' THEN revenue ELSE NULL END) AS Jul_Revenue,\\nSUM(CASE WHEN month = \\'Aug\\' THEN revenue ELSE NULL END) AS Aug_Revenue,\\nSUM(CASE WHEN month = \\'Sep\\' THEN revenue ELSE NULL END) AS Sep_Revenue,\\nSUM(CASE WHEN month = \\'Oct\\' THEN revenue ELSE NULL END) AS Oct_Revenue,\\nSUM(CASE WHEN month = \\'Nov\\' THEN revenue ELSE NULL END) AS Nov_Revenue,\\nSUM(CASE WHEN month = \\'Dec\\' THEN revenue ELSE NULL END) AS Dec_Revenue\\n\\nFROM\\nDepartment\\nGROUP BY 1\\n\\n# Solution 2\\n\\nSELECT \\n    id, \\n    sum( if( month = \\'Jan\\', revenue, null ) ) AS Jan_Revenue,\\n    sum( if( month = \\'Feb\\', revenue, null ) ) AS Feb_Revenue,\\n    sum( if( month = \\'Mar\\', revenue, null ) ) AS Mar_Revenue,\\n    sum( if( month = \\'Apr\\', revenue, null ) ) AS Apr_Revenue,\\n    sum( if( month = \\'May\\', revenue, null ) ) AS May_Revenue,\\n    sum( if( month = \\'Jun\\', revenue, null ) ) AS Jun_Revenue,\\n    sum( if( month = \\'Jul\\', revenue, null ) ) AS Jul_Revenue,\\n    sum( if( month = \\'Aug\\', revenue, null ) ) AS Aug_Revenue,\\n    sum( if( month = \\'Sep\\', revenue, null ) ) AS Sep_Revenue,\\n    sum( if( month = \\'Oct\\', revenue, null ) ) AS Oct_Revenue,\\n    sum( if( month = \\'Nov\\', revenue, null ) ) AS Nov_Revenue,\\n    sum( if( month = \\'Dec\\', revenue, null ) ) AS Dec_Revenue\\nFROM \\nDepartment\\nGROUP BY 1\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\n# Solution 1\\n\\nSELECT\\nid,\\nSUM(CASE WHEN month = \\'Jan\\' THEN revenue ELSE NULL END) AS Jan_Revenue,\\nSUM(CASE WHEN month = \\'Feb\\' THEN revenue ELSE NULL END) AS Feb_Revenue,\\nSUM(CASE WHEN month = \\'Mar\\' THEN revenue ELSE NULL END) AS Mar_Revenue,\\nSUM(CASE WHEN month = \\'Apr\\' THEN revenue ELSE NULL END) AS Apr_Revenue,\\nSUM(CASE WHEN month = \\'May\\' THEN revenue ELSE NULL END) AS May_Revenue,\\nSUM(CASE WHEN month = \\'Jun\\' THEN revenue ELSE NULL END) AS Jun_Revenue,\\nSUM(CASE WHEN month = \\'Jul\\' THEN revenue ELSE NULL END) AS Jul_Revenue,\\nSUM(CASE WHEN month = \\'Aug\\' THEN revenue ELSE NULL END) AS Aug_Revenue,\\nSUM(CASE WHEN month = \\'Sep\\' THEN revenue ELSE NULL END) AS Sep_Revenue,\\nSUM(CASE WHEN month = \\'Oct\\' THEN revenue ELSE NULL END) AS Oct_Revenue,\\nSUM(CASE WHEN month = \\'Nov\\' THEN revenue ELSE NULL END) AS Nov_Revenue,\\nSUM(CASE WHEN month = \\'Dec\\' THEN revenue ELSE NULL END) AS Dec_Revenue\\n\\nFROM\\nDepartment\\nGROUP BY 1\\n\\n# Solution 2\\n\\nSELECT \\n    id, \\n    sum( if( month = \\'Jan\\', revenue, null ) ) AS Jan_Revenue,\\n    sum( if( month = \\'Feb\\', revenue, null ) ) AS Feb_Revenue,\\n    sum( if( month = \\'Mar\\', revenue, null ) ) AS Mar_Revenue,\\n    sum( if( month = \\'Apr\\', revenue, null ) ) AS Apr_Revenue,\\n    sum( if( month = \\'May\\', revenue, null ) ) AS May_Revenue,\\n    sum( if( month = \\'Jun\\', revenue, null ) ) AS Jun_Revenue,\\n    sum( if( month = \\'Jul\\', revenue, null ) ) AS Jul_Revenue,\\n    sum( if( month = \\'Aug\\', revenue, null ) ) AS Aug_Revenue,\\n    sum( if( month = \\'Sep\\', revenue, null ) ) AS Sep_Revenue,\\n    sum( if( month = \\'Oct\\', revenue, null ) ) AS Oct_Revenue,\\n    sum( if( month = \\'Nov\\', revenue, null ) ) AS Nov_Revenue,\\n    sum( if( month = \\'Dec\\', revenue, null ) ) AS Dec_Revenue\\nFROM \\nDepartment\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878138,
                "title": "simple-use-of-case",
                "content": "select id,\\nsum(case when month=\\'jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month=\\'feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month=\\'mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month=\\'apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month=\\'may\\' then revenue end) as May_Revenue,\\nsum(case when month=\\'jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month=\\'jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month=\\'aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month=\\'sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month=\\'oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month=\\'nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month=\\'dec\\' then revenue end) as Dec_Revenue\\nfrom department\\ngroup by 1 order by 1\\n",
                "solutionTags": [],
                "code": "select id,\\nsum(case when month=\\'jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month=\\'feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month=\\'mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month=\\'apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month=\\'may\\' then revenue end) as May_Revenue,\\nsum(case when month=\\'jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month=\\'jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month=\\'aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month=\\'sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month=\\'oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month=\\'nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month=\\'dec\\' then revenue end) as Dec_Revenue\\nfrom department\\ngroup by 1 order by 1\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1858915,
                "title": "simple-case-when-solution",
                "content": "select id, \\nsum(case when month = \"Jan\" then revenue end) as Jan_Revenue,\\nsum(case when month = \"Feb\" then revenue end) as Feb_Revenue,\\nsum(case when month = \"Mar\" then revenue end) as Mar_Revenue,\\nsum(case when month = \"Apr\" then revenue end) as Apr_Revenue,\\nsum(case when month = \"May\" then revenue end) as May_Revenue,\\nsum(case when month = \"Jun\" then revenue end) as Jun_Revenue,\\nsum(case when month = \"Jul\" then revenue end) as Jul_Revenue,\\nsum(case when month = \"Aug\" then revenue end) as Aug_Revenue,\\nsum(case when month = \"Sep\" then revenue end) as Sep_Revenue,\\nsum(case when month = \"Oct\" then revenue end) as Oct_Revenue,\\nsum(case when month = \"Nov\" then revenue end) as Nov_Revenue,\\nsum(case when month = \"Dec\" then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id",
                "solutionTags": [],
                "code": "select id, \\nsum(case when month = \"Jan\" then revenue end) as Jan_Revenue,\\nsum(case when month = \"Feb\" then revenue end) as Feb_Revenue,\\nsum(case when month = \"Mar\" then revenue end) as Mar_Revenue,\\nsum(case when month = \"Apr\" then revenue end) as Apr_Revenue,\\nsum(case when month = \"May\" then revenue end) as May_Revenue,\\nsum(case when month = \"Jun\" then revenue end) as Jun_Revenue,\\nsum(case when month = \"Jul\" then revenue end) as Jul_Revenue,\\nsum(case when month = \"Aug\" then revenue end) as Aug_Revenue,\\nsum(case when month = \"Sep\" then revenue end) as Sep_Revenue,\\nsum(case when month = \"Oct\" then revenue end) as Oct_Revenue,\\nsum(case when month = \"Nov\" then revenue end) as Nov_Revenue,\\nsum(case when month = \"Dec\" then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id",
                "codeTag": "Unknown"
            },
            {
                "id": 1784389,
                "title": "mysql-simple-query-using-if-statement",
                "content": "```\\nSELECT id,\\n        SUM(IF(month = \"Jan\", revenue, null)) AS Jan_Revenue,\\n        SUM(IF(month = \"Feb\", revenue, null)) AS Feb_Revenue,\\n        SUM(IF(month = \"Mar\", revenue, null)) AS Mar_Revenue,\\n        SUM(IF(month = \"Apr\", revenue, null)) AS Apr_Revenue,\\n        SUM(IF(month = \"May\", revenue, null)) AS May_Revenue,\\n        SUM(IF(month = \"Jun\", revenue, null)) AS Jun_Revenue,\\n        SUM(IF(month = \"Jul\", revenue, null)) AS Jul_Revenue,\\n        SUM(IF(month = \"Aug\", revenue, null)) AS Aug_Revenue,\\n        SUM(IF(month = \"Sep\", revenue, null)) AS Sep_Revenue,\\n        SUM(IF(month = \"Oct\", revenue, null)) AS Oct_Revenue,\\n        SUM(IF(month = \"Nov\", revenue, null)) AS Nov_Revenue,\\n        SUM(IF(month = \"Dec\", revenue, null)) AS Dec_Revenue\\nFROM Department \\nGROUP BY 1 \\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT id,\\n        SUM(IF(month = \"Jan\", revenue, null)) AS Jan_Revenue,\\n        SUM(IF(month = \"Feb\", revenue, null)) AS Feb_Revenue,\\n        SUM(IF(month = \"Mar\", revenue, null)) AS Mar_Revenue,\\n        SUM(IF(month = \"Apr\", revenue, null)) AS Apr_Revenue,\\n        SUM(IF(month = \"May\", revenue, null)) AS May_Revenue,\\n        SUM(IF(month = \"Jun\", revenue, null)) AS Jun_Revenue,\\n        SUM(IF(month = \"Jul\", revenue, null)) AS Jul_Revenue,\\n        SUM(IF(month = \"Aug\", revenue, null)) AS Aug_Revenue,\\n        SUM(IF(month = \"Sep\", revenue, null)) AS Sep_Revenue,\\n        SUM(IF(month = \"Oct\", revenue, null)) AS Oct_Revenue,\\n        SUM(IF(month = \"Nov\", revenue, null)) AS Nov_Revenue,\\n        SUM(IF(month = \"Dec\", revenue, null)) AS Dec_Revenue\\nFROM Department \\nGROUP BY 1 \\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1722619,
                "title": "case-statements",
                "content": "```\\nselect id, \\nsum(Case when month=\\'Jan\\' then revenue else null end) as \\'Jan_Revenue\\',\\nsum(Case when month=\\'Feb\\' then revenue else null end) as \\'Feb_Revenue\\',\\nsum(Case when month=\\'Mar\\' then revenue else null end) as \\'Mar_Revenue\\',\\nsum(Case when month=\\'Apr\\' then revenue else null end) as \\'Apr_Revenue\\',\\nsum(Case when month=\\'May\\' then revenue else null end) as \\'May_Revenue\\',\\nsum(Case when month=\\'Jun\\' then revenue else null end) as \\'Jun_Revenue\\',\\nsum(Case when month=\\'Jul\\' then revenue else null end) as \\'Jul_Revenue\\',\\nsum(Case when month=\\'Aug\\' then revenue else null end) as \\'Aug_Revenue\\',\\nsum(Case when month=\\'Sep\\' then revenue else null end) as \\'Sep_Revenue\\',\\nsum(Case when month=\\'Oct\\' then revenue else null end) as \\'Oct_Revenue\\',\\nsum(Case when month=\\'Nov\\' then revenue else null end) as \\'Nov_Revenue\\',\\nsum(Case when month=\\'Dec\\' then revenue else null end) as \\'Dec_Revenue\\'\\nfrom Department\\ngroup by id\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, \\nsum(Case when month=\\'Jan\\' then revenue else null end) as \\'Jan_Revenue\\',\\nsum(Case when month=\\'Feb\\' then revenue else null end) as \\'Feb_Revenue\\',\\nsum(Case when month=\\'Mar\\' then revenue else null end) as \\'Mar_Revenue\\',\\nsum(Case when month=\\'Apr\\' then revenue else null end) as \\'Apr_Revenue\\',\\nsum(Case when month=\\'May\\' then revenue else null end) as \\'May_Revenue\\',\\nsum(Case when month=\\'Jun\\' then revenue else null end) as \\'Jun_Revenue\\',\\nsum(Case when month=\\'Jul\\' then revenue else null end) as \\'Jul_Revenue\\',\\nsum(Case when month=\\'Aug\\' then revenue else null end) as \\'Aug_Revenue\\',\\nsum(Case when month=\\'Sep\\' then revenue else null end) as \\'Sep_Revenue\\',\\nsum(Case when month=\\'Oct\\' then revenue else null end) as \\'Oct_Revenue\\',\\nsum(Case when month=\\'Nov\\' then revenue else null end) as \\'Nov_Revenue\\',\\nsum(Case when month=\\'Dec\\' then revenue else null end) as \\'Dec_Revenue\\'\\nfrom Department\\ngroup by id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1662846,
                "title": "simple-solution-without-case",
                "content": "```sql\\nSELECT \\n    id, \\n    SUM(IF(month=\\'Jan\\', revenue, Null)) AS Jan_Revenue,\\n    SUM(IF(month=\\'Feb\\', revenue, Null)) AS Feb_Revenue,\\n    SUM(IF(month=\\'Mar\\', revenue, Null)) AS Mar_Revenue,\\n    SUM(IF(month=\\'Apr\\', revenue, Null)) AS Apr_Revenue,\\n    SUM(IF(month=\\'May\\', revenue, Null)) AS May_Revenue,\\n    SUM(IF(month=\\'Jun\\', revenue, Null)) AS Jun_Revenue,\\n    SUM(IF(month=\\'Jul\\', revenue, Null)) AS Jul_Revenue,\\n    SUM(IF(month=\\'Aug\\', revenue, Null)) AS Aug_Revenue,\\n    SUM(IF(month=\\'Sep\\', revenue, Null)) AS Sep_Revenue,\\n    SUM(IF(month=\\'Oct\\', revenue, Null)) AS Oct_Revenue,\\n    SUM(IF(month=\\'Nov\\', revenue, Null)) AS Nov_Revenue,\\n    SUM(IF(month=\\'Dec\\', revenue, Null)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id;\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT \\n    id, \\n    SUM(IF(month=\\'Jan\\', revenue, Null)) AS Jan_Revenue,\\n    SUM(IF(month=\\'Feb\\', revenue, Null)) AS Feb_Revenue,\\n    SUM(IF(month=\\'Mar\\', revenue, Null)) AS Mar_Revenue,\\n    SUM(IF(month=\\'Apr\\', revenue, Null)) AS Apr_Revenue,\\n    SUM(IF(month=\\'May\\', revenue, Null)) AS May_Revenue,\\n    SUM(IF(month=\\'Jun\\', revenue, Null)) AS Jun_Revenue,\\n    SUM(IF(month=\\'Jul\\', revenue, Null)) AS Jul_Revenue,\\n    SUM(IF(month=\\'Aug\\', revenue, Null)) AS Aug_Revenue,\\n    SUM(IF(month=\\'Sep\\', revenue, Null)) AS Sep_Revenue,\\n    SUM(IF(month=\\'Oct\\', revenue, Null)) AS Oct_Revenue,\\n    SUM(IF(month=\\'Nov\\', revenue, Null)) AS Nov_Revenue,\\n    SUM(IF(month=\\'Dec\\', revenue, Null)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1501091,
                "title": "my-mysql-solution",
                "content": "```\\nwith monthly_revenues as \\n(\\n    select id, month, sum(revenue) as rev\\n    from Department\\n    group by id, month\\n)\\nselect distinct id, \\n    (select rev from monthly_revenues mr1 where month = \\'Jan\\' and mr.id = mr1.id) Jan_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Feb\\' and mr.id = mr1.id) Feb_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Mar\\' and mr.id = mr1.id) Mar_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Apr\\' and mr.id = mr1.id) Apr_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'May\\' and mr.id = mr1.id) May_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Jun\\' and mr.id = mr1.id) Jun_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Jul\\' and mr.id = mr1.id) Jul_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Aug\\' and mr.id = mr1.id) Aug_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Sep\\' and mr.id = mr1.id) Sep_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Oct\\' and mr.id = mr1.id) Oct_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Nov\\' and mr.id = mr1.id) Nov_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Dec\\' and mr.id = mr1.id) Dec_Revenue\\nfrom monthly_revenues mr\\n```",
                "solutionTags": [],
                "code": "```\\nwith monthly_revenues as \\n(\\n    select id, month, sum(revenue) as rev\\n    from Department\\n    group by id, month\\n)\\nselect distinct id, \\n    (select rev from monthly_revenues mr1 where month = \\'Jan\\' and mr.id = mr1.id) Jan_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Feb\\' and mr.id = mr1.id) Feb_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Mar\\' and mr.id = mr1.id) Mar_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Apr\\' and mr.id = mr1.id) Apr_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'May\\' and mr.id = mr1.id) May_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Jun\\' and mr.id = mr1.id) Jun_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Jul\\' and mr.id = mr1.id) Jul_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Aug\\' and mr.id = mr1.id) Aug_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Sep\\' and mr.id = mr1.id) Sep_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Oct\\' and mr.id = mr1.id) Oct_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Nov\\' and mr.id = mr1.id) Nov_Revenue,\\n    (select rev from monthly_revenues mr1 where month = \\'Dec\\' and mr.id = mr1.id) Dec_Revenue\\nfrom monthly_revenues mr\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1434785,
                "title": "ms-sql-pivot-solution",
                "content": "```\\nselect id, [Jan] as Jan_Revenue, [Feb] as Feb_Revenue,\\n           [Mar] as Mar_Revenue, [Apr] as Apr_Revenue, [May] as May_Revenue,\\n           [Jun] as Jun_Revenue, [Jul] as Jul_Revenue, [Aug] as Aug_Revenue,\\n           [Sep] as Sep_Revenue, [Oct] as Oct_Revenue, [Nov] as Nov_Revenue,\\n           [Dec] as Dec_Revenue\\nfrom department\\npivot (sum(revenue) for month in ([Jan],[Feb],\\n                                  [Mar],[Apr],[May],\\n                                  [Jun],[Jul],[Aug],\\n                                  [Sep],[Oct],[Nov],\\n                                  [Dec])) as p\\n```",
                "solutionTags": [],
                "code": "```\\nselect id, [Jan] as Jan_Revenue, [Feb] as Feb_Revenue,\\n           [Mar] as Mar_Revenue, [Apr] as Apr_Revenue, [May] as May_Revenue,\\n           [Jun] as Jun_Revenue, [Jul] as Jul_Revenue, [Aug] as Aug_Revenue,\\n           [Sep] as Sep_Revenue, [Oct] as Oct_Revenue, [Nov] as Nov_Revenue,\\n           [Dec] as Dec_Revenue\\nfrom department\\npivot (sum(revenue) for month in ([Jan],[Feb],\\n                                  [Mar],[Apr],[May],\\n                                  [Jun],[Jul],[Aug],\\n                                  [Sep],[Oct],[Nov],\\n                                  [Dec])) as p\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1413012,
                "title": "use-pivot-table",
                "content": "```\\nSELECT id,\\n        Jan as Jan_Revenue,\\n        Feb as Feb_Revenue,\\n        Mar as Mar_Revenue,\\n        Apr as Apr_Revenue,\\n        May as May_Revenue,\\n        Jun as Jun_Revenue,\\n        Jul as Jul_Revenue,\\n        Aug as Aug_Revenue,\\n        Sep as Sep_Revenue,\\n        Oct as Oct_Revenue,\\n        Nov as Nov_Revenue,\\n        Dec as Dec_Revenue\\nFROM Department\\n\\nPIVOT(\\n    SUM(revenue)\\n    FOR month IN (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)\\n     ) as pivot_table\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id,\\n        Jan as Jan_Revenue,\\n        Feb as Feb_Revenue,\\n        Mar as Mar_Revenue,\\n        Apr as Apr_Revenue,\\n        May as May_Revenue,\\n        Jun as Jun_Revenue,\\n        Jul as Jul_Revenue,\\n        Aug as Aug_Revenue,\\n        Sep as Sep_Revenue,\\n        Oct as Oct_Revenue,\\n        Nov as Nov_Revenue,\\n        Dec as Dec_Revenue\\nFROM Department\\n\\nPIVOT(\\n    SUM(revenue)\\n    FOR month IN (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec)\\n     ) as pivot_table\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370915,
                "title": "group-by",
                "content": "```\\nSELECT id,\\n    MAX(IF(month = \\'Jan\\', revenue, NULL)) as Jan_Revenue,\\n    MAX(IF(month = \\'Feb\\', revenue, NULL)) as Feb_Revenue,\\n    MAX(IF(month = \\'Mar\\', revenue, NULL)) as Mar_Revenue,\\n    MAX(IF(month = \\'Apr\\', revenue, NULL)) as Apr_Revenue,\\n    MAX(IF(month = \\'May\\', revenue, NULL)) as May_Revenue,\\n    MAX(IF(month = \\'Jun\\', revenue, NULL)) as Jun_Revenue,\\n    MAX(IF(month = \\'Jul\\', revenue, NULL)) as Jul_Revenue,\\n    MAX(IF(month = \\'Aug\\', revenue, NULL)) as Aug_Revenue,\\n    MAX(IF(month = \\'Sep\\', revenue, NULL)) as Sep_Revenue,\\n    MAX(IF(month = \\'Oct\\', revenue, NULL)) as Oct_Revenue,\\n    MAX(IF(month = \\'Nov\\', revenue, NULL)) as Nov_Revenue,\\n    MAX(IF(month = \\'Dec\\', revenue, NULL)) as Dec_Revenue\\nFROM Department\\ngroup by id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id,\\n    MAX(IF(month = \\'Jan\\', revenue, NULL)) as Jan_Revenue,\\n    MAX(IF(month = \\'Feb\\', revenue, NULL)) as Feb_Revenue,\\n    MAX(IF(month = \\'Mar\\', revenue, NULL)) as Mar_Revenue,\\n    MAX(IF(month = \\'Apr\\', revenue, NULL)) as Apr_Revenue,\\n    MAX(IF(month = \\'May\\', revenue, NULL)) as May_Revenue,\\n    MAX(IF(month = \\'Jun\\', revenue, NULL)) as Jun_Revenue,\\n    MAX(IF(month = \\'Jul\\', revenue, NULL)) as Jul_Revenue,\\n    MAX(IF(month = \\'Aug\\', revenue, NULL)) as Aug_Revenue,\\n    MAX(IF(month = \\'Sep\\', revenue, NULL)) as Sep_Revenue,\\n    MAX(IF(month = \\'Oct\\', revenue, NULL)) as Oct_Revenue,\\n    MAX(IF(month = \\'Nov\\', revenue, NULL)) as Nov_Revenue,\\n    MAX(IF(month = \\'Dec\\', revenue, NULL)) as Dec_Revenue\\nFROM Department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1222429,
                "title": "simple-oracle-pivot-function",
                "content": "```\\nselect * from\\n(select id, month, revenue\\nfrom department)\\npivot\\n(\\nsum(revenue)\\n    for month in (\\'Jan\\' as Jan_Revenue ,\\n                 \\'Feb\\' as Feb_Revenue,\\n                 \\'Mar\\' as Mar_Revenue,\\n                 \\'Apr\\' as Apr_Revenue, \\n                 \\'May\\' as May_Revenue,\\n                 \\'Jun\\' as Jun_Revenue,\\n                 \\'Jul\\' as Jul_Revenue,\\n                 \\'Aug\\' as Aug_Revenue,\\n                 \\'Sep\\' as Sep_Revenue,\\n                 \\'Oct\\' as Oct_Revenue,\\n                 \\'Nov\\' as Nov_Revenue,\\n                 \\'Dec\\' as Dec_Revenue)\\n)\\n```",
                "solutionTags": [],
                "code": "```\\nselect * from\\n(select id, month, revenue\\nfrom department)\\npivot\\n(\\nsum(revenue)\\n    for month in (\\'Jan\\' as Jan_Revenue ,\\n                 \\'Feb\\' as Feb_Revenue,\\n                 \\'Mar\\' as Mar_Revenue,\\n                 \\'Apr\\' as Apr_Revenue, \\n                 \\'May\\' as May_Revenue,\\n                 \\'Jun\\' as Jun_Revenue,\\n                 \\'Jul\\' as Jul_Revenue,\\n                 \\'Aug\\' as Aug_Revenue,\\n                 \\'Sep\\' as Sep_Revenue,\\n                 \\'Oct\\' as Oct_Revenue,\\n                 \\'Nov\\' as Nov_Revenue,\\n                 \\'Dec\\' as Dec_Revenue)\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194883,
                "title": "sum-and-if-statement",
                "content": "select\\nid,\\nsum(if((month = \"Jan\") ,revenue, null)) as \\'Jan_Revenue\\',\\nsum(if((month = \"Feb\") ,revenue, null)) as \\'Feb_Revenue\\',\\nsum(if((month = \"Mar\") ,revenue, null)) as \\'Mar_Revenue\\',\\nsum(if((month = \"Apr\") ,revenue, null)) as \\'Apr_Revenue\\',\\nsum(if((month = \"May\") ,revenue, null)) as \\'May_Revenue\\',\\nsum(if((month = \"Jun\") ,revenue, null)) as \\'Jun_Revenue\\',\\nsum(if((month = \"Jul\") ,revenue, null)) as \\'Jul_Revenue\\',\\nsum(if((month = \"Aug\") ,revenue, null)) as \\'Aug_Revenue\\',\\nsum(if((month = \"Sep\") ,revenue, null)) as \\'Sep_Revenue\\',\\nsum(if((month = \"Oct\") ,revenue, null)) as \\'Oct_Revenue\\',\\nsum(if((month = \"Nov\") ,revenue, null)) as \\'Nov_Revenue\\',\\nsum(if((month = \"Dec\") ,revenue, null)) as \\'Dec_Revenue\\'\\nfrom\\nDepartment\\ngroup by id;",
                "solutionTags": [],
                "code": "select\\nid,\\nsum(if((month = \"Jan\") ,revenue, null)) as \\'Jan_Revenue\\',\\nsum(if((month = \"Feb\") ,revenue, null)) as \\'Feb_Revenue\\',\\nsum(if((month = \"Mar\") ,revenue, null)) as \\'Mar_Revenue\\',\\nsum(if((month = \"Apr\") ,revenue, null)) as \\'Apr_Revenue\\',\\nsum(if((month = \"May\") ,revenue, null)) as \\'May_Revenue\\',\\nsum(if((month = \"Jun\") ,revenue, null)) as \\'Jun_Revenue\\',\\nsum(if((month = \"Jul\") ,revenue, null)) as \\'Jul_Revenue\\',\\nsum(if((month = \"Aug\") ,revenue, null)) as \\'Aug_Revenue\\',\\nsum(if((month = \"Sep\") ,revenue, null)) as \\'Sep_Revenue\\',\\nsum(if((month = \"Oct\") ,revenue, null)) as \\'Oct_Revenue\\',\\nsum(if((month = \"Nov\") ,revenue, null)) as \\'Nov_Revenue\\',\\nsum(if((month = \"Dec\") ,revenue, null)) as \\'Dec_Revenue\\'\\nfrom\\nDepartment\\ngroup by id;",
                "codeTag": "Unknown"
            },
            {
                "id": 1029493,
                "title": "sql-solution",
                "content": "```\\nSELECT id, \\n    SUM( IF(month = \"Jan\", revenue, NULL) ) AS Jan_Revenue,\\n    SUM( IF(month = \"Feb\", revenue, NULL) ) AS Feb_Revenue,\\n    SUM( IF(month = \"Mar\", revenue, NULL) ) AS Mar_Revenue,\\n    SUM( IF(month = \"Apr\", revenue, NULL) ) AS Apr_Revenue,\\n    SUM( IF(month = \"May\", revenue, NULL) ) AS May_Revenue,\\n    SUM( IF(month = \"Jun\", revenue, NULL) ) AS Jun_Revenue,\\n    SUM( IF(month = \"Jul\", revenue, NULL) ) AS Jul_Revenue,\\n    SUM( IF(month = \"Aug\", revenue, NULL) ) AS Aug_Revenue,\\n    SUM( IF(month = \"Sep\", revenue, NULL) ) AS Sep_Revenue,\\n    SUM( IF(month = \"Oct\", revenue, NULL) ) AS Oct_Revenue,\\n    SUM( IF(month = \"Nov\", revenue, NULL) ) AS Nov_Revenue,\\n    SUM( IF(month = \"Dec\", revenue, NULL) ) AS Dec_Revenue\\nFROM\\n    Department\\nGROUP BY\\n    id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id, \\n    SUM( IF(month = \"Jan\", revenue, NULL) ) AS Jan_Revenue,\\n    SUM( IF(month = \"Feb\", revenue, NULL) ) AS Feb_Revenue,\\n    SUM( IF(month = \"Mar\", revenue, NULL) ) AS Mar_Revenue,\\n    SUM( IF(month = \"Apr\", revenue, NULL) ) AS Apr_Revenue,\\n    SUM( IF(month = \"May\", revenue, NULL) ) AS May_Revenue,\\n    SUM( IF(month = \"Jun\", revenue, NULL) ) AS Jun_Revenue,\\n    SUM( IF(month = \"Jul\", revenue, NULL) ) AS Jul_Revenue,\\n    SUM( IF(month = \"Aug\", revenue, NULL) ) AS Aug_Revenue,\\n    SUM( IF(month = \"Sep\", revenue, NULL) ) AS Sep_Revenue,\\n    SUM( IF(month = \"Oct\", revenue, NULL) ) AS Oct_Revenue,\\n    SUM( IF(month = \"Nov\", revenue, NULL) ) AS Nov_Revenue,\\n    SUM( IF(month = \"Dec\", revenue, NULL) ) AS Dec_Revenue\\nFROM\\n    Department\\nGROUP BY\\n    id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 865846,
                "title": "simple-pivot-ms-sql",
                "content": "select id, [Jan] as [Jan_Revenue], Feb as [Feb_Revenue],Mar as [Mar_Revenue], Apr as [Apr_Revenue],\\nMay as [May_Revenue], Jun as [Jun_Revenue], Jul as [Jul_Revenue], Aug as [Aug_Revenue],\\nSep as [Sep_Revenue],Oct as [Oct_Revenue],Nov as [Nov_Revenue],Dec as [Dec_Revenue]\\nfrom department\\npivot\\n(\\n    sum(revenue)\\n    for month\\n    in (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec)\\n) as pt",
                "solutionTags": [],
                "code": "select id, [Jan] as [Jan_Revenue], Feb as [Feb_Revenue],Mar as [Mar_Revenue], Apr as [Apr_Revenue],\\nMay as [May_Revenue], Jun as [Jun_Revenue], Jul as [Jul_Revenue], Aug as [Aug_Revenue],\\nSep as [Sep_Revenue],Oct as [Oct_Revenue],Nov as [Nov_Revenue],Dec as [Dec_Revenue]\\nfrom department\\npivot\\n(\\n    sum(revenue)\\n    for month\\n    in (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec)\\n) as pt",
                "codeTag": "Unknown"
            },
            {
                "id": 699505,
                "title": "mssql-faster-than-99-84-submission-pivot",
                "content": "```\\nselect id, [Jan] as \\'Jan_Revenue\\', [Feb] as \\'Feb_Revenue\\', [Mar] as \\'Mar_Revenue\\', [Apr] as \\'Apr_Revenue\\', [May] as \\'May_Revenue\\', [Jun] as \\'Jun_Revenue\\', [Jul] as \\'Jul_Revenue\\', [Aug] as \\'Aug_Revenue\\', [Sep] as \\'Sep_Revenue\\', [Oct] as \\'Oct_Revenue\\', [Nov] as \\'Nov_Revenue\\', [Dec] as \\'Dec_Revenue\\' from \\n(select * from department) as a\\npivot \\n(sum(revenue) for month in ([Jan], [Feb], [Mar], [Apr], [May], [Jun], [Jul], [Aug], [Sep], [Oct], [Nov], [Dec]))as t \\n```",
                "solutionTags": [],
                "code": "```\\nselect id, [Jan] as \\'Jan_Revenue\\', [Feb] as \\'Feb_Revenue\\', [Mar] as \\'Mar_Revenue\\', [Apr] as \\'Apr_Revenue\\', [May] as \\'May_Revenue\\', [Jun] as \\'Jun_Revenue\\', [Jul] as \\'Jul_Revenue\\', [Aug] as \\'Aug_Revenue\\', [Sep] as \\'Sep_Revenue\\', [Oct] as \\'Oct_Revenue\\', [Nov] as \\'Nov_Revenue\\', [Dec] as \\'Dec_Revenue\\' from \\n(select * from department) as a\\npivot \\n(sum(revenue) for month in ([Jan], [Feb], [Mar], [Apr], [May], [Jun], [Jul], [Aug], [Sep], [Oct], [Nov], [Dec]))as t \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696982,
                "title": "simple-of-simple",
                "content": "```\\nSELECT \\n\\tid,\\n    SUM(Jan_Revenue) Jan_Revenue,\\n    SUM(Feb_Revenue) Feb_Revenue,\\n    SUM(Mar_Revenue) Mar_Revenue,\\n    SUM(Apr_Revenue) Apr_Revenue,\\n    SUM(May_Revenue) May_Revenue,\\n    SUM(Jun_Revenue) Jun_Revenue,\\n    SUM(Jul_Revenue) Jul_Revenue,\\n    SUM(Aug_Revenue) Aug_Revenue,\\n    SUM(Sep_Revenue) Sep_Revenue,\\n    SUM(Oct_Revenue) Oct_Revenue,\\n    SUM(Nov_Revenue) Nov_Revenue,\\n    SUM(Dec_Revenue) Dec_Revenue\\nFROM (\\n\\tSELECT id,\\n\\tCASE WHEN month=\\'Jan\\' THEN revenue END AS Jan_Revenue,\\n\\tCASE WHEN month=\\'Feb\\' THEN revenue END AS Feb_Revenue,\\n\\tCASE WHEN month=\\'Mar\\' THEN revenue END AS Mar_Revenue,\\n\\tCASE WHEN month=\\'Apr\\' THEN revenue END AS Apr_Revenue,\\n\\tCASE WHEN month=\\'May\\' THEN revenue END AS May_Revenue,\\n\\tCASE WHEN month=\\'Jun\\' THEN revenue END AS Jun_Revenue,\\n\\tCASE WHEN month=\\'Jul\\' THEN revenue END AS Jul_Revenue,\\n\\tCASE WHEN month=\\'Aug\\' THEN revenue END AS Aug_Revenue,\\n\\tCASE WHEN month=\\'Sep\\' THEN revenue END AS Sep_Revenue,\\n\\tCASE WHEN month=\\'Oct\\' THEN revenue END AS Oct_Revenue,\\n\\tCASE WHEN month=\\'Nov\\' THEN revenue END AS Nov_Revenue,\\n\\tCASE WHEN month=\\'Dec\\' THEN revenue END AS Dec_Revenue\\n\\tFROM Department\\n) result\\nGROUP BY id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n\\tid,\\n    SUM(Jan_Revenue) Jan_Revenue,\\n    SUM(Feb_Revenue) Feb_Revenue,\\n    SUM(Mar_Revenue) Mar_Revenue,\\n    SUM(Apr_Revenue) Apr_Revenue,\\n    SUM(May_Revenue) May_Revenue,\\n    SUM(Jun_Revenue) Jun_Revenue,\\n    SUM(Jul_Revenue) Jul_Revenue,\\n    SUM(Aug_Revenue) Aug_Revenue,\\n    SUM(Sep_Revenue) Sep_Revenue,\\n    SUM(Oct_Revenue) Oct_Revenue,\\n    SUM(Nov_Revenue) Nov_Revenue,\\n    SUM(Dec_Revenue) Dec_Revenue\\nFROM (\\n\\tSELECT id,\\n\\tCASE WHEN month=\\'Jan\\' THEN revenue END AS Jan_Revenue,\\n\\tCASE WHEN month=\\'Feb\\' THEN revenue END AS Feb_Revenue,\\n\\tCASE WHEN month=\\'Mar\\' THEN revenue END AS Mar_Revenue,\\n\\tCASE WHEN month=\\'Apr\\' THEN revenue END AS Apr_Revenue,\\n\\tCASE WHEN month=\\'May\\' THEN revenue END AS May_Revenue,\\n\\tCASE WHEN month=\\'Jun\\' THEN revenue END AS Jun_Revenue,\\n\\tCASE WHEN month=\\'Jul\\' THEN revenue END AS Jul_Revenue,\\n\\tCASE WHEN month=\\'Aug\\' THEN revenue END AS Aug_Revenue,\\n\\tCASE WHEN month=\\'Sep\\' THEN revenue END AS Sep_Revenue,\\n\\tCASE WHEN month=\\'Oct\\' THEN revenue END AS Oct_Revenue,\\n\\tCASE WHEN month=\\'Nov\\' THEN revenue END AS Nov_Revenue,\\n\\tCASE WHEN month=\\'Dec\\' THEN revenue END AS Dec_Revenue\\n\\tFROM Department\\n) result\\nGROUP BY id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690629,
                "title": "mysql-sum-case-when",
                "content": "```\\nselect id,\\nmax(case when month=\\'Jan\\' then revenue else null end) Jan_Revenue,\\nmax(case when month=\\'Feb\\' then revenue else null end) as Feb_Revenue,\\nmax(case when month=\\'Mar\\' then revenue else null end) as Mar_Revenue,\\nmax(case when month=\\'Apr\\' then revenue else null end) as Apr_Revenue,\\nmax(case when month=\\'May\\' then revenue else null end) as May_Revenue,\\nmax(case when month=\\'Jun\\' then revenue else null end) as Jun_Revenue,\\nmax(case when month=\\'Jul\\' then revenue else null end) as Jul_Revenue,\\nmax(case when month=\\'Aug\\' then revenue else null end) as Aug_Revenue,\\nmax(case when month=\\'Sep\\' then revenue else null end) as Sep_Revenue,\\nmax(case when month=\\'Oct\\' then revenue else null end) as Oct_Revenue,\\nmax(case when month=\\'Nov\\' then revenue else null end) as Nov_Revenue,\\nmax(case when month=\\'Dec\\' then revenue else null end) as Dec_Revenue\\nfrom Department\\ngroup by id;\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,\\nmax(case when month=\\'Jan\\' then revenue else null end) Jan_Revenue,\\nmax(case when month=\\'Feb\\' then revenue else null end) as Feb_Revenue,\\nmax(case when month=\\'Mar\\' then revenue else null end) as Mar_Revenue,\\nmax(case when month=\\'Apr\\' then revenue else null end) as Apr_Revenue,\\nmax(case when month=\\'May\\' then revenue else null end) as May_Revenue,\\nmax(case when month=\\'Jun\\' then revenue else null end) as Jun_Revenue,\\nmax(case when month=\\'Jul\\' then revenue else null end) as Jul_Revenue,\\nmax(case when month=\\'Aug\\' then revenue else null end) as Aug_Revenue,\\nmax(case when month=\\'Sep\\' then revenue else null end) as Sep_Revenue,\\nmax(case when month=\\'Oct\\' then revenue else null end) as Oct_Revenue,\\nmax(case when month=\\'Nov\\' then revenue else null end) as Nov_Revenue,\\nmax(case when month=\\'Dec\\' then revenue else null end) as Dec_Revenue\\nfrom Department\\ngroup by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584725,
                "title": "ansi-compliant-solution-that-works-for-all-3-oracle-mysql-and-mssql",
                "content": "# Solution 1 (More Elegant and Faster)\\n\\n```SQL\\nselect\\n    d.id,\\n    sum(case when d.month = \\'Jan\\' then d.revenue else null end) \"Jan_Revenue\",\\n    sum(case when d.month = \\'Feb\\' then d.revenue else null end) \"Feb_Revenue\",\\n    sum(case when d.month = \\'Mar\\' then d.revenue else null end) \"Mar_Revenue\",\\n    sum(case when d.month = \\'Apr\\' then d.revenue else null end) \"Apr_Revenue\",\\n    sum(case when d.month = \\'May\\' then d.revenue else null end) \"May_Revenue\",\\n    sum(case when d.month = \\'Jun\\' then d.revenue else null end) \"Jun_Revenue\",\\n    sum(case when d.month = \\'Jul\\' then d.revenue else null end) \"Jul_Revenue\",\\n    sum(case when d.month = \\'Aug\\' then d.revenue else null end) \"Aug_Revenue\",\\n    sum(case when d.month = \\'Sep\\' then d.revenue else null end) \"Sep_Revenue\",\\n    sum(case when d.month = \\'Oct\\' then d.revenue else null end) \"Oct_Revenue\",\\n    sum(case when d.month = \\'Nov\\' then d.revenue else null end) \"Nov_Revenue\",\\n    sum(case when d.month = \\'Dec\\' then d.revenue else null end) \"Dec_Revenue\"\\nfrom department d\\ngroup by d.id\\n;\\n```\\n\\n# Solution 2\\n\\n```SQL\\nselect\\n    d00.id,\\n    sum(d01.revenue) as \"Jan_Revenue\",\\n    sum(d02.revenue) as \"Feb_Revenue\",\\n    sum(d03.revenue) as \"Mar_Revenue\",\\n    sum(d04.revenue) as \"Apr_Revenue\",\\n    sum(d05.revenue) as \"May_Revenue\",\\n    sum(d06.revenue) as \"Jun_Revenue\",\\n    sum(d07.revenue) as \"Jul_Revenue\",\\n    sum(d08.revenue) as \"Aug_Revenue\",\\n    sum(d09.revenue) as \"Sep_Revenue\",\\n    sum(d10.revenue) as \"Oct_Revenue\",\\n    sum(d11.revenue) as \"Nov_Revenue\",\\n    sum(d12.revenue) as \"Dec_Revenue\"    \\nfrom (select distinct id from department) d00\\nleft join department d01 on d01.id = d00.id and d01.month = \\'Jan\\'\\nleft join department d02 on d02.id = d00.id and d02.month = \\'Feb\\'\\nleft join department d03 on d03.id = d00.id and d03.month = \\'Mar\\'\\nleft join department d04 on d04.id = d00.id and d04.month = \\'Apr\\'\\nleft join department d05 on d05.id = d00.id and d05.month = \\'May\\'\\nleft join department d06 on d06.id = d00.id and d06.month = \\'Jun\\'\\nleft join department d07 on d07.id = d00.id and d07.month = \\'Jul\\'\\nleft join department d08 on d08.id = d00.id and d08.month = \\'Aug\\'\\nleft join department d09 on d09.id = d00.id and d09.month = \\'Sep\\'\\nleft join department d10 on d10.id = d00.id and d10.month = \\'Oct\\'\\nleft join department d11 on d11.id = d00.id and d11.month = \\'Nov\\'\\nleft join department d12 on d12.id = d00.id and d12.month = \\'Dec\\'\\ngroup by d00.id\\n;\\n```",
                "solutionTags": [],
                "code": "```SQL\\nselect\\n    d.id,\\n    sum(case when d.month = \\'Jan\\' then d.revenue else null end) \"Jan_Revenue\",\\n    sum(case when d.month = \\'Feb\\' then d.revenue else null end) \"Feb_Revenue\",\\n    sum(case when d.month = \\'Mar\\' then d.revenue else null end) \"Mar_Revenue\",\\n    sum(case when d.month = \\'Apr\\' then d.revenue else null end) \"Apr_Revenue\",\\n    sum(case when d.month = \\'May\\' then d.revenue else null end) \"May_Revenue\",\\n    sum(case when d.month = \\'Jun\\' then d.revenue else null end) \"Jun_Revenue\",\\n    sum(case when d.month = \\'Jul\\' then d.revenue else null end) \"Jul_Revenue\",\\n    sum(case when d.month = \\'Aug\\' then d.revenue else null end) \"Aug_Revenue\",\\n    sum(case when d.month = \\'Sep\\' then d.revenue else null end) \"Sep_Revenue\",\\n    sum(case when d.month = \\'Oct\\' then d.revenue else null end) \"Oct_Revenue\",\\n    sum(case when d.month = \\'Nov\\' then d.revenue else null end) \"Nov_Revenue\",\\n    sum(case when d.month = \\'Dec\\' then d.revenue else null end) \"Dec_Revenue\"\\nfrom department d\\ngroup by d.id\\n;\\n```\n```SQL\\nselect\\n    d00.id,\\n    sum(d01.revenue) as \"Jan_Revenue\",\\n    sum(d02.revenue) as \"Feb_Revenue\",\\n    sum(d03.revenue) as \"Mar_Revenue\",\\n    sum(d04.revenue) as \"Apr_Revenue\",\\n    sum(d05.revenue) as \"May_Revenue\",\\n    sum(d06.revenue) as \"Jun_Revenue\",\\n    sum(d07.revenue) as \"Jul_Revenue\",\\n    sum(d08.revenue) as \"Aug_Revenue\",\\n    sum(d09.revenue) as \"Sep_Revenue\",\\n    sum(d10.revenue) as \"Oct_Revenue\",\\n    sum(d11.revenue) as \"Nov_Revenue\",\\n    sum(d12.revenue) as \"Dec_Revenue\"    \\nfrom (select distinct id from department) d00\\nleft join department d01 on d01.id = d00.id and d01.month = \\'Jan\\'\\nleft join department d02 on d02.id = d00.id and d02.month = \\'Feb\\'\\nleft join department d03 on d03.id = d00.id and d03.month = \\'Mar\\'\\nleft join department d04 on d04.id = d00.id and d04.month = \\'Apr\\'\\nleft join department d05 on d05.id = d00.id and d05.month = \\'May\\'\\nleft join department d06 on d06.id = d00.id and d06.month = \\'Jun\\'\\nleft join department d07 on d07.id = d00.id and d07.month = \\'Jul\\'\\nleft join department d08 on d08.id = d00.id and d08.month = \\'Aug\\'\\nleft join department d09 on d09.id = d00.id and d09.month = \\'Sep\\'\\nleft join department d10 on d10.id = d00.id and d10.month = \\'Oct\\'\\nleft join department d11 on d11.id = d00.id and d11.month = \\'Nov\\'\\nleft join department d12 on d12.id = d00.id and d12.month = \\'Dec\\'\\ngroup by d00.id\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534064,
                "title": "mysql-ms-sql-conditional-pivot-solutions",
                "content": "# MySQL\\n```sql\\nSELECT d.id, \\nMAX(CASE WHEN d.month=\\'Jan\\' THEN d.revenue END) AS \\'Jan_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Feb\\' THEN d.revenue END) AS \\'Feb_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Mar\\' THEN d.revenue END) AS \\'Mar_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Apr\\' THEN d.revenue END) AS \\'Apr_Revenue\\',\\nMAX(CASE WHEN d.month=\\'May\\' THEN d.revenue END) AS \\'May_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Jun\\' THEN d.revenue END) AS \\'Jun_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Jul\\' THEN d.revenue END) AS \\'Jul_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Aug\\' THEN d.revenue END) AS \\'Aug_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Sep\\' THEN d.revenue END) AS \\'Sep_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Oct\\' THEN d.revenue END) AS \\'Oct_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Nov\\' THEN d.revenue END) AS \\'Nov_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Dec\\' THEN d.revenue END) AS \\'Dec_Revenue\\'\\nFROM Department AS d\\nGROUP BY id;\\n```\\n# MS SQL\\n```sql\\nSELECT id, [Jan] AS Jan_Revenue, [Feb] AS Feb_Revenue, [Mar] AS Mar_Revenue, [Apr] AS Apr_Revenue, [May] AS May_Revenue, [Jun] AS Jun_Revenue, [Jul] AS Jul_Revenue, [Aug] AS Aug_Revenue, [Sep] AS Sep_Revenue, [Oct] AS Oct_Revenue, [Nov] AS Nov_Revenue, [Dec] AS Dec_Revenue FROM\\n(SELECT id, revenue, month FROM Department) AS SourceTable\\nPIVOT\\n(\\nMAX(revenue) \\nFOR month IN ([Jan], \\n              [Feb], \\n              [Mar], \\n              [Apr], \\n              [May], \\n              [Jun], \\n              [Jul], \\n              [Aug], \\n              [Sep], \\n              [Oct], \\n              [Nov], \\n              [Dec])\\n) AS Result;\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```sql\\nSELECT d.id, \\nMAX(CASE WHEN d.month=\\'Jan\\' THEN d.revenue END) AS \\'Jan_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Feb\\' THEN d.revenue END) AS \\'Feb_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Mar\\' THEN d.revenue END) AS \\'Mar_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Apr\\' THEN d.revenue END) AS \\'Apr_Revenue\\',\\nMAX(CASE WHEN d.month=\\'May\\' THEN d.revenue END) AS \\'May_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Jun\\' THEN d.revenue END) AS \\'Jun_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Jul\\' THEN d.revenue END) AS \\'Jul_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Aug\\' THEN d.revenue END) AS \\'Aug_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Sep\\' THEN d.revenue END) AS \\'Sep_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Oct\\' THEN d.revenue END) AS \\'Oct_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Nov\\' THEN d.revenue END) AS \\'Nov_Revenue\\',\\nMAX(CASE WHEN d.month=\\'Dec\\' THEN d.revenue END) AS \\'Dec_Revenue\\'\\nFROM Department AS d\\nGROUP BY id;\\n```\n```sql\\nSELECT id, [Jan] AS Jan_Revenue, [Feb] AS Feb_Revenue, [Mar] AS Mar_Revenue, [Apr] AS Apr_Revenue, [May] AS May_Revenue, [Jun] AS Jun_Revenue, [Jul] AS Jul_Revenue, [Aug] AS Aug_Revenue, [Sep] AS Sep_Revenue, [Oct] AS Oct_Revenue, [Nov] AS Nov_Revenue, [Dec] AS Dec_Revenue FROM\\n(SELECT id, revenue, month FROM Department) AS SourceTable\\nPIVOT\\n(\\nMAX(revenue) \\nFOR month IN ([Jan], \\n              [Feb], \\n              [Mar], \\n              [Apr], \\n              [May], \\n              [Jun], \\n              [Jul], \\n              [Aug], \\n              [Sep], \\n              [Oct], \\n              [Nov], \\n              [Dec])\\n) AS Result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 476718,
                "title": "mysql-solution",
                "content": "I did with `IF` statement on Mysql\\n\\n```sql\\nSELECT id,\\n       SUM(if(month = \\'Jan\\', revenue, null)) AS Jan_Revenue,\\n       SUM(if(month = \\'Feb\\', revenue, null)) AS Feb_Revenue,\\n       SUM(if(month = \\'Mar\\', revenue, null)) AS Mar_Revenue,\\n       SUM(if(month = \\'Apr\\', revenue, null)) AS Apr_Revenue,\\n       SUM(if(month = \\'May\\', revenue, null)) AS May_Revenue,\\n       SUM(if(month = \\'Jun\\', revenue, null)) AS Jun_Revenue,\\n       SUM(if(month = \\'Jul\\', revenue, null)) AS Jul_Revenue,\\n       SUM(if(month = \\'Aug\\', revenue, null)) AS Aug_Revenue,\\n       SUM(if(month = \\'Sep\\', revenue, null)) AS Sep_Revenue,\\n       SUM(if(month = \\'Oct\\', revenue, null)) AS Oct_Revenue,\\n       SUM(if(month = \\'Nov\\', revenue, null)) AS Nov_Revenue,\\n       SUM(if(month = \\'Dec\\', revenue, null)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT id,\\n       SUM(if(month = \\'Jan\\', revenue, null)) AS Jan_Revenue,\\n       SUM(if(month = \\'Feb\\', revenue, null)) AS Feb_Revenue,\\n       SUM(if(month = \\'Mar\\', revenue, null)) AS Mar_Revenue,\\n       SUM(if(month = \\'Apr\\', revenue, null)) AS Apr_Revenue,\\n       SUM(if(month = \\'May\\', revenue, null)) AS May_Revenue,\\n       SUM(if(month = \\'Jun\\', revenue, null)) AS Jun_Revenue,\\n       SUM(if(month = \\'Jul\\', revenue, null)) AS Jul_Revenue,\\n       SUM(if(month = \\'Aug\\', revenue, null)) AS Aug_Revenue,\\n       SUM(if(month = \\'Sep\\', revenue, null)) AS Sep_Revenue,\\n       SUM(if(month = \\'Oct\\', revenue, null)) AS Oct_Revenue,\\n       SUM(if(month = \\'Nov\\', revenue, null)) AS Nov_Revenue,\\n       SUM(if(month = \\'Dec\\', revenue, null)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 460246,
                "title": "1179-reformat-department-table-sql-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**SUM IF** | Rt: 631ms |\\n```sql\\nselect \\n    id,\\n    sum( if(month = \\'Jan\\', revenue, null) ) as \"Jan_Revenue\",\\n    sum( if(month = \\'Feb\\', revenue, null) ) as \"Feb_Revenue\",\\n    sum( if(month = \\'Mar\\', revenue, null) ) as \"Mar_Revenue\",\\n    sum( if(month = \\'Apr\\', revenue, null) ) as \"Apr_Revenue\",\\n    sum( if(month = \\'May\\', revenue, null) ) as \"May_Revenue\",\\n    sum( if(month = \\'Jun\\', revenue, null) ) as \"Jun_Revenue\",\\n    sum( if(month = \\'Jul\\', revenue, null) ) as \"Jul_Revenue\",\\n    sum( if(month = \\'Aug\\', revenue, null) ) as \"Aug_Revenue\",\\n    sum( if(month = \\'Sep\\', revenue, null) ) as \"Sep_Revenue\",\\n    sum( if(month = \\'Oct\\', revenue, null) ) as \"Oct_Revenue\",\\n    sum( if(month = \\'Nov\\', revenue, null) ) as \"Nov_Revenue\",\\n    sum( if(month = \\'Dec\\', revenue, null) ) as \"Dec_Revenue\"\\n    from Department\\n    group by id\\n```\\nReferrence: https://leetcode.com/problems/reformat-department-table/discuss/393818/MySQL-SOLUTION-GROUP-BY\\nComment: using either Max or Sum since the test case are all one-entry. \\n\\nAlternative: \\n```sql\\nselect \\n    id,\\n    max( case when month = \\'Jan\\' then revenue else null end ) as \"Jan_Revenue\",\\n    max( case when month = \\'Feb\\' then revenue else null end ) as \"Feb_Revenue\",\\n    max( case when month = \\'Mar\\' then revenue else null end ) as \"Mar_Revenue\",\\n    max( case when month = \\'Apr\\' then revenue else null end ) as \"Apr_Revenue\",\\n    max( case when month = \\'May\\' then revenue else null end ) as \"May_Revenue\",\\n    max( case when month = \\'Jun\\' then revenue else null end ) as \"Jun_Revenue\",\\n    max( case when month = \\'Jul\\' then revenue else null end ) as \"Jul_Revenue\",\\n    max( case when month = \\'Aug\\' then revenue else null end ) as \"Aug_Revenue\",\\n    max( case when month = \\'Sep\\' then revenue else null end ) as \"Sep_Revenue\",\\n    max( case when month = \\'Oct\\' then revenue else null end ) as \"Oct_Revenue\",\\n    max( case when month = \\'Nov\\' then revenue else null end ) as \"Nov_Revenue\",\\n    max( case when month = \\'Dec\\' then revenue else null end ) as \"Dec_Revenue\"\\n    from Department\\n    group by id\\n```",
                "solutionTags": [],
                "code": "```sql\\nselect \\n    id,\\n    sum( if(month = \\'Jan\\', revenue, null) ) as \"Jan_Revenue\",\\n    sum( if(month = \\'Feb\\', revenue, null) ) as \"Feb_Revenue\",\\n    sum( if(month = \\'Mar\\', revenue, null) ) as \"Mar_Revenue\",\\n    sum( if(month = \\'Apr\\', revenue, null) ) as \"Apr_Revenue\",\\n    sum( if(month = \\'May\\', revenue, null) ) as \"May_Revenue\",\\n    sum( if(month = \\'Jun\\', revenue, null) ) as \"Jun_Revenue\",\\n    sum( if(month = \\'Jul\\', revenue, null) ) as \"Jul_Revenue\",\\n    sum( if(month = \\'Aug\\', revenue, null) ) as \"Aug_Revenue\",\\n    sum( if(month = \\'Sep\\', revenue, null) ) as \"Sep_Revenue\",\\n    sum( if(month = \\'Oct\\', revenue, null) ) as \"Oct_Revenue\",\\n    sum( if(month = \\'Nov\\', revenue, null) ) as \"Nov_Revenue\",\\n    sum( if(month = \\'Dec\\', revenue, null) ) as \"Dec_Revenue\"\\n    from Department\\n    group by id\\n```\n```sql\\nselect \\n    id,\\n    max( case when month = \\'Jan\\' then revenue else null end ) as \"Jan_Revenue\",\\n    max( case when month = \\'Feb\\' then revenue else null end ) as \"Feb_Revenue\",\\n    max( case when month = \\'Mar\\' then revenue else null end ) as \"Mar_Revenue\",\\n    max( case when month = \\'Apr\\' then revenue else null end ) as \"Apr_Revenue\",\\n    max( case when month = \\'May\\' then revenue else null end ) as \"May_Revenue\",\\n    max( case when month = \\'Jun\\' then revenue else null end ) as \"Jun_Revenue\",\\n    max( case when month = \\'Jul\\' then revenue else null end ) as \"Jul_Revenue\",\\n    max( case when month = \\'Aug\\' then revenue else null end ) as \"Aug_Revenue\",\\n    max( case when month = \\'Sep\\' then revenue else null end ) as \"Sep_Revenue\",\\n    max( case when month = \\'Oct\\' then revenue else null end ) as \"Oct_Revenue\",\\n    max( case when month = \\'Nov\\' then revenue else null end ) as \"Nov_Revenue\",\\n    max( case when month = \\'Dec\\' then revenue else null end ) as \"Dec_Revenue\"\\n    from Department\\n    group by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383394,
                "title": "plain-mysql-solution",
                "content": "Can use `max`, `min`, `sum`. It doesn\\'t matter.\\n\\n```\\nselect \\n  id\\n  ,max(case when month = \\'Jan\\' then revenue else null end) as \\'Jan_Revenue\\'\\n  ,max(case when month = \\'Feb\\' then revenue else null end) as \\'Feb_Revenue\\'\\n  ,max(case when month = \\'Mar\\' then revenue else null end) as \\'Mar_Revenue\\'\\n  ,max(case when month = \\'Apr\\' then revenue else null end) as \\'Apr_Revenue\\'\\n  ,max(case when month = \\'May\\' then revenue else null end) as \\'May_Revenue\\'\\n  ,max(case when month = \\'Jun\\' then revenue else null end) as \\'Jun_Revenue\\'\\n  ,max(case when month = \\'Jul\\' then revenue else null end) as \\'Jul_Revenue\\'\\n  ,max(case when month = \\'Aug\\' then revenue else null end) as \\'Aug_Revenue\\'\\n  ,max(case when month = \\'Sep\\' then revenue else null end) as \\'Sep_Revenue\\'\\n  ,max(case when month = \\'Oct\\' then revenue else null end) as \\'Oct_Revenue\\'\\n  ,max(case when month = \\'Nov\\' then revenue else null end) as \\'Nov_Revenue\\'\\n  ,max(case when month = \\'Dec\\' then revenue else null end) as \\'Dec_Revenue\\'\\nfrom Department\\ngroup by id\\norder by id\\n```\\n\\nI\\'m maintaining a GitHub repository that documents useful SQL techniques and common pitfalls in interview. Please star/fork if you find it helpful: https://github.com/shawlu95/Beyond-LeetCode-SQL",
                "solutionTags": [],
                "code": "```\\nselect \\n  id\\n  ,max(case when month = \\'Jan\\' then revenue else null end) as \\'Jan_Revenue\\'\\n  ,max(case when month = \\'Feb\\' then revenue else null end) as \\'Feb_Revenue\\'\\n  ,max(case when month = \\'Mar\\' then revenue else null end) as \\'Mar_Revenue\\'\\n  ,max(case when month = \\'Apr\\' then revenue else null end) as \\'Apr_Revenue\\'\\n  ,max(case when month = \\'May\\' then revenue else null end) as \\'May_Revenue\\'\\n  ,max(case when month = \\'Jun\\' then revenue else null end) as \\'Jun_Revenue\\'\\n  ,max(case when month = \\'Jul\\' then revenue else null end) as \\'Jul_Revenue\\'\\n  ,max(case when month = \\'Aug\\' then revenue else null end) as \\'Aug_Revenue\\'\\n  ,max(case when month = \\'Sep\\' then revenue else null end) as \\'Sep_Revenue\\'\\n  ,max(case when month = \\'Oct\\' then revenue else null end) as \\'Oct_Revenue\\'\\n  ,max(case when month = \\'Nov\\' then revenue else null end) as \\'Nov_Revenue\\'\\n  ,max(case when month = \\'Dec\\' then revenue else null end) as \\'Dec_Revenue\\'\\nfrom Department\\ngroup by id\\norder by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066153,
                "title": "reformat-department-table-pandas-easy-explained-step-by-step",
                "content": "[see the successfully Accepted Submission](https://leetcode.com/submissions/detail/1053950222/)\\n\\n```\\nimport pandas as pd \\n\\ndef reformat_table(department: pd.DataFrame) -> pd.DataFrame:\\n\\n    # Initially, we pivot the table to have \\'id\\' as the index, \\'month\\' as columns, and \\'revenue\\' as values\\n    pivot_table = department.pivot(index=\\'id\\', columns=\\'month\\', values=\\'revenue\\')\\n\\n    # In the next step, the list of all months is defined\\n    all_months = [\\'Jan\\', \\'Feb\\', \\'Mar\\', \\'Apr\\', \\'May\\', \\'Jun\\', \\'Jul\\', \\'Aug\\', \\'Sep\\', \\'Oct\\', \\'Nov\\', \\'Dec\\']\\n\\n    # Then, we add columns for all months, filling with NaN initially\\n    for month in all_months:\\n        if month not in pivot_table.columns:\\n            pivot_table[month] = np.nan\\n\\n    # After that the columns to match the desired order are reordered\\n    pivot_table = pivot_table[all_months]\\n\\n    # At the same time, the index to make \\'id\\' a regular column are reset.\\n    pivot_table.reset_index(inplace=True)\\n\\n    # Finally, the columns as requested are renamed.\\n    pivot_table.columns = [\\'id\\', \\'Jan_Revenue\\', \\'Feb_Revenue\\', \\'Mar_Revenue\\', \\'Apr_Revenue\\', \\'May_Revenue\\', \\'Jun_Revenue\\', \\'Jul_Revenue\\', \\'Aug_Revenue\\', \\'Sep_Revenue\\', \\'Oct_Revenue\\', \\'Nov_Revenue\\', \\'Dec_Revenue\\']\\n \\n    return pivot_table\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/ee91dff7-6cac-40af-af47-a7132d7167ae_1695156718.5932388.jpeg)\\n",
                "solutionTags": [],
                "code": "```\\nimport pandas as pd \\n\\ndef reformat_table(department: pd.DataFrame) -> pd.DataFrame:\\n\\n    # Initially, we pivot the table to have \\'id\\' as the index, \\'month\\' as columns, and \\'revenue\\' as values\\n    pivot_table = department.pivot(index=\\'id\\', columns=\\'month\\', values=\\'revenue\\')\\n\\n    # In the next step, the list of all months is defined\\n    all_months = [\\'Jan\\', \\'Feb\\', \\'Mar\\', \\'Apr\\', \\'May\\', \\'Jun\\', \\'Jul\\', \\'Aug\\', \\'Sep\\', \\'Oct\\', \\'Nov\\', \\'Dec\\']\\n\\n    # Then, we add columns for all months, filling with NaN initially\\n    for month in all_months:\\n        if month not in pivot_table.columns:\\n            pivot_table[month] = np.nan\\n\\n    # After that the columns to match the desired order are reordered\\n    pivot_table = pivot_table[all_months]\\n\\n    # At the same time, the index to make \\'id\\' a regular column are reset.\\n    pivot_table.reset_index(inplace=True)\\n\\n    # Finally, the columns as requested are renamed.\\n    pivot_table.columns = [\\'id\\', \\'Jan_Revenue\\', \\'Feb_Revenue\\', \\'Mar_Revenue\\', \\'Apr_Revenue\\', \\'May_Revenue\\', \\'Jun_Revenue\\', \\'Jul_Revenue\\', \\'Aug_Revenue\\', \\'Sep_Revenue\\', \\'Oct_Revenue\\', \\'Nov_Revenue\\', \\'Dec_Revenue\\']\\n \\n    return pivot_table\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3260482,
                "title": "solution-with-pivot-table-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n\\r\\nSELECT\\r\\n\\t*\\r\\nFROM\\r\\n\\t(\\r\\n        SELECT\\r\\n            id,\\r\\n            revenue,\\r\\n            month + \\'_Revenue\\' [month]\\r\\n        FROM\\r\\n            Department\\r\\n    )TBL1\\r\\nPIVOT (\\r\\n\\tSUM(revenue) FOR [month] IN (Jan_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tFeb_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tMar_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tApr_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tMay_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tJun_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tJul_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tAug_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tSep_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tOct_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tNov_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tDec_Revenue)\\r\\n)PIVOTTABLE\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n\\r\\nSELECT\\r\\n\\t*\\r\\nFROM\\r\\n\\t(\\r\\n        SELECT\\r\\n            id,\\r\\n            revenue,\\r\\n            month + \\'_Revenue\\' [month]\\r\\n        FROM\\r\\n            Department\\r\\n    )TBL1\\r\\nPIVOT (\\r\\n\\tSUM(revenue) FOR [month] IN (Jan_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tFeb_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tMar_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tApr_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tMay_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tJun_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tJul_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tAug_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tSep_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tOct_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tNov_Revenue,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tDec_Revenue)\\r\\n)PIVOTTABLE\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2617686,
                "title": "mysql-simple-solution",
                "content": "Unfortunetly there is no PIVOT function available in MySQL, so we need to use either case, either if statements:\\n```\\nselect id,\\n    max(case when month = \"Jan\" then revenue end) Jan_revenue,\\n    max(case when month = \"Feb\" then revenue end) Feb_revenue,\\n    max(case when month = \"Mar\" then revenue end) Mar_revenue,\\n    max(case when month = \"Apr\" then revenue end) Apr_revenue,\\n    max(case when month = \"May\" then revenue end) May_revenue,\\n    max(case when month = \"Jun\" then revenue end) Jun_revenue,\\n    max(case when month = \"Jul\" then revenue end) Jul_revenue,\\n    max(case when month = \"Aug\" then revenue end) Aug_revenue,\\n    max(case when month = \"Sep\" then revenue end) Sep_revenue,\\n    max(case when month = \"Oct\" then revenue end) Oct_revenue,\\n    max(case when month = \"Nov\" then revenue end) Nov_revenue,\\n    max(case when month = \"Dec\" then revenue end) Dec_revenue\\nfrom Department\\ngroup by id\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,\\n    max(case when month = \"Jan\" then revenue end) Jan_revenue,\\n    max(case when month = \"Feb\" then revenue end) Feb_revenue,\\n    max(case when month = \"Mar\" then revenue end) Mar_revenue,\\n    max(case when month = \"Apr\" then revenue end) Apr_revenue,\\n    max(case when month = \"May\" then revenue end) May_revenue,\\n    max(case when month = \"Jun\" then revenue end) Jun_revenue,\\n    max(case when month = \"Jul\" then revenue end) Jul_revenue,\\n    max(case when month = \"Aug\" then revenue end) Aug_revenue,\\n    max(case when month = \"Sep\" then revenue end) Sep_revenue,\\n    max(case when month = \"Oct\" then revenue end) Oct_revenue,\\n    max(case when month = \"Nov\" then revenue end) Nov_revenue,\\n    max(case when month = \"Dec\" then revenue end) Dec_revenue\\nfrom Department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2601299,
                "title": "easy-solution-using-sum-if",
                "content": "select \\n    id,\\n    sum(if(month=\\'Jan\\', revenue, null))as \\'Jan_Revenue\\',\\n    sum(if(month=\\'Feb\\', revenue, null))as \\'Feb_Revenue\\',\\n    sum(if(month=\\'Mar\\', revenue, null))as \\'Mar_Revenue\\',\\n    sum(if(month=\\'Apr\\', revenue, null))as \\'Apr_Revenue\\',\\n    sum(if(month=\\'May\\', revenue, null))as \\'May_Revenue\\',\\n    sum(if(month=\\'Jun\\', revenue, null))as \\'Jun_Revenue\\',\\n    sum(if(month=\\'Jul\\', revenue, null))as \\'Jul_Revenue\\',\\n    sum(if(month=\\'Aug\\', revenue, null))as \\'Aug_Revenue\\',\\n    sum(if(month=\\'Sep\\', revenue, null))as \\'Sep_Revenue\\',\\n    sum(if(month=\\'Oct\\', revenue, null))as \\'Oct_Revenue\\',\\n    sum(if(month=\\'Nov\\', revenue, null))as \\'Nov_Revenue\\',\\n    sum(if(month=\\'Dec\\', revenue, null))as \\'Dec_Revenue\\'\\nfrom department\\ngroup by id",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select \\n    id,\\n    sum(if(month=\\'Jan\\', revenue, null))as \\'Jan_Revenue\\',\\n    sum(if(month=\\'Feb\\', revenue, null))as \\'Feb_Revenue\\',\\n    sum(if(month=\\'Mar\\', revenue, null))as \\'Mar_Revenue\\',\\n    sum(if(month=\\'Apr\\', revenue, null))as \\'Apr_Revenue\\',\\n    sum(if(month=\\'May\\', revenue, null))as \\'May_Revenue\\',\\n    sum(if(month=\\'Jun\\', revenue, null))as \\'Jun_Revenue\\',\\n    sum(if(month=\\'Jul\\', revenue, null))as \\'Jul_Revenue\\',\\n    sum(if(month=\\'Aug\\', revenue, null))as \\'Aug_Revenue\\',\\n    sum(if(month=\\'Sep\\', revenue, null))as \\'Sep_Revenue\\',\\n    sum(if(month=\\'Oct\\', revenue, null))as \\'Oct_Revenue\\',\\n    sum(if(month=\\'Nov\\', revenue, null))as \\'Nov_Revenue\\',\\n    sum(if(month=\\'Dec\\', revenue, null))as \\'Dec_Revenue\\'\\nfrom department\\ngroup by id",
                "codeTag": "Unknown"
            },
            {
                "id": 2547733,
                "title": "mysql-simple-solution-using-if",
                "content": "```\\nselect id,\\nsum( if( month = \\'jan\\', revenue, null ) ) as jan_revenue,\\nsum( if( month = \\'feb\\', revenue, null ) ) as feb_revenue,\\nsum( if( month = \\'mar\\', revenue, null ) ) as mar_revenue,\\nsum( if( month = \\'apr\\', revenue, null ) ) as apr_revenue,\\nsum( if( month = \\'may\\', revenue, null ) ) as may_revenue,\\nsum( if( month = \\'jun\\', revenue, null ) ) as jun_revenue,\\nsum( if( month = \\'jul\\', revenue, null ) ) as jul_revenue,\\nsum( if( month = \\'aug\\', revenue, null ) ) as aug_revenue,\\nsum( if( month = \\'sep\\', revenue, null ) ) as sep_revenue,\\nsum( if( month = \\'oct\\', revenue, null ) ) as oct_revenue,\\nsum( if( month = \\'nov\\', revenue, null ) ) as nov_revenue,\\nsum( if( month = \\'dec\\', revenue, null ) ) as dec_revenue\\nfrom department\\ngroup by id\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,\\nsum( if( month = \\'jan\\', revenue, null ) ) as jan_revenue,\\nsum( if( month = \\'feb\\', revenue, null ) ) as feb_revenue,\\nsum( if( month = \\'mar\\', revenue, null ) ) as mar_revenue,\\nsum( if( month = \\'apr\\', revenue, null ) ) as apr_revenue,\\nsum( if( month = \\'may\\', revenue, null ) ) as may_revenue,\\nsum( if( month = \\'jun\\', revenue, null ) ) as jun_revenue,\\nsum( if( month = \\'jul\\', revenue, null ) ) as jul_revenue,\\nsum( if( month = \\'aug\\', revenue, null ) ) as aug_revenue,\\nsum( if( month = \\'sep\\', revenue, null ) ) as sep_revenue,\\nsum( if( month = \\'oct\\', revenue, null ) ) as oct_revenue,\\nsum( if( month = \\'nov\\', revenue, null ) ) as nov_revenue,\\nsum( if( month = \\'dec\\', revenue, null ) ) as dec_revenue\\nfrom department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2445371,
                "title": "mssql-solution-without-using-pivot-using-just-max-function",
                "content": "```\\n/* Write your T-SQL query statement below */\\n\\n;with sub1 as\\n(select id,\\ncase when month = \\'Jan\\' then revenue else null end as \\'Jan_Revenue\\',\\ncase when month = \\'Feb\\' then revenue else null end as \\'Feb_revenue\\',\\ncase when month = \\'Mar\\' then revenue else null end as \\'Mar_Revenue\\',\\ncase when month = \\'Apr\\' then revenue else null end as \\'Apr_revenue\\',\\ncase when month = \\'May\\' then revenue else null end as \\'May_Revenue\\',\\ncase when month = \\'Jun\\' then revenue else null end as \\'Jun_revenue\\',\\ncase when month = \\'Jul\\' then revenue else null end as \\'Jul_Revenue\\',\\ncase when month = \\'Aug\\' then revenue else null end as \\'Aug_revenue\\',\\ncase when month = \\'Sep\\' then revenue else null end as \\'Sep_Revenue\\',\\ncase when month = \\'Oct\\' then revenue else null end as \\'Oct_revenue\\',\\ncase when month = \\'Nov\\' then revenue else null end as \\'Nov_Revenue\\',\\ncase when month = \\'Dec\\' then revenue else null end as \\'Dec_revenue\\'\\nfrom Department)\\n\\n\\n\\n\\nselect id,\\nmax(Jan_Revenue) as \\'Jan_Revenue\\',\\nmax(Feb_revenue) as \\'Feb_revenue\\',\\nmax(Mar_Revenue) as \\'Mar_Revenue\\',\\nmax(Apr_revenue) as \\'Apr_revenue\\',\\nmax(May_Revenue) as \\'May_Revenue\\',\\nmax(Jun_revenue) as \\'Jun_revenue\\',\\nmax(Jul_Revenue) as \\'Jul_Revenue\\',\\nmax(Aug_revenue) as \\'Aug_revenue\\',\\nmax(Sep_Revenue) as \\'Sep_Revenue\\',\\nmax(Oct_revenue) as \\'Oct_revenue\\',\\nmax(Nov_Revenue) as \\'Nov_Revenue\\',\\nmax(Dec_revenue) as \\'Dec_revenue\\'\\nfrom sub1\\ngroup by id\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n;with sub1 as\\n(select id,\\ncase when month = \\'Jan\\' then revenue else null end as \\'Jan_Revenue\\',\\ncase when month = \\'Feb\\' then revenue else null end as \\'Feb_revenue\\',\\ncase when month = \\'Mar\\' then revenue else null end as \\'Mar_Revenue\\',\\ncase when month = \\'Apr\\' then revenue else null end as \\'Apr_revenue\\',\\ncase when month = \\'May\\' then revenue else null end as \\'May_Revenue\\',\\ncase when month = \\'Jun\\' then revenue else null end as \\'Jun_revenue\\',\\ncase when month = \\'Jul\\' then revenue else null end as \\'Jul_Revenue\\',\\ncase when month = \\'Aug\\' then revenue else null end as \\'Aug_revenue\\',\\ncase when month = \\'Sep\\' then revenue else null end as \\'Sep_Revenue\\',\\ncase when month = \\'Oct\\' then revenue else null end as \\'Oct_revenue\\',\\ncase when month = \\'Nov\\' then revenue else null end as \\'Nov_Revenue\\',\\ncase when month = \\'Dec\\' then revenue else null end as \\'Dec_revenue\\'\\nfrom Department)\\n\\n\\n\\n\\nselect id,\\nmax(Jan_Revenue) as \\'Jan_Revenue\\',\\nmax(Feb_revenue) as \\'Feb_revenue\\',\\nmax(Mar_Revenue) as \\'Mar_Revenue\\',\\nmax(Apr_revenue) as \\'Apr_revenue\\',\\nmax(May_Revenue) as \\'May_Revenue\\',\\nmax(Jun_revenue) as \\'Jun_revenue\\',\\nmax(Jul_Revenue) as \\'Jul_Revenue\\',\\nmax(Aug_revenue) as \\'Aug_revenue\\',\\nmax(Sep_Revenue) as \\'Sep_Revenue\\',\\nmax(Oct_revenue) as \\'Oct_revenue\\',\\nmax(Nov_Revenue) as \\'Nov_Revenue\\',\\nmax(Dec_revenue) as \\'Dec_revenue\\'\\nfrom sub1\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2402424,
                "title": "easy-mysql",
                "content": "\\n\\n```\\nSELECT id,\\nSUM((CASE WHEN month = \\'Jan\\' THEN revenue END)) as Jan_Revenue,\\nSUM((CASE WHEN month = \\'Feb\\' THEN revenue END)) as Feb_Revenue,\\nSUM((CASE WHEN month = \\'Mar\\' THEN revenue END)) as Mar_Revenue,\\nSUM((CASE WHEN month = \\'Apr\\' THEN revenue END)) as Apr_Revenue,\\nSUM((CASE WHEN month = \\'May\\' THEN revenue END)) as May_Revenue,\\nSUM((CASE WHEN month = \\'Jun\\' THEN revenue END)) as Jun_Revenue,\\nSUM((CASE WHEN month = \\'Jul\\' THEN revenue END)) as Jul_Revenue,\\nSUM((CASE WHEN month = \\'Aug\\' THEN revenue END)) as Aug_Revenue,\\nSUM((CASE WHEN month = \\'Sep\\' THEN revenue END)) as Sep_Revenue,\\nSUM((CASE WHEN month = \\'Oct\\' THEN revenue END)) as Oct_Revenue,\\nSUM((CASE WHEN month = \\'Nov\\' THEN revenue END)) as Nov_Revenue,\\nSUM((CASE WHEN month = \\'Dec\\' THEN revenue END)) as Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT id,\\nSUM((CASE WHEN month = \\'Jan\\' THEN revenue END)) as Jan_Revenue,\\nSUM((CASE WHEN month = \\'Feb\\' THEN revenue END)) as Feb_Revenue,\\nSUM((CASE WHEN month = \\'Mar\\' THEN revenue END)) as Mar_Revenue,\\nSUM((CASE WHEN month = \\'Apr\\' THEN revenue END)) as Apr_Revenue,\\nSUM((CASE WHEN month = \\'May\\' THEN revenue END)) as May_Revenue,\\nSUM((CASE WHEN month = \\'Jun\\' THEN revenue END)) as Jun_Revenue,\\nSUM((CASE WHEN month = \\'Jul\\' THEN revenue END)) as Jul_Revenue,\\nSUM((CASE WHEN month = \\'Aug\\' THEN revenue END)) as Aug_Revenue,\\nSUM((CASE WHEN month = \\'Sep\\' THEN revenue END)) as Sep_Revenue,\\nSUM((CASE WHEN month = \\'Oct\\' THEN revenue END)) as Oct_Revenue,\\nSUM((CASE WHEN month = \\'Nov\\' THEN revenue END)) as Nov_Revenue,\\nSUM((CASE WHEN month = \\'Dec\\' THEN revenue END)) as Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2362915,
                "title": "oracle-with-pivot",
                "content": "```\\nselect * from\\nDepartment\\npivot \\n(\\n   max(revenue) \\n   for month in (\\'Jan\\' as \"Jan_Revenue\", \\n                 \\'Feb\\' as \"Feb_Revenue\",\\n                 \\'Mar\\' as \"Mar_Revenue\",\\n                 \\'Apr\\' as \"Apr_Revenue\",\\n                 \\'May\\' as \"May_Revenue\",\\n                 \\'Jun\\' as \"Jun_Revenue\",\\n                 \\'Jul\\' as \"Jul_Revenue\",\\n                 \\'Aug\\' as \"Aug_Revenue\",\\n                 \\'Sep\\' as \"Sep_Revenue\",\\n                 \\'Oct\\' as \"Oct_Revenue\",\\n                 \\'Nov\\' as \"Nov_Revenue\",\\n                 \\'Dec\\' as \"Dec_Revenue\")\\n)\\norder by id\\n```",
                "solutionTags": [],
                "code": "```\\nselect * from\\nDepartment\\npivot \\n(\\n   max(revenue) \\n   for month in (\\'Jan\\' as \"Jan_Revenue\", \\n                 \\'Feb\\' as \"Feb_Revenue\",\\n                 \\'Mar\\' as \"Mar_Revenue\",\\n                 \\'Apr\\' as \"Apr_Revenue\",\\n                 \\'May\\' as \"May_Revenue\",\\n                 \\'Jun\\' as \"Jun_Revenue\",\\n                 \\'Jul\\' as \"Jul_Revenue\",\\n                 \\'Aug\\' as \"Aug_Revenue\",\\n                 \\'Sep\\' as \"Sep_Revenue\",\\n                 \\'Oct\\' as \"Oct_Revenue\",\\n                 \\'Nov\\' as \"Nov_Revenue\",\\n                 \\'Dec\\' as \"Dec_Revenue\")\\n)\\norder by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2341969,
                "title": "mysql-solution",
                "content": "SELECT id,\\n       MAX(CASE WHEN month = \\'Jan\\' THEN revenue END) Jan_Revenue,\\n       MAX(CASE WHEN month = \\'Feb\\' THEN revenue END) Feb_Revenue,\\n       MAX(CASE WHEN month = \\'Mar\\' THEN revenue END) Mar_Revenue,\\n       MAX(CASE WHEN month = \\'Apr\\' THEN revenue END) Apr_Revenue,\\n       MAX(CASE WHEN month = \\'May\\' THEN revenue END) May_Revenue,\\n       MAX(CASE WHEN month = \\'Jun\\' THEN revenue END) Jun_Revenue,\\n       MAX(CASE WHEN month = \\'Jul\\' THEN revenue END) Jul_Revenue,\\n       MAX(CASE WHEN month = \\'Aug\\' THEN revenue END) Aug_Revenue,\\n       MAX(CASE WHEN month = \\'Sep\\' THEN revenue END) Sep_Revenue,\\n       MAX(CASE WHEN month = \\'Oct\\' THEN revenue END) Oct_Revenue,\\n       MAX(CASE WHEN month = \\'Nov\\' THEN revenue END) Nov_Revenue,\\n       MAX(CASE WHEN month = \\'Dec\\' THEN revenue END) Dec_Revenue\\n  FROM Department\\n GROUP BY id",
                "solutionTags": [],
                "code": "SELECT id,\\n       MAX(CASE WHEN month = \\'Jan\\' THEN revenue END) Jan_Revenue,\\n       MAX(CASE WHEN month = \\'Feb\\' THEN revenue END) Feb_Revenue,\\n       MAX(CASE WHEN month = \\'Mar\\' THEN revenue END) Mar_Revenue,\\n       MAX(CASE WHEN month = \\'Apr\\' THEN revenue END) Apr_Revenue,\\n       MAX(CASE WHEN month = \\'May\\' THEN revenue END) May_Revenue,\\n       MAX(CASE WHEN month = \\'Jun\\' THEN revenue END) Jun_Revenue,\\n       MAX(CASE WHEN month = \\'Jul\\' THEN revenue END) Jul_Revenue,\\n       MAX(CASE WHEN month = \\'Aug\\' THEN revenue END) Aug_Revenue,\\n       MAX(CASE WHEN month = \\'Sep\\' THEN revenue END) Sep_Revenue,\\n       MAX(CASE WHEN month = \\'Oct\\' THEN revenue END) Oct_Revenue,\\n       MAX(CASE WHEN month = \\'Nov\\' THEN revenue END) Nov_Revenue,\\n       MAX(CASE WHEN month = \\'Dec\\' THEN revenue END) Dec_Revenue\\n  FROM Department\\n GROUP BY id",
                "codeTag": "Unknown"
            },
            {
                "id": 2334857,
                "title": "faster-than-77-09-using-pivot-ms-sql-easy-to-understand",
                "content": "```\\nselect id ,jan as jan_revenue,feb as feb_revenue,mar as mar_revenue,apr as apr_revenue,may as may_revenue,jun as jun_revenue,jul as jul_revenue,aug as aug_revenue,sep as sep_revenue,oct as oct_revenue,nov as nov_revenue,dec as dec_revenue from department \\npivot\\n(\\nsum(revenue) for month in (jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec)\\n) as pivot_table\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect id ,jan as jan_revenue,feb as feb_revenue,mar as mar_revenue,apr as apr_revenue,may as may_revenue,jun as jun_revenue,jul as jul_revenue,aug as aug_revenue,sep as sep_revenue,oct as oct_revenue,nov as nov_revenue,dec as dec_revenue from department \\npivot\\n(\\nsum(revenue) for month in (jan,feb,mar,apr,may,jun,jul,aug,sep,oct,nov,dec)\\n) as pivot_table\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322703,
                "title": "1179-reformat-department-table-fast-easy-to-understand-mysql",
                "content": "# Write your MySQL query statement below\\nselect distinct id,\\nsum(if(month = \\'Jan\\',revenue,null)) as \\'Jan_Revenue\\',\\nsum(if(month = \\'Feb\\',revenue,null)) as \\'Feb_Revenue\\',\\nsum(if(month = \\'Mar\\',revenue,null)) as \\'Mar_Revenue\\',\\nsum(if(month = \\'Apr\\',revenue,null)) as \\'Apr_Revenue\\',\\nsum(if(month = \\'May\\',revenue,null)) as \\'May_Revenue\\',\\nsum(if(month = \\'Jun\\',revenue,null)) as \\'Jun_Revenue\\',\\nsum(if(month = \\'Jul\\',revenue,null)) as \\'Jul_Revenue\\',\\nsum(if(month = \\'Aug\\',revenue,null)) as \\'Aug_Revenue\\',\\nsum(if(month = \\'Sep\\',revenue,null)) as \\'Sep_Revenue\\',\\nsum(if(month = \\'Oct\\',revenue,null)) as \\'Oct_Revenue\\',\\nsum(if(month = \\'Nov\\',revenue,null)) as \\'Nov_Revenue\\',\\nsum(if(month = \\'Dec\\',revenue,null)) as \\'Dec_Revenue\\'\\nfrom department\\ngroup by 1",
                "solutionTags": [],
                "code": "# Write your MySQL query statement below\\nselect distinct id,\\nsum(if(month = \\'Jan\\',revenue,null)) as \\'Jan_Revenue\\',\\nsum(if(month = \\'Feb\\',revenue,null)) as \\'Feb_Revenue\\',\\nsum(if(month = \\'Mar\\',revenue,null)) as \\'Mar_Revenue\\',\\nsum(if(month = \\'Apr\\',revenue,null)) as \\'Apr_Revenue\\',\\nsum(if(month = \\'May\\',revenue,null)) as \\'May_Revenue\\',\\nsum(if(month = \\'Jun\\',revenue,null)) as \\'Jun_Revenue\\',\\nsum(if(month = \\'Jul\\',revenue,null)) as \\'Jul_Revenue\\',\\nsum(if(month = \\'Aug\\',revenue,null)) as \\'Aug_Revenue\\',\\nsum(if(month = \\'Sep\\',revenue,null)) as \\'Sep_Revenue\\',\\nsum(if(month = \\'Oct\\',revenue,null)) as \\'Oct_Revenue\\',\\nsum(if(month = \\'Nov\\',revenue,null)) as \\'Nov_Revenue\\',\\nsum(if(month = \\'Dec\\',revenue,null)) as \\'Dec_Revenue\\'\\nfrom department\\ngroup by 1",
                "codeTag": "Unknown"
            },
            {
                "id": 2178602,
                "title": "easiest-solution-using-case-when",
                "content": "```\\nselect id,\\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nselect id,\\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id",
                "codeTag": "Unknown"
            },
            {
                "id": 2174089,
                "title": "just-pivot-it",
                "content": "USE PIVOT AND WILL BE FINISHED IN NO TIME  \\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n    ID AS id,\\n    JAN AS \\'Jan_Revenue\\', FEB AS \\'Feb_Revenue\\', MAR AS \\'Mar_Revenue\\', APR AS \\'Apr_Revenue\\', MAY AS \\'May_Revenue\\', JUN AS \\'Jun_Revenue\\', JUL AS \\'Jul_Revenue\\',\\n    AUG AS \\'Aug_Revenue\\', SEP AS \\'Sep_Revenue\\', OCT AS \\'Oct_Revenue\\', NOV AS \\'Nov_Revenue\\', DEC AS \\'Dec_Revenue\\'\\nFROM (\\n    SELECT\\n        *\\n    FROM\\n        DEPARTMENT\\n) A\\nPIVOT (\\n    SUM(REVENUE) FOR MONTH IN (JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC)\\n) PVT\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n    ID AS id,\\n    JAN AS \\'Jan_Revenue\\', FEB AS \\'Feb_Revenue\\', MAR AS \\'Mar_Revenue\\', APR AS \\'Apr_Revenue\\', MAY AS \\'May_Revenue\\', JUN AS \\'Jun_Revenue\\', JUL AS \\'Jul_Revenue\\',\\n    AUG AS \\'Aug_Revenue\\', SEP AS \\'Sep_Revenue\\', OCT AS \\'Oct_Revenue\\', NOV AS \\'Nov_Revenue\\', DEC AS \\'Dec_Revenue\\'\\nFROM (\\n    SELECT\\n        *\\n    FROM\\n        DEPARTMENT\\n) A\\nPIVOT (\\n    SUM(REVENUE) FOR MONTH IN (JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC)\\n) PVT\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2131916,
                "title": "fastest-and-easiest-solution-using-case-when",
                "content": "\\n```\\nselect id,\\nsum(case when [month]=\\'Jan\\' then revenue end) as Jan_revenue,sum(case when [month]=\\'Feb\\' then revenue end) as Feb_revenue,\\nsum(case when [month]=\\'Mar\\' then revenue end) as Mar_revenue,sum(case when [month]=\\'Apr\\' then revenue end) as Apr_revenue,\\nsum(case when [month]=\\'May\\' then revenue end) as May_revenue,sum(case when [month]=\\'Jun\\' then revenue end) as Jun_revenue,\\nsum(case when [month]=\\'Jul\\' then revenue end) as Jul_revenue,sum(case when [month]=\\'Aug\\' then revenue end) as Aug_revenue,\\nsum(case when [month]=\\'Sep\\' then revenue end) as Sep_revenue,sum(case when [month]=\\'Oct\\' then revenue end) as Oct_revenue,\\nsum(case when [month]=\\'Nov\\' then revenue end) as Nov_revenue,sum(case when [month]=\\'Dec\\' then revenue end) as Dec_revenue\\nfrom Department group by id\\n \\n```",
                "solutionTags": [],
                "code": "```\\nselect id,\\nsum(case when [month]=\\'Jan\\' then revenue end) as Jan_revenue,sum(case when [month]=\\'Feb\\' then revenue end) as Feb_revenue,\\nsum(case when [month]=\\'Mar\\' then revenue end) as Mar_revenue,sum(case when [month]=\\'Apr\\' then revenue end) as Apr_revenue,\\nsum(case when [month]=\\'May\\' then revenue end) as May_revenue,sum(case when [month]=\\'Jun\\' then revenue end) as Jun_revenue,\\nsum(case when [month]=\\'Jul\\' then revenue end) as Jul_revenue,sum(case when [month]=\\'Aug\\' then revenue end) as Aug_revenue,\\nsum(case when [month]=\\'Sep\\' then revenue end) as Sep_revenue,sum(case when [month]=\\'Oct\\' then revenue end) as Oct_revenue,\\nsum(case when [month]=\\'Nov\\' then revenue end) as Nov_revenue,sum(case when [month]=\\'Dec\\' then revenue end) as Dec_revenue\\nfrom Department group by id\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2079485,
                "title": "using-pivot",
                "content": "SELECT id, Jan as \"Jan_Revenue\", Feb as \"Feb_Revenue\", Mar as \"Mar_Revenue\", Apr as \"Apr_Revenue\", May as \"May_Revenue\", Jun as \"Jun_Revenue\", Jul as \"Jul_Revenue\", Aug as \"Aug_Revenue\", Sep as \"Sep_Revenue\", Oct as \"Oct_Revenue\", Nov as \"Nov_Revenue\", Dec as \"Dec_Revenue\" FROM   \\n(SELECT id, Month , Revenue FROM Department )Tab1  \\nPIVOT  \\n(  \\nSUM(Revenue) FOR month IN (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec)) AS Tab2",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "SELECT id, Jan as \"Jan_Revenue\", Feb as \"Feb_Revenue\", Mar as \"Mar_Revenue\", Apr as \"Apr_Revenue\", May as \"May_Revenue\", Jun as \"Jun_Revenue\", Jul as \"Jul_Revenue\", Aug as \"Aug_Revenue\", Sep as \"Sep_Revenue\", Oct as \"Oct_Revenue\", Nov as \"Nov_Revenue\", Dec as \"Dec_Revenue\" FROM   \\n(SELECT id, Month , Revenue FROM Department )Tab1  \\nPIVOT  \\n(  \\nSUM(Revenue) FOR month IN (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec)) AS Tab2",
                "codeTag": "Unknown"
            },
            {
                "id": 2043861,
                "title": "ms-sql-sum-case-group-by-solutions",
                "content": "```\\nSELECT id,\\nSUM(CASE WHEN month=\\'Jan\\' THEN revenue END) AS Jan_Revenue,\\nSUM(CASE WHEN month=\\'Feb\\' THEN revenue END) AS Feb_Revenue,\\nSUM(CASE WHEN month=\\'Mar\\' THEN revenue END) AS Mar_Revenue,\\nSUM(CASE WHEN month=\\'Apr\\' THEN revenue END) AS Apr_Revenue,\\nSUM(CASE WHEN month=\\'May\\' THEN revenue END) AS May_Revenue,\\nSUM(CASE WHEN month=\\'Jun\\' THEN revenue END) AS Jun_Revenue,\\nSUM(CASE WHEN month=\\'Jul\\' THEN revenue END) AS Jul_Revenue,\\nSUM(CASE WHEN month=\\'Aug\\' THEN revenue END) AS Aug_Revenue,\\nSUM(CASE WHEN month=\\'Sep\\' THEN revenue END) AS Sep_Revenue,\\nSUM(CASE WHEN month=\\'Oct\\' THEN revenue END) AS Oct_Revenue,\\nSUM(CASE WHEN month=\\'Nov\\' THEN revenue END) AS Nov_Revenue,\\nSUM(CASE WHEN month=\\'Dec\\' THEN revenue END) AS Dec_Revenue    \\nFROM Department\\nGROUP BY id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id,\\nSUM(CASE WHEN month=\\'Jan\\' THEN revenue END) AS Jan_Revenue,\\nSUM(CASE WHEN month=\\'Feb\\' THEN revenue END) AS Feb_Revenue,\\nSUM(CASE WHEN month=\\'Mar\\' THEN revenue END) AS Mar_Revenue,\\nSUM(CASE WHEN month=\\'Apr\\' THEN revenue END) AS Apr_Revenue,\\nSUM(CASE WHEN month=\\'May\\' THEN revenue END) AS May_Revenue,\\nSUM(CASE WHEN month=\\'Jun\\' THEN revenue END) AS Jun_Revenue,\\nSUM(CASE WHEN month=\\'Jul\\' THEN revenue END) AS Jul_Revenue,\\nSUM(CASE WHEN month=\\'Aug\\' THEN revenue END) AS Aug_Revenue,\\nSUM(CASE WHEN month=\\'Sep\\' THEN revenue END) AS Sep_Revenue,\\nSUM(CASE WHEN month=\\'Oct\\' THEN revenue END) AS Oct_Revenue,\\nSUM(CASE WHEN month=\\'Nov\\' THEN revenue END) AS Nov_Revenue,\\nSUM(CASE WHEN month=\\'Dec\\' THEN revenue END) AS Dec_Revenue    \\nFROM Department\\nGROUP BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988253,
                "title": "solution-through-if",
                "content": "```\\nselect id,\\n       sum(if(month = \\'Jan\\', revenue, Null)) Jan_Revenue,\\n       sum(if(month = \\'Feb\\', revenue, Null)) Feb_Revenue,\\n       sum(if(month = \\'Mar\\', revenue, Null)) Mar_Revenue,\\n       sum(if(month = \\'Apr\\', revenue, Null)) Apr_Revenue,\\n       sum(if(month = \\'May\\', revenue, Null)) May_Revenue,\\n       sum(if(month = \\'Jun\\', revenue, Null)) Jun_Revenue,\\n       sum(if(month = \\'Jul\\', revenue, Null)) Jul_Revenue,\\n       sum(if(month = \\'Aug\\', revenue, Null)) Aug_Revenue,\\n       sum(if(month = \\'Sep\\', revenue, Null)) Sep_Revenue,\\n       sum(if(month = \\'Oct\\', revenue, Null)) Oct_Revenue,\\n       sum(if(month = \\'Nov\\', revenue, Null)) Nov_Revenue,\\n       sum(if(month = \\'Dec\\', revenue, Null)) Dec_Revenue\\nfrom Department\\ngroup by id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect id,\\n       sum(if(month = \\'Jan\\', revenue, Null)) Jan_Revenue,\\n       sum(if(month = \\'Feb\\', revenue, Null)) Feb_Revenue,\\n       sum(if(month = \\'Mar\\', revenue, Null)) Mar_Revenue,\\n       sum(if(month = \\'Apr\\', revenue, Null)) Apr_Revenue,\\n       sum(if(month = \\'May\\', revenue, Null)) May_Revenue,\\n       sum(if(month = \\'Jun\\', revenue, Null)) Jun_Revenue,\\n       sum(if(month = \\'Jul\\', revenue, Null)) Jul_Revenue,\\n       sum(if(month = \\'Aug\\', revenue, Null)) Aug_Revenue,\\n       sum(if(month = \\'Sep\\', revenue, Null)) Sep_Revenue,\\n       sum(if(month = \\'Oct\\', revenue, Null)) Oct_Revenue,\\n       sum(if(month = \\'Nov\\', revenue, Null)) Nov_Revenue,\\n       sum(if(month = \\'Dec\\', revenue, Null)) Dec_Revenue\\nfrom Department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1981838,
                "title": "mysql-by-using-min",
                "content": "```\\nselect id,\\nmin(case when month = \\'Jan\\' then Revenue end) as Jan_Revenue,\\nmin(case when month = \\'Feb\\' then Revenue end) as Feb_Revenue,\\nmin(case when month = \\'Mar\\' then Revenue end) as Mar_Revenue,\\nmin(case when month = \\'Apr\\' then Revenue end) as Apr_Revenue,\\nmin(case when month = \\'May\\' then Revenue end) as May_Revenue,\\nmin(case when month = \\'Jun\\' then Revenue end) as Jun_Revenue,\\nmin(case when month = \\'Jul\\' then Revenue end) as Jul_Revenue,\\nmin(case when month = \\'Aug\\' then Revenue end) as Aug_Revenue,\\nmin(case when month = \\'Sep\\' then Revenue end) as Sep_Revenue,\\nmin(case when month = \\'Oct\\' then Revenue end) as Oct_Revenue,\\nmin(case when month = \\'Nov\\' then Revenue end) as Nov_Revenue,\\nmin(case when month = \\'Dec\\' then Revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id\\n```\\n```\\n```\\n**If Helpful Please Like and Upvoke**",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect id,\\nmin(case when month = \\'Jan\\' then Revenue end) as Jan_Revenue,\\nmin(case when month = \\'Feb\\' then Revenue end) as Feb_Revenue,\\nmin(case when month = \\'Mar\\' then Revenue end) as Mar_Revenue,\\nmin(case when month = \\'Apr\\' then Revenue end) as Apr_Revenue,\\nmin(case when month = \\'May\\' then Revenue end) as May_Revenue,\\nmin(case when month = \\'Jun\\' then Revenue end) as Jun_Revenue,\\nmin(case when month = \\'Jul\\' then Revenue end) as Jul_Revenue,\\nmin(case when month = \\'Aug\\' then Revenue end) as Aug_Revenue,\\nmin(case when month = \\'Sep\\' then Revenue end) as Sep_Revenue,\\nmin(case when month = \\'Oct\\' then Revenue end) as Oct_Revenue,\\nmin(case when month = \\'Nov\\' then Revenue end) as Nov_Revenue,\\nmin(case when month = \\'Dec\\' then Revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1972332,
                "title": "mysql-solution-easy-and-fast",
                "content": "# Solution\\n```\\nSELECT \\n       id,\\n       SUM(CASE WHEN month = \\'Jan\\' THEN revenue ELSE null END) AS \\'Jan_Revenue\\',\\n       SUM(CASE WHEN month = \\'Feb\\' THEN revenue ELSE null END) AS \\'Feb_Revenue\\',\\n       SUM(CASE WHEN month = \\'Mar\\' THEN revenue ELSE null END) AS \\'Mar_Revenue\\',\\n       SUM(CASE WHEN month = \\'Apr\\' THEN revenue ELSE null END) AS \\'Apr_Revenue\\',\\n       SUM(CASE WHEN month = \\'May\\' THEN revenue ELSE null END) AS \\'May_Revenue\\',\\n       SUM(CASE WHEN month = \\'Jun\\' THEN revenue ELSE null END) AS \\'Jun_Revenue\\',\\n       SUM(CASE WHEN month = \\'Jul\\' THEN revenue ELSE null END) AS \\'Jul_Revenue\\',\\n       SUM(CASE WHEN month = \\'Aug\\' THEN revenue ELSE null END) AS \\'Aug_Revenue\\',\\n       SUM(CASE WHEN month = \\'Sep\\' THEN revenue ELSE null END) AS \\'Sep_Revenue\\',\\n       SUM(CASE WHEN month = \\'Oct\\' THEN revenue ELSE null END) AS \\'Oct_Revenue\\',\\n       SUM(CASE WHEN month = \\'Nov\\' THEN revenue ELSE null END) AS \\'Nov_Revenue\\',\\n       SUM(CASE WHEN month = \\'Dec\\' THEN revenue ELSE null END) AS \\'Dec_Revenue\\'\\nFROM Department\\nGROUP BY Id\\n```\\nThe **CASE** statement goes through conditions and returns a value when the first condition is met (like an if-then-else statement). So, once a condition is true, it will stop reading and return the result. If no conditions are true, it returns the value in the ELSE clause.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n       id,\\n       SUM(CASE WHEN month = \\'Jan\\' THEN revenue ELSE null END) AS \\'Jan_Revenue\\',\\n       SUM(CASE WHEN month = \\'Feb\\' THEN revenue ELSE null END) AS \\'Feb_Revenue\\',\\n       SUM(CASE WHEN month = \\'Mar\\' THEN revenue ELSE null END) AS \\'Mar_Revenue\\',\\n       SUM(CASE WHEN month = \\'Apr\\' THEN revenue ELSE null END) AS \\'Apr_Revenue\\',\\n       SUM(CASE WHEN month = \\'May\\' THEN revenue ELSE null END) AS \\'May_Revenue\\',\\n       SUM(CASE WHEN month = \\'Jun\\' THEN revenue ELSE null END) AS \\'Jun_Revenue\\',\\n       SUM(CASE WHEN month = \\'Jul\\' THEN revenue ELSE null END) AS \\'Jul_Revenue\\',\\n       SUM(CASE WHEN month = \\'Aug\\' THEN revenue ELSE null END) AS \\'Aug_Revenue\\',\\n       SUM(CASE WHEN month = \\'Sep\\' THEN revenue ELSE null END) AS \\'Sep_Revenue\\',\\n       SUM(CASE WHEN month = \\'Oct\\' THEN revenue ELSE null END) AS \\'Oct_Revenue\\',\\n       SUM(CASE WHEN month = \\'Nov\\' THEN revenue ELSE null END) AS \\'Nov_Revenue\\',\\n       SUM(CASE WHEN month = \\'Dec\\' THEN revenue ELSE null END) AS \\'Dec_Revenue\\'\\nFROM Department\\nGROUP BY Id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845866,
                "title": "mysql-and-postgres-simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\nselect id, \\nsum(case when month=\\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month=\\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month=\\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month=\\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month=\\'May\\' then revenue end) as May_Revenue,\\nsum(case when month=\\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month=\\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month=\\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month=\\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month=\\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month=\\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month=\\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect id, \\nsum(case when month=\\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month=\\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month=\\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month=\\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month=\\'May\\' then revenue end) as May_Revenue,\\nsum(case when month=\\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month=\\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month=\\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month=\\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month=\\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month=\\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month=\\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795039,
                "title": "simple-solution-using-pivot",
                "content": "\\nselect *\\nfrom Department\\npivot\\n(\\n    sum(revenue)\\n    for \\n    month in(\\'Jan\\' as Jan_Revenue,\\n             \\'Feb\\' as Feb_Revenue,\\n             \\'Mar\\' as Mar_Revenue,\\n             \\'Apr\\' as Apr_Revenue,\\n             \\'May\\' as May_Revenue,\\n             \\'Jun\\' as Jun_Revenue,\\n             \\'Jul\\' as Jul_Revenue,\\n             \\'Aug\\' as Aug_Revenue,\\n             \\'Sep\\' as Sep_Revenue,\\n             \\'Oct\\' as Oct_Revenue,\\n             \\'Nov\\' as Nov_Revenue,\\n             \\'Dec\\' as Dec_Revenue)\\n)",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "\\nselect *\\nfrom Department\\npivot\\n(\\n    sum(revenue)\\n    for \\n    month in(\\'Jan\\' as Jan_Revenue,\\n             \\'Feb\\' as Feb_Revenue,\\n             \\'Mar\\' as Mar_Revenue,\\n             \\'Apr\\' as Apr_Revenue,\\n             \\'May\\' as May_Revenue,\\n             \\'Jun\\' as Jun_Revenue,\\n             \\'Jul\\' as Jul_Revenue,\\n             \\'Aug\\' as Aug_Revenue,\\n             \\'Sep\\' as Sep_Revenue,\\n             \\'Oct\\' as Oct_Revenue,\\n             \\'Nov\\' as Nov_Revenue,\\n             \\'Dec\\' as Dec_Revenue)\\n)",
                "codeTag": "Unknown"
            },
            {
                "id": 1728162,
                "title": "case-statement-question-why-we-need-sum-for-each-case-statement",
                "content": "``` select id, \\nCASE WHEN month= \\'Jan\\' then revenue END as Jan_Revenue , \\nCASE WHEN month= \\'Feb\\' then revenue END as Feb_Revenue , \\nCASE WHEN month= \\'Mar\\' then revenue END as Mar_Revenue , \\nCASE WHEN month= \\'Apr\\' then revenue END as Apr_Revenue , \\nCASE WHEN month= \\'May\\' then revenue END as May_Revenue ,\\nCASE WHEN month= \\'Jun\\' then revenue END as Jun_Revenue ,\\nCASE WHEN month= \\'Jul\\' then revenue END as Jul_Revenue ,\\nCASE WHEN month= \\'Aug\\' then revenue END as Aug_Revenue ,\\nCASE WHEN month= \\'Sep\\' then revenue END as Sep_Revenue ,\\nCASE WHEN month= \\'Oct\\' then revenue END as Oct_Revenue ,\\nCASE WHEN month= \\'Nov\\' then revenue END as Nov_Revenue ,\\nCASE WHEN month= \\'Dec\\' then revenue END as Dec_Revenue \\nfrom Department group by id ```\\nwhen I code without sum(), the Feb and Mar will show null instead of the revenue number for the example. I don\\'t understand why sum() would return the true value.",
                "solutionTags": [],
                "code": "``` select id, \\nCASE WHEN month= \\'Jan\\' then revenue END as Jan_Revenue , \\nCASE WHEN month= \\'Feb\\' then revenue END as Feb_Revenue , \\nCASE WHEN month= \\'Mar\\' then revenue END as Mar_Revenue , \\nCASE WHEN month= \\'Apr\\' then revenue END as Apr_Revenue , \\nCASE WHEN month= \\'May\\' then revenue END as May_Revenue ,\\nCASE WHEN month= \\'Jun\\' then revenue END as Jun_Revenue ,\\nCASE WHEN month= \\'Jul\\' then revenue END as Jul_Revenue ,\\nCASE WHEN month= \\'Aug\\' then revenue END as Aug_Revenue ,\\nCASE WHEN month= \\'Sep\\' then revenue END as Sep_Revenue ,\\nCASE WHEN month= \\'Oct\\' then revenue END as Oct_Revenue ,\\nCASE WHEN month= \\'Nov\\' then revenue END as Nov_Revenue ,\\nCASE WHEN month= \\'Dec\\' then revenue END as Dec_Revenue \\nfrom Department group by id ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1679362,
                "title": "ms-sql-server-pivot-function",
                "content": "```\\nselect\\n    id\\n     , Jan as Jan_Revenue\\n     , Feb as Feb_Revenue\\n     , Mar as Mar_Revenue\\n     , Apr as Apr_Revenue\\n     , May as May_Revenue\\n     , Jun as Jun_Revenue\\n     , Jul as Jul_Revenue\\n     , Aug as Aug_Revenue\\n     , Sep as Sep_Revenue\\n     , Oct as Oct_Revenue\\n     , Nov as Nov_Revenue\\n     , Dec as Dec_Revenue\\nfrom \\n(\\n    select\\n        id\\n        , revenue\\n        , month\\n    from department\\n) as a\\npivot (sum(a.revenue)\\n      for month in ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n      ) as pivot_1\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    id\\n     , Jan as Jan_Revenue\\n     , Feb as Feb_Revenue\\n     , Mar as Mar_Revenue\\n     , Apr as Apr_Revenue\\n     , May as May_Revenue\\n     , Jun as Jun_Revenue\\n     , Jul as Jul_Revenue\\n     , Aug as Aug_Revenue\\n     , Sep as Sep_Revenue\\n     , Oct as Oct_Revenue\\n     , Nov as Nov_Revenue\\n     , Dec as Dec_Revenue\\nfrom \\n(\\n    select\\n        id\\n        , revenue\\n        , month\\n    from department\\n) as a\\npivot (sum(a.revenue)\\n      for month in ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n      ) as pivot_1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578712,
                "title": "simple-and-easy-oracle-solution",
                "content": "select\\nid,\\nsum(case when month =\\'Jan\\' then revenue end) Jan_Revenue,\\nsum(case when month =\\'Feb\\' then revenue end) Feb_Revenue,\\nsum(case when month =\\'Mar\\' then revenue end) Mar_Revenue,\\nsum(case when month =\\'Apr\\' then revenue end) Apr_Revenue,\\nsum(case when month =\\'May\\' then revenue end) May_Revenue,\\nsum(case when month =\\'Jun\\' then revenue end) Jun_Revenue,\\nsum(case when month =\\'Jul\\' then revenue end) Jul_Revenue,\\nsum(case when month =\\'Aug\\' then revenue end) Aug_Revenue,\\nsum(case when month =\\'Sep\\' then revenue end) Sep_Revenue,\\nsum(case when month =\\'Oct\\' then revenue end) Oct_Revenue,\\nsum(case when month =\\'Nov\\' then revenue end) Nov_Revenue,\\nsum(case when month =\\'Dec\\' then revenue end) Dec_Revenue\\nfrom Department\\ngroup by id",
                "solutionTags": [],
                "code": "select\\nid,\\nsum(case when month =\\'Jan\\' then revenue end) Jan_Revenue,\\nsum(case when month =\\'Feb\\' then revenue end) Feb_Revenue,\\nsum(case when month =\\'Mar\\' then revenue end) Mar_Revenue,\\nsum(case when month =\\'Apr\\' then revenue end) Apr_Revenue,\\nsum(case when month =\\'May\\' then revenue end) May_Revenue,\\nsum(case when month =\\'Jun\\' then revenue end) Jun_Revenue,\\nsum(case when month =\\'Jul\\' then revenue end) Jul_Revenue,\\nsum(case when month =\\'Aug\\' then revenue end) Aug_Revenue,\\nsum(case when month =\\'Sep\\' then revenue end) Sep_Revenue,\\nsum(case when month =\\'Oct\\' then revenue end) Oct_Revenue,\\nsum(case when month =\\'Nov\\' then revenue end) Nov_Revenue,\\nsum(case when month =\\'Dec\\' then revenue end) Dec_Revenue\\nfrom Department\\ngroup by id",
                "codeTag": "Unknown"
            },
            {
                "id": 1568840,
                "title": "my-brutal-force-solution-lol",
                "content": "```\\nwith\\n    Dept_Id as (select distinct id from Department),\\n    Jan_Revenue as (select id, revenue from Department where month=\\'Jan\\'),\\n    Feb_Revenue as (select id, revenue from Department where month=\\'Feb\\'),\\n    Mar_Revenue as (select id, revenue from Department where month=\\'Mar\\'),\\n    Apr_Revenue as (select id, revenue from Department where month=\\'Apr\\'),\\n    May_Revenue as (select id, revenue from Department where month=\\'May\\'),\\n    Jun_Revenue as (select id, revenue from Department where month=\\'Jun\\'),\\n    Jul_Revenue as (select id, revenue from Department where month=\\'Jul\\'),\\n    Aug_Revenue as (select id, revenue from Department where month=\\'Aug\\'),\\n    Sep_Revenue as (select id, revenue from Department where month=\\'Sep\\'),\\n    Oct_Revenue as (select id, revenue from Department where month=\\'Oct\\'),\\n    Nov_Revenue as (select id, revenue from Department where month=\\'Nov\\'),\\n    Dec_Revenue as (select id, revenue from Department where month=\\'Dec\\')\\nselect\\n    d.id as id, \\n    m1.revenue as \\'Jan_Revenue\\',\\n    m2.revenue as \\'Feb_Revenue\\',\\n    m3.revenue as \\'Mar_Revenue\\',\\n    m4.revenue as \\'Apr_Revenue\\',\\n    m5.revenue as \\'May_Revenue\\',\\n    m6.revenue as \\'Jun_Revenue\\',\\n    m7.revenue as \\'Jul_Revenue\\',\\n    m8.revenue as \\'Aug_Revenue\\',\\n    m9.revenue as \\'Sep_Revenue\\',\\n    m10.revenue as \\'Oct_Revenue\\',\\n    m11.revenue as \\'Nov_Revenue\\',\\n    m12.revenue as \\'Dec_Revenue\\'\\nfrom Dept_Id d\\n    left join Jan_Revenue m1 using (id)\\n    left join Feb_Revenue m2 using (id)\\n    left join Mar_Revenue m3 using (id)\\n    left join Apr_Revenue m4 using (id)\\n    left join May_Revenue m5 using (id)\\n    left join Jun_Revenue m6 using (id)\\n    left join Jul_Revenue m7 using (id)\\n    left join Aug_Revenue m8 using (id)\\n    left join Sep_Revenue m9 using (id)\\n    left join Oct_Revenue m10 using (id)\\n    left join Nov_Revenue m11 using (id)\\n    left join Dec_Revenue m12 using (id);\\n```",
                "solutionTags": [],
                "code": "```\\nwith\\n    Dept_Id as (select distinct id from Department),\\n    Jan_Revenue as (select id, revenue from Department where month=\\'Jan\\'),\\n    Feb_Revenue as (select id, revenue from Department where month=\\'Feb\\'),\\n    Mar_Revenue as (select id, revenue from Department where month=\\'Mar\\'),\\n    Apr_Revenue as (select id, revenue from Department where month=\\'Apr\\'),\\n    May_Revenue as (select id, revenue from Department where month=\\'May\\'),\\n    Jun_Revenue as (select id, revenue from Department where month=\\'Jun\\'),\\n    Jul_Revenue as (select id, revenue from Department where month=\\'Jul\\'),\\n    Aug_Revenue as (select id, revenue from Department where month=\\'Aug\\'),\\n    Sep_Revenue as (select id, revenue from Department where month=\\'Sep\\'),\\n    Oct_Revenue as (select id, revenue from Department where month=\\'Oct\\'),\\n    Nov_Revenue as (select id, revenue from Department where month=\\'Nov\\'),\\n    Dec_Revenue as (select id, revenue from Department where month=\\'Dec\\')\\nselect\\n    d.id as id, \\n    m1.revenue as \\'Jan_Revenue\\',\\n    m2.revenue as \\'Feb_Revenue\\',\\n    m3.revenue as \\'Mar_Revenue\\',\\n    m4.revenue as \\'Apr_Revenue\\',\\n    m5.revenue as \\'May_Revenue\\',\\n    m6.revenue as \\'Jun_Revenue\\',\\n    m7.revenue as \\'Jul_Revenue\\',\\n    m8.revenue as \\'Aug_Revenue\\',\\n    m9.revenue as \\'Sep_Revenue\\',\\n    m10.revenue as \\'Oct_Revenue\\',\\n    m11.revenue as \\'Nov_Revenue\\',\\n    m12.revenue as \\'Dec_Revenue\\'\\nfrom Dept_Id d\\n    left join Jan_Revenue m1 using (id)\\n    left join Feb_Revenue m2 using (id)\\n    left join Mar_Revenue m3 using (id)\\n    left join Apr_Revenue m4 using (id)\\n    left join May_Revenue m5 using (id)\\n    left join Jun_Revenue m6 using (id)\\n    left join Jul_Revenue m7 using (id)\\n    left join Aug_Revenue m8 using (id)\\n    left join Sep_Revenue m9 using (id)\\n    left join Oct_Revenue m10 using (id)\\n    left join Nov_Revenue m11 using (id)\\n    left join Dec_Revenue m12 using (id);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1536198,
                "title": "mysql-solution-case-when",
                "content": "```\\nselect id,\\nsum(case when month=\\'Jan\\' then revenue else null end) Jan_revenue,\\nsum(case when month=\\'Feb\\' then revenue else null end) Feb_revenue,\\nsum(case when month=\\'Mar\\' then revenue else null end) Mar_revenue,\\nsum(case when month=\\'Apr\\' then revenue else null end) Apr_revenue,\\nsum(case when month=\\'May\\' then revenue else null end) May_revenue,\\nsum(case when month=\\'Jun\\' then revenue else null end) Jun_revenue,\\nsum(case when month=\\'Jul\\' then revenue else null end) Jul_revenue,\\nsum(case when month=\\'Aug\\' then revenue else null end) Aug_revenue,\\nsum(case when month=\\'Sep\\' then revenue else null end) Sep_revenue,\\nsum(case when month=\\'Oct\\' then revenue else null end) Oct_revenue,\\nsum(case when month=\\'Nov\\' then revenue else null end) Nov_revenue,\\nsum(case when month=\\'Dec\\' then revenue else null end) Dec_revenue\\nfrom department\\ngroup by 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,\\nsum(case when month=\\'Jan\\' then revenue else null end) Jan_revenue,\\nsum(case when month=\\'Feb\\' then revenue else null end) Feb_revenue,\\nsum(case when month=\\'Mar\\' then revenue else null end) Mar_revenue,\\nsum(case when month=\\'Apr\\' then revenue else null end) Apr_revenue,\\nsum(case when month=\\'May\\' then revenue else null end) May_revenue,\\nsum(case when month=\\'Jun\\' then revenue else null end) Jun_revenue,\\nsum(case when month=\\'Jul\\' then revenue else null end) Jul_revenue,\\nsum(case when month=\\'Aug\\' then revenue else null end) Aug_revenue,\\nsum(case when month=\\'Sep\\' then revenue else null end) Sep_revenue,\\nsum(case when month=\\'Oct\\' then revenue else null end) Oct_revenue,\\nsum(case when month=\\'Nov\\' then revenue else null end) Nov_revenue,\\nsum(case when month=\\'Dec\\' then revenue else null end) Dec_revenue\\nfrom department\\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529281,
                "title": "using-multiple-case-statements",
                "content": "`select id,\\n\\nsum(case when month = \\'Jan\\' then revenue else null end) as \\'Jan_Revenue\\',\\n\\nsum(case when month = \\'Feb\\' then revenue else null end) as \\'Feb_Revenue\\',\\n\\nsum(case when month = \\'Mar\\' then revenue else null end) as \\'Mar_Revenue\\',\\n\\nsum(case when month = \\'Apr\\' then revenue else null end) as \\'Apr_Revenue\\',\\n\\nsum(case when month = \\'May\\' then revenue else null end) as \\'May_Revenue\\',\\n\\nsum(case when month = \\'Jun\\' then revenue else null end) as \\'Jun_Revenue\\',\\n\\nsum(case when month = \\'Jul\\' then revenue else null end) as \\'Jul_Revenue\\',\\n\\nsum(case when month = \\'Aug\\' then revenue else null end) as \\'Aug_Revenue\\',\\n\\nsum(case when month = \\'Sep\\' then revenue else null end) as \\'Sep_Revenue\\',\\n\\nsum(case when month = \\'Oct\\' then revenue else null end) as \\'Oct_Revenue\\',\\n\\nsum(case when month = \\'Nov\\' then revenue else null end) as \\'Nov_Revenue\\',\\n\\nsum(case when month = \\'Dec\\' then revenue else null end) as \\'Dec_Revenue\\'\\n\\nfrom Department\\n\\ngroup by id`",
                "solutionTags": [],
                "code": "`select id,\\n\\nsum(case when month = \\'Jan\\' then revenue else null end) as \\'Jan_Revenue\\',\\n\\nsum(case when month = \\'Feb\\' then revenue else null end) as \\'Feb_Revenue\\',\\n\\nsum(case when month = \\'Mar\\' then revenue else null end) as \\'Mar_Revenue\\',\\n\\nsum(case when month = \\'Apr\\' then revenue else null end) as \\'Apr_Revenue\\',\\n\\nsum(case when month = \\'May\\' then revenue else null end) as \\'May_Revenue\\',\\n\\nsum(case when month = \\'Jun\\' then revenue else null end) as \\'Jun_Revenue\\',\\n\\nsum(case when month = \\'Jul\\' then revenue else null end) as \\'Jul_Revenue\\',\\n\\nsum(case when month = \\'Aug\\' then revenue else null end) as \\'Aug_Revenue\\',\\n\\nsum(case when month = \\'Sep\\' then revenue else null end) as \\'Sep_Revenue\\',\\n\\nsum(case when month = \\'Oct\\' then revenue else null end) as \\'Oct_Revenue\\',\\n\\nsum(case when month = \\'Nov\\' then revenue else null end) as \\'Nov_Revenue\\',\\n\\nsum(case when month = \\'Dec\\' then revenue else null end) as \\'Dec_Revenue\\'\\n\\nfrom Department\\n\\ngroup by id`",
                "codeTag": "Unknown"
            },
            {
                "id": 1498191,
                "title": "well-this-is-also-one-of-the-crazy-solutions-d",
                "content": "select distinct(dt.id) as id, \\n(select revenue from Department where month=\"Jan\" and id=dt.id) as Jan_Revenue,\\n(select revenue from Department where month=\"Feb\" and id=dt.id) as Feb_Revenue,\\n(select revenue from Department where month=\"Mar\" and id=dt.id) as Mar_Revenue,\\n(select revenue from Department where month=\"Apr\" and id=dt.id) as Apr_Revenue,\\n(select revenue from Department where month=\"May\" and id=dt.id) as May_Revenue,\\n(select revenue from Department where month=\"Jun\" and id=dt.id) as Jun_Revenue,\\n(select revenue from Department where month=\"Jul\" and id=dt.id) as Jul_Revenue,\\n(select revenue from Department where month=\"Aug\" and id=dt.id) as Aug_Revenue,\\n(select revenue from Department where month=\"Sep\" and id=dt.id) as Sep_Revenue,\\n(select revenue from Department where month=\"Oct\" and id=dt.id) as Oct_Revenue,\\n(select revenue from Department where month=\"Nov\" and id=dt.id) as Nov_Revenue,\\n(select revenue from Department where month=\"Dec\" and id=dt.id) as Dec_Revenue\\nfrom Department as dt;",
                "solutionTags": [],
                "code": "select distinct(dt.id) as id, \\n(select revenue from Department where month=\"Jan\" and id=dt.id) as Jan_Revenue,\\n(select revenue from Department where month=\"Feb\" and id=dt.id) as Feb_Revenue,\\n(select revenue from Department where month=\"Mar\" and id=dt.id) as Mar_Revenue,\\n(select revenue from Department where month=\"Apr\" and id=dt.id) as Apr_Revenue,\\n(select revenue from Department where month=\"May\" and id=dt.id) as May_Revenue,\\n(select revenue from Department where month=\"Jun\" and id=dt.id) as Jun_Revenue,\\n(select revenue from Department where month=\"Jul\" and id=dt.id) as Jul_Revenue,\\n(select revenue from Department where month=\"Aug\" and id=dt.id) as Aug_Revenue,\\n(select revenue from Department where month=\"Sep\" and id=dt.id) as Sep_Revenue,\\n(select revenue from Department where month=\"Oct\" and id=dt.id) as Oct_Revenue,\\n(select revenue from Department where month=\"Nov\" and id=dt.id) as Nov_Revenue,\\n(select revenue from Department where month=\"Dec\" and id=dt.id) as Dec_Revenue\\nfrom Department as dt;",
                "codeTag": "Unknown"
            },
            {
                "id": 1441878,
                "title": "simple-mysql-group-by",
                "content": "```\\nSelect id,\\nSUM(IF(month=\"Jan\",revenue,NULL)) as \\'Jan_Revenue\\', \\nSUM(IF(month=\"Feb\",revenue,NULL)) as \\'Feb_Revenue\\', \\nSUM(IF(month=\"Mar\",revenue,NULL)) as \\'Mar_Revenue\\',\\nSUM(IF(month=\"Apr\",revenue,NULL)) as \\'Apr_Revenue\\', \\nSUM(IF(month=\"May\",revenue,NULL)) as \\'May_Revenue\\', \\nSUM(IF(month=\"Jun\",revenue,NULL)) as \\'Jun_Revenue\\',\\nSUM(IF(month=\"Jul\",revenue,NULL)) as \\'Jul_Revenue\\', \\nSUM(IF(month=\"Aug\",revenue,NULL)) as \\'Aug_Revenue\\', \\nSUM(IF(month=\"Sep\",revenue,NULL)) as \\'Sep_Revenue\\',\\nSUM(IF(month=\"Oct\",revenue,NULL)) as\\' Oct_Revenue\\', \\nSUM(IF(month=\"Nov\",revenue,NULL)) as \\'Nov_Revenue\\',\\nSUM(IF(month=\"Dec\",revenue,NULL)) as \\'Dec_Revenue\\'\\nfrom Department\\ngroup by id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect id,\\nSUM(IF(month=\"Jan\",revenue,NULL)) as \\'Jan_Revenue\\', \\nSUM(IF(month=\"Feb\",revenue,NULL)) as \\'Feb_Revenue\\', \\nSUM(IF(month=\"Mar\",revenue,NULL)) as \\'Mar_Revenue\\',\\nSUM(IF(month=\"Apr\",revenue,NULL)) as \\'Apr_Revenue\\', \\nSUM(IF(month=\"May\",revenue,NULL)) as \\'May_Revenue\\', \\nSUM(IF(month=\"Jun\",revenue,NULL)) as \\'Jun_Revenue\\',\\nSUM(IF(month=\"Jul\",revenue,NULL)) as \\'Jul_Revenue\\', \\nSUM(IF(month=\"Aug\",revenue,NULL)) as \\'Aug_Revenue\\', \\nSUM(IF(month=\"Sep\",revenue,NULL)) as \\'Sep_Revenue\\',\\nSUM(IF(month=\"Oct\",revenue,NULL)) as\\' Oct_Revenue\\', \\nSUM(IF(month=\"Nov\",revenue,NULL)) as \\'Nov_Revenue\\',\\nSUM(IF(month=\"Dec\",revenue,NULL)) as \\'Dec_Revenue\\'\\nfrom Department\\ngroup by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1399025,
                "title": "mysql",
                "content": "\\n\\n\\tSELECT id,\\n\\n\\t\\tMAX(IF(month=\"Jan\",revenue,NULL)) AS Jan_Revenue,\\n        MAX(IF(month=\"Feb\",revenue,NULL)) AS Feb_Revenue,\\n        MAX(IF(month=\"Mar\",revenue,NULL)) AS Mar_Revenue,\\n        MAX(IF(month=\"Apr\",revenue,NULL)) AS Apr_Revenue,\\n        MAX(IF(month=\"May\",revenue,NULL)) AS May_Revenue,\\n        MAX(IF(month=\"Jun\",revenue,NULL)) AS Jun_Revenue,\\n        MAX(IF(month=\"Jul\",revenue,NULL)) AS Jul_Revenue,\\n        MAX(IF(month=\"Aug\",revenue,NULL)) AS Aug_Revenue,\\n        MAX(IF(month=\"Sep\",revenue,NULL)) AS Sep_Revenue,\\n        MAX(IF(month=\"Oct\",revenue,NULL)) AS Oct_Revenue,\\n        MAX(IF(month=\"Nov\",revenue,NULL)) AS Nov_Revenue,\\n        MAX(IF(month=\"Dec\",revenue,NULL)) AS Dec_Revenue\\n    FROM Department\\n    group by id;",
                "solutionTags": [],
                "code": "\\n\\n\\tSELECT id,\\n\\n\\t\\tMAX(IF(month=\"Jan\",revenue,NULL)) AS Jan_Revenue,\\n        MAX(IF(month=\"Feb\",revenue,NULL)) AS Feb_Revenue,\\n        MAX(IF(month=\"Mar\",revenue,NULL)) AS Mar_Revenue,\\n        MAX(IF(month=\"Apr\",revenue,NULL)) AS Apr_Revenue,\\n        MAX(IF(month=\"May\",revenue,NULL)) AS May_Revenue,\\n        MAX(IF(month=\"Jun\",revenue,NULL)) AS Jun_Revenue,\\n        MAX(IF(month=\"Jul\",revenue,NULL)) AS Jul_Revenue,\\n        MAX(IF(month=\"Aug\",revenue,NULL)) AS Aug_Revenue,\\n        MAX(IF(month=\"Sep\",revenue,NULL)) AS Sep_Revenue,\\n        MAX(IF(month=\"Oct\",revenue,NULL)) AS Oct_Revenue,\\n        MAX(IF(month=\"Nov\",revenue,NULL)) AS Nov_Revenue,\\n        MAX(IF(month=\"Dec\",revenue,NULL)) AS Dec_Revenue\\n    FROM Department\\n    group by id;",
                "codeTag": "Unknown"
            },
            {
                "id": 1355930,
                "title": "sql-server-pivot-table",
                "content": "select \\nid,\\nJan as \\'Jan_Revenue\\',\\nFeb as \\'feb_revenue\\',\\nMar as \\'Mar_revenue\\',\\napr as \\'apr_revenue\\',\\nmay as \\'may_revenue\\',\\njun as \\'jun_revenue\\',\\njul as \\'jul_revenue\\',\\naug as \\'aug_revenue\\',\\nsep as \\'sep_revenue\\',\\noct as \\'oct_revenue\\',\\nnov as \\'nov_revenue\\',\\ndec as \\'dec_revenue\\'\\nfrom\\ndepartment\\npivot(\\n      sum(revenue)\\n   for month in (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec))\\n     as pivot_table\\n    \\n    \\n    \\n\\n",
                "solutionTags": [],
                "code": "select \\nid,\\nJan as \\'Jan_Revenue\\',\\nFeb as \\'feb_revenue\\',\\nMar as \\'Mar_revenue\\',\\napr as \\'apr_revenue\\',\\nmay as \\'may_revenue\\',\\njun as \\'jun_revenue\\',\\njul as \\'jul_revenue\\',\\naug as \\'aug_revenue\\',\\nsep as \\'sep_revenue\\',\\noct as \\'oct_revenue\\',\\nnov as \\'nov_revenue\\',\\ndec as \\'dec_revenue\\'\\nfrom\\ndepartment\\npivot(\\n      sum(revenue)\\n   for month in (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec))\\n     as pivot_table\\n    \\n    \\n    \\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1289295,
                "title": "dynamic-pivot-in-mysql-using-group-concat-why-does-it-not-work",
                "content": "I was basically trying to iterate the Jan to Dec columns using Group Concat function.\\nBut it gets error at the first SELECT statement. \\nIs it the case wehre LeetCode server does not allow more than 1 complete code ? (only one \";\" allowed?)\\n\\n```\\nSET @sql = NULL;\\n\\nSELECT \\n    GROUP_CONCAT\\n      (DISTINCT\\n        CONCAT(\\'SUM(IF(MONTH =\\'\\'\\',\\n                 month,\\n                  \\'\\'\\', REVENUE,NULL)) AS \\',\\n                 month,\\n                  \\'_Revenue\\')\\n      ) INTO @sql\\nFROM Department;\\n  \\nSET @sql = CONCAT(\\'SELECT id, \\', \\n                  @sql, \\' \\n                  FROM Department\\n                  GROUP BY id\\n                  ORDER BY id\\');\\n\\nPREPARE stmt FROM @sql;\\nEXECUTE stmt;\\nDEALLOCATE PREPARE stmt;\\n\\n```\\n\\nThe above code is basically translating this manual line creation in below accepted answer\\n```\\nSELECT id,\\n    sum(IF(MONTH = \"Jan\",REVENUE,NULL)) AS Jan_Revenue,\\n    sum(IF(MONTH = \"Feb\",REVENUE,NULL)) AS Feb_Revenue,\\n    sum(IF(MONTH = \"Mar\",REVENUE,NULL)) AS Mar_Revenue,\\n    sum(IF(MONTH = \"Apr\",REVENUE,NULL)) AS Apr_Revenue,\\n    sum(IF(MONTH = \"May\",REVENUE,NULL)) AS May_Revenue,\\n    sum(IF(MONTH = \"Jun\",REVENUE,NULL)) AS Jun_Revenue,\\n    sum(IF(MONTH = \"Jul\",REVENUE,NULL)) AS Jul_Revenue,\\n    sum(IF(MONTH = \"Aug\",REVENUE,NULL)) AS Aug_Revenue,\\n    sum(IF(MONTH = \"Sep\",REVENUE,NULL)) AS Sep_Revenue,\\n    sum(IF(MONTH = \"Oct\",REVENUE,NULL)) AS Oct_Revenue,\\n    sum(IF(MONTH = \"Nov\",REVENUE,NULL)) AS Nov_Revenue,\\n    sum(IF(MONTH = \"Dec\",REVENUE,NULL)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\nORDER BY id\\n```",
                "solutionTags": [],
                "code": "```\\nSET @sql = NULL;\\n\\nSELECT \\n    GROUP_CONCAT\\n      (DISTINCT\\n        CONCAT(\\'SUM(IF(MONTH =\\'\\'\\',\\n                 month,\\n                  \\'\\'\\', REVENUE,NULL)) AS \\',\\n                 month,\\n                  \\'_Revenue\\')\\n      ) INTO @sql\\nFROM Department;\\n  \\nSET @sql = CONCAT(\\'SELECT id, \\', \\n                  @sql, \\' \\n                  FROM Department\\n                  GROUP BY id\\n                  ORDER BY id\\');\\n\\nPREPARE stmt FROM @sql;\\nEXECUTE stmt;\\nDEALLOCATE PREPARE stmt;\\n\\n```\n```\\nSELECT id,\\n    sum(IF(MONTH = \"Jan\",REVENUE,NULL)) AS Jan_Revenue,\\n    sum(IF(MONTH = \"Feb\",REVENUE,NULL)) AS Feb_Revenue,\\n    sum(IF(MONTH = \"Mar\",REVENUE,NULL)) AS Mar_Revenue,\\n    sum(IF(MONTH = \"Apr\",REVENUE,NULL)) AS Apr_Revenue,\\n    sum(IF(MONTH = \"May\",REVENUE,NULL)) AS May_Revenue,\\n    sum(IF(MONTH = \"Jun\",REVENUE,NULL)) AS Jun_Revenue,\\n    sum(IF(MONTH = \"Jul\",REVENUE,NULL)) AS Jul_Revenue,\\n    sum(IF(MONTH = \"Aug\",REVENUE,NULL)) AS Aug_Revenue,\\n    sum(IF(MONTH = \"Sep\",REVENUE,NULL)) AS Sep_Revenue,\\n    sum(IF(MONTH = \"Oct\",REVENUE,NULL)) AS Oct_Revenue,\\n    sum(IF(MONTH = \"Nov\",REVENUE,NULL)) AS Nov_Revenue,\\n    sum(IF(MONTH = \"Dec\",REVENUE,NULL)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\nORDER BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218528,
                "title": "mysql-tried-to-come-up-with-something-interesting-but-didn-t",
                "content": "```\\nselect id,\\nsum(if(month = \"Jan\", revenue, null)) as  \"Jan_Revenue\", \\nsum(if(month = \"Feb\", revenue, null)) as  \"Feb_Revenue\", \\nsum(if(month = \"Mar\", revenue, null)) as  \"Mar_Revenue\", \\nsum(if(month = \"Apr\", revenue, null)) as  \"Apr_Revenue\", \\nsum(if(month = \"May\", revenue, null)) as  \"May_Revenue\", \\nsum(if(month = \"Jun\", revenue, null)) as  \"Jun_Revenue\", \\nsum(if(month = \"Jul\", revenue, null)) as  \"Jul_Revenue\", \\nsum(if(month = \"Aug\", revenue, null)) as  \"Aug_Revenue\", \\nsum(if(month = \"Sep\", revenue, null)) as  \"Sep_Revenue\", \\nsum(if(month = \"Oct\", revenue, null)) as  \"Oct_Revenue\", \\nsum(if(month = \"Nov\", revenue, null)) as  \"Nov_Revenue\", \\nsum(if(month = \"Dec\", revenue, null)) as  \"Dec_Revenue\"\\nfrom Department\\ngroup by id;\\n```",
                "solutionTags": [],
                "code": "```\\nselect id,\\nsum(if(month = \"Jan\", revenue, null)) as  \"Jan_Revenue\", \\nsum(if(month = \"Feb\", revenue, null)) as  \"Feb_Revenue\", \\nsum(if(month = \"Mar\", revenue, null)) as  \"Mar_Revenue\", \\nsum(if(month = \"Apr\", revenue, null)) as  \"Apr_Revenue\", \\nsum(if(month = \"May\", revenue, null)) as  \"May_Revenue\", \\nsum(if(month = \"Jun\", revenue, null)) as  \"Jun_Revenue\", \\nsum(if(month = \"Jul\", revenue, null)) as  \"Jul_Revenue\", \\nsum(if(month = \"Aug\", revenue, null)) as  \"Aug_Revenue\", \\nsum(if(month = \"Sep\", revenue, null)) as  \"Sep_Revenue\", \\nsum(if(month = \"Oct\", revenue, null)) as  \"Oct_Revenue\", \\nsum(if(month = \"Nov\", revenue, null)) as  \"Nov_Revenue\", \\nsum(if(month = \"Dec\", revenue, null)) as  \"Dec_Revenue\"\\nfrom Department\\ngroup by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203452,
                "title": "left-outer-join-solution",
                "content": "# Write your MySQL query statement below\\nselect d0.id as id,\\n       d1.Revenue as Jan_Revenue,\\n       d2.Revenue as Feb_Revenue,\\n       d3.Revenue as Mar_Revenue,\\n       d4.Revenue as Apr_Revenue,\\n       d5.Revenue as May_Revenue,\\n       d6.Revenue as Jun_Revenue,\\n       d7.Revenue as Jul_Revenue,\\n       d8.Revenue as Aug_Revenue,\\n       d9.Revenue as Sep_Revenue,\\n       d10.Revenue as Oct_Revenue,\\n       d11.Revenue as Nov_Revenue,\\n       d12.Revenue as Dec_Revenue\\nfrom (select distinct id from Department) as d0\\n                      left join Department as d1 on d1.id = d0.id and d1.month = \\'Jan\\'\\n                      left join Department as d2 on d2.id = d0.id and d2.month = \\'Feb\\'\\n                      left join Department as d3 on d3.id = d0.id and d3.month = \\'Mar\\'\\n                      left join Department as d4 on d4.id = d0.id and d4.month = \\'Apr\\'\\n                      left join Department as d5 on d5.id = d0.id and d5.month = \\'May\\'\\n                      left join Department as d6 on d6.id = d0.id and d6.month = \\'Jun\\'\\n                      left join Department as d7 on d7.id = d0.id and d7.month = \\'Jul\\'\\n                      left join Department as d8 on d8.id = d0.id and d8.month = \\'Aug\\'\\n                      left join Department as d9 on d9.id = d0.id and d9.month = \\'Sep\\'\\n                      left join Department as d10 on d10.id = d0.id and d10.month = \\'Oct\\'\\n                      left join Department as d11 on d11.id = d0.id and d11.month = \\'Nov\\'\\n                      left join Department as d12 on d12.id = d0.id and d12.month = \\'Dec\\'\\n",
                "solutionTags": [],
                "code": "# Write your MySQL query statement below\\nselect d0.id as id,\\n       d1.Revenue as Jan_Revenue,\\n       d2.Revenue as Feb_Revenue,\\n       d3.Revenue as Mar_Revenue,\\n       d4.Revenue as Apr_Revenue,\\n       d5.Revenue as May_Revenue,\\n       d6.Revenue as Jun_Revenue,\\n       d7.Revenue as Jul_Revenue,\\n       d8.Revenue as Aug_Revenue,\\n       d9.Revenue as Sep_Revenue,\\n       d10.Revenue as Oct_Revenue,\\n       d11.Revenue as Nov_Revenue,\\n       d12.Revenue as Dec_Revenue\\nfrom (select distinct id from Department) as d0\\n                      left join Department as d1 on d1.id = d0.id and d1.month = \\'Jan\\'\\n                      left join Department as d2 on d2.id = d0.id and d2.month = \\'Feb\\'\\n                      left join Department as d3 on d3.id = d0.id and d3.month = \\'Mar\\'\\n                      left join Department as d4 on d4.id = d0.id and d4.month = \\'Apr\\'\\n                      left join Department as d5 on d5.id = d0.id and d5.month = \\'May\\'\\n                      left join Department as d6 on d6.id = d0.id and d6.month = \\'Jun\\'\\n                      left join Department as d7 on d7.id = d0.id and d7.month = \\'Jul\\'\\n                      left join Department as d8 on d8.id = d0.id and d8.month = \\'Aug\\'\\n                      left join Department as d9 on d9.id = d0.id and d9.month = \\'Sep\\'\\n                      left join Department as d10 on d10.id = d0.id and d10.month = \\'Oct\\'\\n                      left join Department as d11 on d11.id = d0.id and d11.month = \\'Nov\\'\\n                      left join Department as d12 on d12.id = d0.id and d12.month = \\'Dec\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1167232,
                "title": "oracle-pivot-solution",
                "content": "select * from (\\n select id, revenue, month from department\\n)\\npivot ( \\n sum(revenue) for month in\\n    (\\'Jan\\' Jan_Revenue,\\'Feb\\' Feb_Revenue,\\n     \\'Mar\\' Mar_Revenue,\\'Apr\\' Apr_Revenue,\\n     \\'May\\' May_Revenue,\\'Jun\\' Jun_Revenue,\\n     \\'Jul\\' Jul_Revenue,\\'Aug\\' Aug_Revenue,\\n     \\'Sep\\' Sep_Revenue,\\'Oct\\' Oct_Revenue,\\n     \\'Nov\\' Nov_Revenue,\\'Dec\\' Dec_Revenue)\\n)",
                "solutionTags": [],
                "code": "select * from (\\n select id, revenue, month from department\\n)\\npivot ( \\n sum(revenue) for month in\\n    (\\'Jan\\' Jan_Revenue,\\'Feb\\' Feb_Revenue,\\n     \\'Mar\\' Mar_Revenue,\\'Apr\\' Apr_Revenue,\\n     \\'May\\' May_Revenue,\\'Jun\\' Jun_Revenue,\\n     \\'Jul\\' Jul_Revenue,\\'Aug\\' Aug_Revenue,\\n     \\'Sep\\' Sep_Revenue,\\'Oct\\' Oct_Revenue,\\n     \\'Nov\\' Nov_Revenue,\\'Dec\\' Dec_Revenue)\\n)",
                "codeTag": "Unknown"
            },
            {
                "id": 1117570,
                "title": "use-if",
                "content": "select id, \\n    sum(if(month = \\'Jan\\', revenue, null)) as Jan_Revenue,\\n    sum(if(month = \\'Feb\\', revenue, null)) as Feb_Revenue,\\n    sum(if(month = \\'Mar\\', revenue, null)) as Mar_Revenue,\\n    sum(if(month = \\'Apr\\', revenue, null)) as Apr_Revenue,\\n    sum(if(month = \\'May\\', revenue, null)) as May_Revenue,\\n    sum(if(month = \\'Jun\\', revenue, null)) as Jun_Revenue,\\n    sum(if(month = \\'Jul\\', revenue, null)) as Jul_Revenue,\\n    sum(if(month = \\'Aug\\', revenue, null)) as Aug_Revenue,\\n    sum(if(month = \\'Sep\\', revenue, null)) as Sep_Revenue,\\n    sum(if(month = \\'Oct\\', revenue, null)) as Oct_Revenue,\\n    sum(if(month = \\'Nov\\', revenue, null)) as Nov_Revenue,\\n    sum(if(month = \\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom Department\\ngroup by id",
                "solutionTags": [],
                "code": "select id, \\n    sum(if(month = \\'Jan\\', revenue, null)) as Jan_Revenue,\\n    sum(if(month = \\'Feb\\', revenue, null)) as Feb_Revenue,\\n    sum(if(month = \\'Mar\\', revenue, null)) as Mar_Revenue,\\n    sum(if(month = \\'Apr\\', revenue, null)) as Apr_Revenue,\\n    sum(if(month = \\'May\\', revenue, null)) as May_Revenue,\\n    sum(if(month = \\'Jun\\', revenue, null)) as Jun_Revenue,\\n    sum(if(month = \\'Jul\\', revenue, null)) as Jul_Revenue,\\n    sum(if(month = \\'Aug\\', revenue, null)) as Aug_Revenue,\\n    sum(if(month = \\'Sep\\', revenue, null)) as Sep_Revenue,\\n    sum(if(month = \\'Oct\\', revenue, null)) as Oct_Revenue,\\n    sum(if(month = \\'Nov\\', revenue, null)) as Nov_Revenue,\\n    sum(if(month = \\'Dec\\', revenue, null)) as Dec_Revenue\\nfrom Department\\ngroup by id",
                "codeTag": "Unknown"
            },
            {
                "id": 1086035,
                "title": "solution-for-mysql",
                "content": "```\\nselect \\n\\tid,\\n\\tsum(Jan_Revenue) as Jan_Revenue,\\n\\tsum(Feb_Revenue) as Feb_Revenue,\\n\\tsum(Mar_Revenue) as Mar_Revenue,\\n\\tsum(Apr_Revenue) as Apr_Revenue,\\n\\tsum(May_Revenue) as May_Revenue,\\n\\tsum(Jun_Revenue) as Jun_Revenue,\\n\\tsum(Jul_Revenue) as Jul_Revenue,\\n\\tsum(Aug_Revenue) as Aug_Revenue,\\n\\tsum(Sep_Revenue) as Sep_Revenue,\\n\\tsum(Oct_Revenue) as Oct_Revenue,\\n\\tsum(Nov_Revenue) as Nov_Revenue,\\n\\tsum(Dec_Revenue) as Dec_Revenue\\nfrom (\\n    select\\n        department.*,\\n        case when month = \\'Jan\\' then revenue end as \\'Jan_Revenue\\',\\n        case when month = \\'Feb\\' then revenue end as \\'Feb_Revenue\\',\\n        case when month = \\'Mar\\' then revenue end as \\'Mar_Revenue\\',\\n        case when month = \\'Apr\\' then revenue end as \\'Apr_Revenue\\',\\n        case when month = \\'May\\' then revenue end as \\'May_Revenue\\',\\n        case when month = \\'Jun\\' then revenue end as \\'Jun_Revenue\\',\\n        case when month = \\'Jul\\' then revenue end as \\'Jul_Revenue\\',\\n        case when month = \\'Aug\\' then revenue end as \\'Aug_Revenue\\',\\n        case when month = \\'Sep\\' then revenue end as \\'Sep_Revenue\\',\\n        case when month = \\'Oct\\' then revenue end as \\'Oct_Revenue\\',\\n        case when month = \\'Nov\\' then revenue end as \\'Nov_Revenue\\',\\n        case when month = \\'Dec\\' then revenue end as \\'Dec_Revenue\\'\\n    from department\\n) tbl\\ngroup by id;\\n```",
                "solutionTags": [],
                "code": "```\\nselect \\n\\tid,\\n\\tsum(Jan_Revenue) as Jan_Revenue,\\n\\tsum(Feb_Revenue) as Feb_Revenue,\\n\\tsum(Mar_Revenue) as Mar_Revenue,\\n\\tsum(Apr_Revenue) as Apr_Revenue,\\n\\tsum(May_Revenue) as May_Revenue,\\n\\tsum(Jun_Revenue) as Jun_Revenue,\\n\\tsum(Jul_Revenue) as Jul_Revenue,\\n\\tsum(Aug_Revenue) as Aug_Revenue,\\n\\tsum(Sep_Revenue) as Sep_Revenue,\\n\\tsum(Oct_Revenue) as Oct_Revenue,\\n\\tsum(Nov_Revenue) as Nov_Revenue,\\n\\tsum(Dec_Revenue) as Dec_Revenue\\nfrom (\\n    select\\n        department.*,\\n        case when month = \\'Jan\\' then revenue end as \\'Jan_Revenue\\',\\n        case when month = \\'Feb\\' then revenue end as \\'Feb_Revenue\\',\\n        case when month = \\'Mar\\' then revenue end as \\'Mar_Revenue\\',\\n        case when month = \\'Apr\\' then revenue end as \\'Apr_Revenue\\',\\n        case when month = \\'May\\' then revenue end as \\'May_Revenue\\',\\n        case when month = \\'Jun\\' then revenue end as \\'Jun_Revenue\\',\\n        case when month = \\'Jul\\' then revenue end as \\'Jul_Revenue\\',\\n        case when month = \\'Aug\\' then revenue end as \\'Aug_Revenue\\',\\n        case when month = \\'Sep\\' then revenue end as \\'Sep_Revenue\\',\\n        case when month = \\'Oct\\' then revenue end as \\'Oct_Revenue\\',\\n        case when month = \\'Nov\\' then revenue end as \\'Nov_Revenue\\',\\n        case when month = \\'Dec\\' then revenue end as \\'Dec_Revenue\\'\\n    from department\\n) tbl\\ngroup by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1034871,
                "title": "easy-solution",
                "content": "```\\nSelect id\\n      ,sum(Case when month = \\'Jan\\' then revenue else null end) as Jan_Revenue\\n      ,sum(Case when month = \\'Feb\\' then revenue else null end) as Feb_Revenue\\n      ,sum(Case when month = \\'Mar\\' then revenue else null end) as Mar_Revenue\\n      ,sum(Case when month = \\'Apr\\' then revenue else null end) as Apr_Revenue\\n      ,sum(Case when month = \\'May\\' then revenue else null end) as May_Revenue\\n      ,sum(Case when month = \\'Jun\\' then revenue else null end) as Jun_Revenue\\n      ,sum(Case when month = \\'Jul\\' then revenue else null end) as Jul_Revenue\\n      ,sum(Case when month = \\'Aug\\' then revenue else null end) as Aug_Revenue\\n      ,sum(Case when month = \\'Sep\\' then revenue else null end) as Sep_Revenue\\n      ,sum(Case when month = \\'Oct\\' then revenue else null end) as Oct_Revenue\\n      ,sum(Case when month = \\'Nov\\' then revenue else null end) as Nov_Revenue\\n      ,sum(Case when month = \\'Dec\\' then revenue else null end) as Dec_Revenue\\n      from Department\\n      group by id\\n      order by id\\n\\t  ```",
                "solutionTags": [],
                "code": "```\\nSelect id\\n      ,sum(Case when month = \\'Jan\\' then revenue else null end) as Jan_Revenue\\n      ,sum(Case when month = \\'Feb\\' then revenue else null end) as Feb_Revenue\\n      ,sum(Case when month = \\'Mar\\' then revenue else null end) as Mar_Revenue\\n      ,sum(Case when month = \\'Apr\\' then revenue else null end) as Apr_Revenue\\n      ,sum(Case when month = \\'May\\' then revenue else null end) as May_Revenue\\n      ,sum(Case when month = \\'Jun\\' then revenue else null end) as Jun_Revenue\\n      ,sum(Case when month = \\'Jul\\' then revenue else null end) as Jul_Revenue\\n      ,sum(Case when month = \\'Aug\\' then revenue else null end) as Aug_Revenue\\n      ,sum(Case when month = \\'Sep\\' then revenue else null end) as Sep_Revenue\\n      ,sum(Case when month = \\'Oct\\' then revenue else null end) as Oct_Revenue\\n      ,sum(Case when month = \\'Nov\\' then revenue else null end) as Nov_Revenue\\n      ,sum(Case when month = \\'Dec\\' then revenue else null end) as Dec_Revenue\\n      from Department\\n      group by id\\n      order by id\\n\\t  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022254,
                "title": "mysql",
                "content": "```\\nWITH CTE AS (\\nselect  id,revenue,\\n        concat(month,\\'_Revenue\\') AS month\\nFROM department \\n)\\n\\nselect id,\\n        SUM(IF(month = \\'Jan_Revenue\\',revenue,NULL)) as \\'Jan_Revenue\\',\\n        SUM(IF(month = \\'Feb_Revenue\\',revenue,NULL)) as \\'Feb_Revenue\\',\\n        SUM(IF(month = \\'Mar_Revenue\\',revenue,NULL)) as \\'Mar_Revenue\\',\\n        SUM(IF(month = \\'Apr_Revenue\\',revenue,NULL)) as \\'Apr_Revenue\\',\\n        SUM(IF(month = \\'May_Revenue\\',revenue,NULL)) as \\'May_Revenue\\',\\n        SUM(IF(month = \\'Jun_Revenue\\',revenue,NULL)) as \\'Jun_Revenue\\',\\n        SUM(IF(month = \\'Jul_Revenue\\',revenue,NULL)) as \\'Jul_Revenue\\',\\n        SUM(IF(month = \\'Aug_Revenue\\',revenue,NULL)) as \\'Aug_Revenue\\',\\n        SUM(IF(month = \\'Sep_Revenue\\',revenue,NULL)) as \\'Sep_Revenue\\',\\n        SUM(IF(month = \\'Oct_Revenue\\',revenue,NULL)) as \\'Oct_Revenue\\',\\n        SUM(IF(month = \\'Nov_Revenue\\',revenue,NULL)) as \\'Nov_Revenue\\',\\n        SUM(IF(month = \\'Dec_Revenue\\',revenue,NULL)) as \\'Dec_Revenue\\'\\nfrom cte\\ngroup by id;\\n```",
                "solutionTags": [],
                "code": "```\\nWITH CTE AS (\\nselect  id,revenue,\\n        concat(month,\\'_Revenue\\') AS month\\nFROM department \\n)\\n\\nselect id,\\n        SUM(IF(month = \\'Jan_Revenue\\',revenue,NULL)) as \\'Jan_Revenue\\',\\n        SUM(IF(month = \\'Feb_Revenue\\',revenue,NULL)) as \\'Feb_Revenue\\',\\n        SUM(IF(month = \\'Mar_Revenue\\',revenue,NULL)) as \\'Mar_Revenue\\',\\n        SUM(IF(month = \\'Apr_Revenue\\',revenue,NULL)) as \\'Apr_Revenue\\',\\n        SUM(IF(month = \\'May_Revenue\\',revenue,NULL)) as \\'May_Revenue\\',\\n        SUM(IF(month = \\'Jun_Revenue\\',revenue,NULL)) as \\'Jun_Revenue\\',\\n        SUM(IF(month = \\'Jul_Revenue\\',revenue,NULL)) as \\'Jul_Revenue\\',\\n        SUM(IF(month = \\'Aug_Revenue\\',revenue,NULL)) as \\'Aug_Revenue\\',\\n        SUM(IF(month = \\'Sep_Revenue\\',revenue,NULL)) as \\'Sep_Revenue\\',\\n        SUM(IF(month = \\'Oct_Revenue\\',revenue,NULL)) as \\'Oct_Revenue\\',\\n        SUM(IF(month = \\'Nov_Revenue\\',revenue,NULL)) as \\'Nov_Revenue\\',\\n        SUM(IF(month = \\'Dec_Revenue\\',revenue,NULL)) as \\'Dec_Revenue\\'\\nfrom cte\\ngroup by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1010981,
                "title": "ms-sql-server-pivot-solution",
                "content": "```\\n/* Write your T-SQL query statement below */\\nselect\\tid, Jan as Jan_Revenue, Feb as Feb_Revenue, Mar as Mar_Revenue, Apr as Apr_Revenue, May as May_Revenue,\\n\\t\\tJun as Jun_Revenue, Jul as Jul_Revenue, Aug as Aug_Revenue, Sep as Sep_Revenue, Oct as Oct_Revenue, \\n\\t\\tNov as Nov_Revenue, Dec as Dec_Revenue\\nfrom Department  \\npivot (sum(revenue) for [month] \\nin (\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \\n\\t\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \\n\\t\"Dec\"  ) ) \\nas pivottable\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect\\tid, Jan as Jan_Revenue, Feb as Feb_Revenue, Mar as Mar_Revenue, Apr as Apr_Revenue, May as May_Revenue,\\n\\t\\tJun as Jun_Revenue, Jul as Jul_Revenue, Aug as Aug_Revenue, Sep as Sep_Revenue, Oct as Oct_Revenue, \\n\\t\\tNov as Nov_Revenue, Dec as Dec_Revenue\\nfrom Department  \\npivot (sum(revenue) for [month] \\nin (\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \\n\\t\"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \\n\\t\"Dec\"  ) ) \\nas pivottable\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 987154,
                "title": "ms-sqlserver-simplest-and-best-solution",
                "content": "SELECT id,\\nsum(iif(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(iif(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(iif(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(iif(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(iif(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(iif(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(iif(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(iif(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(iif(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(iif(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(iif(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(iif(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nFROM Department\\nGROUP BY id",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT id,\\nsum(iif(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(iif(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(iif(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(iif(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(iif(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(iif(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(iif(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(iif(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(iif(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(iif(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(iif(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(iif(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nFROM Department\\nGROUP BY id",
                "codeTag": "Unknown"
            },
            {
                "id": 965874,
                "title": "oracle-decode",
                "content": "It\\'s possible to use *DECODE* instead of *CASE*:\\n```\\nselect\\nid, \\nMAX(decode(month,\\'Jan\\',revenue)) Jan_Revenue,\\nMAX(decode(month,\\'Feb\\',revenue)) Feb_Revenue,\\nMAX(decode(month,\\'Mar\\',revenue)) Mar_Revenue,\\nMAX(decode(month,\\'Apr\\',revenue)) Apr_Revenue,\\nMAX(decode(month,\\'May\\',revenue)) May_Revenue,\\nMAX(decode(month,\\'Jun\\',revenue)) Jun_Revenue,\\nMAX(decode(month,\\'Jul\\',revenue)) Jul_Revenue,\\nMAX(decode(month,\\'Aug\\',revenue)) Aug_Revenue,\\nMAX(decode(month,\\'Sep\\',revenue)) Sep_Revenue,\\nMAX(decode(month,\\'Oct\\',revenue)) Oct_Revenue,\\nMAX(decode(month,\\'Nov\\',revenue)) Nov_Revenue,\\nMAX(decode(month,\\'Dec\\',revenue)) Dec_Revenue\\nfrom Department\\ngroup by id\\n```\\n*MAX* is used because there are no pairs with the same id and month (PK = id, month)",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nselect\\nid, \\nMAX(decode(month,\\'Jan\\',revenue)) Jan_Revenue,\\nMAX(decode(month,\\'Feb\\',revenue)) Feb_Revenue,\\nMAX(decode(month,\\'Mar\\',revenue)) Mar_Revenue,\\nMAX(decode(month,\\'Apr\\',revenue)) Apr_Revenue,\\nMAX(decode(month,\\'May\\',revenue)) May_Revenue,\\nMAX(decode(month,\\'Jun\\',revenue)) Jun_Revenue,\\nMAX(decode(month,\\'Jul\\',revenue)) Jul_Revenue,\\nMAX(decode(month,\\'Aug\\',revenue)) Aug_Revenue,\\nMAX(decode(month,\\'Sep\\',revenue)) Sep_Revenue,\\nMAX(decode(month,\\'Oct\\',revenue)) Oct_Revenue,\\nMAX(decode(month,\\'Nov\\',revenue)) Nov_Revenue,\\nMAX(decode(month,\\'Dec\\',revenue)) Dec_Revenue\\nfrom Department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934878,
                "title": "simple-mysql-sum-if-solution",
                "content": "select id\\n, sum(if(`month`=\\'Jan\\', revenue, NULL)) as Jan_revenue\\n, sum(if(`month`=\\'Feb\\', revenue, NULL)) as Feb_revenue\\n, sum(if(`month`=\\'Mar\\', revenue, NULL)) as Mar_revenue\\n, sum(if(`month`=\\'Apr\\', revenue, NULL)) as Apr_revenue\\n, sum(if(`month`=\\'May\\', revenue, NULL)) as May_revenue\\n, sum(if(`month`=\\'Jun\\', revenue, NULL)) as Jun_revenue\\n, sum(if(`month`=\\'Jul\\', revenue, NULL)) as Jul_revenue\\n, sum(if(`month`=\\'Aug\\', revenue, NULL)) as Aug_revenue\\n, sum(if(`month`=\\'Sep\\', revenue, NULL)) as Sep_revenue\\n, sum(if(`month`=\\'Oct\\', revenue, NULL)) as Oct_revenue\\n, sum(if(`month`=\\'Nov\\', revenue, NULL)) as Nov_revenue\\n, sum(if(`month`=\\'Dec\\', revenue, NULL)) as Dec_revenue\\nfrom department\\ngroup by id;",
                "solutionTags": [],
                "code": "select id\\n, sum(if(`month`=\\'Jan\\', revenue, NULL)) as Jan_revenue\\n, sum(if(`month`=\\'Feb\\', revenue, NULL)) as Feb_revenue\\n, sum(if(`month`=\\'Mar\\', revenue, NULL)) as Mar_revenue\\n, sum(if(`month`=\\'Apr\\', revenue, NULL)) as Apr_revenue\\n, sum(if(`month`=\\'May\\', revenue, NULL)) as May_revenue\\n, sum(if(`month`=\\'Jun\\', revenue, NULL)) as Jun_revenue\\n, sum(if(`month`=\\'Jul\\', revenue, NULL)) as Jul_revenue\\n, sum(if(`month`=\\'Aug\\', revenue, NULL)) as Aug_revenue\\n, sum(if(`month`=\\'Sep\\', revenue, NULL)) as Sep_revenue\\n, sum(if(`month`=\\'Oct\\', revenue, NULL)) as Oct_revenue\\n, sum(if(`month`=\\'Nov\\', revenue, NULL)) as Nov_revenue\\n, sum(if(`month`=\\'Dec\\', revenue, NULL)) as Dec_revenue\\nfrom department\\ngroup by id;",
                "codeTag": "Unknown"
            },
            {
                "id": 913913,
                "title": "mysql-solution",
                "content": "```\\n\\nSELECT d.id,\\nSUM(CASE WHEN d.month = \\'Jan\\' THEN d.revenue END) AS Jan_Revenue,\\nSUM(CASE WHEN d.month = \\'Feb\\' THEN d.revenue END) AS Feb_Revenue,\\nSUM(CASE WHEN d.month = \\'Mar\\' THEN d.revenue END) AS Mar_Revenue,\\nSUM(CASE WHEN d.month = \\'Apr\\' THEN d.revenue END) AS Apr_Revenue,\\nSUM(CASE WHEN d.month = \\'May\\' THEN d.revenue END) AS May_Revenue,\\nSUM(CASE WHEN d.month = \\'Jun\\' THEN d.revenue END) AS Jun_Revenue,\\nSUM(CASE WHEN d.month = \\'Jul\\' THEN d.revenue END) AS Jul_Revenue,\\nSUM(CASE WHEN d.month = \\'Aug\\' THEN d.revenue END) AS Aug_Revenue,\\nSUM(CASE WHEN d.month = \\'Sep\\' THEN d.revenue END) AS Sep_Revenue,\\nSUM(CASE WHEN d.month = \\'Oct\\' THEN d.revenue END) AS Oct_Revenue,\\nSUM(CASE WHEN d.month = \\'Nov\\' THEN d.revenue END) AS Nov_Revenue,\\nSUM(CASE WHEN d.month = \\'Dec\\' THEN d.revenue END) AS Dec_Revenue\\nFROM Department d\\nGROUP BY d.id;\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT d.id,\\nSUM(CASE WHEN d.month = \\'Jan\\' THEN d.revenue END) AS Jan_Revenue,\\nSUM(CASE WHEN d.month = \\'Feb\\' THEN d.revenue END) AS Feb_Revenue,\\nSUM(CASE WHEN d.month = \\'Mar\\' THEN d.revenue END) AS Mar_Revenue,\\nSUM(CASE WHEN d.month = \\'Apr\\' THEN d.revenue END) AS Apr_Revenue,\\nSUM(CASE WHEN d.month = \\'May\\' THEN d.revenue END) AS May_Revenue,\\nSUM(CASE WHEN d.month = \\'Jun\\' THEN d.revenue END) AS Jun_Revenue,\\nSUM(CASE WHEN d.month = \\'Jul\\' THEN d.revenue END) AS Jul_Revenue,\\nSUM(CASE WHEN d.month = \\'Aug\\' THEN d.revenue END) AS Aug_Revenue,\\nSUM(CASE WHEN d.month = \\'Sep\\' THEN d.revenue END) AS Sep_Revenue,\\nSUM(CASE WHEN d.month = \\'Oct\\' THEN d.revenue END) AS Oct_Revenue,\\nSUM(CASE WHEN d.month = \\'Nov\\' THEN d.revenue END) AS Nov_Revenue,\\nSUM(CASE WHEN d.month = \\'Dec\\' THEN d.revenue END) AS Dec_Revenue\\nFROM Department d\\nGROUP BY d.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 905085,
                "title": "mysql-solution-faster-than-99",
                "content": "select d.id,\\n    max(case when d.month = \\'Jan\\' then d.revenue else null end) as \\'Jan_Revenue\\',\\n    max(case when d.month = \\'Feb\\' then d.revenue else null end) as \\'Feb_Revenue\\',\\n    max(case when d.month = \\'Mar\\' then d.revenue else null end) as \\'Mar_Revenue\\',\\n    max(case when d.month = \\'Apr\\' then d.revenue else null end) as \\'Apr_Revenue\\',\\n    max(case when d.month = \\'May\\' then d.revenue else null end) as \\'May_Revenue\\',\\n    max(case when d.month = \\'Jun\\' then d.revenue else null end) as \\'Jun_Revenue\\',\\n    max(case when d.month = \\'Jul\\' then d.revenue else null end) as \\'Jul_Revenue\\',\\n    max(case when d.month = \\'Aug\\' then d.revenue else null end) as \\'Aug_Revenue\\',\\n    max(case when d.month = \\'Sep\\' then d.revenue else null end) as \\'Sep_Revenue\\',\\n    max(case when d.month = \\'Oct\\' then d.revenue else null end) as \\'Oct_Revenue\\',\\n    max(case when d.month = \\'Nov\\' then d.revenue else null end) as \\'Nov_Revenue\\',\\n    max(case when d.month = \\'Dec\\' then d.revenue else null end) as \\'Dec_Revenue\\'\\nfrom department d\\ngroup by d.id",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select d.id,\\n    max(case when d.month = \\'Jan\\' then d.revenue else null end) as \\'Jan_Revenue\\',\\n    max(case when d.month = \\'Feb\\' then d.revenue else null end) as \\'Feb_Revenue\\',\\n    max(case when d.month = \\'Mar\\' then d.revenue else null end) as \\'Mar_Revenue\\',\\n    max(case when d.month = \\'Apr\\' then d.revenue else null end) as \\'Apr_Revenue\\',\\n    max(case when d.month = \\'May\\' then d.revenue else null end) as \\'May_Revenue\\',\\n    max(case when d.month = \\'Jun\\' then d.revenue else null end) as \\'Jun_Revenue\\',\\n    max(case when d.month = \\'Jul\\' then d.revenue else null end) as \\'Jul_Revenue\\',\\n    max(case when d.month = \\'Aug\\' then d.revenue else null end) as \\'Aug_Revenue\\',\\n    max(case when d.month = \\'Sep\\' then d.revenue else null end) as \\'Sep_Revenue\\',\\n    max(case when d.month = \\'Oct\\' then d.revenue else null end) as \\'Oct_Revenue\\',\\n    max(case when d.month = \\'Nov\\' then d.revenue else null end) as \\'Nov_Revenue\\',\\n    max(case when d.month = \\'Dec\\' then d.revenue else null end) as \\'Dec_Revenue\\'\\nfrom department d\\ngroup by d.id",
                "codeTag": "Unknown"
            },
            {
                "id": 862953,
                "title": "pivot-in-oracle",
                "content": "```\\nselect *\\nfrom  (select id, revenue, month  from department)\\n pivot  (min(revenue) as Revenue\\n                     for month in (\\'Jan\\' as Jan, \\'Feb\\' as Feb, \\'Mar\\' as Mar, \\'Apr\\' as Apr, \\'May\\' as May, \\'Jun\\' as Jun, \\'Jul\\' as Jul, \\'Aug\\' as Aug, \\'Sep\\' as Sep, \\'Oct\\' as Oct, \\'Nov\\' as Nov, \\'Dec\\' as Dec)\\n        )\\norder by id;\\n```",
                "solutionTags": [],
                "code": "```\\nselect *\\nfrom  (select id, revenue, month  from department)\\n pivot  (min(revenue) as Revenue\\n                     for month in (\\'Jan\\' as Jan, \\'Feb\\' as Feb, \\'Mar\\' as Mar, \\'Apr\\' as Apr, \\'May\\' as May, \\'Jun\\' as Jun, \\'Jul\\' as Jul, \\'Aug\\' as Aug, \\'Sep\\' as Sep, \\'Oct\\' as Oct, \\'Nov\\' as Nov, \\'Dec\\' as Dec)\\n        )\\norder by id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 759706,
                "title": "ms-sql-server",
                "content": "```\\nselect  id,\\n        [Jan] as Jan_Revenue,[Feb] as Feb_Revenue,[Mar] as Mar_Revenue,[Apr] as Apr_Revenue,\\n        [May] as May_Revenue,[Jun] as Jun_Revenue,[Jul] as Jul_Revenue,[Aug] as Aug_Revenue,\\n        [Sep] as Sep_Revenue,[Oct] as Oct_Revenue,[Nov] as Nov_Revenue,[Dec] as Dec_Revenue\\nfrom\\n    (select id,revenue,month from Department) as dep\\npivot\\n(\\n    max(revenue)\\n    for month in ([Jan],[Feb],[Mar],[Apr],\\n                  [May],[Jun],[Jul],[Aug],\\n                  [Sep],[Oct],[Nov],[Dec])\\n) as Reformat\\n```",
                "solutionTags": [],
                "code": "```\\nselect  id,\\n        [Jan] as Jan_Revenue,[Feb] as Feb_Revenue,[Mar] as Mar_Revenue,[Apr] as Apr_Revenue,\\n        [May] as May_Revenue,[Jun] as Jun_Revenue,[Jul] as Jul_Revenue,[Aug] as Aug_Revenue,\\n        [Sep] as Sep_Revenue,[Oct] as Oct_Revenue,[Nov] as Nov_Revenue,[Dec] as Dec_Revenue\\nfrom\\n    (select id,revenue,month from Department) as dep\\npivot\\n(\\n    max(revenue)\\n    for month in ([Jan],[Feb],[Mar],[Apr],\\n                  [May],[Jun],[Jul],[Aug],\\n                  [Sep],[Oct],[Nov],[Dec])\\n) as Reformat\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 758968,
                "title": "mssql",
                "content": "```SQL\\n\\n/* Write your T-SQL query statement below */\\nselect id, sum(case when month = \\'Jan\\' then revenue else NULL end) as Jan_Revenue ,\\n           sum(case when month = \\'Feb\\' then revenue else NULL end) as Feb_Revenue ,\\n           sum(case when month = \\'Mar\\' then revenue else NULL end) as Mar_Revenue ,\\n           sum(case when month = \\'Apr\\' then revenue else NULL end) as Apr_Revenue ,\\n           sum(case when month = \\'May\\' then revenue else NULL end) as May_Revenue ,\\n           sum(case when month = \\'Jun\\' then revenue else NULL end) as Jun_Revenue ,\\n           sum(case when month = \\'Jul\\' then revenue else NULL end) as Jul_Revenue ,\\n           sum(case when month = \\'Aug\\' then revenue else NULL end) as Aug_Revenue ,\\n           sum(case when month = \\'Sep\\' then revenue else NULL end) as Sep_Revenue ,\\n           sum(case when month = \\'Oct\\' then revenue else NULL end) as Oct_Revenue ,\\n           sum(case when month = \\'Nov\\' then revenue else NULL end) as Nov_Revenue ,\\n           sum(case when month = \\'Dec\\' then revenue else NULL end) as Dec_Revenue \\nfrom Department \\ngroup by id\\n\\n--Runtime: 1341 ms, faster than 96.69% of MS SQL Server online submissions for Reformat Department Table.",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```SQL\\n\\n/* Write your T-SQL query statement below */\\nselect id, sum(case when month = \\'Jan\\' then revenue else NULL end) as Jan_Revenue ,\\n           sum(case when month = \\'Feb\\' then revenue else NULL end) as Feb_Revenue ,\\n           sum(case when month = \\'Mar\\' then revenue else NULL end) as Mar_Revenue ,\\n           sum(case when month = \\'Apr\\' then revenue else NULL end) as Apr_Revenue ,\\n           sum(case when month = \\'May\\' then revenue else NULL end) as May_Revenue ,\\n           sum(case when month = \\'Jun\\' then revenue else NULL end) as Jun_Revenue ,\\n           sum(case when month = \\'Jul\\' then revenue else NULL end) as Jul_Revenue ,\\n           sum(case when month = \\'Aug\\' then revenue else NULL end) as Aug_Revenue ,\\n           sum(case when month = \\'Sep\\' then revenue else NULL end) as Sep_Revenue ,\\n           sum(case when month = \\'Oct\\' then revenue else NULL end) as Oct_Revenue ,\\n           sum(case when month = \\'Nov\\' then revenue else NULL end) as Nov_Revenue ,\\n           sum(case when month = \\'Dec\\' then revenue else NULL end) as Dec_Revenue \\nfrom Department \\ngroup by id\\n\\n--Runtime: 1341 ms, faster than 96.69% of MS SQL Server online submissions for Reformat Department Table.",
                "codeTag": "Unknown"
            },
            {
                "id": 733067,
                "title": "simple-sum-if",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT id,\\n    SUM(IF(month = \\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\n    SUM(IF(month = \\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\n    SUM(IF(month = \\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\n    SUM(IF(month = \\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\n    SUM(IF(month = \\'May\\', revenue, NULL)) AS May_Revenue,\\n    SUM(IF(month = \\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\n    SUM(IF(month = \\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\n    SUM(IF(month = \\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\n    SUM(IF(month = \\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\n    SUM(IF(month = \\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\n    SUM(IF(month = \\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\n    SUM(IF(month = \\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id;\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT id,\\n    SUM(IF(month = \\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\n    SUM(IF(month = \\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\n    SUM(IF(month = \\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\n    SUM(IF(month = \\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\n    SUM(IF(month = \\'May\\', revenue, NULL)) AS May_Revenue,\\n    SUM(IF(month = \\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\n    SUM(IF(month = \\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\n    SUM(IF(month = \\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\n    SUM(IF(month = \\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\n    SUM(IF(month = \\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\n    SUM(IF(month = \\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\n    SUM(IF(month = \\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGROUP BY id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696243,
                "title": "oracle-with-group-by-and-case",
                "content": "```\\nSELECT \"id\",\\n        SUM(\"Jan_Revenue\") \"Jan_Revenue\", \\n        SUM(\"Feb_Revenue\") \"Feb_Revenue\",\\n        SUM(\"Mar_Revenue\") \"Mar_Revenue\",\\n        SUM(\"Apr_Revenue\") \"Apr_Revenue\",\\n        SUM(\"May_Revenue\") \"May_Revenue\",\\n        SUM(\"Jun_Revenue\") \"Jun_Revenue\",\\n        SUM(\"Jul_Revenue\") \"Jul_Revenue\",\\n        SUM(\"Aug_Revenue\") \"Aug_Revenue\",\\n        SUM(\"Sep_Revenue\") \"Sep_Revenue\",\\n        SUM(\"Oct_Revenue\") \"Oct_Revenue\",\\n        SUM(\"Nov_Revenue\") \"Nov_Revenue\",\\n        SUM(\"Dec_Revenue\") \"Dec_Revenue\"\\nFROM\\n(SELECT id as \"id\",\\n       CASE month WHEN \\'Jan\\' THEN revenue ELSE null END AS \"Jan_Revenue\",\\n       CASE month WHEN \\'Feb\\' THEN revenue ELSE null END AS \"Feb_Revenue\",\\n       CASE month WHEN \\'Mar\\' THEN revenue ELSE null END AS \"Mar_Revenue\",\\n       CASE month WHEN \\'Apr\\' THEN revenue ELSE null END AS \"Apr_Revenue\",\\n       CASE month WHEN \\'May\\' THEN revenue ELSE null END AS \"May_Revenue\",\\n       CASE month WHEN \\'Jun\\' THEN revenue ELSE null END AS \"Jun_Revenue\",\\n       CASE month WHEN \\'Jul\\' THEN revenue ELSE null END AS \"Jul_Revenue\",\\n       CASE month WHEN \\'Aug\\' THEN revenue ELSE null END AS \"Aug_Revenue\",\\n       CASE month WHEN \\'Sep\\' THEN revenue ELSE null END AS \"Sep_Revenue\",\\n       CASE month WHEN \\'Oct\\' THEN revenue ELSE null END AS \"Oct_Revenue\",\\n       CASE month WHEN \\'Nov\\' THEN revenue ELSE null END AS \"Nov_Revenue\",\\n       CASE month WHEN \\'Dec\\' THEN revenue ELSE null END AS \"Dec_Revenue\"\\nFROM Department)\\nGROUP BY \"id\"\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \"id\",\\n        SUM(\"Jan_Revenue\") \"Jan_Revenue\", \\n        SUM(\"Feb_Revenue\") \"Feb_Revenue\",\\n        SUM(\"Mar_Revenue\") \"Mar_Revenue\",\\n        SUM(\"Apr_Revenue\") \"Apr_Revenue\",\\n        SUM(\"May_Revenue\") \"May_Revenue\",\\n        SUM(\"Jun_Revenue\") \"Jun_Revenue\",\\n        SUM(\"Jul_Revenue\") \"Jul_Revenue\",\\n        SUM(\"Aug_Revenue\") \"Aug_Revenue\",\\n        SUM(\"Sep_Revenue\") \"Sep_Revenue\",\\n        SUM(\"Oct_Revenue\") \"Oct_Revenue\",\\n        SUM(\"Nov_Revenue\") \"Nov_Revenue\",\\n        SUM(\"Dec_Revenue\") \"Dec_Revenue\"\\nFROM\\n(SELECT id as \"id\",\\n       CASE month WHEN \\'Jan\\' THEN revenue ELSE null END AS \"Jan_Revenue\",\\n       CASE month WHEN \\'Feb\\' THEN revenue ELSE null END AS \"Feb_Revenue\",\\n       CASE month WHEN \\'Mar\\' THEN revenue ELSE null END AS \"Mar_Revenue\",\\n       CASE month WHEN \\'Apr\\' THEN revenue ELSE null END AS \"Apr_Revenue\",\\n       CASE month WHEN \\'May\\' THEN revenue ELSE null END AS \"May_Revenue\",\\n       CASE month WHEN \\'Jun\\' THEN revenue ELSE null END AS \"Jun_Revenue\",\\n       CASE month WHEN \\'Jul\\' THEN revenue ELSE null END AS \"Jul_Revenue\",\\n       CASE month WHEN \\'Aug\\' THEN revenue ELSE null END AS \"Aug_Revenue\",\\n       CASE month WHEN \\'Sep\\' THEN revenue ELSE null END AS \"Sep_Revenue\",\\n       CASE month WHEN \\'Oct\\' THEN revenue ELSE null END AS \"Oct_Revenue\",\\n       CASE month WHEN \\'Nov\\' THEN revenue ELSE null END AS \"Nov_Revenue\",\\n       CASE month WHEN \\'Dec\\' THEN revenue ELSE null END AS \"Dec_Revenue\"\\nFROM Department)\\nGROUP BY \"id\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 679384,
                "title": "ms-sql-pivot-table",
                "content": "```\\n\\nwith cte as(\\n\\tselect id\\n\\t\\t\\t,revenue\\n\\t\\t\\t,case month \\n\\t\\t\\t\\twhen \\'Jan\\' then \\'Jan_Revenue\\'\\n\\t\\t\\t\\twhen \\'Feb\\' then \\'Feb_Revenue\\'\\n\\t\\t\\t\\twhen \\'Mar\\' then \\'Mar_Revenue\\'\\n\\t\\t\\t\\twhen \\'Apr\\' then \\'Apr_Revenue\\'\\n\\t\\t\\t\\twhen \\'May\\' then \\'May_Revenue\\'\\n\\t\\t\\t\\twhen \\'Jun\\' then \\'Jun_Revenue\\'\\n\\t\\t\\t\\twhen \\'Jul\\' then \\'Jul_Revenue\\'\\n\\t\\t\\t\\twhen \\'Aug\\' then \\'Aug_Revenue\\'\\n\\t\\t\\t\\twhen \\'Sep\\' then \\'Sep_Revenue\\'\\n\\t\\t\\t\\twhen \\'Oct\\' then \\'Oct_Revenue\\'\\n\\t\\t\\t\\twhen \\'Nov\\' then \\'Nov_Revenue\\'\\n\\t\\t\\t\\twhen \\'Dec\\' then \\'Dec_Revenue\\'\\n\\t\\t\\t\\telse month end \\n\\t\\t\\t as Month_\\n\\tfrom Department\\n)\\nselect * from cte\\npivot\\n(sum(revenue)\\nfor Month_ in \\n([Jan_Revenue], [Feb_Revenue],[Mar_Revenue],[Apr_Revenue],[May_Revenue],[Jun_Revenue],[Jul_Revenue],[Aug_Revenue],[Sep_Revenue],[Oct_Revenue],[Nov_Revenue],[Dec_Revenue])\\n) as pvt",
                "solutionTags": [],
                "code": "```\\n\\nwith cte as(\\n\\tselect id\\n\\t\\t\\t,revenue\\n\\t\\t\\t,case month \\n\\t\\t\\t\\twhen \\'Jan\\' then \\'Jan_Revenue\\'\\n\\t\\t\\t\\twhen \\'Feb\\' then \\'Feb_Revenue\\'\\n\\t\\t\\t\\twhen \\'Mar\\' then \\'Mar_Revenue\\'\\n\\t\\t\\t\\twhen \\'Apr\\' then \\'Apr_Revenue\\'\\n\\t\\t\\t\\twhen \\'May\\' then \\'May_Revenue\\'\\n\\t\\t\\t\\twhen \\'Jun\\' then \\'Jun_Revenue\\'\\n\\t\\t\\t\\twhen \\'Jul\\' then \\'Jul_Revenue\\'\\n\\t\\t\\t\\twhen \\'Aug\\' then \\'Aug_Revenue\\'\\n\\t\\t\\t\\twhen \\'Sep\\' then \\'Sep_Revenue\\'\\n\\t\\t\\t\\twhen \\'Oct\\' then \\'Oct_Revenue\\'\\n\\t\\t\\t\\twhen \\'Nov\\' then \\'Nov_Revenue\\'\\n\\t\\t\\t\\twhen \\'Dec\\' then \\'Dec_Revenue\\'\\n\\t\\t\\t\\telse month end \\n\\t\\t\\t as Month_\\n\\tfrom Department\\n)\\nselect * from cte\\npivot\\n(sum(revenue)\\nfor Month_ in \\n([Jan_Revenue], [Feb_Revenue],[Mar_Revenue],[Apr_Revenue],[May_Revenue],[Jun_Revenue],[Jul_Revenue],[Aug_Revenue],[Sep_Revenue],[Oct_Revenue],[Nov_Revenue],[Dec_Revenue])\\n) as pvt",
                "codeTag": "Unknown"
            },
            {
                "id": 588235,
                "title": "oracle-solution-using-pivot",
                "content": "Select * from\\n(Select id, revenue, month from department)\\npivot(\\nmin(revenue) for month in (\\'Jan\\' Jan_Revenue, \\'Feb\\' Feb_Revenue, \\'Mar\\' Mar_Revenue,\\n                          \\'Apr\\' Apr_Revenue, \\'May\\' May_Revenue, \\'Jun\\' Jun_Revenue,\\n                           \\'Jul\\' Jul_Revenue, \\'Aug\\' Aug_Revenue, \\'Sep\\' Sep_Revenue,\\n                           \\'Oct\\' Oct_Revenue, \\'Nov\\' Nov_Revenue, \\'Dec\\' Dec_Revenue\\n                          )\\n)",
                "solutionTags": [],
                "code": "Select * from\\n(Select id, revenue, month from department)\\npivot(\\nmin(revenue) for month in (\\'Jan\\' Jan_Revenue, \\'Feb\\' Feb_Revenue, \\'Mar\\' Mar_Revenue,\\n                          \\'Apr\\' Apr_Revenue, \\'May\\' May_Revenue, \\'Jun\\' Jun_Revenue,\\n                           \\'Jul\\' Jul_Revenue, \\'Aug\\' Aug_Revenue, \\'Sep\\' Sep_Revenue,\\n                           \\'Oct\\' Oct_Revenue, \\'Nov\\' Nov_Revenue, \\'Dec\\' Dec_Revenue\\n                          )\\n)",
                "codeTag": "Unknown"
            },
            {
                "id": 520732,
                "title": "ms-sql-using-pivot-faster-than-96-58",
                "content": "```\\nSELECT id, \\n       [Jan] AS Jan_Revenue, \\n       [Feb] AS Feb_Revenue, \\n       [Mar] AS Mar_Revenue, \\n       [Apr] AS Apr_Revenue,\\n       [May] AS May_Revenue,\\n       [Jun] AS Jun_Revenue,\\n       [Jul] AS Jul_Revenue,\\n       [Aug] AS Aug_Revenue,\\n       [Sep] AS Sep_Revenue,\\n       [Oct] AS Oct_Revenue,\\n       [Nov] AS Nov_Revenue,\\n       [Dec] AS Dec_Revenue\\nFROM\\n(SELECT Id, revenue, month FROM Department) AS p\\n    PIVOT  \\n        (  \\n            SUM(revenue)\\n            FOR month IN  \\n            (  [Jan],\\n               [Feb],\\n               [Mar],\\n               [Apr],\\n               [May],\\n               [Jun],\\n               [Jul],\\n               [Aug],\\n               [Sep],\\n               [Oct],\\n               [Nov],\\n               [Dec] \\n            )  \\n        ) AS pvt\\nORDER BY pvt.ID\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id, \\n       [Jan] AS Jan_Revenue, \\n       [Feb] AS Feb_Revenue, \\n       [Mar] AS Mar_Revenue, \\n       [Apr] AS Apr_Revenue,\\n       [May] AS May_Revenue,\\n       [Jun] AS Jun_Revenue,\\n       [Jul] AS Jul_Revenue,\\n       [Aug] AS Aug_Revenue,\\n       [Sep] AS Sep_Revenue,\\n       [Oct] AS Oct_Revenue,\\n       [Nov] AS Nov_Revenue,\\n       [Dec] AS Dec_Revenue\\nFROM\\n(SELECT Id, revenue, month FROM Department) AS p\\n    PIVOT  \\n        (  \\n            SUM(revenue)\\n            FOR month IN  \\n            (  [Jan],\\n               [Feb],\\n               [Mar],\\n               [Apr],\\n               [May],\\n               [Jun],\\n               [Jul],\\n               [Aug],\\n               [Sep],\\n               [Oct],\\n               [Nov],\\n               [Dec] \\n            )  \\n        ) AS pvt\\nORDER BY pvt.ID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459546,
                "title": "mssql-without-case",
                "content": "Using subquery in SELECT\\n\\n```\\n\\nSELECT DISTINCT D.id,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Jan\\' AND D.id = J.id) AS Jan_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Feb\\' AND D.id = J.id) AS Feb_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Mar\\' AND D.id = J.id) AS Mar_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Apr\\' AND D.id = J.id) AS Apr_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'May\\' AND D.id = J.id) AS May_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Jun\\' AND D.id = J.id) AS Jun_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Jul\\' AND D.id = J.id) AS Jul_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Aug\\' AND D.id = J.id) AS Aug_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Sep\\' AND D.id = J.id) AS Sep_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Oct\\' AND D.id = J.id) AS Oct_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Nov\\' AND D.id = J.id) AS Nov_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Dec\\' AND D.id = J.id) AS Dec_Revenue\\nFROM Department D\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT DISTINCT D.id,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Jan\\' AND D.id = J.id) AS Jan_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Feb\\' AND D.id = J.id) AS Feb_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Mar\\' AND D.id = J.id) AS Mar_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Apr\\' AND D.id = J.id) AS Apr_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'May\\' AND D.id = J.id) AS May_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Jun\\' AND D.id = J.id) AS Jun_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Jul\\' AND D.id = J.id) AS Jul_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Aug\\' AND D.id = J.id) AS Aug_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Sep\\' AND D.id = J.id) AS Sep_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Oct\\' AND D.id = J.id) AS Oct_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Nov\\' AND D.id = J.id) AS Nov_Revenue,\\n(SELECT SUM(revenue) FROM Department J WHERE J.month = \\'Dec\\' AND D.id = J.id) AS Dec_Revenue\\nFROM Department D\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 441551,
                "title": "simple-mysql",
                "content": "select a.id,\\n(select revenue from Department where month = \\'Jan\\' and id = a.id) as Jan_Revenue,\\n(select revenue from Department where month = \\'Feb\\' and id = a.id) as Feb_Revenue,\\n(select revenue from Department where month = \\'Mar\\' and id = a.id) as Mar_Revenue,\\n(select revenue from Department where month = \\'Apr\\' and id = a.id) as Apr_Revenue,\\n(select revenue from Department where month = \\'May\\' and id = a.id) as May_Revenue,\\n(select revenue from Department where month = \\'Jun\\' and id = a.id) as Jun_Revenue,\\n(select revenue from Department where month = \\'Jul\\' and id = a.id) as Jul_Revenue,\\n(select revenue from Department where month = \\'Aug\\' and id = a.id) as Aug_Revenue,\\n(select revenue from Department where month = \\'Sep\\' and id = a.id) as Sep_Revenue,\\n(select revenue from Department where month = \\'Oct\\' and id = a.id) as Oct_Revenue,\\n(select revenue from Department where month = \\'Nov\\' and id = a.id) as Nov_Revenue,\\n(select revenue from Department where month = \\'Dec\\' and id = a.id) as Dec_Revenue\\nfrom \\n(select distinct id as id from Department) a",
                "solutionTags": [],
                "code": "select a.id,\\n(select revenue from Department where month = \\'Jan\\' and id = a.id) as Jan_Revenue,\\n(select revenue from Department where month = \\'Feb\\' and id = a.id) as Feb_Revenue,\\n(select revenue from Department where month = \\'Mar\\' and id = a.id) as Mar_Revenue,\\n(select revenue from Department where month = \\'Apr\\' and id = a.id) as Apr_Revenue,\\n(select revenue from Department where month = \\'May\\' and id = a.id) as May_Revenue,\\n(select revenue from Department where month = \\'Jun\\' and id = a.id) as Jun_Revenue,\\n(select revenue from Department where month = \\'Jul\\' and id = a.id) as Jul_Revenue,\\n(select revenue from Department where month = \\'Aug\\' and id = a.id) as Aug_Revenue,\\n(select revenue from Department where month = \\'Sep\\' and id = a.id) as Sep_Revenue,\\n(select revenue from Department where month = \\'Oct\\' and id = a.id) as Oct_Revenue,\\n(select revenue from Department where month = \\'Nov\\' and id = a.id) as Nov_Revenue,\\n(select revenue from Department where month = \\'Dec\\' and id = a.id) as Dec_Revenue\\nfrom \\n(select distinct id as id from Department) a",
                "codeTag": "Unknown"
            },
            {
                "id": 437770,
                "title": "oracle-0-memory",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nSELECT\\n    id,\\n    SUM(Jan_Revenue) Jan_Revenue,\\n    SUM(Feb_Revenue) Feb_Revenue,\\n    SUM(Mar_Revenue) Mar_Revenue,\\n    SUM(Apr_Revenue) Apr_Revenue,\\n    SUM(May_Revenue) May_Revenue,\\n    SUM(Jun_Revenue) Jun_Revenue,\\n    SUM(Jul_Revenue) Jul_Revenue,\\n    SUM(Aug_Revenue) Aug_Revenue,\\n    SUM(Sep_Revenue) Sep_Revenue,\\n    SUM(Oct_Revenue) Oct_Revenue,\\n    SUM(Nov_Revenue) Nov_Revenue,\\n    SUM(Dec_Revenue) Dec_Revenue\\nFROM (\\n    SELECT\\n        id,\\n        CASE WHEN month LIKE \\'Jan\\' THEN revenue ELSE null END Jan_Revenue,\\n        CASE WHEN month LIKE \\'Feb\\' THEN revenue ELSE null END Feb_Revenue,\\n        CASE WHEN month LIKE \\'Mar\\' THEN revenue ELSE null END Mar_Revenue,\\n        CASE WHEN month LIKE \\'Apr\\' THEN revenue ELSE null END Apr_Revenue,\\n        CASE WHEN month LIKE \\'May\\' THEN revenue ELSE null END May_Revenue,\\n        CASE WHEN month LIKE \\'Jun\\' THEN revenue ELSE null END Jun_Revenue,\\n        CASE WHEN month LIKE \\'Jul\\' THEN revenue ELSE null END Jul_Revenue,\\n        CASE WHEN month LIKE \\'Aug\\' THEN revenue ELSE null END Aug_Revenue,\\n        CASE WHEN month LIKE \\'Sep\\' THEN revenue ELSE null END Sep_Revenue,\\n        CASE WHEN month LIKE \\'Oct\\' THEN revenue ELSE null END Oct_Revenue,\\n        CASE WHEN month LIKE \\'Nov\\' THEN revenue ELSE null END Nov_Revenue,\\n        CASE WHEN month LIKE \\'Dec\\' THEN revenue ELSE null END Dec_Revenue\\n    FROM Department\\n)\\nGROUP BY id\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT\\n    id,\\n    SUM(Jan_Revenue) Jan_Revenue,\\n    SUM(Feb_Revenue) Feb_Revenue,\\n    SUM(Mar_Revenue) Mar_Revenue,\\n    SUM(Apr_Revenue) Apr_Revenue,\\n    SUM(May_Revenue) May_Revenue,\\n    SUM(Jun_Revenue) Jun_Revenue,\\n    SUM(Jul_Revenue) Jul_Revenue,\\n    SUM(Aug_Revenue) Aug_Revenue,\\n    SUM(Sep_Revenue) Sep_Revenue,\\n    SUM(Oct_Revenue) Oct_Revenue,\\n    SUM(Nov_Revenue) Nov_Revenue,\\n    SUM(Dec_Revenue) Dec_Revenue\\nFROM (\\n    SELECT\\n        id,\\n        CASE WHEN month LIKE \\'Jan\\' THEN revenue ELSE null END Jan_Revenue,\\n        CASE WHEN month LIKE \\'Feb\\' THEN revenue ELSE null END Feb_Revenue,\\n        CASE WHEN month LIKE \\'Mar\\' THEN revenue ELSE null END Mar_Revenue,\\n        CASE WHEN month LIKE \\'Apr\\' THEN revenue ELSE null END Apr_Revenue,\\n        CASE WHEN month LIKE \\'May\\' THEN revenue ELSE null END May_Revenue,\\n        CASE WHEN month LIKE \\'Jun\\' THEN revenue ELSE null END Jun_Revenue,\\n        CASE WHEN month LIKE \\'Jul\\' THEN revenue ELSE null END Jul_Revenue,\\n        CASE WHEN month LIKE \\'Aug\\' THEN revenue ELSE null END Aug_Revenue,\\n        CASE WHEN month LIKE \\'Sep\\' THEN revenue ELSE null END Sep_Revenue,\\n        CASE WHEN month LIKE \\'Oct\\' THEN revenue ELSE null END Oct_Revenue,\\n        CASE WHEN month LIKE \\'Nov\\' THEN revenue ELSE null END Nov_Revenue,\\n        CASE WHEN month LIKE \\'Dec\\' THEN revenue ELSE null END Dec_Revenue\\n    FROM Department\\n)\\nGROUP BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 433476,
                "title": "wonder-if-there-is-an-easier-and-faster-solution",
                "content": "```\\n\\nSELECT id,\\n       SUM(jan) AS Jan_Revenue,\\n       SUM(feb) AS Feb_Revenue,\\n       SUM(mar) AS Mar_Revenue,\\n       SUM(apr) AS Apr_Revenue,\\n       SUM(may) AS May_Revenue,\\n       SUM(jun) AS Jun_Revenue,\\n       SUM(jul) AS Jul_Revenue,\\n       SUM(aug) AS Aug_Revenue,\\n       SUM(sep) AS Sep_Revenue,\\n       SUM(oct) AS Oct_Revenue,\\n       SUM(nov) AS Nov_Revenue,\\n       SUM(decm) AS Dec_Revenue\\nFROM (\\n         SELECT id,\\n                CASE WHEN month = \\'Jan\\' THEN revenue END AS jan,\\n                CASE WHEN month = \\'Feb\\' THEN revenue END AS feb,\\n                CASE WHEN month = \\'Mar\\' THEN revenue END AS mar,\\n                CASE WHEN month = \\'Apr\\' THEN revenue END AS apr,\\n                CASE WHEN month = \\'May\\' THEN revenue END AS may,\\n                CASE WHEN month = \\'Jun\\' THEN revenue END AS jun,\\n                CASE WHEN month = \\'Jul\\' THEN revenue END AS jul,\\n                CASE WHEN month = \\'Aug\\' THEN revenue END AS aug,\\n                CASE WHEN month = \\'Sep\\' THEN revenue END AS sep,\\n                CASE WHEN month = \\'Oct\\' THEN revenue END AS oct,\\n                CASE WHEN month = \\'Nov\\' THEN revenue END AS nov,\\n                CASE WHEN month = \\'Dec\\' THEN revenue END AS decm\\n         FROM department\\n     ) AS X\\nGROUP BY id\\nORDER BY id\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT id,\\n       SUM(jan) AS Jan_Revenue,\\n       SUM(feb) AS Feb_Revenue,\\n       SUM(mar) AS Mar_Revenue,\\n       SUM(apr) AS Apr_Revenue,\\n       SUM(may) AS May_Revenue,\\n       SUM(jun) AS Jun_Revenue,\\n       SUM(jul) AS Jul_Revenue,\\n       SUM(aug) AS Aug_Revenue,\\n       SUM(sep) AS Sep_Revenue,\\n       SUM(oct) AS Oct_Revenue,\\n       SUM(nov) AS Nov_Revenue,\\n       SUM(decm) AS Dec_Revenue\\nFROM (\\n         SELECT id,\\n                CASE WHEN month = \\'Jan\\' THEN revenue END AS jan,\\n                CASE WHEN month = \\'Feb\\' THEN revenue END AS feb,\\n                CASE WHEN month = \\'Mar\\' THEN revenue END AS mar,\\n                CASE WHEN month = \\'Apr\\' THEN revenue END AS apr,\\n                CASE WHEN month = \\'May\\' THEN revenue END AS may,\\n                CASE WHEN month = \\'Jun\\' THEN revenue END AS jun,\\n                CASE WHEN month = \\'Jul\\' THEN revenue END AS jul,\\n                CASE WHEN month = \\'Aug\\' THEN revenue END AS aug,\\n                CASE WHEN month = \\'Sep\\' THEN revenue END AS sep,\\n                CASE WHEN month = \\'Oct\\' THEN revenue END AS oct,\\n                CASE WHEN month = \\'Nov\\' THEN revenue END AS nov,\\n                CASE WHEN month = \\'Dec\\' THEN revenue END AS decm\\n         FROM department\\n     ) AS X\\nGROUP BY id\\nORDER BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 421605,
                "title": "sql-server-solution",
                "content": "select id,\\n    Jan as Jan_Revenue, \\n    Feb as Feb_Revenue, \\n    Mar as Mar_Revenue, \\n    Apr as Apr_Revenue, \\n    May as May_Revenue, \\n    Jun as Jun_Revenue, \\n    Jul as Jul_Revenue, \\n    Aug as Aug_Revenue, \\n    Sep as Sep_Revenue, \\n    Oct as Oct_Revenue, \\n    Nov as Nov_Revenue, \\n    Dec as Dec_Revenue\\nFROM  Department\\n**PIVOT**  \\n    (  \\n        **Sum**(revenue) /*what is the value?*/\\n        **FOR** Month /*what is the current column?*/\\n        **IN** (Jan, Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct, Nov, Dec) /*what values in new columns?*/\\n    ) as tb;",
                "solutionTags": [],
                "code": "select id,\\n    Jan as Jan_Revenue, \\n    Feb as Feb_Revenue, \\n    Mar as Mar_Revenue, \\n    Apr as Apr_Revenue, \\n    May as May_Revenue, \\n    Jun as Jun_Revenue, \\n    Jul as Jul_Revenue, \\n    Aug as Aug_Revenue, \\n    Sep as Sep_Revenue, \\n    Oct as Oct_Revenue, \\n    Nov as Nov_Revenue, \\n    Dec as Dec_Revenue\\nFROM  Department\\n**PIVOT**  \\n    (  \\n        **Sum**(revenue) /*what is the value?*/\\n        **FOR** Month /*what is the current column?*/\\n        **IN** (Jan, Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct, Nov, Dec) /*what values in new columns?*/\\n    ) as tb;",
                "codeTag": "Unknown"
            },
            {
                "id": 417904,
                "title": "ms-sql-using-pivot",
                "content": "```\\n\\nSELECT id,\\n    [Jan] as Jan_Revenue, \\n    [Feb] as Feb_Revenue, \\n    [Mar] as Mar_Revenue, \\n    [Apr] as Apr_Revenue, \\n    [May] as May_Revenue, \\n    [Jun] as Jun_Revenue, \\n    [Jul] as Jul_Revenue, \\n    [Aug] as Aug_Revenue, \\n    [Sep] as Sep_Revenue, \\n    [Oct] as Oct_Revenue, \\n    [Nov] as Nov_Revenue, \\n    [Dec] as Dec_Revenue\\nFROM  Department\\nPIVOT  \\n    (  \\n        Sum(revenue)\\n        FOR Month\\n        IN ([Jan], [Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct], [Nov], [Dec])\\n    ) as pivot_table;\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT id,\\n    [Jan] as Jan_Revenue, \\n    [Feb] as Feb_Revenue, \\n    [Mar] as Mar_Revenue, \\n    [Apr] as Apr_Revenue, \\n    [May] as May_Revenue, \\n    [Jun] as Jun_Revenue, \\n    [Jul] as Jul_Revenue, \\n    [Aug] as Aug_Revenue, \\n    [Sep] as Sep_Revenue, \\n    [Oct] as Oct_Revenue, \\n    [Nov] as Nov_Revenue, \\n    [Dec] as Dec_Revenue\\nFROM  Department\\nPIVOT  \\n    (  \\n        Sum(revenue)\\n        FOR Month\\n        IN ([Jan], [Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct], [Nov], [Dec])\\n    ) as pivot_table;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 403501,
                "title": "92-86-faster-mssql-pivot-solution-simple",
                "content": "```\\nSELECT Id\\n\\t\\t\\t, [Jan] Jan_Revenue\\n\\t\\t\\t, [Feb] Feb_Revenue\\n\\t\\t\\t, [Mar] Mar_Revenue\\n\\t\\t\\t, [Apr] Apr_Revenue\\n\\t\\t\\t, [May] May_Revenue\\n\\t\\t\\t, [Jun] Jun_Revenue\\n\\t\\t\\t, [Jul] Jul_Revenue\\n\\t\\t\\t, [Aug] Aug_Revenue\\n\\t\\t\\t, [Sep] Sep_Revenue\\n\\t\\t\\t, [Oct] Oct_Revenue\\n\\t\\t\\t, [Nov] Nov_Revenue\\n\\t\\t\\t, [Dec] Dec_Revenue\\nFROM Department\\nPIVOT\\n(\\n    SUM(Revenue)\\n    FOR Month\\n    IN ([Jan], [Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct], [Nov], [Dec])\\n\\n) AS Pivot_Table\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Id\\n\\t\\t\\t, [Jan] Jan_Revenue\\n\\t\\t\\t, [Feb] Feb_Revenue\\n\\t\\t\\t, [Mar] Mar_Revenue\\n\\t\\t\\t, [Apr] Apr_Revenue\\n\\t\\t\\t, [May] May_Revenue\\n\\t\\t\\t, [Jun] Jun_Revenue\\n\\t\\t\\t, [Jul] Jul_Revenue\\n\\t\\t\\t, [Aug] Aug_Revenue\\n\\t\\t\\t, [Sep] Sep_Revenue\\n\\t\\t\\t, [Oct] Oct_Revenue\\n\\t\\t\\t, [Nov] Nov_Revenue\\n\\t\\t\\t, [Dec] Dec_Revenue\\nFROM Department\\nPIVOT\\n(\\n    SUM(Revenue)\\n    FOR Month\\n    IN ([Jan], [Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct], [Nov], [Dec])\\n\\n) AS Pivot_Table\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 382904,
                "title": "mysql-solution",
                "content": "```\\n# Write your MySQL query statement below\\n\\nselect id, max(case when month = \\'Jan\\'\\n           then revenue\\n           else null \\n           end) as Jan_Revenue,\\n          max(case when month = \\'Feb\\'\\n           then revenue\\n           else null \\n           end )as Feb_Revenue,\\n           max(case when month = \\'Mar\\'\\n           then revenue\\n           else null \\n           end )as Mar_Revenue,\\n           max(case when month = \\'Apr\\'\\n           then revenue\\n           else null \\n           end ) as Apr_Revenue,\\n           max(case when month = \\'May\\'\\n           then revenue\\n           else null \\n           end) as May_Revenue,\\n           max(case when month = \\'Jun\\'\\n           then revenue\\n           else null \\n           end ) as Jun_Revenue,\\n           max(case when month = \\'Jul\\'\\n           then revenue\\n           else null \\n           end) as Jul_Revenue,\\n           max(case when month = \\'Aug\\'\\n           then revenue\\n           else null \\n           end) as Aug_Revenue,\\n           max(case when month = \\'Sep\\'\\n           then revenue\\n           else null \\n           end) as Sep_Revenue,\\n           max(case when month = \\'Oct\\'\\n           then revenue\\n           else null \\n           end) as Oct_Revenue,\\n           max(case when month = \\'Nov\\'\\n           then revenue\\n           else null \\n           end) as Nov_Revenue,\\n           max(case when month = \\'Dec\\'\\n           then revenue\\n           else null \\n           end) as Dec_Revenue\\nfrom department\\ngroup by id\\norder by id \\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect id, max(case when month = \\'Jan\\'\\n           then revenue\\n           else null \\n           end) as Jan_Revenue,\\n          max(case when month = \\'Feb\\'\\n           then revenue\\n           else null \\n           end )as Feb_Revenue,\\n           max(case when month = \\'Mar\\'\\n           then revenue\\n           else null \\n           end )as Mar_Revenue,\\n           max(case when month = \\'Apr\\'\\n           then revenue\\n           else null \\n           end ) as Apr_Revenue,\\n           max(case when month = \\'May\\'\\n           then revenue\\n           else null \\n           end) as May_Revenue,\\n           max(case when month = \\'Jun\\'\\n           then revenue\\n           else null \\n           end ) as Jun_Revenue,\\n           max(case when month = \\'Jul\\'\\n           then revenue\\n           else null \\n           end) as Jul_Revenue,\\n           max(case when month = \\'Aug\\'\\n           then revenue\\n           else null \\n           end) as Aug_Revenue,\\n           max(case when month = \\'Sep\\'\\n           then revenue\\n           else null \\n           end) as Sep_Revenue,\\n           max(case when month = \\'Oct\\'\\n           then revenue\\n           else null \\n           end) as Oct_Revenue,\\n           max(case when month = \\'Nov\\'\\n           then revenue\\n           else null \\n           end) as Nov_Revenue,\\n           max(case when month = \\'Dec\\'\\n           then revenue\\n           else null \\n           end) as Dec_Revenue\\nfrom department\\ngroup by id\\norder by id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376755,
                "title": "ms-sql-server-1330ms",
                "content": "Passes all tests even without ordering:\\n```\\nSELECT id,\\nSUM(CASE WHEN Month = \\'Jan\\' THEN Revenue END) AS Jan_Revenue,\\nSUM(CASE WHEN Month = \\'Feb\\' THEN Revenue END) AS Feb_Revenue,\\nSUM(CASE WHEN Month = \\'Mar\\' THEN Revenue END) AS Mar_Revenue,\\nSUM(CASE WHEN Month = \\'Apr\\' THEN Revenue END) AS Apr_Revenue,\\nSUM(CASE WHEN Month = \\'May\\' THEN Revenue END) AS May_Revenue,\\nSUM(CASE WHEN Month = \\'Jun\\' THEN Revenue END) AS Jun_Revenue,\\nSUM(CASE WHEN Month = \\'Jul\\' THEN Revenue END) AS Jul_Revenue,\\nSUM(CASE WHEN Month = \\'Aug\\' THEN Revenue END) AS Aug_Revenue,\\nSUM(CASE WHEN Month = \\'Sep\\' THEN Revenue END) AS Sep_Revenue,\\nSUM(CASE WHEN Month = \\'Oct\\' THEN Revenue END) AS Oct_Revenue,\\nSUM(CASE WHEN Month = \\'Nov\\' THEN Revenue END) AS Nov_Revenue,\\nSUM(CASE WHEN Month = \\'Dec\\' THEN Revenue END) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT id,\\nSUM(CASE WHEN Month = \\'Jan\\' THEN Revenue END) AS Jan_Revenue,\\nSUM(CASE WHEN Month = \\'Feb\\' THEN Revenue END) AS Feb_Revenue,\\nSUM(CASE WHEN Month = \\'Mar\\' THEN Revenue END) AS Mar_Revenue,\\nSUM(CASE WHEN Month = \\'Apr\\' THEN Revenue END) AS Apr_Revenue,\\nSUM(CASE WHEN Month = \\'May\\' THEN Revenue END) AS May_Revenue,\\nSUM(CASE WHEN Month = \\'Jun\\' THEN Revenue END) AS Jun_Revenue,\\nSUM(CASE WHEN Month = \\'Jul\\' THEN Revenue END) AS Jul_Revenue,\\nSUM(CASE WHEN Month = \\'Aug\\' THEN Revenue END) AS Aug_Revenue,\\nSUM(CASE WHEN Month = \\'Sep\\' THEN Revenue END) AS Sep_Revenue,\\nSUM(CASE WHEN Month = \\'Oct\\' THEN Revenue END) AS Oct_Revenue,\\nSUM(CASE WHEN Month = \\'Nov\\' THEN Revenue END) AS Nov_Revenue,\\nSUM(CASE WHEN Month = \\'Dec\\' THEN Revenue END) AS Dec_Revenue\\nFROM Department\\nGROUP BY id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376376,
                "title": "ms-sql-code-has-to-work-on-mssql-too",
                "content": "I have done this in one step or you can break that to two steps for better understanding \\n# Single step \\n```\\nSELECT id\\n      ,SUM(CASE WHEN month = \\'Jan\\' THEN revenue end) as Jan_Revenue \\n      ,SUM(CASE WHEN month = \\'Feb\\' THEN revenue end) as Feb_Revenue \\n      ,SUM(CASE WHEN month = \\'Mar\\' THEN revenue end) as Mar_Revenue \\n      ,SUM(CASE WHEN month = \\'Apr\\' THEN revenue end) as Apr_Revenue \\n      ,SUM(CASE WHEN month = \\'May\\' THEN revenue end) as May_Revenue \\n      ,SUM(CASE WHEN month = \\'Jun\\' THEN revenue end) as Jun_Revenue \\n      ,SUM(CASE WHEN month = \\'Jul\\' THEN revenue end) as Jul_Revenue \\n      ,SUM(CASE WHEN month = \\'Aug\\' THEN revenue end) as Aug_Revenue \\n      ,SUM(CASE WHEN month = \\'Sep\\' THEN revenue end) as Sep_Revenue \\n      ,SUM(CASE WHEN month = \\'Oct\\' THEN revenue end) as Oct_Revenue \\n      ,SUM(CASE WHEN month = \\'Nov\\' THEN revenue end) as Nov_Revenue \\n      ,SUM(CASE WHEN month = \\'Dec\\' THEN revenue end) as Dec_Revenue \\n  FROM Department \\nGROUP BY id ORDER BY id\\n```\\n\\n# Two steps \\n```\\nSELECT a.id\\n      ,SUM(a.Jan_Revenue) AS Jan_Revenue\\n      ,SUM(a.Feb_Revenue) AS Feb_Revenue\\n      ,SUM(a.Mar_Revenue) AS Mar_Revenue\\n      ,SUM(a.Apr_Revenue) AS Apr_Revenue\\n      ,SUM(a.May_Revenue) AS May_Revenue\\n      ,SUM(a.Jun_Revenue) AS Jun_Revenue\\n      ,SUM(a.Jul_Revenue) AS Jul_Revenue\\n      ,SUM(a.Aug_Revenue) AS Aug_Revenue\\n      ,SUM(a.Sep_Revenue) AS Sep_Revenue\\n      ,SUM(a.Oct_Revenue) AS Oct_Revenue\\n      ,SUM(a.Nov_Revenue) AS Nov_Revenue\\n      ,SUM(a.Dec_Revenue) AS Dec_Revenue\\n    FROM (SELECT id\\n                ,CASE WHEN month = \\'Jan\\' THEN revenue end as Jan_Revenue \\n                ,CASE WHEN month = \\'Feb\\' THEN revenue end as Feb_Revenue \\n                ,CASE WHEN month = \\'Mar\\' THEN revenue end as Mar_Revenue \\n                ,CASE WHEN month = \\'Apr\\' THEN revenue end as Apr_Revenue \\n                ,CASE WHEN month = \\'May\\' THEN revenue end as May_Revenue \\n                ,CASE WHEN month = \\'Jun\\' THEN revenue end as Jun_Revenue \\n                ,CASE WHEN month = \\'Jul\\' THEN revenue end as Jul_Revenue \\n                ,CASE WHEN month = \\'Aug\\' THEN revenue end as Aug_Revenue \\n                ,CASE WHEN month = \\'Sep\\' THEN revenue end as Sep_Revenue \\n                ,CASE WHEN month = \\'Oct\\' THEN revenue end as Oct_Revenue \\n                ,CASE WHEN month = \\'Nov\\' THEN revenue end as Nov_Revenue \\n                ,CASE WHEN month = \\'Dec\\' THEN revenue end as Dec_Revenue \\n            FROM Department )a\\nGROUP BY a.id\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT id\\n      ,SUM(CASE WHEN month = \\'Jan\\' THEN revenue end) as Jan_Revenue \\n      ,SUM(CASE WHEN month = \\'Feb\\' THEN revenue end) as Feb_Revenue \\n      ,SUM(CASE WHEN month = \\'Mar\\' THEN revenue end) as Mar_Revenue \\n      ,SUM(CASE WHEN month = \\'Apr\\' THEN revenue end) as Apr_Revenue \\n      ,SUM(CASE WHEN month = \\'May\\' THEN revenue end) as May_Revenue \\n      ,SUM(CASE WHEN month = \\'Jun\\' THEN revenue end) as Jun_Revenue \\n      ,SUM(CASE WHEN month = \\'Jul\\' THEN revenue end) as Jul_Revenue \\n      ,SUM(CASE WHEN month = \\'Aug\\' THEN revenue end) as Aug_Revenue \\n      ,SUM(CASE WHEN month = \\'Sep\\' THEN revenue end) as Sep_Revenue \\n      ,SUM(CASE WHEN month = \\'Oct\\' THEN revenue end) as Oct_Revenue \\n      ,SUM(CASE WHEN month = \\'Nov\\' THEN revenue end) as Nov_Revenue \\n      ,SUM(CASE WHEN month = \\'Dec\\' THEN revenue end) as Dec_Revenue \\n  FROM Department \\nGROUP BY id ORDER BY id\\n```\n```\\nSELECT a.id\\n      ,SUM(a.Jan_Revenue) AS Jan_Revenue\\n      ,SUM(a.Feb_Revenue) AS Feb_Revenue\\n      ,SUM(a.Mar_Revenue) AS Mar_Revenue\\n      ,SUM(a.Apr_Revenue) AS Apr_Revenue\\n      ,SUM(a.May_Revenue) AS May_Revenue\\n      ,SUM(a.Jun_Revenue) AS Jun_Revenue\\n      ,SUM(a.Jul_Revenue) AS Jul_Revenue\\n      ,SUM(a.Aug_Revenue) AS Aug_Revenue\\n      ,SUM(a.Sep_Revenue) AS Sep_Revenue\\n      ,SUM(a.Oct_Revenue) AS Oct_Revenue\\n      ,SUM(a.Nov_Revenue) AS Nov_Revenue\\n      ,SUM(a.Dec_Revenue) AS Dec_Revenue\\n    FROM (SELECT id\\n                ,CASE WHEN month = \\'Jan\\' THEN revenue end as Jan_Revenue \\n                ,CASE WHEN month = \\'Feb\\' THEN revenue end as Feb_Revenue \\n                ,CASE WHEN month = \\'Mar\\' THEN revenue end as Mar_Revenue \\n                ,CASE WHEN month = \\'Apr\\' THEN revenue end as Apr_Revenue \\n                ,CASE WHEN month = \\'May\\' THEN revenue end as May_Revenue \\n                ,CASE WHEN month = \\'Jun\\' THEN revenue end as Jun_Revenue \\n                ,CASE WHEN month = \\'Jul\\' THEN revenue end as Jul_Revenue \\n                ,CASE WHEN month = \\'Aug\\' THEN revenue end as Aug_Revenue \\n                ,CASE WHEN month = \\'Sep\\' THEN revenue end as Sep_Revenue \\n                ,CASE WHEN month = \\'Oct\\' THEN revenue end as Oct_Revenue \\n                ,CASE WHEN month = \\'Nov\\' THEN revenue end as Nov_Revenue \\n                ,CASE WHEN month = \\'Dec\\' THEN revenue end as Dec_Revenue \\n            FROM Department )a\\nGROUP BY a.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091026,
                "title": "mysql-case-when-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect id, \\n       sum(case when month = \\'Jan\\' then revenue else null end ) as Jan_Revenue,\\n       sum(case when month = \"Feb\" then revenue else NULL end) as Feb_Revenue,\\nsum(case when month = \"Mar\" then revenue else NULL end) as Mar_Revenue,\\nsum(case when month = \"Apr\" then revenue else NULL end) as Apr_Revenue,\\nsum(case when month = \"May\" then revenue else NULL end) as May_Revenue,\\nsum(case when month = \"Jun\" then revenue else NULL end) as Jun_Revenue,\\nsum(case when month = \"Jul\" then revenue else NULL end) as Jul_Revenue,\\nsum(case when month = \"Aug\" then revenue else NULL end) as Aug_Revenue,\\nsum(case when month = \"Sep\" then revenue else NULL end) as Sep_Revenue,\\nsum(case when month = \"Oct\" then revenue else NULL end) as Oct_Revenue,\\nsum(case when month = \"Nov\" then revenue else NULL end) as Nov_Revenue,\\nsum(case when month = \"Dec\" then revenue else NULL end) as Dec_Revenue\\nfrom department\\ngroup by id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect id, \\n       sum(case when month = \\'Jan\\' then revenue else null end ) as Jan_Revenue,\\n       sum(case when month = \"Feb\" then revenue else NULL end) as Feb_Revenue,\\nsum(case when month = \"Mar\" then revenue else NULL end) as Mar_Revenue,\\nsum(case when month = \"Apr\" then revenue else NULL end) as Apr_Revenue,\\nsum(case when month = \"May\" then revenue else NULL end) as May_Revenue,\\nsum(case when month = \"Jun\" then revenue else NULL end) as Jun_Revenue,\\nsum(case when month = \"Jul\" then revenue else NULL end) as Jul_Revenue,\\nsum(case when month = \"Aug\" then revenue else NULL end) as Aug_Revenue,\\nsum(case when month = \"Sep\" then revenue else NULL end) as Sep_Revenue,\\nsum(case when month = \"Oct\" then revenue else NULL end) as Oct_Revenue,\\nsum(case when month = \"Nov\" then revenue else NULL end) as Nov_Revenue,\\nsum(case when month = \"Dec\" then revenue else NULL end) as Dec_Revenue\\nfrom department\\ngroup by id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079169,
                "title": "pandas-succint-code-callendar-pivot-and-concat",
                "content": "# Intuition\\nThis question is perfect example of getting familiar with pivoting:\\nWhat is pivoting? It\\'s no more, no less, than turning your table by 90$^{\\\\circ}$ by one of columns, resulting in new table that has columns that were previously rows of this chosen column.\\nRead about it here: [pandas.DataFrame.pivot](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pivot.html) or [pandas.pivot_table](https://pandas.pydata.org/docs/reference/api/pandas.pivot_table.html).\\nHere we gonna use simple pivot.\\n\\n# Approach\\nFirst we have to pivot our original table. It\\'s as simple as:\\n```\\ndepartment.pivot(index=\\'id\\',columns=\\'month\\',values=\\'revenue\\')\\n```\\nWe specify:\\n1. index = our new rows\\n2. columns = our column to pivot on - it\\'s values will now be columns, so in this example: `Jan`,`Feb`,`Mar`.... etc.\\n3. values = new values of our table.\\n\\nSince our task is to have `Jan_Revenue`, `Feb_Revenue`.. etc as our column name, we can use `.add_suffix(\\'_Revenue\\')` on table - it does exactly what is says : adding suffix to columns. Finally we want to reset index - since we need it as one of our columns - its important that we resetting this index after adding suffix, so it\\'s stays the same as it was originally.\\n\\n\\nSecond part of our task is to create some frame for our pivoted table:\\n1. pivoted tables tend to have columns in alphabetical order, here we want month order.\\n2. pivoted table dont have to have all months we need\\n\\nFor Monhts we can use callendar module and `callendar.month_abbr` atribute, to get 3 letter representation of month names.\\n\\n```\\n| id | Jan_Revenue | Feb_Revenue | Mar_Revenue | Apr_Revenue | May_Revenue | Jun_Revenue | Jul_Revenue | Aug_Revenue | Sep_Revenue | Oct_Revenue | Nov_Revenue | Dec_Revenue |\\n| -- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |\\n```\\nFinally just use `pd.concat` to put one table on top of other. The order of column will be kept from first table, so thats were we use our empty DataFrame with all months.\\n\\n# Code\\n```\\nimport pandas as pd\\nimport calendar\\ndef reformat_table(department: pd.DataFrame) -> pd.DataFrame:\\n    columns =  pd.DataFrame(columns = [\\'id\\'] + [calendar.month_abbr[i] + \\'_Revenue\\' for i in range(1,13)])\\n    department = department.pivot(index=\\'id\\',columns=\\'month\\',values=\\'revenue\\').add_suffix(\\'_Revenue\\').reset_index()\\n    return pd.concat([columns, department])\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\ndepartment.pivot(index=\\'id\\',columns=\\'month\\',values=\\'revenue\\')\\n```\n```\\n| id | Jan_Revenue | Feb_Revenue | Mar_Revenue | Apr_Revenue | May_Revenue | Jun_Revenue | Jul_Revenue | Aug_Revenue | Sep_Revenue | Oct_Revenue | Nov_Revenue | Dec_Revenue |\\n| -- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |\\n```\n```\\nimport pandas as pd\\nimport calendar\\ndef reformat_table(department: pd.DataFrame) -> pd.DataFrame:\\n    columns =  pd.DataFrame(columns = [\\'id\\'] + [calendar.month_abbr[i] + \\'_Revenue\\' for i in range(1,13)])\\n    department = department.pivot(index=\\'id\\',columns=\\'month\\',values=\\'revenue\\').add_suffix(\\'_Revenue\\').reset_index()\\n    return pd.concat([columns, department])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4070238,
                "title": "solution-pandas",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef reformat_table(department: pd.DataFrame) -> pd.DataFrame:\\n    df = department.pivot(index=\\'id\\', columns=\\'month\\', values=\\'revenue\\').add_suffix(\\'_Revenue\\').reset_index()\\n\\n    new_columns = [\\'id\\'] + [f\"{month}_Revenue\" for month in [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]]\\n    df = df.reindex(columns=new_columns)\\n\\n    return df\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef reformat_table(department: pd.DataFrame) -> pd.DataFrame:\\n    df = department.pivot(index=\\'id\\', columns=\\'month\\', values=\\'revenue\\').add_suffix(\\'_Revenue\\').reset_index()\\n\\n    new_columns = [\\'id\\'] + [f\"{month}_Revenue\" for month in [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]]\\n    df = df.reindex(columns=new_columns)\\n\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4063750,
                "title": "pandas-with-explanation",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef reformat_table(department: pd.DataFrame) -> pd.DataFrame:\\n    # define columns\\n    cols = [\\'Jan_Revenue\\', \\'Feb_Revenue\\', \\'Mar_Revenue\\', \\'Apr_Revenue\\', \\'May_Revenue\\', \\'Jun_Revenue\\', \\'Jul_Revenue\\', \\'Aug_Revenue\\', \\'Sep_Revenue\\', \\'Oct_Revenue\\', \\'Nov_Revenue\\', \\'Dec_Revenue\\']\\n    # pivot table as needed\\n    department = department.sort_values(by=\\'id\\').pivot(index=\\'id\\', columns=\\'month\\', values=\\'revenue\\').add_suffix(\\'_Revenue\\').reset_index()\\n    # we have a lack of months, so we need to add special columns\\n    for col in cols:\\n        if col not in department:\\n            department[col] = np.nan\\n    return department[[\\'id\\'] + cols]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef reformat_table(department: pd.DataFrame) -> pd.DataFrame:\\n    # define columns\\n    cols = [\\'Jan_Revenue\\', \\'Feb_Revenue\\', \\'Mar_Revenue\\', \\'Apr_Revenue\\', \\'May_Revenue\\', \\'Jun_Revenue\\', \\'Jul_Revenue\\', \\'Aug_Revenue\\', \\'Sep_Revenue\\', \\'Oct_Revenue\\', \\'Nov_Revenue\\', \\'Dec_Revenue\\']\\n    # pivot table as needed\\n    department = department.sort_values(by=\\'id\\').pivot(index=\\'id\\', columns=\\'month\\', values=\\'revenue\\').add_suffix(\\'_Revenue\\').reset_index()\\n    # we have a lack of months, so we need to add special columns\\n    for col in cols:\\n        if col not in department:\\n            department[col] = np.nan\\n    return department[[\\'id\\'] + cols]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4048050,
                "title": "easy-solution-beginner-friendly",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT *\\nFROM   (\\n  SELECT ID,\\n        revenue,\\n         month\\n  FROM   Department \\n)\\nPIVOT (\\n  SUM( revenue ) FOR month IN (\\n     \\'Jan\\' AS Jan_Revenue,\\n     \\'Feb\\' AS Feb_Revenue,\\n     \\'Mar\\' AS Mar_Revenue,\\n     \\'Apr\\' AS Apr_Revenue,\\n     \\'May\\' AS May_Revenue,\\n     \\'Jun\\' AS Jun_Revenue,\\n     \\'Jul\\' AS Jul_Revenue,\\n     \\'Aug\\' AS Aug_Revenue,\\n     \\'Sep\\' AS Sep_Revenue,\\n    \\'Oct\\' AS Oct_Revenue,\\n    \\'Nov\\' AS Nov_Revenue,\\n    \\'Dec\\' AS Dec_Revenue\\n  )\\n)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT *\\nFROM   (\\n  SELECT ID,\\n        revenue,\\n         month\\n  FROM   Department \\n)\\nPIVOT (\\n  SUM( revenue ) FOR month IN (\\n     \\'Jan\\' AS Jan_Revenue,\\n     \\'Feb\\' AS Feb_Revenue,\\n     \\'Mar\\' AS Mar_Revenue,\\n     \\'Apr\\' AS Apr_Revenue,\\n     \\'May\\' AS May_Revenue,\\n     \\'Jun\\' AS Jun_Revenue,\\n     \\'Jul\\' AS Jul_Revenue,\\n     \\'Aug\\' AS Aug_Revenue,\\n     \\'Sep\\' AS Sep_Revenue,\\n    \\'Oct\\' AS Oct_Revenue,\\n    \\'Nov\\' AS Nov_Revenue,\\n    \\'Dec\\' AS Dec_Revenue\\n  )\\n)\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1567549,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1576533,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1765224,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1567498,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1575929,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1575202,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1570226,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1576807,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1569950,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1574572,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1567549,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1576533,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1765224,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1567498,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1575929,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1575202,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1570226,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1576807,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1569950,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            },
            {
                "id": 1574572,
                "content": [
                    {
                        "username": "frederikmuller",
                        "content": "Hey everyone,\\n\\nI started a series on YouTube where I give free video explanations to all LeetCode SQL problems. Here\\'s the video for this problem:\\n[https://youtu.be/olcS-QwoGHg](https://youtu.be/olcS-QwoGHg)\\n\\nI cleared technical interviews at Spotify, Facebook, Apple, PlayStation and others. I\\u2019m also leading technical interviews for my own company and learned a lot from being on the other side of an interview. Therefore I focus on teaching both the correct way of finding and explaining a solution to a technical problem in my tutorials. I\\u2019m planning to go through all database problems on LeetCode so make sure to subscribe if you want assistance on your journey to mastering the SQL interview."
                    },
                    {
                        "username": "xchen0311",
                        "content": "thank you, I didn\\'t understand the reason why we needed sum but now I get it"
                    },
                    {
                        "username": "allenrun",
                        "content": "1. meaninglessly repeating the simplest syntax\\n2. conflicted definition of the revenue for Apr to Dec\\n3. confusing wrong submission when it passed the code test and it\\'s absolutely right\\n\\nWhat a wast of time"
                    },
                    {
                        "username": "hero4future",
                        "content": "yeah im really not going to do this question"
                    },
                    {
                        "username": "nupursinghbaghel",
                        "content": "\\'\\'\\'\\nselect id,[Jan] as \"Jan_Revenue\" ,[Feb] AS \"Feb_Revenue\",[Mar]  AS \"Mar_Revenue\",[Apr]  AS \"Apr_Revenue\",[May]  AS \"May_Revenue\",[Jun]  AS \"Jun_Revenue\",[Jul] AS \"Jul_Revenue\",[Aug] AS \"Aug_Revenue\",[Sep] AS \"Sep_Revenue\",[Oct] AS \"Oct_Revenue\",[Nov] AS \"Nov_Revenue\",[Dec] AS \"Dec_Revenue\"\\nfrom\\n(select * from Department) dep \\nPIVOT \\n(sum(revenue)  for month IN\\n ([Jan],[Feb],[Mar],[Apr],[May],[Jun],[Jul],[Aug],[Sep],[Oct],[Nov],[Dec])\\n) as piv\\n \\n \\'\\'\\'"
                    },
                    {
                        "username": "ldn005402",
                        "content": "Hi guys, I saw most of you using sum case when, but I wonder why we need lots of case when rather than a single case when? \\n\\nLike:\\nCASE\\n     WHEN month=\\'Jan\\' THEN sum(revenue) AS Jan_Revenue\\n     WHEN....\\n\\t ....\\n\\t ELSE\\nEND"
                    },
                    {
                        "username": "HelloEcho",
                        "content": "Third day in SQL, I\\'m just wondering why none of the solutions contain any form of loops.\\ne.g. in simple py, we can always dim \"i\" so that we don\\'t have to be typing Jan, Feb...\\nMight be one of my silly thoughts but this really bothers me so plz discuss \\nHuge THX\\uFF01"
                    },
                    {
                        "username": "BiteTheBits",
                        "content": "loops only work inside a procedure, function or a trigger"
                    },
                    {
                        "username": "vyneeeth",
                        "content": "Were you able to solve this question in your third day itself!? Please share the source of where you were learning from..."
                    },
                    {
                        "username": "user3715ge",
                        "content": "a very forced SQL question really. Iteration is the domain of the real programming languages."
                    },
                    {
                        "username": "sankitgupta",
                        "content": "Runtime 452ms\\n\\nselect distinct d.id, d1.revenue as Jan_Revenue, d2.revenue as Feb_Revenue, d3.revenue as Mar_Revenue,\\nd4.revenue as Apr_Revenue, d5.revenue as May_Revenue, d6.revenue as Jun_Revenue, d7.revenue as Jul_Revenue, d8.revenue as Aug_Revenue, d9.revenue as Sep_Revenue, d10.revenue as Oct_Revenue,\\nd11.revenue as Nov_Revenue, d12.revenue as Dec_Revenue\\nfrom department d\\nleft join department d1 on d.id=d1.id and d1.month =\"Jan\"\\nleft join department d2 on d.id=d2.id and d2.month =\"Feb\"\\nleft join department d3 on d.id=d3.id and d3.month =\"Mar\"\\nleft join department d4 on d.id=d4.id and d4.month =\"Apr\"\\nleft join department d5 on d.id=d5.id and d5.month =\"May\"\\nleft join department d6 on d.id=d6.id  and d6.month =\"Jun\"\\nleft join department d7 on d.id=d7.id and d7.month =\"Jul\"\\nleft join department d8 on d.id=d8.id and d8.month =\"Aug\"\\nleft join department d9 on d.id=d9.id and d9.month =\"Sep\"\\nleft join department d10 on d.id=d10.id  and d10.month =\"Oct\"\\nleft join department d11 on d.id=d11.id and d11.month =\"Nov\"\\nleft join department d12 on d.id=d12.id and d12.month =\"Dec\""
                    },
                    {
                        "username": "Mubin12",
                        "content": "\\nSELECT id,\\nSUM(IF(month=\\'Jan\\', revenue, NULL)) AS Jan_Revenue,\\nSUM(IF(month=\\'Feb\\', revenue, NULL)) AS Feb_Revenue,\\nSUM(IF(month=\\'Mar\\', revenue, NULL)) AS Mar_Revenue,\\nSUM(IF(month=\\'Apr\\', revenue, NULL)) AS Apr_Revenue,\\nSUM(IF(month=\\'May\\', revenue, NULL)) AS May_Revenue,\\nSUM(IF(month=\\'Jun\\', revenue, NULL)) AS Jun_Revenue,\\nSUM(IF(month=\\'Jul\\', revenue, NULL)) AS Jul_Revenue,\\nSUM(IF(month=\\'Aug\\', revenue, NULL)) AS Aug_Revenue,\\nSUM(IF(month=\\'Sep\\', revenue, NULL)) AS Sep_Revenue,\\nSUM(IF(month=\\'Oct\\', revenue, NULL)) AS Oct_Revenue,\\nSUM(IF(month=\\'Nov\\', revenue, NULL)) AS Nov_Revenue,\\nSUM(IF(month=\\'Dec\\', revenue, NULL)) AS Dec_Revenue\\nFROM Department\\nGroup BY id;"
                    },
                    {
                        "username": "shounak192",
                        "content": "why do we need to do SUM?"
                    },
                    {
                        "username": "go7going",
                        "content": "\\n\\'\\'\\'\\nselect id,\\nsum(if(month=\\'Jan\\',revenue,null)) as Jan_Revenue,\\nsum(if(month=\\'Feb\\',revenue,null)) as Feb_Revenue,\\nsum(if(month=\\'Mar\\',revenue,null)) as Mar_Revenue,\\nsum(if(month=\\'Apr\\',revenue,null)) as Apr_Revenue,\\nsum(if(month=\\'May\\',revenue,null)) as May_Revenue,\\nsum(if(month=\\'Jun\\',revenue,null)) as Jun_Revenue,\\nsum(if(month=\\'Jul\\',revenue,null)) as Jul_Revenue,\\nsum(if(month=\\'Aug\\',revenue,null)) as Aug_Revenue,\\nsum(if(month=\\'Sep\\',revenue,null)) as Sep_Revenue,\\nsum(if(month=\\'Oct\\',revenue,null)) as Oct_Revenue,\\nsum(if(month=\\'Nov\\',revenue,null)) as Nov_Revenue,\\nsum(if(month=\\'Dec\\',revenue,null)) as Dec_Revenue\\nfrom Department\\ngroup by id\\n\\'\\'\\'"
                    },
                    {
                        "username": "satyaloud",
                        "content": "\\n\\n/* Write your PL/SQL query statement below */\\n\\nselect \\nid, \\nsum(case when month = \\'Jan\\' then revenue end) as Jan_Revenue,\\nsum(case when month = \\'Feb\\' then revenue end) as Feb_Revenue,\\nsum(case when month = \\'Mar\\' then revenue end) as Mar_Revenue,\\nsum(case when month = \\'Apr\\' then revenue end) as Apr_Revenue,\\nsum(case when month = \\'May\\' then revenue end) as May_Revenue,\\nsum(case when month = \\'Jun\\' then revenue end) as Jun_Revenue,\\nsum(case when month = \\'Jul\\' then revenue end) as Jul_Revenue,\\nsum(case when month = \\'Aug\\' then revenue end) as Aug_Revenue,\\nsum(case when month = \\'Sep\\' then revenue end) as Sep_Revenue,\\nsum(case when month = \\'Oct\\' then revenue end) as Oct_Revenue,\\nsum(case when month = \\'Nov\\' then revenue end) as Nov_Revenue,\\nsum(case when month = \\'Dec\\' then revenue end) as Dec_Revenue\\nfrom Department\\ngroup by id"
                    }
                ]
            }
        ]
    }
]