[
    {
        "title": "Encrypt and Decrypt Strings",
        "question_content": "You are given a character array keys containing unique characters and a string array values containing strings of length 2. You are also given another string array dictionary that contains all permitted original strings after decryption. You should implement a data structure that can encrypt or decrypt a 0-indexed string.\nA string is encrypted with the following process:\n\n\tFor each character c in the string, we find the index i satisfying keys[i] == c in keys.\n\tReplace c with values[i] in the string.\n\nNote that in case a character of the string is not present in keys, the encryption process cannot be carried out, and an empty string \"\" is returned.\nA string is decrypted with the following process:\n\n\tFor each substring s of length 2 occurring at an even index in the string, we find an i such that values[i] == s. If there are multiple valid i, we choose any one of them. This means a string could have multiple possible strings it can decrypt to.\n\tReplace s with keys[i] in the string.\n\nImplement the Encrypter class:\n\n\tEncrypter(char[] keys, String[] values, String[] dictionary) Initializes the Encrypter class with keys, values, and dictionary.\n\tString encrypt(String word1) Encrypts word1 with the encryption process described above and returns the encrypted string.\n\tint decrypt(String word2) Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\n\n&nbsp;\nExample 1:\n\nInput\n[\"Encrypter\", \"encrypt\", \"decrypt\"]\n[[['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]], [\"abcd\"], [\"eizfeiam\"]]\nOutput\n[null, \"eizfeiam\", 2]\nExplanation\nEncrypter encrypter = new Encrypter([['a', 'b', 'c', 'd'], [\"ei\", \"zf\", \"ei\", \"am\"], [\"abcd\", \"acbd\", \"adbc\", \"badc\", \"dacb\", \"cadb\", \"cbda\", \"abad\"]);\nencrypter.encrypt(\"abcd\"); // return \"eizfeiam\". \n&nbsp;                          // 'a' maps to \"ei\", 'b' maps to \"zf\", 'c' maps to \"ei\", and 'd' maps to \"am\".\nencrypter.decrypt(\"eizfeiam\"); // return 2. \n                              // \"ei\" can map to 'a' or 'c', \"zf\" maps to 'b', and \"am\" maps to 'd'. \n                              // Thus, the possible strings after decryption are \"abad\", \"cbad\", \"abcd\", and \"cbcd\". \n                              // 2 of those strings, \"abad\" and \"abcd\", appear in dictionary, so the answer is 2.\n\n&nbsp;\nConstraints:\n\n\t1 <= keys.length == values.length <= 26\n\tvalues[i].length == 2\n\t1 <= dictionary.length <= 100\n\t1 <= dictionary[i].length <= 100\n\tAll keys[i] and dictionary[i] are unique.\n\t1 <= word1.length <= 2000\n\t1 <= word2.length <= 200\n\tAll word1[i] appear in keys.\n\tword2.length is even.\n\tkeys, values[i], dictionary[i], word1, and word2 only contain lowercase English letters.\n\tAt most 200 calls will be made to encrypt and decrypt in total.",
        "solutions": [
            {
                "id": 1909025,
                "title": "java-c-python-two-hashmaps-with-explanation",
                "content": "# **Explanation**\\nThe hashmap `enc` help binding each paire of `keys[i]` and `values[i]`,\\nso that we can encrypt a char to the string in `O(1)`\\n\\n`count` counts the frequency of words in `dictionary` after `encrypt`,\\nthen we can used in `decrypt` in `O(1)`.\\n<br>\\n\\n# **Complexity**\\n`Encrypter`  Time `O(n)`      Space `O(n)`\\n`encrypt`    Time `O(word1)`  Space `O(word1)`\\n`decrypt`    Time `O(1)`      Space `O(1)`\\n<br>\\n\\n# **Note**\\nNot all word can be \"encrypt\", \\nFor character `c`, if we can\\'t find the index `i` satisfying `keys[i] == c` in keys.\\nThe behavior are **NOT** clearly defined.\\n\\nIn my opinion we should do nothing but keep the original character, \\n(the standard solution of OJ doesn\\'t work as I suggest)\\n\\nThese kind of test cases are not present in the original test cases set,\\nbut recedntly blindly added to the test cases.\\n\\nThe descrption of probelm should be fixed, not blindly add an appropriat test cases.\\n\\nIt\\'s like, a bug is reported and not guarded by tests, \\nthen LC adds a test but not fix anything at all.\\n\\n\\n**Java**\\n```java\\n    Map<Character, String> enc;\\n    Map<String, Integer> count;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        enc = new HashMap<>();\\n        for (int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        count = new HashMap<>();\\n        for (String w : dictionary) {\\n            String e = encrypt(w);\\n            count.put(e, count.getOrDefault(e, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < word1.length(); ++i)\\n            res.append(enc.getOrDefault(word1.charAt(i), \"#\"));\\n        return res.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return count.getOrDefault(word2, 0);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n```\\n\\n**Python**\\n3-lines Python.\\n`decrypt` method is not missing, `defined` in `init`\\nI remoded unnecessay code from default template.\\n```py\\nclass Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n        self.enc = {k: v for k,v in zip(keys, values)}\\n        self.decrypt = collections.Counter(self.encrypt(w) for w in dictionary).__getitem__\\n\\n    def encrypt(self, word1):\\n        return \\'\\'.join(self.enc.get(c, \\'#\\') for c in word1)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    Map<Character, String> enc;\\n    Map<String, Integer> count;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        enc = new HashMap<>();\\n        for (int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        count = new HashMap<>();\\n        for (String w : dictionary) {\\n            String e = encrypt(w);\\n            count.put(e, count.getOrDefault(e, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < word1.length(); ++i)\\n            res.append(enc.getOrDefault(word1.charAt(i), \"#\"));\\n        return res.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return count.getOrDefault(word2, 0);\\n    }\\n```\n```cpp\\n    unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n```\n```py\\nclass Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n        self.enc = {k: v for k,v in zip(keys, values)}\\n        self.decrypt = collections.Counter(self.encrypt(w) for w in dictionary).__getitem__\\n\\n    def encrypt(self, word1):\\n        return \\'\\'.join(self.enc.get(c, \\'#\\') for c in word1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908722,
                "title": "easy-understanding-c-code-with-comments-without-tries",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            dict[encrypt(d[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string ans = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()) return \"\";\\n            ans += m[s[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\\n**Upvote if it helps!\\uD83D\\uDE4C**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            dict[encrypt(d[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string ans = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()) return \"\";\\n            ans += m[s[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908714,
                "title": "c-simple-solution-w-explanation-hashmap-trie-dfs-hashmap-preprocess",
                "content": "\\n\\u2714\\uFE0F ***Solution - I  (Hashmap + Trie)***\\n\\nWe are given an array of characters `K`, an array of strings `V` and another array of strings `D`.\\nA string `W` is encrypted by replacing each character `c`, found at `K[i]` with `V[i]` (only single possible index `i`).\\nA string `W` is decrypted by replacing every 2-character substring `s`, found at `V[i]` with `K[i]` for all possible `i`. This decrypted value must be present in `D`.\\n\\n**Encryption:**\\n* The encryption process is straight-forward wherein for every character `c` in given word `W`, we need to find  `c`\\'s index `i` in `K` & replace it with corresponding string in `V`, i.e `V[i]`. \\n* For this, we can use a hashmap `K_V` to keep mapping between each key and value.\\n\\n**Decryption:**\\n* For decryption, there can be multiple choices for replacement of a substring of length 2 and we need to consider each of them to find count of possible decryptions. \\n* But for efficient decryption process, we need to eliminate a choice as soon as we know that it wont be found in `D`. \\n* For this, we can maintain Trie consisting of all strings from `D` & we stop further exploration as soon as we find that current choice wont lead to a string present in the trie.\\n* We also keep a hashmap `V_Ks` to map a value in `V` to all possible keys in `K`.\\n\\n**C++**\\n```cpp\\nclass Trie {\\npublic:    \\n    Trie* chars[26]{};\\n    bool endsHere = false;\\n    void insert(string& s) {\\n        auto cur = this;\\n        for(auto c : s) \\n            cur = cur -> chars[c-\\'a\\'] ? cur -> chars[c-\\'a\\'] : cur -> chars[c-\\'a\\'] = new Trie();\\n        cur -> endsHere = true;\\n    }\\n};\\n\\nclass Encrypter {\\n    Trie* t = new Trie();                      // Trie of dictionary strings\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, vector<char>> V_Ks;  // value : [key]\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) \\n            K_V[K[i]] = V[i], \\n            V_Ks[V[i]].push_back(K[i]);\\n        for(auto& d : D) t -> insert(d);\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return dfs(W, t);\\n    }\\n    int dfs(string& W, Trie* T, int i = 0) {\\n        if(i == size(W)) return T -> endsHere;\\n        int ans = 0;\\n        for(string s = W.substr(i, 2); auto c : V_Ks[s]) \\n            if(T -> chars[c-\\'a\\']) \\n                ans += dfs(W, T -> chars[c-\\'a\\'], i+2);\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - II  (Hashmap + Pre-process)***\\n\\nWe can also preprocess and keep all possible encrypted strings that can be obtained by encrypting strings in `D`. Then we can directly return the count of strings which could lead to a given encrypted string `W`.\\n\\n**C++**\\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, int> mp;             // encrypted string : count\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) K_V[K[i]] = V[i];\\n        for(auto& d : D) mp[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return mp[W];\\n    }\\n};\\n```\\n\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Trie {\\npublic:    \\n    Trie* chars[26]{};\\n    bool endsHere = false;\\n    void insert(string& s) {\\n        auto cur = this;\\n        for(auto c : s) \\n            cur = cur -> chars[c-\\'a\\'] ? cur -> chars[c-\\'a\\'] : cur -> chars[c-\\'a\\'] = new Trie();\\n        cur -> endsHere = true;\\n    }\\n};\\n\\nclass Encrypter {\\n    Trie* t = new Trie();                      // Trie of dictionary strings\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, vector<char>> V_Ks;  // value : [key]\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) \\n            K_V[K[i]] = V[i], \\n            V_Ks[V[i]].push_back(K[i]);\\n        for(auto& d : D) t -> insert(d);\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return dfs(W, t);\\n    }\\n    int dfs(string& W, Trie* T, int i = 0) {\\n        if(i == size(W)) return T -> endsHere;\\n        int ans = 0;\\n        for(string s = W.substr(i, 2); auto c : V_Ks[s]) \\n            if(T -> chars[c-\\'a\\']) \\n                ans += dfs(W, T -> chars[c-\\'a\\'], i+2);\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> K_V;           // key : value\\n    unordered_map<string, int> mp;             // encrypted string : count\\npublic:\\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for(int i = 0; i < size(K); i++) K_V[K[i]] = V[i];\\n        for(auto& d : D) mp[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string W) {\\n        string ans = \"\";\\n        for(auto c : W) ans += K_V[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string W) {\\n        return mp[W];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908702,
                "title": "encrypted-dictionary-vs-trie",
                "content": "#### Approach 1: Encrypted Dictionary\\nI did not see this, but it makes sense. If we encrypt all words in the dictionary, some of those words may have the same encrypted representation.\\n\\nWe could store the number of dictionary words for each encrypted representation in hash map `m`, and return this count in the `decrypt` function.\\n\\n**C++**\\n```cpp\\nclass Encrypter {\\n    unordered_map<char, string> ch2s;    \\n    unordered_map<string, int> m;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            ch2s[keys[i]] = values[i];\\n        for (auto &s : dictionary)\\n            ++m[encrypt(s)];\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return m[word2]; }\\n};\\n```\\n\\n#### Approach 2: Trie\\nWe need to pay attention to the `decrypt` function. If we check for a valid word in the end, we will get TLE.\\n    \\nTherefore, we need to use Trie so we can prune invalid words as we go.\\n    \\n**C++**\\n```cpp\\nint val2int(char a, char b) { return (a - \\'a\\') * 26 + b - \\'a\\'; }\\nstruct trie {\\n    trie* ch[26] = {};\\n    bool end = false;\\n    void insert(string &w, int i = 0) {\\n        if (i == w.size())\\n            end = true;\\n        else {\\n            auto *p = ch[w[i] - \\'a\\'];\\n            if (p == nullptr)\\n                p = ch[w[i] - \\'a\\'] = new trie();\\n            p->insert(w, i + 1);\\n        }\\n    }\\n    int count(string &w, unordered_map<int, vector<char>> &s2ch, int i = 0) {\\n        if (i == w.size())\\n            return end;\\n        int res = 0, v = val2int(w[i], w[i + 1]);\\n        for (auto k : s2ch[v])\\n            if (ch[k - \\'a\\'] != nullptr)\\n                res += ch[k - \\'a\\']->count(w, s2ch, i + 2);\\n        return res;\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<int, vector<char>> s2ch;\\n    unordered_map<char, string> ch2s;    \\n    trie root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            s2ch[val2int(values[i][0], values[i][1])].push_back(keys[i]);\\n            ch2s[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary)\\n            root.insert(s);\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return root.count(word2, s2ch); }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Encrypter {\\n    unordered_map<char, string> ch2s;    \\n    unordered_map<string, int> m;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            ch2s[keys[i]] = values[i];\\n        for (auto &s : dictionary)\\n            ++m[encrypt(s)];\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return m[word2]; }\\n};\\n```\n```cpp\\nint val2int(char a, char b) { return (a - \\'a\\') * 26 + b - \\'a\\'; }\\nstruct trie {\\n    trie* ch[26] = {};\\n    bool end = false;\\n    void insert(string &w, int i = 0) {\\n        if (i == w.size())\\n            end = true;\\n        else {\\n            auto *p = ch[w[i] - \\'a\\'];\\n            if (p == nullptr)\\n                p = ch[w[i] - \\'a\\'] = new trie();\\n            p->insert(w, i + 1);\\n        }\\n    }\\n    int count(string &w, unordered_map<int, vector<char>> &s2ch, int i = 0) {\\n        if (i == w.size())\\n            return end;\\n        int res = 0, v = val2int(w[i], w[i + 1]);\\n        for (auto k : s2ch[v])\\n            if (ch[k - \\'a\\'] != nullptr)\\n                res += ch[k - \\'a\\']->count(w, s2ch, i + 2);\\n        return res;\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<int, vector<char>> s2ch;\\n    unordered_map<char, string> ch2s;    \\n    trie root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            s2ch[val2int(values[i][0], values[i][1])].push_back(keys[i]);\\n            ch2s[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary)\\n            root.insert(s);\\n    }\\n    string encrypt(string word1) {\\n        string res;\\n        for (char ch : word1)\\n            res += ch2s[ch];\\n        return res;\\n    }\\n    int decrypt(string word2) { return root.count(word2, s2ch); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908833,
                "title": "python-hashmap-counter-solution-with-detailed-explanations-very-clean-concise",
                "content": "This is the first time I get AK over the past few months. I would like to share my solution with the LC community.\\n\\n**Intuition**\\nThe given constraints are not large, we can pre-compute all necessary quantities only once.\\n\\n\\n**Explanation**\\nWe can pre-compute two hashmaps as follows:\\n\\n(1) The first hashmap `self.hashmap` is a encryption map - we map each key with their encrypted values, which is straightforward.\\n(2) The second hashmap `self.dictmap` is a `Counter` - we encrypt each word in the given `dictionary` and use the encrypted string as the key and increase the counter by 1. As such, we have solved the duplication problem of the `decrypt()` method.\\n\\n**Complexity**\\nTime in `__init__()`: `O(sum(dictionary[i].length))`, which gets amortized over later function calls\\nSpace in `__init__()`: `O(dictionary.length)`\\nTime in `encrypt()`: `O(word1.length)`\\nSpace in `encrypt()`: `O(1)` (if not counting the `output` string)\\nTime in `decrypt()`: `O(1)`\\nSpace in `decrypt()`: `O(1)`\\n\\n\\nBelow is my in-contest solution. Please upvote if you find this solution helpful. Thanks!\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\\n\\n**Follow up** (for self-learning purpose): The `encrypt()` method can be written as follows to handle more general test cases (given in the Comments section).\\n```\\ndef encrypt(self, word1: str) -> str:\\n    output = \\'\\'\\n    for char in word1:\\n        if char in self.hashmap:\\n            output += self.hashmap[char]\\n        else:\\n            return \\'\\'\\n    return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\n```\\ndef encrypt(self, word1: str) -> str:\\n    output = \\'\\'\\n    for char in word1:\\n        if char in self.hashmap:\\n            output += self.hashmap[char]\\n        else:\\n            return \\'\\'\\n    return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908706,
                "title": "c-maps-fastest",
                "content": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908902,
                "title": "python-very-simple-code",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.enc = dict()\\n        self.n = len(keys)        \\n        \\n        for i in range(self.n):\\n            self.enc[keys[i]] = values[i]\\n        \\n        self.dict = dictionary\\n            \\n    def encrypt(self, word1: str) -> str:\\n        es = \\'\\'\\n        for w in word1:\\n            es += self.enc[w]\\n        return es\\n\\n    def decrypt(self, word2: str) -> int:\\n        ans = 0 \\n        for w in self.dict:\\n            if self.encrypt(w) == word2:\\n                ans += 1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.enc = dict()\\n        self.n = len(keys)        \\n        \\n        for i in range(self.n):\\n            self.enc[keys[i]] = values[i]\\n        \\n        self.dict = dictionary\\n            \\n    def encrypt(self, word1: str) -> str:\\n        es = \\'\\'\\n        for w in word1:\\n            es += self.enc[w]\\n        return es\\n\\n    def decrypt(self, word2: str) -> int:\\n        ans = 0 \\n        for w in self.dict:\\n            if self.encrypt(w) == word2:\\n                ans += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908891,
                "title": "java-solution-with-description-pre-process-dictionary-o-1-decrypt",
                "content": "**Approach**: \\nWhenever decrypt(word) is called decrypt the word. However `values` contains duplicates and it will match to different keys and our descrypt can have many answers. \\nSo, total number of combinations you can achieve is really high and checking every value to dictionary is not a feasible solution.\\n\\nTo overcome that instead of processing word in decrypt(word), pre-process all values in dictionary before. As given there are at most 100 words in dictionary so, encrypt that. As any encryption can lead to same string, store the count of each encryption. This way whenever decrypt is called, just seach that string in our Map and return the count.\\n\\n**Time complexity**:\\n\\nEncrypt: O(n), n: length of word\\nDecrypt: O(1)\\nClass define Encrypter : O(n*m), where n: length of longest word in dictionary, m = dictionary.length\\n\\n**Upvote if it helps. Thanks :)**\\n\\n```\\nclass Encrypter {\\n    \\n    Map<String, Integer> encryptedDictCount;\\n    int[] keys;\\n    Set<String> dictionary;\\n    String[] val;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = new int[26];\\n        encryptedDictCount = new HashMap<>();\\n        this.val = values.clone();\\n        this.dictionary = new HashSet<>(Arrays.asList(dictionary));\\n        \\n        for(int i=0; i<keys.length; i++) {\\n            this.keys[keys[i] - \\'a\\'] = i;\\n        }\\n        \\n        for(String dict : dictionary) {\\n            String encrpted = encrypt(dict);\\n            encryptedDictCount.put(encrpted, encryptedDictCount.getOrDefault(encrpted, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i < word1.length(); i++) {\\n            int c = word1.charAt(i) - \\'a\\';\\n            sb.append(val[keys[c]]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encryptedDictCount.getOrDefault(word2, 0);\\n    }\\n}\\n\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    \\n    Map<String, Integer> encryptedDictCount;\\n    int[] keys;\\n    Set<String> dictionary;\\n    String[] val;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = new int[26];\\n        encryptedDictCount = new HashMap<>();\\n        this.val = values.clone();\\n        this.dictionary = new HashSet<>(Arrays.asList(dictionary));\\n        \\n        for(int i=0; i<keys.length; i++) {\\n            this.keys[keys[i] - \\'a\\'] = i;\\n        }\\n        \\n        for(String dict : dictionary) {\\n            String encrpted = encrypt(dict);\\n            encryptedDictCount.put(encrpted, encryptedDictCount.getOrDefault(encrpted, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i =0; i < word1.length(); i++) {\\n            int c = word1.charAt(i) - \\'a\\';\\n            sb.append(val[keys[c]]);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encryptedDictCount.getOrDefault(word2, 0);\\n    }\\n}\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2778107,
                "title": "java-solutions",
                "content": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908980,
                "title": "java-trie-map-with-trie-node-class-implementation",
                "content": "The approach is to first encrypt the words of the dictionary and store them in a trie with a count of each words.\\nNext, what\\'s left is just traversing over the trie with decrypted word to get the count.\\n**Please upvote if you got the solution.**\\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\\nQueries and discussions regarding the implementation are most welcome.",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908851,
                "title": "c-short-hash-map",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n\\n## Solution 1. Hash Map\\n\\n`encrypt` is straightforward. For `decrypt`, we can precompute ans store the frequencies of encrypted permitted value strings in a map `freq`, and return `freq[word]` in `decrypt`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/encrypt-and-decrypt-strings/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      Encrypter: O(K + V + D) where `K` is the length of `keys`, `V` and `D` are the sizes of all the contents in `values` and `dict`, respectively.\\n//      encrypt: O(W) where `W` is the length of the input word\\n//      decrypt: O(W)\\n// Space: O(K + V + D)\\nclass Encrypter {\\n    unordered_map<char, string> m; // mapping from character keys to corresponding value strings\\n    unordered_map<string, int> freq; // frequency map of encrypted permitted original strings\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            m[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary) {\\n            auto e = encrypt(s);\\n            if (e.size()) freq[e]++;\\n        }\\n    }\\n    string encrypt(string s) {\\n        string ans;\\n        for (char c : s) {\\n            if (m.count(c) == 0) return \"\"; // invalid key character met, return empty string.\\n            ans += m[c];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string s) {\\n        return freq.count(s) ? freq[s] : 0;\\n    }\\n};\\n```\\n\\nThe problem didn\\'t say clearly whether a permitted original string might include unsupported keys. If it might include, then we need to consider the following testcase:\\n\\n```\\n[\"Encrypter\",\"decrypt\"]\\n[[[\"a\"],[\"pq\"],[\"a\",\"ax\"]],[\"pq\"]]\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/encrypt-and-decrypt-strings/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      Encrypter: O(K + V + D) where `K` is the length of `keys`, `V` and `D` are the sizes of all the contents in `values` and `dict`, respectively.\\n//      encrypt: O(W) where `W` is the length of the input word\\n//      decrypt: O(W)\\n// Space: O(K + V + D)\\nclass Encrypter {\\n    unordered_map<char, string> m; // mapping from character keys to corresponding value strings\\n    unordered_map<string, int> freq; // frequency map of encrypted permitted original strings\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            m[keys[i]] = values[i];\\n        }\\n        for (auto &s : dictionary) {\\n            auto e = encrypt(s);\\n            if (e.size()) freq[e]++;\\n        }\\n    }\\n    string encrypt(string s) {\\n        string ans;\\n        for (char c : s) {\\n            if (m.count(c) == 0) return \"\"; // invalid key character met, return empty string.\\n            ans += m[c];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string s) {\\n        return freq.count(s) ? freq[s] : 0;\\n    }\\n};\\n```\n```\\n[\"Encrypter\",\"decrypt\"]\\n[[[\"a\"],[\"pq\"],[\"a\",\"ax\"]],[\"pq\"]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979556,
                "title": "java-c-python-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***C++***\\n```class Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            string p = encrypt(d[i]);\\n            dict[p]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string p = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()){\\n                return \"\";\\n            }\\n            p += m[s[i]];\\n        }\\n        return p;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\\n\\n***Java***\\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\\n\\n***Python***\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```class Encrypter {\\npublic:\\n    unordered_map<char,string> m;\\n    unordered_map<string,int> dict;\\n    // vector k is keys, vector v is values and vector d is dictionary\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        int n = k.size();\\n        // we store the key value pairs in an unordered_map m, so that encryption of a char takes O(1).\\n        for(int i=0;i<n;i++){\\n            m[k[i]] = v[i];\\n        }\\n        \\n        // we encrypt the strings in the vector d and store it\\'s count in an unordered_map dict.\\n        // so that we can directly say the count of decryptions for a string in O(1).\\n        n = d.size();\\n        for(int i=0;i<n;i++){\\n            string p = encrypt(d[i]);\\n            dict[p]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        // encrypt the string using key value pairs in unordered_map m\\n        int n = s.length();\\n        string p = \"\";\\n        for(int i=0;i<n;i++){\\n            if(m.find(s[i])==m.end()){\\n                return \"\";\\n            }\\n            p += m[s[i]];\\n        }\\n        return p;\\n    }\\n    \\n    int decrypt(string s) {\\n        if(dict.find(s)==dict.end()) return 0; // if not present in dict, return 0\\n        return dict[s]; // else return count.\\n    }\\n};\\n```\n```\\nclass Encrypter {\\n    class TrieNode{\\n        int count;\\n        TrieNode[] letter;\\n        public TrieNode(){\\n            letter=new TrieNode[26];\\n            count=0;\\n        }\\n        \\n        public void add(String s){\\n            TrieNode p=this;\\n            for(int i=0;i<s.length();i++){\\n                char ch=s.charAt(i);\\n                if(p.letter[ch-97]==null){\\n                    p.letter[ch-97]=new TrieNode();\\n                }\\n                p=p.letter[ch-97];\\n            }\\n            p.count++;\\n        }\\n        \\n    }\\n    Map<Character,String> charMap;\\n    Map<String,Set<Character>> valueMap;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        charMap=new HashMap<>();\\n        valueMap=new HashMap<>();\\n        root=new TrieNode();\\n        for(int i=0;i<keys.length;i++){\\n            charMap.put(keys[i],values[i]);\\n            valueMap.computeIfAbsent(values[i],key->new HashSet<>()).add(keys[i]);\\n        }\\n        for(String word:dictionary){\\n            String encrypted=encrypt(word);\\n            if(null!=encrypted)\\n                root.add(encrypted);\\n        }\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<word1.length();i++){\\n            if(charMap.get(word1.charAt(i))==null)\\n                return null;\\n            sb.append(charMap.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    public int decrypt(String word2) {\\n        TrieNode p=root;\\n        for(int i=0;i<word2.length();i++){\\n            p=p.letter[word2.charAt(i)-97];\\n            if(p==null)\\n                return 0;\\n        }\\n        return p.count;\\n    }\\n}\\n```\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.hashmap = dict()\\n        for i in range(len(keys)):\\n            self.hashmap[keys[i]] = values[i]\\n        self.dictmap = defaultdict(int)\\n        for word in dictionary:\\n            self.dictmap[self.encrypt(word)] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        output = \\'\\'\\n        for char in word1:\\n            output += self.hashmap[char]\\n        return output\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dictmap[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961804,
                "title": "python3-hash-table-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/f2b4a5c0268eb27201b136764bb0b6ad3880c6f6) for solutions of weekly 287.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mp = dict(zip(keys, values))\\n        self.freq = Counter(map(self.encrypt, dictionary))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.mp.get(ch, \"##\") for ch in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.freq[word2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mp = dict(zip(keys, values))\\n        self.freq = Counter(map(self.encrypt, dictionary))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.mp.get(ch, \"##\") for ch in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.freq[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909284,
                "title": "c-hashmap-based-solution-why-is-this-problem-marked-as-hard",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<string, int> cnt;\\n    map<char, string> kv;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        \\n        for(int i=0; i<keys.size(); i++)\\n            kv[keys[i]]=values[i];\\n        \\n        for(auto d : dict)\\n            cnt[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encp;\\n        for(auto c : word1)\\n            encp+=kv[c];\\n        return encp;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt[word2];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<string, int> cnt;\\n    map<char, string> kv;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        \\n        for(int i=0; i<keys.size(); i++)\\n            kv[keys[i]]=values[i];\\n        \\n        for(auto d : dict)\\n            cnt[encrypt(d)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encp;\\n        for(auto c : word1)\\n            encp+=kv[c];\\n        return encp;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt[word2];\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1909054,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_set<string> dict;\\n    unordered_map<char,string> en;\\n    unordered_map<string,vector<char>> dy;\\n   \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& t:dictionary)\\n         {   dict.insert(t);}\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            char c=keys[i];\\n            string s=values[i];\\n            en[c]=s;\\n            dy[s].push_back(c);\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(char c:word1)\\n        {\\n            ans+=en[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int cnt=0;\\n        for(auto t:dict)\\n        {\\n            string ans=\"\";\\n            for(int i=0;i<t.size();i++)\\n            {\\n                ans+=en[t[i]];\\n            }\\n            if(ans==word2)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_set<string> dict;\\n    unordered_map<char,string> en;\\n    unordered_map<string,vector<char>> dy;\\n   \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& t:dictionary)\\n         {   dict.insert(t);}\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            char c=keys[i];\\n            string s=values[i];\\n            en[c]=s;\\n            dy[s].push_back(c);\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(char c:word1)\\n        {\\n            ans+=en[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int cnt=0;\\n        for(auto t:dict)\\n        {\\n            string ans=\"\";\\n            for(int i=0;i<t.size();i++)\\n            {\\n                ans+=en[t[i]];\\n            }\\n            if(ans==word2)\\n                cnt++;\\n        }\\n        return cnt;\\n    }\\n \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908746,
                "title": "java-solution-using-hashmaps",
                "content": "```\\nclass Encrypter {\\n    Map<Character, String> map;\\n    Map<String, Integer> counts;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        map = new HashMap<>();\\n        counts = new HashMap<>();\\n        \\n        for (int i = 0; i < keys.length; i++) {\\n            map.put(keys[i], values[i]);\\n        }\\n        \\n        for (int i = 0; i < dictionary.length; i++) {\\n            String dictionaryResult = encrypt(dictionary[i]);\\n            counts.put(dictionaryResult, counts.getOrDefault(dictionaryResult, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String result = \"\";\\n        \\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            result = result + map.get(c);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return counts.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Simulation"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character, String> map;\\n    Map<String, Integer> counts;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        map = new HashMap<>();\\n        counts = new HashMap<>();\\n        \\n        for (int i = 0; i < keys.length; i++) {\\n            map.put(keys[i], values[i]);\\n        }\\n        \\n        for (int i = 0; i < dictionary.length; i++) {\\n            String dictionaryResult = encrypt(dictionary[i]);\\n            counts.put(dictionaryResult, counts.getOrDefault(dictionaryResult, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String result = \"\";\\n        \\n        for (int i = 0; i < word1.length(); i++) {\\n            char c = word1.charAt(i);\\n            result = result + map.get(c);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return counts.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908740,
                "title": "python-trie-solution-and-explanation",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python] \\uD83C\\uDF1F Trie Solution and Explanation \\uD83D\\uDC95\\n## 1\\uFE0F\\u20E3 Main Idea:\\n* key2Value:  It is a **one to one map** from key to value, so we could just creat a key2Value hashMap easily\\n* value2Key: It is a **one to many map** from value back to keys, so we use defaultdict(list) to store all keys\\n* trieDict: We build our dictionary in a trie, beacuse when we decrypt from value2Key. There are too many possible that could generate Memory Limit Exceed\\n\\tSo we could use a trie, once we found currChar is not in our currNode. We don\\'t have to traverse all remaining possible.\\n\\t\\n* **func buildTrie** : Init a trie = {}, iterate through all words in dictionary. And iterate through char in word to build a trie\\n* **encrypt**: Iterate through word1 to map all char to its value. And append it in res. Finnally stringfy res and return.\\n* **decrypt** : This is the hard part in this question\\n1. Find all posiible from value2Key: For example ```\"ei\" can map to \\'a\\' or \\'c\\', \"zf\" maps to \\'b\\', and \"am\" maps to \\'d\\'.``` ```So possible = [[a,c] , [b], [a,c], [d]]```\\n2. findInTrie: Given possibles, DFS search from possible in our self.trieDict. If current word is valid res += 1.\\n\\n## Code\\n\\n**Python**\\n```python\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.key2Value = {}\\n        for key, value in zip(keys, values):\\n            self.key2Value[key] = value\\n            \\n        self.value2Key = defaultdict(list)\\n        for key, value in zip(keys, values):\\n            self.value2Key[value].append(key)\\n            \\n        self.trieDict = self.buildTrie(dictionary)\\n        \\n    def buildTrie(self, dictionary):\\n        trie = {}\\n        for word in dictionary:\\n            currNode = trie\\n            for s in word:\\n                if s not in currNode:\\n                    currNode[s] = {}\\n                currNode = currNode[s]\\n            currNode[\"*\"] = word\\n        return trie\\n    \\n    def encrypt(self, word1: str) -> str:\\n        res = []\\n        for char in word1:\\n            res.append(self.key2Value[char])\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        # 1. Find all posiible from value2Key \\n        idx = 0\\n        possible = []\\n        while idx < len(word2):\\n            value = word2[idx:idx+2]\\n            possible.append(self.value2Key[value])\\n            idx += 2\\n        # 2. Given possible, see if a possilbe is valid in trie\\n        return self.findInTrie(possible, 0, self.trieDict)\\n        \\n        \\n    def findInTrie(self, possible, idx, currNode):\\n        res = 0\\n        if idx == len(possible):\\n            if \"*\" in currNode:\\n                return 1\\n            return 0\\n        for char in possible[idx]:\\n            if char in currNode:\\n                res += self.findInTrie(possible, idx + 1, currNode[char])\\n        return res\\n```\\n\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [],
                "code": "```\"ei\" can map to \\'a\\' or \\'c\\', \"zf\" maps to \\'b\\', and \"am\" maps to \\'d\\'.```\n```So possible = [[a,c] , [b], [a,c], [d]]```\n```python\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.key2Value = {}\\n        for key, value in zip(keys, values):\\n            self.key2Value[key] = value\\n            \\n        self.value2Key = defaultdict(list)\\n        for key, value in zip(keys, values):\\n            self.value2Key[value].append(key)\\n            \\n        self.trieDict = self.buildTrie(dictionary)\\n        \\n    def buildTrie(self, dictionary):\\n        trie = {}\\n        for word in dictionary:\\n            currNode = trie\\n            for s in word:\\n                if s not in currNode:\\n                    currNode[s] = {}\\n                currNode = currNode[s]\\n            currNode[\"*\"] = word\\n        return trie\\n    \\n    def encrypt(self, word1: str) -> str:\\n        res = []\\n        for char in word1:\\n            res.append(self.key2Value[char])\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        # 1. Find all posiible from value2Key \\n        idx = 0\\n        possible = []\\n        while idx < len(word2):\\n            value = word2[idx:idx+2]\\n            possible.append(self.value2Key[value])\\n            idx += 2\\n        # 2. Given possible, see if a possilbe is valid in trie\\n        return self.findInTrie(possible, 0, self.trieDict)\\n        \\n        \\n    def findInTrie(self, possible, idx, currNode):\\n        res = 0\\n        if idx == len(possible):\\n            if \"*\" in currNode:\\n                return 1\\n            return 0\\n        for char in possible[idx]:\\n            if char in currNode:\\n                res += self.findInTrie(possible, idx + 1, currNode[char])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775969,
                "title": "c-easy-faster",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n   unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n   unordered_map<char, string> enc;\\n    unordered_map<string, int> count;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i)\\n            enc[keys[i]] = values[i];\\n        for (string& w: dictionary)\\n            count[encrypt(w)]++;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (char c: word1) {\\n        \\tif (!enc.count(c)) return \"\";\\n            res += enc[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909590,
                "title": "easiest-hard-probelm-logic-complexity-analysis-c",
                "content": "## **Solution**\\n\\n\\n#### **LOGIC**\\n* Map vector ```keys``` to ```values``` so that we do not need to loop through ```keys``` to find correct value.\\n* ```dictionary``` is having all decrypted string, so we will encrypt them and see if the result match to the ```word2``` if so, then increase ```sol``` by 1.\\n* If you crete all decrypted string from ```word2``` and then try to look ```dictionary``` for that valuse. then it will make it very complex in term of code and time.\\n\\n\\n#### **Code**  \\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> mp1;\\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->dictionary = dictionary;\\n        for (int i = 0; i < keys.size(); i++) {\\n            mp1[keys[i]] =  values[i];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string sol = \"\";\\n        for (auto x : word1) {\\n            sol += mp1[x];\\n        }\\n        return sol;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sol = 0;\\n        \\n        for (auto x : this->dictionary) {\\n            if (encrypt(x) == word2) {\\n                sol++;\\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```\\n\\n## **Complexity**\\n\\n##### __Apporach : 1__  \\n##### Time Complexity:  \\n* __Encrypter__:  __O(size_of_keys)__\\n* __encrypt__:  __O(size_of_word1)__\\n* __decrypt__:  __O(size_of_dictionary)__\\n\\n##### Space Complexity:\\n* __O(size_of_dictionary)__\\n\\n\\n<br>\\n\\n __Check out all [my](https://leetcode.com/siddp6/) recent solutions [here](https://github.com/sidd6p/LeetCode)__\\n\\n \\n __Feel Free to Ask Doubts\\nAnd Please Share Some Suggestions\\nHAPPY CODING :)__\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```keys```\n```values```\n```keys```\n```dictionary```\n```word2```\n```sol```\n```word2```\n```dictionary```\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> mp1;\\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->dictionary = dictionary;\\n        for (int i = 0; i < keys.size(); i++) {\\n            mp1[keys[i]] =  values[i];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string sol = \"\";\\n        for (auto x : word1) {\\n            sol += mp1[x];\\n        }\\n        return sol;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sol = 0;\\n        \\n        for (auto x : this->dictionary) {\\n            if (encrypt(x) == word2) {\\n                sol++;\\n            }\\n        }\\n        \\n        return sol;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909251,
                "title": "elegant-pythonic-solution",
                "content": "The `encrypt` is the easiest part of the problem. Create a mapping and you are done.  The `decrypt` and `dictionary` values is a little tricky to figure out and we have basically have to create an inverse frequency map for this.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.encrypt_map = {k: v for k, v in zip(keys, values)}\\n        self.decrypt_map = Counter()\\n        \\n        for word in dictionary:\\n            res = self.encrypt(word)\\n            self.decrypt_map[res] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.encrypt_map[letter] for letter in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decrypt_map[word2]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.encrypt_map = {k: v for k, v in zip(keys, values)}\\n        self.decrypt_map = Counter()\\n        \\n        for word in dictionary:\\n            res = self.encrypt(word)\\n            self.decrypt_map[res] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.encrypt_map[letter] for letter in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decrypt_map[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909075,
                "title": "python-easy-understanding-python-solution",
                "content": "After 1 hour struggled with dp and trie. The question tend to be solved as simple as this \\nLOL\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = set(dictionary)\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        res = 0\\n        \\n        for item in self.dictionary:\\n            if self.encrypt(item) == word2:\\n                res += 1\\n        return res\\n```\\n\\nHere I also  post my Trie + Dp solution, but it is exceed the time limit. I would appricate if anyone could helpe me optimize the solution.\\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = {}\\n    \\n    def add(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.child:\\n                cur.child[c] = Trie()\\n            cur = cur.child[c]\\n        \\n        if \\'#\\' not in cur.child:\\n            cur.child[\\'#\\'] = \\'#\\'\\n    \\n    def find(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        \\n        return True \\n    \\n    def findExact(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        return \\'#\\' in cur.child \\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.trie = Trie()\\n        \\n        for word in dictionary:\\n            self.trie.add(word)\\n            \\n        self.map = defaultdict(list)\\n        \\n        for key, enco in zip(keys, values): # build the map from the eco to the initial word\\n            self.map[enco].append(key)\\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        chunks, chunk_size = len(word2), 2\\n        word = [ word2[i:i+chunk_size] for i in range(0, chunks, chunk_size)]\\n        size = len(word)\\n        dp = [[] for _ in range(size)]\\n        \\n        res  = 0\\n        for i in range(size):\\n            enco = word[i]\\n            if i == 0:\\n                for item in self.map[enco]:\\n                    if self.trie.find(item):\\n                        if i == size -1:\\n                            if \\'#\\' in self.trie.child[item].child:\\n                                res += 1\\n                        else:       \\n                            dp[i].append((item,self.trie.child[item]))\\n            else :\\n                for prev,pointer in dp[i-1]:\\n                    for curc in self.map[enco]:\\n                        if pointer.find(curc):\\n                            if i == size -1:\\n                                if \\'#\\' in pointer.child[curc].child:\\n                                    res += 1\\n                            else:\\n                                dp[i].append((prev + curc,pointer.child[curc]))\\n        return res     \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = set(dictionary)\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        res = 0\\n        \\n        for item in self.dictionary:\\n            if self.encrypt(item) == word2:\\n                res += 1\\n        return res\\n```\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = {}\\n    \\n    def add(self, word):\\n        cur = self\\n        for c in word:\\n            if c not in cur.child:\\n                cur.child[c] = Trie()\\n            cur = cur.child[c]\\n        \\n        if \\'#\\' not in cur.child:\\n            cur.child[\\'#\\'] = \\'#\\'\\n    \\n    def find(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        \\n        return True \\n    \\n    def findExact(self, word):\\n        cur = self \\n        \\n        for c in word:\\n            if c not in cur.child:\\n                return False\\n            cur = cur.child[c]\\n        return \\'#\\' in cur.child \\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keydic = {e:i for i,e in enumerate(keys)}\\n        self.values = values\\n        self.trie = Trie()\\n        \\n        for word in dictionary:\\n            self.trie.add(word)\\n            \\n        self.map = defaultdict(list)\\n        \\n        for key, enco in zip(keys, values): # build the map from the eco to the initial word\\n            self.map[enco].append(key)\\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            res += self.values[self.keydic[c]]\\n        return res\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        chunks, chunk_size = len(word2), 2\\n        word = [ word2[i:i+chunk_size] for i in range(0, chunks, chunk_size)]\\n        size = len(word)\\n        dp = [[] for _ in range(size)]\\n        \\n        res  = 0\\n        for i in range(size):\\n            enco = word[i]\\n            if i == 0:\\n                for item in self.map[enco]:\\n                    if self.trie.find(item):\\n                        if i == size -1:\\n                            if \\'#\\' in self.trie.child[item].child:\\n                                res += 1\\n                        else:       \\n                            dp[i].append((item,self.trie.child[item]))\\n            else :\\n                for prev,pointer in dp[i-1]:\\n                    for curc in self.map[enco]:\\n                        if pointer.find(curc):\\n                            if i == size -1:\\n                                if \\'#\\' in pointer.child[curc].child:\\n                                    res += 1\\n                            else:\\n                                dp[i].append((prev + curc,pointer.child[curc]))\\n        return res     \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908808,
                "title": "c-hashmap-trie-dp-dfs",
                "content": "```C++\\nstruct Trie {\\n    Trie* next[26];\\n    bool eof = false;\\n    Trie() {memset(next,0,sizeof(next));}\\n    void insert(string& s, int p) {\\n        if(p == s.length()) eof = true;\\n        else {\\n            if(!next[s[p]-\\'a\\']) next[s[p]-\\'a\\'] = new Trie();\\n            next[s[p]-\\'a\\']->insert(s, p + 1);\\n        }\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<char, int> k;\\n    vector<string> v;\\n    unordered_map<string, unordered_set<char>> mpv;\\n    Trie* t, *rt;\\n\\n    vector<pair<bool, vector<Trie*>>> DP;\\n    vector<bool> vis;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        t = new Trie();\\n        rt = new Trie();\\n        v = values;\\n\\n        for(int i = 0; i < keys.size(); i++)\\n            k[keys[i]] = i;\\n        for(int i = 0; i < values.size(); i++)\\n            mpv[values[i]].insert(keys[i]);\\n        for(auto& v : values)\\n            t->insert(v, 0);\\n        for(auto& d : dictionary) {\\n            auto rd = d;\\n            reverse(rd.begin(), rd.end());\\n            rt->insert(rd, 0);\\n        }\\n    }\\n\\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for(auto& w : word1) {\\n            ss<<v[k[w]];\\n        }\\n        return ss.str();\\n    }\\n\\n    int decrypt(string word2) {\\n        int n = word2.length();\\n        DP = vector<pair<bool, vector<Trie*>>>(n + 1, {false, {}});\\n        DP.back() = {true, {rt}};\\n\\n        vis = vector<bool>(n + 1, false);\\n        vis.back() = true;\\n\\n        auto [_, s] = helper(word2, 0);\\n        int res = 0;\\n        for(auto& rtrie : s) {\\n            res += rtrie->eof;\\n        }\\n\\n        return res;\\n    }\\n\\n    pair<bool,vector<Trie*>> helper(string& w, int p) {\\n        if(vis[p]) return DP[p];\\n        vis[p] = true;\\n        string ss;\\n        vector<Trie*> res;\\n        Trie* trie = t;\\n        bool PO = false;\\n        for(int i = p; i < w.length(); i++) {\\n            if(!trie->next[w[i]-\\'a\\']) break;\\n\\n            trie = trie->next[w[i]-\\'a\\'];\\n            ss += w[i];\\n            if(!trie->eof) continue;\\n            auto [po, comb] = helper(w, i + 1);\\n            if(!po) continue;\\n\\n            for(auto& rtrie : comb) {\\n                for(auto ch : mpv[ss]) {\\n                    if(!rtrie->next[ch-\\'a\\']) continue;\\n                    PO = true;\\n                    Trie* nrt = rtrie->next[ch-\\'a\\'];\\n                    res.push_back(nrt);\\n                }\\n            }\\n        }\\n        return DP[p] = {PO, res};\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```C++\\nstruct Trie {\\n    Trie* next[26];\\n    bool eof = false;\\n    Trie() {memset(next,0,sizeof(next));}\\n    void insert(string& s, int p) {\\n        if(p == s.length()) eof = true;\\n        else {\\n            if(!next[s[p]-\\'a\\']) next[s[p]-\\'a\\'] = new Trie();\\n            next[s[p]-\\'a\\']->insert(s, p + 1);\\n        }\\n    }\\n};\\nclass Encrypter {\\n    unordered_map<char, int> k;\\n    vector<string> v;\\n    unordered_map<string, unordered_set<char>> mpv;\\n    Trie* t, *rt;\\n\\n    vector<pair<bool, vector<Trie*>>> DP;\\n    vector<bool> vis;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        t = new Trie();\\n        rt = new Trie();\\n        v = values;\\n\\n        for(int i = 0; i < keys.size(); i++)\\n            k[keys[i]] = i;\\n        for(int i = 0; i < values.size(); i++)\\n            mpv[values[i]].insert(keys[i]);\\n        for(auto& v : values)\\n            t->insert(v, 0);\\n        for(auto& d : dictionary) {\\n            auto rd = d;\\n            reverse(rd.begin(), rd.end());\\n            rt->insert(rd, 0);\\n        }\\n    }\\n\\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for(auto& w : word1) {\\n            ss<<v[k[w]];\\n        }\\n        return ss.str();\\n    }\\n\\n    int decrypt(string word2) {\\n        int n = word2.length();\\n        DP = vector<pair<bool, vector<Trie*>>>(n + 1, {false, {}});\\n        DP.back() = {true, {rt}};\\n\\n        vis = vector<bool>(n + 1, false);\\n        vis.back() = true;\\n\\n        auto [_, s] = helper(word2, 0);\\n        int res = 0;\\n        for(auto& rtrie : s) {\\n            res += rtrie->eof;\\n        }\\n\\n        return res;\\n    }\\n\\n    pair<bool,vector<Trie*>> helper(string& w, int p) {\\n        if(vis[p]) return DP[p];\\n        vis[p] = true;\\n        string ss;\\n        vector<Trie*> res;\\n        Trie* trie = t;\\n        bool PO = false;\\n        for(int i = p; i < w.length(); i++) {\\n            if(!trie->next[w[i]-\\'a\\']) break;\\n\\n            trie = trie->next[w[i]-\\'a\\'];\\n            ss += w[i];\\n            if(!trie->eof) continue;\\n            auto [po, comb] = helper(w, i + 1);\\n            if(!po) continue;\\n\\n            for(auto& rtrie : comb) {\\n                for(auto ch : mpv[ss]) {\\n                    if(!rtrie->next[ch-\\'a\\']) continue;\\n                    PO = true;\\n                    Trie* nrt = rtrie->next[ch-\\'a\\'];\\n                    res.push_back(nrt);\\n                }\\n            }\\n        }\\n        return DP[p] = {PO, res};\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908758,
                "title": "c-hashmap-set",
                "content": "Decryption: The dictionary of strings size is atmax 100. it\\'s better to encrypt each string in the dictionary and check whether it matches with the given string.\\n```\\nclass Encrypter {\\npublic:\\n    set<string> isInDictionary;\\n    vector<string> value;\\n    vector<int> keyIndex;\\n    unordered_map<char,string> keyToValueMap;\\n    \\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        //allocate space to store indices of each character in keys.\\n        keyIndex.resize(26,INT_MAX);\\n        \\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n            keyIndex[keys[i]-\\'a\\']=i;\\n        \\n        //assign value to values vector.\\n        value=values;\\n        \\n        \\n        // store the corresponding value string of each character in keys.\\n        for(int i=0;i<n;i++)\\n            keyToValueMap[keys[i]]=values[i];\\n        \\n        //save the strings in dictionary in a map.\\n        for(auto str:dictionary)\\n            isInDictionary.insert(str);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encryptedStr;\\n        // retrieve each charater value string using the keyIndex of that character.\\n        for(auto ch:word1)\\n            encryptedStr+=value[keyIndex[ch-\\'a\\']];\\n        return encryptedStr;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sz=word2.length();\\n        int count=0;\\n        // dictionary contains the decrypted strings since the dictionary size is 100.\\n        // traverse the dictionary and construct the corresponding encrypted string.\\n        for(string dictStr:isInDictionary){\\n            string enctryptedStr;\\n            //construct the encrypted string.\\n            for(auto ch:dictStr){\\n                //if there is no mapping for the character\\n                if(keyToValueMap.find(ch)==keyToValueMap.end())\\n                    return 0;\\n                enctryptedStr+=keyToValueMap[ch];\\n            }\\n\\t\\t\\t//increase the count if the encrypted string matches with word2.\\n            if(enctryptedStr==word2)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "Decryption: The dictionary of strings size is atmax 100. it\\'s better to encrypt each string in the dictionary and check whether it matches with the given string.\\n```\\nclass Encrypter {\\npublic:\\n    set<string> isInDictionary;\\n    vector<string> value;\\n    vector<int> keyIndex;\\n    unordered_map<char,string> keyToValueMap;\\n    \\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        //allocate space to store indices of each character in keys.\\n        keyIndex.resize(26,INT_MAX);\\n        \\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n            keyIndex[keys[i]-\\'a\\']=i;\\n        \\n        //assign value to values vector.\\n        value=values;\\n        \\n        \\n        // store the corresponding value string of each character in keys.\\n        for(int i=0;i<n;i++)\\n            keyToValueMap[keys[i]]=values[i];\\n        \\n        //save the strings in dictionary in a map.\\n        for(auto str:dictionary)\\n            isInDictionary.insert(str);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string encryptedStr;\\n        // retrieve each charater value string using the keyIndex of that character.\\n        for(auto ch:word1)\\n            encryptedStr+=value[keyIndex[ch-\\'a\\']];\\n        return encryptedStr;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int sz=word2.length();\\n        int count=0;\\n        // dictionary contains the decrypted strings since the dictionary size is 100.\\n        // traverse the dictionary and construct the corresponding encrypted string.\\n        for(string dictStr:isInDictionary){\\n            string enctryptedStr;\\n            //construct the encrypted string.\\n            for(auto ch:dictStr){\\n                //if there is no mapping for the character\\n                if(keyToValueMap.find(ch)==keyToValueMap.end())\\n                    return 0;\\n                enctryptedStr+=keyToValueMap[ch];\\n            }\\n\\t\\t\\t//increase the count if the encrypted string matches with word2.\\n            if(enctryptedStr==word2)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 4080996,
                "title": "very-simple-solution-try-catch-without-trie",
                "content": "# Code\\n```\\nclass Encrypter {\\n    String key_value[]=new String[26];\\n    HashMap<String, Integer> encrypted_dictionary=new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i=0;\\n        for(char key: keys) key_value[key-\\'a\\']=values[i++];\\n        \\n        for(String word: dictionary) {\\n            String encr=encrypt(word);\\n            if(encr==null) continue;\\n            encrypted_dictionary.put(encr, encrypted_dictionary.getOrDefault(encr, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] res=new char[word1.length()*2];\\n        for(int i=0;i<word1.length();i++) {\\n            try{\\n                res[i*2]=key_value[word1.charAt(i)-\\'a\\'].charAt(0);\\n                res[i*2+1]=key_value[word1.charAt(i)-\\'a\\'].charAt(1);\\n            }catch(Exception e){\\n                return null;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encrypted_dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\\n\\nThe Try catch block... its because I didnt want to mannually check for the error. Anyways, if a word causes problem, it wont be there in encrypted dictionary anyways... \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Encrypter {\\n    String key_value[]=new String[26];\\n    HashMap<String, Integer> encrypted_dictionary=new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i=0;\\n        for(char key: keys) key_value[key-\\'a\\']=values[i++];\\n        \\n        for(String word: dictionary) {\\n            String encr=encrypt(word);\\n            if(encr==null) continue;\\n            encrypted_dictionary.put(encr, encrypted_dictionary.getOrDefault(encr, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] res=new char[word1.length()*2];\\n        for(int i=0;i<word1.length();i++) {\\n            try{\\n                res[i*2]=key_value[word1.charAt(i)-\\'a\\'].charAt(0);\\n                res[i*2+1]=key_value[word1.charAt(i)-\\'a\\'].charAt(1);\\n            }catch(Exception e){\\n                return null;\\n            }\\n        }\\n        return new String(res);\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encrypted_dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544782,
                "title": "two-maps-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n    map<char,string> mp;\\n    map<string,int> decrypted;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++){\\n            mp[keys[i]] = values[i];\\n        }\\n        for(int i = 0; i < dictionary.size(); i++){\\n            decrypted[encrypt(dictionary[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            if(mp.find(word1[i]) == mp.end()){\\n                return \"\";\\n            }\\n            ans += mp[word1[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       if(decrypted.find(word2) == decrypted.end()){\\n           return 0;\\n       }\\n       return decrypted[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> mp;\\n    map<string,int> decrypted;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++){\\n            mp[keys[i]] = values[i];\\n        }\\n        for(int i = 0; i < dictionary.size(); i++){\\n            decrypted[encrypt(dictionary[i])]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            if(mp.find(word1[i]) == mp.end()){\\n                return \"\";\\n            }\\n            ans += mp[word1[i]];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       if(decrypted.find(word2) == decrypted.end()){\\n           return 0;\\n       }\\n       return decrypted[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475098,
                "title": "java-trie-hashmap",
                "content": "```\\nclass Encrypter {\\n    class Node {\\n        Node[] child = new Node[26];\\n        boolean isEnd = false;\\n        String word;\\n        Node () {\\n            //  Default\\n        }\\n    }\\n    //  this map is requied for encrypting the string\\n    HashMap<Integer, List<String>> charMap = new HashMap<>();\\n    //  this map is required for decrypting the string (to get the next valid or possible \\n    //  characters of a string in dictionary)\\n    HashMap<String, List<Integer>> revMap = new HashMap<>();\\n    //  stores all string in dictionary\\n    HashSet<String> dict = new HashSet<>();\\n    //  root of the Trie\\n    Node root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (String s : dictionary) {\\n            dict.add(s);\\n        }\\n        constructTrie(dictionary);\\n        for (int i = 0; i < keys.length; i++) {\\n            //  charMap\\n            if (!charMap.containsKey(keys[i] - \\'a\\')) {\\n                charMap.put(keys[i] - \\'a\\', new ArrayList<>());\\n            }\\n            charMap.get(keys[i] - \\'a\\').add(values[i]);\\n            //  revMap\\n            if (!revMap.containsKey(values[i])) {\\n                revMap.put(values[i], new ArrayList<>());\\n            }\\n            revMap.get(values[i]).add(keys[i] - \\'a\\');\\n        }\\n    }\\n    \\n    //  Trie for pruning (adding words on trie)\\n    private void constructTrie(String[] words) {\\n        root = new Node();\\n        for (String w : words) {\\n            Node curr = root;\\n            for (char c : w.toCharArray()) {\\n                if (curr.child[c - \\'a\\'] == null) {\\n                    curr.child[c - \\'a\\'] = new Node();\\n                }\\n                curr = curr.child[c - \\'a\\'];\\n            }\\n            curr.isEnd = true;\\n            curr.word = w;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder answer = new StringBuilder(\"\");\\n        for (char c : word1.toCharArray()) {\\n            if (!charMap.containsKey(c - \\'a\\')) return \"\";\\n            answer.append(charMap.get(c - \\'a\\').get(0));\\n        }\\n        return answer.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        Node curr = root;\\n        return helper(word2, curr, 0);\\n    }\\n    \\n    private int helper(String s, Node curr, int currIdx) {\\n        if (currIdx == s.length()) {\\n            //  at the end of the string and checking if this is present in the dict\\n            return dict.contains(curr.word) ? 1 : 0;\\n        }\\n        String key = s.substring(currIdx, currIdx + 2);\\n        List<Integer> next = revMap.getOrDefault(key, new ArrayList<>());\\n        int count = 0;\\n        for (int c : next) {\\n            if (curr.child[c] != null) {\\n                count += helper(s, curr.child[c], currIdx + 2);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    class Node {\\n        Node[] child = new Node[26];\\n        boolean isEnd = false;\\n        String word;\\n        Node () {\\n            //  Default\\n        }\\n    }\\n    //  this map is requied for encrypting the string\\n    HashMap<Integer, List<String>> charMap = new HashMap<>();\\n    //  this map is required for decrypting the string (to get the next valid or possible \\n    //  characters of a string in dictionary)\\n    HashMap<String, List<Integer>> revMap = new HashMap<>();\\n    //  stores all string in dictionary\\n    HashSet<String> dict = new HashSet<>();\\n    //  root of the Trie\\n    Node root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (String s : dictionary) {\\n            dict.add(s);\\n        }\\n        constructTrie(dictionary);\\n        for (int i = 0; i < keys.length; i++) {\\n            //  charMap\\n            if (!charMap.containsKey(keys[i] - \\'a\\')) {\\n                charMap.put(keys[i] - \\'a\\', new ArrayList<>());\\n            }\\n            charMap.get(keys[i] - \\'a\\').add(values[i]);\\n            //  revMap\\n            if (!revMap.containsKey(values[i])) {\\n                revMap.put(values[i], new ArrayList<>());\\n            }\\n            revMap.get(values[i]).add(keys[i] - \\'a\\');\\n        }\\n    }\\n    \\n    //  Trie for pruning (adding words on trie)\\n    private void constructTrie(String[] words) {\\n        root = new Node();\\n        for (String w : words) {\\n            Node curr = root;\\n            for (char c : w.toCharArray()) {\\n                if (curr.child[c - \\'a\\'] == null) {\\n                    curr.child[c - \\'a\\'] = new Node();\\n                }\\n                curr = curr.child[c - \\'a\\'];\\n            }\\n            curr.isEnd = true;\\n            curr.word = w;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder answer = new StringBuilder(\"\");\\n        for (char c : word1.toCharArray()) {\\n            if (!charMap.containsKey(c - \\'a\\')) return \"\";\\n            answer.append(charMap.get(c - \\'a\\').get(0));\\n        }\\n        return answer.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        Node curr = root;\\n        return helper(word2, curr, 0);\\n    }\\n    \\n    private int helper(String s, Node curr, int currIdx) {\\n        if (currIdx == s.length()) {\\n            //  at the end of the string and checking if this is present in the dict\\n            return dict.contains(curr.word) ? 1 : 0;\\n        }\\n        String key = s.substring(currIdx, currIdx + 2);\\n        List<Integer> next = revMap.getOrDefault(key, new ArrayList<>());\\n        int count = 0;\\n        for (int c : next) {\\n            if (curr.child[c] != null) {\\n                count += helper(s, curr.child[c], currIdx + 2);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1956564,
                "title": "python-trie-and-hashmap",
                "content": "`@cache` helps a lot with same queries in test cases.\\n\\n# Trie\\n```python\\nclass TrieNode:\\n    def __init__(self, words: List[str] = None):\\n        self.children = {}\\n        self.a_word = False\\n        if words:\\n            for word in words:\\n                self.add(word)\\n\\n    def add(self, word: str):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.a_word = True\\n\\n\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keylookup = {key: val for key, val in zip(keys, values)}\\n        self.vallookup = defaultdict(list)\\n        for i, val in enumerate(values):\\n            self.vallookup[val].append(keys[i])\\n        self.trie = TrieNode(dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.keylookup:\\n                return \"\"\\n            ret.append(self.keylookup[c])\\n        return \"\".join(ret)\\n\\n    @cache\\n    def decrypt(self, word2: str) -> int:\\n        chunks = (word2[i : i + 2] for i in range(0, len(word2), 2))\\n        candidates = list(self.vallookup[s] for s in chunks)\\n        N = len(candidates)\\n\\n        def dfs(root: TrieNode, i):\\n            if i == N:\\n                return int(root.a_word)\\n\\n            count = 0\\n            for key in candidates[i]:\\n                if key in root.children:\\n                    count += dfs(root.children[key], i + 1)\\n\\n            return count\\n\\n        return dfs(self.trie, 0)\\n```\\n\\n# hashmap\\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.klookup = {key: val for key, val in zip(keys, values)}\\n        self.dlookup = Counter(self.encrypt(w) for w in dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.klookup:\\n                return \"\"\\n            ret.append(self.klookup[c])\\n        return \"\".join(ret)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dlookup[word2]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self, words: List[str] = None):\\n        self.children = {}\\n        self.a_word = False\\n        if words:\\n            for word in words:\\n                self.add(word)\\n\\n    def add(self, word: str):\\n        cur = self\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.a_word = True\\n\\n\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.keylookup = {key: val for key, val in zip(keys, values)}\\n        self.vallookup = defaultdict(list)\\n        for i, val in enumerate(values):\\n            self.vallookup[val].append(keys[i])\\n        self.trie = TrieNode(dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.keylookup:\\n                return \"\"\\n            ret.append(self.keylookup[c])\\n        return \"\".join(ret)\\n\\n    @cache\\n    def decrypt(self, word2: str) -> int:\\n        chunks = (word2[i : i + 2] for i in range(0, len(word2), 2))\\n        candidates = list(self.vallookup[s] for s in chunks)\\n        N = len(candidates)\\n\\n        def dfs(root: TrieNode, i):\\n            if i == N:\\n                return int(root.a_word)\\n\\n            count = 0\\n            for key in candidates[i]:\\n                if key in root.children:\\n                    count += dfs(root.children[key], i + 1)\\n\\n            return count\\n\\n        return dfs(self.trie, 0)\\n```\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.klookup = {key: val for key, val in zip(keys, values)}\\n        self.dlookup = Counter(self.encrypt(w) for w in dictionary)\\n\\n    @cache\\n    def encrypt(self, word1: str) -> str:\\n        ret = []\\n        for c in word1:\\n            if c not in self.klookup:\\n                return \"\"\\n            ret.append(self.klookup[c])\\n        return \"\".join(ret)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.dlookup[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942851,
                "title": "java-solution-faster-than-25-81-less-than-81-35",
                "content": "```\\n\\tMap<Character, String> kvMap = new HashMap<>();\\n    Map<String, List<Character>> vkMap = new HashMap<>();\\n    TrieNode root = new TrieNode();\\n    Map<String, Integer> cache = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0, len = keys.length; i < len; ++i) {\\n            char key = keys[i];\\n            String value = values[i];\\n            kvMap.put(key, value);\\n            List<Character> characters = vkMap.getOrDefault(value, new ArrayList<>());\\n            characters.add(key);\\n            vkMap.put(value, characters);\\n        }\\n        for (String dic : dictionary) {\\n            build(root, dic);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            String s = kvMap.get(c);\\n            if (s == null) {\\n                return \"\";\\n            }\\n            sb.append(s);\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        Integer integer = cache.get(word2);\\n        if (integer == null) {\\n            int dfs = dfs(word2, 0, new StringBuilder());\\n            cache.put(word2, dfs);\\n            return dfs;\\n        }\\n        return integer;\\n    }\\n\\n        private int dfs(String word2, int index, StringBuilder sb) {\\n        if (index == word2.length()) {\\n            return search(root, sb.toString(), 0) ? 1 : 0;\\n        }\\n        if (index > 0 && !searchPrefix(root, sb.toString(), 0)) {\\n             return 0;\\n        }\\n        int count = 0;\\n        String substr = word2.substring(index, index + 2);\\n        List<Character> characters = vkMap.get(substr);\\n        if (characters == null) {\\n            return 0;\\n        }\\n        for (Character c : characters) {\\n            sb.append(c);\\n            count += dfs(word2, index + 2, sb);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        return count;\\n    }\\n\\n    private void build(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        for (char c : word.toCharArray()) {\\n            Map<Character, TrieNode> children = curr.getChildren();\\n            TrieNode node = children.get(c);\\n            if (node == null) {\\n                node = new TrieNode();\\n                children.put(c, node);\\n            }\\n            curr = node;\\n        }\\n        curr.setWord(true);\\n    }\\n\\n    private boolean search(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return false;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        if (index == word.length() - 1 && node.isWord) {\\n            return true;\\n        }\\n        return search(node, word, index + 1);\\n    }\\n\\n    private boolean searchPrefix(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return true;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        return searchPrefix(node, word, index + 1);\\n    }\\n\\n    private static class TrieNode {\\n\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isWord;\\n\\n        public Map<Character, TrieNode> getChildren() {\\n            return children;\\n        }\\n\\n        public void setChildren(Map<Character, TrieNode> children) {\\n            this.children = children;\\n        }\\n\\n        public boolean isWord() {\\n            return isWord;\\n        }\\n\\n        public void setWord(boolean word) {\\n            isWord = word;\\n        }\\n\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n\\tMap<Character, String> kvMap = new HashMap<>();\\n    Map<String, List<Character>> vkMap = new HashMap<>();\\n    TrieNode root = new TrieNode();\\n    Map<String, Integer> cache = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0, len = keys.length; i < len; ++i) {\\n            char key = keys[i];\\n            String value = values[i];\\n            kvMap.put(key, value);\\n            List<Character> characters = vkMap.getOrDefault(value, new ArrayList<>());\\n            characters.add(key);\\n            vkMap.put(value, characters);\\n        }\\n        for (String dic : dictionary) {\\n            build(root, dic);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            String s = kvMap.get(c);\\n            if (s == null) {\\n                return \"\";\\n            }\\n            sb.append(s);\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        Integer integer = cache.get(word2);\\n        if (integer == null) {\\n            int dfs = dfs(word2, 0, new StringBuilder());\\n            cache.put(word2, dfs);\\n            return dfs;\\n        }\\n        return integer;\\n    }\\n\\n        private int dfs(String word2, int index, StringBuilder sb) {\\n        if (index == word2.length()) {\\n            return search(root, sb.toString(), 0) ? 1 : 0;\\n        }\\n        if (index > 0 && !searchPrefix(root, sb.toString(), 0)) {\\n             return 0;\\n        }\\n        int count = 0;\\n        String substr = word2.substring(index, index + 2);\\n        List<Character> characters = vkMap.get(substr);\\n        if (characters == null) {\\n            return 0;\\n        }\\n        for (Character c : characters) {\\n            sb.append(c);\\n            count += dfs(word2, index + 2, sb);\\n            sb.deleteCharAt(sb.length() - 1);\\n        }\\n        return count;\\n    }\\n\\n    private void build(TrieNode root, String word) {\\n        TrieNode curr = root;\\n        for (char c : word.toCharArray()) {\\n            Map<Character, TrieNode> children = curr.getChildren();\\n            TrieNode node = children.get(c);\\n            if (node == null) {\\n                node = new TrieNode();\\n                children.put(c, node);\\n            }\\n            curr = node;\\n        }\\n        curr.setWord(true);\\n    }\\n\\n    private boolean search(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return false;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        if (index == word.length() - 1 && node.isWord) {\\n            return true;\\n        }\\n        return search(node, word, index + 1);\\n    }\\n\\n    private boolean searchPrefix(TrieNode root, String word, int index) {\\n        if (index == word.length()) {\\n            return true;\\n        }\\n        char c = word.charAt(index);\\n        TrieNode node = root.getChildren().get(c);\\n        if (node == null) {\\n            return false;\\n        }\\n        return searchPrefix(node, word, index + 1);\\n    }\\n\\n    private static class TrieNode {\\n\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean isWord;\\n\\n        public Map<Character, TrieNode> getChildren() {\\n            return children;\\n        }\\n\\n        public void setChildren(Map<Character, TrieNode> children) {\\n            this.children = children;\\n        }\\n\\n        public boolean isWord() {\\n            return isWord;\\n        }\\n\\n        public void setWord(boolean word) {\\n            isWord = word;\\n        }\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930455,
                "title": "this-very-simple-solution-beats-80-while-trie-gets-tle",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {k:v for k,v in zip(keys, values)}\\n        self.d = collections.Counter([self.encrypt(d) for d in dictionary])\\n        \\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            if c not in self.kv: return \\'\\'\\n            res += self.kv[c]\\n        return res\\n\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n            \\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {k:v for k,v in zip(keys, values)}\\n        self.d = collections.Counter([self.encrypt(d) for d in dictionary])\\n        \\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for c in word1:\\n            if c not in self.kv: return \\'\\'\\n            res += self.kv[c]\\n        return res\\n\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n            \\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926788,
                "title": "simple-java-solution-with-2-maps",
                "content": "```\\nclass Encrypter {\\n    private Map<Character, String> enc = new HashMap<>();\\n    private Map<String, Integer> countMap = new HashMap<>();\\n    private static final String DEFAULT_ENCODE_STRING = \"#\";\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int idx = 0; idx < keys.length; idx++) {\\n            enc.put(keys[idx], values[idx]);\\n        }\\n        for (String word : dictionary) {\\n            String encryptString = encrypt(word);\\n            countMap.put(encryptString, countMap.getOrDefault(encryptString, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder result = new StringBuilder();\\n        for (int idx = 0; idx < word1.length(); idx++) {\\n            result.append(enc.getOrDefault(word1.charAt(idx), DEFAULT_ENCODE_STRING));\\n        }\\n        return result.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return countMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    private Map<Character, String> enc = new HashMap<>();\\n    private Map<String, Integer> countMap = new HashMap<>();\\n    private static final String DEFAULT_ENCODE_STRING = \"#\";\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int idx = 0; idx < keys.length; idx++) {\\n            enc.put(keys[idx], values[idx]);\\n        }\\n        for (String word : dictionary) {\\n            String encryptString = encrypt(word);\\n            countMap.put(encryptString, countMap.getOrDefault(encryptString, 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder result = new StringBuilder();\\n        for (int idx = 0; idx < word1.length(); idx++) {\\n            result.append(enc.getOrDefault(word1.charAt(idx), DEFAULT_ENCODE_STRING));\\n        }\\n        return result.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return countMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920897,
                "title": "c-easy-to-understand-simple-solution-using-hashmap",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> mp1;\\n    vector<string> dic;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[keys[i]]=values[i];\\n        }\\n        dic=dictionary;\\n    }\\n    string encrypt(string word1) {\\n     string ans=\"\";\\n        for(char ch:word1)\\n        {\\n            if(mp1.find(ch)==mp1.end())\\n            return \"\";\\n            ans+=mp1[ch];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        int ans=0;\\n        for(auto str:dic)\\n        {\\n          if(encrypt(str)==word2)\\n          ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> mp1;\\n    vector<string> dic;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n=keys.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp1[keys[i]]=values[i];\\n        }\\n        dic=dictionary;\\n    }\\n    string encrypt(string word1) {\\n     string ans=\"\";\\n        for(char ch:word1)\\n        {\\n            if(mp1.find(ch)==mp1.end())\\n            return \"\";\\n            ans+=mp1[ch];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        int ans=0;\\n        for(auto str:dic)\\n        {\\n          if(encrypt(str)==word2)\\n          ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920780,
                "title": "a-few-solutions",
                "content": "Encrypt each string `s` of the input array `A` as `t` and track the count `cnt` of each successfully encrypted `t`.  We use a map `m` to associate each `i`<sup>th</sup> input character of `C` with the corresponding `i`<sup>th</sup> input string of `S` for encryption.\\n\\nNote: we know the encryption successfully transforms input string `s` into output string `t` when the cardinality of `s` is equal to the cardinality of `t` divided evenly by `2` since each single character is encoded as two characters.\\n* `2 * |s| == |t|`\\n\\n---\\n\\n*Kotlin*\\n```\\ntypealias CA = CharArray\\ntypealias AS = Array<String>\\nclass Encrypter(C: CA, S: AS, A: AS) {\\n    private var m = mutableMapOf<Char, String>()\\n    private var cnt = mutableMapOf<String, Int>()\\n    var encrypt = { s: String -> s.toCharArray().map{ m[it] ?: \"\" }.joinToString(\"\") }\\n    var decrypt = { s: String -> cnt[s] ?: 0 }\\n    init {\\n        m = (C zip S).toMap().toMutableMap()\\n        for (s in A) {\\n            var t = encrypt(s)\\n            if (2 * s.length == t.length)\\n                cnt[t] = 1 + (cnt[t] ?: 0)\\n        }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nclass Encrypter {\\n    constructor(C, S, A) {\\n        this.m = new Map(_.zip(C, S));\\n        this.cnt = new Map();\\n        for (let s of A) {\\n            let t = this.encrypt(s);\\n            if (2 * s.length == t.length)\\n                this.cnt.set(t, 1 + (this.cnt.get(t) || 0));\\n        }\\n    }\\n    encrypt = s => s.split(\\'\\').map(c => this.m.get(c) || \\'\\').join(\\'\\');\\n    decrypt = s => this.cnt.get(s) || 0;\\n}\\n```\\n\\n*Python3*\\n```\\nclass Encrypter:\\n    def __init__(self, C, S, A):\\n        self.m = { c: s for c, s in zip(C, S) }\\n        self.cnt = defaultdict(int)\\n        for s in A:\\n            t = self.encrypt(s)\\n            if 2 * len(s) == len(t):\\n                self.cnt[t] += 1\\n    encrypt = lambda self, s: \\'\\'.join(self.m[c] for c in list(s) if c in self.m)\\n    decrypt = lambda self, s: self.cnt[s]\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashMap;\\nstruct Encrypter {\\n    m: HashMap<char, String>,\\n    cnt: HashMap<String, i32>\\n}\\ntype VC = Vec<char>;\\ntype VS = Vec<String>;\\nimpl Encrypter {\\n    fn new(C: VC, S: VS, A: VS) -> Self {\\n        let mut m = HashMap::new();\\n        let mut cnt = HashMap::new();\\n        for (c, s) in C.iter().zip(S.iter()) {\\n            m.insert(*c, s.clone());\\n        }\\n        let mut me = Encrypter{ m, cnt };\\n        for s in A {\\n            let t = Self::encrypt(&mut me, s.clone());\\n            if 2 * s.len() == t.len() {\\n                *me.cnt.entry(t).or_insert(0) += 1;\\n            }\\n        }\\n        me\\n    }\\n    fn encrypt(&mut self, s: String) -> String {\\n        let mut t = String::new();\\n        for c in s.chars() {\\n            if let Some(x) = self.m.get(&c) {\\n                t.push_str(x.as_str());\\n            }\\n        }\\n        t\\n    }\\n    fn decrypt(&mut self, s: String) -> i32 {\\n        *self.cnt.entry(s).or_insert(0)\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Encrypter {\\npublic:\\n    using VC = vector<char>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<char, string>;\\n    using Counter = unordered_map<string, int>;\\n    Map m;\\n    Counter cnt;\\n    Encrypter(VC& C, VS& S, VS& A) {\\n        for (auto i{ 0 }; i < C.size(); ++i)\\n            m[C[i]] = S[i];\\n        for (auto& s: A) {\\n            auto t = encrypt(s);\\n            if (2 * s.size() == t.size())\\n                ++cnt[t];\\n        }\\n    }\\n    string encrypt(string s) {\\n        ostringstream os;\\n        transform(s.begin(), s.end(), ostream_iterator<string>(os, \"\"), [&](auto c) { return m[c]; });\\n        return os.str();\\n    }\\n    int decrypt(string s) {\\n        return cnt[s];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypealias CA = CharArray\\ntypealias AS = Array<String>\\nclass Encrypter(C: CA, S: AS, A: AS) {\\n    private var m = mutableMapOf<Char, String>()\\n    private var cnt = mutableMapOf<String, Int>()\\n    var encrypt = { s: String -> s.toCharArray().map{ m[it] ?: \"\" }.joinToString(\"\") }\\n    var decrypt = { s: String -> cnt[s] ?: 0 }\\n    init {\\n        m = (C zip S).toMap().toMutableMap()\\n        for (s in A) {\\n            var t = encrypt(s)\\n            if (2 * s.length == t.length)\\n                cnt[t] = 1 + (cnt[t] ?: 0)\\n        }\\n    }\\n}\\n```\n```\\nclass Encrypter {\\n    constructor(C, S, A) {\\n        this.m = new Map(_.zip(C, S));\\n        this.cnt = new Map();\\n        for (let s of A) {\\n            let t = this.encrypt(s);\\n            if (2 * s.length == t.length)\\n                this.cnt.set(t, 1 + (this.cnt.get(t) || 0));\\n        }\\n    }\\n    encrypt = s => s.split(\\'\\').map(c => this.m.get(c) || \\'\\').join(\\'\\');\\n    decrypt = s => this.cnt.get(s) || 0;\\n}\\n```\n```\\nclass Encrypter:\\n    def __init__(self, C, S, A):\\n        self.m = { c: s for c, s in zip(C, S) }\\n        self.cnt = defaultdict(int)\\n        for s in A:\\n            t = self.encrypt(s)\\n            if 2 * len(s) == len(t):\\n                self.cnt[t] += 1\\n    encrypt = lambda self, s: \\'\\'.join(self.m[c] for c in list(s) if c in self.m)\\n    decrypt = lambda self, s: self.cnt[s]\\n```\n```\\nuse std::collections::HashMap;\\nstruct Encrypter {\\n    m: HashMap<char, String>,\\n    cnt: HashMap<String, i32>\\n}\\ntype VC = Vec<char>;\\ntype VS = Vec<String>;\\nimpl Encrypter {\\n    fn new(C: VC, S: VS, A: VS) -> Self {\\n        let mut m = HashMap::new();\\n        let mut cnt = HashMap::new();\\n        for (c, s) in C.iter().zip(S.iter()) {\\n            m.insert(*c, s.clone());\\n        }\\n        let mut me = Encrypter{ m, cnt };\\n        for s in A {\\n            let t = Self::encrypt(&mut me, s.clone());\\n            if 2 * s.len() == t.len() {\\n                *me.cnt.entry(t).or_insert(0) += 1;\\n            }\\n        }\\n        me\\n    }\\n    fn encrypt(&mut self, s: String) -> String {\\n        let mut t = String::new();\\n        for c in s.chars() {\\n            if let Some(x) = self.m.get(&c) {\\n                t.push_str(x.as_str());\\n            }\\n        }\\n        t\\n    }\\n    fn decrypt(&mut self, s: String) -> i32 {\\n        *self.cnt.entry(s).or_insert(0)\\n    }\\n}\\n```\n```\\nclass Encrypter {\\npublic:\\n    using VC = vector<char>;\\n    using VS = vector<string>;\\n    using Map = unordered_map<char, string>;\\n    using Counter = unordered_map<string, int>;\\n    Map m;\\n    Counter cnt;\\n    Encrypter(VC& C, VS& S, VS& A) {\\n        for (auto i{ 0 }; i < C.size(); ++i)\\n            m[C[i]] = S[i];\\n        for (auto& s: A) {\\n            auto t = encrypt(s);\\n            if (2 * s.size() == t.size())\\n                ++cnt[t];\\n        }\\n    }\\n    string encrypt(string s) {\\n        ostringstream os;\\n        transform(s.begin(), s.end(), ostream_iterator<string>(os, \"\"), [&](auto c) { return m[c]; });\\n        return os.str();\\n    }\\n    int decrypt(string s) {\\n        return cnt[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915722,
                "title": "c-using-two-hashmaps-easy-understanding-fastest",
                "content": "Here\\'s the trick:\\nDo not generate all the possible strings after decryption and then count the occurrences in dictionary, TAKE THE REVERSE WAY, encrypt the dictionary and store it in a map, now just return the number of occurrences in that map of the desired string to be decrypted.\\n\\nWe can create 2 hashmaps, \\n- one to map the keys to value, so that we can instantly get the corresponding encryption of a character in O(1) for the encryption method.\\n- other for decryption method, to encrypt all the strings in the dictionary and count the occurences. Now whenever we get a call to decrypt a string, we can direct look it up in the hashmap, and return the count instead of actually decrypting it and checking if it exists in the dictionary.\\n\\nThe Code below would make it much clearer. \\n\\n```\\nclass Encrypter {\\npublic:\\n  unordered_map<char, string> encDict;\\n  unordered_map<string, int> decDict;\\n  \\n  Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n    for(int i=0; i<keys.size(); i++) {\\n      encDict[keys[i]] = values[i];\\n    }\\n    for(auto i:dictionary) {\\n      string tmp = encrypt(i);\\n      if(tmp.size())\\n        decDict[tmp]++;\\n    }\\n  }\\n\\n  string encrypt(string word1) {\\n    string encrypted = \"\";\\n    for(auto i:word1) {\\n      if(encDict[i]==\"\") return \"\";\\n      encrypted += encDict[i];\\n    }\\n    return encrypted;\\n  }\\n\\n  int decrypt(string word2) {    \\n    return decDict[word2];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n  unordered_map<char, string> encDict;\\n  unordered_map<string, int> decDict;\\n  \\n  Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n    for(int i=0; i<keys.size(); i++) {\\n      encDict[keys[i]] = values[i];\\n    }\\n    for(auto i:dictionary) {\\n      string tmp = encrypt(i);\\n      if(tmp.size())\\n        decDict[tmp]++;\\n    }\\n  }\\n\\n  string encrypt(string word1) {\\n    string encrypted = \"\";\\n    for(auto i:word1) {\\n      if(encDict[i]==\"\") return \"\";\\n      encrypted += encDict[i];\\n    }\\n    return encrypted;\\n  }\\n\\n  int decrypt(string word2) {    \\n    return decDict[word2];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915491,
                "title": "test-cases-can-be-passed-using-a-simple-cache",
                "content": "The Time Limit Exceeded  cases (e.g case 201) rely on sending the same input over and over. If one adds a simple cache those cases get passed and the solution gets Accepted, despite it not being the intention.\\n\\nThere needs to be cases that lead to TLE using different inputs for each one to avoid this issue.",
                "solutionTags": [],
                "code": "The Time Limit Exceeded  cases (e.g case 201) rely on sending the same input over and over. If one adds a simple cache those cases get passed and the solution gets Accepted, despite it not being the intention.\\n\\nThere needs to be cases that lead to TLE using different inputs for each one to avoid this issue.",
                "codeTag": "Unknown"
            },
            {
                "id": 1915086,
                "title": "javascript-two-hashmaps",
                "content": "```\\nclass Encrypter {\\n  constructor(keys, values, dictionary) {\\n    this.mapKeyToValue = {};\\n    this.mapCount = {};\\n    const n = keys.length;\\n\\n    for (let i = 0; i < n; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.mapKeyToValue[key] = value;\\n    }\\n\\n    for (const dict of dictionary) {\\n      const encrypted = this.encrypt(dict);\\n      this.mapCount[encrypted] = (this.mapCount[encrypted] || 0) + 1;\\n    }\\n  }\\n\\n  encrypt(word1) {\\n    let res = \\'\\';\\n    for (const char of word1) {\\n      res += this.mapKeyToValue[char];\\n    }\\n    return res;\\n  }\\n\\n  decrypt(word2) {\\n    return this.mapCount[word2] || 0;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n  constructor(keys, values, dictionary) {\\n    this.mapKeyToValue = {};\\n    this.mapCount = {};\\n    const n = keys.length;\\n\\n    for (let i = 0; i < n; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.mapKeyToValue[key] = value;\\n    }\\n\\n    for (const dict of dictionary) {\\n      const encrypted = this.encrypt(dict);\\n      this.mapCount[encrypted] = (this.mapCount[encrypted] || 0) + 1;\\n    }\\n  }\\n\\n  encrypt(word1) {\\n    let res = \\'\\';\\n    for (const char of word1) {\\n      res += this.mapKeyToValue[char];\\n    }\\n    return res;\\n  }\\n\\n  decrypt(word2) {\\n    return this.mapCount[word2] || 0;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911392,
                "title": "easy-to-understand-cpp",
                "content": "```\\nclass Encrypter {\\n    map<char,int> k;\\n    map<int,string> v;\\n    map<string,int> cnt;\\n    set<string> dic;\\n    map<string,int> freq;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)k[keys[i]]=i;\\n        for(int i=0;i<values.size();i++)v[i]=values[i];\\n        \\n        for(auto &x:values)cnt[x]++;\\n        \\n        for(auto &x:dictionary){\\n            string enc=encrypt(x);\\n            freq[enc]++;\\n        }\\n        // dic.insert(x);        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(auto &x:word1){\\n            int tem=k[x];\\n            string s=v[tem];\\n            ans+=s;\\n        }\\n        return ans;        \\n    }\\n    \\n    int decrypt(string word2) {\\n        // if(dic.find(word2)==dic.end())return 0;\\n        int ans=1;\\n        \\n        \\n        return freq[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,int> k;\\n    map<int,string> v;\\n    map<string,int> cnt;\\n    set<string> dic;\\n    map<string,int> freq;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)k[keys[i]]=i;\\n        for(int i=0;i<values.size();i++)v[i]=values[i];\\n        \\n        for(auto &x:values)cnt[x]++;\\n        \\n        for(auto &x:dictionary){\\n            string enc=encrypt(x);\\n            freq[enc]++;\\n        }\\n        // dic.insert(x);        \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(auto &x:word1){\\n            int tem=k[x];\\n            string s=v[tem];\\n            ans+=s;\\n        }\\n        return ans;        \\n    }\\n    \\n    int decrypt(string word2) {\\n        // if(dic.find(word2)==dic.end())return 0;\\n        int ans=1;\\n        \\n        \\n        return freq[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1911274,
                "title": "python-trie",
                "content": "Build the trie with encrypted strings in the dictionary. Use c[\\'#\\'] to store the number of occurence. \\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                cur[c]={}\\n            cur = cur[c]\\n        if \\'#\\' not in cur:\\n            cur[\\'#\\'] = 1\\n        else:\\n            cur[\\'#\\'] += 1\\n    \\n    def get(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                return 0\\n            cur = cur[c]\\n        if \\'#\\' in cur:\\n            return cur[\\'#\\']\\n        else:\\n            return 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        n = len(keys)\\n        self.dic = defaultdict(str)\\n        for i in range(n):\\n            self.dic[keys[i]] = values[i]\\n        \\n        self.T = Trie()\\n        for di in dictionary:\\n            ndi = [self.dic[c] for c in di]\\n            self.T.add(\\'\\'.join(ndi))\\n\\n    def encrypt(self, word1: str) -> str:\\n        ns = [self.dic[c] for c in word1]\\n        return \\'\\'.join(ns)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.T.get(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.trie = {}\\n    \\n    def add(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                cur[c]={}\\n            cur = cur[c]\\n        if \\'#\\' not in cur:\\n            cur[\\'#\\'] = 1\\n        else:\\n            cur[\\'#\\'] += 1\\n    \\n    def get(self,s):\\n        cur = self.trie\\n        ns = len(s)\\n        for i in range(0,ns,2):\\n            c = s[i:i+2]\\n            if c not in cur:\\n                return 0\\n            cur = cur[c]\\n        if \\'#\\' in cur:\\n            return cur[\\'#\\']\\n        else:\\n            return 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        n = len(keys)\\n        self.dic = defaultdict(str)\\n        for i in range(n):\\n            self.dic[keys[i]] = values[i]\\n        \\n        self.T = Trie()\\n        for di in dictionary:\\n            ndi = [self.dic[c] for c in di]\\n            self.T.add(\\'\\'.join(ndi))\\n\\n    def encrypt(self, word1: str) -> str:\\n        ns = [self.dic[c] for c in word1]\\n        return \\'\\'.join(ns)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.T.get(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909405,
                "title": "javascript-brain-teaser-390ms",
                "content": "for decrypt() first thinking is do backtracking, and check if match to any of them in dictionary, this way I tried get TLE with 201/203 passed (don\\'t know how to improve)\\n\\nThen I figure out what we need to do is just encrypt each string in dictionary, and see if it match to decrypt (^_^)\\n```\\n// template: {value: array indices increasing order}\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v), memo = new Map();\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) { // reverse thinking\\n        if (memo.has(s)) return memo.get(s);\\n        let res = 0;\\n        for (const dic of dict) {\\n            if (encrypt(dic) == s) res++;\\n        }\\n        memo.set(s, res);\\n        return res;\\n    }\\n}\\n```\\nbacktracking tried version, not working TLE 201/203 passed\\n```\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v);\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) {\\n        let n = s.length, res = 0;\\n        function dfs(pos, cur) {\\n            if (pos == n) {\\n                let t = cur.join(\"\");\\n                if (dict.has(t)) res++;\\n                return;\\n            }\\n            for (let i = pos; i < n; i++) {\\n                let next = s.slice(pos, i + 1); // find next substring/array\\n                if (!mv.has(next)) continue;\\n                let ia = mv.get(next) || [];\\n                for (const idx of ia) {\\n                    cur.push(k[idx]);\\n                    dfs(i + 1, cur);\\n                    cur.pop();\\n                }\\n            }\\n        }\\n        dfs(0, []);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n// template: {value: array indices increasing order}\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v), memo = new Map();\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) { // reverse thinking\\n        if (memo.has(s)) return memo.get(s);\\n        let res = 0;\\n        for (const dic of dict) {\\n            if (encrypt(dic) == s) res++;\\n        }\\n        memo.set(s, res);\\n        return res;\\n    }\\n}\\n```\n```\\nconst counter_value_in_indexA_in = (a_or_s) => { let m = new Map(); let n = a_or_s.length; for (let i = 0; i < n; i++) { if (!m.has(a_or_s[i])) m.set(a_or_s[i], []); m.get(a_or_s[i]).push(i); } return m; };\\n\\nfunction Encrypter(k, v, dict) {\\n    dict = new Set(dict);\\n    let mk = counter_value_in_indexA_in(k), mv = counter_value_in_indexA_in(v);\\n    return { encrypt, decrypt }\\n    function encrypt(s) {\\n        let res = \\'\\';\\n        for (const c of s) {\\n            let i = mk.get(c)[0];\\n            res += v[i];\\n        }\\n        return res;\\n    }\\n    function decrypt(s) {\\n        let n = s.length, res = 0;\\n        function dfs(pos, cur) {\\n            if (pos == n) {\\n                let t = cur.join(\"\");\\n                if (dict.has(t)) res++;\\n                return;\\n            }\\n            for (let i = pos; i < n; i++) {\\n                let next = s.slice(pos, i + 1); // find next substring/array\\n                if (!mv.has(next)) continue;\\n                let ia = mv.get(next) || [];\\n                for (const idx of ia) {\\n                    cur.push(k[idx]);\\n                    dfs(i + 1, cur);\\n                    cur.pop();\\n                }\\n            }\\n        }\\n        dfs(0, []);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909305,
                "title": "python-simple-short-and-easy-to-understand",
                "content": "```\\nfrom collections import defaultdict\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = { key:val for key, val in zip(keys, values)}\\n        self.decryptCount = defaultdict(lambda:0)\\n        \\n        for word in dictionary:\\n            self.decryptCount[\"\".join([self.keys[ch] for ch in word])]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join([self.keys[ch] for ch in word1])\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decryptCount[word2]\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = { key:val for key, val in zip(keys, values)}\\n        self.decryptCount = defaultdict(lambda:0)\\n        \\n        for word in dictionary:\\n            self.decryptCount[\"\".join([self.keys[ch] for ch in word])]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join([self.keys[ch] for ch in word1])\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.decryptCount[word2]\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909172,
                "title": "c-using-hashmap-preprocessing",
                "content": "Simply, encrypt all the strings of *dictionary* in the constructor only and then store the frequency of the encoded string in the *dict* map. Then, return the frequency of the encoded string from the *dict* map int the **decrpyt** method.\\n\\n```\\nclass Encrypter\\n{\\npublic:\\n    unordered_map<char, string> kv;\\n    unordered_map<string,int> dict;\\n    Encrypter(vector<char> &keys, vector<string> &values, vector<string> &dictionary) {\\n        for (int i = 0; i < size(keys); i++)\\n            kv[keys[i]] = values[i];\\n        for(auto str: dictionary)\\n            dict[encrypt(str)]++;\\n    }\\n    \\n    string encrypt(string w) {\\n        string s = \"\";\\n        for (int i = 0; i < size(w); i++)\\n            s += kv[w[i]];\\n        return s;\\n    }\\n    \\n    int decrypt(string w) {\\n        return dict[w];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter\\n{\\npublic:\\n    unordered_map<char, string> kv;\\n    unordered_map<string,int> dict;\\n    Encrypter(vector<char> &keys, vector<string> &values, vector<string> &dictionary) {\\n        for (int i = 0; i < size(keys); i++)\\n            kv[keys[i]] = values[i];\\n        for(auto str: dictionary)\\n            dict[encrypt(str)]++;\\n    }\\n    \\n    string encrypt(string w) {\\n        string s = \"\";\\n        for (int i = 0; i < size(w); i++)\\n            s += kv[w[i]];\\n        return s;\\n    }\\n    \\n    int decrypt(string w) {\\n        return dict[w];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909139,
                "title": "easy-map-solution-in-c-with-comments-without-trie",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m1;\\n    map<string,vector<char>> m2;\\n    map<string,int> m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];  //store value of key\\n            m2[values[i]].push_back(keys[i]); //store key of value\\n        }\\n        for(int i=0;i<dic.size();i++)\\n        {\\n\\t\\t\\t//count the frequency of given text in encrypted form\\n            string sa=encrypt(dic[i]); \\n            m3[sa]++;\\n        }\\n    }\\n    string encrypt(string word1) {\\n        string s1;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            s1+=m1[word1[i]];\\n        }\\n        return s1;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m1;\\n    map<string,vector<char>> m2;\\n    map<string,int> m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];  //store value of key\\n            m2[values[i]].push_back(keys[i]); //store key of value\\n        }\\n        for(int i=0;i<dic.size();i++)\\n        {\\n\\t\\t\\t//count the frequency of given text in encrypted form\\n            string sa=encrypt(dic[i]); \\n            m3[sa]++;\\n        }\\n    }\\n    string encrypt(string word1) {\\n        string s1;\\n        for(int i=0;i<word1.size();i++)\\n        {\\n            s1+=m1[word1[i]];\\n        }\\n        return s1;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1909130,
                "title": "by-using-three-maps",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string>m1;\\n    unordered_map<string,vector<char>>m2;\\n    unordered_map<string,int>m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]]=values[i];\\n            m2[values[i]].push_back(keys[i]);\\n        }\\n        for(int i=0;i<dictionary.size();i++) {\\n            string ss=encrypt(dictionary[i]);\\n            m3[ss]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ss;\\n        for(int i=0;i<word1.size();i++){\\n            ss+=m1[word1[i]];\\n        }\\n        return ss;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string>m1;\\n    unordered_map<string,vector<char>>m2;\\n    unordered_map<string,int>m3;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]]=values[i];\\n            m2[values[i]].push_back(keys[i]);\\n        }\\n        for(int i=0;i<dictionary.size();i++) {\\n            string ss=encrypt(dictionary[i]);\\n            m3[ss]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ss;\\n        for(int i=0;i<word1.size();i++){\\n            ss+=m1[word1[i]];\\n        }\\n        return ss;\\n    }\\n    int decrypt(string word2) {\\n        return m3[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909101,
                "title": "java-trie",
                "content": "\\tclass TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        \\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n    \\n    Map<Character, String> key2value;\\n    Map<String, Set<Character>> value2key;\\n    TrieNode root;\\n    \\n    private void insert(String word, TrieNode root){\\n        TrieNode cur = root;\\n        for(int i = 0; i < word.length(); i++){\\n            char c = word.charAt(i);\\n            if(cur.children[c - \\'a\\'] == null)\\n                cur.children[c - \\'a\\'] = new TrieNode();\\n            cur = cur.children[c - \\'a\\'];\\n            if(i == word.length() - 1){\\n                cur.isWord = true;\\n            }\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        key2value = new HashMap<>();\\n        value2key = new HashMap<>();\\n        root = new TrieNode();\\n        for(int i = 0; i < keys.length; i++){\\n            char key = keys[i];\\n            String value = values[i];\\n            key2value.put(key, value);\\n            value2key.putIfAbsent(value, new HashSet<Character>());\\n            value2key.get(value).add(key);\\n        }\\n        for(String s: dictionary){\\n            insert(s, root);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < word1.length(); i++){\\n            sb.append(key2value.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int[] res = new int[1];\\n        dfs(word2, 0, res, this.root);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String s, int idx, int[] res, TrieNode root){\\n        if(idx == s.length() && root.isWord){\\n            res[0]++;\\n            return;\\n        }\\n        if(idx >= s.length()){\\n            return;\\n        }\\n        String str = s.substring(idx, idx + 2);\\n        if(!value2key.containsKey(str)){\\n            return;\\n        }\\n        for(char cha: value2key.get(str)){\\n            if(root.children[cha - \\'a\\'] != null){\\n                dfs(s, idx + 2, res, root.children[cha - \\'a\\']);\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "\\tclass TrieNode{\\n        TrieNode[] children;\\n        boolean isWord;\\n        \\n        public TrieNode(){\\n            children = new TrieNode[26];\\n            isWord = false;\\n        }\\n    }\\n    \\n    Map<Character, String> key2value;\\n    Map<String, Set<Character>> value2key;\\n    TrieNode root;\\n    \\n    private void insert(String word, TrieNode root){\\n        TrieNode cur = root;\\n        for(int i = 0; i < word.length(); i++){\\n            char c = word.charAt(i);\\n            if(cur.children[c - \\'a\\'] == null)\\n                cur.children[c - \\'a\\'] = new TrieNode();\\n            cur = cur.children[c - \\'a\\'];\\n            if(i == word.length() - 1){\\n                cur.isWord = true;\\n            }\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        key2value = new HashMap<>();\\n        value2key = new HashMap<>();\\n        root = new TrieNode();\\n        for(int i = 0; i < keys.length; i++){\\n            char key = keys[i];\\n            String value = values[i];\\n            key2value.put(key, value);\\n            value2key.putIfAbsent(value, new HashSet<Character>());\\n            value2key.get(value).add(key);\\n        }\\n        for(String s: dictionary){\\n            insert(s, root);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < word1.length(); i++){\\n            sb.append(key2value.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int[] res = new int[1];\\n        dfs(word2, 0, res, this.root);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String s, int idx, int[] res, TrieNode root){\\n        if(idx == s.length() && root.isWord){\\n            res[0]++;\\n            return;\\n        }\\n        if(idx >= s.length()){\\n            return;\\n        }\\n        String str = s.substring(idx, idx + 2);\\n        if(!value2key.containsKey(str)){\\n            return;\\n        }\\n        for(char cha: value2key.get(str)){\\n            if(root.children[cha - \\'a\\'] != null){\\n                dfs(s, idx + 2, res, root.children[cha - \\'a\\']);\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1909063,
                "title": "cheated-solution-make-this-a-easy-problem",
                "content": "Instead of really solving this problem, as the dictionary is super short, we can just do a encryption of all of them when initialize, and store the encrpted->count map.\\n\\n\\n```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> m;\\n    unordered_map<string, int> count;\\n    \\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for (int i = 0; i < K.size(); ++i) \\n            m[K[i]] = V[i];\\n        \\n        for (string& s : D) {\\n            string en_s = encrypt(s);\\n            count[en_s]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret = \"\";\\n        for (char& c : word1) ret += m[c];\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> m;\\n    unordered_map<string, int> count;\\n    \\n    Encrypter(vector<char>& K, vector<string>& V, vector<string>& D) {\\n        for (int i = 0; i < K.size(); ++i) \\n            m[K[i]] = V[i];\\n        \\n        for (string& s : D) {\\n            string en_s = encrypt(s);\\n            count[en_s]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret = \"\";\\n        for (char& c : word1) ret += m[c];\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return count[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909016,
                "title": "hash-map-bruteforce",
                "content": "\\n```\\nclass Encrypter {\\npublic:\\n    map<char,string> m;\\n    map<string,int> com;\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        for(int i=0; i<k.size(); ++i)\\n        {\\n            m[k[i]] = v[i];\\n            // mm[v[i]].push_back(k[i]);\\n        }\\n        \\n        for(int i=0; i<d.size(); ++i)\\n        {\\n            string ans = \"\";\\n            for(int j=0; j<d[i].size(); ++j)\\n            {\\n                ans+=m[d[i][j]];\\n            }\\n            com[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        \\n        string ans = \"\";\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            ans+=m[s[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string s) {\\n        \\n        if(com.count(s))\\n            return com[s];\\n        \\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string> m;\\n    map<string,int> com;\\n    Encrypter(vector<char>& k, vector<string>& v, vector<string>& d) {\\n        for(int i=0; i<k.size(); ++i)\\n        {\\n            m[k[i]] = v[i];\\n            // mm[v[i]].push_back(k[i]);\\n        }\\n        \\n        for(int i=0; i<d.size(); ++i)\\n        {\\n            string ans = \"\";\\n            for(int j=0; j<d[i].size(); ++j)\\n            {\\n                ans+=m[d[i][j]];\\n            }\\n            com[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string s) {\\n        \\n        string ans = \"\";\\n        \\n        for(int i=0; i<s.size(); ++i)\\n        {\\n            ans+=m[s[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string s) {\\n        \\n        if(com.count(s))\\n            return com[s];\\n        \\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908959,
                "title": "easy-trie-bfs-python-optimized-code",
                "content": "**Solution 1: Trie**\\n\\n1. Use a trie to store the target words of dict\\n2. Find all combinations using a lookup dict.\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.child = defaultdict()\\n        self.present = False\\n        \\nclass Encrypter:\\n\\n    def insert(self,s):\\n        p = self.t\\n        for ch in s:\\n            if ch not in p.child:\\n                p.child[ch] = Trie()\\n            p = p.child[ch]\\n        p.present = True\\n    \\n    def __init__(self, k: List[str], v: List[str], target_dict: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.t = Trie()\\n        self.max_d_word_len = 0\\n        for s in target_dict:\\n            flag = True\\n            for ch in s:\\n                if ch not in self.d:\\n                    flag = False\\n                    break\\n            if flag:\\n                self.max_d_word_len = max(self.max_d_word_len, len(s))\\n                self.insert(s)\\n        \\n        self.rev = defaultdict(list)\\n        for i in range(len(k)):\\n            self.rev[v[i]].append(k[i])\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n      \\n        if len(s)//2 > self.max_d_word_len:\\n            return 0\\n        \\n        p = self.t        \\n        q = deque()\\n        q.append([0,p]) # index in s, ptr to trie\\n        cnt = 0\\n\\n        while q:\\n            i, p = q.popleft()\\n            \\n            if i == len(s):\\n                if p.present:\\n                    cnt += 1\\n                continue\\n            \\n            for k in self.rev[s[i:i+2]]:\\n                if k not in p.child:\\n                    continue\\n                t = p.child[k]\\n                q.append([i+2,t])\\n            \\n        return cnt\\n```\\n\\n**Solution 2:**\\n\\nInstead of decrypting result for each decrypt() call and then matching it with target list.\\nEncrypt the words in target list and count them. \\nSo each decrypt call can look it up in dict.\\n```\\nclass Encrypter:\\n    \\n    def __init__(self, k: List[str], v: List[str], target: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.encrypt_target = defaultdict(int)\\n        for val in target:\\n            self.encrypt_target[self.encrypt(val)] += 1\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n        return self.encrypt_target[s]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.child = defaultdict()\\n        self.present = False\\n        \\nclass Encrypter:\\n\\n    def insert(self,s):\\n        p = self.t\\n        for ch in s:\\n            if ch not in p.child:\\n                p.child[ch] = Trie()\\n            p = p.child[ch]\\n        p.present = True\\n    \\n    def __init__(self, k: List[str], v: List[str], target_dict: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.t = Trie()\\n        self.max_d_word_len = 0\\n        for s in target_dict:\\n            flag = True\\n            for ch in s:\\n                if ch not in self.d:\\n                    flag = False\\n                    break\\n            if flag:\\n                self.max_d_word_len = max(self.max_d_word_len, len(s))\\n                self.insert(s)\\n        \\n        self.rev = defaultdict(list)\\n        for i in range(len(k)):\\n            self.rev[v[i]].append(k[i])\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n      \\n        if len(s)//2 > self.max_d_word_len:\\n            return 0\\n        \\n        p = self.t        \\n        q = deque()\\n        q.append([0,p]) # index in s, ptr to trie\\n        cnt = 0\\n\\n        while q:\\n            i, p = q.popleft()\\n            \\n            if i == len(s):\\n                if p.present:\\n                    cnt += 1\\n                continue\\n            \\n            for k in self.rev[s[i:i+2]]:\\n                if k not in p.child:\\n                    continue\\n                t = p.child[k]\\n                q.append([i+2,t])\\n            \\n        return cnt\\n```\n```\\nclass Encrypter:\\n    \\n    def __init__(self, k: List[str], v: List[str], target: List[str]):\\n        self.d = {k[i]:v[i] for i in range(len(k))}\\n        self.encrypt_target = defaultdict(int)\\n        for val in target:\\n            self.encrypt_target[self.encrypt(val)] += 1\\n            \\n    def encrypt(self, s: str) -> str:\\n        res = \"\"\\n        for ch in s:\\n            res += self.d[ch]\\n        return res\\n\\n    def decrypt(self, s: str) -> int:\\n        return self.encrypt_target[s]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908949,
                "title": "python-10-liner-o-1-for-decrypt",
                "content": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_to_value = {k: v for k, v in zip(keys, values)}\\n        self.counter = Counter([self.encrypt(word) for word in dictionary])\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.key_to_value[char] for char in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.counter[word2]\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_to_value = {k: v for k, v in zip(keys, values)}\\n        self.counter = Counter([self.encrypt(word) for word in dictionary])\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join([self.key_to_value[char] for char in word1])\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.counter[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908938,
                "title": "simple-java-solution-precompute-o-1-decrypt",
                "content": "Idea is pre-encryting the word in dictionary and store the count in a map. When doing decryption, simply check the map and return the count.\\n```\\nclass Encrypter {\\n    Map<Character, Integer> keyIndexMap = new HashMap<>();\\n    Map<String, Integer> dictCountMap = new HashMap<>();\\n    String[] values;\\n    String[] dictionary;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0; i < keys.length; i++) {\\n            this.keyIndexMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n\\t\\t// precompute the encrypted value of all words in dict\\n        for(int i = 0; i < dictionary.length; i++) {\\n            dictionary[i] = encrypt(dictionary[i]);\\n            dictCountMap.put(dictionary[i], dictCountMap.getOrDefault(dictionary[i], 0) + 1);\\n        }\\n        this.dictionary = dictionary;\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] charArray = word1.toCharArray();\\n        StringBuilder builder = new StringBuilder();\\n        for(char c: charArray) {\\n            int index = keyIndexMap.get(c);\\n            builder.append(values[index]);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictCountMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    Map<Character, Integer> keyIndexMap = new HashMap<>();\\n    Map<String, Integer> dictCountMap = new HashMap<>();\\n    String[] values;\\n    String[] dictionary;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0; i < keys.length; i++) {\\n            this.keyIndexMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n\\t\\t// precompute the encrypted value of all words in dict\\n        for(int i = 0; i < dictionary.length; i++) {\\n            dictionary[i] = encrypt(dictionary[i]);\\n            dictCountMap.put(dictionary[i], dictCountMap.getOrDefault(dictionary[i], 0) + 1);\\n        }\\n        this.dictionary = dictionary;\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] charArray = word1.toCharArray();\\n        StringBuilder builder = new StringBuilder();\\n        for(char c: charArray) {\\n            int index = keyIndexMap.get(c);\\n            builder.append(values[index]);\\n        }\\n        return builder.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictCountMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908927,
                "title": "python-not-trie-just-search-on-the-dictionary",
                "content": "Instead of trie, try to search for each word in the dictionary (because the dictionary size is only 100 and each word in the dictionary is also 100):\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {}\\n        self.vk = {}\\n        for i in range(len(keys)):\\n            k, v = keys[i], values[i]\\n            self.kv[k] = values[i]\\n            \\n            if v not in self.vk:\\n                self.vk[v] = set()\\n                \\n            self.vk[v].add(k)\\n            \\n        self.dick = dictionary\\n\\n        \\n    def encrypt(self, w: str) -> str:\\n        res = \"\"\\n        for c in w:\\n            res += self.kv[c]\\n        return res\\n    \\n\\n    def decrypt(self, w: str) -> int:\\n        adj = []\\n        for i in range(2, len(w)+1, 2):\\n            cur = w[i-2:i]\\n            if cur not in self.vk:\\n                return 0\\n            adj.append(self.vk[cur])\\n                \\n        res = 0\\n        for d in self.dick:\\n            if len(d) != len(adj):\\n                continue\\n                \\n            ok = True\\n            for i in range(len(d)):\\n                if d[i] not in adj[i]:\\n                    ok = False\\n                    break\\n            if ok:\\n                res += 1\\n        \\n        return res\\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = {}\\n        self.vk = {}\\n        for i in range(len(keys)):\\n            k, v = keys[i], values[i]\\n            self.kv[k] = values[i]\\n            \\n            if v not in self.vk:\\n                self.vk[v] = set()\\n                \\n            self.vk[v].add(k)\\n            \\n        self.dick = dictionary\\n\\n        \\n    def encrypt(self, w: str) -> str:\\n        res = \"\"\\n        for c in w:\\n            res += self.kv[c]\\n        return res\\n    \\n\\n    def decrypt(self, w: str) -> int:\\n        adj = []\\n        for i in range(2, len(w)+1, 2):\\n            cur = w[i-2:i]\\n            if cur not in self.vk:\\n                return 0\\n            adj.append(self.vk[cur])\\n                \\n        res = 0\\n        for d in self.dick:\\n            if len(d) != len(adj):\\n                continue\\n                \\n            ok = True\\n            for i in range(len(d)):\\n                if d[i] not in adj[i]:\\n                    ok = False\\n                    break\\n            if ok:\\n                res += 1\\n        \\n        return res\\n        \\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908901,
                "title": "java-dfs-trie",
                "content": "This is the first time I completed all four problems~~~!!!\\n```\\nclass Encrypter {\\n    Map<Character,String> enMap;\\n    Map<String, List<Character>> deMap;\\n    Set<String> dict;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enMap = new HashMap<>();\\n        this.deMap = new HashMap<>();\\n        this.dict = new HashSet<>();\\n        \\n        for(int i = 0; i < keys.length; i++) {\\n            enMap.put(keys[i], values[i]);\\n            if(!deMap.containsKey(values[i])) {\\n                deMap.put(values[i], new ArrayList<>());\\n            }\\n            deMap.get(values[i]).add(keys[i]);\\n        }   \\n        \\n        for(String str : dictionary) {\\n            dict.add(str);\\n        }  \\n        \\n        this.root = new TrieNode();\\n        for(String str : dictionary){\\n            root.insert(root, str);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sol = new StringBuilder();\\n        for(char ch : word1.toCharArray()) {\\n            sol.append(enMap.get(ch));\\n        }\\n        return sol.toString();\\n    } \\n    \\n    public int decrypt(String word2) {\\n        int[] res = {0};\\n        StringBuilder sol = new StringBuilder();\\n        TrieNode curRoot = root;\\n        \\n        dfs(word2, curRoot, 0, sol, deMap, dict, res);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String word, TrieNode curRoot, int index, StringBuilder sol, Map<String, List<Character>> deMap, Set<String> dict, int[] res) {\\n        \\n        if(index >= word.length() - 1) {\\n            String temp = sol.toString();\\n            if(dict.contains(temp)) {\\n                res[0]++;\\n            }\\n            return;\\n        }\\n        \\n        String cur = word.substring(index, index + 2);\\n        \\n        List<Character> list = deMap.get(cur);\\n        int len = sol.length();\\n        if(list == null) {\\n            sol.append(cur);\\n            dfs(word, curRoot, index + 2, sol, deMap, dict, res);\\n            sol.setLength(len);\\n        } else {\\n            for(char c : list) {\\n                if(curRoot.children[c - \\'a\\'] == null) {\\n                    continue;\\n                }\\n                sol.append(c);\\n                dfs(word, curRoot.children[c -\\'a\\'], index + 2, sol, deMap, dict, res);\\n                sol.setLength(len);\\n            }\\n        }    \\n    }\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] children;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.children = new TrieNode[26];\\n        }\\n        \\n        public TrieNode insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            \\n            for(int i = 0; i < word.length(); i++) {\\n                if(cur.children[word.charAt(i) - \\'a\\'] == null) {\\n                    cur.children[word.charAt(i) - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[word.charAt(i) - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n            return root;\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> enMap;\\n    Map<String, List<Character>> deMap;\\n    Set<String> dict;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enMap = new HashMap<>();\\n        this.deMap = new HashMap<>();\\n        this.dict = new HashSet<>();\\n        \\n        for(int i = 0; i < keys.length; i++) {\\n            enMap.put(keys[i], values[i]);\\n            if(!deMap.containsKey(values[i])) {\\n                deMap.put(values[i], new ArrayList<>());\\n            }\\n            deMap.get(values[i]).add(keys[i]);\\n        }   \\n        \\n        for(String str : dictionary) {\\n            dict.add(str);\\n        }  \\n        \\n        this.root = new TrieNode();\\n        for(String str : dictionary){\\n            root.insert(root, str);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sol = new StringBuilder();\\n        for(char ch : word1.toCharArray()) {\\n            sol.append(enMap.get(ch));\\n        }\\n        return sol.toString();\\n    } \\n    \\n    public int decrypt(String word2) {\\n        int[] res = {0};\\n        StringBuilder sol = new StringBuilder();\\n        TrieNode curRoot = root;\\n        \\n        dfs(word2, curRoot, 0, sol, deMap, dict, res);\\n        return res[0];\\n    }\\n    \\n    private void dfs(String word, TrieNode curRoot, int index, StringBuilder sol, Map<String, List<Character>> deMap, Set<String> dict, int[] res) {\\n        \\n        if(index >= word.length() - 1) {\\n            String temp = sol.toString();\\n            if(dict.contains(temp)) {\\n                res[0]++;\\n            }\\n            return;\\n        }\\n        \\n        String cur = word.substring(index, index + 2);\\n        \\n        List<Character> list = deMap.get(cur);\\n        int len = sol.length();\\n        if(list == null) {\\n            sol.append(cur);\\n            dfs(word, curRoot, index + 2, sol, deMap, dict, res);\\n            sol.setLength(len);\\n        } else {\\n            for(char c : list) {\\n                if(curRoot.children[c - \\'a\\'] == null) {\\n                    continue;\\n                }\\n                sol.append(c);\\n                dfs(word, curRoot.children[c -\\'a\\'], index + 2, sol, deMap, dict, res);\\n                sol.setLength(len);\\n            }\\n        }    \\n    }\\n    \\n    class TrieNode {\\n        boolean isWord;\\n        TrieNode[] children;\\n        public TrieNode() {\\n            this.isWord = false;\\n            this.children = new TrieNode[26];\\n        }\\n        \\n        public TrieNode insert(TrieNode root, String word) {\\n            TrieNode cur = root;\\n            \\n            for(int i = 0; i < word.length(); i++) {\\n                if(cur.children[word.charAt(i) - \\'a\\'] == null) {\\n                    cur.children[word.charAt(i) - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[word.charAt(i) - \\'a\\'];\\n            }\\n            cur.isWord = true;\\n            return root;\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908887,
                "title": "c-rainbow-table-solution-and-trie-solution",
                "content": "#### rainbow table \\nA [rainbow table](https://en.wikipedia.org/wiki/Rainbow_table) is a precomputed table for caching the output of cryptographic hash functions, usually for cracking password hashes. \\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    unordered_map<string,int> m; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& s : dictionary) {\\n            m[encrypt(s)]++; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return m[word2];\\n    }\\n};\\n\\n```\\n#### Trie solution \\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    class Node {\\n    public:\\n        bool leaf = false; \\n        vector<Node*> children;\\n        Node() : leaf{false}, children(26,nullptr) {}\\n    };\\n    class Trie {\\n    public:\\n        Node* root = new Node(); \\n        void insert(const string& str) {\\n            auto t = root; \\n            for(char ch : str) {\\n                if(t->children[ch - \\'a\\'] == nullptr) {\\n                    t->children[ch-\\'a\\'] = new Node(); \\n                }\\n                t = t->children[ch-\\'a\\'];\\n            }\\n            t->leaf = true; \\n        }\\n    };\\n    Trie trie; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& str : dictionary) {\\n            trie.insert(str);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    int f(Node* node, const string& word2, int i) {\\n        if(node == nullptr) {\\n            return 0; \\n        }\\n        if(i == word2.size()) {\\n            if(node->leaf) {\\n                return 1;\\n            }\\n            return 0; \\n        }\\n        auto v = word2.substr(i,2);\\n        int ret = 0; \\n        for(int k : v2k[v]) {\\n            ret += f(node->children[k],word2,i+2);\\n        }\\n        return ret; \\n    }\\n    int decrypt(string word2) {\\n        return f(trie.root,word2,0); \\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    unordered_map<string,int> m; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& s : dictionary) {\\n            m[encrypt(s)]++; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return m[word2];\\n    }\\n};\\n\\n```\n```\\nclass Encrypter {\\npublic:\\n    vector<string> k2v;\\n    unordered_map<string,vector<int>> v2k; \\n    class Node {\\n    public:\\n        bool leaf = false; \\n        vector<Node*> children;\\n        Node() : leaf{false}, children(26,nullptr) {}\\n    };\\n    class Trie {\\n    public:\\n        Node* root = new Node(); \\n        void insert(const string& str) {\\n            auto t = root; \\n            for(char ch : str) {\\n                if(t->children[ch - \\'a\\'] == nullptr) {\\n                    t->children[ch-\\'a\\'] = new Node(); \\n                }\\n                t = t->children[ch-\\'a\\'];\\n            }\\n            t->leaf = true; \\n        }\\n    };\\n    Trie trie; \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) : k2v(26,\"\"){\\n        for(int i = 0;i<keys.size();i++) {\\n            k2v[keys[i] - \\'a\\'] = values[i];\\n            v2k[values[i]].push_back(keys[i] - \\'a\\');\\n        }\\n        for(auto& str : dictionary) {\\n            trie.insert(str);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ret;\\n        for(char ch : word1) {\\n            ret += k2v[ch-\\'a\\'];\\n        }\\n        return ret; \\n    }\\n    \\n    int f(Node* node, const string& word2, int i) {\\n        if(node == nullptr) {\\n            return 0; \\n        }\\n        if(i == word2.size()) {\\n            if(node->leaf) {\\n                return 1;\\n            }\\n            return 0; \\n        }\\n        auto v = word2.substr(i,2);\\n        int ret = 0; \\n        for(int k : v2k[v]) {\\n            ret += f(node->children[k],word2,i+2);\\n        }\\n        return ret; \\n    }\\n    int decrypt(string word2) {\\n        return f(trie.root,word2,0); \\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1908884,
                "title": "c-trie",
                "content": "```\\nclass TrieNode {\\npublic: \\n    TrieNode* next[26];\\n    bool is_word;\\n    TrieNode() {memset(next, 0, sizeof(next)); is_word = false;}\\n};\\n\\nclass Trie {\\npublic: \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    TrieNode* getRoot()\\n    {\\n        return root;\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* cur = root;\\n        for (auto c : word)\\n        {\\n            if (!cur->next[c - \\'a\\'])\\n                cur->next[c - \\'a\\'] = new TrieNode();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->is_word = true;\\n    }\\n    \\n    TrieNode* find(char c, TrieNode* node)\\n    {\\n        if (node->next[c - \\'a\\'])\\n            return node->next[c - \\'a\\'];\\n        else \\n            return nullptr;\\n    }\\n    \\nprivate: \\n    TrieNode* root;\\n};\\n\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n = keys.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            k2v[keys[i]] = values[i];\\n            v2k[values[i]].push_back(keys[i]);\\n        }\\n        trie = new Trie();\\n        for (auto& s : dictionary)\\n            trie->insert(s);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for (auto& c : word1)\\n            ans += k2v[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int n = word2.length(), m = n / 2;\\n        vector<vector<char>> k(m);\\n        for (int i = 0, j = 0; i < n; i += 2, j++)\\n        {\\n            k[j] = v2k[word2.substr(i, 2)];\\n            if (k[j].size() == 0)\\n                return 0;\\n        }\\n        int ans = 0;\\n        dfs(k, 0, m, trie->getRoot(), ans);\\n        return ans;\\n    }\\n    \\nprivate: \\n    unordered_map<char, string> k2v;\\n    unordered_map<string, vector<char>> v2k;\\n    Trie* trie;\\n    \\n    void dfs(vector<vector<char>>& k, int r, int& m, TrieNode* cur, int& ans)\\n    {\\n        if (r == m)\\n        {\\n            if (cur->is_word)\\n                ans++;\\n            return;\\n        }\\n        for (auto& c : k[r])\\n        {\\n            TrieNode* nxt = trie->find(c, cur);\\n            if (nxt)\\n                dfs(k, r + 1, m, nxt, ans);\\n        }\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\npublic: \\n    TrieNode* next[26];\\n    bool is_word;\\n    TrieNode() {memset(next, 0, sizeof(next)); is_word = false;}\\n};\\n\\nclass Trie {\\npublic: \\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    TrieNode* getRoot()\\n    {\\n        return root;\\n    }\\n    \\n    void insert(string word) {\\n        TrieNode* cur = root;\\n        for (auto c : word)\\n        {\\n            if (!cur->next[c - \\'a\\'])\\n                cur->next[c - \\'a\\'] = new TrieNode();\\n            cur = cur->next[c - \\'a\\'];\\n        }\\n        cur->is_word = true;\\n    }\\n    \\n    TrieNode* find(char c, TrieNode* node)\\n    {\\n        if (node->next[c - \\'a\\'])\\n            return node->next[c - \\'a\\'];\\n        else \\n            return nullptr;\\n    }\\n    \\nprivate: \\n    TrieNode* root;\\n};\\n\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        int n = keys.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            k2v[keys[i]] = values[i];\\n            v2k[values[i]].push_back(keys[i]);\\n        }\\n        trie = new Trie();\\n        for (auto& s : dictionary)\\n            trie->insert(s);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for (auto& c : word1)\\n            ans += k2v[c];\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int n = word2.length(), m = n / 2;\\n        vector<vector<char>> k(m);\\n        for (int i = 0, j = 0; i < n; i += 2, j++)\\n        {\\n            k[j] = v2k[word2.substr(i, 2)];\\n            if (k[j].size() == 0)\\n                return 0;\\n        }\\n        int ans = 0;\\n        dfs(k, 0, m, trie->getRoot(), ans);\\n        return ans;\\n    }\\n    \\nprivate: \\n    unordered_map<char, string> k2v;\\n    unordered_map<string, vector<char>> v2k;\\n    Trie* trie;\\n    \\n    void dfs(vector<vector<char>>& k, int r, int& m, TrieNode* cur, int& ans)\\n    {\\n        if (r == m)\\n        {\\n            if (cur->is_word)\\n                ans++;\\n            return;\\n        }\\n        for (auto& c : k[r])\\n        {\\n            TrieNode* nxt = trie->find(c, cur);\\n            if (nxt)\\n                dfs(k, r + 1, m, nxt, ans);\\n        }\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908873,
                "title": "c-clean-commented-code",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map <char, string> mp; // Will be used while encrypting. \\n    unordered_map <string, unordered_set<char>> allTwotoOne; // stores for each string of len 2, possible characteres it can map to\\n    unordered_set <string> dict; // our dictionary which includes valid words after decrypting.\\n\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            mp[keys[i]] = values[i]; // will be used in encryption.\\n        }\\n        for (int i = 0; i < values.size(); ++i) {\\n            allTwotoOne[values[i]].insert(keys[i]); // all possible chars which this encrypted 2 len string can decrpt to.\\n        }\\n        for (auto x : dictionary) {\\n            dict.insert(x);   // just making it global.\\n        }\\n    }   \\n    \\n    /*\\n        We can use mp to just replace each character with susbtrs of len 2.\\n    */\\n\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (auto x : word1) {\\n            res += mp[x];\\n        }\\n        return res;\\n    }\\n    /*\\n        Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\\n    */\\n    int decrypt(string word2) {\\n        int ways = 0;\\n        int enc_len = word2.size() / 2;\\n        // check for each word in dictionary, can it be formed while decyrpting string in given manner.\\n        for (auto x : dict) { \\n            if (x.size() != enc_len) continue; // prune as fast as possible.\\n            int i = 0;\\n            int can = 1;\\n            for (auto ch : x) {\\n                if (!allTwotoOne[word2.substr(i, 2)].count(ch)) { // if this 2 len substr cant decrypt to the current char of current string in dict, then break(prune)\\n                    can = 0;\\n                    break;\\n                } else { // go to next 2 len substr.\\n                    i += 2;\\n                }\\n            }\\n            ways += can;\\n        }\\n        return ways;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```\\n\\nUPvote if you liked my solution.\\nThanks.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map <char, string> mp; // Will be used while encrypting. \\n    unordered_map <string, unordered_set<char>> allTwotoOne; // stores for each string of len 2, possible characteres it can map to\\n    unordered_set <string> dict; // our dictionary which includes valid words after decrypting.\\n\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) {\\n            mp[keys[i]] = values[i]; // will be used in encryption.\\n        }\\n        for (int i = 0; i < values.size(); ++i) {\\n            allTwotoOne[values[i]].insert(keys[i]); // all possible chars which this encrypted 2 len string can decrpt to.\\n        }\\n        for (auto x : dictionary) {\\n            dict.insert(x);   // just making it global.\\n        }\\n    }   \\n    \\n    /*\\n        We can use mp to just replace each character with susbtrs of len 2.\\n    */\\n\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for (auto x : word1) {\\n            res += mp[x];\\n        }\\n        return res;\\n    }\\n    /*\\n        Returns the number of possible strings word2 could decrypt to that also appear in dictionary.\\n    */\\n    int decrypt(string word2) {\\n        int ways = 0;\\n        int enc_len = word2.size() / 2;\\n        // check for each word in dictionary, can it be formed while decyrpting string in given manner.\\n        for (auto x : dict) { \\n            if (x.size() != enc_len) continue; // prune as fast as possible.\\n            int i = 0;\\n            int can = 1;\\n            for (auto ch : x) {\\n                if (!allTwotoOne[word2.substr(i, 2)].count(ch)) { // if this 2 len substr cant decrypt to the current char of current string in dict, then break(prune)\\n                    can = 0;\\n                    break;\\n                } else { // go to next 2 len substr.\\n                    i += 2;\\n                }\\n            }\\n            ways += can;\\n        }\\n        return ways;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908865,
                "title": "java-hashing-easy-to-understand-smart-approach",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. Create an `enc` map which **stores the key value pair** of what each character will **encrypt** to.\\n2. Create a `dictionary` map which will **store the count of each encrypted word** from the `dictionary` string.\\n3. In `encrypt` function, we just take each character from `word1`, and use `enc` map to **encrypt** it.\\n4. In `decrypt` function, we just return the **count of each** `word2` from `dictionary` map.\\n\\n**Source Code:**\\n```\\nclass Encrypter {\\n    Map<Character, String> enc;\\n    Map<String, Integer> dictionary;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enc = new HashMap<>();\\n        this.dictionary = new HashMap<>();\\n        \\n        for(int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        for(String v : dictionary) {\\n            StringBuilder sb = new StringBuilder();\\n            \\n            for(char ch : v.toCharArray())\\n                sb.append(enc.get(ch));\\n            \\n            this.dictionary.put(sb.toString(), this.dictionary.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char ch : word1.toCharArray())\\n            sb.append(enc.get(ch));\\n        \\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(c * n) // c = number of calls, n = word.length\\nSpace Complexity : O(m) // m = number of dictionary words\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character, String> enc;\\n    Map<String, Integer> dictionary;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.enc = new HashMap<>();\\n        this.dictionary = new HashMap<>();\\n        \\n        for(int i = 0; i < keys.length; ++i)\\n            enc.put(keys[i], values[i]);\\n        \\n        for(String v : dictionary) {\\n            StringBuilder sb = new StringBuilder();\\n            \\n            for(char ch : v.toCharArray())\\n                sb.append(enc.get(ch));\\n            \\n            this.dictionary.put(sb.toString(), this.dictionary.getOrDefault(sb.toString(), 0) + 1);\\n        }\\n        \\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char ch : word1.toCharArray())\\n            sb.append(enc.get(ch));\\n        \\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return dictionary.getOrDefault(word2, 0);\\n    }\\n}\\n```\n```\\nTime Complexity: O(c * n) // c = number of calls, n = word.length\\nSpace Complexity : O(m) // m = number of dictionary words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908853,
                "title": "hashmap-solution-o-n-encrypt-o-1-decrypt",
                "content": "pre-built dictionary to encrypt string\\n\\n```\\nclass Encrypter {\\n\\n    Map<Character, String> keyValueMap = new HashMap<>();\\n    Map<String, Integer> encryptCntMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0; i < keys.length; i++) {\\n            keyValueMap.put(keys[i], values[i]);\\n        }\\n\\n        for (String s : dictionary) {\\n            String enc = this.encrypt(s);\\n            encryptCntMap.put(enc, encryptCntMap.getOrDefault(enc, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            sb.append(keyValueMap.get(word1.charAt(i)));\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return encryptCntMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n\\n    Map<Character, String> keyValueMap = new HashMap<>();\\n    Map<String, Integer> encryptCntMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for (int i = 0; i < keys.length; i++) {\\n            keyValueMap.put(keys[i], values[i]);\\n        }\\n\\n        for (String s : dictionary) {\\n            String enc = this.encrypt(s);\\n            encryptCntMap.put(enc, encryptCntMap.getOrDefault(enc, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < word1.length(); i++) {\\n            sb.append(keyValueMap.get(word1.charAt(i)));\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return encryptCntMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908836,
                "title": "easy-understand-code-no-dfs-no-trie-simple-logic",
                "content": "public class Encrypter {\\n\\n    HashSet<string> pString;\\n    // dictionary used for encryption\\n    Dictionary<string, HashSet<char>> rDict = new Dictionary<string, HashSet<char>>();\\n    // dictionary used for decryption\\n    Dictionary<char, string> fDict = new Dictionary<char, string>();\\n        \\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        pString = new HashSet<string>(dictionary);\\n        for (int i = 0; i < keys.Length; i++){\\n            fDict.Add(keys[i], values[i]);\\n            if (!rDict.ContainsKey(values[i]))\\n                rDict.Add(values[i], new HashSet<char>());\\n            rDict[values[i]].Add(keys[i]);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string output = \"\";\\n        foreach (char c in word1){\\n            output += fDict[c];\\n        }\\n        return output;\\n    }\\n    \\n    // Because the dictionary is smaller than 100, we basically just loop the dictionary for each number, worst time is just 100 * 100\\n    public int Decrypt(string word2) {\\n        List<string> hs = new List<string>(pString);\\n        int len = word2.Length / 2;\\n        for (int i = 0; i < len; i++){\\n            string str = word2.Substring(i*2, 2);\\n            if (!rDict.ContainsKey(str))\\n                return 0;\\n            HashSet<char> ch = rDict[str];\\n            List<string> temp = new List<string>();\\n            foreach (string h in hs){\\n                if (h.Length > i && ch.Contains(h[i]))\\n                    temp.Add(h);\\n            }\\n            if (temp.Count == 0)\\n                return 0;\\n            hs = temp;\\n        }\\n        List<string> output = new List<string>();\\n        foreach (string k in hs){\\n            if (k.Length == len)\\n                output.Add(k);\\n        }\\n\\n        return output.Count;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */",
                "solutionTags": [],
                "code": "public class Encrypter {\\n\\n    HashSet<string> pString;\\n    // dictionary used for encryption\\n    Dictionary<string, HashSet<char>> rDict = new Dictionary<string, HashSet<char>>();\\n    // dictionary used for decryption\\n    Dictionary<char, string> fDict = new Dictionary<char, string>();\\n        \\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        pString = new HashSet<string>(dictionary);\\n        for (int i = 0; i < keys.Length; i++){\\n            fDict.Add(keys[i], values[i]);\\n            if (!rDict.ContainsKey(values[i]))\\n                rDict.Add(values[i], new HashSet<char>());\\n            rDict[values[i]].Add(keys[i]);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string output = \"\";\\n        foreach (char c in word1){\\n            output += fDict[c];\\n        }\\n        return output;\\n    }\\n    \\n    // Because the dictionary is smaller than 100, we basically just loop the dictionary for each number, worst time is just 100 * 100\\n    public int Decrypt(string word2) {\\n        List<string> hs = new List<string>(pString);\\n        int len = word2.Length / 2;\\n        for (int i = 0; i < len; i++){\\n            string str = word2.Substring(i*2, 2);\\n            if (!rDict.ContainsKey(str))\\n                return 0;\\n            HashSet<char> ch = rDict[str];\\n            List<string> temp = new List<string>();\\n            foreach (string h in hs){\\n                if (h.Length > i && ch.Contains(h[i]))\\n                    temp.Add(h);\\n            }\\n            if (temp.Count == 0)\\n                return 0;\\n            hs = temp;\\n        }\\n        List<string> output = new List<string>();\\n        foreach (string k in hs){\\n            if (k.Length == len)\\n                output.Add(k);\\n        }\\n\\n        return output.Count;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1908770,
                "title": "python-not-hard-but-confusing",
                "content": "That is, the way this question is worded. We are supposed to use the encryption function we have written to descript efficiently. That\\'s sort of the hint (otherwise it\\'s trivial to code the encryption).\\n\\n```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h = collections.defaultdict(str)\\n        for k, v in zip(keys, values):\\n            self.h[k] = v\\n        self.dictionary = set(dictionary)\\n        \\n\\n    def encrypt(self, word1):\\n        ans = \\'\\'\\n        for x in word1:\\n            if not self.h[x]:\\n                ans += x\\n            else:\\n                ans += self.h[x]\\n        return ans\\n\\n    \\n    def decrypt(self, word2):\\n        ans = 0\\n        for word in self.dictionary:\\n            if self.encrypt(word) == word2:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h = collections.defaultdict(str)\\n        for k, v in zip(keys, values):\\n            self.h[k] = v\\n        self.dictionary = set(dictionary)\\n        \\n\\n    def encrypt(self, word1):\\n        ans = \\'\\'\\n        for x in word1:\\n            if not self.h[x]:\\n                ans += x\\n            else:\\n                ans += self.h[x]\\n        return ans\\n\\n    \\n    def decrypt(self, word2):\\n        ans = 0\\n        for word in self.dictionary:\\n            if self.encrypt(word) == word2:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908735,
                "title": "easy-to-understand-solution-c-unordered-maps",
                "content": "Firstly, we will store all the information present with us in a hashmap so that we can retrieve them faster. The two arrays Keys[] and Values[] can be stored in a single hashmap\\n\\nThe encrypt function is easy to implement. Just traverse through the string \\u2018word1\\u2019 and replace each character with its corresponding value string.\\n\\nThe decrypt function needs only one trick to implement. One may think we can recursively form all the possible strings by taking characters in pairs and encrypt these pairs but this will have a polynomial time complexity since a given pair may have one or more encryption characters.\\n\\n**But we can be a little smart in doing this. Instead of finding all the decryption strings of the given string and check how many of those are present in the dictionary array, we can encrypt all the strings present in the dictionary array, maintain their count using a frequency hashmap and finally check how any time the string \\u2018word2\\u2019 exist in this frequency map. **\\n\\n\\n```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        // storing all the characters along with their encryption keys\\n\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];\\n        }\\n        \\n        // iterating through the string in the dictionary, encrypting them and maintaining a frequency hashmap m2\\n        \\n        for(auto i:dictionary)\\n        {\\n            string ans=\"\";\\n            \\n            string word1=i;\\n        \\n            for(int i=0;i<word1.size();i++)\\n            {\\n                ans+=m1[word1[i]];\\n            }\\n\\n            if(m2.find(ans)==m2.end())\\n            {\\n                m2[ans]=1;\\n            }\\n            else{\\n                m2[ans]++;\\n            }\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        // simple encryption\\n        \\n        string ans=\"\";\\n        \\n        for(int i=0;i<word1.size();i++)\\n        {\\n            ans+=m1[word1[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        // return the frequency of the word2 in the hashmap m2\\n        \\n        if(m2.find(word2)==m2.end())\\n        {\\n            return 0;\\n        }\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        \\n        // storing all the characters along with their encryption keys\\n\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            m1[keys[i]]=values[i];\\n        }\\n        \\n        // iterating through the string in the dictionary, encrypting them and maintaining a frequency hashmap m2\\n        \\n        for(auto i:dictionary)\\n        {\\n            string ans=\"\";\\n            \\n            string word1=i;\\n        \\n            for(int i=0;i<word1.size();i++)\\n            {\\n                ans+=m1[word1[i]];\\n            }\\n\\n            if(m2.find(ans)==m2.end())\\n            {\\n                m2[ans]=1;\\n            }\\n            else{\\n                m2[ans]++;\\n            }\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        // simple encryption\\n        \\n        string ans=\"\";\\n        \\n        for(int i=0;i<word1.size();i++)\\n        {\\n            ans+=m1[word1[i]];\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        // return the frequency of the word2 in the hashmap m2\\n        \\n        if(m2.find(word2)==m2.end())\\n        {\\n            return 0;\\n        }\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908733,
                "title": "cpp-straight-forward-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> lookup;\\n    vector<string> dict;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict = dictionary;\\n        for(int i = 0; i < keys.size(); i++) {\\n            lookup[keys[i]] = values[i];\\n        }\\n        \\n    }\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for(auto key : word1) res += lookup[key];\\n        return res;\\n    }\\n    \\n    //generate all decrypted words from words in dictonary\\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        for(auto word : dict) {\\n            string s = \"\";\\n            for(auto key : word) {\\n                s += lookup[key];\\n            }\\n            \\n            if(s == word2) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> lookup;\\n    vector<string> dict;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict = dictionary;\\n        for(int i = 0; i < keys.size(); i++) {\\n            lookup[keys[i]] = values[i];\\n        }\\n        \\n    }\\n    string encrypt(string word1) {\\n        string res = \"\";\\n        for(auto key : word1) res += lookup[key];\\n        return res;\\n    }\\n    \\n    //generate all decrypted words from words in dictonary\\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        for(auto word : dict) {\\n            string s = \"\";\\n            for(auto key : word) {\\n                s += lookup[key];\\n            }\\n            \\n            if(s == word2) cnt++;\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018573,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    map: HashMap<char, String>,\\n    dictionary: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let map: HashMap<char, String> = keys.into_iter().zip(values.into_iter()).collect();\\n        let mut ret = Self { map, dictionary: HashMap::new() };\\n\\n        ret.dictionary = dictionary.into_iter().fold(HashMap::new(), |mut dict, word| {\\n            let word = ret.encrypt(word);\\n            if !word.is_empty() {\\n                dict.entry(word).and_modify(|e| *e += 1).or_insert(1);\\n            }\\n            dict\\n        });\\n        ret\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ret = String::new();\\n        for c in word1.chars() {\\n            if let Some(s) = self.map.get(&c) {\\n                ret.push_str(s.as_str());\\n            } else {\\n                return String::new();\\n            }\\n        }\\n        ret\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 { self.dictionary.get(&word2).cloned().unwrap_or(0) }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    map: HashMap<char, String>,\\n    dictionary: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let map: HashMap<char, String> = keys.into_iter().zip(values.into_iter()).collect();\\n        let mut ret = Self { map, dictionary: HashMap::new() };\\n\\n        ret.dictionary = dictionary.into_iter().fold(HashMap::new(), |mut dict, word| {\\n            let word = ret.encrypt(word);\\n            if !word.is_empty() {\\n                dict.entry(word).and_modify(|e| *e += 1).or_insert(1);\\n            }\\n            dict\\n        });\\n        ret\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ret = String::new();\\n        for c in word1.chars() {\\n            if let Some(s) = self.map.get(&c) {\\n                ret.push_str(s.as_str());\\n            } else {\\n                return String::new();\\n            }\\n        }\\n        ret\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 { self.dictionary.get(&word2).cloned().unwrap_or(0) }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996812,
                "title": "2-typescript-javascript-solutions-reverse-lookup-and-trie",
                "content": "# Code\\n\\n## Using Reverse Lookup (~200ms)\\n(Encrypt all dictionary words and lookup count during decryption.)\\n```\\nclass Encrypter {\\n  private keysToValues: { [key: string]: string } = {};\\n  private encryptionCount: { [word: string]: number } = {};\\n  \\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    for (let i = 0; i < keys.length; i++) {\\n      this.keysToValues[keys[i]] = values[i];\\n    }\\n    for (const word of dictionary) {\\n      const encrypted = this.encrypt(word);\\n      this.encryptionCount[encrypted] ??= 0;\\n      this.encryptionCount[encrypted]++;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    return this.encryptionCount[word2] ?? 0;\\n  }\\n}\\n```\\n\\n## Using Trie (~1500ms)\\n(Probably the intended solution.)\\n```\\nclass Encrypter {\\n  private trie: TrieNode;\\n  private keysToValues: { [key: string]: string } = {};\\n  private valuesToKeys: { [value: string]: string[] } = {};\\n\\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    this.trie = buildTrie(dictionary);\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.keysToValues[key] = value;\\n      const arr = this.valuesToKeys[value] ?? [];\\n      arr.push(key);\\n      this.valuesToKeys[value] = arr;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    const possible = [this.trie];\\n    for (let i = 0; i <= word2.length - 2; i += 2) {\\n      for (const trieNode of possible.splice(0, possible.length)) {\\n        for (const key of this.valuesToKeys[word2.slice(i, i + 2)] ?? []) {\\n          const nextNode = trieNode.children[key];\\n          if (nextNode) possible.push(nextNode);\\n        }\\n      }\\n      if (possible.length === 0) break;\\n    }\\n    return possible.filter(({ leaf }) => leaf).length;\\n  }\\n}\\n\\ninterface TrieNode {\\n  char: string;\\n  leaf: boolean;\\n  children: { [char: string]: TrieNode };\\n}\\n\\nconst buildTrie = (\\n  words: string[],\\n  parent: TrieNode = { char: \"\", leaf: false, children: {} }\\n) => {\\n  const wordMap: { [char: string]: string[] } = {};\\n  for (const word of words) {\\n    if (word === \"\") {\\n      parent.leaf = true;\\n      continue;\\n    }\\n    const char = word[0];\\n    const arr = wordMap[char] ?? [];\\n    arr.push(word.slice(1));\\n    wordMap[char] = arr;\\n  }\\n  for (const [char, words] of Object.entries(wordMap)) {\\n    const trieNode = {\\n      char,\\n      leaf: false,\\n      children: {},\\n    };\\n    buildTrie(words, trieNode);\\n    parent.children[char] = trieNode;\\n  }\\n  return parent;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n  private keysToValues: { [key: string]: string } = {};\\n  private encryptionCount: { [word: string]: number } = {};\\n  \\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    for (let i = 0; i < keys.length; i++) {\\n      this.keysToValues[keys[i]] = values[i];\\n    }\\n    for (const word of dictionary) {\\n      const encrypted = this.encrypt(word);\\n      this.encryptionCount[encrypted] ??= 0;\\n      this.encryptionCount[encrypted]++;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    return this.encryptionCount[word2] ?? 0;\\n  }\\n}\\n```\n```\\nclass Encrypter {\\n  private trie: TrieNode;\\n  private keysToValues: { [key: string]: string } = {};\\n  private valuesToKeys: { [value: string]: string[] } = {};\\n\\n  constructor(keys: string[], values: string[], dictionary: string[]) {\\n    this.trie = buildTrie(dictionary);\\n    for (let i = 0; i < keys.length; i++) {\\n      const key = keys[i];\\n      const value = values[i];\\n      this.keysToValues[key] = value;\\n      const arr = this.valuesToKeys[value] ?? [];\\n      arr.push(key);\\n      this.valuesToKeys[value] = arr;\\n    }\\n  }\\n\\n  encrypt(word1: string): string {\\n    let encrypted = \"\";\\n    for (const char of word1) {\\n      if (!this.keysToValues[char]) return \"\";\\n      encrypted += this.keysToValues[char];\\n    }\\n    return encrypted;\\n  }\\n\\n  decrypt(word2: string): number {\\n    const possible = [this.trie];\\n    for (let i = 0; i <= word2.length - 2; i += 2) {\\n      for (const trieNode of possible.splice(0, possible.length)) {\\n        for (const key of this.valuesToKeys[word2.slice(i, i + 2)] ?? []) {\\n          const nextNode = trieNode.children[key];\\n          if (nextNode) possible.push(nextNode);\\n        }\\n      }\\n      if (possible.length === 0) break;\\n    }\\n    return possible.filter(({ leaf }) => leaf).length;\\n  }\\n}\\n\\ninterface TrieNode {\\n  char: string;\\n  leaf: boolean;\\n  children: { [char: string]: TrieNode };\\n}\\n\\nconst buildTrie = (\\n  words: string[],\\n  parent: TrieNode = { char: \"\", leaf: false, children: {} }\\n) => {\\n  const wordMap: { [char: string]: string[] } = {};\\n  for (const word of words) {\\n    if (word === \"\") {\\n      parent.leaf = true;\\n      continue;\\n    }\\n    const char = word[0];\\n    const arr = wordMap[char] ?? [];\\n    arr.push(word.slice(1));\\n    wordMap[char] = arr;\\n  }\\n  for (const [char, words] of Object.entries(wordMap)) {\\n    const trieNode = {\\n      char,\\n      leaf: false,\\n      children: {},\\n    };\\n    buildTrie(words, trieNode);\\n    parent.children[char] = trieNode;\\n  }\\n  return parent;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958315,
                "title": "encrypt-decrypt-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)\\n//        encrypt: O(n)\\n//        decrypt: O(n)\\n// Space: O(m + d)\\n\\n// freq table\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < size(keys); ++i) {\\n            lookup_[keys[i]] = values[i];\\n        }\\n        for (const auto& x : dictionary) {\\n            ++cnt_[encrypt(x)];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (const auto& c : word1) {\\n            if (!lookup_.count(c)) {\\n                return \"\";\\n            }\\n            result += lookup_[c];\\n        }\\n        return result;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt_[word2];\\n    }\\n\\nprivate:\\n    unordered_map<char, string> lookup_;\\n    unordered_map<string, int> cnt_;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Design",
                    "Trie"
                ],
                "code": "```\\n// Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)\\n//        encrypt: O(n)\\n//        decrypt: O(n)\\n// Space: O(m + d)\\n\\n// freq table\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < size(keys); ++i) {\\n            lookup_[keys[i]] = values[i];\\n        }\\n        for (const auto& x : dictionary) {\\n            ++cnt_[encrypt(x)];\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (const auto& c : word1) {\\n            if (!lookup_.count(c)) {\\n                return \"\";\\n            }\\n            result += lookup_[c];\\n        }\\n        return result;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return cnt_[word2];\\n    }\\n\\nprivate:\\n    unordered_map<char, string> lookup_;\\n    unordered_map<string, int> cnt_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899951,
                "title": "typescript-hash-table-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\n    private _keyMap: Map<string, string>;\\n    private _decryptedWordMap: Map<string, number>;\\n\\n    constructor(keys: string[], values: string[], dictionary: string[]) {\\n        this._keyMap = new Map();\\n        this._decryptedWordMap = new Map();\\n\\n        keys.forEach((key, i) => {\\n            this._keyMap.set(key, values[i]);\\n        });\\n\\n        dictionary.forEach((word) => {\\n            const decryptedWord = this.encrypt(word);\\n            const decryptedWordNum = this._decryptedWordMap.get(decryptedWord);\\n\\n            if (decryptedWordNum !== undefined)\\n                this._decryptedWordMap.set(decryptedWord, decryptedWordNum + 1);\\n            else\\n                this._decryptedWordMap.set(decryptedWord, 1);\\n        });\\n    }\\n\\n    encrypt(word1: string): string {\\n        let decryptedWord1 = \"\";\\n\\n        word1.split(\"\").forEach((char) => {\\n            decryptedWord1 += this._keyMap.get(char);\\n        });\\n\\n        return decryptedWord1;\\n    }\\n\\n    decrypt(word2: string): number {\\n        const decryptedWordNum = this._decryptedWordMap.get(word2);\\n\\n        if (decryptedWordNum)\\n            return decryptedWordNum\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\n    private _keyMap: Map<string, string>;\\n    private _decryptedWordMap: Map<string, number>;\\n\\n    constructor(keys: string[], values: string[], dictionary: string[]) {\\n        this._keyMap = new Map();\\n        this._decryptedWordMap = new Map();\\n\\n        keys.forEach((key, i) => {\\n            this._keyMap.set(key, values[i]);\\n        });\\n\\n        dictionary.forEach((word) => {\\n            const decryptedWord = this.encrypt(word);\\n            const decryptedWordNum = this._decryptedWordMap.get(decryptedWord);\\n\\n            if (decryptedWordNum !== undefined)\\n                this._decryptedWordMap.set(decryptedWord, decryptedWordNum + 1);\\n            else\\n                this._decryptedWordMap.set(decryptedWord, 1);\\n        });\\n    }\\n\\n    encrypt(word1: string): string {\\n        let decryptedWord1 = \"\";\\n\\n        word1.split(\"\").forEach((char) => {\\n            decryptedWord1 += this._keyMap.get(char);\\n        });\\n\\n        return decryptedWord1;\\n    }\\n\\n    decrypt(word2: string): number {\\n        const decryptedWordNum = this._decryptedWordMap.get(word2);\\n\\n        if (decryptedWordNum)\\n            return decryptedWordNum\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874459,
                "title": "python-simple-solution-beats-96-92",
                "content": "# Code\\n```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key2value={}\\n        for k,v in zip(keys,values):\\n            self.key2value[k]=v\\n        self.dictionary=Counter()\\n        for d in dictionary:\\n            self.dictionary[self.encrypt(d)]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        res=[]\\n        for c in word1:\\n            if c in self.key2value:\\n                res.append(self.key2value[c])\\n            else:\\n                return \"\"\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return  self.dictionary[word2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key2value={}\\n        for k,v in zip(keys,values):\\n            self.key2value[k]=v\\n        self.dictionary=Counter()\\n        for d in dictionary:\\n            self.dictionary[self.encrypt(d)]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        res=[]\\n        for c in word1:\\n            if c in self.key2value:\\n                res.append(self.key2value[c])\\n            else:\\n                return \"\"\\n        return \"\".join(res)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return  self.dictionary[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750883,
                "title": "c-solution-without-trie-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\n    public:\\n    unordered_map<char,string>mp;\\n    unordered_map<string,unordered_map<char,int>>revMp;\\n    unordered_map<int,vector<string>>dict;\\n\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            mp[keys[i]] = values[i];\\n            revMp[values[i]][keys[i]]++;\\n        }\\n        for(auto &i:dictionary)\\n        {\\n            dict[i.length()].push_back(i);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& i:word1)\\n        {\\n            if(mp.find(i) == mp.end())\\n            return \"\";\\n            ans+=mp[i];\\n        }\\n    return ans;\\n    }\\n    \\n    int decrypt(string word2){\\n        if(word2.length() % 2 )\\n        return 0;\\n        vector<string>&v = dict[word2.length()/2];\\n        int res=0;\\n        for(auto &i : v)\\n        {\\n            bool ok = true;\\n            int x = 0;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                if(revMp[word2.substr(x,2)][i[j]] == 0)\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n                x+=2;\\n            }\\n\\n            if(ok)\\n            res++;\\n        }\\n    return res;\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Encrypter {\\n    public:\\n    unordered_map<char,string>mp;\\n    unordered_map<string,unordered_map<char,int>>revMp;\\n    unordered_map<int,vector<string>>dict;\\n\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            mp[keys[i]] = values[i];\\n            revMp[values[i]][keys[i]]++;\\n        }\\n        for(auto &i:dictionary)\\n        {\\n            dict[i.length()].push_back(i);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& i:word1)\\n        {\\n            if(mp.find(i) == mp.end())\\n            return \"\";\\n            ans+=mp[i];\\n        }\\n    return ans;\\n    }\\n    \\n    int decrypt(string word2){\\n        if(word2.length() % 2 )\\n        return 0;\\n        vector<string>&v = dict[word2.length()/2];\\n        int res=0;\\n        for(auto &i : v)\\n        {\\n            bool ok = true;\\n            int x = 0;\\n            for(int j=0;j<i.length();j++)\\n            {\\n                if(revMp[word2.substr(x,2)][i[j]] == 0)\\n                {\\n                    ok=false;\\n                    break;\\n                }\\n                x+=2;\\n            }\\n\\n            if(ok)\\n            res++;\\n        }\\n    return res;\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676976,
                "title": "python3-hashmap-solution",
                "content": "\\n# Code\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mapping = {}\\n        self.countDict = defaultdict(int)\\n        for i in range(len(keys)):\\n            self.mapping[keys[i]]=values[i]\\n        for key in dictionary:\\n            self.countDict[self.encrypt(key,0)] += 1\\n    def encrypt(self, word1: str,init = 1) -> str:\\n        ans = \"\"\\n        for ch in word1:\\n            if ch in self.mapping:\\n                ans+=self.mapping[ch]\\n            else:\\n                if init==0: return \"\"\\n                ans+=ch\\n        return ans\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.countDict[word2]\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.mapping = {}\\n        self.countDict = defaultdict(int)\\n        for i in range(len(keys)):\\n            self.mapping[keys[i]]=values[i]\\n        for key in dictionary:\\n            self.countDict[self.encrypt(key,0)] += 1\\n    def encrypt(self, word1: str,init = 1) -> str:\\n        ans = \"\"\\n        for ch in word1:\\n            if ch in self.mapping:\\n                ans+=self.mapping[ch]\\n            else:\\n                if init==0: return \"\"\\n                ans+=ch\\n        return ans\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.countDict[word2]\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661824,
                "title": "c-python-trie-hash-map-solution-with-explanation",
                "content": "use a hash map to record mapping of letter to values.\\nuse Trie to store word of dictionary after encrypting, if the word  after encrypting is empty string, pass it.\\n\\ntc: \\n__init__ O(len(keys) + O(len(dictionary)))\\nencrypt O(n)\\ndecrypt O(n)\\n\\nsc is O(len(dictionary) * 100)\\n\\n### c++\\n```cpp\\nclass Trie {\\npublic:\\n    int cnt;\\n    Trie* child[26];\\n    Trie(): cnt(0), child{} {};\\n};\\n\\nclass Encrypter {\\npublic:\\n    string* map[26];\\n    Trie* root;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary): map{nullptr}, root{nullptr} {\\n        for (int i = 0, size = keys.size(); i < size; i+=1) map[keys[i]-\\'a\\'] = &values[i];\\n        this -> root = new Trie();\\n        auto insert = [&] (const string& word) -> void {\\n            if (word.empty()) return;\\n            Trie* cur = this -> root;\\n            for (auto& ch: word) {\\n                if (cur -> child[ch-\\'a\\'] == nullptr) cur -> child[ch-\\'a\\'] = new Trie();\\n                cur = cur -> child[ch-\\'a\\'];\\n            }\\n            cur -> cnt += 1;\\n        };\\n        for (auto& word: dictionary) insert(this -> encrypt(word));\\n    }\\n    \\n    string encrypt(string word1) {\\n        string s;\\n        for (auto& ch: word1) {\\n            if (!this -> map[ch - \\'a\\']) return \"\";\\n            s += *(this -> map[ch - \\'a\\']);\\n        }\\n        return s;\\n    }\\n    \\n    int decrypt(string word2) {\\n        Trie* cur = this -> root;\\n        for (auto& ch: word2) {\\n            if (! cur -> child[ch -\\'a\\']) return 0;\\n            cur = cur -> child[ch -\\'a\\'];\\n        }\\n        return cur -> cnt;\\n    }\\n};\\n```\\n### python\\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.childs = {}\\n        self.cnt = 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.map = {k:v for k, v in zip(keys, values)}\\n        self.root = Trie()\\n        def insert(word):\\n            if not word: return\\n            cur = self.root\\n            for ch in word:\\n                if ch not in cur.childs: cur.childs[ch] = Trie()\\n                cur = cur.childs[ch]\\n            cur.cnt += 1\\n\\n        for word in dictionary:\\n            insert(self.encrypt(word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        string = []\\n        for ch in word1:\\n            if ch not in self.map: return \\'\\'\\n            string.append(self.map[ch])\\n        return \\'\\'.join(string)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        cur = self.root\\n        for idx, ch in enumerate(word2):\\n            if ch not in cur.childs: return 0\\n            cur = cur.childs[ch]\\n        return cur.cnt\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```cpp\\nclass Trie {\\npublic:\\n    int cnt;\\n    Trie* child[26];\\n    Trie(): cnt(0), child{} {};\\n};\\n\\nclass Encrypter {\\npublic:\\n    string* map[26];\\n    Trie* root;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary): map{nullptr}, root{nullptr} {\\n        for (int i = 0, size = keys.size(); i < size; i+=1) map[keys[i]-\\'a\\'] = &values[i];\\n        this -> root = new Trie();\\n        auto insert = [&] (const string& word) -> void {\\n            if (word.empty()) return;\\n            Trie* cur = this -> root;\\n            for (auto& ch: word) {\\n                if (cur -> child[ch-\\'a\\'] == nullptr) cur -> child[ch-\\'a\\'] = new Trie();\\n                cur = cur -> child[ch-\\'a\\'];\\n            }\\n            cur -> cnt += 1;\\n        };\\n        for (auto& word: dictionary) insert(this -> encrypt(word));\\n    }\\n    \\n    string encrypt(string word1) {\\n        string s;\\n        for (auto& ch: word1) {\\n            if (!this -> map[ch - \\'a\\']) return \"\";\\n            s += *(this -> map[ch - \\'a\\']);\\n        }\\n        return s;\\n    }\\n    \\n    int decrypt(string word2) {\\n        Trie* cur = this -> root;\\n        for (auto& ch: word2) {\\n            if (! cur -> child[ch -\\'a\\']) return 0;\\n            cur = cur -> child[ch -\\'a\\'];\\n        }\\n        return cur -> cnt;\\n    }\\n};\\n```\n```python\\nclass Trie:\\n    def __init__(self):\\n        self.childs = {}\\n        self.cnt = 0\\n\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.map = {k:v for k, v in zip(keys, values)}\\n        self.root = Trie()\\n        def insert(word):\\n            if not word: return\\n            cur = self.root\\n            for ch in word:\\n                if ch not in cur.childs: cur.childs[ch] = Trie()\\n                cur = cur.childs[ch]\\n            cur.cnt += 1\\n\\n        for word in dictionary:\\n            insert(self.encrypt(word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        string = []\\n        for ch in word1:\\n            if ch not in self.map: return \\'\\'\\n            string.append(self.map[ch])\\n        return \\'\\'.join(string)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        cur = self.root\\n        for idx, ch in enumerate(word2):\\n            if ch not in cur.childs: return 0\\n            cur = cur.childs[ch]\\n        return cur.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613010,
                "title": "straight-forward-solution-187ms-runtime-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor encryption - since for every character in string \\'c\\' present in key[i] we need to fetch values[i], we\\'ll build a dictionary mapping each key[i] to valeus[i] so we can get value associated with each key-character in O(1).\\n\\nFor decryption - since we need to find possible strings in valid \\'dictionary\\' array that we can encrypt to get this string that we are currently trying to decrypt, we can simply encrypt all the possible/valid string provided already in \\'dictionary\\' array, and see how many of those strings can map to same encrypted result (that we are currently tryint to decrypt)\\n\\nFor both of these steps since we need to build dictionaries, we perform the pre-computation steps needed in constructor.\\n\\n![Screenshot 2023-06-08 145030.png](https://assets.leetcode.com/users/images/b0531d62-cd4f-4283-8292-6e2d8fc57fd4_1686216056.4274116.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**Constructor / Pre-processing** - O(D*N) -> D is number of words in dictionary and N is the max number of characters in a word (as we are calling Encrypt for each word)\\n**Encrypt** - O(N) -> N is the number of characters in the word to encrypt\\n**Decrypt** - O(1)\\n\\nOverall - O(D*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Constructor / Pre-processing** - O(D) -> D is number of words in dictionary that we are storing in Dictionary\\n**Encrypt** - O(N) -> as we are using a StringBuilder\\n**Decrypt** - O(1)\\n\\nOverall - O(D)\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Encrypter {\\n    char[] keys;\\n    string[] values;\\n    string[] dictionary;\\n\\n    //for encrypt\\n    Dictionary<char, string> keyMap;\\n\\n    //for decrypt\\n    Dictionary<string, int> valueMap;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.dictionary = dictionary;\\n\\n        keyMap = new Dictionary<char, string>();\\n        for (int i = 0; i < keys.Length; i++)\\n            keyMap[keys[i]] = values[i];\\n\\n        valueMap = new Dictionary<string, int>();\\n        for (int i = 0; i < dictionary.Length; i++)\\n        {\\n            string str = Encrypt(dictionary[i]);\\n            if (!valueMap.ContainsKey(str))\\n            {\\n                valueMap.Add(str, 1);\\n            }\\n            else\\n            {\\n                valueMap[str]++;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < word1.Length; i++)\\n        {\\n            if (keyMap.TryGetValue(word1[i], out string str))\\n            {\\n                sb.Append(str);\\n            }\\n            else\\n            {\\n                return \"\";\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        if(valueMap.TryGetValue(word2, out int result))\\n            return result;\\n        else\\n            return 0;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\npublic class Encrypter {\\n    char[] keys;\\n    string[] values;\\n    string[] dictionary;\\n\\n    //for encrypt\\n    Dictionary<char, string> keyMap;\\n\\n    //for decrypt\\n    Dictionary<string, int> valueMap;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.dictionary = dictionary;\\n\\n        keyMap = new Dictionary<char, string>();\\n        for (int i = 0; i < keys.Length; i++)\\n            keyMap[keys[i]] = values[i];\\n\\n        valueMap = new Dictionary<string, int>();\\n        for (int i = 0; i < dictionary.Length; i++)\\n        {\\n            string str = Encrypt(dictionary[i]);\\n            if (!valueMap.ContainsKey(str))\\n            {\\n                valueMap.Add(str, 1);\\n            }\\n            else\\n            {\\n                valueMap[str]++;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < word1.Length; i++)\\n        {\\n            if (keyMap.TryGetValue(word1[i], out string str))\\n            {\\n                sb.Append(str);\\n            }\\n            else\\n            {\\n                return \"\";\\n            }\\n        }\\n\\n        return sb.ToString();\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        if(valueMap.TryGetValue(word2, out int result))\\n            return result;\\n        else\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594273,
                "title": "python-simple-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter:\\n    def __init__(self, keys, values, dictionary):\\n        self.dict1 = {i:j for i,j in zip(keys,values)}\\n        self.dict2 = defaultdict(list)\\n        self.dictionary = dictionary\\n\\n        for i,j in zip(values,keys):\\n            self.dict2[i].append(j)\\n\\n    def encrypt(self, word1):\\n        str1 = \"\"\\n\\n        for i in word1:\\n            if i not in self.dict1:\\n                return \"\"\\n            else:\\n                str1 += self.dict1[i]\\n\\n        return str1\\n\\n    def decrypt(self, word2):\\n        total = 0\\n\\n        for i in self.dictionary:\\n            if self.encrypt(i) == word2:\\n                total += 1\\n\\n        return total\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys, values, dictionary):\\n        self.dict1 = {i:j for i,j in zip(keys,values)}\\n        self.dict2 = defaultdict(list)\\n        self.dictionary = dictionary\\n\\n        for i,j in zip(values,keys):\\n            self.dict2[i].append(j)\\n\\n    def encrypt(self, word1):\\n        str1 = \"\"\\n\\n        for i in word1:\\n            if i not in self.dict1:\\n                return \"\"\\n            else:\\n                str1 += self.dict1[i]\\n\\n        return str1\\n\\n    def decrypt(self, word2):\\n        total = 0\\n\\n        for i in self.dictionary:\\n            if self.encrypt(i) == word2:\\n                total += 1\\n\\n        return total\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590876,
                "title": "c-simple-solution-using-two-dictionaries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want a keys[i] -> values[i] dictionary to easily encrypt a character in O(1) and a word in O(n) where n is the length of the word.\\n\\nSimilarly, for an O(1) decryption we want to pre-process all of the strings in the given dictionary upon Encrypter construction.\\n\\nThe Encrytper would run in O(n) where n is the number of strings in the dictionary. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a dicitonary mapping chars to strings (keys to values).\\nUse a dicitonary mapping words to count the number of possible strings word2 could decrypt to that also appear in dictionary.\\nProcess the above in Encrypter.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nEncrypter O(n)\\nEncrypt O(n)\\nDecrypt O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nEncrypter O(n)\\nEncrypt O(1)\\nDecrypt O(1)\\n\\n# Code\\n```\\npublic class Encrypter {\\n\\n    Dictionary<char, string> keyToValue = new Dictionary<char,string>();\\n    Dictionary<string,int> fullDict = new Dictionary<string,int>();\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        for(int i = 0; i < keys.Length; i++) {\\n            keyToValue[keys[i]] = values[i];\\n        }\\n        \\n        for (int j = 0; j < dictionary.Length; j++) {\\n            var word = dictionary[j];\\n            var encrypted = Encrypt(word);\\n            var present = fullDict.TryGetValue(encrypted, out var val);\\n            if (!present) {\\n                fullDict.Add(encrypted, 1);\\n            }\\n            else {\\n                val++;\\n                fullDict[encrypted] = val;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        var encStr = string.Empty;\\n        for (int i = 0; i < word1.Length; i++) {\\n            var present = keyToValue.TryGetValue(word1[i] , out var val);\\n            if(!present) {\\n                encStr += \"#\";\\n                // gotta add a random value so that strings with no mapping don\\'t increase count in fullDict by mistake\\n                // testcase for this is \\n                //[[[\"b\"],[\"ca\"],[\"aaa\",\"cacbc\",\"bbaba\",\"bb\"]],[\"bbb\"],[\"cacaca\"]]\\n            }\\n            else{\\n                encStr += val; \\n            }          \\n        }\\n        return encStr;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        var present = fullDict.TryGetValue(word2, out var count);\\n        return present ? count : 0;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Encrypter {\\n\\n    Dictionary<char, string> keyToValue = new Dictionary<char,string>();\\n    Dictionary<string,int> fullDict = new Dictionary<string,int>();\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        for(int i = 0; i < keys.Length; i++) {\\n            keyToValue[keys[i]] = values[i];\\n        }\\n        \\n        for (int j = 0; j < dictionary.Length; j++) {\\n            var word = dictionary[j];\\n            var encrypted = Encrypt(word);\\n            var present = fullDict.TryGetValue(encrypted, out var val);\\n            if (!present) {\\n                fullDict.Add(encrypted, 1);\\n            }\\n            else {\\n                val++;\\n                fullDict[encrypted] = val;\\n            }\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        var encStr = string.Empty;\\n        for (int i = 0; i < word1.Length; i++) {\\n            var present = keyToValue.TryGetValue(word1[i] , out var val);\\n            if(!present) {\\n                encStr += \"#\";\\n                // gotta add a random value so that strings with no mapping don\\'t increase count in fullDict by mistake\\n                // testcase for this is \\n                //[[[\"b\"],[\"ca\"],[\"aaa\",\"cacbc\",\"bbaba\",\"bb\"]],[\"bbb\"],[\"cacaca\"]]\\n            }\\n            else{\\n                encStr += val; \\n            }          \\n        }\\n        return encStr;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        var present = fullDict.TryGetValue(word2, out var count);\\n        return present ? count : 0;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405875,
                "title": "simple-java-solution",
                "content": "```\\nclass Encrypter {\\n    HashMap<Character,String> h=new HashMap<Character,String>();\\n    HashMap<String,Integer> map=new HashMap<String,Integer>();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++)\\n        {\\n            h.put(keys[i],values[i]);\\n        }\\n        for(int i=0;i<dictionary.length;i++)\\n        {\\n            String str=\"\";\\n            int flag=0;\\n            for(int j=0;j<dictionary[i].length();j++)\\n            {\\n                if(!h.containsKey(dictionary[i].charAt(j)))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n               str+=h.get(dictionary[i].charAt(j));\\n            }\\n            if(flag==0)\\n            {\\n                if(!map.containsKey(str))\\n                {\\n                    map.put(str,1);\\n                }\\n                else\\n                {\\n                    map.put(str,map.get(str)+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String str=\"\";\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            str+=h.get(word1.charAt(i));\\n        }\\n\\n        return str;\\n        \\n    }\\n    \\n    public int decrypt(String word2) {\\n        if(map.containsKey(word2))\\n        {\\n            return map.get(word2);\\n        }\\n\\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character,String> h=new HashMap<Character,String>();\\n    HashMap<String,Integer> map=new HashMap<String,Integer>();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++)\\n        {\\n            h.put(keys[i],values[i]);\\n        }\\n        for(int i=0;i<dictionary.length;i++)\\n        {\\n            String str=\"\";\\n            int flag=0;\\n            for(int j=0;j<dictionary[i].length();j++)\\n            {\\n                if(!h.containsKey(dictionary[i].charAt(j)))\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n               str+=h.get(dictionary[i].charAt(j));\\n            }\\n            if(flag==0)\\n            {\\n                if(!map.containsKey(str))\\n                {\\n                    map.put(str,1);\\n                }\\n                else\\n                {\\n                    map.put(str,map.get(str)+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String str=\"\";\\n        for(int i=0;i<word1.length();i++)\\n        {\\n            str+=h.get(word1.charAt(i));\\n        }\\n\\n        return str;\\n        \\n    }\\n    \\n    public int decrypt(String word2) {\\n        if(map.containsKey(word2))\\n        {\\n            return map.get(word2);\\n        }\\n\\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352515,
                "title": "c-golang-2-maps",
                "content": "# Code\\n```\\n//--------------------------------------\\n// C++\\n//--------------------------------------\\nclass Encrypter {\\n    unordered_map<char, string> EMap;\\n    unordered_map<string, int> DMap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++) {\\n            EMap[keys[i]] = values[i];\\n        }\\n        for(string word: dictionary) {\\n            string val = \"\";\\n            bool flag = true;\\n            for(char ch: word) {\\n                if(EMap.find(ch) != EMap.end())\\n                    val += EMap[ch];\\n                else {\\n                    flag = false;\\n                    break;\\n                }\\n            } \\n            if(flag)\\n            DMap[val]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1) {\\n            ans += EMap[ch];\\n        } \\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return DMap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n\\n//--------------------------------------\\n// Golang\\n//--------------------------------------\\ntype Encrypter struct {\\n    EMap map[byte]string\\n    DMap map[string]int\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    EMap := make(map[byte]string)\\n    DMap := make(map[string]int)\\n    for i := 0; i < len(keys); i++ {\\n        EMap[keys[i]] = values[i]\\n    }\\n    for _, word := range dictionary {\\n        val := \"\"\\n        flag := true\\n        for _, ch := range word {\\n            if _, ok := EMap[byte(ch)]; ok {\\n                val += EMap[byte(ch)]\\n            } else {\\n                flag = false\\n                break\\n            }\\n        } \\n        if flag {DMap[val]++} \\n    }\\n    return Encrypter {\\n        EMap: EMap,\\n        DMap: DMap,\\n    }\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    ans := \"\"\\n    for _, ch := range word1 {\\n        ans += this.EMap[byte(ch)]\\n    } \\n    return ans\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.DMap[word2]\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "String",
                    "Design"
                ],
                "code": "```\\n//--------------------------------------\\n// C++\\n//--------------------------------------\\nclass Encrypter {\\n    unordered_map<char, string> EMap;\\n    unordered_map<string, int> DMap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++) {\\n            EMap[keys[i]] = values[i];\\n        }\\n        for(string word: dictionary) {\\n            string val = \"\";\\n            bool flag = true;\\n            for(char ch: word) {\\n                if(EMap.find(ch) != EMap.end())\\n                    val += EMap[ch];\\n                else {\\n                    flag = false;\\n                    break;\\n                }\\n            } \\n            if(flag)\\n            DMap[val]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1) {\\n            ans += EMap[ch];\\n        } \\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return DMap[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n\\n\\n//--------------------------------------\\n// Golang\\n//--------------------------------------\\ntype Encrypter struct {\\n    EMap map[byte]string\\n    DMap map[string]int\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    EMap := make(map[byte]string)\\n    DMap := make(map[string]int)\\n    for i := 0; i < len(keys); i++ {\\n        EMap[keys[i]] = values[i]\\n    }\\n    for _, word := range dictionary {\\n        val := \"\"\\n        flag := true\\n        for _, ch := range word {\\n            if _, ok := EMap[byte(ch)]; ok {\\n                val += EMap[byte(ch)]\\n            } else {\\n                flag = false\\n                break\\n            }\\n        } \\n        if flag {DMap[val]++} \\n    }\\n    return Encrypter {\\n        EMap: EMap,\\n        DMap: DMap,\\n    }\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    ans := \"\"\\n    for _, ch := range word1 {\\n        ans += this.EMap[byte(ch)]\\n    } \\n    return ans\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.DMap[word2]\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284893,
                "title": "c-trie-dfs",
                "content": "```\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& s:dictionary) add(s);\\n        vals.resize(128);\\n        for(int i=0;i<keys.size();i++){\\n            vals[keys[i]] = values[i];\\n            decodeMap[values[i]].push_back(keys[i]-\\'a\\');\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res;\\n        for(auto c:word1){\\n            if(vals[c].empty()) return {};\\n            res += vals[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int res = 0;\\n        decrypt(word2, 0, root, res);\\n        return res;\\n    }\\n\\nprivate:\\n    struct Node{\\n        bool isWord = false;\\n        Node* child[26] = {nullptr};\\n    };\\n\\n    void add(const string& s){\\n        auto p = root;\\n        for(auto c:s){\\n            if(!p->child[c-\\'a\\']) p->child[c-\\'a\\'] = new Node();\\n            p = p->child[c-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n\\n    void decrypt(const string& s, int i, Node* p, int& res){\\n        if(!p) return;\\n        if(i == s.size()){\\n            if(p->isWord) res++;\\n            return;\\n        }\\n        auto& v = decodeMap[s.substr(i, 2)];\\n        for(auto c:v){\\n            decrypt(s, i+2, p->child[c], res);\\n        }\\n    }\\n    \\n    Node* root = new Node();\\n    vector<string> vals;\\n    unordered_map<string, vector<int>> decodeMap;\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(auto& s:dictionary) add(s);\\n        vals.resize(128);\\n        for(int i=0;i<keys.size();i++){\\n            vals[keys[i]] = values[i];\\n            decodeMap[values[i]].push_back(keys[i]-\\'a\\');\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res;\\n        for(auto c:word1){\\n            if(vals[c].empty()) return {};\\n            res += vals[c];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        int res = 0;\\n        decrypt(word2, 0, root, res);\\n        return res;\\n    }\\n\\nprivate:\\n    struct Node{\\n        bool isWord = false;\\n        Node* child[26] = {nullptr};\\n    };\\n\\n    void add(const string& s){\\n        auto p = root;\\n        for(auto c:s){\\n            if(!p->child[c-\\'a\\']) p->child[c-\\'a\\'] = new Node();\\n            p = p->child[c-\\'a\\'];\\n        }\\n        p->isWord = true;\\n    }\\n\\n    void decrypt(const string& s, int i, Node* p, int& res){\\n        if(!p) return;\\n        if(i == s.size()){\\n            if(p->isWord) res++;\\n            return;\\n        }\\n        auto& v = decodeMap[s.substr(i, 2)];\\n        for(auto c:v){\\n            decrypt(s, i+2, p->child[c], res);\\n        }\\n    }\\n    \\n    Node* root = new Node();\\n    vector<string> vals;\\n    unordered_map<string, vector<int>> decodeMap;\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283180,
                "title": "c-solution-with-comments",
                "content": "unordered_map<char, string>m;\\n    unordered_map<string, int>dict;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n   //key--->value ki mapping kro\\n     int n = keys.size();   \\n     for(int i=0; i<n; i++){\\n         m[keys[i]] = values[i];\\n     }   \\n     //dictionary ke words  ko encrypt krkr unn encrypted words ki frequency store kro..   \\n     n = dictionary.size();  \\n     for(int i=0; i<n; i++){\\n        dict[encrypt(dictionary[i])]++; \\n     }   \\n    }\\n    \\n    string encrypt(string word1) {\\n    //map ki help de word1 ko encrypt kro\\n    int n = word1.size();  \\n      string ans = \"\";  \\n        for(int i=0; i<n; i++){\\n            if(m.find(word1[i]) == m.end())return \"\";\\n            else{\\n                ans += m[word1[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n   //map ke through word ko decrypt kro\\n        if(dict.find(word2) == dict.end())return 0;``\\n        return dict[word2];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "unordered_map<char, string>m;\\n    unordered_map<string, int>dict;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n   //key--->value ki mapping kro\\n     int n = keys.size();   \\n     for(int i=0; i<n; i++){\\n         m[keys[i]] = values[i];\\n     }   \\n     //dictionary ke words  ko encrypt krkr unn encrypted words ki frequency store kro..   \\n     n = dictionary.size();  \\n     for(int i=0; i<n; i++){\\n        dict[encrypt(dictionary[i])]++; \\n     }   \\n    }\\n    \\n    string encrypt(string word1) {\\n    //map ki help de word1 ko encrypt kro\\n    int n = word1.size();  \\n      string ans = \"\";  \\n        for(int i=0; i<n; i++){\\n            if(m.find(word1[i]) == m.end())return \"\";\\n            else{\\n                ans += m[word1[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n   //map ke through word ko decrypt kro\\n        if(dict.find(word2) == dict.end())return 0;``\\n        return dict[word2];\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3254331,
                "title": "using-hashmap",
                "content": "\\n# Code\\n```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243268,
                "title": "java-simple-solution-using-hashmap-and-its-methods",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encryptionMap;\\n    Map<String,Integer> wayToDecrypt;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encryptionMap=new HashMap<>();\\n        for(int i=0;i<keys.length;i++){\\n            encryptionMap.put(keys[i],values[i]);\\n        }\\n        wayToDecrypt=new HashMap<>();\\n        for(String w:dictionary){\\n            String encryptedStr=encrypt(w);\\n            wayToDecrypt.put(encryptedStr,wayToDecrypt.getOrDefault(encryptedStr,0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder encryptedStr=new StringBuilder();\\n        for(int i=0;i<word1.length();i++)\\n            encryptedStr.append(encryptionMap.getOrDefault(word1.charAt(i),\"#\"));\\n        return encryptedStr.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return wayToDecrypt.getOrDefault(word2,0);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105951,
                "title": "simple-solution-100-faster-using-hashtable-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will save values for encryption and as we have to decrypt word2 and see how many words can be made that lie in dict , so we will make encryption for words in dict and count in how many ways that encryption can be decrypted , so we can simply return in decrypt call .\\n![image.png](https://assets.leetcode.com/users/images/b48e583f-c741-4e4f-b8d9-9b7d0c74e89e_1674834382.4091935.png)\\n\\n# Complexity\\n- Time complexity: O(dict[i]*dict.length + word1.length**calls to encrypt)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Encrypter {\\npublic:\\n    vector<string> val;\\n    unordered_map<string,int> m;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        val.resize(26,\"\");\\n        for(int i=0;i<keys.size();i++){\\n            val[keys[i]-\\'a\\'] = values[i];\\n        }\\n        // we will simply store encrypt string\\n        for(auto s: dict){\\n            string tem = \"\";\\n            for(auto c: s){\\n                if(val[c-\\'a\\'] == \"\"){ tem =\"\"; break;}\\n                tem += val[c-\\'a\\'];\\n            }\\n            m[tem]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c: word1){\\n            if(val[c-\\'a\\'] == \"\") return \"\";\\n            ans += val[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(m.find(word2) != m.end()) return m[word2];\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<string> val;\\n    unordered_map<string,int> m;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dict) {\\n        val.resize(26,\"\");\\n        for(int i=0;i<keys.size();i++){\\n            val[keys[i]-\\'a\\'] = values[i];\\n        }\\n        // we will simply store encrypt string\\n        for(auto s: dict){\\n            string tem = \"\";\\n            for(auto c: s){\\n                if(val[c-\\'a\\'] == \"\"){ tem =\"\"; break;}\\n                tem += val[c-\\'a\\'];\\n            }\\n            m[tem]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c: word1){\\n            if(val[c-\\'a\\'] == \"\") return \"\";\\n            ans += val[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(m.find(word2) != m.end()) return m[word2];\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899070,
                "title": "golang-hash-map-and-trie",
                "content": "```go\\ntype TrieNode struct {\\n  Children [26]*TrieNode\\n  Word bool\\n}\\n\\ntype Encrypter struct {\\n  encryptsTo map[byte]string\\n  decryptsTo map[string][]byte\\n  dict *TrieNode\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n  encryptsTo := make(map[byte]string)\\n  decryptsTo := make(map[string][]byte)\\n  for i := 0; i < len(keys); i++ {\\n    encryptsTo[keys[i]] = values[i]\\n    decryptsTo[values[i]] = append(decryptsTo[values[i]], keys[i])\\n  }\\n  root := &TrieNode{}\\n  for _, word := range dictionary {\\n    insert(root, word)\\n  }\\n  return Encrypter{encryptsTo, decryptsTo, root}\\n}\\n\\nfunc insert(root *TrieNode, word string) {\\n  curr := root\\n  for i := 0; i < len(word); i++ {\\n    child := curr.Children[word[i]-\\'a\\']\\n    if child == nil {\\n      child = &TrieNode{}\\n      curr.Children[word[i]-\\'a\\'] = child\\n    }\\n    curr = child\\n  }\\n  curr.Word = true\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n  var res strings.Builder\\n  for i := 0; i < len(word1); i++ {\\n    if ct, ok := this.encryptsTo[word1[i]]; ok {\\n      res.WriteString(ct)\\n    } else {\\n      return \"\"\\n    }\\n  }\\n  return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n  return this.countDecryptions(this.dict, word2, 0)  \\n}\\n\\nfunc (this *Encrypter) countDecryptions(node *TrieNode, word string, pos int) int {\\n  if pos == len(word) {\\n    if node.Word {\\n      return 1\\n    }\\n    return 0\\n  }\\n  var res int\\n  ct := word[pos:pos+2]\\n  for _, key := range this.decryptsTo[ct] {\\n    child := node.Children[key-\\'a\\']\\n    if child != nil {\\n      res += this.countDecryptions(child, word, pos+2)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n ```",
                "solutionTags": [
                    "Go",
                    "Trie"
                ],
                "code": "```go\\ntype TrieNode struct {\\n  Children [26]*TrieNode\\n  Word bool\\n}\\n\\ntype Encrypter struct {\\n  encryptsTo map[byte]string\\n  decryptsTo map[string][]byte\\n  dict *TrieNode\\n}\\n\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n  encryptsTo := make(map[byte]string)\\n  decryptsTo := make(map[string][]byte)\\n  for i := 0; i < len(keys); i++ {\\n    encryptsTo[keys[i]] = values[i]\\n    decryptsTo[values[i]] = append(decryptsTo[values[i]], keys[i])\\n  }\\n  root := &TrieNode{}\\n  for _, word := range dictionary {\\n    insert(root, word)\\n  }\\n  return Encrypter{encryptsTo, decryptsTo, root}\\n}\\n\\nfunc insert(root *TrieNode, word string) {\\n  curr := root\\n  for i := 0; i < len(word); i++ {\\n    child := curr.Children[word[i]-\\'a\\']\\n    if child == nil {\\n      child = &TrieNode{}\\n      curr.Children[word[i]-\\'a\\'] = child\\n    }\\n    curr = child\\n  }\\n  curr.Word = true\\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n  var res strings.Builder\\n  for i := 0; i < len(word1); i++ {\\n    if ct, ok := this.encryptsTo[word1[i]]; ok {\\n      res.WriteString(ct)\\n    } else {\\n      return \"\"\\n    }\\n  }\\n  return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n  return this.countDecryptions(this.dict, word2, 0)  \\n}\\n\\nfunc (this *Encrypter) countDecryptions(node *TrieNode, word string, pos int) int {\\n  if pos == len(word) {\\n    if node.Word {\\n      return 1\\n    }\\n    return 0\\n  }\\n  var res int\\n  ct := word[pos:pos+2]\\n  for _, key := range this.decryptsTo[ct] {\\n    child := node.Children[key-\\'a\\']\\n    if child != nil {\\n      res += this.countDecryptions(child, word, pos+2)\\n    }\\n  }\\n  return res\\n}\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2826497,
                "title": "c-solution-using-little-string-trick",
                "content": "Well, unexpected problem : having problems in adding strings together (-_-) during encryption = time limit exceeded.\\n\\nSolution : Well, just realized that one can just set the resultant string into final size and assign characters to it = what do you know, 100 times faster than adding substrings (which will extend the string but I\\'ve never expected to have such a difference in runtime (-_-)) \\n\\nHa ha (-_-)\\n\\n```cpp\\nstruct n {\\n    char flag;\\n    n* chi[26];\\n    n() {\\n        for (int i = 0; i < 26; i++) {\\n            chi[i] = nullptr;\\n        }\\n    }\\n};\\nclass Encrypter {\\npublic:\\n    n* D;\\n    std::map<string, vector<char>> V;\\n    string M[26];\\n    int cnt, w2len;\\n    \\n    void insertT(n* T, string& str, char f) {\\n        for (char c : str) {\\n            if (T->chi[(c - \\'a\\')] == nullptr) {\\n                T->chi[(c - \\'a\\')] = new n();\\n            }\\n            T = T->chi[(c - \\'a\\')];\\n        }\\n        T->flag = f;\\n    }\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        D = new n();\\n        V = {};\\n        for (int i = 0; i < 26; i++) {\\n            M[i] = \"\";\\n        }\\n        for (int i = 0; i < values.size(); i++) {\\n            if (V.find(values[i]) == V.end()) {\\n                V[values[i]] = { keys[i] };\\n            }\\n            else {\\n                V[values[i]].push_back(keys[i]);\\n            }\\n            M[(keys[i] - \\'a\\')] = values[i];\\n        }    \\n        for (int i = 0; i < dictionary.size(); i++) {\\n            insertT(D, dictionary[i], \\'$\\');\\n        }\\n    }\\n    \\n    void opt(string& w2, int idx, n* cd) {\\n        string k = w2.substr(idx, 2);\\n        if (V.find(k) == V.end())\\n            return;\\n        else {\\n            for (char des : V[k]) {\\n                if (cd->chi[(des - \\'a\\')] != nullptr) {\\n                    if (idx + 2 == w2len && cd->chi[(des - \\'a\\')]->flag == \\'$\\') {\\n                        cnt++;\\n                    }\\n                    else {\\n                        opt(w2, idx + 2, cd->chi[(des - \\'a\\')]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = word1;\\n        res = res + word1;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (M[(word1[i] - \\'a\\')].length() == 0) {\\n                return \"\";\\n            }\\n            res[i * 2] = M[(word1[i] - \\'a\\')][0];\\n            res[i * 2 + 1] = M[(word1[i] - \\'a\\')][1];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        cnt = 0;\\n        w2len = word2.length();\\n        opt(word2, 0, D);\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```cpp\\nstruct n {\\n    char flag;\\n    n* chi[26];\\n    n() {\\n        for (int i = 0; i < 26; i++) {\\n            chi[i] = nullptr;\\n        }\\n    }\\n};\\nclass Encrypter {\\npublic:\\n    n* D;\\n    std::map<string, vector<char>> V;\\n    string M[26];\\n    int cnt, w2len;\\n    \\n    void insertT(n* T, string& str, char f) {\\n        for (char c : str) {\\n            if (T->chi[(c - \\'a\\')] == nullptr) {\\n                T->chi[(c - \\'a\\')] = new n();\\n            }\\n            T = T->chi[(c - \\'a\\')];\\n        }\\n        T->flag = f;\\n    }\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        D = new n();\\n        V = {};\\n        for (int i = 0; i < 26; i++) {\\n            M[i] = \"\";\\n        }\\n        for (int i = 0; i < values.size(); i++) {\\n            if (V.find(values[i]) == V.end()) {\\n                V[values[i]] = { keys[i] };\\n            }\\n            else {\\n                V[values[i]].push_back(keys[i]);\\n            }\\n            M[(keys[i] - \\'a\\')] = values[i];\\n        }    \\n        for (int i = 0; i < dictionary.size(); i++) {\\n            insertT(D, dictionary[i], \\'$\\');\\n        }\\n    }\\n    \\n    void opt(string& w2, int idx, n* cd) {\\n        string k = w2.substr(idx, 2);\\n        if (V.find(k) == V.end())\\n            return;\\n        else {\\n            for (char des : V[k]) {\\n                if (cd->chi[(des - \\'a\\')] != nullptr) {\\n                    if (idx + 2 == w2len && cd->chi[(des - \\'a\\')]->flag == \\'$\\') {\\n                        cnt++;\\n                    }\\n                    else {\\n                        opt(w2, idx + 2, cd->chi[(des - \\'a\\')]);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res = word1;\\n        res = res + word1;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (M[(word1[i] - \\'a\\')].length() == 0) {\\n                return \"\";\\n            }\\n            res[i * 2] = M[(word1[i] - \\'a\\')][0];\\n            res[i * 2 + 1] = M[(word1[i] - \\'a\\')][1];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        cnt = 0;\\n        w2len = word2.length();\\n        opt(word2, 0, D);\\n        return cnt;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813645,
                "title": "go-solution-with-trie",
                "content": "```\\n// 2227. Encrypt and Decrypt Strings\\n// 2227. \\u52A0\\u5BC6\\u89E3\\u5BC6\\u5B57\\u7B26\\u4E32\\n// \\u601D\\u8DEF\\uFF1A\\u9006\\u5411\\u601D\\u7EF4\\ntype Encrypter struct {\\n\\tchildren [26]*Encrypter\\n\\tisEnd    bool\\n\\tcount    int             // counting the number of dictionary\\'s word same encrypt code\\n\\tm        map[byte]string // keys[i]:values[i]\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\te := Encrypter{}\\n\\t// keys[i]:values[i]\\n\\te.m = make(map[byte]string, len(keys))\\n\\tfor i := 0; i < len(keys); i++ {\\n\\t\\te.m[keys[i]] = values[i]\\n\\t}\\n\\t// encrypt the words of the dictionary\\n\\t// and store them in a trie\\n\\t// with a count of each words.\\n\\tfor _, word := range dictionary {\\n\\t\\tw := e.Encrypt(word)\\n\\t\\tif len(w) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\te.insert(w)\\n\\t}\\n\\treturn e\\n}\\n\\nfunc (e *Encrypter) insert(w string) {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\tcur.children[ch-\\'a\\'] = &Encrypter{}\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\tcur.isEnd = true\\n\\tcur.count++\\n}\\n\\nfunc (e *Encrypter) search(w string) bool {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.isEnd\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Encrypt(w string) string {\\n\\tans := strings.Builder{}\\n\\tfor _, ch := range w {\\n\\t\\tval, ok := e.m[byte(ch)]\\n\\t\\tif !ok {\\n\\t\\t\\t// in case a character of the string is not present in keys,\\n\\t\\t\\t// the encryption process cannot be carried out,\\n\\t\\t\\t// and an empty string \"\" is returned.\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tans.WriteString(val)\\n\\t}\\n\\treturn ans.String()\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Decrypt(w string) int {\\n\\t// traversing over the trie\\n\\t// with decrypted word to get the count.\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.count\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Trie"
                ],
                "code": "```\\n// 2227. Encrypt and Decrypt Strings\\n// 2227. \\u52A0\\u5BC6\\u89E3\\u5BC6\\u5B57\\u7B26\\u4E32\\n// \\u601D\\u8DEF\\uFF1A\\u9006\\u5411\\u601D\\u7EF4\\ntype Encrypter struct {\\n\\tchildren [26]*Encrypter\\n\\tisEnd    bool\\n\\tcount    int             // counting the number of dictionary\\'s word same encrypt code\\n\\tm        map[byte]string // keys[i]:values[i]\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\te := Encrypter{}\\n\\t// keys[i]:values[i]\\n\\te.m = make(map[byte]string, len(keys))\\n\\tfor i := 0; i < len(keys); i++ {\\n\\t\\te.m[keys[i]] = values[i]\\n\\t}\\n\\t// encrypt the words of the dictionary\\n\\t// and store them in a trie\\n\\t// with a count of each words.\\n\\tfor _, word := range dictionary {\\n\\t\\tw := e.Encrypt(word)\\n\\t\\tif len(w) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\te.insert(w)\\n\\t}\\n\\treturn e\\n}\\n\\nfunc (e *Encrypter) insert(w string) {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\tcur.children[ch-\\'a\\'] = &Encrypter{}\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\tcur.isEnd = true\\n\\tcur.count++\\n}\\n\\nfunc (e *Encrypter) search(w string) bool {\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.isEnd\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Encrypt(w string) string {\\n\\tans := strings.Builder{}\\n\\tfor _, ch := range w {\\n\\t\\tval, ok := e.m[byte(ch)]\\n\\t\\tif !ok {\\n\\t\\t\\t// in case a character of the string is not present in keys,\\n\\t\\t\\t// the encryption process cannot be carried out,\\n\\t\\t\\t// and an empty string \"\" is returned.\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tans.WriteString(val)\\n\\t}\\n\\treturn ans.String()\\n}\\n\\n// time O(n) space O(n)\\nfunc (e *Encrypter) Decrypt(w string) int {\\n\\t// traversing over the trie\\n\\t// with decrypted word to get the count.\\n\\tcur := e\\n\\tfor _, ch := range w {\\n\\t\\tif cur.children[ch-\\'a\\'] == nil {\\n\\t\\t\\treturn 0\\n\\t\\t}\\n\\t\\tcur = cur.children[ch-\\'a\\']\\n\\t}\\n\\treturn cur.count\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * obj := Constructor(keys, values, dictionary);\\n * param_1 := obj.Encrypt(word1);\\n * param_2 := obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2806049,
                "title": "2-solutions-using-trie-and-2-maps-easy-to-understand-c",
                "content": "```\\n\\nvector<int> keyMap;\\n    unordered_map<string,int> decryptMap;\\n    vector<string> valueArr;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        valueArr = values;\\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            decryptMap[encrypt(w)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        int len = word1.length();\\n        string result(2*len,\\'a\\');\\n        for (int i = 0; i < len; i++) {\\n            int idx = keyMap[word1[i]-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result[2*i]   = valueArr[idx][0];\\n            result[2*i+1] = valueArr[idx][1];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n       auto it = decryptMap.find(word2);\\n       if (it == decryptMap.end())\\n           return 0;\\n       return it->second;\\n    }\\n\\t\\nclass Encrypter {\\npublic:\\n    \\n    // Construct the trie of the given word\\n    struct TrieNode {\\n        bool isLeaf;\\n       TrieNode* child[26];\\n    };\\n    \\n    TrieNode* root = NULL;\\n    TrieNode* makeTrieNode() {\\n        TrieNode* node = new TrieNode();\\n        node->isLeaf = false;\\n        for (int i = 0; i <  26; i++) {\\n            node->child[i] = NULL;\\n        }\\n        return node;\\n    }\\n    \\n    void addToTrie(string word) {\\n        if (!root) {\\n            root = makeTrieNode();\\n        }\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.length(); i++){\\n            int idx = word[i] - \\'a\\';\\n            if (!node->child[idx]) {\\n                node->child[idx] = makeTrieNode();\\n            }\\n            node = node->child[idx];\\n        }\\n        node->isLeaf = true;\\n    }\\n    \\n    \\n    \\n    int n = 26;\\n    \\n    vector<string> dict;\\n    vector<char> keyData;\\n    vector<int> keyMap;\\n    unordered_map<string,vector<int>> strKeyMap;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        keyData = keys;\\n        dict = values;\\n        \\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        // keep value to index mapping\\n        for (int i = 0; i < values.size(); i++) {\\n            strKeyMap[values[i]].push_back(i);\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            addToTrie(w);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (auto &c : word1) {\\n            int idx = keyMap[c-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result += dict[idx];\\n        }\\n        return result;\\n    }\\n    \\n    int helper(int idx, string &word, TrieNode* node) {\\n        // if no trie node return\\n        if (!node) {\\n            return 0;\\n        }\\n        \\n        // if reached end of the word, check if we are trieNode leaf\\n        if (idx == word.size()) {\\n            if (node->isLeaf) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        // check if current value has a key mapping\\n        string str = word.substr(idx,2);\\n        auto it = strKeyMap.find(str);\\n        if (it == strKeyMap.end())\\n            return 0;\\n        \\n        int ret = 0;\\n        // Iterate on list of possible keys\\n        for (auto &i : it->second) {\\n            int id = keyData[i] - \\'a\\';\\n            ret += helper(idx+2,word,node->child[id]);\\n        }\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n       string dWord;\\n       return helper(0,word2,root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvector<int> keyMap;\\n    unordered_map<string,int> decryptMap;\\n    vector<string> valueArr;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        valueArr = values;\\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            decryptMap[encrypt(w)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        int len = word1.length();\\n        string result(2*len,\\'a\\');\\n        for (int i = 0; i < len; i++) {\\n            int idx = keyMap[word1[i]-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result[2*i]   = valueArr[idx][0];\\n            result[2*i+1] = valueArr[idx][1];\\n        }\\n        return result;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n       auto it = decryptMap.find(word2);\\n       if (it == decryptMap.end())\\n           return 0;\\n       return it->second;\\n    }\\n\\t\\nclass Encrypter {\\npublic:\\n    \\n    // Construct the trie of the given word\\n    struct TrieNode {\\n        bool isLeaf;\\n       TrieNode* child[26];\\n    };\\n    \\n    TrieNode* root = NULL;\\n    TrieNode* makeTrieNode() {\\n        TrieNode* node = new TrieNode();\\n        node->isLeaf = false;\\n        for (int i = 0; i <  26; i++) {\\n            node->child[i] = NULL;\\n        }\\n        return node;\\n    }\\n    \\n    void addToTrie(string word) {\\n        if (!root) {\\n            root = makeTrieNode();\\n        }\\n        TrieNode* node = root;\\n        for (int i = 0; i < word.length(); i++){\\n            int idx = word[i] - \\'a\\';\\n            if (!node->child[idx]) {\\n                node->child[idx] = makeTrieNode();\\n            }\\n            node = node->child[idx];\\n        }\\n        node->isLeaf = true;\\n    }\\n    \\n    \\n    \\n    int n = 26;\\n    \\n    vector<string> dict;\\n    vector<char> keyData;\\n    vector<int> keyMap;\\n    unordered_map<string,vector<int>> strKeyMap;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        keyData = keys;\\n        dict = values;\\n        \\n        keyMap = vector<int>(26,-1);\\n        // keep key to index mapping\\n        for(int i = 0; i < keys.size(); i++) {\\n            keyMap[keys[i]-\\'a\\'] = i;\\n        }\\n        // keep value to index mapping\\n        for (int i = 0; i < values.size(); i++) {\\n            strKeyMap[values[i]].push_back(i);\\n        }\\n        \\n        // Create Trie for all dictionary words to search\\n        for (auto &w : dictionary) {\\n            addToTrie(w);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string result;\\n        for (auto &c : word1) {\\n            int idx = keyMap[c-\\'a\\'];\\n            if (idx == -1)\\n                return \"\";\\n            result += dict[idx];\\n        }\\n        return result;\\n    }\\n    \\n    int helper(int idx, string &word, TrieNode* node) {\\n        // if no trie node return\\n        if (!node) {\\n            return 0;\\n        }\\n        \\n        // if reached end of the word, check if we are trieNode leaf\\n        if (idx == word.size()) {\\n            if (node->isLeaf) {\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        \\n        // check if current value has a key mapping\\n        string str = word.substr(idx,2);\\n        auto it = strKeyMap.find(str);\\n        if (it == strKeyMap.end())\\n            return 0;\\n        \\n        int ret = 0;\\n        // Iterate on list of possible keys\\n        for (auto &i : it->second) {\\n            int id = keyData[i] - \\'a\\';\\n            ret += helper(idx+2,word,node->child[id]);\\n        }\\n        return ret;\\n    }\\n    \\n    int decrypt(string word2) {\\n       string dWord;\\n       return helper(0,word2,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780295,
                "title": "python-solution-using-trie-and-hash-table-o-len-word1-encrypt-and-o-len-word2-decrypt",
                "content": "\\n\\n# Code\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d1=[None for _ in range(26)]\\n        self.d2={}\\n        for i,item in enumerate(keys):\\n            self.d1[ord(item)-97]=values[i]\\n        self.dict=Trie()\\n        for item in dictionary:\\n            val=self.encrypt(item)\\n            self.dict.insert(val)\\n    def encrypt(self, word1: str) -> str:\\n        ans=[]\\n        for item in word1:\\n            item=ord(item)-97\\n            if(not self.d1[item]):\\n                return \"\"\\n            else:\\n                ans.append(self.d1[item])\\n        return \"\".join(ans)\\n    def decrypt(self, word2: str) -> int:\\n        return self.dict.search(word2)\\n\\nclass Trie:\\n    def __init__(self):\\n        self.child=[None for _ in range(26)]\\n        self.count=0\\n    def insert(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                self.child[j]=Trie()\\n            self=self.child[j]\\n        self.count+=1\\n    def search(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                return 0\\n            self=self.child[j]\\n        return self.count\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d1=[None for _ in range(26)]\\n        self.d2={}\\n        for i,item in enumerate(keys):\\n            self.d1[ord(item)-97]=values[i]\\n        self.dict=Trie()\\n        for item in dictionary:\\n            val=self.encrypt(item)\\n            self.dict.insert(val)\\n    def encrypt(self, word1: str) -> str:\\n        ans=[]\\n        for item in word1:\\n            item=ord(item)-97\\n            if(not self.d1[item]):\\n                return \"\"\\n            else:\\n                ans.append(self.d1[item])\\n        return \"\".join(ans)\\n    def decrypt(self, word2: str) -> int:\\n        return self.dict.search(word2)\\n\\nclass Trie:\\n    def __init__(self):\\n        self.child=[None for _ in range(26)]\\n        self.count=0\\n    def insert(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                self.child[j]=Trie()\\n            self=self.child[j]\\n        self.count+=1\\n    def search(self,word):\\n        for item in word:\\n            j=ord(item)-97\\n            if(not self.child[j]):\\n                return 0\\n            self=self.child[j]\\n        return self.count\\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779845,
                "title": "rust-solution-with-hashmap-28-ms-6-3-mb",
                "content": "\\nKey Idea :  encrypt and decrypt will be called around 200 times for one new call, so, even if new is slow, if encrypt and decrypt are relatively fast, the whole process would be fast. \\n\\nEncrypt will have to remain O(N) because, we don\\'t know which all words can be encrypted so we can not cache them prior to it\\'s call.\\n\\nDecrypt on the other hand returns how many Strings upon encryption in Dictionary will return that string. Since the dictionary is only initialized once, and has finite number of words with finite length, we can cache it\\'s results in a hashmap. So, if we have the encrypted string as key, we can use that to get the count or return 0.\\n\\nWith some other minor optimizations, we can get the final Space and Time Complexities of the functions like so\\n\\nnew() -> TC : O(N<sup>2</sup>), SC : O(N)\\nEncrypt -> TC : O(N), SC : O(N)\\nDecrypt -> TC : O*(1), SC : O(1)\\n\\n**Note that since we are using a HashMap, the time complexity can get to O(N), however, here since the number of words in dictionary isn\\'t that much, it\\'s O(1).**\\n\\n```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    value_map : [String; 26],\\n    dict_map : HashMap<String, i32>\\n}\\n\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut value_map : [String; 26] = Default::default();\\n        \\n        keys\\n\\t\\t.into_iter()\\n\\t\\t.zip(values.into_iter())\\n\\t\\t.for_each(\\n\\t\\t\\t#[inline]\\n\\t\\t\\t|(key, value)| \\n\\t\\t\\tvalue_map[(key as u8 - b\\'a\\') as usize] = value\\n\\t\\t);\\n        \\n        let mut res = Self{\\n            value_map,\\n            dict_map : HashMap::with_capacity(5)\\n        };\\n        \\n        for word in dictionary {\\n            let key = res.encrypt(word);\\n            *res.dict_map.entry(key).or_insert(0) += 1;\\n        }\\n        \\n        res\\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res : String = String::with_capacity(word1.len() * 2);\\n        \\n        for b in word1.into_bytes() {\\n            if !self.value_map[(b - b\\'a\\') as usize].is_empty(){\\n                res.push_str(&self.value_map[(b - b\\'a\\') as usize]);\\n            } else {\\n                return String::new()\\n            }\\n        }\\n        \\n        res\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        *self.dict_map.get(&word2).unwrap_or(&0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct Encrypter {\\n    value_map : [String; 26],\\n    dict_map : HashMap<String, i32>\\n}\\n\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut value_map : [String; 26] = Default::default();\\n        \\n        keys\\n\\t\\t.into_iter()\\n\\t\\t.zip(values.into_iter())\\n\\t\\t.for_each(\\n\\t\\t\\t#[inline]\\n\\t\\t\\t|(key, value)| \\n\\t\\t\\tvalue_map[(key as u8 - b\\'a\\') as usize] = value\\n\\t\\t);\\n        \\n        let mut res = Self{\\n            value_map,\\n            dict_map : HashMap::with_capacity(5)\\n        };\\n        \\n        for word in dictionary {\\n            let key = res.encrypt(word);\\n            *res.dict_map.entry(key).or_insert(0) += 1;\\n        }\\n        \\n        res\\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res : String = String::with_capacity(word1.len() * 2);\\n        \\n        for b in word1.into_bytes() {\\n            if !self.value_map[(b - b\\'a\\') as usize].is_empty(){\\n                res.push_str(&self.value_map[(b - b\\'a\\') as usize]);\\n            } else {\\n                return String::new()\\n            }\\n        }\\n        \\n        res\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        *self.dict_map.get(&word2).unwrap_or(&0)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2779656,
                "title": "javascript-the-hard-way",
                "content": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    var i;\\n    \\n    this.ks = {};\\n    this.sk = {};\\n    \\n    let paintTrie = function(word, key) {\\n        var i;\\n        let sk = this.sk;\\n        \\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in sk) ) sk[word[i]] = {};\\n            sk = sk[word[i]];\\n        }\\n        if( !(\\'key\\' in sk) ) sk.key = new Set();\\n        sk.key.add(key);\\n    }\\n    var sk;\\n    for( i=0; i<keys.length; i++ ) {\\n        this.ks[keys[i]] = values[i];\\n        \\n        paintTrie.bind(this)(values[i], keys[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    this.dictrie = {};\\n    var dt, word;\\n    for( word of this.dict ) {\\n        dt = this.dictrie;\\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in dt) ) dt[word[i]] = {};\\n            dt = dt[word[i]];\\n        }\\n        dt.valid = true;\\n    }\\n};\\n\\nEncrypter.prototype.encrypt = function(word1) {\\n    var i, result=\"\";\\n    for( i=0; i<word1.length; i++ ) {\\n        result += this.ks[word1[i]];\\n    }\\n    return result;\\n};\\n\\nEncrypter.prototype.decrypt = function(word2) {\\n    let ways = function(i=0, ansTrees=null) {\\n        var j, k, y, z;\\n        var sk = this.sk;\\n        var ans = 0;\\n        var res, subtrees, subkeys;\\n        \\n\\n        if( ansTrees === null ) ansTrees = [this.dictrie];\\n        if( i >= word2.length ) {\\n            let count=0;\\n            for( j=0; j<ansTrees.length; j++ ) {\\n                if( ansTrees[j].valid === true )\\n                    count++;\\n            }\\n            return count;\\n        }\\n        \\n        for( j=i; j<word2.length; j++ ) {\\n            if( !(word2[j] in sk) )\\n                break;\\n            sk = sk[word2[j]];\\n            \\n            if( \\'key\\' in sk ) {\\n                subkeys = [];\\n                subtrees = [];\\n                for( res of sk.key ) {\\n                    for( y=0; y<ansTrees.length; y++ ) {\\n                        dt = ansTrees[y];\\n                        for( k=0; k<res.length; k++ ) {\\n                            if( !(res[k] in dt) ) break;\\n                            dt = dt[res[k]];\\n                        }\\n                        if( k<res.length ) continue;\\n                        subkeys.push(res);\\n                        subtrees.push(dt);\\n                    }\\n                }\\n                if( subkeys.length == 0 ) continue;\\n                \\n                let sub = ways.bind(this)( j+1, subtrees );\\n                ans += sub;\\n            }\\n        }\\n        \\n        return ans;\\n    };\\n    \\n    return ways.bind(this)();\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    var i;\\n    \\n    this.ks = {};\\n    this.sk = {};\\n    \\n    let paintTrie = function(word, key) {\\n        var i;\\n        let sk = this.sk;\\n        \\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in sk) ) sk[word[i]] = {};\\n            sk = sk[word[i]];\\n        }\\n        if( !(\\'key\\' in sk) ) sk.key = new Set();\\n        sk.key.add(key);\\n    }\\n    var sk;\\n    for( i=0; i<keys.length; i++ ) {\\n        this.ks[keys[i]] = values[i];\\n        \\n        paintTrie.bind(this)(values[i], keys[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    this.dictrie = {};\\n    var dt, word;\\n    for( word of this.dict ) {\\n        dt = this.dictrie;\\n        for( i=0; i<word.length; i++ ) {\\n            if( !(word[i] in dt) ) dt[word[i]] = {};\\n            dt = dt[word[i]];\\n        }\\n        dt.valid = true;\\n    }\\n};\\n\\nEncrypter.prototype.encrypt = function(word1) {\\n    var i, result=\"\";\\n    for( i=0; i<word1.length; i++ ) {\\n        result += this.ks[word1[i]];\\n    }\\n    return result;\\n};\\n\\nEncrypter.prototype.decrypt = function(word2) {\\n    let ways = function(i=0, ansTrees=null) {\\n        var j, k, y, z;\\n        var sk = this.sk;\\n        var ans = 0;\\n        var res, subtrees, subkeys;\\n        \\n\\n        if( ansTrees === null ) ansTrees = [this.dictrie];\\n        if( i >= word2.length ) {\\n            let count=0;\\n            for( j=0; j<ansTrees.length; j++ ) {\\n                if( ansTrees[j].valid === true )\\n                    count++;\\n            }\\n            return count;\\n        }\\n        \\n        for( j=i; j<word2.length; j++ ) {\\n            if( !(word2[j] in sk) )\\n                break;\\n            sk = sk[word2[j]];\\n            \\n            if( \\'key\\' in sk ) {\\n                subkeys = [];\\n                subtrees = [];\\n                for( res of sk.key ) {\\n                    for( y=0; y<ansTrees.length; y++ ) {\\n                        dt = ansTrees[y];\\n                        for( k=0; k<res.length; k++ ) {\\n                            if( !(res[k] in dt) ) break;\\n                            dt = dt[res[k]];\\n                        }\\n                        if( k<res.length ) continue;\\n                        subkeys.push(res);\\n                        subtrees.push(dt);\\n                    }\\n                }\\n                if( subkeys.length == 0 ) continue;\\n                \\n                let sub = ways.bind(this)( j+1, subtrees );\\n                ans += sub;\\n            }\\n        }\\n        \\n        return ans;\\n    };\\n    \\n    return ways.bind(this)();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703218,
                "title": "easy-understanding-map",
                "content": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            // cout<<encrypt(x)<<\" \";\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            if(kmap.find(x) == kmap.end()) return \"\";\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    map<char,string> kmap;\\n    map<string,int> rmap;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic) {\\n        int n = keys.size();\\n        for(int i  = 0 ; i < n ; i++){\\n            kmap[keys[i]] = values[i];\\n        }\\n        for(auto x : dic){\\n            // cout<<encrypt(x)<<\" \";\\n            rmap[encrypt(x)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto x : word1){\\n            if(kmap.find(x) == kmap.end()) return \"\";\\n            ans += kmap[x];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        return rmap[word2];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2665637,
                "title": "one-hashmap-use",
                "content": "class Encrypter {\\n\\n    String[] key = new String[26];\\n    String[] dictionary;\\n    HashMap<String,Integer> H;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        H = new HashMap<>();\\n        simplyKeys(keys,values);\\n        this.dictionary=dictionary;\\n        addHashMap();\\n    }\\n    \\n    public void simplyKeys(char[] keys,String[] values){\\n        for(int i=0;i<keys.length;i++){\\n            key[keys[i]-\\'a\\']=values[i];\\n        }\\n    }\\n    \\n    public void addHashMap(){\\n        for(String dict : dictionary){\\n            H.put(encrypt(dict),H.getOrDefault(encrypt(dict),0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String res = \"\";\\n        for(char ch : word1.toCharArray()){\\n            if(key[ch-\\'a\\']==null ||key[ch-\\'a\\']==\"\") return \"\";\\n            else res+=key[ch-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return H.containsKey(word2) ? H.get(word2) : 0;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Encrypter {\\n\\n    String[] key = new String[26];\\n    String[] dictionary;\\n    HashMap<String,Integer> H;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        H = new HashMap<>();\\n        simplyKeys(keys,values);\\n        this.dictionary=dictionary;\\n        addHashMap();\\n    }\\n    \\n    public void simplyKeys(char[] keys,String[] values){\\n        for(int i=0;i<keys.length;i++){\\n            key[keys[i]-\\'a\\']=values[i];\\n        }\\n    }\\n    \\n    public void addHashMap(){\\n        for(String dict : dictionary){\\n            H.put(encrypt(dict),H.getOrDefault(encrypt(dict),0)+1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String res = \"\";\\n        for(char ch : word1.toCharArray()){\\n            if(key[ch-\\'a\\']==null ||key[ch-\\'a\\']==\"\") return \"\";\\n            else res+=key[ch-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return H.containsKey(word2) ? H.get(word2) : 0;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2599073,
                "title": "kotlin-100-time-and-space-saving-dictionary-in-trie-checking-recursively",
                "content": "```\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n\\n    class TrieNode(val next: Array<TrieNode?> = Array(26) { null }, var isEnd: Boolean = false)\\n\\n    val forward = mutableMapOf<Char, String>().also {\\n        keys.forEachIndexed { index, c ->\\n            it[c] = values[index]\\n        }\\n    }\\n    val backward = mutableMapOf<String, MutableList<Char>>().also {\\n        values.forEachIndexed { index, str ->\\n            it[str] = (it[str] ?: mutableListOf()).also {\\n                it.add(keys[index])\\n            }\\n        }\\n    }\\n\\n    // for dictionary [a, aba, acba, abaff] trie will be\\n\\t//\\n    //                        *root*\\n    //                      a (end=true)\\n    //                b            c\\n    //        a (end = true)     b\\n    //          f               a (end = true)\\n    //            f (end = true)\\n    //\\n    val root = TrieNode().also { root ->\\n        dictionary.forEach {dicStr ->\\n            var nowItem = root\\n            dicStr.forEachIndexed { index, ch ->\\n                if (nowItem.next[ch - \\'a\\'] == null) {\\n                    TrieNode(isEnd = (index == dicStr.length-1)).also {\\n                        nowItem.next[ch - \\'a\\'] = it\\n                        nowItem = it\\n                    }\\n                } else {\\n\\n                    nowItem = nowItem.next[ch - \\'a\\']!!.also {\\n                        it.isEnd = it.isEnd || (index == dicStr.length-1)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        return word1.asSequence().map { forward[it] }.joinToString(\"\")\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var cantBeAny = false\\n        val possChars = word2.chunked(2).asSequence().map {\\n            backward[it] ?: mutableListOf<Char>().also {\\n                cantBeAny = true\\n            }\\n        }.toList().toTypedArray()\\n\\n        // odd length or any of pair is not present in \\'values\\' array\\n        if (cantBeAny) return 0\\n\\n        var count = 0\\n\\n        fun tryAdd(nowNode: TrieNode, index: Int) {\\n            if (index == possChars.size - 1) { // last char checking\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        if(nextNode.isEnd) {\\n                            count++\\n                        }\\n                    }\\n                }\\n            } else {\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        tryAdd(nextNode, index + 1)\\n                    }\\n                }\\n            }\\n        }\\n\\n        tryAdd(root, 0)\\n        return count\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n\\n    class TrieNode(val next: Array<TrieNode?> = Array(26) { null }, var isEnd: Boolean = false)\\n\\n    val forward = mutableMapOf<Char, String>().also {\\n        keys.forEachIndexed { index, c ->\\n            it[c] = values[index]\\n        }\\n    }\\n    val backward = mutableMapOf<String, MutableList<Char>>().also {\\n        values.forEachIndexed { index, str ->\\n            it[str] = (it[str] ?: mutableListOf()).also {\\n                it.add(keys[index])\\n            }\\n        }\\n    }\\n\\n    // for dictionary [a, aba, acba, abaff] trie will be\\n\\t//\\n    //                        *root*\\n    //                      a (end=true)\\n    //                b            c\\n    //        a (end = true)     b\\n    //          f               a (end = true)\\n    //            f (end = true)\\n    //\\n    val root = TrieNode().also { root ->\\n        dictionary.forEach {dicStr ->\\n            var nowItem = root\\n            dicStr.forEachIndexed { index, ch ->\\n                if (nowItem.next[ch - \\'a\\'] == null) {\\n                    TrieNode(isEnd = (index == dicStr.length-1)).also {\\n                        nowItem.next[ch - \\'a\\'] = it\\n                        nowItem = it\\n                    }\\n                } else {\\n\\n                    nowItem = nowItem.next[ch - \\'a\\']!!.also {\\n                        it.isEnd = it.isEnd || (index == dicStr.length-1)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        return word1.asSequence().map { forward[it] }.joinToString(\"\")\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var cantBeAny = false\\n        val possChars = word2.chunked(2).asSequence().map {\\n            backward[it] ?: mutableListOf<Char>().also {\\n                cantBeAny = true\\n            }\\n        }.toList().toTypedArray()\\n\\n        // odd length or any of pair is not present in \\'values\\' array\\n        if (cantBeAny) return 0\\n\\n        var count = 0\\n\\n        fun tryAdd(nowNode: TrieNode, index: Int) {\\n            if (index == possChars.size - 1) { // last char checking\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        if(nextNode.isEnd) {\\n                            count++\\n                        }\\n                    }\\n                }\\n            } else {\\n                possChars[index].forEach {\\n                    nowNode.next[it - \\'a\\']?.let { nextNode ->\\n                        tryAdd(nextNode, index + 1)\\n                    }\\n                }\\n            }\\n        }\\n\\n        tryAdd(root, 0)\\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521009,
                "title": "c",
                "content": "```\\npublic class Encrypter {\\n    Trie t;\\n    Dictionary<char,string> d;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        d = new Dictionary<char,string>();\\n        t = new Trie();\\n        for(int i = 0; i < keys.Length; i++){\\n            d[keys[i]] = values[i];\\n        }\\n        foreach(var i in dictionary){\\n            string check = Encrypt(i);\\n            if(!string.IsNullOrEmpty(check))\\n              t.Insert(check);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string res = \"\";\\n        foreach(var i in word1){\\n            if(d.ContainsKey(i))\\n                res+= d[i];\\n            else return string.Empty;\\n        }\\n        return res;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        return t.Search(word2);\\n    }\\n}\\n\\npublic class Trie{\\n    public TrieNode root = new TrieNode();\\n    \\n    public void Insert(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)){\\n                temp.ch.Add(i,new TrieNode());\\n            }\\n            temp = temp.ch[i];\\n        }\\n        temp.end += 1;\\n    }\\n    public int Search(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)) return 0;\\n            temp = temp.ch[i];\\n        }\\n        return temp.end;\\n    }\\n}\\npublic class TrieNode{\\n    public char val;\\n    public Dictionary<char,TrieNode> ch = new ();\\n    public int end;\\n    \\n    public TrieNode(){}\\n    \\n    public TrieNode(char val){\\n        this.val = val;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\npublic class Encrypter {\\n    Trie t;\\n    Dictionary<char,string> d;\\n\\n    public Encrypter(char[] keys, string[] values, string[] dictionary) {\\n        d = new Dictionary<char,string>();\\n        t = new Trie();\\n        for(int i = 0; i < keys.Length; i++){\\n            d[keys[i]] = values[i];\\n        }\\n        foreach(var i in dictionary){\\n            string check = Encrypt(i);\\n            if(!string.IsNullOrEmpty(check))\\n              t.Insert(check);\\n        }\\n    }\\n    \\n    public string Encrypt(string word1) {\\n        string res = \"\";\\n        foreach(var i in word1){\\n            if(d.ContainsKey(i))\\n                res+= d[i];\\n            else return string.Empty;\\n        }\\n        return res;\\n    }\\n    \\n    public int Decrypt(string word2) {\\n        return t.Search(word2);\\n    }\\n}\\n\\npublic class Trie{\\n    public TrieNode root = new TrieNode();\\n    \\n    public void Insert(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)){\\n                temp.ch.Add(i,new TrieNode());\\n            }\\n            temp = temp.ch[i];\\n        }\\n        temp.end += 1;\\n    }\\n    public int Search(string word){\\n        var temp = root;\\n        foreach(var i in word){\\n            if(!temp.ch.ContainsKey(i)) return 0;\\n            temp = temp.ch[i];\\n        }\\n        return temp.end;\\n    }\\n}\\npublic class TrieNode{\\n    public char val;\\n    public Dictionary<char,TrieNode> ch = new ();\\n    public int end;\\n    \\n    public TrieNode(){}\\n    \\n    public TrieNode(char val){\\n        this.val = val;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj.Encrypt(word1);\\n * int param_2 = obj.Decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514185,
                "title": "c-hashmap",
                "content": "```\\nclass Encrypter {\\npublic:\\n    vector<int>hash;\\n    vector<char>keys;\\n    vector<string>dict,values;\\n    unordered_map<string,int>mpEncrpyted;\\n    Encrypter(vector<char>& key, vector<string>& value, vector<string>& dictionary) {\\n        hash=vector<int>(26,-1);\\n        for(int i=0;i<key.size();i++)\\n        {\\n            hash[key[i]-\\'a\\']=i;\\n        }\\n        \\n        keys=key;\\n        values=value;\\n        dict=dictionary;\\n        for(string s:dict)\\n        {\\n            mpEncrpyted[encrypt(s)]++;\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        int n=word1.length();\\n        string ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash[word1[i]-\\'a\\']==-1)return \"\";\\n            ans+=values[hash[word1[i]-\\'a\\']];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return mpEncrpyted[word2];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    vector<int>hash;\\n    vector<char>keys;\\n    vector<string>dict,values;\\n    unordered_map<string,int>mpEncrpyted;\\n    Encrypter(vector<char>& key, vector<string>& value, vector<string>& dictionary) {\\n        hash=vector<int>(26,-1);\\n        for(int i=0;i<key.size();i++)\\n        {\\n            hash[key[i]-\\'a\\']=i;\\n        }\\n        \\n        keys=key;\\n        values=value;\\n        dict=dictionary;\\n        for(string s:dict)\\n        {\\n            mpEncrpyted[encrypt(s)]++;\\n        }\\n        \\n    }\\n    \\n    string encrypt(string word1) {\\n        int n=word1.length();\\n        string ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(hash[word1[i]-\\'a\\']==-1)return \"\";\\n            ans+=values[hash[word1[i]-\\'a\\']];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return mpEncrpyted[word2];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496934,
                "title": "python-dictionary-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], d: List[str]):\\n        self.look = dict(zip(keys, values))\\n        self.d = Counter(self.encrypt(c) for c in d)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.look.get(c, \\'#\\') for c in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], d: List[str]):\\n        self.look = dict(zip(keys, values))\\n        self.d = Counter(self.encrypt(c) for c in d)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.look.get(c, \\'#\\') for c in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488939,
                "title": "encrypt",
                "content": "class Encrypter {\\npublic:\\n    map<char,string>mp1;\\n    map<string,set<char>>mp2;\\n     vector<string>d;\\n    Encrypter(vector<char>& key, vector<string>& values, vector<string>& dict) {\\n        for(int i=0;i<key.size();i++){\\n            mp1[key[i]]=values[i];\\n            mp2[values[i]].insert(key[i]);\\n        }\\n        d=dict;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(auto x:word1){\\n            if(mp1.find(x)==mp1.end()) return \"\";\\n            res+=mp1[x];\\n        }\\n        return res;\\n    }\\n    int decrypt(string w) {\\n        int n=w.size();\\n        if(n%2) return 0;\\n        int ans=0;\\n        for(auto s:d){\\n            if(w==encrypt(s)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Encrypter {\\npublic:\\n    map<char,string>mp1;\\n    map<string,set<char>>mp2;\\n     vector<string>d;\\n    Encrypter(vector<char>& key, vector<string>& values, vector<string>& dict) {\\n        for(int i=0;i<key.size();i++){\\n            mp1[key[i]]=values[i];\\n            mp2[values[i]].insert(key[i]);\\n        }\\n        d=dict;\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(auto x:word1){\\n            if(mp1.find(x)==mp1.end()) return \"\";\\n            res+=mp1[x];\\n        }\\n        return res;\\n    }\\n    int decrypt(string w) {\\n        int n=w.size();\\n        if(n%2) return 0;\\n        int ans=0;\\n        for(auto s:d){\\n            if(w==encrypt(s)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2488362,
                "title": "python-trie",
                "content": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h=defaultdict(lambda:\\'*\\')\\n        for key,value in zip(keys,values):\\n            self.h[key]=value\\n        self.trie=Trie()\\n        for word in dictionary:\\n            self.trie.add(\\'\\'.join(self.h[x] for x in word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.h[x] for x in word1 if self.h[x]!=\\'*\\')\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.trie.get(word2)\\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n    def add(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                node[cur]={}\\n            node=node[cur]\\n        if \\'#\\' not in node:\\n            node[\\'#\\']=1\\n        else:\\n            node[\\'#\\']+=1\\n    def get(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                return 0\\n            else:\\n                node=node[cur]\\n        if \\'#\\' in node:\\n            return node[\\'#\\']\\n        else:\\n            return 0\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.h=defaultdict(lambda:\\'*\\')\\n        for key,value in zip(keys,values):\\n            self.h[key]=value\\n        self.trie=Trie()\\n        for word in dictionary:\\n            self.trie.add(\\'\\'.join(self.h[x] for x in word))\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \\'\\'.join(self.h[x] for x in word1 if self.h[x]!=\\'*\\')\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.trie.get(word2)\\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root={}\\n    def add(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                node[cur]={}\\n            node=node[cur]\\n        if \\'#\\' not in node:\\n            node[\\'#\\']=1\\n        else:\\n            node[\\'#\\']+=1\\n    def get(self,word):\\n        node=self.root\\n        for i in range(0,len(word),2):\\n            cur=word[i:i+2]\\n            if cur not in node:\\n                return 0\\n            else:\\n                node=node[cur]\\n        if \\'#\\' in node:\\n            return node[\\'#\\']\\n        else:\\n            return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483394,
                "title": "just-use-encrypt-for-decrypt-simple-python-solution",
                "content": "```\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = {c : i for i, c in enumerate(keys)}\\n        self.val_list = values\\n        self.dict = set(dictionary)\\n       \\n    def encrypt(self, word1: str) -> str:    \\n        ans = \\'\\'\\n        for c in word1:\\n            if c not in self.keys:\\n                return \\'\\'\\n            ans += self.val_list[self.keys[c]]\\n        return ans \\n\\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        cnt = 0\\n        for c in self.dict:\\n            ans = self.encrypt(c)\\n            if ans == word2:\\n                cnt += 1\\n        \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.keys = {c : i for i, c in enumerate(keys)}\\n        self.val_list = values\\n        self.dict = set(dictionary)\\n       \\n    def encrypt(self, word1: str) -> str:    \\n        ans = \\'\\'\\n        for c in word1:\\n            if c not in self.keys:\\n                return \\'\\'\\n            ans += self.val_list[self.keys[c]]\\n        return ans \\n\\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        cnt = 0\\n        for c in self.dict:\\n            ans = self.encrypt(c)\\n            if ans == word2:\\n                cnt += 1\\n        \\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2471560,
                "title": "python",
                "content": "```\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.dic = {x : i for i, x in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = dictionary\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for i in word1:\\n            if i not in self.dic:\\n                return \\'\\'\\n            res += self.values[self.dic[i]]\\n        return res\\n\\n    def decrypt(self, word2: str) -> int:\\n        cnt = 0\\n        for i in self.dictionary:\\n            s = self.encrypt(i)\\n            if s == word2:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.dic = {x : i for i, x in enumerate(keys)}\\n        self.values = values\\n        self.dictionary = dictionary\\n\\n    def encrypt(self, word1: str) -> str:\\n        res = \\'\\'\\n        for i in word1:\\n            if i not in self.dic:\\n                return \\'\\'\\n            res += self.values[self.dic[i]]\\n        return res\\n\\n    def decrypt(self, word2: str) -> int:\\n        cnt = 0\\n        for i in self.dictionary:\\n            s = self.encrypt(i)\\n            if s == word2:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2402687,
                "title": "java-hashmap-84",
                "content": "```\\nclass Encrypter {\\n    Map<Character,String> encTable;\\n    Map<String,Integer> dictionaryMap;\\n    int decRes;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encTable = new HashMap<>();\\n        dictionaryMap = new HashMap<>();\\n        for(int i = 0; i < keys.length; i++){\\n            encTable.put(keys[i], values[i]);            \\n        }\\n        \\n        for(String s : dictionary){\\n            char[] cArr = s.toCharArray();\\n            StringBuilder sb = new StringBuilder();\\n            boolean appendYn = true;\\n            for(char c : cArr){\\n                if(!encTable.containsKey(c)){\\n                    appendYn = false;\\n                    break;                    \\n                }\\n                sb.append(encTable.get(c));\\n            }            \\n            \\n            if(!appendYn){\\n                continue;\\n            }\\n            \\n            String d = sb.toString();\\n            if(d.length() > 0){\\n                dictionaryMap.put(d,dictionaryMap.getOrDefault(d,0)+1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] cArr = word1.toCharArray();\\n        for(char c : cArr){\\n            sb.append(encTable.get(c));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {        \\n        return dictionaryMap.getOrDefault(word2,0);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> encTable;\\n    Map<String,Integer> dictionaryMap;\\n    int decRes;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        encTable = new HashMap<>();\\n        dictionaryMap = new HashMap<>();\\n        for(int i = 0; i < keys.length; i++){\\n            encTable.put(keys[i], values[i]);            \\n        }\\n        \\n        for(String s : dictionary){\\n            char[] cArr = s.toCharArray();\\n            StringBuilder sb = new StringBuilder();\\n            boolean appendYn = true;\\n            for(char c : cArr){\\n                if(!encTable.containsKey(c)){\\n                    appendYn = false;\\n                    break;                    \\n                }\\n                sb.append(encTable.get(c));\\n            }            \\n            \\n            if(!appendYn){\\n                continue;\\n            }\\n            \\n            String d = sb.toString();\\n            if(d.length() > 0){\\n                dictionaryMap.put(d,dictionaryMap.getOrDefault(d,0)+1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] cArr = word1.toCharArray();\\n        for(char c : cArr){\\n            sb.append(encTable.get(c));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {        \\n        return dictionaryMap.getOrDefault(word2,0);\\n    }\\n    \\n}",
                "codeTag": "Java"
            },
            {
                "id": 2309711,
                "title": "javascript-easy-to-undertand-beats-67",
                "content": "```\\nclass Encrypter {\\n    constructor (keys, values, dictionary) {\\n        this.encryptMap = keys.reduce((map, key, i) => (map[key] = values[i], map), {});\\n        this.encryptedVals = [...new Set(dictionary)].map((w) => this.encrypt(w));\\n    }\\n    \\n    encrypt (word) {\\n        return word.split(``).reduce((s, c) => s + this.encryptMap[c], ``);\\n    }\\n    \\n    decrypt (word) {\\n        return this.encryptedVals.filter((x) => x === word).length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Encrypter {\\n    constructor (keys, values, dictionary) {\\n        this.encryptMap = keys.reduce((map, key, i) => (map[key] = values[i], map), {});\\n        this.encryptedVals = [...new Set(dictionary)].map((w) => this.encrypt(w));\\n    }\\n    \\n    encrypt (word) {\\n        return word.split(``).reduce((s, c) => s + this.encryptMap[c], ``);\\n    }\\n    \\n    decrypt (word) {\\n        return this.encryptedVals.filter((x) => x === word).length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286710,
                "title": "javascript-with-pre-encryption",
                "content": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    this.encryptMap = new Map();\\n    for (let i = 0; i < keys.length; i++) {\\n        this.encryptMap.set(keys[i], values[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    // Encypt the values in dict for easy comparison later\\n    this.encryptedVals = [];\\n    for (let word of this.dict) {\\n        this.encryptedVals.push(this.encrypt(word));\\n    }\\n};\\nEncrypter.prototype.encrypt = function(word1) {\\n    let encrypted = \\'\\';\\n    for (let char of word1) {\\n        encrypted += this.encryptMap.get(char);\\n    }\\n    return encrypted;\\n};\\nEncrypter.prototype.decrypt = function(word2) {\\n    return this.encryptedVals.filter(x => x === word2).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Encrypter = function(keys, values, dictionary) {\\n    this.encryptMap = new Map();\\n    for (let i = 0; i < keys.length; i++) {\\n        this.encryptMap.set(keys[i], values[i]);\\n    }\\n    this.dict = new Set(dictionary);\\n    // Encypt the values in dict for easy comparison later\\n    this.encryptedVals = [];\\n    for (let word of this.dict) {\\n        this.encryptedVals.push(this.encrypt(word));\\n    }\\n};\\nEncrypter.prototype.encrypt = function(word1) {\\n    let encrypted = \\'\\';\\n    for (let char of word1) {\\n        encrypted += this.encryptMap.get(char);\\n    }\\n    return encrypted;\\n};\\nEncrypter.prototype.decrypt = function(word2) {\\n    return this.encryptedVals.filter(x => x === word2).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126251,
                "title": "java-easy-solution-without-using-trie",
                "content": "\\n\\n\\n```\\nMap<Character, String> eMap;\\n    Map<String, Integer> dMap;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        eMap = new HashMap<>();\\n        dMap = new HashMap<>();\\n        for (int i = 0; i < keys.length; i++) \\n            eMap.put(keys[i], values[i]);\\n\\n        for (int i = 0; i < dictionary.length; i++) {\\n            String str = encrypt(dictionary[i]);\\n\\t\\t\\t/*\\n\\t\\t\\tInput: [\"Encrypter\",\"decrypt\"]  [[[\"a\"],[\"pq\"],[\"aa\",\"x\"]],[\"null\"]]\\n            Output: [null,1]   <------ wrong o/p\\n           Expected: [null,0]\\n\\t\\t\\tto avoid wrong ans,\\n\\t\\t\\twe need to put \"if condition\" after that we need to add in dMap to update the current value\\n\\t\\t\\t*/\\n            if (!str.equals(\"\") && !str.equals(\"null\"))\\n                dMap.put(str, dMap.getOrDefault(str, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            sb.append(eMap.get(c));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return dMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nMap<Character, String> eMap;\\n    Map<String, Integer> dMap;\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        eMap = new HashMap<>();\\n        dMap = new HashMap<>();\\n        for (int i = 0; i < keys.length; i++) \\n            eMap.put(keys[i], values[i]);\\n\\n        for (int i = 0; i < dictionary.length; i++) {\\n            String str = encrypt(dictionary[i]);\\n\\t\\t\\t/*\\n\\t\\t\\tInput: [\"Encrypter\",\"decrypt\"]  [[[\"a\"],[\"pq\"],[\"aa\",\"x\"]],[\"null\"]]\\n            Output: [null,1]   <------ wrong o/p\\n           Expected: [null,0]\\n\\t\\t\\tto avoid wrong ans,\\n\\t\\t\\twe need to put \"if condition\" after that we need to add in dMap to update the current value\\n\\t\\t\\t*/\\n            if (!str.equals(\"\") && !str.equals(\"null\"))\\n                dMap.put(str, dMap.getOrDefault(str, 0) + 1);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            sb.append(eMap.get(c));\\n        }\\n        return sb.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        return dMap.getOrDefault(word2, 0);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2101700,
                "title": "kotlin-simple-ds-to-reverse-check-the-elements-without-a-trie",
                "content": "```\\nclass MultiString(val size: Int) {\\n    private val indexList: Array<MutableSet<Char>> = Array(size) {it -> mutableSetOf<Char>()}\\n    \\n    fun addPossibleCharsAtIndex(chars: Collection<Char>, index: Int) {\\n        indexList[index].addAll(chars)\\n    }\\n    \\n    override fun toString(): String {\\n        return indexList.joinToString(\",\")\\n    }\\n    fun match(other: String): Boolean {\\n        if(other.length != size) {\\n            return false\\n        }\\n        for(i in 0 until other.length) {\\n            if(!indexList[i].contains(other[i])) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n    \\n    private val keyMap = mutableMapOf<Char, String>()\\n    private val reverseMap = mutableMapOf<String, MutableSet<Char>>()\\n    private val dictSet = mutableListOf<String>()\\n    \\n    init {\\n        for(i in 0 until keys.size) {\\n            keyMap[keys[i]] = values[i]\\n            val reverseSet = reverseMap[values[i]] ?: mutableSetOf<Char>()\\n            reverseSet.add(keys[i])\\n            reverseMap[values[i]] = reverseSet\\n        }\\n        dictSet.addAll(dictionary)\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        val result = StringBuilder()\\n        var ok = true\\n        for(c in word1) {\\n            val value = keyMap[c] ?: run {\\n                ok = false\\n            }\\n            if(!ok) {\\n                break\\n            }\\n            result.append(value)\\n        }\\n        if(!ok) {\\n            return \"\"\\n        }\\n        return result.toString()\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var count = 0\\n        val word2MultiString = MultiString(word2.length/2)\\n        for(i in 0 until word2.length step 2) {\\n            val currentString = \"\" + word2[i] + word2[i+1]\\n            val chars = reverseMap[currentString] ?: return 0\\n            word2MultiString.addPossibleCharsAtIndex(chars, i/2)\\n        }\\n        //println(word2MultiString)\\n        \\n        for(dict in dictSet) {\\n            if(word2MultiString.match(dict)) {\\n                //println(\"$dict is a match\")\\n                count++\\n            }\\n        }\\n        return count\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass MultiString(val size: Int) {\\n    private val indexList: Array<MutableSet<Char>> = Array(size) {it -> mutableSetOf<Char>()}\\n    \\n    fun addPossibleCharsAtIndex(chars: Collection<Char>, index: Int) {\\n        indexList[index].addAll(chars)\\n    }\\n    \\n    override fun toString(): String {\\n        return indexList.joinToString(\",\")\\n    }\\n    fun match(other: String): Boolean {\\n        if(other.length != size) {\\n            return false\\n        }\\n        for(i in 0 until other.length) {\\n            if(!indexList[i].contains(other[i])) {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n}\\n\\nclass Encrypter(keys: CharArray, values: Array<String>, dictionary: Array<String>) {\\n    \\n    private val keyMap = mutableMapOf<Char, String>()\\n    private val reverseMap = mutableMapOf<String, MutableSet<Char>>()\\n    private val dictSet = mutableListOf<String>()\\n    \\n    init {\\n        for(i in 0 until keys.size) {\\n            keyMap[keys[i]] = values[i]\\n            val reverseSet = reverseMap[values[i]] ?: mutableSetOf<Char>()\\n            reverseSet.add(keys[i])\\n            reverseMap[values[i]] = reverseSet\\n        }\\n        dictSet.addAll(dictionary)\\n    }\\n\\n    fun encrypt(word1: String): String {\\n        val result = StringBuilder()\\n        var ok = true\\n        for(c in word1) {\\n            val value = keyMap[c] ?: run {\\n                ok = false\\n            }\\n            if(!ok) {\\n                break\\n            }\\n            result.append(value)\\n        }\\n        if(!ok) {\\n            return \"\"\\n        }\\n        return result.toString()\\n    }\\n\\n    fun decrypt(word2: String): Int {\\n        var count = 0\\n        val word2MultiString = MultiString(word2.length/2)\\n        for(i in 0 until word2.length step 2) {\\n            val currentString = \"\" + word2[i] + word2[i+1]\\n            val chars = reverseMap[currentString] ?: return 0\\n            word2MultiString.addPossibleCharsAtIndex(chars, i/2)\\n        }\\n        //println(word2MultiString)\\n        \\n        for(dict in dictSet) {\\n            if(word2MultiString.match(dict)) {\\n                //println(\"$dict is a match\")\\n                count++\\n            }\\n        }\\n        return count\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054508,
                "title": "java-trie",
                "content": "```\\nclass Encrypter {\\n    \\n    Map<Character,Integer> map = new HashMap<>();\\n    Map<String,List<Integer>> valueMap = new HashMap<>();\\n    char [] keys;\\n\\tTrie trie = new Trie();\\n    String[] values;\\n    \\n    class Trie{\\n        Map<Character,Trie> children = new HashMap<>();\\n        boolean leaf = false;\\n        \\n        void insert(String str,int idx){\\n            if(idx>=str.length()){\\n                this.leaf = true;\\n                return;\\n            }\\n            Trie child = children.get(str.charAt(idx));\\n            if(child==null){\\n                children.put(str.charAt(idx),new Trie());\\n            }\\n            children.get(str.charAt(idx)).insert(str,idx+1);\\n        }\\n        \\n        int search(String str, int idx){\\n            if(str.length()%2!=0){\\n                return 0;\\n            }\\n            if(idx>=str.length()){\\n                return this.leaf?1:0;\\n            }\\n            int count = 0;\\n            String next = str.substring(idx,idx+2);\\n            List<Integer> nextIndicies = valueMap.getOrDefault(next,new ArrayList<>());\\n            for(Integer nextIndex:nextIndicies){\\n                if(children.containsKey(keys[nextIndex])){\\n                    count += children.get(keys[nextIndex]).search(str, idx + 2);\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        for(int i= 0;i<keys.length;i++){\\n            map.put(keys[i],i);\\n        }\\n        for(int i= 0;i<values.length;i++){\\n            List<Integer> list = valueMap.getOrDefault(values[i],new ArrayList<>());\\n            list.add(i);\\n            valueMap.put(values[i],list);\\n        }\\n        \\n        for(String str : dictionary){\\n            trie.insert(str,0);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuffer b = new StringBuffer();\\n        for(char ch : word1.toCharArray()){\\n            if(map.containsKey(ch)){\\n                b.append(values[map.get(ch)]);\\n            }else{\\n                return \"\";\\n            }\\n        }\\n        return b.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return trie.search(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    \\n    Map<Character,Integer> map = new HashMap<>();\\n    Map<String,List<Integer>> valueMap = new HashMap<>();\\n    char [] keys;\\n\\tTrie trie = new Trie();\\n    String[] values;\\n    \\n    class Trie{\\n        Map<Character,Trie> children = new HashMap<>();\\n        boolean leaf = false;\\n        \\n        void insert(String str,int idx){\\n            if(idx>=str.length()){\\n                this.leaf = true;\\n                return;\\n            }\\n            Trie child = children.get(str.charAt(idx));\\n            if(child==null){\\n                children.put(str.charAt(idx),new Trie());\\n            }\\n            children.get(str.charAt(idx)).insert(str,idx+1);\\n        }\\n        \\n        int search(String str, int idx){\\n            if(str.length()%2!=0){\\n                return 0;\\n            }\\n            if(idx>=str.length()){\\n                return this.leaf?1:0;\\n            }\\n            int count = 0;\\n            String next = str.substring(idx,idx+2);\\n            List<Integer> nextIndicies = valueMap.getOrDefault(next,new ArrayList<>());\\n            for(Integer nextIndex:nextIndicies){\\n                if(children.containsKey(keys[nextIndex])){\\n                    count += children.get(keys[nextIndex]).search(str, idx + 2);\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        for(int i= 0;i<keys.length;i++){\\n            map.put(keys[i],i);\\n        }\\n        for(int i= 0;i<values.length;i++){\\n            List<Integer> list = valueMap.getOrDefault(values[i],new ArrayList<>());\\n            list.add(i);\\n            valueMap.put(values[i],list);\\n        }\\n        \\n        for(String str : dictionary){\\n            trie.insert(str,0);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuffer b = new StringBuffer();\\n        for(char ch : word1.toCharArray()){\\n            if(map.containsKey(ch)){\\n                b.append(values[map.get(ch)]);\\n            }else{\\n                return \"\";\\n            }\\n        }\\n        return b.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return trie.search(word2,0);\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2023323,
                "title": "c-without-trie",
                "content": "```\\n#define forup(i,i0,n) for(int i=i0; i<=(int)n; i++)\\n#define fordown(i,n,i0) for(int i=n; i>=(int)i0; i--)\\n\\nclass Encrypter {\\n    map <char, string> keyToVal; \\n    map <string, set <char> > valToKey; \\n    vector <string> d; \\npublic:\\n    Encrypter(vector<char> keys, vector<string> values, vector<string> dict) {\\n        forup(i,0,keys.size()-1) {\\n            keyToVal[keys[i]] = values[i];\\n            valToKey[values[i]].insert(keys[i]);\\n        }\\n        d = dict;\\n    }\\n    \\n    string encrypt(string w) {\\n        string res=\"\";\\n        forup(i,0,w.size()-1) {\\n            if (keyToVal.find(w[i]) == keyToVal.end()) return \"\"; \\n            res += keyToVal[w[i]]; \\n        }\\n        return res; \\n    }\\n    \\n    int decrypt(string w) {\\n        int n = w.size();\\n        if (n%2 == 1) return 0; \\n        int ans = 0;\\n        for(string cand : d) {\\n            if (cand.size() == n/2) {\\n                bool ok = true; \\n                for(int i = 0; i < n; i+=2) {\\n                    string val = \"\"; val+=w[i]; val+=w[i+1]; \\n                    if (valToKey.find(val) != valToKey.end()) {\\n                        if (valToKey[val].find(cand[i/2]) == valToKey[val].end()) ok = false; \\n                    }\\n                    else ok = false; \\n                }\\n                if (ok) ans++;\\n            }\\n        }\\n        return ans;          \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define forup(i,i0,n) for(int i=i0; i<=(int)n; i++)\\n#define fordown(i,n,i0) for(int i=n; i>=(int)i0; i--)\\n\\nclass Encrypter {\\n    map <char, string> keyToVal; \\n    map <string, set <char> > valToKey; \\n    vector <string> d; \\npublic:\\n    Encrypter(vector<char> keys, vector<string> values, vector<string> dict) {\\n        forup(i,0,keys.size()-1) {\\n            keyToVal[keys[i]] = values[i];\\n            valToKey[values[i]].insert(keys[i]);\\n        }\\n        d = dict;\\n    }\\n    \\n    string encrypt(string w) {\\n        string res=\"\";\\n        forup(i,0,w.size()-1) {\\n            if (keyToVal.find(w[i]) == keyToVal.end()) return \"\"; \\n            res += keyToVal[w[i]]; \\n        }\\n        return res; \\n    }\\n    \\n    int decrypt(string w) {\\n        int n = w.size();\\n        if (n%2 == 1) return 0; \\n        int ans = 0;\\n        for(string cand : d) {\\n            if (cand.size() == n/2) {\\n                bool ok = true; \\n                for(int i = 0; i < n; i+=2) {\\n                    string val = \"\"; val+=w[i]; val+=w[i+1]; \\n                    if (valToKey.find(val) != valToKey.end()) {\\n                        if (valToKey[val].find(cand[i/2]) == valToKey[val].end()) ok = false; \\n                    }\\n                    else ok = false; \\n                }\\n                if (ok) ans++;\\n            }\\n        }\\n        return ans;          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973915,
                "title": "c-trie-based-solution",
                "content": "```\\nclass Encrypter {\\n    unordered_map<char, string> map;\\n    unordered_map<string, vector<char>> reverse_map;\\n    class trie {\\n      vector<trie*> next;\\n      bool end;\\n    public:\\n      trie() {\\n        next.resize(26, nullptr);\\n        end = false;\\n      }\\n      ~trie() {\\n        for (trie *t : next) delete t;\\n        next.clear();\\n      }\\n      void add(const std::string &s) {\\n        trie *t = this;\\n        for (int i = 0; i < s.length(); i++) {\\n          if (t->next[s[i]-\\'a\\'] == nullptr) {\\n            t->next[s[i]-\\'a\\'] = new trie;\\n          }\\n          t = t->next[s[i]-\\'a\\'];\\n        }\\n        t->end = true;\\n      }\\n      trie* nextNode(char ch) {\\n        return next[ch-\\'a\\'];\\n      }\\n      bool isValid() { return end; }        \\n    };\\n    trie t;    \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (string &s: dictionary)\\n          t.add(s);\\n        for (int i = 0; i < keys.size(); i++) { \\n            map[keys[i]] = values[i];\\n            reverse_map[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for (char ch: word1) {\\n            auto it = map.find(ch);\\n            if (it != map.end())\\n                ss << it->second;\\n            else ss << ch;\\n        }\\n        return ss.str();\\n    }\\n\\n    void helper(std::string &s, int &cnt, int index, trie* node) {\\n      if (index >= s.length()) {\\n        if (node && node->isValid())\\n            cnt++;\\n        return;\\n      }\\n      string t = s.substr(index, 2);\\n      for (char ch: reverse_map[t]) {\\n        trie *t_node = node->nextNode(ch);\\n        if (t_node != nullptr) {\\n          helper(s, cnt, index+2, t_node);\\n        }\\n      }\\n    }    \\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        helper(word2, cnt, 0, &t);\\n        return cnt;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    unordered_map<char, string> map;\\n    unordered_map<string, vector<char>> reverse_map;\\n    class trie {\\n      vector<trie*> next;\\n      bool end;\\n    public:\\n      trie() {\\n        next.resize(26, nullptr);\\n        end = false;\\n      }\\n      ~trie() {\\n        for (trie *t : next) delete t;\\n        next.clear();\\n      }\\n      void add(const std::string &s) {\\n        trie *t = this;\\n        for (int i = 0; i < s.length(); i++) {\\n          if (t->next[s[i]-\\'a\\'] == nullptr) {\\n            t->next[s[i]-\\'a\\'] = new trie;\\n          }\\n          t = t->next[s[i]-\\'a\\'];\\n        }\\n        t->end = true;\\n      }\\n      trie* nextNode(char ch) {\\n        return next[ch-\\'a\\'];\\n      }\\n      bool isValid() { return end; }        \\n    };\\n    trie t;    \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (string &s: dictionary)\\n          t.add(s);\\n        for (int i = 0; i < keys.size(); i++) { \\n            map[keys[i]] = values[i];\\n            reverse_map[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        stringstream ss;\\n        for (char ch: word1) {\\n            auto it = map.find(ch);\\n            if (it != map.end())\\n                ss << it->second;\\n            else ss << ch;\\n        }\\n        return ss.str();\\n    }\\n\\n    void helper(std::string &s, int &cnt, int index, trie* node) {\\n      if (index >= s.length()) {\\n        if (node && node->isValid())\\n            cnt++;\\n        return;\\n      }\\n      string t = s.substr(index, 2);\\n      for (char ch: reverse_map[t]) {\\n        trie *t_node = node->nextNode(ch);\\n        if (t_node != nullptr) {\\n          helper(s, cnt, index+2, t_node);\\n        }\\n      }\\n    }    \\n    int decrypt(string word2) {\\n        int cnt = 0;\\n        helper(word2, cnt, 0, &t);\\n        return cnt;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969128,
                "title": "java-trie-based-faster-than-95-mem-less-than-87",
                "content": "```\\nclass Encrypter {\\n    Map<Character, Integer> keysMap;\\n    Map<String, Set<Integer>> valuesMap;\\n    char[] keys;\\n    String[] values;\\n    Trie trie;\\n    Map<String, Integer> decMem;\\n    Map<String, String> encMem;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.keysMap = new HashMap<>();\\n        this.valuesMap = new HashMap<>();\\n        this.trie = new Trie();\\n        decMem = new HashMap<>();\\n        encMem = new HashMap<>();\\n        for(int i=0; i<keys.length; i++){\\n            keysMap.put(keys[i], i);\\n        }\\n        for(int i=0; i< this.values.length; i++){\\n            Set<Integer> st = valuesMap.getOrDefault(values[i], new HashSet<>());\\n            st.add(i);\\n            valuesMap.put(values[i], st);\\n        }\\n        for(String s: dictionary){\\n            trie.add(s);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        if(encMem.containsKey(word1)) return encMem.get(word1);\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0; i<word1.length(); i++){\\n            if(!keysMap.containsKey(word1.charAt(i))) return \"\";\\n            String repl = this.values[keysMap.get(word1.charAt(i))];\\n            res.append(repl);\\n        }\\n        String ans = res.toString();\\n        encMem.put(word1, ans);\\n        return ans;\\n    } \\n     public int decrypt(String word2) {\\n         if(decMem.containsKey(word2)) return decMem.get(word2);\\n         int ans = decryptRec(word2, 0, new StringBuilder(), this.trie);\\n         decMem.put(word2, ans);\\n         return ans;\\n     }\\n    public int decryptRec(String word2, int start, StringBuilder prefix, Trie t) {\\n        //handle base case\\n        if(start>=word2.length()) {\\n            if(this.trie.wordExists(prefix)) return 1;\\n            return 0;\\n        }\\n        String hashed = word2.substring(start, start+2);\\n        Set<Integer> indcs = valuesMap.getOrDefault(hashed, new HashSet<>());\\n        int ans = 0;\\n        for(Integer i: indcs){\\n            char repl = keys[i];\\n            prefix.append(repl);\\n            if(t.links.containsKey(repl)) ans = ans + decryptRec(word2, start+2, prefix, t.links.get(repl));\\n            prefix.deleteCharAt(prefix.length()-1);\\n        }\\n        return ans;\\n    }\\n}\\nclass Trie{\\n    Map<Character, Trie> links = new HashMap<>();\\n    boolean isTerminal = false;\\n    String word = null;\\n    public void add(String s){\\n        Trie cur = this;\\n        for(int i=0; i<s.length(); i++){\\n            Trie next = cur.links.getOrDefault(s.charAt(i), new Trie());\\n            cur.links.put(s.charAt(i), next);\\n            if(i==s.length()-1){\\n                next.isTerminal = true;\\n                next.word = s;\\n            }\\n            cur = next;\\n        }\\n    }\\n    public boolean prefixExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return true;\\n    }\\n    public boolean wordExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            if(i==p.length()-1 && t.links.get(p.charAt(i)).isTerminal) return true;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\n    Map<Character, Integer> keysMap;\\n    Map<String, Set<Integer>> valuesMap;\\n    char[] keys;\\n    String[] values;\\n    Trie trie;\\n    Map<String, Integer> decMem;\\n    Map<String, String> encMem;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.keys = keys;\\n        this.values = values;\\n        this.keysMap = new HashMap<>();\\n        this.valuesMap = new HashMap<>();\\n        this.trie = new Trie();\\n        decMem = new HashMap<>();\\n        encMem = new HashMap<>();\\n        for(int i=0; i<keys.length; i++){\\n            keysMap.put(keys[i], i);\\n        }\\n        for(int i=0; i< this.values.length; i++){\\n            Set<Integer> st = valuesMap.getOrDefault(values[i], new HashSet<>());\\n            st.add(i);\\n            valuesMap.put(values[i], st);\\n        }\\n        for(String s: dictionary){\\n            trie.add(s);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        if(encMem.containsKey(word1)) return encMem.get(word1);\\n        StringBuilder res = new StringBuilder();\\n        for(int i=0; i<word1.length(); i++){\\n            if(!keysMap.containsKey(word1.charAt(i))) return \"\";\\n            String repl = this.values[keysMap.get(word1.charAt(i))];\\n            res.append(repl);\\n        }\\n        String ans = res.toString();\\n        encMem.put(word1, ans);\\n        return ans;\\n    } \\n     public int decrypt(String word2) {\\n         if(decMem.containsKey(word2)) return decMem.get(word2);\\n         int ans = decryptRec(word2, 0, new StringBuilder(), this.trie);\\n         decMem.put(word2, ans);\\n         return ans;\\n     }\\n    public int decryptRec(String word2, int start, StringBuilder prefix, Trie t) {\\n        //handle base case\\n        if(start>=word2.length()) {\\n            if(this.trie.wordExists(prefix)) return 1;\\n            return 0;\\n        }\\n        String hashed = word2.substring(start, start+2);\\n        Set<Integer> indcs = valuesMap.getOrDefault(hashed, new HashSet<>());\\n        int ans = 0;\\n        for(Integer i: indcs){\\n            char repl = keys[i];\\n            prefix.append(repl);\\n            if(t.links.containsKey(repl)) ans = ans + decryptRec(word2, start+2, prefix, t.links.get(repl));\\n            prefix.deleteCharAt(prefix.length()-1);\\n        }\\n        return ans;\\n    }\\n}\\nclass Trie{\\n    Map<Character, Trie> links = new HashMap<>();\\n    boolean isTerminal = false;\\n    String word = null;\\n    public void add(String s){\\n        Trie cur = this;\\n        for(int i=0; i<s.length(); i++){\\n            Trie next = cur.links.getOrDefault(s.charAt(i), new Trie());\\n            cur.links.put(s.charAt(i), next);\\n            if(i==s.length()-1){\\n                next.isTerminal = true;\\n                next.word = s;\\n            }\\n            cur = next;\\n        }\\n    }\\n    public boolean prefixExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return true;\\n    }\\n    public boolean wordExists(StringBuilder p){\\n        Trie t = this;\\n        for(int i=0; i<p.length(); i++){\\n            if(!t.links.containsKey(p.charAt(i))) return false;\\n            if(i==p.length()-1 && t.links.get(p.charAt(i)).isTerminal) return true;\\n            t = t.links.get(p.charAt(i));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1962125,
                "title": "c-2227-encrypt-and-decrypt-strings",
                "content": "\\n```\\nclass Encrypter {\\n    unordered_map<char, string> mp; \\n    unordered_map<string, int> freq; \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) mp[keys[i]] = values[i]; \\n        for (auto& word : dictionary) {\\n            string key; \\n            for (auto& ch : word) \\n                if (!mp.count(ch)) key += \"##\"; \\n                else key += mp[ch]; \\n            ++freq[key]; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans; \\n        for (auto& ch : word1) ans += mp[ch]; \\n        return ans; \\n    }\\n    \\n    int decrypt(string word2) {\\n        return freq[word2]; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\n    unordered_map<char, string> mp; \\n    unordered_map<string, int> freq; \\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for (int i = 0; i < keys.size(); ++i) mp[keys[i]] = values[i]; \\n        for (auto& word : dictionary) {\\n            string key; \\n            for (auto& ch : word) \\n                if (!mp.count(ch)) key += \"##\"; \\n                else key += mp[ch]; \\n            ++freq[key]; \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans; \\n        for (auto& ch : word1) ans += mp[ch]; \\n        return ans; \\n    }\\n    \\n    int decrypt(string word2) {\\n        return freq[word2]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1947464,
                "title": "simple-python-solution",
                "content": "class Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n\\n        self.values=values\\n        self.keys=keys\\n        self.dic=defaultdict(int)\\n        for i in dictionary:\\n            self.dic[self.encrypt(i)]+=1\\n        \\n        \"\"\"\\n        :type keys: List[str]\\n        :type values: List[str]\\n        :type dictionary: List[str]\\n        \"\"\"\\n        \\n\\n    def encrypt(self, word1):\\n        ans=\"\"\\n        for i in word1:\\n            if i not in self.keys:\\n                return 0\\n            ans+=self.values[(self.keys.index(i))]\\n        return ans\\n        \"\"\"\\n        :type word1: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\n    def decrypt(self, word2):\\n        return self.dic[word2]\\n        \"\"\"\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Encrypter(object):\\n\\n    def __init__(self, keys, values, dictionary):\\n\\n        self.values=values\\n        self.keys=keys\\n        self.dic=defaultdict(int)\\n        for i in dictionary:\\n            self.dic[self.encrypt(i)]+=1\\n        \\n        \"\"\"\\n        :type keys: List[str]\\n        :type values: List[str]\\n        :type dictionary: List[str]\\n        \"\"\"\\n        \\n\\n    def encrypt(self, word1):\\n        ans=\"\"\\n        for i in word1:\\n            if i not in self.keys:\\n                return 0\\n            ans+=self.values[(self.keys.index(i))]\\n        return ans\\n        \"\"\"\\n        :type word1: str\\n        :rtype: str\\n        \"\"\"\\n        \\n\\n    def decrypt(self, word2):\\n        return self.dic[word2]\\n        \"\"\"\\n        :type word2: str\\n        :rtype: int\\n        \"\"\"\\n        \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1942236,
                "title": "trie-bfs",
                "content": "```\\nclass Encrypter \\n{\\nprivate:\\n    unordered_map<char,string> m;\\n    unordered_map<string,vector<char>> ump;\\n    struct Node\\n    {\\n        Node* links[26];\\n        bool flag=false;\\n        \\n        bool containsKey(char ch)\\n        {\\n            return links[ch-\\'a\\']!=nullptr;\\n        }\\n\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        \\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        \\n        void setEnd()\\n        {\\n            flag = true;\\n        }\\n    };\\n    \\n    void insert(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(!node->containsKey(word[i]))\\n            {\\n                node->put(word[i],new Node());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    \\n    bool search(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(node->containsKey(word[i]))\\n                node=node->get(word[i]);\\n            else\\n                return false;\\n        }\\n        return node->flag;\\n    }\\n    Node* root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) \\n    {\\n        root=new Node();\\n        for(string s:dictionary)\\n            insert(root,s);\\n        ump.clear();\\n        m.clear();\\n        for(int i=0;i<keys.size();i++){\\n            m[keys[i]]=values[i];\\n            ump[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) \\n    {\\n        string ans=\"\";\\n        for(char c : word1)\\n        {\\n            ans+=m[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) \\n    {\\n        int ans=0;\\n        vector<vector<char>> v;        \\n        for(int i=0;i<word2.length();i+=2)\\n        {\\n            string str = word2.substr(i,2);\\n            vector<char> temp;\\n            for(char c : ump[str])\\n            {\\n                temp.push_back(c);\\n            }    \\n            v.push_back(temp);\\n        }\\n        int j=0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int f = v.size()-1;\\n        \\n        while(j<v.size() && !q.empty())\\n        {\\n            Node* temp = q.front();\\n            if(temp == nullptr)\\n            {\\n                j++;\\n                q.pop();\\n                if(j!=v.size())\\n                    q.push(nullptr);\\n                continue;\\n            }\\n            if(j != f)\\n            {                \\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        q.push(temp->get(ch));\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        Node* t = temp->get(ch);\\n                        if(t->flag)\\n                            ans++;                        \\n                    }\\n                }\\n            }  \\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Trie",
                    "Queue"
                ],
                "code": "```\\nclass Encrypter \\n{\\nprivate:\\n    unordered_map<char,string> m;\\n    unordered_map<string,vector<char>> ump;\\n    struct Node\\n    {\\n        Node* links[26];\\n        bool flag=false;\\n        \\n        bool containsKey(char ch)\\n        {\\n            return links[ch-\\'a\\']!=nullptr;\\n        }\\n\\n        void put(char ch,Node* node)\\n        {\\n            links[ch-\\'a\\']=node;\\n        }\\n        \\n        Node* get(char ch)\\n        {\\n            return links[ch-\\'a\\'];\\n        }\\n        \\n        void setEnd()\\n        {\\n            flag = true;\\n        }\\n    };\\n    \\n    void insert(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(!node->containsKey(word[i]))\\n            {\\n                node->put(word[i],new Node());\\n            }\\n            node = node->get(word[i]);\\n        }\\n        node->setEnd();\\n    }\\n    \\n    bool search(Node* node,string word)\\n    {\\n        for(int i=0;i<word.length();i++)\\n        {\\n            if(node->containsKey(word[i]))\\n                node=node->get(word[i]);\\n            else\\n                return false;\\n        }\\n        return node->flag;\\n    }\\n    Node* root;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) \\n    {\\n        root=new Node();\\n        for(string s:dictionary)\\n            insert(root,s);\\n        ump.clear();\\n        m.clear();\\n        for(int i=0;i<keys.size();i++){\\n            m[keys[i]]=values[i];\\n            ump[values[i]].push_back(keys[i]);\\n        }\\n    }\\n    \\n    string encrypt(string word1) \\n    {\\n        string ans=\"\";\\n        for(char c : word1)\\n        {\\n            ans+=m[c];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) \\n    {\\n        int ans=0;\\n        vector<vector<char>> v;        \\n        for(int i=0;i<word2.length();i+=2)\\n        {\\n            string str = word2.substr(i,2);\\n            vector<char> temp;\\n            for(char c : ump[str])\\n            {\\n                temp.push_back(c);\\n            }    \\n            v.push_back(temp);\\n        }\\n        int j=0;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(nullptr);\\n        int f = v.size()-1;\\n        \\n        while(j<v.size() && !q.empty())\\n        {\\n            Node* temp = q.front();\\n            if(temp == nullptr)\\n            {\\n                j++;\\n                q.pop();\\n                if(j!=v.size())\\n                    q.push(nullptr);\\n                continue;\\n            }\\n            if(j != f)\\n            {                \\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        q.push(temp->get(ch));\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(char ch : v[j])\\n                {\\n                    if(temp->containsKey(ch))\\n                    {\\n                        Node* t = temp->get(ch);\\n                        if(t->flag)\\n                            ans++;                        \\n                    }\\n                }\\n            }  \\n            q.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936856,
                "title": "c-simple-solution",
                "content": "*The solution is very intuitive.*\\n**1**. **Encrypt**:\\n\\tFor encryption, we need to replace every char of `word1` by its corresponding value. It is best to use a hashmap to store key, value pairs. So, while encrypting, replace every character by its corresponding value stored in the map `k2v`.\\n\\n**2**. **Decrypt**:\\n\\tSince we need to match every possible decryption with the given dictionary to see how many matches are there, it is better to reverse this approach. So, for every word in the dictionary, calculate the encrypted version and store the count of it in another hashmap `dict` . So, when decrypt function is called, we can just return the count of `dict[word2]`. Thing to note is, while calculating encryptions of words in a dictionary, not every char of a word will be in `k2v keys`. So, for those strings, no encryption is possible and hence we do need to store them (as they will never be able form a word with a possible decryption).\\n\\n```\\nclass Encrypter {\\nprivate:\\n    unordered_map<char, string> k2v;\\n    unordered_map<string, int> dict;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++){\\n            k2v[keys[i]] = values[i];\\n        }\\n        for(string d: dictionary){\\n            string enc = \"\";\\n            int flag = 0;\\n            for(char c: d){\\n                if(k2v.find(c) == k2v.end()){\\n                    flag = 1;\\n                    break;\\n                }\\n                enc += k2v[c];\\n            }\\n            if(!flag) dict[enc]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string enc = \"\";\\n        for(char c: word1){\\n            enc += k2v[c];\\n        }\\n        return enc;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dict[word2];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Encrypter {\\nprivate:\\n    unordered_map<char, string> k2v;\\n    unordered_map<string, int> dict;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++){\\n            k2v[keys[i]] = values[i];\\n        }\\n        for(string d: dictionary){\\n            string enc = \"\";\\n            int flag = 0;\\n            for(char c: d){\\n                if(k2v.find(c) == k2v.end()){\\n                    flag = 1;\\n                    break;\\n                }\\n                enc += k2v[c];\\n            }\\n            if(!flag) dict[enc]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string enc = \"\";\\n        for(char c: word1){\\n            enc += k2v[c];\\n        }\\n        return enc;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dict[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1930872,
                "title": "scala-trie-with-dfs",
                "content": "```scala\\n\\nclass Encrypter(_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n\\n  type int = Int\\n  import scala.collection.mutable.{HashMap, ArrayBuffer}\\n  val keys = new HashMap[Char, Int]\\n  _keys.zipWithIndex.foreach { case (v, i) =>\\n    keys += (v -> i)\\n  }\\n  type ab = ArrayBuffer[int]\\n  val values = new HashMap[String, ab]\\n  _values.zipWithIndex.foreach {\\n    case (x, i) => {\\n      if (!values.contains(x)) values += (x -> new ab)\\n      values(x) += i\\n    }\\n  }\\n\\n  case class Node(\\n      val c: Char,\\n      val chs: HashMap[Char, Node] = new HashMap[Char, Node],\\n      var isEnd: Boolean = false\\n  )\\n\\n  def f(_node: Node, str: String): Unit = {\\n    var node = _node\\n    str.toCharArray\\n      .foreach(c => {\\n        if (!node.chs.contains(c)) node.chs += (c -> (new Node(c)))\\n        node = node.chs(c)\\n      })\\n    node.isEnd = true\\n  }\\n\\n  val root = new Node(\\' \\')\\n  _dictionary.foreach(str => f(root, str))\\n\\n  // println(values )\\n  def encrypt(word1: String): String =\\n    word1.toCharArray\\n      .map(c => _values(keys(c)))\\n      .mkString\\n\\n  def decrypt(word2: String): Int = {\\n\\n    var count    = 0\\n    var continue = true\\n    def f(idx: int, node: Node): Unit = {\\n      if (!continue) return\\n      if (idx == word2.length()) {\\n        if (node.isEnd)\\n          count += 1\\n        return\\n      }\\n      val s = word2.charAt(idx) + \"\" + word2.charAt(idx + 1)\\n      if (!values.contains(s)) {\\n        continue = false\\n        return\\n      }\\n      values(s).foreach(id => if (node.chs.contains(_keys(id))) f(idx + 2, node.chs(_keys(id))))\\n\\n    }\\n\\n    f(0, root)\\n    count\\n\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```scala\\n\\nclass Encrypter(_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n\\n  type int = Int\\n  import scala.collection.mutable.{HashMap, ArrayBuffer}\\n  val keys = new HashMap[Char, Int]\\n  _keys.zipWithIndex.foreach { case (v, i) =>\\n    keys += (v -> i)\\n  }\\n  type ab = ArrayBuffer[int]\\n  val values = new HashMap[String, ab]\\n  _values.zipWithIndex.foreach {\\n    case (x, i) => {\\n      if (!values.contains(x)) values += (x -> new ab)\\n      values(x) += i\\n    }\\n  }\\n\\n  case class Node(\\n      val c: Char,\\n      val chs: HashMap[Char, Node] = new HashMap[Char, Node],\\n      var isEnd: Boolean = false\\n  )\\n\\n  def f(_node: Node, str: String): Unit = {\\n    var node = _node\\n    str.toCharArray\\n      .foreach(c => {\\n        if (!node.chs.contains(c)) node.chs += (c -> (new Node(c)))\\n        node = node.chs(c)\\n      })\\n    node.isEnd = true\\n  }\\n\\n  val root = new Node(\\' \\')\\n  _dictionary.foreach(str => f(root, str))\\n\\n  // println(values )\\n  def encrypt(word1: String): String =\\n    word1.toCharArray\\n      .map(c => _values(keys(c)))\\n      .mkString\\n\\n  def decrypt(word2: String): Int = {\\n\\n    var count    = 0\\n    var continue = true\\n    def f(idx: int, node: Node): Unit = {\\n      if (!continue) return\\n      if (idx == word2.length()) {\\n        if (node.isEnd)\\n          count += 1\\n        return\\n      }\\n      val s = word2.charAt(idx) + \"\" + word2.charAt(idx + 1)\\n      if (!values.contains(s)) {\\n        continue = false\\n        return\\n      }\\n      values(s).foreach(id => if (node.chs.contains(_keys(id))) f(idx + 2, node.chs(_keys(id))))\\n\\n    }\\n\\n    f(0, root)\\n    count\\n\\n  }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929920,
                "title": "java-trie-in-40-lines",
                "content": "```\\nprivate static class Node {\\n\\tprivate final String encryptedChar;\\n\\tprivate final Map<String, Node> nexts = new HashMap<>();\\n\\tprivate int wordCount = 0;\\n\\tprivate Node(String encryptedChar) {\\n\\t\\tthis.encryptedChar = encryptedChar;\\n\\t}\\n}\\nprivate final Map<Character, String> forwardMap = new HashMap<>();\\nprivate final Node start = new Node(null);\\npublic Encrypter(char[] keys, String[] values, String[] dictionary) {\\n\\tfor(int i = 0; i < keys.length; i++) {\\n\\t\\tforwardMap.put(keys[i], values[i]);\\n\\t}\\n\\tfor(String word : dictionary) {\\n\\t\\tNode node = start;\\n\\t\\tfor(int i = 0; i<word.length(); i++) {\\n\\t\\t\\tString encryptedChar = forwardMap.get(word.charAt(i));\\n\\t\\t\\tNode nextNode = node.nexts.computeIfAbsent(encryptedChar, key -> new Node(encryptedChar));\\n\\t\\t\\tif(i == word.length() - 1) nextNode.wordCount++;\\n\\t\\t\\tnode = nextNode;\\n\\t\\t}\\n\\t}\\n}\\npublic String encrypt(String word1) {\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(char c : word1.toCharArray()) result.append(forwardMap.get(c));\\n\\treturn result.toString();\\n}\\npublic int decrypt(String word2) {\\n\\tNode node = start;\\n\\tfor(int i = 0; i<word2.length() / 2; i++) {\\n\\t\\tString encryptedChar = word2.substring(i * 2, i * 2 + 2);\\n\\t\\tnode = node.nexts.get(encryptedChar);\\n\\t\\tif(node == null) return 0;\\n\\t}\\n\\treturn node.wordCount;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nprivate static class Node {\\n\\tprivate final String encryptedChar;\\n\\tprivate final Map<String, Node> nexts = new HashMap<>();\\n\\tprivate int wordCount = 0;\\n\\tprivate Node(String encryptedChar) {\\n\\t\\tthis.encryptedChar = encryptedChar;\\n\\t}\\n}\\nprivate final Map<Character, String> forwardMap = new HashMap<>();\\nprivate final Node start = new Node(null);\\npublic Encrypter(char[] keys, String[] values, String[] dictionary) {\\n\\tfor(int i = 0; i < keys.length; i++) {\\n\\t\\tforwardMap.put(keys[i], values[i]);\\n\\t}\\n\\tfor(String word : dictionary) {\\n\\t\\tNode node = start;\\n\\t\\tfor(int i = 0; i<word.length(); i++) {\\n\\t\\t\\tString encryptedChar = forwardMap.get(word.charAt(i));\\n\\t\\t\\tNode nextNode = node.nexts.computeIfAbsent(encryptedChar, key -> new Node(encryptedChar));\\n\\t\\t\\tif(i == word.length() - 1) nextNode.wordCount++;\\n\\t\\t\\tnode = nextNode;\\n\\t\\t}\\n\\t}\\n}\\npublic String encrypt(String word1) {\\n\\tStringBuffer result = new StringBuffer();\\n\\tfor(char c : word1.toCharArray()) result.append(forwardMap.get(c));\\n\\treturn result.toString();\\n}\\npublic int decrypt(String word2) {\\n\\tNode node = start;\\n\\tfor(int i = 0; i<word2.length() / 2; i++) {\\n\\t\\tString encryptedChar = word2.substring(i * 2, i * 2 + 2);\\n\\t\\tnode = node.nexts.get(encryptedChar);\\n\\t\\tif(node == null) return 0;\\n\\t}\\n\\treturn node.wordCount;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929334,
                "title": "java-sol-2-maps-and-precompute",
                "content": "Approach,\\n1. Make 2 maps\\n2. One for storing <keys[i],values[i]> pairs.\\n3. Second for storing decrypted string frequencies from dictionary array\\n4. While precomputing dictionary array, make sure not to store invalid decrypted strings\\n5. Below is the implementation for the same.\\n```\\nclass Encrypter {\\n    Map<Character,String> en;\\n    Map<String,Integer> deq;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        en = new HashMap<>();\\n        deq = new HashMap<>();\\n        int n = keys.length;\\n        //Encrypt Map\\n        for (int i = 0; i < n; i++) {\\n            en.put(keys[i],values[i]);\\n        }\\n        \\n        // Decrypted Strings from dictionary array\\n        for (String s : dictionary) {\\n            StringBuilder ans = new StringBuilder();\\n            boolean flag = true;\\n            for (char ch : s.toCharArray()) {\\n                if (en.get(ch) == null) {\\n                    flag = false;\\n                    break;\\n                }\\n                ans.append(en.get(ch));\\n            }\\n            String key = ans.toString();\\n            if (key.equals(\"\") || !flag) continue;\\n            deq.put(key,deq.getOrDefault(key,0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder ans = new StringBuilder();\\n        for (char ch : word1.toCharArray()) {\\n            ans.append(en.getOrDefault(ch,\"\"));\\n        }\\n        return ans.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return deq.getOrDefault(word2,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    Map<Character,String> en;\\n    Map<String,Integer> deq;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        en = new HashMap<>();\\n        deq = new HashMap<>();\\n        int n = keys.length;\\n        //Encrypt Map\\n        for (int i = 0; i < n; i++) {\\n            en.put(keys[i],values[i]);\\n        }\\n        \\n        // Decrypted Strings from dictionary array\\n        for (String s : dictionary) {\\n            StringBuilder ans = new StringBuilder();\\n            boolean flag = true;\\n            for (char ch : s.toCharArray()) {\\n                if (en.get(ch) == null) {\\n                    flag = false;\\n                    break;\\n                }\\n                ans.append(en.get(ch));\\n            }\\n            String key = ans.toString();\\n            if (key.equals(\"\") || !flag) continue;\\n            deq.put(key,deq.getOrDefault(key,0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder ans = new StringBuilder();\\n        for (char ch : word1.toCharArray()) {\\n            ans.append(en.getOrDefault(ch,\"\"));\\n        }\\n        return ans.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return deq.getOrDefault(word2,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928783,
                "title": "c-code-two-hashmap-s-only",
                "content": "```\\nclass Encrypter {\\npublic:\\n    \\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& d) {\\n        m1.clear();\\n        m2.clear();\\n        \\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]] = values[i];\\n        }\\n        \\n        for(int i=0;i<d.size();i++){\\n            string str = encrypt(d[i]);\\n            \\n            if(str != \"\"){\\n                 m2[str]++;\\n            }\\n           \\n            \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string str = \"\";\\n        \\n        for(int i=0;i<word1.size();i++){\\n            if(m1.find(word1[i])==m1.end()) return \"\";\\n            str += m1[word1[i]];\\n        }\\n       \\n        return str;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    \\n    unordered_map<char,string> m1;\\n    unordered_map<string,int> m2;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& d) {\\n        m1.clear();\\n        m2.clear();\\n        \\n        for(int i=0;i<keys.size();i++){\\n            m1[keys[i]] = values[i];\\n        }\\n        \\n        for(int i=0;i<d.size();i++){\\n            string str = encrypt(d[i]);\\n            \\n            if(str != \"\"){\\n                 m2[str]++;\\n            }\\n           \\n            \\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string str = \"\";\\n        \\n        for(int i=0;i<word1.size();i++){\\n            if(m1.find(word1[i])==m1.end()) return \"\";\\n            str += m1[word1[i]];\\n        }\\n       \\n        return str;\\n        \\n    }\\n    \\n    int decrypt(string word2) {\\n        return m2[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926771,
                "title": "java-hashmap",
                "content": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Encrypter {\\n\\n    private String[] dictionary;\\n    private Map<Character, String> charVsStringMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.dictionary = dictionary;\\n        for (int i = 0; i < keys.length; i++) {\\n            charVsStringMap.putIfAbsent(keys[i], values[i]);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            stringBuilder.append(charVsStringMap.get(c));\\n        }\\n        return stringBuilder.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        int ans = 0;\\n        for (String str : dictionary) {\\n            String newStr = \"\";\\n\\n            for (char ch : str.toCharArray()) {\\n\\n                if (charVsStringMap.containsKey(ch)) {\\n                    newStr += charVsStringMap.get(ch);\\n\\n                } else {\\n                    newStr = \"\";\\n                    break;\\n                }\\n            }\\n            if (newStr.equals(word2)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\nclass Encrypter {\\n\\n    private String[] dictionary;\\n    private Map<Character, String> charVsStringMap = new HashMap<>();\\n\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        this.dictionary = dictionary;\\n        for (int i = 0; i < keys.length; i++) {\\n            charVsStringMap.putIfAbsent(keys[i], values[i]);\\n        }\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (char c : word1.toCharArray()) {\\n            stringBuilder.append(charVsStringMap.get(c));\\n        }\\n        return stringBuilder.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        int ans = 0;\\n        for (String str : dictionary) {\\n            String newStr = \"\";\\n\\n            for (char ch : str.toCharArray()) {\\n\\n                if (charVsStringMap.containsKey(ch)) {\\n                    newStr += charVsStringMap.get(ch);\\n\\n                } else {\\n                    newStr = \"\";\\n                    break;\\n                }\\n            }\\n            if (newStr.equals(word2)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926295,
                "title": "golang-trie",
                "content": "```\\ntype Encrypter struct {\\n    k2v map[byte]string\\n    v2k map[string][]byte\\n    trie *node\\n}\\n\\ntype node struct {\\n    next []*node\\n    end bool\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    k2v := make(map[byte]string)\\n    v2k := make(map[string][]byte)\\n    \\n    for i, k := range keys {\\n        k2v[k] = values[i]\\n    }\\n    \\n    for i, v := range values {\\n        v2k[v] = append(v2k[v], keys[i])\\n    }\\n    \\n    trie := &node{\\n        next: make([]*node, 26),\\n        end: false,\\n    }\\n    \\n    for _, w := range dictionary {\\n        cur := trie\\n        for _, r := range w {\\n            if cur.next[r - \\'a\\'] == nil {\\n                cur.next[r - \\'a\\'] = &node{\\n                    next: make([]*node, 26),\\n                    end: false,\\n                }\\n            }\\n            cur = cur.next[r - \\'a\\']\\n        }\\n        cur.end = true\\n    }\\n    \\n    return Encrypter{\\n        k2v: k2v,\\n        v2k: v2k,\\n        trie: trie,\\n    }    \\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    var res bytes.Buffer\\n    for i := 0; i < len(word1); i++ {\\n        res.WriteString(this.k2v[word1[i]])\\n    }\\n    return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.dfs(word2)\\n}\\n\\nfunc (this *Encrypter) dfs(word2 string) int {\\n    if len(word2) == 0 {\\n        if this.trie.end {\\n            return 1\\n        } else {\\n            return 0\\n        }\\n    }\\n    \\n    res := 0\\n    for _, b := range this.v2k[word2[:2]] {\\n        if this.trie.next[b - \\'a\\'] != nil {\\n            tmp := this.trie\\n            this.trie = this.trie.next[b - \\'a\\']\\n            res += this.dfs(word2[2:])\\n            this.trie = tmp\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype Encrypter struct {\\n    k2v map[byte]string\\n    v2k map[string][]byte\\n    trie *node\\n}\\n\\ntype node struct {\\n    next []*node\\n    end bool\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n    k2v := make(map[byte]string)\\n    v2k := make(map[string][]byte)\\n    \\n    for i, k := range keys {\\n        k2v[k] = values[i]\\n    }\\n    \\n    for i, v := range values {\\n        v2k[v] = append(v2k[v], keys[i])\\n    }\\n    \\n    trie := &node{\\n        next: make([]*node, 26),\\n        end: false,\\n    }\\n    \\n    for _, w := range dictionary {\\n        cur := trie\\n        for _, r := range w {\\n            if cur.next[r - \\'a\\'] == nil {\\n                cur.next[r - \\'a\\'] = &node{\\n                    next: make([]*node, 26),\\n                    end: false,\\n                }\\n            }\\n            cur = cur.next[r - \\'a\\']\\n        }\\n        cur.end = true\\n    }\\n    \\n    return Encrypter{\\n        k2v: k2v,\\n        v2k: v2k,\\n        trie: trie,\\n    }    \\n}\\n\\n\\nfunc (this *Encrypter) Encrypt(word1 string) string {\\n    var res bytes.Buffer\\n    for i := 0; i < len(word1); i++ {\\n        res.WriteString(this.k2v[word1[i]])\\n    }\\n    return res.String()\\n}\\n\\n\\nfunc (this *Encrypter) Decrypt(word2 string) int {\\n    return this.dfs(word2)\\n}\\n\\nfunc (this *Encrypter) dfs(word2 string) int {\\n    if len(word2) == 0 {\\n        if this.trie.end {\\n            return 1\\n        } else {\\n            return 0\\n        }\\n    }\\n    \\n    res := 0\\n    for _, b := range this.v2k[word2[:2]] {\\n        if this.trie.next[b - \\'a\\'] != nil {\\n            tmp := this.trie\\n            this.trie = this.trie.next[b - \\'a\\']\\n            res += this.dfs(word2[2:])\\n            this.trie = tmp\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925491,
                "title": "java-trie-dfs-hashmaps",
                "content": "Runtime: 970 ms, faster than 27.23% of Java online submissions for Encrypt and Decrypt Strings.\\nMemory Usage: 509.4 MB, less than 5.06% of Java online submissions for Encrypt and Decrypt Strings.\\n```\\nclass Encrypter {\\n  class Node{                                            //class for each node in Trie\\n    public Node[] p;                                     //array all neigbours    \\n    public boolean eow;                                  //mark for end of word\\n    \\n    Node (){\\n      p = new Node[26];                                  //whan we construct node\\n      for(int i = 0; i != 26; i++) p[i] = null;          //we inicialize all neigbours as \"null\"  \\n      eow = false;                                       //and check our mark for end of word as false\\n    }\\n  }\\n  public Node root;                                      //root of Trie\\n    \\n  public void insert(String w) { \\n    Node n = root;                                       //node for traversal through Trie\\n    for(int i = 0; i < w.length(); i++){                 \\n      int id = (int)(w.charAt(i) - \\'a\\');                 //fetch current letter from word and calculate index for it\\n      \\n      if(n.p[id] != null) n = n.p[id];                   //if this letter is presented in table move to next\\n      else                                               //if not \\n        for(; i != w.length(); i++){                     //create new nodes\\n          id = (int)(w.charAt(i) - \\'a\\');\\n          n.p[id] = new Node();\\n          n = n.p[id];\\n        }\\n    }\\n    n.eow = true;                                        //check last node as end of word\\n  }\\n      \\n  Map<Character, String> en;                             //for encoding strings\\n  Map<String, List<Integer>> de;                         //{string, list of indexes of letters with this string} \\n  Map<String, Integer> answeres;                         //for coinciding enquiries\\n  int ans;                                               //for counting all possibilities for each enquiry \\n  \\n  public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n    en = new HashMap<>();\\n    de = new HashMap<>();\\n    answeres = new HashMap<>();\\n    root = new Node();                                   //construct new Trie\\n    root.eow = true;                                     //and put string \"\"\\n  \\n    \\n    for(int i = 0; i != keys.length; i++){               //fill our hashmaps\\n      en.put(keys[i], values[i]);\\n      if(!de.containsKey(values[i])){\\n        List<Integer> list = new ArrayList<>();\\n        de.put(values[i], list);\\n      }\\n      de.get(values[i]).add(keys[i] - \\'a\\');\\n    }\\n    \\n    for(int i = 0; i != dictionary.length; i++)          //and construct Trie\\n      insert(dictionary[i]);\\n  }\\n    \\n  public String encrypt(String word1) {                  //construct answer\\n    String ans = \"\";\\n    for(int i = 0; i != word1.length(); i++)\\n      ans += en.get(word1.charAt(i));\\n    \\n    return ans;\\n  }\\n    \\n  public int decrypt(String word2) {\\n    if(answeres.containsKey(word2)) return answeres.get(word2);   //if we already have this inquiry\\n    \\n    ans = 0;                                                      //refrash counter of all possibilities\\n    dfs(0, root, word2);                                          //dfs\\n    answeres.put(word2, ans);                                     //put this answer for next inquiries\\n    \\n    return ans;   \\n  }\\n  \\n  public void dfs(int i, Node node, String w){                    //dfs\\n    String key = w.substring(i, i + 2);                           //fetch current substring\\n    if(de.containsKey(key))                                       //if we have keys for this substring\\n      for(int j = 0; j != de.get(key).size(); j++)                //try to move through Trie\\n        if( node.p[de.get(key).get(j)] != null) {                 //if we dont have node in Trie\\n          if(i + 2 == w.length()){                             //if we reach end of current word\\n            if(node.p[de.get(key).get(j)].eow == true) ans++;     //check : have we this word in Trie?\\n          }\\n          else dfs(i+2, node.p[de.get(key).get(j)], w);        //if we dont reach\\n    }\\n  }\\n  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n  class Node{                                            //class for each node in Trie\\n    public Node[] p;                                     //array all neigbours    \\n    public boolean eow;                                  //mark for end of word\\n    \\n    Node (){\\n      p = new Node[26];                                  //whan we construct node\\n      for(int i = 0; i != 26; i++) p[i] = null;          //we inicialize all neigbours as \"null\"  \\n      eow = false;                                       //and check our mark for end of word as false\\n    }\\n  }\\n  public Node root;                                      //root of Trie\\n    \\n  public void insert(String w) { \\n    Node n = root;                                       //node for traversal through Trie\\n    for(int i = 0; i < w.length(); i++){                 \\n      int id = (int)(w.charAt(i) - \\'a\\');                 //fetch current letter from word and calculate index for it\\n      \\n      if(n.p[id] != null) n = n.p[id];                   //if this letter is presented in table move to next\\n      else                                               //if not \\n        for(; i != w.length(); i++){                     //create new nodes\\n          id = (int)(w.charAt(i) - \\'a\\');\\n          n.p[id] = new Node();\\n          n = n.p[id];\\n        }\\n    }\\n    n.eow = true;                                        //check last node as end of word\\n  }\\n      \\n  Map<Character, String> en;                             //for encoding strings\\n  Map<String, List<Integer>> de;                         //{string, list of indexes of letters with this string} \\n  Map<String, Integer> answeres;                         //for coinciding enquiries\\n  int ans;                                               //for counting all possibilities for each enquiry \\n  \\n  public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n    en = new HashMap<>();\\n    de = new HashMap<>();\\n    answeres = new HashMap<>();\\n    root = new Node();                                   //construct new Trie\\n    root.eow = true;                                     //and put string \"\"\\n  \\n    \\n    for(int i = 0; i != keys.length; i++){               //fill our hashmaps\\n      en.put(keys[i], values[i]);\\n      if(!de.containsKey(values[i])){\\n        List<Integer> list = new ArrayList<>();\\n        de.put(values[i], list);\\n      }\\n      de.get(values[i]).add(keys[i] - \\'a\\');\\n    }\\n    \\n    for(int i = 0; i != dictionary.length; i++)          //and construct Trie\\n      insert(dictionary[i]);\\n  }\\n    \\n  public String encrypt(String word1) {                  //construct answer\\n    String ans = \"\";\\n    for(int i = 0; i != word1.length(); i++)\\n      ans += en.get(word1.charAt(i));\\n    \\n    return ans;\\n  }\\n    \\n  public int decrypt(String word2) {\\n    if(answeres.containsKey(word2)) return answeres.get(word2);   //if we already have this inquiry\\n    \\n    ans = 0;                                                      //refrash counter of all possibilities\\n    dfs(0, root, word2);                                          //dfs\\n    answeres.put(word2, ans);                                     //put this answer for next inquiries\\n    \\n    return ans;   \\n  }\\n  \\n  public void dfs(int i, Node node, String w){                    //dfs\\n    String key = w.substring(i, i + 2);                           //fetch current substring\\n    if(de.containsKey(key))                                       //if we have keys for this substring\\n      for(int j = 0; j != de.get(key).size(); j++)                //try to move through Trie\\n        if( node.p[de.get(key).get(j)] != null) {                 //if we dont have node in Trie\\n          if(i + 2 == w.length()){                             //if we reach end of current word\\n            if(node.p[de.get(key).get(j)].eow == true) ans++;     //check : have we this word in Trie?\\n          }\\n          else dfs(i+2, node.p[de.get(key).get(j)], w);        //if we dont reach\\n    }\\n  }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924906,
                "title": "python-solution-with-explanation",
                "content": "I refrain from using \"+\" operator to concatenate strings in the encrypt method because that would give us the O(word1)**2 squared complexity since strings are immutable and we are basically copying everything to a new string every time. So it would be more efficient and apt to use \"join\" statement as it would cost us just O(word1) time.\\n\\nPlease let me know in the comments if something is not clear.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.mapping = defaultdict(str)\\n        \\n\\t\\t#mapping each key to its respective value\\n        for x, y in zip(keys, values): \\n            self.mapping[x] = y            \\n            \\n        self.frequency = defaultdict(int)\\n        \\n\\t\\t#encrpting every worder by function calling and updating \\n\\t\\t#how many times the encrypted sequene occurs\\n        for word in dictionary:\\n            self.frequency[self.encrypt(word)] += 1  \\n        \\n  \\n    def encrypt(self, word1: str) -> str:\\n\\t    #Using list. So that it would be efficient to concatenate it at the end using join.\\n        res = [] \\n        \\n        for c in word1:\\n            if c in self.mapping:\\n                res.append(self.mapping[c])\\n            else:\\n                return \\'\\' \\n\\t\\t\\t\\t# #it\\'s important that even if one charecter is missing, we should\\n\\t\\t\\t\\t#return an empty string or else it would give wrong output\\n\\t\\t\\t\\t\\n        return \"\".join(res)  \\n        \\n\\t\\t\\n    def decrypt(self, word2: str) -> int:\\n\\t\\n\\t    #return the frequency of the encrypted sequence\\n        return self.frequency[word2]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "I refrain from using \"+\" operator to concatenate strings in the encrypt method because that would give us the O(word1)**2 squared complexity since strings are immutable and we are basically copying everything to a new string every time. So it would be more efficient and apt to use \"join\" statement as it would cost us just O(word1) time.\\n\\nPlease let me know in the comments if something is not clear.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        \\n        self.mapping = defaultdict(str)\\n        \\n\\t\\t#mapping each key to its respective value\\n        for x, y in zip(keys, values): \\n            self.mapping[x] = y            \\n            \\n        self.frequency = defaultdict(int)\\n        \\n\\t\\t#encrpting every worder by function calling and updating \\n\\t\\t#how many times the encrypted sequene occurs\\n        for word in dictionary:\\n            self.frequency[self.encrypt(word)] += 1  \\n        \\n  \\n    def encrypt(self, word1: str) -> str:\\n\\t    #Using list. So that it would be efficient to concatenate it at the end using join.\\n        res = [] \\n        \\n        for c in word1:\\n            if c in self.mapping:\\n                res.append(self.mapping[c])\\n            else:\\n                return \\'\\' \\n\\t\\t\\t\\t# #it\\'s important that even if one charecter is missing, we should\\n\\t\\t\\t\\t#return an empty string or else it would give wrong output\\n\\t\\t\\t\\t\\n        return \"\".join(res)  \\n        \\n\\t\\t\\n    def decrypt(self, word2: str) -> int:\\n\\t\\n\\t    #return the frequency of the encrypted sequence\\n        return self.frequency[word2]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1920939,
                "title": "swift-hash-map-solution",
                "content": "```\\n\\nclass Encrypter {\\n\\n    var dict = [Character: String]()\\n    var map = [String: [String]]()\\n\\n    init(_ keys: [Character], _ values: [String], _ dictionary: [String]) {\\n        let count = keys.count\\n\\n        for i in 0..<count {\\n            dict[keys[i]] = values[i]\\n        }\\n        \\n        for i in dictionary {\\n          map[encrypt(i), default: []].append(i)   \\n        }\\n    }\\n    \\n    func encrypt(_ word1: String) -> String {\\n        var res = \"\"\\n    \\n        for i in word1 {\\n            if let val = dict[i] {\\n                res += val\\n            } else { return \"\" }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func decrypt(_ word2: String) -> Int {\\n        return map[word2, default: []].count     \\n    }\\n}",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\n\\nclass Encrypter {\\n\\n    var dict = [Character: String]()\\n    var map = [String: [String]]()\\n\\n    init(_ keys: [Character], _ values: [String], _ dictionary: [String]) {\\n        let count = keys.count\\n\\n        for i in 0..<count {\\n            dict[keys[i]] = values[i]\\n        }\\n        \\n        for i in dictionary {\\n          map[encrypt(i), default: []].append(i)   \\n        }\\n    }\\n    \\n    func encrypt(_ word1: String) -> String {\\n        var res = \"\"\\n    \\n        for i in word1 {\\n            if let val = dict[i] {\\n                res += val\\n            } else { return \"\" }\\n        }\\n        \\n        return res\\n    }\\n    \\n    func decrypt(_ word2: String) -> Int {\\n        return map[word2, default: []].count     \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1920424,
                "title": "cpp-simple-and-clean-code",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> hsh;\\n    unordered_map<string, int> box;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            hsh[keys[i]] = values[i];\\n        }\\n        for(string&s: dictionary){\\n            box[encrypt(s)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char c: word1){\\n            if(hsh.find(c) != hsh.end()) ans += hsh[c];\\n            else ans.push_back(\\'.\\');\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return box[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, string> hsh;\\n    unordered_map<string, int> box;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0;i<keys.size();i++){\\n            hsh[keys[i]] = values[i];\\n        }\\n        for(string&s: dictionary){\\n            box[encrypt(s)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char c: word1){\\n            if(hsh.find(c) != hsh.end()) ans += hsh[c];\\n            else ans.push_back(\\'.\\');\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    int decrypt(string word2) {\\n        return box[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1920343,
                "title": "golang-hash-solution",
                "content": "```go\\n// AC\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tencryptMap    map[string]string\\n\\tresultCounter map[string]int\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tencryptMap := make(map[string]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t}\\n\\tresultCounter := make(map[string]int)\\n\\tfor _, v := range dictionary {\\n\\t\\tencrypted := encryptHelper(v, encryptMap)\\n\\t\\tif len(encrypted) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tresultCounter[encrypted]++\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tencryptMap:    encryptMap,\\n\\t\\tresultCounter: resultCounter,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\treturn encryptHelper(word1, e.encryptMap)\\n}\\n\\nfunc encryptHelper(word string, encryptMap map[string]string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word {\\n\\t\\tif len(encryptMap[string(v)]) == 0 {\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tsb.WriteString(encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\treturn e.resultCounter[word2]\\n}\\n```\\n\\n```go\\n// TLE :(\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tdictionary map[int]map[string]bool\\n\\tencryptMap map[string]string\\n\\tdecryptMap map[string][]string\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tdictionaryHelper := make(map[int]map[string]bool)\\n\\tfor _, v := range dictionary {\\n\\t\\tif dictionaryHelper[len(v)] == nil {\\n\\t\\t\\tdictionaryHelper[len(v)] = make(map[string]bool)\\n\\t\\t}\\n\\t\\tfor i := 1; i <= len(v); i++ {\\n\\t\\t\\tdictionaryHelper[len(v)][v[:i]] = true\\n\\t\\t}\\n\\t}\\n\\tencryptMap := make(map[string]string)\\n\\tdecryptMap := make(map[string][]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t\\tdecryptMap[values[i]] = append(decryptMap[values[i]], string(v))\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tdictionary: dictionaryHelper,\\n\\t\\tencryptMap: encryptMap,\\n\\t\\tdecryptMap: decryptMap,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word1 {\\n\\t\\tsb.WriteString(e.encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\tdictionary := e.dictionary[len(word2)/2]\\n\\tcurrent := make([]string, 0, len(e.decryptMap[word2[:2]]))\\n\\tfor _, v := range e.decryptMap[word2[:2]] {\\n\\t\\tif dictionary[v] == true {\\n\\t\\t\\tcurrent = append(current, v)\\n\\t\\t}\\n\\t}\\n\\tfor i := 2; i < len(word2) && len(current) > 0; i += 2 {\\n\\t\\talphas := e.decryptMap[word2[i:i+2]]\\n\\t\\tnext := make([]string, 0, len(current))\\n\\t\\tfor _, alpha := range alphas {\\n\\t\\t\\tfor _, pre := range current {\\n\\t\\t\\t\\tnewWord := pre + alpha\\n\\t\\t\\t\\tif dictionary[newWord] == true {\\n\\t\\t\\t\\t\\tnext = append(next, newWord)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn len(current)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\n// AC\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tencryptMap    map[string]string\\n\\tresultCounter map[string]int\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tencryptMap := make(map[string]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t}\\n\\tresultCounter := make(map[string]int)\\n\\tfor _, v := range dictionary {\\n\\t\\tencrypted := encryptHelper(v, encryptMap)\\n\\t\\tif len(encrypted) == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tresultCounter[encrypted]++\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tencryptMap:    encryptMap,\\n\\t\\tresultCounter: resultCounter,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\treturn encryptHelper(word1, e.encryptMap)\\n}\\n\\nfunc encryptHelper(word string, encryptMap map[string]string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word {\\n\\t\\tif len(encryptMap[string(v)]) == 0 {\\n\\t\\t\\treturn \"\"\\n\\t\\t}\\n\\t\\tsb.WriteString(encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\treturn e.resultCounter[word2]\\n}\\n```\n```go\\n// TLE :(\\nimport \"strings\"\\n\\ntype Encrypter struct {\\n\\tdictionary map[int]map[string]bool\\n\\tencryptMap map[string]string\\n\\tdecryptMap map[string][]string\\n}\\n\\nfunc Constructor(keys []byte, values []string, dictionary []string) Encrypter {\\n\\tdictionaryHelper := make(map[int]map[string]bool)\\n\\tfor _, v := range dictionary {\\n\\t\\tif dictionaryHelper[len(v)] == nil {\\n\\t\\t\\tdictionaryHelper[len(v)] = make(map[string]bool)\\n\\t\\t}\\n\\t\\tfor i := 1; i <= len(v); i++ {\\n\\t\\t\\tdictionaryHelper[len(v)][v[:i]] = true\\n\\t\\t}\\n\\t}\\n\\tencryptMap := make(map[string]string)\\n\\tdecryptMap := make(map[string][]string)\\n\\tfor i, v := range keys {\\n\\t\\tencryptMap[string(v)] = values[i]\\n\\t\\tdecryptMap[values[i]] = append(decryptMap[values[i]], string(v))\\n\\t}\\n\\treturn Encrypter{\\n\\t\\tdictionary: dictionaryHelper,\\n\\t\\tencryptMap: encryptMap,\\n\\t\\tdecryptMap: decryptMap,\\n\\t}\\n}\\n\\nfunc (e *Encrypter) Encrypt(word1 string) string {\\n\\tsb := strings.Builder{}\\n\\tfor _, v := range word1 {\\n\\t\\tsb.WriteString(e.encryptMap[string(v)])\\n\\t}\\n\\treturn sb.String()\\n}\\n\\nfunc (e *Encrypter) Decrypt(word2 string) int {\\n\\tdictionary := e.dictionary[len(word2)/2]\\n\\tcurrent := make([]string, 0, len(e.decryptMap[word2[:2]]))\\n\\tfor _, v := range e.decryptMap[word2[:2]] {\\n\\t\\tif dictionary[v] == true {\\n\\t\\t\\tcurrent = append(current, v)\\n\\t\\t}\\n\\t}\\n\\tfor i := 2; i < len(word2) && len(current) > 0; i += 2 {\\n\\t\\talphas := e.decryptMap[word2[i:i+2]]\\n\\t\\tnext := make([]string, 0, len(current))\\n\\t\\tfor _, alpha := range alphas {\\n\\t\\t\\tfor _, pre := range current {\\n\\t\\t\\t\\tnewWord := pre + alpha\\n\\t\\t\\t\\tif dictionary[newWord] == true {\\n\\t\\t\\t\\t\\tnext = append(next, newWord)\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tcurrent = next\\n\\t}\\n\\treturn len(current)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1915872,
                "title": "using-zip-and-dict-in-python",
                "content": "class Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            print(l)\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "solutionTags": [],
                "code": "class Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            print(l)\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "codeTag": "Java"
            },
            {
                "id": 1915670,
                "title": "rust-hashmap-hashset-search-from-dic-word-o-n",
                "content": "```\\nuse std::collections::{HashMap, HashSet};\\nstruct Encrypter {\\n    ci: HashMap<char, usize>,\\n    vi: HashMap<String, HashSet<usize>>,\\n    values: Vec<String>,\\n    dic: Vec<String>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Encrypter {\\n\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut ci = HashMap::new();\\n        let mut vi = HashMap::new();\\n        for (i, &c) in keys.iter().enumerate() {\\n            ci.insert(c, i);\\n        }\\n        for (i, v) in values.iter().enumerate() {\\n            let list = vi.entry(v.to_string()).or_insert(HashSet::new());\\n            list.insert(i);\\n        }\\n        \\n        // println!(\"ci {:?}\\\\n vi {:#?}\\\\n\", ci, vi);\\n        \\n        Encrypter {\\n            ci,\\n            vi,\\n            values,\\n            dic: dictionary,\\n        }\\n        \\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ans = \"\".to_owned();\\n        for c in word1.chars() {\\n            let i = self.ci[&c];\\n            let v = &self.values[i][..];\\n            ans.push_str(v);\\n        }\\n        ans\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        let mut cnt = 0;\\n        let mut conn:Vec<&HashSet<usize>> = vec![];\\n        let n = word2.len()/2;\\n        for i in 0..n {\\n            let sub = &word2[i*2..i*2+2];\\n            // println!(\"sub {}\", sub);\\n            if !self.vi.contains_key(sub) {\\n                return 0;\\n            }\\n            let ids = &self.vi[sub];\\n            conn.push(ids);\\n        }\\n        // println!(\"conn {:?}\", conn);\\n        \\'dic_loop: for word in self.dic.iter() {\\n            if word.len() != n {\\n                continue\\n            }\\n            for (i, c) in word.chars().enumerate() {\\n                if !self.ci.contains_key(&c) {\\n                    continue \\'dic_loop;\\n                }\\n                let ids = &conn[i];\\n                let id = self.ci[&c];\\n                if !ids.contains(&id) {\\n                    continue \\'dic_loop;\\n                }\\n            }\\n            cnt += 1;\\n        }\\n        \\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::{HashMap, HashSet};\\nstruct Encrypter {\\n    ci: HashMap<char, usize>,\\n    vi: HashMap<String, HashSet<usize>>,\\n    values: Vec<String>,\\n    dic: Vec<String>,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl Encrypter {\\n\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut ci = HashMap::new();\\n        let mut vi = HashMap::new();\\n        for (i, &c) in keys.iter().enumerate() {\\n            ci.insert(c, i);\\n        }\\n        for (i, v) in values.iter().enumerate() {\\n            let list = vi.entry(v.to_string()).or_insert(HashSet::new());\\n            list.insert(i);\\n        }\\n        \\n        // println!(\"ci {:?}\\\\n vi {:#?}\\\\n\", ci, vi);\\n        \\n        Encrypter {\\n            ci,\\n            vi,\\n            values,\\n            dic: dictionary,\\n        }\\n        \\n    }\\n    \\n    fn encrypt(&self, word1: String) -> String {\\n        let mut ans = \"\".to_owned();\\n        for c in word1.chars() {\\n            let i = self.ci[&c];\\n            let v = &self.values[i][..];\\n            ans.push_str(v);\\n        }\\n        ans\\n    }\\n    \\n    fn decrypt(&self, word2: String) -> i32 {\\n        let mut cnt = 0;\\n        let mut conn:Vec<&HashSet<usize>> = vec![];\\n        let n = word2.len()/2;\\n        for i in 0..n {\\n            let sub = &word2[i*2..i*2+2];\\n            // println!(\"sub {}\", sub);\\n            if !self.vi.contains_key(sub) {\\n                return 0;\\n            }\\n            let ids = &self.vi[sub];\\n            conn.push(ids);\\n        }\\n        // println!(\"conn {:?}\", conn);\\n        \\'dic_loop: for word in self.dic.iter() {\\n            if word.len() != n {\\n                continue\\n            }\\n            for (i, c) in word.chars().enumerate() {\\n                if !self.ci.contains_key(&c) {\\n                    continue \\'dic_loop;\\n                }\\n                let ids = &conn[i];\\n                let id = self.ci[&c];\\n                if !ids.contains(&id) {\\n                    continue \\'dic_loop;\\n                }\\n            }\\n            cnt += 1;\\n        }\\n        \\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914609,
                "title": "c-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    map<char,string>em;\\n    map<string,set<char>>dm;\\n    set<string>words;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic)     {\\n       for(int i=0;i<keys.size();i++)\\n       {\\n           em[keys[i]]=values[i];\\n           dm[values[i]].insert(keys[i]);\\n       }\\n        for(auto it:dic) words.insert(it);\\n    }\\n    \\n    string encrypt(string w1) {\\n       string s;\\n        for(auto it:w1) s+=em[it];\\n        return s;\\n    }\\n    \\n    int decrypt(string w2) {\\n        int tc=0;\\n        for(auto it:words)\\n        {\\n            if(encrypt(it)==w2) tc++;\\n        }\\n        return tc;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    map<char,string>em;\\n    map<string,set<char>>dm;\\n    set<string>words;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dic)     {\\n       for(int i=0;i<keys.size();i++)\\n       {\\n           em[keys[i]]=values[i];\\n           dm[values[i]].insert(keys[i]);\\n       }\\n        for(auto it:dic) words.insert(it);\\n    }\\n    \\n    string encrypt(string w1) {\\n       string s;\\n        for(auto it:w1) s+=em[it];\\n        return s;\\n    }\\n    \\n    int decrypt(string w2) {\\n        int tc=0;\\n        for(auto it:words)\\n        {\\n            if(encrypt(it)==w2) tc++;\\n        }\\n        return tc;\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913855,
                "title": "using-hashmap-java",
                "content": "\\n     class Encrypter {\\n        Map<Character,String> m=new HashMap<>();\\n    String dictionary1[];\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++){\\n            m.put(keys[i],values[i]);\\n        }\\n        dictionary1=new String[dictionary.length];\\n        int i=0;\\n        for(String x:dictionary){\\n            dictionary1[i++]=x;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String x=\"\";\\n        for(char c:word1.toCharArray()){\\n            if(m.containsKey(c)){\\n                x+=m.get(c);\\n            }\\n        }\\n        return x;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int c1=0;\\n        for(String x:dictionary1){\\n           String x1=\"\";\\n            for(char c:x.toCharArray()){\\n                if(m.containsKey(c)){\\n                    x1+=m.get(c);\\n                }\\n            }\\n            if(word2.equals(x1))c1++;\\n        }\\n        return c1;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "\\n     class Encrypter {\\n        Map<Character,String> m=new HashMap<>();\\n    String dictionary1[];\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i=0;i<keys.length;i++){\\n            m.put(keys[i],values[i]);\\n        }\\n        dictionary1=new String[dictionary.length];\\n        int i=0;\\n        for(String x:dictionary){\\n            dictionary1[i++]=x;\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String x=\"\";\\n        for(char c:word1.toCharArray()){\\n            if(m.containsKey(c)){\\n                x+=m.get(c);\\n            }\\n        }\\n        return x;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int c1=0;\\n        for(String x:dictionary1){\\n           String x1=\"\";\\n            for(char c:x.toCharArray()){\\n                if(m.containsKey(c)){\\n                    x1+=m.get(c);\\n                }\\n            }\\n            if(word2.equals(x1))c1++;\\n        }\\n        return c1;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1913315,
                "title": "c-solution-using-trie",
                "content": "\\tclass Encrypter {\\n\\tpublic:\\n\\t\\tclass node{\\n\\t\\t\\tpublic:\\n\\t\\t\\tnode* next[26];\\n\\t\\t\\tbool isend;\\n\\t\\t\\tnode(){\\n\\t\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\t\\tnext[i] = nullptr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tisend = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tclass Trie {\\n\\t\\tpublic:\\n\\n\\t\\t\\tnode* root = new node;\\n\\t\\t\\tvoid insert(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) temp->next[c-\\'a\\'] = new node;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp->isend = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool search(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) return false;;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn temp->isend;\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\t\\tTrie t;\\n\\t\\tunordered_map<char,string> mp;\\n\\t\\tunordered_map<string, vector<char>> rmp;\\n\\t\\tunordered_map<string , bool> vis;\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\tfor(int i=0; i<keys.size(); i++){\\n\\t\\t\\t\\tmp[keys[i]] = values[i];\\n\\t\\t\\t\\trmp[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &w : dictionary){\\n\\t\\t\\t\\tvis[w] = true;\\n\\t\\t\\t\\tt.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\tstring str = \"\";\\n\\t\\t\\tfor(auto &c : word1){\\n\\t\\t\\t\\tstr += mp[c];\\n\\t\\t\\t}\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t\\tint solve(int i, vector<vector<char>> &vt, node* temp){\\n\\t\\t\\tif(i == vt.size()){\\n\\t\\t\\t\\tif(temp->isend) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int j=0; j<vt[i].size(); j++){\\n\\t\\t\\t\\tif(temp->next[vt[i][j] - \\'a\\'] != NULL){\\n\\t\\t\\t\\t\\tans += solve(i+1, vt, temp->next[vt[i][j] - \\'a\\']);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<char>> vt;\\n\\t\\t\\tvector<char> prev;\\n\\t\\t\\tif(n &1) return 0;\\n\\t\\t\\tfor(int i=0; i<n; i+=2){\\n\\t\\t\\t\\tstring str = \"\";\\n\\t\\t\\t\\tstr += word2[i];\\n\\t\\t\\t\\tstr += word2[i+1];\\n\\t\\t\\t\\tif(rmp.count(str) == 0) return 0;\\n\\t\\t\\t\\tvt.push_back(rmp[str]);\\n\\t\\t\\t}\\n\\t\\t\\tnode* temp = t.root;\\n\\t\\t\\tint ans = solve(0, vt, temp);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "\\tclass Encrypter {\\n\\tpublic:\\n\\t\\tclass node{\\n\\t\\t\\tpublic:\\n\\t\\t\\tnode* next[26];\\n\\t\\t\\tbool isend;\\n\\t\\t\\tnode(){\\n\\t\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\t\\tnext[i] = nullptr;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tisend = false;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tclass Trie {\\n\\t\\tpublic:\\n\\n\\t\\t\\tnode* root = new node;\\n\\t\\t\\tvoid insert(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) temp->next[c-\\'a\\'] = new node;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttemp->isend = true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool search(string word) {\\n\\t\\t\\t\\tnode* temp = root;\\n\\t\\t\\t\\tfor(int i=0; i<word.size(); i++){\\n\\t\\t\\t\\t\\tchar c = word[i];\\n\\t\\t\\t\\t\\tif(temp->next[c - \\'a\\'] == nullptr) return false;;\\n\\t\\t\\t\\t\\ttemp = temp->next[c-\\'a\\'];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn temp->isend;\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\t\\tTrie t;\\n\\t\\tunordered_map<char,string> mp;\\n\\t\\tunordered_map<string, vector<char>> rmp;\\n\\t\\tunordered_map<string , bool> vis;\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\tfor(int i=0; i<keys.size(); i++){\\n\\t\\t\\t\\tmp[keys[i]] = values[i];\\n\\t\\t\\t\\trmp[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &w : dictionary){\\n\\t\\t\\t\\tvis[w] = true;\\n\\t\\t\\t\\tt.insert(w);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\tstring str = \"\";\\n\\t\\t\\tfor(auto &c : word1){\\n\\t\\t\\t\\tstr += mp[c];\\n\\t\\t\\t}\\n\\t\\t\\treturn str;\\n\\t\\t}\\n\\t\\tint solve(int i, vector<vector<char>> &vt, node* temp){\\n\\t\\t\\tif(i == vt.size()){\\n\\t\\t\\t\\tif(temp->isend) return 1;\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\tfor(int j=0; j<vt[i].size(); j++){\\n\\t\\t\\t\\tif(temp->next[vt[i][j] - \\'a\\'] != NULL){\\n\\t\\t\\t\\t\\tans += solve(i+1, vt, temp->next[vt[i][j] - \\'a\\']);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\tint n = word2.size();\\n\\t\\t\\tvector<vector<char>> vt;\\n\\t\\t\\tvector<char> prev;\\n\\t\\t\\tif(n &1) return 0;\\n\\t\\t\\tfor(int i=0; i<n; i+=2){\\n\\t\\t\\t\\tstring str = \"\";\\n\\t\\t\\t\\tstr += word2[i];\\n\\t\\t\\t\\tstr += word2[i+1];\\n\\t\\t\\t\\tif(rmp.count(str) == 0) return 0;\\n\\t\\t\\t\\tvt.push_back(rmp[str]);\\n\\t\\t\\t}\\n\\t\\t\\tnode* temp = t.root;\\n\\t\\t\\tint ans = solve(0, vt, temp);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 1913137,
                "title": "c-hashset-and-trie",
                "content": "Basic ideas:\\n1.TLE issue: using dict1 as cache of Encrypt to avoid TLE.\\n2.Build a trie tree by all valid strings from dictionary. Using valid to mark an acceptable decrypt string.\\n\\n```\\n    public class Encrypter\\n    {\\n        private readonly Dictionary<char, string> encryptDict;\\n        private readonly Dictionary<string, List<char>> decryptDict;\\n        private readonly HashSet<string> set;\\n        private readonly Dictionary<string, string> dict1;\\n        private readonly TrieOfEncrypt root;\\n        public Encrypter(char[] keys, string[] values, string[] dictionary)\\n        {\\n            encryptDict=new Dictionary<char, string>();\\n            decryptDict=new Dictionary<string, List<char>>();\\n            for(int i=0; i<keys.Length; i++)\\n            {\\n                encryptDict.Add(keys[i], values[i]);\\n                if(!decryptDict.ContainsKey(values[i])) decryptDict.Add(values[i],new List<char>());\\n                decryptDict[values[i]].Add(keys[i]);\\n            }\\n            set = new HashSet<string>(dictionary);\\n            dict1 = new Dictionary<string, string>();\\n            root = new TrieOfEncrypt();\\n            BuildTrieTree();\\n        }\\n\\n        private void BuildTrieTree()\\n        {\\n            foreach(var key in set)\\n            {\\n                var curr = root;\\n                foreach(var c in key)\\n                {\\n                    if (!curr.childs.ContainsKey(c)) curr.childs.Add(c, new TrieOfEncrypt());\\n                    curr = curr.childs[c];\\n                }\\n                //only trie node with valid == true count 1 in Decrypt()\\n                curr.valid = true;\\n            }\\n        }\\n\\n        public string Encrypt(string word1)\\n        {\\n            //cache encrypt keys to avoid TLE\\n            if(dict1.ContainsKey(word1))return dict1[word1];\\n            StringBuilder sb= new StringBuilder();\\n            //string res = string.Empty;\\n            foreach (var c in word1)\\n                sb.Append(encryptDict[c]);\\n            var res = sb.ToString();\\n            dict1.Add(word1, res);\\n            return res;\\n        }\\n\\t\\t\\n        public int Decrypt(string word2)\\n        {\\n            var list = new List<TrieOfEncrypt>() { root };\\n            for(int i = 0; i < word2.Length; i += 2)\\n            {\\n                var str=word2.Substring(i, 2);\\n                if (!decryptDict.ContainsKey(str)) return 0;//cannot decrypted\\n                var next = new List<TrieOfEncrypt>();\\n                foreach (var curr in list)\\n                {\\n                    foreach (var c in decryptDict[str])\\n                    {\\n                        if (curr.childs.ContainsKey(c))\\n                            next.Add(curr.childs[c]);//only add available nodes to next loop\\n                    }\\n                }\\n                list = next;\\n                if (list.Count == 0) return 0;//can not decrypted\\n            }\\n            return list.Where(x=>x.valid).Count();\\n        }\\n    }\\n\\n    public class TrieOfEncrypt\\n    {\\n        //indicate if current trie node is valid\\n        public bool valid = false;\\n        public readonly Dictionary<char, TrieOfEncrypt> childs;\\n        public TrieOfEncrypt()\\n        {\\n            childs = new Dictionary<char, TrieOfEncrypt>();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Encrypter\\n    {\\n        private readonly Dictionary<char, string> encryptDict;\\n        private readonly Dictionary<string, List<char>> decryptDict;\\n        private readonly HashSet<string> set;\\n        private readonly Dictionary<string, string> dict1;\\n        private readonly TrieOfEncrypt root;\\n        public Encrypter(char[] keys, string[] values, string[] dictionary)\\n        {\\n            encryptDict=new Dictionary<char, string>();\\n            decryptDict=new Dictionary<string, List<char>>();\\n            for(int i=0; i<keys.Length; i++)\\n            {\\n                encryptDict.Add(keys[i], values[i]);\\n                if(!decryptDict.ContainsKey(values[i])) decryptDict.Add(values[i],new List<char>());\\n                decryptDict[values[i]].Add(keys[i]);\\n            }\\n            set = new HashSet<string>(dictionary);\\n            dict1 = new Dictionary<string, string>();\\n            root = new TrieOfEncrypt();\\n            BuildTrieTree();\\n        }\\n\\n        private void BuildTrieTree()\\n        {\\n            foreach(var key in set)\\n            {\\n                var curr = root;\\n                foreach(var c in key)\\n                {\\n                    if (!curr.childs.ContainsKey(c)) curr.childs.Add(c, new TrieOfEncrypt());\\n                    curr = curr.childs[c];\\n                }\\n                //only trie node with valid == true count 1 in Decrypt()\\n                curr.valid = true;\\n            }\\n        }\\n\\n        public string Encrypt(string word1)\\n        {\\n            //cache encrypt keys to avoid TLE\\n            if(dict1.ContainsKey(word1))return dict1[word1];\\n            StringBuilder sb= new StringBuilder();\\n            //string res = string.Empty;\\n            foreach (var c in word1)\\n                sb.Append(encryptDict[c]);\\n            var res = sb.ToString();\\n            dict1.Add(word1, res);\\n            return res;\\n        }\\n\\t\\t\\n        public int Decrypt(string word2)\\n        {\\n            var list = new List<TrieOfEncrypt>() { root };\\n            for(int i = 0; i < word2.Length; i += 2)\\n            {\\n                var str=word2.Substring(i, 2);\\n                if (!decryptDict.ContainsKey(str)) return 0;//cannot decrypted\\n                var next = new List<TrieOfEncrypt>();\\n                foreach (var curr in list)\\n                {\\n                    foreach (var c in decryptDict[str])\\n                    {\\n                        if (curr.childs.ContainsKey(c))\\n                            next.Add(curr.childs[c]);//only add available nodes to next loop\\n                    }\\n                }\\n                list = next;\\n                if (list.Count == 0) return 0;//can not decrypted\\n            }\\n            return list.Where(x=>x.valid).Count();\\n        }\\n    }\\n\\n    public class TrieOfEncrypt\\n    {\\n        //indicate if current trie node is valid\\n        public bool valid = false;\\n        public readonly Dictionary<char, TrieOfEncrypt> childs;\\n        public TrieOfEncrypt()\\n        {\\n            childs = new Dictionary<char, TrieOfEncrypt>();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913134,
                "title": "pre-count-dictionary-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.m={}\\n        for i in range(len(keys)):\\n            self.m[keys[i]]=values[i]\\n        self.count={}\\n        for word in dictionary:\\n            l=[]\\n            for c in word:\\n                l.append(self.m[c])\\n            possible_string=\"\".join(l)\\n            self.count[possible_string]=self.count.get(possible_string,0)+1\\n\\n                \\n    def encrypt(self, word1: str) -> str:\\n        l=[]\\n        for c in word1:\\n            l.append(self.m[c])\\n        possible_string=\"\".join(l)\\n        return possible_string\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.count.get(word2,0)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.m={}\\n        for i in range(len(keys)):\\n            self.m[keys[i]]=values[i]\\n        self.count={}\\n        for word in dictionary:\\n            l=[]\\n            for c in word:\\n                l.append(self.m[c])\\n            possible_string=\"\".join(l)\\n            self.count[possible_string]=self.count.get(possible_string,0)+1\\n\\n                \\n    def encrypt(self, word1: str) -> str:\\n        l=[]\\n        for c in word1:\\n            l.append(self.m[c])\\n        possible_string=\"\".join(l)\\n        return possible_string\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.count.get(word2,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912932,
                "title": "scala-simple-problem-so-0-need-for-more-than-5-lines-including-all",
                "content": "`encrypt` is easy. Now you might want to use complex algorithm for `decrypt`, but it turns out *(gotcha)*, the dictionary input is always quite small.\\nSo you could pre-encrypt them and make the histogram of encrypted values. When you hit `decrypt`, you simply return the pre-computed counts.\\n\\n```scala\\nclass Encrypter (_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n  val ktov = (_keys.iterator zip _values.iterator).toMap\\n  val encCounts = _dictionary.groupMapReduce (encrypt (_)) (_ => 1) (_ + _)\\n  def encrypt (word1: String): String = word1.flatMap (ktov (_)).mkString\\n  def decrypt (word2: String): Int = encCounts.getOrElse (word2, 0) }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```scala\\nclass Encrypter (_keys: Array[Char], _values: Array[String], _dictionary: Array[String]) {\\n  val ktov = (_keys.iterator zip _values.iterator).toMap\\n  val encCounts = _dictionary.groupMapReduce (encrypt (_)) (_ => 1) (_ + _)\\n  def encrypt (word1: String): String = word1.flatMap (ktov (_)).mkString\\n  def decrypt (word2: String): Int = encCounts.getOrElse (word2, 0) }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1912816,
                "title": "easy-understanding-c-code-trie",
                "content": "https://github.com/kumarmanish03/DSA-Solved-Questions/blob/main/Tree/Encrypt%20and%20Decrypt%20Strings.cpp\\n\\n```\\n// Manish Kumar, IIIT Allahabad\\n// Trie\\n\\nhttps://leetcode.com/problems/encrypt-and-decrypt-strings/\\n\\nclass Encrypter {\\npublic:\\n    struct Trie{\\n        Trie *child[26];\\n        Trie(){\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie* d;\\n    \\n    unordered_map<string, vector<char>> v;\\n    unordered_map<string, int> dict;\\n    vector<string> data;\\n    unordered_map<string, int> decrypted;\\n    \\n    int cnt;\\n    \\n    void insert(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                curr->child[c-\\'a\\'] = new Trie();\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n    }\\n    \\n    bool search(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                return false;\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n    \\n    Encrypter(vector<char>& key, vector<string>& val, vector<string>& dictionary) {\\n        d = new Trie();\\n        v.clear();\\n        cnt = 0;\\n        dict.clear();\\n        data.resize(26, \"\");\\n        decrypted.clear();\\n        \\n        for(string s:dictionary){\\n            insert(s, d);\\n            dict[s]++;\\n        }\\n        \\n        for(int i = 0; i < key.size();i++){\\n            data[key[i]-\\'a\\'] = val[i];\\n                // cout<<val[24];\\n        } \\n        \\n        for(int i = 0; i < val.size(); i++){\\n            v[val[i]].push_back(key[i]);\\n        }\\n        \\n               \\n        \\n    }\\n    \\n    void recur(string s, string t, int i){\\n        if(i >= s.size()){\\n            if(dict[t])\\n                cnt++;\\n            return;\\n        }\\n        \\n        if(search(t, d) == false)\\n            return;\\n        \\n        string q = s.substr(i, 2);\\n        for(char x:v[q])\\n            recur(s, t+x, i+2);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            res += data[word1[i]-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(decrypted.find(word2) != decrypted.end())\\n            return decrypted[word2];\\n        cnt = 0;\\n        string t = \"\";\\n        int i = 0;\\n        recur(word2, t, i);\\n        return decrypted[word2] = cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\n// Manish Kumar, IIIT Allahabad\\n// Trie\\n\\nhttps://leetcode.com/problems/encrypt-and-decrypt-strings/\\n\\nclass Encrypter {\\npublic:\\n    struct Trie{\\n        Trie *child[26];\\n        Trie(){\\n            for(int i = 0; i < 26; i++)\\n                child[i] = NULL;\\n        }\\n    };\\n    \\n    Trie* d;\\n    \\n    unordered_map<string, vector<char>> v;\\n    unordered_map<string, int> dict;\\n    vector<string> data;\\n    unordered_map<string, int> decrypted;\\n    \\n    int cnt;\\n    \\n    void insert(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                curr->child[c-\\'a\\'] = new Trie();\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n    }\\n    \\n    bool search(string s, Trie* head){\\n        Trie* curr = head;\\n        for(char c:s){\\n            if(!curr->child[c-\\'a\\'])\\n                return false;\\n            curr = curr->child[c-\\'a\\'];\\n        }\\n        return true;\\n    }\\n    \\n    Encrypter(vector<char>& key, vector<string>& val, vector<string>& dictionary) {\\n        d = new Trie();\\n        v.clear();\\n        cnt = 0;\\n        dict.clear();\\n        data.resize(26, \"\");\\n        decrypted.clear();\\n        \\n        for(string s:dictionary){\\n            insert(s, d);\\n            dict[s]++;\\n        }\\n        \\n        for(int i = 0; i < key.size();i++){\\n            data[key[i]-\\'a\\'] = val[i];\\n                // cout<<val[24];\\n        } \\n        \\n        for(int i = 0; i < val.size(); i++){\\n            v[val[i]].push_back(key[i]);\\n        }\\n        \\n               \\n        \\n    }\\n    \\n    void recur(string s, string t, int i){\\n        if(i >= s.size()){\\n            if(dict[t])\\n                cnt++;\\n            return;\\n        }\\n        \\n        if(search(t, d) == false)\\n            return;\\n        \\n        string q = s.substr(i, 2);\\n        for(char x:v[q])\\n            recur(s, t+x, i+2);\\n    }\\n    \\n    string encrypt(string word1) {\\n        string res=\"\";\\n        for(int i = 0; i < word1.size(); i++){\\n            res += data[word1[i]-\\'a\\'];\\n        }\\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if(decrypted.find(word2) != decrypted.end())\\n            return decrypted[word2];\\n        cnt = 0;\\n        string t = \"\";\\n        int i = 0;\\n        recur(word2, t, i);\\n        return decrypted[word2] = cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1912408,
                "title": "rust-translated-from-lee215-s-solution",
                "content": "```rust\\n\\nuse std::{\\n    cmp::{Ordering, Reverse},\\n    collections::{BinaryHeap, HashMap, HashSet},\\n    fmt::Binary,\\n    hash::Hash,\\n};\\n\\nstruct Encrypter {\\n    encode: HashMap<char, String>,\\n    count: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut encode = HashMap::new();\\n        for i in 0..keys.len() {\\n            encode.insert(keys[i], values[i].clone());\\n        }\\n\\n        let mut count = HashMap::new();\\n        let mut encrypter = Encrypter { encode, count };\\n\\n        for w in dictionary {\\n            let encoded = Self::encrypt(&encrypter, w);\\n            *encrypter.count.entry(encoded).or_insert(0) += 1;\\n        }\\n\\n        encryptera\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res = String::new();\\n        for c in word1.chars() {\\n            let value = self.encode.get(&c).unwrap();\\n            res.push_str(value.as_str())\\n        }\\n        res\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 {\\n        match self.count.get(&word2) {\\n            Some(res) => *res,\\n            None => 0,\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n\\nuse std::{\\n    cmp::{Ordering, Reverse},\\n    collections::{BinaryHeap, HashMap, HashSet},\\n    fmt::Binary,\\n    hash::Hash,\\n};\\n\\nstruct Encrypter {\\n    encode: HashMap<char, String>,\\n    count: HashMap<String, i32>,\\n}\\n\\nimpl Encrypter {\\n    fn new(keys: Vec<char>, values: Vec<String>, dictionary: Vec<String>) -> Self {\\n        let mut encode = HashMap::new();\\n        for i in 0..keys.len() {\\n            encode.insert(keys[i], values[i].clone());\\n        }\\n\\n        let mut count = HashMap::new();\\n        let mut encrypter = Encrypter { encode, count };\\n\\n        for w in dictionary {\\n            let encoded = Self::encrypt(&encrypter, w);\\n            *encrypter.count.entry(encoded).or_insert(0) += 1;\\n        }\\n\\n        encryptera\\n    }\\n\\n    fn encrypt(&self, word1: String) -> String {\\n        let mut res = String::new();\\n        for c in word1.chars() {\\n            let value = self.encode.get(&c).unwrap();\\n            res.push_str(value.as_str())\\n        }\\n        res\\n    }\\n\\n    fn decrypt(&self, word2: String) -> i32 {\\n        match self.count.get(&word2) {\\n            Some(res) => *res,\\n            None => 0,\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1912223,
                "title": "3-min-hindi-video-simple-hash-solution",
                "content": "3 min Hindi Video | Simple hash Solution \\nyoutube .com/watch?v=3Ev4oM6p-s4\\n\\nPLEASE PLEASE upvote it if you like it. Jaroor upvote karna.",
                "solutionTags": [],
                "code": "3 min Hindi Video | Simple hash Solution \\nyoutube .com/watch?v=3Ev4oM6p-s4\\n\\nPLEASE PLEASE upvote it if you like it. Jaroor upvote karna.",
                "codeTag": "Unknown"
            },
            {
                "id": 1911731,
                "title": "python-simple-use-two-dicts",
                "content": "We just need to use 2 dicts:\\n**dict1**: to map character from *key* to its value in *values* (which will be used in *encrypt*)\\n**dict2**: to map each word in dictionary to its encrypted word using **dict1** and store its count of occurances (which will be used in *decrypt*)\\n\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.pair,self.de = defaultdict(str),defaultdict(int)\\n        for i,j in enumerate(keys):\\n            self.pair[j]=values[i]\\n        for i in dictionary:\\n            key = \"\".join(self.pair[j] for j in i)\\n            self.de[key]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.pair[i] for i in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.de[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.pair,self.de = defaultdict(str),defaultdict(int)\\n        for i,j in enumerate(keys):\\n            self.pair[j]=values[i]\\n        for i in dictionary:\\n            key = \"\".join(self.pair[j] for j in i)\\n            self.de[key]+=1\\n\\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.pair[i] for i in word1)\\n\\n    def decrypt(self, word2: str) -> int:\\n        return self.de[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911486,
                "title": "c-easy-solution",
                "content": "```\\nclass Encrypter {\\npublic:\\n    //data members\\n    vector<char> keys;\\n    vector<string> values;\\n    vector<string> dictionary;\\n    unordered_map<char, int> keyIndex;\\n    unordered_map<string, vector<int>> valuesIndex;\\n    unordered_map<string, int> freq;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->keys = keys;\\n        this->values = values;\\n        this->dictionary = dictionary;\\n        for(int i = 0; i < keys.size(); i++){\\n            keyIndex[keys[i]] = i;\\n        }\\n        for(int i = 0; i < values.size(); i++){\\n            valuesIndex[values[i]].push_back(i);\\n        }\\n        \\n        for(auto i: dictionary){\\n            string ans = encrypt(i);\\n            freq[ans] += 1;\\n        }\\n    }\\n   \\n\\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto i: word1){\\n            int index = keyIndex[i];\\n            string temp = values[index];\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       return freq[word2];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter {\\npublic:\\n    //data members\\n    vector<char> keys;\\n    vector<string> values;\\n    vector<string> dictionary;\\n    unordered_map<char, int> keyIndex;\\n    unordered_map<string, vector<int>> valuesIndex;\\n    unordered_map<string, int> freq;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        this->keys = keys;\\n        this->values = values;\\n        this->dictionary = dictionary;\\n        for(int i = 0; i < keys.size(); i++){\\n            keyIndex[keys[i]] = i;\\n        }\\n        for(int i = 0; i < values.size(); i++){\\n            valuesIndex[values[i]].push_back(i);\\n        }\\n        \\n        for(auto i: dictionary){\\n            string ans = encrypt(i);\\n            freq[ans] += 1;\\n        }\\n    }\\n   \\n\\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto i: word1){\\n            int index = keyIndex[i];\\n            string temp = values[index];\\n            ans += temp;\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n       return freq[word2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911396,
                "title": "python-very-simple-solution",
                "content": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_val_map=dict()\\n        for i in range(len(keys)):\\n            self.key_val_map[keys[i]]=values[i]\\n        \\n        self.dictionary_freq=defaultdict(int)\\n        for i in dictionary:\\n            ans=\"\"\\n            for char in i:\\n                ans+=self.key_val_map[char]\\n            self.dictionary_freq[ans]+=1\\n                \\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        ans=\"\"\\n        for char in word1:\\n            ans+=self.key_val_map[char]\\n        return ans\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        return self.dictionary_freq[word2]\\n        \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.key_val_map=dict()\\n        for i in range(len(keys)):\\n            self.key_val_map[keys[i]]=values[i]\\n        \\n        self.dictionary_freq=defaultdict(int)\\n        for i in dictionary:\\n            ans=\"\"\\n            for char in i:\\n                ans+=self.key_val_map[char]\\n            self.dictionary_freq[ans]+=1\\n                \\n        \\n\\n    def encrypt(self, word1: str) -> str:\\n        ans=\"\"\\n        for char in word1:\\n            ans+=self.key_val_map[char]\\n        return ans\\n        \\n\\n    def decrypt(self, word2: str) -> int:\\n        \\n        return self.dictionary_freq[word2]\\n        \\n\\n\\n# Your Encrypter object will be instantiated and called as such:\\n# obj = Encrypter(keys, values, dictionary)\\n# param_1 = obj.encrypt(word1)\\n# param_2 = obj.decrypt(word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911391,
                "title": "python-three-lines-of-code",
                "content": "This is the easiest hard problem ever. It\\'s just three lines of python code with one line in each class method.\\n\\n```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.k2v, self.dict = dict(zip(keys, values)), dictionary\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.k2v[c] for c in word1)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return sum(1 for word in self.dict if self.encrypt(word) == word2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.k2v, self.dict = dict(zip(keys, values)), dictionary\\n        \\n    def encrypt(self, word1: str) -> str:\\n        return \"\".join(self.k2v[c] for c in word1)\\n        \\n    def decrypt(self, word2: str) -> int:\\n        return sum(1 for word in self.dict if self.encrypt(word) == word2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911346,
                "title": "java-solution-using-trie",
                "content": "```\\nclass TrieNode{\\n    public Map<Character, TrieNode> children = new HashMap();\\n    public boolean isWord;\\n}\\n\\nclass Encrypter {\\n    Map<Character, String> keysToValues  = new HashMap();\\n    Map<String, List<Character>> valuesToKeys = new HashMap();\\n    TrieNode root = new TrieNode();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i  = 0;\\n        for(char key : keys){\\n            keysToValues.put(key, values[i++]);\\n        }\\n        for(i = 0; i < values.length; i++){\\n            valuesToKeys.putIfAbsent(values[i], new ArrayList());\\n            valuesToKeys.get(values[i]).add(keys[i]);\\n        }\\n        \\n        for(String word : dictionary){\\n            construct(root, word);\\n        }\\n    }\\n    \\n    private void construct(TrieNode root, String word){\\n        for(int i = 0; i< word.length(); i++){\\n            char c = word.charAt(i);\\n            if(root.children.containsKey(c)){\\n                root = root.children.get(c);\\n            }else{\\n                TrieNode node = new TrieNode();\\n                root.children.put(c, node);\\n                root = node;\\n            }\\n        }\\n        \\n        root.isWord = true;\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i< word1.length(); i++){\\n            char c = word1.charAt(i);\\n            if(keysToValues.get(c) != null){\\n                sb.append(keysToValues.get(c));\\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n       return count(root, word2, 0);\\n    }\\n    \\n    private int count(TrieNode root, String word2, int index){\\n        if(index == word2.length() && root.isWord) return 1;\\n        if(index == word2.length()) return 0;\\n        String str = word2.substring(index, index+2);\\n        int res = 0;\\n        if( valuesToKeys.get(str) != null){\\n            for(Character c  : valuesToKeys.get(str)){\\n                if(root.children.get(c) != null){\\n                    res += count(root.children.get(c), word2, index+2);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n    public Map<Character, TrieNode> children = new HashMap();\\n    public boolean isWord;\\n}\\n\\nclass Encrypter {\\n    Map<Character, String> keysToValues  = new HashMap();\\n    Map<String, List<Character>> valuesToKeys = new HashMap();\\n    TrieNode root = new TrieNode();\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int i  = 0;\\n        for(char key : keys){\\n            keysToValues.put(key, values[i++]);\\n        }\\n        for(i = 0; i < values.length; i++){\\n            valuesToKeys.putIfAbsent(values[i], new ArrayList());\\n            valuesToKeys.get(values[i]).add(keys[i]);\\n        }\\n        \\n        for(String word : dictionary){\\n            construct(root, word);\\n        }\\n    }\\n    \\n    private void construct(TrieNode root, String word){\\n        for(int i = 0; i< word.length(); i++){\\n            char c = word.charAt(i);\\n            if(root.children.containsKey(c)){\\n                root = root.children.get(c);\\n            }else{\\n                TrieNode node = new TrieNode();\\n                root.children.put(c, node);\\n                root = node;\\n            }\\n        }\\n        \\n        root.isWord = true;\\n    }\\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(int i = 0; i< word1.length(); i++){\\n            char c = word1.charAt(i);\\n            if(keysToValues.get(c) != null){\\n                sb.append(keysToValues.get(c));\\n            }else{\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n       return count(root, word2, 0);\\n    }\\n    \\n    private int count(TrieNode root, String word2, int index){\\n        if(index == word2.length() && root.isWord) return 1;\\n        if(index == word2.length()) return 0;\\n        String str = word2.substring(index, index+2);\\n        int res = 0;\\n        if( valuesToKeys.get(str) != null){\\n            for(Character c  : valuesToKeys.get(str)){\\n                if(root.children.get(c) != null){\\n                    res += count(root.children.get(c), word2, index+2);\\n                } \\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1911321,
                "title": "most-optimized-code-using-dict",
                "content": "\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n\\t\\tself.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\tdef decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "solutionTags": [],
                "code": "\\ndef __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n\\t\\tself.d = defaultdict(int)\\n        self.m = {}\\n        for i, j in zip(keys, values):\\n            self.m[i] = j\\n        print(self.m)\\n        for i in dictionary:\\n            l = []\\n            for x in i:\\n                l.append(self.m[x])\\n            self.d[\\'\\'.join(l)] += 1\\n        print(self.d)\\n    def encrypt(self, word1: str) -> str:\\n        l = []\\n        for x in word1:\\n            l.append(self.m[x])\\n        return \\'\\'.join(l)\\n\\tdef decrypt(self, word2: str) -> int:\\n        return self.d[word2]",
                "codeTag": "Python3"
            },
            {
                "id": 1911295,
                "title": "easy-c-solution-hashmap-tries",
                "content": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> encryptMap;\\n    map<string,vector<char>> decryptMap;\\n    struct Trie{\\n        Trie* characters[26];\\n        bool isEnd = false;\\n    }*trie = new Trie();\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int index = 0 ; index < keys.size() ; ++index){\\n            encryptMap[keys[index]] = values[index];\\n        }\\n        for(int index = 0 ; index < values.size() ; ++index){\\n            decryptMap[values[index]].push_back(keys[index]);\\n        }\\n        for(auto word : dictionary){\\n            struct Trie* temp = trie;\\n            for(auto ch : word){\\n                if(!temp->characters[ch - \\'a\\']){\\n                    temp->characters[ch - \\'a\\'] = new Trie();\\n                }\\n                temp = temp->characters[ch - \\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans;\\n        for(auto ch : word1){\\n            ans.append(encryptMap[ch]);\\n        }\\n        return ans;\\n    }\\n    int decryptCount(string &word2 , int index , struct Trie* trie){\\n        if(index == word2.length()){\\n            if(trie->isEnd){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        int count = 0;\\n        for(auto ch : decryptMap[word2.substr(index , 2)]){\\n            if(trie->characters[ch - \\'a\\']){\\n                count += decryptCount(word2 , index + 2 , trie->characters[ch - \\'a\\']);\\n            }\\n        }\\n        return count;\\n    }\\n    int decrypt(string word2) {\\n        return decryptCount(word2 , 0 , trie);\\n    \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char,string> encryptMap;\\n    map<string,vector<char>> decryptMap;\\n    struct Trie{\\n        Trie* characters[26];\\n        bool isEnd = false;\\n    }*trie = new Trie();\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int index = 0 ; index < keys.size() ; ++index){\\n            encryptMap[keys[index]] = values[index];\\n        }\\n        for(int index = 0 ; index < values.size() ; ++index){\\n            decryptMap[values[index]].push_back(keys[index]);\\n        }\\n        for(auto word : dictionary){\\n            struct Trie* temp = trie;\\n            for(auto ch : word){\\n                if(!temp->characters[ch - \\'a\\']){\\n                    temp->characters[ch - \\'a\\'] = new Trie();\\n                }\\n                temp = temp->characters[ch - \\'a\\'];\\n            }\\n            temp->isEnd = true;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans;\\n        for(auto ch : word1){\\n            ans.append(encryptMap[ch]);\\n        }\\n        return ans;\\n    }\\n    int decryptCount(string &word2 , int index , struct Trie* trie){\\n        if(index == word2.length()){\\n            if(trie->isEnd){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        int count = 0;\\n        for(auto ch : decryptMap[word2.substr(index , 2)]){\\n            if(trie->characters[ch - \\'a\\']){\\n                count += decryptCount(word2 , index + 2 , trie->characters[ch - \\'a\\']);\\n            }\\n        }\\n        return count;\\n    }\\n    int decrypt(string word2) {\\n        return decryptCount(word2 , 0 , trie);\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911250,
                "title": "python3-stupid-easy-solution-with-counter",
                "content": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = dict(zip(keys, values))\\n        self.ctr = Counter(self.encrypt(w) for w in dictionary)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        s = list(word1)\\n        for i, c in enumerate(word1):\\n            s[i] = self.kv[c]\\n        return \\'\\'.join(s)\\n            \\n    def decrypt(self, word2: str) -> int:\\n        return self.ctr[word2]\\n ```",
                "solutionTags": [],
                "code": "```python\\nclass Encrypter:\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.kv = dict(zip(keys, values))\\n        self.ctr = Counter(self.encrypt(w) for w in dictionary)\\n        \\n    def encrypt(self, word1: str) -> str:\\n        s = list(word1)\\n        for i, c in enumerate(word1):\\n            s[i] = self.kv[c]\\n        return \\'\\'.join(s)\\n            \\n    def decrypt(self, word2: str) -> int:\\n        return self.ctr[word2]\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1911205,
                "title": "java-hashmaps-with-trick",
                "content": "The way the problem is defined - is probably just Medium:\\n* Encryption - just follow the mapping rules.\\n* Decryption - there\\'s only a finite number of decryption results - encrypt them all in preprocessing and then just lookup input to decrypt.\\n```\\nclass Encrypter {\\n    Map<Character,String> enc;\\n    Map<String,Integer> encDict;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int n= keys.length;\\n        this.enc= new HashMap<>();\\n        for(int i=0; i<n; i++) enc.put(keys[i], values[i]);\\n\\n        this.encDict= new HashMap<>();\\n        for(String word:dictionary){\\n            String encWord= encrypt(word);\\n            encDict.put(encWord, 1+encDict.getOrDefault(encWord, 0));\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] ca= word1.toCharArray();\\n        StringBuilder sb= new StringBuilder();\\n        for(char c:ca) sb.append(enc.get(c));\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encDict.getOrDefault(word2, 0);\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "The way the problem is defined - is probably just Medium:\\n* Encryption - just follow the mapping rules.\\n* Decryption - there\\'s only a finite number of decryption results - encrypt them all in preprocessing and then just lookup input to decrypt.\\n```\\nclass Encrypter {\\n    Map<Character,String> enc;\\n    Map<String,Integer> encDict;\\n    \\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        int n= keys.length;\\n        this.enc= new HashMap<>();\\n        for(int i=0; i<n; i++) enc.put(keys[i], values[i]);\\n\\n        this.encDict= new HashMap<>();\\n        for(String word:dictionary){\\n            String encWord= encrypt(word);\\n            encDict.put(encWord, 1+encDict.getOrDefault(encWord, 0));\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        char[] ca= word1.toCharArray();\\n        StringBuilder sb= new StringBuilder();\\n        for(char c:ca) sb.append(enc.get(c));\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return encDict.getOrDefault(word2, 0);\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1910749,
                "title": "python-3-hashmap-and-counter",
                "content": "Maintain a hashmap and a counter. Hashmap `c2v` converts keys to values, and garanteed by the question all letters in word1 appear in keys. Counter `en_ct` keeps count of encrypted from all words in the dictionary, if word2 is in `en_ct`, return its count, otherwise 0 - word2 not in the dictionary.\\n\\n```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.en_ct = Counter()\\n        self.c2v = {keys[i]: values[i] for i in range(len(keys))}\\n        for word in dictionary:\\n            s = \\'\\'\\n            for c in word:\\n                s += self.c2v[c]\\n            self.en_ct[s] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        s = \\'\\'\\n        for c in word1:\\n            s += self.c2v[c]\\n        return s\\n\\n    def decrypt(self, word2: str) -> int:\\n        if word2 not in self.en_ct:\\n            return 0\\n        return self.en_ct[word2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Encrypter:\\n\\n    def __init__(self, keys: List[str], values: List[str], dictionary: List[str]):\\n        self.en_ct = Counter()\\n        self.c2v = {keys[i]: values[i] for i in range(len(keys))}\\n        for word in dictionary:\\n            s = \\'\\'\\n            for c in word:\\n                s += self.c2v[c]\\n            self.en_ct[s] += 1\\n\\n    def encrypt(self, word1: str) -> str:\\n        s = \\'\\'\\n        for c in word1:\\n            s += self.c2v[c]\\n        return s\\n\\n    def decrypt(self, word2: str) -> int:\\n        if word2 not in self.en_ct:\\n            return 0\\n        return self.en_ct[word2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910648,
                "title": "java-trie-hashmap-o-n",
                "content": "The idea is to encrypt all dictionary words and create a trie tree of all of them.\\nRoot nodes of the trie tree should hold the dictionary frequency of each encrypted word \\n\\n```\\nclass Encrypter {\\n\\n    class TrieNode {\\n        public int count;\\n        public TrieNode[] next;\\n\\n        public TrieNode() {\\n            count = 0;\\n            next = new TrieNode[26];\\n        }\\n        public void add(String str) {\\n            TrieNode node = this;\\n            for (int i = 0; i < str.length(); i++) {\\n                int index = str.charAt(i) - \\'a\\';\\n                if (node.next[index] == null) {\\n                    node.next[index] = new TrieNode();\\n                }\\n                node = node.next[index];\\n            }\\n            node.count++;\\n        }\\n    }\\n\\n\\n    HashMap < Character, Integer > keysMap;\\n    String[] values;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        keysMap = new HashMap();\\n        for (int i = 0; i < keys.length; i++) {\\n            keysMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n        root = new TrieNode();\\n        for (String s: dictionary) {\\n            root.add(encrypt(s));\\n        }\\n\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < word1.length(); i++) {\\n            str.append(values[keysMap.get(word1.charAt(i))]);\\n        }\\n\\n        return str.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        TrieNode node = root;\\n        for (int i = 0; i < word2.length(); i++) {\\n            int index = word2.charAt(i) - \\'a\\';\\n            if (node.next[index] == null) return 0;\\n            else node = node.next[index];\\n        }\\n        return node.count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass Encrypter {\\n\\n    class TrieNode {\\n        public int count;\\n        public TrieNode[] next;\\n\\n        public TrieNode() {\\n            count = 0;\\n            next = new TrieNode[26];\\n        }\\n        public void add(String str) {\\n            TrieNode node = this;\\n            for (int i = 0; i < str.length(); i++) {\\n                int index = str.charAt(i) - \\'a\\';\\n                if (node.next[index] == null) {\\n                    node.next[index] = new TrieNode();\\n                }\\n                node = node.next[index];\\n            }\\n            node.count++;\\n        }\\n    }\\n\\n\\n    HashMap < Character, Integer > keysMap;\\n    String[] values;\\n    TrieNode root;\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        keysMap = new HashMap();\\n        for (int i = 0; i < keys.length; i++) {\\n            keysMap.put(keys[i], i);\\n        }\\n        this.values = values;\\n        root = new TrieNode();\\n        for (String s: dictionary) {\\n            root.add(encrypt(s));\\n        }\\n\\n    }\\n\\n    public String encrypt(String word1) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < word1.length(); i++) {\\n            str.append(values[keysMap.get(word1.charAt(i))]);\\n        }\\n\\n        return str.toString();\\n    }\\n\\n    public int decrypt(String word2) {\\n        TrieNode node = root;\\n        for (int i = 0; i < word2.length(); i++) {\\n            int index = word2.charAt(i) - \\'a\\';\\n            if (node.next[index] == null) return 0;\\n            else node = node.next[index];\\n        }\\n        return node.count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910582,
                "title": "java-hashmap-only-easy-understanding",
                "content": "```\\nclass Encrypter {\\n    HashMap<Character, String> map = new HashMap<>(); // key to value\\n    HashMap<String, Integer> map2 = new HashMap<>(); // encrypt every word in dictionary, map it to number of times its found in dictionary\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0;i < keys.length; i++){\\n            map.put(keys[i], values[i]);\\n        }\\n        for(int i = 0;i < dictionary.length; i++){\\n            map2.put(encrypt(dictionary[i]), map2.getOrDefault(encrypt(dictionary[i]), 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String encrypted = \"\";\\n        for(int i = 0;i < word1.length(); i++){\\n            char curr = word1.charAt(i);\\n            encrypted += map.get(curr);\\n        }\\n        return encrypted;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return map2.getOrDefault(word2, 0);\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character, String> map = new HashMap<>(); // key to value\\n    HashMap<String, Integer> map2 = new HashMap<>(); // encrypt every word in dictionary, map it to number of times its found in dictionary\\n    public Encrypter(char[] keys, String[] values, String[] dictionary) {\\n        for(int i = 0;i < keys.length; i++){\\n            map.put(keys[i], values[i]);\\n        }\\n        for(int i = 0;i < dictionary.length; i++){\\n            map2.put(encrypt(dictionary[i]), map2.getOrDefault(encrypt(dictionary[i]), 0) + 1);\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        String encrypted = \"\";\\n        for(int i = 0;i < word1.length(); i++){\\n            char curr = word1.charAt(i);\\n            encrypted += map.get(curr);\\n        }\\n        return encrypted;\\n    }\\n    \\n    public int decrypt(String word2) {\\n        return map2.getOrDefault(word2, 0);\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910551,
                "title": "c-hashmap-trie",
                "content": "```\\nclass Trie{\\nprivate:\\n    unordered_map<string, Trie*> next; \\n    bool isWord = false;\\n    int match = 0;\\npublic:\\n    Trie(){}\\n    void insert(string word,vector<string>& ktov)\\n    {\\n        Trie* node = this;\\n        for(char& c:word)\\n        {\\n            if(node->next[ktov[c-\\'a\\']]==nullptr)\\n                node->next[ktov[c-\\'a\\']] = new Trie();\\n            node = node->next[ktov[c-\\'a\\']];\\n        }\\n        node->isWord = true;\\n        node->match++;\\n    }\\n    int search(string word)\\n    {\\n        Trie* node = this;\\n        for(int i=0;i<word.size();i+=2)\\n        {\\n            string now = word.substr(i,2);\\n            if(node->next[now]==nullptr)\\n                return 0;\\n            node = node->next[now];\\n        }\\n        return node->match;\\n    }\\n};\\nclass Encrypter {\\nprivate:\\n    unordered_set<string> dict;\\n    vector<string> ktov;\\n    unordered_map<string,vector<char>> vtok;\\n    Trie* d;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        ktov.assign(26,\"\");\\n        d = new Trie();\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            ktov[keys[i]-\\'a\\'] = values[i];\\n            vtok[values[i]].push_back(keys[i]);\\n        }\\n        for(auto& t:dictionary)\\n        {\\n            d->insert(t,ktov);\\n        }\\n            \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& w:word1)\\n        {\\n            ans += ktov[w-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return d->search(word2);\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Trie{\\nprivate:\\n    unordered_map<string, Trie*> next; \\n    bool isWord = false;\\n    int match = 0;\\npublic:\\n    Trie(){}\\n    void insert(string word,vector<string>& ktov)\\n    {\\n        Trie* node = this;\\n        for(char& c:word)\\n        {\\n            if(node->next[ktov[c-\\'a\\']]==nullptr)\\n                node->next[ktov[c-\\'a\\']] = new Trie();\\n            node = node->next[ktov[c-\\'a\\']];\\n        }\\n        node->isWord = true;\\n        node->match++;\\n    }\\n    int search(string word)\\n    {\\n        Trie* node = this;\\n        for(int i=0;i<word.size();i+=2)\\n        {\\n            string now = word.substr(i,2);\\n            if(node->next[now]==nullptr)\\n                return 0;\\n            node = node->next[now];\\n        }\\n        return node->match;\\n    }\\n};\\nclass Encrypter {\\nprivate:\\n    unordered_set<string> dict;\\n    vector<string> ktov;\\n    unordered_map<string,vector<char>> vtok;\\n    Trie* d;\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        ktov.assign(26,\"\");\\n        d = new Trie();\\n        for(int i=0;i<keys.size();i++)\\n        {\\n            ktov[keys[i]-\\'a\\'] = values[i];\\n            vtok[values[i]].push_back(keys[i]);\\n        }\\n        for(auto& t:dictionary)\\n        {\\n            d->insert(t,ktov);\\n        }\\n            \\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto& w:word1)\\n        {\\n            ans += ktov[w-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return d->search(word2);\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910411,
                "title": "trie-but-failed-very-hard-time-limit",
                "content": "\\tclass Node{\\n\\tpublic:\\n\\t\\tbool isEnd;\\n\\t\\tNode* arr[26];\\n\\n\\t\\tNode(){\\n\\t\\t\\tisEnd = false;\\n\\t\\t\\tfor(int i=0;i<26;i++) {\\n\\t\\t\\t\\tarr[i] = NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tclass Encrypter {\\n\\t\\tNode* root;\\n\\t\\tunordered_map<char,string> keys;\\n\\t\\tunordered_map<string,vector<char> > values;\\n\\n\\t\\tvoid insert(string& s){\\n\\t\\t\\tNode* t = root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tif(t->arr[s[i] - \\'a\\'] == NULL) {\\n\\t\\t\\t\\t\\tt->arr[s[i] - \\'a\\'] = new Node();\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tt = t->arr[s[i]-\\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tt->isEnd = true;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string& word,int i,Node* t){\\n\\t\\t\\tif(i >= word.size()) {\\n\\t\\t\\t\\treturn t->isEnd;\\n\\t\\t\\t}\\n\\t\\t\\tstring s = word.substr(i,2);\\n\\t\\t\\tint ans = 0;        \\n\\t\\t\\tfor(char& ch:values[s]) {\\n\\t\\t\\t\\tif(t->arr[ch - \\'a\\'] == NULL) continue;\\n\\t\\t\\t\\tans += decrypt(word, i+2, t->arr[ch - \\'a\\']);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\t// Encrypter\\n\\t\\t\\tfor(int i=0;i<keys.size();i++) {\\n\\t\\t\\t\\tthis->keys[keys[i]] = values[i];\\n\\t\\t\\t\\tthis->values[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\troot = new Node();\\n\\t\\t\\tfor(string& it:dictionary){\\n\\t\\t\\t\\tinsert(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\t// encrypt\\n\\t\\t\\tstring word = \"\";\\n\\t\\t\\tfor(char& c:word1){\\n\\t\\t\\t\\tword = word + keys[c]; \\n\\t\\t\\t}\\n\\t\\t\\treturn word;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\t// decrypt\\n\\t\\t\\treturn decrypt(word2, 0, root);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "solutionTags": [
                    "Trie"
                ],
                "code": "\\tclass Node{\\n\\tpublic:\\n\\t\\tbool isEnd;\\n\\t\\tNode* arr[26];\\n\\n\\t\\tNode(){\\n\\t\\t\\tisEnd = false;\\n\\t\\t\\tfor(int i=0;i<26;i++) {\\n\\t\\t\\t\\tarr[i] = NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\n\\tclass Encrypter {\\n\\t\\tNode* root;\\n\\t\\tunordered_map<char,string> keys;\\n\\t\\tunordered_map<string,vector<char> > values;\\n\\n\\t\\tvoid insert(string& s){\\n\\t\\t\\tNode* t = root;\\n\\t\\t\\tfor(int i=0;i<s.size();i++) {\\n\\t\\t\\t\\tif(t->arr[s[i] - \\'a\\'] == NULL) {\\n\\t\\t\\t\\t\\tt->arr[s[i] - \\'a\\'] = new Node();\\n\\t\\t\\t\\t}            \\n\\t\\t\\t\\tt = t->arr[s[i]-\\'a\\'];\\n\\t\\t\\t}\\n\\t\\t\\tt->isEnd = true;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string& word,int i,Node* t){\\n\\t\\t\\tif(i >= word.size()) {\\n\\t\\t\\t\\treturn t->isEnd;\\n\\t\\t\\t}\\n\\t\\t\\tstring s = word.substr(i,2);\\n\\t\\t\\tint ans = 0;        \\n\\t\\t\\tfor(char& ch:values[s]) {\\n\\t\\t\\t\\tif(t->arr[ch - \\'a\\'] == NULL) continue;\\n\\t\\t\\t\\tans += decrypt(word, i+2, t->arr[ch - \\'a\\']);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tEncrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n\\t\\t\\t// Encrypter\\n\\t\\t\\tfor(int i=0;i<keys.size();i++) {\\n\\t\\t\\t\\tthis->keys[keys[i]] = values[i];\\n\\t\\t\\t\\tthis->values[values[i]].push_back(keys[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\troot = new Node();\\n\\t\\t\\tfor(string& it:dictionary){\\n\\t\\t\\t\\tinsert(it);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tstring encrypt(string word1) {\\n\\t\\t\\t// encrypt\\n\\t\\t\\tstring word = \"\";\\n\\t\\t\\tfor(char& c:word1){\\n\\t\\t\\t\\tword = word + keys[c]; \\n\\t\\t\\t}\\n\\t\\t\\treturn word;\\n\\t\\t}\\n\\n\\t\\tint decrypt(string word2) {\\n\\t\\t\\t// decrypt\\n\\t\\t\\treturn decrypt(word2, 0, root);\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your Encrypter object will be instantiated and called as such:\\n\\t * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n\\t * string param_1 = obj->encrypt(word1);\\n\\t * int param_2 = obj->decrypt(word2);\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 1910319,
                "title": "c-solution-with-trick-making-it-easiest-hard-problem",
                "content": "\\n\\n```\\n class Encrypter {\\npublic:\\n    //For mappint character with its index\\n    map<char,int> keys_mp;\\n    \\n    //For storing values array\\n    vector<string> val;\\n    //Dictionary map to store reverse mapping of dictonary words and its encryption count.\\n    map<string, int> dict_mp;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++) keys_mp[keys[i]] = i;\\n        val = values;\\n        //Preparing map for encrypted dictionary word and its count\\n        for(string str: dictionary){\\n            dict_mp[encrypt(str)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1){\\n            ans += val[keys_mp[ch]];    \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if (dict_mp.find(word2) == dict_mp.end()) return 0;\\n        return dict_mp[word2];\\n    }\\n};\\n   \\n```",
                "solutionTags": [],
                "code": "```\\n class Encrypter {\\npublic:\\n    //For mappint character with its index\\n    map<char,int> keys_mp;\\n    \\n    //For storing values array\\n    vector<string> val;\\n    //Dictionary map to store reverse mapping of dictonary words and its encryption count.\\n    map<string, int> dict_mp;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i=0; i<keys.size(); i++) keys_mp[keys[i]] = i;\\n        val = values;\\n        //Preparing map for encrypted dictionary word and its count\\n        for(string str: dictionary){\\n            dict_mp[encrypt(str)]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(char ch: word1){\\n            ans += val[keys_mp[ch]];    \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        if (dict_mp.find(word2) == dict_mp.end()) return 0;\\n        return dict_mp[word2];\\n    }\\n};\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910089,
                "title": "map-c",
                "content": "```class Encrypter {\\npublic:\\n    map<string,int>dict;\\n    map<char,string>key;\\n    map<string,vector<char>>value;\\n    map<string,int>mp;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict.clear();\\n        key.clear();\\n        value.clear();\\n        for(auto &a:dictionary) dict[a]++;\\n        for(int i=0;i<keys.size();i++){\\n            key[keys[i]]=values[i];\\n            value[values[i]].push_back(keys[i]);\\n        }\\n        for(auto &a:dictionary){\\n            string ans=\"\";\\n            bool h=false;\\n            for(int i=0;i<a.size();i++){\\n                if(key.count(a[i])) ans+=key[a[i]];\\n                else h=true;\\n            }\\n            if(h) continue;\\n            mp[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(int i=0;i<word1.size();i++){\\n            if(key.count(word1[i])) ans+=key[word1[i]];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        if(!mp.count(word2)) return 0;\\n        return mp[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "solutionTags": [],
                "code": "```class Encrypter {\\npublic:\\n    map<string,int>dict;\\n    map<char,string>key;\\n    map<string,vector<char>>value;\\n    map<string,int>mp;\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        dict.clear();\\n        key.clear();\\n        value.clear();\\n        for(auto &a:dictionary) dict[a]++;\\n        for(int i=0;i<keys.size();i++){\\n            key[keys[i]]=values[i];\\n            value[values[i]].push_back(keys[i]);\\n        }\\n        for(auto &a:dictionary){\\n            string ans=\"\";\\n            bool h=false;\\n            for(int i=0;i<a.size();i++){\\n                if(key.count(a[i])) ans+=key[a[i]];\\n                else h=true;\\n            }\\n            if(h) continue;\\n            mp[ans]++;\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans=\"\";\\n        for(int i=0;i<word1.size();i++){\\n            if(key.count(word1[i])) ans+=key[word1[i]];\\n        }\\n        return ans;\\n    }\\n    int decrypt(string word2) {\\n        if(!mp.count(word2)) return 0;\\n        return mp[word2];\\n    }\\n};\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1910027,
                "title": "c-solution",
                "content": "\\tclass Encrypter {\\n    unordered_map<char, string> en;\\n    unordered_map<string, int> de;\\n\\n\\tpublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++)\\n            en[keys[i]] = values[i];\\n\\n        for(string s: dictionary)\\n            de[encrypt(s)]++;\\n    }\\n    \\n    string encrypt(string s) {\\n        string ans = \"\";\\n        \\n        for(char c: s)\\n            ans += en[c];\\n        \\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        return de[s];\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "\\tclass Encrypter {\\n    unordered_map<char, string> en;\\n    unordered_map<string, int> de;\\n\\n\\tpublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        for(int i = 0; i < keys.size(); i++)\\n            en[keys[i]] = values[i];\\n\\n        for(string s: dictionary)\\n            de[encrypt(s)]++;\\n    }\\n    \\n    string encrypt(string s) {\\n        string ans = \"\";\\n        \\n        for(char c: s)\\n            ans += en[c];\\n        \\n        return ans;\\n    }\\n    \\n    int decrypt(string s) {\\n        return de[s];\\n    }\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 1909945,
                "title": "c-encryption-hashmap-decryption-dfs-trie",
                "content": "**Prerequisite: TRIE**\\nEncrypting the string is straight forward, just store the string for each character in map and You are good to go. Also decryption of string is easy, the only difficult part is verifying the final string from the dictionary. \\n##### TLE for Set: \\nIf we use **set** to store and verify from dictionary, no doubt it will give the correct ans but using so will also increase our runtime. Because, before verifying we will 1st decrypt the whole string and after that we will verify from **Set**. By doing so we are doing redundent searches because its possible that the string doesn\\'t even exists in **set**. \\nSo, we need to find a way to decrypt the string word by word along with verification. Solution to this is Trie, as trie stores the string word by word and level by level.\\n#### Trie Solution:\\n1. Store each word of `dictionary` in trie\\n1. For decryption, use Trie along with DFS. \\n1. Take two character(given) at a time, find it\\'s decryption match from hashmap. Verify the if this character in the word exits in trie or not.\\n*  **Example**: We have a word in Trie, `word` = **\"abbccc\"**,(stored in trie like a->b->b->c->c->c) and we have formed the decrypted string till 3rd character like,`re` = **\"abb\"**. \\n*  Now suppose our next character after decryption is **\\'f\\'**, but **\\'f\\'** does exits in next sequence of characters in **trie**. So, we will stop our search here and **return** **0**. But if it matches, we will continue our search untill there are no more chararcter to decrypt. If we reach at the end of the string, check if the word exits, if it do, **return 1**.\\n\\nBelow is the Implementation.\\n```\\nclass trie {\\npublic:\\n    char c;\\n    int word; trie* arr[26];\\n    trie(char ch) {\\n        c= ch;\\n        word = 0;\\n        for(int i = 0; i<26;++i){\\n            arr[i]=NULL;\\n        }\\n    }\\n    \\n    void addWord(string s) {\\n        trie* temp = this;\\n        for(int i = 0; i<s.size();++i){\\n            if(temp->arr[s[i]-\\'a\\']!=NULL) temp = temp->arr[s[i]-\\'a\\'];\\n            else{\\n                trie* p = new trie(s[i]);\\n                temp->arr[s[i]-\\'a\\'] = p;\\n                temp=p;\\n            }\\n        }\\n        temp->word=1;\\n    }\\n};\\nclass Encrypter {\\n    map<char,string> mp;\\n    map<string,vector<char>> mp1;\\n    trie* root = NULL;\\n    \\n    int dfs(string &s,int in,trie* root){\\n        if(in>=s.size()) return root->word;\\n        string t = string(1,s[in])+string(1,s[in+1]);\\n        int ans = 0;\\n        vector<char>& temp = mp1[t];\\n        for(int i = 0; i<temp.size();++i){\\n            if(root->arr[temp[i]-\\'a\\']!=NULL){\\n                ans+= dfs(s,in+2,root->arr[temp[i]-\\'a\\']);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        root = new trie(\\'*\\');\\n        for(int i = 0; i<dictionary.size();++i) root->addWord(dictionary[i]);\\n        for(int i = 0; i<keys.size();++i) mp[keys[i]] = values[i];\\n        for(int i = 0; i<values.size();++i) mp1[values[i]].push_back(keys[i]);\\n    }\\n    \\n    string encrypt(string s) {\\n        string re;\\n        for(int i = 0; i<s.size();++i) re+=mp[s[i]];\\n        return re;\\n    }\\n    \\n    int decrypt(string s) {\\n       return dfs(s,0,root);\\n    }\\n};\\n```\\n**Upvote if it Helps**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nclass trie {\\npublic:\\n    char c;\\n    int word; trie* arr[26];\\n    trie(char ch) {\\n        c= ch;\\n        word = 0;\\n        for(int i = 0; i<26;++i){\\n            arr[i]=NULL;\\n        }\\n    }\\n    \\n    void addWord(string s) {\\n        trie* temp = this;\\n        for(int i = 0; i<s.size();++i){\\n            if(temp->arr[s[i]-\\'a\\']!=NULL) temp = temp->arr[s[i]-\\'a\\'];\\n            else{\\n                trie* p = new trie(s[i]);\\n                temp->arr[s[i]-\\'a\\'] = p;\\n                temp=p;\\n            }\\n        }\\n        temp->word=1;\\n    }\\n};\\nclass Encrypter {\\n    map<char,string> mp;\\n    map<string,vector<char>> mp1;\\n    trie* root = NULL;\\n    \\n    int dfs(string &s,int in,trie* root){\\n        if(in>=s.size()) return root->word;\\n        string t = string(1,s[in])+string(1,s[in+1]);\\n        int ans = 0;\\n        vector<char>& temp = mp1[t];\\n        for(int i = 0; i<temp.size();++i){\\n            if(root->arr[temp[i]-\\'a\\']!=NULL){\\n                ans+= dfs(s,in+2,root->arr[temp[i]-\\'a\\']);\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionary) {\\n        root = new trie(\\'*\\');\\n        for(int i = 0; i<dictionary.size();++i) root->addWord(dictionary[i]);\\n        for(int i = 0; i<keys.size();++i) mp[keys[i]] = values[i];\\n        for(int i = 0; i<values.size();++i) mp1[values[i]].push_back(keys[i]);\\n    }\\n    \\n    string encrypt(string s) {\\n        string re;\\n        for(int i = 0; i<s.size();++i) re+=mp[s[i]];\\n        return re;\\n    }\\n    \\n    int decrypt(string s) {\\n       return dfs(s,0,root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909917,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N * N), for decryption and O(N) for encryption***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, int> key;\\n    \\n    vector<string> value;\\n    \\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionarys) {\\n        \\n        for(int i = 0; i < keys.size(); i++)\\n        {\\n            key[keys[i]] = i;\\n        }\\n        \\n        value = values;\\n        \\n        dictionary = dictionarys;\\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        int n = word1.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            char c = word1[i];\\n            \\n            int idx = key[c];\\n            \\n            string str = value[idx];\\n            \\n            res += str;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        int res = 0;\\n        \\n        for(auto x : dictionary)\\n        {\\n            if(encrypt(x) == word2)\\n            {\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    unordered_map<char, int> key;\\n    \\n    vector<string> value;\\n    \\n    vector<string> dictionary;\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& dictionarys) {\\n        \\n        for(int i = 0; i < keys.size(); i++)\\n        {\\n            key[keys[i]] = i;\\n        }\\n        \\n        value = values;\\n        \\n        dictionary = dictionarys;\\n    }\\n    \\n    string encrypt(string word1) {\\n        \\n        int n = word1.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            char c = word1[i];\\n            \\n            int idx = key[c];\\n            \\n            string str = value[idx];\\n            \\n            res += str;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int decrypt(string word2) {\\n        \\n        int res = 0;\\n        \\n        for(auto x : dictionary)\\n        {\\n            if(encrypt(x) == word2)\\n            {\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909883,
                "title": "java-simple-code-using-hashmap-100-faster-with-explaination",
                "content": "**Time Complexity :-\\nEncrypter:- O(nlog(n))\\nencrypt:- O(mlog(n)) ; m-> length of provided String\\ndecrypt:- O(mlog(n))\\n\\n**\\n\\n**Explanation :-**\\nComming Soon\\n\\n**JAVA Code :-**\\n```\\nclass Encrypter {\\n    HashMap<Character,String> map1;\\n    HashMap<String,ArrayList<Character>> map2;\\n    HashMap<String,Integer> map3;\\n    public Encrypter(char[] keys, String[] values, String[] dict) {\\n        map1 = new HashMap<>();\\n        map2 = new HashMap<>();\\n        map3 = new HashMap<>();\\n        for(int i=0;i<keys.length;i++) {\\n            map1.put(keys[i],values[i]);\\n            if(map2.containsKey(values[i])) {\\n                ArrayList<Character> list = map2.get(values[i]);\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            } else {\\n                ArrayList<Character> list = new ArrayList<>();\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            }\\n        }\\n        for(String s : dict) {\\n            String cd = encrypt(s);\\n            if(map3.containsKey(cd)) {\\n                map3.put(cd,map3.get(cd)+1);\\n            } else {\\n                map3.put(cd,1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<word1.length();i++) {\\n            sb.append(map1.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int ct=0;\\n        for(String k : map3.keySet()) {\\n            if(k.compareTo(word2)==0) {\\n                ct+=map3.get(k);\\n            }\\n        }\\n        return ct;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Encrypter {\\n    HashMap<Character,String> map1;\\n    HashMap<String,ArrayList<Character>> map2;\\n    HashMap<String,Integer> map3;\\n    public Encrypter(char[] keys, String[] values, String[] dict) {\\n        map1 = new HashMap<>();\\n        map2 = new HashMap<>();\\n        map3 = new HashMap<>();\\n        for(int i=0;i<keys.length;i++) {\\n            map1.put(keys[i],values[i]);\\n            if(map2.containsKey(values[i])) {\\n                ArrayList<Character> list = map2.get(values[i]);\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            } else {\\n                ArrayList<Character> list = new ArrayList<>();\\n                list.add(keys[i]);\\n                map2.put(values[i],list);\\n            }\\n        }\\n        for(String s : dict) {\\n            String cd = encrypt(s);\\n            if(map3.containsKey(cd)) {\\n                map3.put(cd,map3.get(cd)+1);\\n            } else {\\n                map3.put(cd,1);\\n            }\\n        }\\n    }\\n    \\n    public String encrypt(String word1) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<word1.length();i++) {\\n            sb.append(map1.get(word1.charAt(i)));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int decrypt(String word2) {\\n        int ct=0;\\n        for(String k : map3.keySet()) {\\n            if(k.compareTo(word2)==0) {\\n                ct+=map3.get(k);\\n            }\\n        }\\n        return ct;\\n    }\\n}\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter obj = new Encrypter(keys, values, dictionary);\\n * String param_1 = obj.encrypt(word1);\\n * int param_2 = obj.decrypt(word2);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1909756,
                "title": "c-trie",
                "content": "```\\nclass Encrypter {\\npublic:\\n    string charmap[26];\\n    vector<char> rmap[26][26];\\n    \\n    struct trienode{\\n        char c;\\n        trienode* child[26];\\n        bool isend;\\n        \\n        trienode(char cc){\\n            c = cc;\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n        \\n        \\n        trienode(){\\n            c = \\'#\\';\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n    }*root;\\n    \\n    void insert(trienode* root,string word){\\n        trienode* travel = root;\\n        \\n        for(int i=0;i<word.size();i++){\\n            int c = word[i]-\\'a\\';\\n            if(!travel->child[c]){\\n                travel->child[c] = new trienode(word[i]);\\n            }\\n            travel = travel->child[c];\\n        }\\n        travel->isend = true;\\n    }\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& words) {\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                rmap[i][j].clear();\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            charmap[i] = \"\";\\n        }\\n        \\n        for(int i=0;i<keys.size();i++){\\n            charmap[keys[i]-\\'a\\'] = values[i];\\n            rmap[values[i][0]-\\'a\\'][values[i][1]-\\'a\\'].push_back(keys[i]);\\n        }\\n        \\n        root = new trienode(\\'$\\');\\n        for(auto word : words){\\n            insert(root,word);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c : word1){\\n            ans+=charmap[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(string &word,int idx,trienode* travel){\\n        int n = word.size();\\n        \\n        if(!travel)return 0;\\n        \\n        if(idx==n){\\n            return travel->isend;\\n        }\\n        \\n        if(rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\'].size()==0)return 0;\\n        \\n        int ans = 0;\\n        for(char c : rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\']){\\n            ans+=dfs(word,idx+2,travel->child[c-\\'a\\']);  \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dfs(word2,0,root);\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */``\\n```\\n\\n**TIme Complexity of Encrypt : o(no of chars in given word)\\nTime Complexity of Decrypt : O((no_of chars in given word/2) * size_of_dictionary)**\\n\\nSince we are using Trie, there lies atmost size of dictionary paths at the end of last recursion call and other would have been pruned.\\n\\nThe max depth of recursion tree is no_of_chars/2 and max paths is size_of_dictionary.\\nHence Complexity is O((no_of chars in given word/2) * size_of_dictionary).\\n\\n**Note: If you dont pass word by reference in Decrypt dfs function call you would get TLE**",
                "solutionTags": [
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Encrypter {\\npublic:\\n    string charmap[26];\\n    vector<char> rmap[26][26];\\n    \\n    struct trienode{\\n        char c;\\n        trienode* child[26];\\n        bool isend;\\n        \\n        trienode(char cc){\\n            c = cc;\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n        \\n        \\n        trienode(){\\n            c = \\'#\\';\\n            for(int i=0;i<26;i++){\\n                child[i] =nullptr;\\n            }\\n            isend =false;\\n        }\\n    }*root;\\n    \\n    void insert(trienode* root,string word){\\n        trienode* travel = root;\\n        \\n        for(int i=0;i<word.size();i++){\\n            int c = word[i]-\\'a\\';\\n            if(!travel->child[c]){\\n                travel->child[c] = new trienode(word[i]);\\n            }\\n            travel = travel->child[c];\\n        }\\n        travel->isend = true;\\n    }\\n    \\n    Encrypter(vector<char>& keys, vector<string>& values, vector<string>& words) {\\n        \\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                rmap[i][j].clear();\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            charmap[i] = \"\";\\n        }\\n        \\n        for(int i=0;i<keys.size();i++){\\n            charmap[keys[i]-\\'a\\'] = values[i];\\n            rmap[values[i][0]-\\'a\\'][values[i][1]-\\'a\\'].push_back(keys[i]);\\n        }\\n        \\n        root = new trienode(\\'$\\');\\n        for(auto word : words){\\n            insert(root,word);\\n        }\\n    }\\n    \\n    string encrypt(string word1) {\\n        string ans = \"\";\\n        for(auto c : word1){\\n            ans+=charmap[c-\\'a\\'];\\n        }\\n        return ans;\\n    }\\n    \\n    int dfs(string &word,int idx,trienode* travel){\\n        int n = word.size();\\n        \\n        if(!travel)return 0;\\n        \\n        if(idx==n){\\n            return travel->isend;\\n        }\\n        \\n        if(rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\'].size()==0)return 0;\\n        \\n        int ans = 0;\\n        for(char c : rmap[word[idx]-\\'a\\'][word[idx+1]-\\'a\\']){\\n            ans+=dfs(word,idx+2,travel->child[c-\\'a\\']);  \\n        }\\n        return ans;\\n    }\\n    \\n    int decrypt(string word2) {\\n        return dfs(word2,0,root);\\n    }\\n};\\n\\n\\n/**\\n * Your Encrypter object will be instantiated and called as such:\\n * Encrypter* obj = new Encrypter(keys, values, dictionary);\\n * string param_1 = obj->encrypt(word1);\\n * int param_2 = obj->decrypt(word2);\\n */``\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1834851,
                "content": [
                    {
                        "username": "matthewwdaly",
                        "content": "Testcases do not allow encrypting a word containing a letter not in the keys, even though we are specifically told to handle that edge case."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Think about storing dictionary in encrypted form."
                    }
                ]
            },
            {
                "id": 2043619,
                "content": [
                    {
                        "username": "matthewwdaly",
                        "content": "Testcases do not allow encrypting a word containing a letter not in the keys, even though we are specifically told to handle that edge case."
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Think about storing dictionary in encrypted form."
                    }
                ]
            }
        ]
    },
    {
        "title": " Check if There Is a Valid Parentheses String Path",
        "question_content": "<p>A parentheses string is a <strong>non-empty</strong> string consisting only of <code>&#39;(&#39;</code> and <code>&#39;)&#39;</code>. It is <strong>valid</strong> if <strong>any</strong> of the following conditions is <strong>true</strong>:</p>\n\n<ul>\n\t<li>It is <code>()</code>.</li>\n\t<li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid parentheses strings.</li>\n\t<li>It can be written as <code>(A)</code>, where <code>A</code> is a valid parentheses string.</li>\n</ul>\n\n<p>You are given an <code>m x n</code> matrix of parentheses <code>grid</code>. A <strong>valid parentheses string path</strong> in the grid is a path satisfying <strong>all</strong> of the following conditions:</p>\n\n<ul>\n\t<li>The path starts from the upper left cell <code>(0, 0)</code>.</li>\n\t<li>The path ends at the bottom-right cell <code>(m - 1, n - 1)</code>.</li>\n\t<li>The path only ever moves <strong>down</strong> or <strong>right</strong>.</li>\n\t<li>The resulting parentheses string formed by the path is <strong>valid</strong>.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if there exists a <strong>valid parentheses string path</strong> in the grid.</em> Otherwise, return <code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png\" style=\"width: 521px; height: 300px;\" />\n<pre>\n<strong>Input:</strong> grid = [[&quot;(&quot;,&quot;(&quot;,&quot;(&quot;],[&quot;)&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;,&quot;)&quot;]]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The above diagram shows two possible paths that form valid parentheses strings.\nThe first path shown results in the valid parentheses string &quot;()(())&quot;.\nThe second path shown results in the valid parentheses string &quot;((()))&quot;.\nNote that there may be other valid parentheses string paths.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png\" style=\"width: 165px; height: 165px;\" />\n<pre>\n<strong>Input:</strong> grid = [[&quot;)&quot;,&quot;)&quot;],[&quot;(&quot;,&quot;(&quot;]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The two possible paths form the parentheses strings &quot;))(&quot; and &quot;)((&quot;. Since neither of them are valid parentheses strings, we return false.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>grid[i][j]</code> is either <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2017937,
                "title": "simple-dfs-dp",
                "content": "This problem can be solved by simply applying a DFS from top of the grid to bottom and keeping a count of \\'(\\' and \\')\\' as k.\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int dp[100][100][205];\\n    bool solve(vector<vector<char>>& grid, int i, int j, int k)\\n    {\\n        if(i>=n || j>=m)\\n            return 0;\\n        \\n        if(grid[i][j]==\\'(\\')\\n            k++;\\n        else\\n            k--;\\n        \\n        if(k<0)\\n            return 0;\\n        \\n        if(i==n-1 && j==m-1)\\n            return (k==0);\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        return dp[i][j][k]=(solve(grid, i+1, j, k) | solve(grid, i, j+1, k));\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid)\\n    {\\n        n=grid.size();\\n        m=grid[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int dp[100][100][205];\\n    bool solve(vector<vector<char>>& grid, int i, int j, int k)\\n    {\\n        if(i>=n || j>=m)\\n            return 0;\\n        \\n        if(grid[i][j]==\\'(\\')\\n            k++;\\n        else\\n            k--;\\n        \\n        if(k<0)\\n            return 0;\\n        \\n        if(i==n-1 && j==m-1)\\n            return (k==0);\\n        \\n        if(dp[i][j][k]!=-1)\\n            return dp[i][j][k];\\n        \\n        return dp[i][j][k]=(solve(grid, i+1, j, k) | solve(grid, i, j+1, k));\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid)\\n    {\\n        n=grid.size();\\n        m=grid[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017740,
                "title": "dfs",
                "content": "We run normal DFS, going left and right.\\n- We track the balance `bal` to check if the path is valid.\\n- If `bal` goes negative - we prune: orphan \\')\\'.\\n- if `bal` exceeds `(m + n) / 2` - we prune: too many \\'(\\' to close.\\n- If we reach the bottom-right corner, and `bal` is zero - we found a valid path.\\n\\nWe need to use memoisation (`visited`) so we do not explore the same cell with the same balance - otherwise we\\'ll get TLE.\\n\\n**C++**\\n```cpp\\nint visited[100][100][101] = {};\\nbool hasValidPath(vector<vector<char>>& grid, int i = 0, int j = 0, int bal = 0) {\\n    int m = grid.size(), n = grid[0].size();\\n    bal += grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (bal < 0 || bal > (m + n) / 2 || visited[i][j][bal])\\n        return false;\\n    visited[i][j][bal] = true;\\n    if (i == m - 1 && j == n - 1 && bal == 0)\\n        return true;\\n    if (i < m - 1 && hasValidPath(grid, i + 1, j, bal))\\n        return true;\\n    if (j < n - 1 && hasValidPath(grid, i, j + 1, bal))\\n        return true;\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint visited[100][100][101] = {};\\nbool hasValidPath(vector<vector<char>>& grid, int i = 0, int j = 0, int bal = 0) {\\n    int m = grid.size(), n = grid[0].size();\\n    bal += grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (bal < 0 || bal > (m + n) / 2 || visited[i][j][bal])\\n        return false;\\n    visited[i][j][bal] = true;\\n    if (i == m - 1 && j == n - 1 && bal == 0)\\n        return true;\\n    if (i < m - 1 && hasValidPath(grid, i + 1, j, bal))\\n        return true;\\n    if (j < n - 1 && hasValidPath(grid, i, j + 1, bal))\\n        return true;\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2017872,
                "title": "java-c-python-dp-solution",
                "content": "# **Explanation**\\nFor each ceel `A[i][j]`\\nwe count the number of open parenthese for the path reaching `A[i][j]`.\\nIf it\\'s negative, it\\'s not valid already.\\nFinally we check if there is a path to `A[m-1][n-1]` that has no open parenthese,\\nthat means a valid parentheses string path reaching `A[m-1][n-1]`.\\n<br>\\n\\n# **Optimisation**\\nI usually don\\'t handle edge cases specially,\\nsince they can be correctly handled by itself.\\nAnd usually the short cut only improve edge case, not general case,\\n\\nHere are 3 quick fail case:\\nIf `(n + m) % 2 == 0`, the length of path to `A[m-1][n-1]` is odd, can return false.\\nIf `A[-1][-1] == \\'(\\'`, no valid start can return false.\\nIf `A[0][0] == \\')\\'`, no valid end, can return false.\\n<br>\\n\\n# **Complexity**\\nTime `O(mn(m+n))`\\nSpace `O(mn(m+n))`\\n<br>\\n\\n**Java**\\nEdited from @arignote solution.\\n\\nTrick 1: \\nA[i][j][0] for the path count -1,\\nA[i][j][1] for the path count 0, etc.\\nNo need to handle negative specially.\\n\\nTrick 2: \\nUse something like `A[i+1] += A[i]` instead of `A[i] = A[i-1]`\\nNo need to handle `i == 0` and `j == 0` specially.\\n\\nTrick 3: \\n`dp[m][n - 1]` and `dp[m - 1][n]` are from `dp[m - 1][n - 1]`,\\nreturn `dp[m][n - 1][1]` for the result.\\n\\n```java\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```\\n**C++**\\nEdited from @agrinote, explained above.\\n```cpp\\n    bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n```\\n\\n**Python**\\nUsing `set` are faster, since most path are not valid.\\n```py\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```\n```cpp\\n    bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n```\n```py\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2018503,
                "title": "c-extremely-fast-short-2-loops-dp",
                "content": "You can refer to other posts for basic 3D DP solution. Here I optimize the 3D DP with two tricks:\\n\\n* Early return if the length of path is odd\\n* Use `bitset` with each bit representing a possible number of open parenthesis. When we meet a new opening `\\'(\\'`, we should add one more open parenthesis to all previous memorized result. With `bitset` we simply left shift. Similarly, For `\\')\\'` we right shift.\\n\\n```\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    if ((m + n - 1) % 2) // early return for odd length path\\n        return false;\\n    vector<bitset<100>> dp(n + 1);\\n    for (int i = 0; i < m; i++) {\\n        dp[0][0] = !i;\\n        for (int j = 0; j < n; j++)\\n            dp[j + 1] = grid[i][j] == \\'(\\' ? (dp[j] | dp[j + 1]) << 1: (dp[j] | dp[j + 1]) >> 1;\\n    }\\n    return dp[n][0];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    int m = grid.size(), n = grid[0].size();\\n    if ((m + n - 1) % 2) // early return for odd length path\\n        return false;\\n    vector<bitset<100>> dp(n + 1);\\n    for (int i = 0; i < m; i++) {\\n        dp[0][0] = !i;\\n        for (int j = 0; j < n; j++)\\n            dp[j + 1] = grid[i][j] == \\'(\\' ? (dp[j] | dp[j + 1]) << 1: (dp[j] | dp[j + 1]) >> 1;\\n    }\\n    return dp[n][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018005,
                "title": "python-simple-memoisation-caching",
                "content": "There are two main parts of the solution:\\n1. Logic to determine whether a sequence is [Balanced Paranteses](https://leetcode.com/problems/valid-parentheses/). This can be achieved using `Stack`(`O(N) space`) or using a `counter` variable(`O(1) space`). I will be using the latter.\\n2. A recursive function to check the existence of a valid parantheses sequence in the input `grid`.\\n\\n\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:  \\n        m = len(grid)\\n        n = len(grid[0])\\n        @lru_cache(maxsize=None)\\n        def hasValidPathInner(x, y, cnt):\\n            # cnt variable would act as a counter to track \\n            # the balance of parantheses sequence\\n            if x == m or y == n or cnt < 0:\\n                return False\\n            \\n            # logic to check the balance of sequence\\n            cnt += 1 if grid[x][y] == \\'(\\' else -1\\n            \\n            # if balanced and end of grid, return True\\n            if x == m - 1 and y == n - 1 and not cnt:\\n                return True\\n            \\n            return hasValidPathInner(x + 1, y, cnt) or hasValidPathInner(x, y + 1, cnt)\\n\\n        return hasValidPathInner(0, 0, 0)\\n```\\n\\n**Time = O(mn(m+n))** - Due to memoization, the same path won\\'t be visited twice. `M + N` is the max length of a sequence or max depth of recursive stack from `0,0` to `m-1,n-1` in the `grid` \\n**Space = O(mn(m+n))**\\n\\n\\n----\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:  \\n        m = len(grid)\\n        n = len(grid[0])\\n        @lru_cache(maxsize=None)\\n        def hasValidPathInner(x, y, cnt):\\n            # cnt variable would act as a counter to track \\n            # the balance of parantheses sequence\\n            if x == m or y == n or cnt < 0:\\n                return False\\n            \\n            # logic to check the balance of sequence\\n            cnt += 1 if grid[x][y] == \\'(\\' else -1\\n            \\n            # if balanced and end of grid, return True\\n            if x == m - 1 and y == n - 1 and not cnt:\\n                return True\\n            \\n            return hasValidPathInner(x + 1, y, cnt) or hasValidPathInner(x, y + 1, cnt)\\n\\n        return hasValidPathInner(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018115,
                "title": "memoization",
                "content": "**if at any point open < 0 then the path is not balanced.**\\n\\n```\\nclass Solution {\\n    int m, n;\\n    int memo[101][101][201];\\npublic:\\n    bool doit(vector<vector<char>>& grid, int i, int j, int open) {\\n        \\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0)   return false;\\n        if (memo[i][j][open] != -1) return memo[i][j][open];\\n        if (i == m-1 and j == n-1 and open == 0)    return true;\\n        if (i < m-1 and doit(grid, i+1, j, open))   return memo[i][j][open] = true;\\n        if (j < n-1 and doit(grid, i, j+1, open))   return memo[i][j][open] = true;\\n        return memo[i][j][open] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        memset(memo, -1, sizeof memo);\\n        m = size(grid), n = size(grid[0]);\\n        if((m+n-1)&1) return false;\\n        return doit(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    int memo[101][101][201];\\npublic:\\n    bool doit(vector<vector<char>>& grid, int i, int j, int open) {\\n        \\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0)   return false;\\n        if (memo[i][j][open] != -1) return memo[i][j][open];\\n        if (i == m-1 and j == n-1 and open == 0)    return true;\\n        if (i < m-1 and doit(grid, i+1, j, open))   return memo[i][j][open] = true;\\n        if (j < n-1 and doit(grid, i, j+1, open))   return memo[i][j][open] = true;\\n        return memo[i][j][open] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        memset(memo, -1, sizeof memo);\\n        m = size(grid), n = size(grid[0]);\\n        if((m+n-1)&1) return false;\\n        return doit(grid, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017812,
                "title": "same-as-valid-parenthesis-string-but-with-memo-o-mn-m-n",
                "content": "**Intuition:** Same as checking valid parenthesis in a string. Need to maintain a counter \"open\" to mark the number of opening/closing braces encountered. If \\'(\\' is encountered incr. open by 1, else decrement open by 1. Now as there can be several paths possible from each cell in a grid, so there can be multiple repeated calculations done from each cell. To avoid that use DP/Memoisation.\\nDP array has 3 states: row, col, open count. Since open count can be maximum of 199(complete first row + complete last column), so taking 201.\\n\\n```\\nCode: \\nclass Solution {\\npublic:\\n    int dp[101][101][201];\\t\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp, -1, sizeof(dp));\\n        return isPossible(grid, 0, 0, 0);\\n    }\\n    \\n    bool isPossible(vector<vector<char>>& grid, int i, int j, int open) {\\n        if(i == grid.size() || j == grid[0].size())\\n            return false;\\n        if(grid[i][j] == \\')\\' && open == 0)\\n            return false;\\n        if(i == grid.size()-1 && j == grid[0].size()-1) \\n            return open+(grid[i][j] == \\'(\\' ? 1 : -1) == 0;\\n        if(dp[i][j][open] != -1)\\n            return dp[i][j][open];\\n        return dp[i][j][open] = isPossible(grid, i+1, j, open+(grid[i][j] == \\'(\\' ? 1 : -1)) ||  // down\\n                                isPossible(grid, i, j+1, open+(grid[i][j] == \\'(\\' ? 1 : -1));\\t// right\\n    }\\n};\\n```\\n\\nKindly upvote if helpful to keep me motivated ^-^. Also comment down for any doubts.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nCode: \\nclass Solution {\\npublic:\\n    int dp[101][101][201];\\t\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp, -1, sizeof(dp));\\n        return isPossible(grid, 0, 0, 0);\\n    }\\n    \\n    bool isPossible(vector<vector<char>>& grid, int i, int j, int open) {\\n        if(i == grid.size() || j == grid[0].size())\\n            return false;\\n        if(grid[i][j] == \\')\\' && open == 0)\\n            return false;\\n        if(i == grid.size()-1 && j == grid[0].size()-1) \\n            return open+(grid[i][j] == \\'(\\' ? 1 : -1) == 0;\\n        if(dp[i][j][open] != -1)\\n            return dp[i][j][open];\\n        return dp[i][j][open] = isPossible(grid, i+1, j, open+(grid[i][j] == \\'(\\' ? 1 : -1)) ||  // down\\n                                isPossible(grid, i, j+1, open+(grid[i][j] == \\'(\\' ? 1 : -1));\\t// right\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017824,
                "title": "java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    static Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        dp = new Boolean[101][101][201];  // [row][col][open-close]\\n        if(grid[0][0] == \\')\\'){   // cannot start with \\')\\'\\n            return false;\\n        }\\n        if(grid[m-1][n-1] == \\'(\\'){  // cannot end with \\'(\\' \\n            return false;\\n        }\\n        return solve(grid,0,0,m,n,0,0);\\n    }\\n    public static boolean solve(char[][] grid,int i,int j,int m,int n,int open,int close){\\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            close++;\\n        }\\n        if(close > open){  // at any point if closeBracket count exceeds openBracket count then return false since this path can never lead to valid paranthesis string\\n            return false;\\n        }\\n        if(i == m-1 && j == n-1){  // on reaching bottom right cell if openCount == closeCount return true else return false\\n            return open == close;\\n        }\\n        if(dp[i][j][open-close] != null){  // check for precomputed overlapping subproblem\\n            return dp[i][j][open-close];\\n        }\\n        if(i == m-1){   // make sure to not go out of the grid in last row\\n            return dp[i][j][open-close] = solve(grid,i,j+1,m,n,open,close);\\n        }\\n        if(j == n-1){  // make sure to not go out of the grid in last col\\n            return dp[i][j][open-close] = solve(grid,i+1,j,m,n,open,close);\\n        }\\n        boolean op = solve(grid,i+1,j,m,n,open,close) || solve(grid,i,j+1,m,n,open,close); // we have two choices to move forward, [i+1][j] or [i][j+1]\\n        return dp[i][j][open-close] = op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    static Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        dp = new Boolean[101][101][201];  // [row][col][open-close]\\n        if(grid[0][0] == \\')\\'){   // cannot start with \\')\\'\\n            return false;\\n        }\\n        if(grid[m-1][n-1] == \\'(\\'){  // cannot end with \\'(\\' \\n            return false;\\n        }\\n        return solve(grid,0,0,m,n,0,0);\\n    }\\n    public static boolean solve(char[][] grid,int i,int j,int m,int n,int open,int close){\\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            close++;\\n        }\\n        if(close > open){  // at any point if closeBracket count exceeds openBracket count then return false since this path can never lead to valid paranthesis string\\n            return false;\\n        }\\n        if(i == m-1 && j == n-1){  // on reaching bottom right cell if openCount == closeCount return true else return false\\n            return open == close;\\n        }\\n        if(dp[i][j][open-close] != null){  // check for precomputed overlapping subproblem\\n            return dp[i][j][open-close];\\n        }\\n        if(i == m-1){   // make sure to not go out of the grid in last row\\n            return dp[i][j][open-close] = solve(grid,i,j+1,m,n,open,close);\\n        }\\n        if(j == n-1){  // make sure to not go out of the grid in last col\\n            return dp[i][j][open-close] = solve(grid,i+1,j,m,n,open,close);\\n        }\\n        boolean op = solve(grid,i+1,j,m,n,open,close) || solve(grid,i,j+1,m,n,open,close); // we have two choices to move forward, [i+1][j] or [i][j+1]\\n        return dp[i][j][open-close] = op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017743,
                "title": "c-two-solution-bfs-and-dp-dp-and-memoization",
                "content": "**first bfs solution**\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        vector<pair<int,int>>d={{0,1},{1,0}};\\n        n=mat.size();\\n        m=mat[0].size();\\n        queue<tuple<int,int,int>>q;\\n        if(mat[0][0]==\\'(\\')\\n        {\\n        q.push({0,0,1});\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        int dp[111][111][311];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0][0][1]=1;\\n        while(q.size())\\n        {\\n            auto [x,y,b]=q.front();\\n            q.pop();\\n            if(b<0)\\n            {\\n                continue;\\n            }\\n            if(x==n-1&&y==m-1)\\n            {\\n                if(b==0)\\n                {\\n                    return true;\\n                }\\n            }\\n            for(auto it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(b<0)\\n                {\\n                    continue;\\n                }\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m&&dp[nx][ny][b]==-1)\\n                {\\n                    if(b>=0&&b<=n*m)\\n                    dp[nx][ny][b]=1;\\n                    if(mat[nx][ny]==\\'(\\')\\n                    {\\n                        q.push({nx,ny,b+1});\\n                    }\\n                    else\\n                    {\\n                        q.push({nx,ny,b-1});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n**second dp solution using memoization**\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[101][101][200];\\n    bool find(vector<vector<char>>& mat,int row,int col,int open)\\n    {\\n        if(row<0||col<0||row>=n||col>=m||open<0)\\n        {\\n            return false;\\n        }\\n        if(dp[row][col][open]!=-1)\\n        {\\n            return dp[row][col][open];\\n        }\\n        if(row==n-1&&col==m-1)\\n        {\\n            if(mat[row][col]==\\'(\\')\\n            {\\n                open++;\\n            }\\n            else \\n            {\\n                open--;\\n            }\\n            return open==0;\\n        }\\n        if(mat[row][col]==\\'(\\')\\n        {\\n            if(find(mat,row+1,col,open+1)||find(mat,row,col+1,open+1))\\n            {\\n                return true;\\n            }\\n        }\\n        else\\n        {\\n            if(find(mat,row+1,col,open-1)||find(mat,row,col+1,open-1))\\n            {\\n                return true;\\n            }\\n        }\\n        return dp[row][col][open]=false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=mat.size();\\n        m=mat[0].size();\\n        return find(mat,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        vector<pair<int,int>>d={{0,1},{1,0}};\\n        n=mat.size();\\n        m=mat[0].size();\\n        queue<tuple<int,int,int>>q;\\n        if(mat[0][0]==\\'(\\')\\n        {\\n        q.push({0,0,1});\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n        int dp[111][111][311];\\n        memset(dp,-1,sizeof(dp));\\n        dp[0][0][1]=1;\\n        while(q.size())\\n        {\\n            auto [x,y,b]=q.front();\\n            q.pop();\\n            if(b<0)\\n            {\\n                continue;\\n            }\\n            if(x==n-1&&y==m-1)\\n            {\\n                if(b==0)\\n                {\\n                    return true;\\n                }\\n            }\\n            for(auto it:d)\\n            {\\n                int nx=x+it.first;\\n                int ny=y+it.second;\\n                if(b<0)\\n                {\\n                    continue;\\n                }\\n                if(nx>=0&&ny>=0&&nx<n&&ny<m&&dp[nx][ny][b]==-1)\\n                {\\n                    if(b>=0&&b<=n*m)\\n                    dp[nx][ny][b]=1;\\n                    if(mat[nx][ny]==\\'(\\')\\n                    {\\n                        q.push({nx,ny,b+1});\\n                    }\\n                    else\\n                    {\\n                        q.push({nx,ny,b-1});\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[101][101][200];\\n    bool find(vector<vector<char>>& mat,int row,int col,int open)\\n    {\\n        if(row<0||col<0||row>=n||col>=m||open<0)\\n        {\\n            return false;\\n        }\\n        if(dp[row][col][open]!=-1)\\n        {\\n            return dp[row][col][open];\\n        }\\n        if(row==n-1&&col==m-1)\\n        {\\n            if(mat[row][col]==\\'(\\')\\n            {\\n                open++;\\n            }\\n            else \\n            {\\n                open--;\\n            }\\n            return open==0;\\n        }\\n        if(mat[row][col]==\\'(\\')\\n        {\\n            if(find(mat,row+1,col,open+1)||find(mat,row,col+1,open+1))\\n            {\\n                return true;\\n            }\\n        }\\n        else\\n        {\\n            if(find(mat,row+1,col,open-1)||find(mat,row,col+1,open-1))\\n            {\\n                return true;\\n            }\\n        }\\n        return dp[row][col][open]=false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& mat) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        n=mat.size();\\n        m=mat[0].size();\\n        return find(mat,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018172,
                "title": "dfs-memo",
                "content": "* If `g[i][j] == \\'(\\'` then o++ (increment openings)\\nelse o-- (decrement openings) \\n* At max brackets will be manhattan distance from last cell to 0th cell\\n\\t i.e., `r-1 + c-1 => r+c-2`\\n* Prune when `o>max or o<0`\\n```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        max = (r + c) - 2;\\n        dp = new Boolean[r + 1][c + 1][max + 1];\\n        return solve(0, 0, grid, 0);\\n    }\\n\\n    int max = 0;\\n    Boolean dp[][][];\\n\\n    private boolean solve(int i, int j, char g[][], int open) {\\n        if (i < 0 || j < 0 || i >= g.length || j >= g[0].length) return false;\\n        if (open < 0 || open > max) return false;\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n        if (i == g.length - 1 && j == g[0].length - 1) {\\n            if (g[i][j] == \\'(\\') open++; else open--;\\n            return open == 0;\\n        }\\n        if (g[i][j] == \\'(\\') return dp[i][j][open] = solve(i + 1, j, g, open + 1) || solve(i, j + 1, g, open + 1);\\n        return dp[i][j][open] = solve(i + 1, j, g, open - 1) || solve(i, j + 1, g, open - 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        max = (r + c) - 2;\\n        dp = new Boolean[r + 1][c + 1][max + 1];\\n        return solve(0, 0, grid, 0);\\n    }\\n\\n    int max = 0;\\n    Boolean dp[][][];\\n\\n    private boolean solve(int i, int j, char g[][], int open) {\\n        if (i < 0 || j < 0 || i >= g.length || j >= g[0].length) return false;\\n        if (open < 0 || open > max) return false;\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n        if (i == g.length - 1 && j == g[0].length - 1) {\\n            if (g[i][j] == \\'(\\') open++; else open--;\\n            return open == 0;\\n        }\\n        if (g[i][j] == \\'(\\') return dp[i][j][open] = solve(i + 1, j, g, open + 1) || solve(i, j + 1, g, open + 1);\\n        return dp[i][j][open] = solve(i + 1, j, g, open - 1) || solve(i, j + 1, g, open - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021277,
                "title": "6-short-lines-python-bitsets",
                "content": "Using ints as bitsets, where bit `i` being 1 means that we can reach the grid cell with `i` parentheses opened. Always take the union of the left cell\\'s and upper cell\\'s bitset, and shift it left or right depending on the cell\\'s parenthesis.\\n\\n**Solution 1, bottom-up DP**\\n\\nInstead of a 2D dp array, I just keep its latest row. \\n\\n    def hasValidPath(_, A):\\n        dp = [1] + [0] * 99\\n        for row in A:\\n            L = 0\\n            dp = [L := (lshift, rshift)[a == \\')\\'](L | U, 1)\\n                  for a, U in zip(row, dp)]\\n        return dp[-1] & 1\\n\\n**Solution 2, top-down with memoization**\\n\\n    def hasValidPath(_, A):\\n        @cache\\n        def dp(i, j):\\n            if i < 0 or j < 0:\\n                return i == 0\\n            return (lshift, rshift)[A[i][j] == \\')\\'](dp(i-1, j) | dp(i, j-1), 1)\\n        return dp(len(A)-1, len(A[0])-1) & 1",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "Using ints as bitsets, where bit `i` being 1 means that we can reach the grid cell with `i` parentheses opened. Always take the union of the left cell\\'s and upper cell\\'s bitset, and shift it left or right depending on the cell\\'s parenthesis.\\n\\n**Solution 1, bottom-up DP**\\n\\nInstead of a 2D dp array, I just keep its latest row. \\n\\n    def hasValidPath(_, A):\\n        dp = [1] + [0] * 99\\n        for row in A:\\n            L = 0\\n            dp = [L := (lshift, rshift)[a == \\')\\'](L | U, 1)\\n                  for a, U in zip(row, dp)]\\n        return dp[-1] & 1\\n\\n**Solution 2, top-down with memoization**\\n\\n    def hasValidPath(_, A):\\n        @cache\\n        def dp(i, j):\\n            if i < 0 or j < 0:\\n                return i == 0\\n            return (lshift, rshift)[A[i][j] == \\')\\'](dp(i-1, j) | dp(i, j-1), 1)\\n        return dp(len(A)-1, len(A[0])-1) & 1",
                "codeTag": "Python3"
            },
            {
                "id": 2018906,
                "title": "c-simple-bfs-dp-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        queue<tuple<int,int,int>> q;\\n        int visited[100][100][101] = {};\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        if(grid[0][0]==\\'(\\') q.push({0,0,1});\\n        else return false;\\n        \\n        while(!q.empty()){\\n            \\n            auto [Nx,Ny,b]=q.front();\\n            q.pop();\\n            \\n            if(b<0 or b>(row+col)/2 or visited[Nx][Ny][b]) continue;\\n            visited[Nx][Ny][b] = true;\\n\\n            if(Nx==row-1 and Ny==col-1 and b==0) return true;\\n            \\n            if(Nx+1<row){\\n                if(grid[Nx+1][Ny]==\\'(\\') q.push({Nx+1,Ny,b+1});\\n                else q.push({Nx+1,Ny,b-1});\\n            }\\n            if(Ny+1<col){\\n                if(grid[Nx][Ny+1]==\\'(\\') q.push({Nx,Ny+1,b+1});\\n                else q.push({Nx,Ny+1,b-1});\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        queue<tuple<int,int,int>> q;\\n        int visited[100][100][101] = {};\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        if(grid[0][0]==\\'(\\') q.push({0,0,1});\\n        else return false;\\n        \\n        while(!q.empty()){\\n            \\n            auto [Nx,Ny,b]=q.front();\\n            q.pop();\\n            \\n            if(b<0 or b>(row+col)/2 or visited[Nx][Ny][b]) continue;\\n            visited[Nx][Ny][b] = true;\\n\\n            if(Nx==row-1 and Ny==col-1 and b==0) return true;\\n            \\n            if(Nx+1<row){\\n                if(grid[Nx+1][Ny]==\\'(\\') q.push({Nx+1,Ny,b+1});\\n                else q.push({Nx+1,Ny,b-1});\\n            }\\n            if(Ny+1<col){\\n                if(grid[Nx][Ny+1]==\\'(\\') q.push({Nx,Ny+1,b+1});\\n                else q.push({Nx,Ny+1,b-1});\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018305,
                "title": "java-dfs-memoization-easy-to-understand",
                "content": "```\\nclass Solution {\\n    boolean[][][] vis = new boolean[100][100][101];\\n    boolean isValid(char[][] grid, int i, int j, int count){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        count += grid[i][j]==\\'(\\' ? 1 : -1;\\n        if(count < 0 || count > (n+m)/2 || vis[i][j][count]) return false;\\n        vis[i][j][count] = true;\\n\\t\\t\\n        if(count==0 && i==n-1 &&  j==m-1) return true;\\n        if(i < n-1 && isValid(grid,i+1,j,count)) return true;\\n        if(j < m-1 && isValid(grid,i,j+1,count)) return true;\\n        return false;\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        return isValid(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][][] vis = new boolean[100][100][101];\\n    boolean isValid(char[][] grid, int i, int j, int count){\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        count += grid[i][j]==\\'(\\' ? 1 : -1;\\n        if(count < 0 || count > (n+m)/2 || vis[i][j][count]) return false;\\n        vis[i][j][count] = true;\\n\\t\\t\\n        if(count==0 && i==n-1 &&  j==m-1) return true;\\n        if(i < n-1 && isValid(grid,i+1,j,count)) return true;\\n        if(j < m-1 && isValid(grid,i,j+1,count)) return true;\\n        return false;\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        return isValid(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018132,
                "title": "python3-short-dp-6-lines-explained",
                "content": "### Explanation:\\n* `k` denotes the running sum of the parentheses. For each `(`, add +1 for each `)` add -1\\n* At any point `k` should not be less than 0 else valid parentheses beyond that point is not possible\\n*  If `(A[i][j] == \\')\\' and k < 1)` k will become < 0 when we perform k - 1, so we return `False`\\n*  `if i == m - 1 and j == n - 1: return A[i][j] == \\')\\' and k == 1` If we are on the last cell return `True` if last cell contains `)` and `k == 1`. `k - 1` will be `= 0` which will mean parentheses are balanced. For every other case on last cell, we return `False` \\n*  The `any()` function returns True if any item in an iterable are true, otherwise it returns False.\\n\\n```\\ndef hasValidPath(self, A: List[List[str]]) -> bool:\\n\\t@cache\\n\\tdef dfs(i, j, k):\\n\\t\\tif i >= len(A) or j >= len(A[0]) or (A[i][j] == \\')\\' and k < 1): return False\\n\\t\\tif i == len(A) - 1 and j == len(A[0]) - 1: return A[i][j] == \\')\\' and k == 1\\n\\t\\treturn any(dfs(i + x, j + y, k + (1 if A[i][j] == \\'(\\' else -1)) for x, y in [[0, 1], [1, 0]])\\n\\treturn dfs(0, 0, 0)\\n```\\nTime complexity: O(mn(m+n))",
                "solutionTags": [],
                "code": "```\\ndef hasValidPath(self, A: List[List[str]]) -> bool:\\n\\t@cache\\n\\tdef dfs(i, j, k):\\n\\t\\tif i >= len(A) or j >= len(A[0]) or (A[i][j] == \\')\\' and k < 1): return False\\n\\t\\tif i == len(A) - 1 and j == len(A[0]) - 1: return A[i][j] == \\')\\' and k == 1\\n\\t\\treturn any(dfs(i + x, j + y, k + (1 if A[i][j] == \\'(\\' else -1)) for x, y in [[0, 1], [1, 0]])\\n\\treturn dfs(0, 0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2017796,
                "title": "simple-top-down-code",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if(grid[0][0]==\")\"):return False\\n        @lru_cache(None)\\n        def fun(s,i,j):\\n            if(s<0):return False\\n            if(i==(len(grid)-1) and j==(len(grid[0])-1)):return s==0\\n            if(i+1<len(grid)):\\n                if(grid[i+1][j]==\")\"):\\n                    if(fun(s-1,i+1,j)):return True\\n                if(grid[i+1][j]==\"(\"):\\n                    if(fun(s+1,i+1,j)):return True\\n            if(j+1<len(grid[0])):\\n                if(grid[i][j+1]==\")\"):\\n                    if(fun(s-1,i,j+1)):return True\\n                if(grid[i][j+1]==\"(\"):\\n                    if(fun(s+1,i,j+1)):return True\\n            return False\\n        return fun(1,0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if(grid[0][0]==\")\"):return False\\n        @lru_cache(None)\\n        def fun(s,i,j):\\n            if(s<0):return False\\n            if(i==(len(grid)-1) and j==(len(grid[0])-1)):return s==0\\n            if(i+1<len(grid)):\\n                if(grid[i+1][j]==\")\"):\\n                    if(fun(s-1,i+1,j)):return True\\n                if(grid[i+1][j]==\"(\"):\\n                    if(fun(s+1,i+1,j)):return True\\n            if(j+1<len(grid[0])):\\n                if(grid[i][j+1]==\")\"):\\n                    if(fun(s-1,i,j+1)):return True\\n                if(grid[i][j+1]==\"(\"):\\n                    if(fun(s+1,i,j+1)):return True\\n            return False\\n        return fun(1,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020278,
                "title": "c-bottom-up-dp-solution-faster-than-100-o-mn-m-n-64",
                "content": "The solution uses a similar idea to all the other current solutions. Since int_128 seems to be unavailable, we can simply use a bitset to achieve O(mn(m+n) / 64) time complexity.\\n\\nIdea:\\nWe know from valid parantheses question all we need to do is maintain the number of left brackets. Here, `dp[i][j][k]` represents whether there is a valid way of reaching i, j with k left brackets remaining. The bit operations here just help speedup the solution but the logic is similar to all other DP solutions.\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<vector<bitset<101>>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        dp.assign(r, vector<bitset<101>>(c, bitset<101>()));\\n        \\n        if (grid[0][0] == \\'(\\') dp[0][0][1] = 1;\\n        else return false;\\n        \\n        for (int i = 1; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[i][0] = (dp[i-1][0] << 1);\\n            else dp[i][0] = (dp[i-1][0] >> 1);\\n        }\\n        \\n        for (int j = 1; j < c; j++) {\\n            if (grid[0][j] == \\'(\\') dp[0][j] = (dp[0][j-1] << 1);\\n            else dp[0][j] = (dp[0][j-1] >> 1);\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = dp[i-1][j] | dp[i][j-1];\\n                if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n                else dp[i][j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[r-1][c-1][0];\\n    }\\n};\\n```\\n\\nFurther optimization: we can simply compress it to a vector of bitsets instead :)\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<bitset<101>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        if (grid[0][0] != \\'(\\') return false;\\n        dp.assign(c, bitset<101>()); dp[0][0] = 1;\\n        \\n        for (int i = 0; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[0] <<= 1;\\n            else dp[0] >>= 1;\\n            for (int j = 1; j < c; j++) {\\n                dp[j] |= dp[j-1];\\n                if (grid[i][j] == \\'(\\') dp[j] <<= 1;\\n                else dp[j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[c-1][0];\\n    }\\n};\\n```\\n\\nDo upvote if you think the solution helped you! And do leave any questions below :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<vector<bitset<101>>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        dp.assign(r, vector<bitset<101>>(c, bitset<101>()));\\n        \\n        if (grid[0][0] == \\'(\\') dp[0][0][1] = 1;\\n        else return false;\\n        \\n        for (int i = 1; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[i][0] = (dp[i-1][0] << 1);\\n            else dp[i][0] = (dp[i-1][0] >> 1);\\n        }\\n        \\n        for (int j = 1; j < c; j++) {\\n            if (grid[0][j] == \\'(\\') dp[0][j] = (dp[0][j-1] << 1);\\n            else dp[0][j] = (dp[0][j-1] >> 1);\\n        }\\n        \\n        for (int i = 1; i < r; i++) {\\n            for (int j = 1; j < c; j++) {\\n                dp[i][j] = dp[i-1][j] | dp[i][j-1];\\n                if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n                else dp[i][j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[r-1][c-1][0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector<bitset<101>> dp;\\n        int r = grid.size(), c = grid[0].size();\\n        if (grid[0][0] != \\'(\\') return false;\\n        dp.assign(c, bitset<101>()); dp[0][0] = 1;\\n        \\n        for (int i = 0; i < r; i++) {\\n            if (grid[i][0] == \\'(\\') dp[0] <<= 1;\\n            else dp[0] >>= 1;\\n            for (int j = 1; j < c; j++) {\\n                dp[j] |= dp[j-1];\\n                if (grid[i][j] == \\'(\\') dp[j] <<= 1;\\n                else dp[j] >>= 1;\\n            }\\n        }\\n        \\n        return dp[c-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017789,
                "title": "python3-dfs-iterative",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\':\\n            return False\\n        \\n        m, n = len(grid), len(grid[0])\\n        DIRS = [[0,1],[1,0]]\\n        \\n        stack = []\\n        \\n        # bal for tracking parenthesis balance\\n        bal = 1\\n        stack.append([0, 0, bal])\\n        seen = set()\\n        seen.add((0, 0, bal))\\n        while stack:\\n            x, y, curr_bal = stack.pop()\\n            if x == m - 1 and y == n - 1 and curr_bal == 0:\\n                return True\\n            curr = grid[x][y]\\n            for d in DIRS:\\n                r = x + d[0]\\n                c = y + d[1]\\n                if 0<=r<m and 0<=c<n:\\n                    if (r,c,curr_bal) not in seen:\\n                        seen.add((r,c,curr_bal))\\n                        next_p = grid[r][c]\\n                        if next_p == \"(\":\\n                            curr_bal += 1\\n                            stack.append([r, c, curr_bal])\\n                            curr_bal -= 1\\n                        else:\\n                            if curr_bal > 0:\\n                                curr_bal -= 1\\n                                stack.append([r, c, curr_bal])\\n                                curr_bal += 1\\n        return False\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\':\\n            return False\\n        \\n        m, n = len(grid), len(grid[0])\\n        DIRS = [[0,1],[1,0]]\\n        \\n        stack = []\\n        \\n        # bal for tracking parenthesis balance\\n        bal = 1\\n        stack.append([0, 0, bal])\\n        seen = set()\\n        seen.add((0, 0, bal))\\n        while stack:\\n            x, y, curr_bal = stack.pop()\\n            if x == m - 1 and y == n - 1 and curr_bal == 0:\\n                return True\\n            curr = grid[x][y]\\n            for d in DIRS:\\n                r = x + d[0]\\n                c = y + d[1]\\n                if 0<=r<m and 0<=c<n:\\n                    if (r,c,curr_bal) not in seen:\\n                        seen.add((r,c,curr_bal))\\n                        next_p = grid[r][c]\\n                        if next_p == \"(\":\\n                            curr_bal += 1\\n                            stack.append([r, c, curr_bal])\\n                            curr_bal -= 1\\n                        else:\\n                            if curr_bal > 0:\\n                                curr_bal -= 1\\n                                stack.append([r, c, curr_bal])\\n                                curr_bal += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017723,
                "title": "3d-dp-simple-intuition",
                "content": "**Approach :-**\\n\\nWe try to find a path such that there will be always opening bracket >= closing bracket and finally at the end opening bracket == closing bracket. We use third changing variable as the opening bracket + closing bracket and hence we can solve this using 3D DP.\\n\\n```\\nCode:\\n\\nclass Solution {\\npublic:\\n    bool isSafe(int i,int j,int m,int n){\\n        return i >= 0 and i < m and j >= 0 and j < n;\\n    }\\n    bool solve(vector<vector<char>>& grid,int i,int j,int curr,vector<vector<vector<int>>>&dp){\\n        if(curr < 0) return false;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i == m-1 and j == n-1){\\n            if(grid[i][j] == \\'(\\'){\\n                curr += 1;\\n            }else{\\n                curr -= 1;\\n            }\\n            if(curr == 0) return true;\\n            return false;\\n        }\\n        if(dp[i][j][curr] != -1) return dp[i][j][curr];\\n        int temp;\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\'){\\n            temp = 1;\\n        }else{\\n            temp = -1;\\n        }\\n        \\n        if(isSafe(i+1,j,m,n)){\\n            ans |= solve(grid,i+1,j,curr+temp,dp);\\n        }\\n        if(isSafe(i,j+1,m,n)){\\n            ans |= solve(grid,i,j+1,curr+temp,dp);\\n        }\\n        return dp[i][j][curr] = ans;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(201,-1)));\\n        return solve(grid,0,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nCode:\\n\\nclass Solution {\\npublic:\\n    bool isSafe(int i,int j,int m,int n){\\n        return i >= 0 and i < m and j >= 0 and j < n;\\n    }\\n    bool solve(vector<vector<char>>& grid,int i,int j,int curr,vector<vector<vector<int>>>&dp){\\n        if(curr < 0) return false;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if(i == m-1 and j == n-1){\\n            if(grid[i][j] == \\'(\\'){\\n                curr += 1;\\n            }else{\\n                curr -= 1;\\n            }\\n            if(curr == 0) return true;\\n            return false;\\n        }\\n        if(dp[i][j][curr] != -1) return dp[i][j][curr];\\n        int temp;\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\'){\\n            temp = 1;\\n        }else{\\n            temp = -1;\\n        }\\n        \\n        if(isSafe(i+1,j,m,n)){\\n            ans |= solve(grid,i+1,j,curr+temp,dp);\\n        }\\n        if(isSafe(i,j+1,m,n)){\\n            ans |= solve(grid,i,j+1,curr+temp,dp);\\n        }\\n        return dp[i][j][curr] = ans;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(201,-1)));\\n        return solve(grid,0,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389353,
                "title": "c-simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n, m;\\n    bool dfs(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n            if(open == 0)\\n                return true;\\n            return false;\\n        }\\n        bool val = dfs(x+1, y, open, grid, dp) || dfs(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = val;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return dfs(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    bool dfs(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n            if(open == 0)\\n                return true;\\n            return false;\\n        }\\n        bool val = dfs(x+1, y, open, grid, dp) || dfs(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = val;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return dfs(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034492,
                "title": "3d-dp-intuitive-easy-to-understand",
                "content": "**Key Points** - We have to take care of the open parenthesis we are left with till now in our path.\\nSo, for any given indeces i and j we can have atmost n+m open braces i.e, the sum of the matrix dimensions. Whenever we calculate our answer for a given combination of \\'i\\' , \\'j\\' and \\'open\\' (open stands for unclosed brackets we have till now), we store that answer in the dp array.\\n\\nNote :- pls refer the code for more clarity\\n\\n\\n```class Solution {\\npublic:\\n    int t[101][101][201];                              //Dp array \\n    bool helper(vector<vector<char>>& grid,int open,int i,int j)\\n    {\\n        if(i>=grid.size() || j>=grid[0].size())   //Base Case  - out of bound\\n            return false;\\n        \\n        \\n        if(i==grid.size()-1 && j==grid[0].size()-1) // reached the n-1,m-1 cell\\n            {\\n                if(open==1 && grid[i][j]==\\')\\')   // true only if last element is \\'{\\' and number of open brackets left if 1 \\n                    return t[i][j][open]=true;  \\n                else\\n                    return t[i][j][open]=false;      // false otherwise\\n            }\\n        \\n        if(t[i][j][open]!=-1)   // if calculated previously \\n            return t[i][j][open];\\n        \\n        if(grid[i][j]==\\'(\\')  // if we encounter an open bracket\\n        {\\n            return  t[i][j][open]=helper(grid,open+1,i+1,j) || helper(grid,open+1,i,j+1);  // moving down and right\\n        }\\n        else     // if we encounter an open bracket\\n        {\\n            if(open<=0)                          //when closing bracket is encountered without any previous open bracket\\n                return t[i][j][open]=false;\\n                                                                                   // open count will decrease when closed bracket is encountered\\n                return t[i][j][open]=helper(grid,open-1,i+1,j) || helper(grid,open-1,i,j+1);   // moving down and right\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(t,-1,sizeof(t));               // intializing the dp array\\n        return helper(grid,0,0,0);           // initially  i=0 , j=0 i.e; starting point and open is also 0\\n    }\\n};```\\n\\nDo upvote if you found this to be helpful \\uD83D\\uDE0A\\uD83D\\uDE0A.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```class Solution {\\npublic:\\n    int t[101][101][201];                              //Dp array \\n    bool helper(vector<vector<char>>& grid,int open,int i,int j)\\n    {\\n        if(i>=grid.size() || j>=grid[0].size())   //Base Case  - out of bound\\n            return false;\\n        \\n        \\n        if(i==grid.size()-1 && j==grid[0].size()-1) // reached the n-1,m-1 cell\\n            {\\n                if(open==1 && grid[i][j]==\\')\\')   // true only if last element is \\'{\\' and number of open brackets left if 1 \\n                    return t[i][j][open]=true;  \\n                else\\n                    return t[i][j][open]=false;      // false otherwise\\n            }\\n        \\n        if(t[i][j][open]!=-1)   // if calculated previously \\n            return t[i][j][open];\\n        \\n        if(grid[i][j]==\\'(\\')  // if we encounter an open bracket\\n        {\\n            return  t[i][j][open]=helper(grid,open+1,i+1,j) || helper(grid,open+1,i,j+1);  // moving down and right\\n        }\\n        else     // if we encounter an open bracket\\n        {\\n            if(open<=0)                          //when closing bracket is encountered without any previous open bracket\\n                return t[i][j][open]=false;\\n                                                                                   // open count will decrease when closed bracket is encountered\\n                return t[i][j][open]=helper(grid,open-1,i+1,j) || helper(grid,open-1,i,j+1);   // moving down and right\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(t,-1,sizeof(t));               // intializing the dp array\\n        return helper(grid,0,0,0);           // initially  i=0 , j=0 i.e; starting point and open is also 0\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2020540,
                "title": "simple-dp-solution-with-c-bitset",
                "content": "At dp[i][j] we count how many excess open parenthesis we have till ```i,j``` (>= 0, negative means that particular path can be ignored from now on).  Now, at ```i,j``` if it\\'s open, we increase all counts by 1 (i.e left-shift) otherwise decrease all counts by 1.  \\nC++ bitset<201> can simulate this directly. increase can be left-shift etc.\\n```\\ntypedef bitset<201> sp;\\ntypedef vector<sp> vsp;\\ntypedef vector<vsp> vvsp;\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvsp dp = vvsp(m, vsp(n, sp()));\\n        dp[0][0] = grid[0][0] == \\'(\\';\\n        for (int i=0;i<m;++i) for (int j=0;j<n;++j) {\\n            dp[i][j] = dp[i][j] | (j ? dp[i][j-1] : 0) | (i ? dp[i-1][j] : 0 );\\n            if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n            else dp[i][j] >>= 1;\\n        }\\n        return dp.back().back().test(0) > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```i,j```\n```i,j```\n```\\ntypedef bitset<201> sp;\\ntypedef vector<sp> vsp;\\ntypedef vector<vsp> vvsp;\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvsp dp = vvsp(m, vsp(n, sp()));\\n        dp[0][0] = grid[0][0] == \\'(\\';\\n        for (int i=0;i<m;++i) for (int j=0;j<n;++j) {\\n            dp[i][j] = dp[i][j] | (j ? dp[i][j-1] : 0) | (i ? dp[i-1][j] : 0 );\\n            if (grid[i][j] == \\'(\\') dp[i][j] <<= 1;\\n            else dp[i][j] >>= 1;\\n        }\\n        return dp.back().back().test(0) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019994,
                "title": "fully-explained-recursion-memoization-cpp",
                "content": "we can solve this question easily by taking \\'(\\' as +1 and \\')\\' as -1.Now start adding the cell values in right or down direction and if sum is negative that means it cant be a valid path as it can not be balanced at any condition.\\nNow do a recursion and check if we have already visited this node with th current sum, if yes then return the memoized value otherwise go to the right and down and return OR of both paths.\\nBase condition: if we will reach at the bottom right cell then sum should be 0 for a correct path otherwise the paranthesis must be unbalanced.\\n\\nPFB my code for your reference:)\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int n,int m,int score,vector<vector<int>>& g,vector<vector<vector<int>>>& dp){\\n        if(i>=n || j>=m) return false;\\n        score+=g[i][j];\\n        if(i==n-1 && j==m-1) return score==0;\\n        if(score<0) return false;\\n        if(dp[i][j][score] != -1) return dp[i][j][score];\\n        return dp[i][j][score]=dfs(i+1,j,n,m,score,g,dp) || dfs(i,j+1,n,m,score,g,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)&1) return false;\\n        vector<vector<int>> g(n,vector<int>(m,-1));\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(n+m+5,-1)));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==\\'(\\') g[i][j]=1;\\n        return dfs(0,0,n,m,0,g,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,int n,int m,int score,vector<vector<int>>& g,vector<vector<vector<int>>>& dp){\\n        if(i>=n || j>=m) return false;\\n        score+=g[i][j];\\n        if(i==n-1 && j==m-1) return score==0;\\n        if(score<0) return false;\\n        if(dp[i][j][score] != -1) return dp[i][j][score];\\n        return dp[i][j][score]=dfs(i+1,j,n,m,score,g,dp) || dfs(i,j+1,n,m,score,g,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)&1) return false;\\n        vector<vector<int>> g(n,vector<int>(m,-1));\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m,vector<int>(n+m+5,-1)));\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid[i][j]==\\'(\\') g[i][j]=1;\\n        return dfs(0,0,n,m,0,g,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019857,
                "title": "c-solution-with-visitedflag-array",
                "content": "\\tpublic class Solution {\\n\\n\\t\\tprivate bool[,,] _visited;\\n\\t\\tprivate int _rowLength;\\n\\t\\tprivate int _colLength;\\n\\t\\tprivate int _midLength;\\n\\t\\tprivate char[][] _grid;\\n\\n\\t\\tpublic bool ValidPath(int row, int col,int bal){\\n\\t\\t\\tbal += _grid[row][col]==\\'(\\'?1:-1;\\n\\t\\t\\tif(bal < 0 || bal > _midLength || _visited[row,col,bal])\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t_visited[row,col,bal]=true;\\n\\t\\t\\tif(row == _rowLength-1 && col == _colLength-1){\\n\\t\\t\\t\\tif(bal == 0)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(row<_rowLength-1 && ValidPath(row+1,col,bal))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif(col<_colLength-1 && ValidPath(row,col+1,bal))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic bool HasValidPath(char[][] grid) {\\n\\t\\t\\t_rowLength = grid.Length;\\n\\t\\t\\t_colLength = grid[0].Length;\\n\\t\\t\\t_midLength = (_rowLength+_colLength)/2;\\n\\t\\t\\t_visited = new bool[_rowLength,_colLength,_midLength+1];\\n\\t\\t\\t_grid = grid;\\n\\n\\t\\t\\treturn ValidPath(0,0,0);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\t\\tprivate bool[,,] _visited;\\n\\t\\tprivate int _rowLength;\\n\\t\\tprivate int _colLength;\\n\\t\\tprivate int _midLength;\\n\\t\\tprivate char[][] _grid;\\n\\n\\t\\tpublic bool ValidPath(int row, int col,int bal){\\n\\t\\t\\tbal += _grid[row][col]==\\'(\\'?1:-1;\\n\\t\\t\\tif(bal < 0 || bal > _midLength || _visited[row,col,bal])\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t_visited[row,col,bal]=true;\\n\\t\\t\\tif(row == _rowLength-1 && col == _colLength-1){\\n\\t\\t\\t\\tif(bal == 0)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2019037,
                "title": "c-solution-dfs-3d-dp-memoization",
                "content": "The approach is based on simple dfs on the given matrix. We start from the very first cell `matrix[0][0]` and consider both the two choices to go right or down from the current cell. On the fly we track the balancing of the parenthesis by taking a variable (Here `s`) and adding one to it if we encounter an opening `\\'(\\'` parentheses and subtracting one from it if we encounter a closing parenthesis `\\')\\'`. \\n\\nOn reaching the last cell i.e., `matrix[n - 1][m - 1]` we check if `s` becomes equal to zero, we found a valid parenthesis string path.\\n\\n```\\nclass Solution {\\npublic:\\n    bool ff(vector<vector<vector<int>>> &dp, int i, int j, int n, int m, int s, vector<vector<char>> &a)\\n    {\\n        if(i == n || j == m || s < 0) return false;\\n        if(i == n - 1 && j == m - 1) \\n        {\\n            int sum = (a[i][j] == \\'(\\' ? s + 1 : s - 1);\\n            return (sum == 0);\\n        }\\n        if(dp[i][j][s] != -1) return dp[i][j][s];\\n        // Go Down\\n        if(ff(dp, i + 1, j, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        // Go Right\\n        if(ff(dp, i, j + 1, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        return dp[i][j][s] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& a) \\n    {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (n + m + 2, -1)));\\n        return ff(dp, 0, 0, n, m, 0, a);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ff(vector<vector<vector<int>>> &dp, int i, int j, int n, int m, int s, vector<vector<char>> &a)\\n    {\\n        if(i == n || j == m || s < 0) return false;\\n        if(i == n - 1 && j == m - 1) \\n        {\\n            int sum = (a[i][j] == \\'(\\' ? s + 1 : s - 1);\\n            return (sum == 0);\\n        }\\n        if(dp[i][j][s] != -1) return dp[i][j][s];\\n        // Go Down\\n        if(ff(dp, i + 1, j, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        // Go Right\\n        if(ff(dp, i, j + 1, n, m, ((a[i][j] == \\'(\\') ? s + 1 : s - 1), a)) return dp[i][j][s] = true;\\n        return dp[i][j][s] = false;\\n    }\\n    bool hasValidPath(vector<vector<char>>& a) \\n    {\\n        int n = a.size(), m = a[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (n + m + 2, -1)));\\n        return ff(dp, 0, 0, n, m, 0, a);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018216,
                "title": "python-3-pruned-bfs-with-memo-counting-brackets",
                "content": "**BFS solution with count open bracket and closing bracket**\\n\\nFalse case + pruning case to skip the addition to the queue\\n- if starting with close bracket -> False\\n- if ending with open bracket -> False\\n- if memo at the current position has less number of open bracket, no need to check as both path will end up same result -> skip\\n- if current number of unmatched open bracket has more then the steps left to the target -> this path is invalid -> skip\\n- We can\\'t have closing bracket when current path has no open bracket left to be matched -> skip\\n- if we didn\\'t find the answer until try all the path -> False\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rLen, cLen = len(grid), len(grid[0])\\n        direc = [(1, 0), (0, 1)]\\n        q = deque()\\n        maxStep = rLen + cLen - 2\\n        visited = {}\\n        \\n        # starting with closing bracket = invalid parentheses return False\\n        if grid[0][0] == \\')\\':\\n            return False\\n        # can\\'t end with closing bracket\\n        elif grid[rLen - 1][cLen - 1] == \\'(\\':\\n            return False\\n        elif grid[0][0] == \\'(\\':\\n            q.append((0, 0, 1))\\n        \\n        while q:\\n            currR, currC, currCount = q.popleft()\\n            # memo skip if currCount > then previous as we will find answer anyways\\n            if (currR, currC) in visited:\\n                if visited[(currR, currC)] <= currCount:\\n                    continue\\n            visited[(currR, currC)] = currCount\\n            # if curr number of open count has more than possible steps left to target then skip\\n            if (maxStep - currR + currC) < currCount:\\n                continue\\n            # reach to target? -> make sure our count == 0 and return True\\n            if currR == rLen - 1 and currC == cLen - 1:\\n                if currCount == 0:\\n                    return True\\n            for dr, dc in direc:\\n                newR, newC = currR + dr, currC + dc\\n                if newR < rLen and newC < cLen:\\n                    if grid[newR][newC] == \\'(\\':\\n                        q.append((newR, newC, currCount + 1))\\n                    elif grid[newR][newC] == \\')\\':\\n                        # if currCount is 0 then we can\\'t take path with closing bracket\\n                        if currCount > 0:\\n                            q.append((newR, newC, currCount - 1))\\n        # we didnt find solution for all possible path return False\\n        return False\\n```\\n\\n**Please UPVOTE if you find this solution helpful !\\nHappy algo!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rLen, cLen = len(grid), len(grid[0])\\n        direc = [(1, 0), (0, 1)]\\n        q = deque()\\n        maxStep = rLen + cLen - 2\\n        visited = {}\\n        \\n        # starting with closing bracket = invalid parentheses return False\\n        if grid[0][0] == \\')\\':\\n            return False\\n        # can\\'t end with closing bracket\\n        elif grid[rLen - 1][cLen - 1] == \\'(\\':\\n            return False\\n        elif grid[0][0] == \\'(\\':\\n            q.append((0, 0, 1))\\n        \\n        while q:\\n            currR, currC, currCount = q.popleft()\\n            # memo skip if currCount > then previous as we will find answer anyways\\n            if (currR, currC) in visited:\\n                if visited[(currR, currC)] <= currCount:\\n                    continue\\n            visited[(currR, currC)] = currCount\\n            # if curr number of open count has more than possible steps left to target then skip\\n            if (maxStep - currR + currC) < currCount:\\n                continue\\n            # reach to target? -> make sure our count == 0 and return True\\n            if currR == rLen - 1 and currC == cLen - 1:\\n                if currCount == 0:\\n                    return True\\n            for dr, dc in direc:\\n                newR, newC = currR + dr, currC + dc\\n                if newR < rLen and newC < cLen:\\n                    if grid[newR][newC] == \\'(\\':\\n                        q.append((newR, newC, currCount + 1))\\n                    elif grid[newR][newC] == \\')\\':\\n                        # if currCount is 0 then we can\\'t take path with closing bracket\\n                        if currCount > 0:\\n                            q.append((newR, newC, currCount - 1))\\n        # we didnt find solution for all possible path return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018050,
                "title": "dfs-3-d-dp-memoization",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL**\\n\\n```\\nclass Solution {\\n    bool f=0;\\n    int c=0;\\n    //int dp[101][101][201];\\n    bool dfs(vector<vector<char>>& grid,int i,int j,int &n,int &m, vector<vector<vector<int>>>& dp)\\n    {\\n        if(f)return 1;\\n        if(i>=n||j>=m)return 0;\\n        \\n        if(i==n-1&&j==m-1)\\n        {\\n            if(c==1){f=1;return 1;}\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][c]!=-1)\\n            return dp[i][j][c];\\n        \\n        if(grid[i][j]==\\'(\\')\\n            c++;\\n        else\\n        {\\n            if(c)c--;\\n            else\\n                return 0;\\n        }\\n        \\n        bool flag=0;\\n        flag|=dfs(grid,i+1,j,n,m,dp);\\n        flag|=dfs(grid,i,j+1,n,m,dp);\\n        \\n        c=grid[i][j]==\\'(\\'?c-1:c+1;\\n        return dp[i][j][c]=flag?1:0;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        if(grid[0][0]==\\')\\'||grid[n-1][m-1]==\\'(\\')return 0;\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n-1,-1)));\\n        return dfs(grid,0,0,n,m,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool f=0;\\n    int c=0;\\n    //int dp[101][101][201];\\n    bool dfs(vector<vector<char>>& grid,int i,int j,int &n,int &m, vector<vector<vector<int>>>& dp)\\n    {\\n        if(f)return 1;\\n        if(i>=n||j>=m)return 0;\\n        \\n        if(i==n-1&&j==m-1)\\n        {\\n            if(c==1){f=1;return 1;}\\n            return 0;\\n        }\\n        \\n        if(dp[i][j][c]!=-1)\\n            return dp[i][j][c];\\n        \\n        if(grid[i][j]==\\'(\\')\\n            c++;\\n        else\\n        {\\n            if(c)c--;\\n            else\\n                return 0;\\n        }\\n        \\n        bool flag=0;\\n        flag|=dfs(grid,i+1,j,n,m,dp);\\n        flag|=dfs(grid,i,j+1,n,m,dp);\\n        \\n        c=grid[i][j]==\\'(\\'?c-1:c+1;\\n        return dp[i][j][c]=flag?1:0;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int n=grid.size(),m=grid[0].size();\\n        if(grid[0][0]==\\')\\'||grid[n-1][m-1]==\\'(\\')return 0;\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n-1,-1)));\\n        return dfs(grid,0,0,n,m,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017898,
                "title": "c-hashset-dp-w-crappy-image-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/c8a67b6a-e11b-420d-94e2-eef687da5e05_1651983094.751082.png)\\n\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if (grid[m-1][n-1] == \\'(\\' || (m+n)%2 == 0)\\n            return false;\\n        vector<vector<unordered_set<int>>> dp(m+1, vector<unordered_set<int>>(n+1));\\n        dp[m][n-1].insert(0);\\n        dp[m-1][n].insert(0);\\n        for (int i = m-1; i >= 0; --i) {\\n            for (int j = n-1; j >= 0; --j) {\\n                int p = (grid[i][j] == \\')\\') ? 1 : -1;\\n                for (int v: dp[i+1][j]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n                for (int v: dp[i][j+1]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n            }\\n        }\\n        return dp[0][0].find(0) != dp[0][0].end();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        if (grid[m-1][n-1] == \\'(\\' || (m+n)%2 == 0)\\n            return false;\\n        vector<vector<unordered_set<int>>> dp(m+1, vector<unordered_set<int>>(n+1));\\n        dp[m][n-1].insert(0);\\n        dp[m-1][n].insert(0);\\n        for (int i = m-1; i >= 0; --i) {\\n            for (int j = n-1; j >= 0; --j) {\\n                int p = (grid[i][j] == \\')\\') ? 1 : -1;\\n                for (int v: dp[i+1][j]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n                for (int v: dp[i][j+1]) {\\n                    v += p;\\n                    if (v >= 0)\\n                        dp[i][j].insert(v);\\n                }\\n            }\\n        }\\n        return dp[0][0].find(0) != dp[0][0].end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017736,
                "title": "cpp-dfs-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<vector<int>>> dp;\\n    bool dfs(int i,int j,vector<vector<char>>& g,int cnt){     // cnt = number of opening brackets remaining\\n        if(i<0 || j<0 || i>=n || j>=m) return 0;\\n        \\n        if(dp[i][j][cnt]!=-1) return dp[i][j][cnt];\\n        \\n        if(i==n-1 && j==m-1){\\n            if(g[i][j]==\\'(\\') cnt++;\\n            else cnt--;\\n            \\n            if(cnt<0) return 0;\\n            if(cnt==0) return 1;\\n            \\n            return dp[i][j][cnt] = 0;\\n        }\\n        \\n        if(g[i][j] == \\'(\\'){\\n            if(dfs(i+1,j,g,cnt+1)) return 1;\\n            if(dfs(i,j+1,g,cnt+1)) return 1;\\n        }\\n        else{\\n            if(cnt == 0) return dp[i][j][cnt] = 0;\\n            if(dfs(i+1,j,g,cnt-1)) return 1;\\n            if(dfs(i,j+1,g,cnt-1)) return 1;\\n        }\\n        \\n        return dp[i][j][cnt]=0;\\n    }\\n\\t\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        n = g.size(), m = g[0].size();\\n        dp = vector<vector<vector<int>>>(n,vector<vector<int>>(m,vector<int>(m+n+1,-1)));\\n        return dfs(0,0,g,0);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int n,m;\\n    vector<vector<vector<int>>> dp;\\n    bool dfs(int i,int j,vector<vector<char>>& g,int cnt){     // cnt = number of opening brackets remaining\\n        if(i<0 || j<0 || i>=n || j>=m) return 0;\\n        \\n        if(dp[i][j][cnt]!=-1) return dp[i][j][cnt];\\n        \\n        if(i==n-1 && j==m-1){\\n            if(g[i][j]==\\'(\\') cnt++;\\n            else cnt--;\\n            \\n            if(cnt<0) return 0;\\n            if(cnt==0) return 1;\\n            \\n            return dp[i][j][cnt] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3724881,
                "title": "3-d-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int r, int c, int count, vector<vector<char>> &grid, vector<vector<vector<int>>> &dp)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (r == n - 1 and c == m - 1)\\n    {\\n        return count == 1;\\n    }\\n\\n    if (r < 0 or r >= n or c < 0 or c >= m or count < 0 or count > ((m + n) / 2))\\n    {\\n        return false;\\n    }\\n\\n    if (dp[r][c][count] != -1)\\n    {\\n        return dp[r][c][count];\\n    }\\n\\n    int tot = count;\\n    if (grid[r][c] == \\'(\\')\\n    {\\n        tot++;\\n    }\\n    else\\n    {\\n        tot--;\\n    }\\n\\n    bool right = solve(r, c + 1, tot, grid, dp);\\n    bool down = solve(r + 1, c, tot, grid, dp);\\n\\n    return dp[r][c][count] = right or down;\\n}\\n\\nbool hasValidPath(vector<vector<char>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (n % 2 == m % 2)\\n    {\\n        return false;\\n    }\\n    if (grid[0][0] == \\')\\' or grid[n - 1][m - 1] == \\'(\\')\\n    {\\n        return false;\\n    }\\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(((m + n) / 2) + 1, -1)));\\n\\n    return solve(0, 0, 0, grid, dp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int r, int c, int count, vector<vector<char>> &grid, vector<vector<vector<int>>> &dp)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (r == n - 1 and c == m - 1)\\n    {\\n        return count == 1;\\n    }\\n\\n    if (r < 0 or r >= n or c < 0 or c >= m or count < 0 or count > ((m + n) / 2))\\n    {\\n        return false;\\n    }\\n\\n    if (dp[r][c][count] != -1)\\n    {\\n        return dp[r][c][count];\\n    }\\n\\n    int tot = count;\\n    if (grid[r][c] == \\'(\\')\\n    {\\n        tot++;\\n    }\\n    else\\n    {\\n        tot--;\\n    }\\n\\n    bool right = solve(r, c + 1, tot, grid, dp);\\n    bool down = solve(r + 1, c, tot, grid, dp);\\n\\n    return dp[r][c][count] = right or down;\\n}\\n\\nbool hasValidPath(vector<vector<char>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n    if (n % 2 == m % 2)\\n    {\\n        return false;\\n    }\\n    if (grid[0][0] == \\')\\' or grid[n - 1][m - 1] == \\'(\\')\\n    {\\n        return false;\\n    }\\n    vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(((m + n) / 2) + 1, -1)));\\n\\n    return solve(0, 0, 0, grid, dp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434922,
                "title": "100-faster-using-recursion-3d-dp-dp-row-column-count-of",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(int i, int j, int count, vector<vector<char>>& grid,  vector< vector< vector<int> > > &dp) {\\n        if(i == grid.size() || j == grid[0].size()) return false;\\n        if(i == grid.size() -1 && j == grid[0].size() - 1) {\\n            if(grid[i][j] == \\'(\\') return false;\\n            return count - 1 == 0;\\n        }\\n        if(dp[i][j][count] != -1) return dp[i][j][count];\\n\\n        if(grid[i][j] == \\'(\\') {\\n            return dp[i][j][count] = helper(i+1, j, count+1, grid, dp) || helper(i, j+1, count+1, grid, dp);\\n        }\\n        if(count > 0) return dp[i][j][count] = helper(i+1, j, count-1, grid, dp) || helper(i, j+1, count-1, grid, dp);\\n\\n        return dp[i][j][count] =false;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector< vector< vector<int> > > dp(grid.size(), vector< vector< int > > (grid[0].size(), vector< int > (grid.size()+grid[0].size(), -1)));\\n        return helper(0, 0, 0, grid, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(int i, int j, int count, vector<vector<char>>& grid,  vector< vector< vector<int> > > &dp) {\\n        if(i == grid.size() || j == grid[0].size()) return false;\\n        if(i == grid.size() -1 && j == grid[0].size() - 1) {\\n            if(grid[i][j] == \\'(\\') return false;\\n            return count - 1 == 0;\\n        }\\n        if(dp[i][j][count] != -1) return dp[i][j][count];\\n\\n        if(grid[i][j] == \\'(\\') {\\n            return dp[i][j][count] = helper(i+1, j, count+1, grid, dp) || helper(i, j+1, count+1, grid, dp);\\n        }\\n        if(count > 0) return dp[i][j][count] = helper(i+1, j, count-1, grid, dp) || helper(i, j+1, count-1, grid, dp);\\n\\n        return dp[i][j][count] =false;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        vector< vector< vector<int> > > dp(grid.size(), vector< vector< int > > (grid[0].size(), vector< int > (grid.size()+grid[0].size(), -1)));\\n        return helper(0, 0, 0, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353083,
                "title": "2d-dp-solution-in-java",
                "content": "### Approach\\nThe approach used in the given code is to solve the problem using dynamic programming. The idea is to create a 2D array called dp, where each cell stores the set of possible balance values at that position. We start by initializing the set at the top-left cell with the value 1 if the path starts with a \\'(\\' character.\\n\\nThen, we iterate over each cell of the dp array and update the set of balances at each cell based on the direction of the paths. For each neighboring cell, we check the set of possible balances at that cell and add or subtract 1 to get the new balance value. We then add the new balance value to the set of balances at the current cell if it is non-negative.\\n\\nFinally, we check if the set of balances at the bottom-right cell of the dp array contains 0, which means that there exists a path from the top-left cell to the bottom-right cell with a balanced set of parentheses. If the set contains 0, we return `true`. Otherwise, we return `false`.\\n\\n# Complexity\\n- Time complexity: $$O(mn(m+n))$$\\n- Space complexity: $$O(mn)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] path = new int[][]{{-1, 0}, {0, -1}};\\n\\n        Set<Integer>[][] dp = new HashSet[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<>();\\n            }\\n        }\\n\\n        if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n        /*This is the main logic of the program. \\n        \\n        We iterate over each cell of the dp array and calculate the balance of \\n        the parentheses at that cell.The variable cur is set to 1 if the current cell\\n        contains an open parenthesis, and -1 otherwise.*/\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n                for (int[] d : path) {\\n                    int x = i + d[0], y = j + d[1];\\n                    if (x < 0 || y < 0) continue;\\n\\n                    for (int bal : dp[x][y]) {\\n                        bal += cur;\\n                        if (bal < 0) continue;\\n                        dp[i][j].add(bal);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1].contains(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] path = new int[][]{{-1, 0}, {0, -1}};\\n\\n        Set<Integer>[][] dp = new HashSet[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<>();\\n            }\\n        }\\n\\n        if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n        /*This is the main logic of the program. \\n        \\n        We iterate over each cell of the dp array and calculate the balance of \\n        the parentheses at that cell.The variable cur is set to 1 if the current cell\\n        contains an open parenthesis, and -1 otherwise.*/\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n                for (int[] d : path) {\\n                    int x = i + d[0], y = j + d[1];\\n                    if (x < 0 || y < 0) continue;\\n\\n                    for (int bal : dp[x][y]) {\\n                        bal += cur;\\n                        if (bal < 0) continue;\\n                        dp[i][j].add(bal);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[m-1][n-1].contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731709,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool hasValidPath(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), maxk = (m + n + 1) / 2;\\n        vector<vector<vector<int>>> dp(m + 1, vector<vector<int>>(n + 1, vector<int>(maxk + 10)));\\n        dp[0][0][1] = 1;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= maxk; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263853,
                "title": "c-memomization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>&g,int i,int j,int st,vector<vector<vector<int>>>&dp)\\n    { \\n        if(i==0&&j==0)\\n        {\\n            if(st==1)\\n            {\\n                if(g[i][j]==\\'(\\')\\n                    return true;\\n                else\\n                    return false;\\n            }\\n            else\\n                return false;\\n        }\\n        if(i<0||j<0)\\n        {\\n          return false;\\n        }   \\n        if(g[i][j]==\\')\\')\\n            st+=1;\\n        else\\n        {\\n           if(st==0)\\n               return dp[i][j][st]=false;\\n           else\\n               st--;\\n        }\\n        if(dp[i][j][st]!=-1)\\n            return dp[i][j][st];\\n        return dp[i][j][st]=f(g,i-1,j,st,dp)||f(g,i,j-1,st,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>&g) {\\n        int st=0;\\n        vector<vector<vector<int>>>dp(g.size()+1,vector<vector<int>>(g[0].size()+1,vector<int>(g.size()+g[0].size()+2,-1)));\\n        return f(g,g.size()-1,g[0].size()-1,st,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>&g,int i,int j,int st,vector<vector<vector<int>>>&dp)\\n    { \\n        if(i==0&&j==0)\\n        {\\n            if(st==1)\\n            {\\n                if(g[i][j]==\\'(\\')\\n                    return true;\\n                else\\n                    return false;\\n            }\\n            else\\n                return false;\\n        }\\n        if(i<0||j<0)\\n        {\\n          return false;\\n        }   \\n        if(g[i][j]==\\')\\')\\n            st+=1;\\n        else\\n        {\\n           if(st==0)\\n               return dp[i][j][st]=false;\\n           else\\n               st--;\\n        }\\n        if(dp[i][j][st]!=-1)\\n            return dp[i][j][st];\\n        return dp[i][j][st]=f(g,i-1,j,st,dp)||f(g,i,j-1,st,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>&g) {\\n        int st=0;\\n        vector<vector<vector<int>>>dp(g.size()+1,vector<vector<int>>(g[0].size()+1,vector<int>(g.size()+g[0].size()+2,-1)));\\n        return f(g,g.size()-1,g[0].size()-1,st,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162698,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nLet `k` be the amount of open parenthesis `\\'(\\'` *not* paired with a close parenthesis `\\')\\'` on the path from the top-left cell `0`,`0` ending at cell `i`,`j`.  Note: `k` must *not* be negative at any point in the path (otherwise there\\'s too many close parenthesis `\\')\\'` for a valid path)\\n\\n**Top-Down:** let `D` and `R` denote adjacent cells \"down\" and \"right\" correspondingly.\\n\\n**Bottom-Up:** let `U` and `L` denote adjacent cells \"up\" and \"left\" correspondingly, let `dp[i][j]` denote the set of all `k` possibilities of open parenthesis `\\'(\\'` for paths ending at cell `i`,`j`.  And we formulate the future from the past by considering all `k` candidates `cands`. \\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var D = go(i + 1, j, k)\\n            var R = go(i, j + 1, k)\\n            return D || R\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var m = mutableMapOf<String, Boolean>()\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var key = \"$i,$j,$k\"\\n            if (!m.contains(key)) {\\n                var D = go(i + 1, j, k)\\n                var R = go(i, j + 1, k)\\n                m[key] = D || R\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var dp = Array(M) { Array(N) { mutableSetOf<Int>() } }\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].add(1)\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                var U = if (0 <= i - 1) dp[i - 1][j] else mutableSetOf<Int>()\\n                var L = if (0 <= j - 1) dp[i][j - 1] else mutableSetOf<Int>()\\n                var cands = U union L\\n                for (k_ in cands) {\\n                    var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n                    if (0 <= k)\\n                        dp[i][j].add(k)\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].contains(0)\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let D = go(i + 1, j, k),\\n            R = go(i, j + 1, k);\\n        return D || R;\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet hasValidPath = (A, m = new Map()) => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let key = `${i},${j},${k}`;\\n        if (!m.has(key)) {\\n            let D = go(i + 1, j, k),\\n                R = go(i, j + 1, k);\\n            m.set(key, D || R);\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let dp = [...Array(M)].map(_ => [...Array(N)].map(_ => new Set()));\\n    if (A[0][0] == \\'(\\')\\n        dp[0][0].add(1);\\n    for (let i = 0; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let U = 0 <= i - 1 ? dp[i - 1][j] : new Set(),\\n                L = 0 <= j - 1 ? dp[i][j - 1] : new Set();\\n            let cands = new Set([...U, ...L]);\\n            for (let k of cands) {\\n                k += A[i][j] == \\'(\\' ? 1 : -1;\\n                if (0 <= k)\\n                    dp[i][j].add(k);\\n            }\\n        }\\n    }\\n    return dp[M - 1][N - 1].has(0);\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        @cache\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        dp = [[set() for _ in range(N)] for _ in range(M)]\\n        if A[0][0] == \\'(\\':\\n            dp[0][0].add(1)\\n        for i in range(M):\\n            for j in range(N):\\n                U = dp[i - 1][j] if 0 <= i - 1 else set()\\n                L = dp[i][j - 1] if 0 <= j - 1 else set()\\n                for k in U.union(L):\\n                    k += 1 if A[i][j] == \\'(\\' else -1\\n                    if 0 <= k:\\n                        dp[i][j].add(k)\\n        return 0 in dp[M - 1][N - 1]\\n```\\n\\n---\\n\\n**Rust Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let D = go(A, i + 1, j, k);\\n            let R = go(A, i, j + 1, k);\\n            return D || R;\\n        }\\n        go(&A, 0, 0, 0)\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32, m: &mut HashMap::<String, bool>) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let key = format!(\"{},{},{}\", i, j, k);\\n            if !m.contains_key(&key) {\\n                let D = go(A, i + 1, j, k, m);\\n                let R = go(A, i, j + 1, k, m);\\n                m.insert(key.clone(), D || R);\\n            }\\n            *m.get(&key).unwrap()\\n        }\\n        let mut m = HashMap::new();\\n        go(&A, 0, 0, 0, &mut m)\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        let M = A.len();\\n        let N = A[0].len();\\n        let mut dp = vec![vec![HashSet::new(); N]; M];\\n        if A[0][0] == \\'(\\' {\\n            dp[0][0].insert(1);\\n        }\\n        for i in 0..M {\\n            for j in 0..N {\\n                let U = if 0 <= i as i32 - 1 { dp[i - 1][j].clone() } else { HashSet::new() };\\n                let L = if 0 <= j as i32 - 1 { dp[i][j - 1].clone() } else { HashSet::new() };\\n                let cands = U.union(&L);\\n                for k_ in cands {\\n                    let k = k_ + if A[i][j] == \\'(\\' { 1 } else { -1 };\\n                    if 0 <= k {\\n                        dp[i][j].insert(k);\\n                    }\\n                }\\n            }\\n        }\\n        dp[M - 1][N - 1].contains(&0)\\n    }\\n}\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto D = go(i + 1, j, k),\\n                 R = go(i, j + 1, k);\\n            return D || R;\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    using Map = unordered_map<string, bool>;\\n    bool hasValidPath(VVC& A, Map m = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto hash = [](auto i, auto j, auto k) {\\n            stringstream ss; ss << i << \",\" << j << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto key = hash(i, j, k);\\n            if (m.find(key) == m.end()) {\\n                auto D = go(i + 1, j, k),\\n                     R = go(i, j + 1, k);\\n                m[key] = D || R;\\n            }\\n            return m[key];\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using Set = unordered_set<int>;\\n    using VS = vector<Set>;\\n    using VVS = vector<VS>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VVS dp(M, VS(N));\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].insert(1);\\n        for (auto i{ 0 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto U = 0 <= i - 1 ? dp[i - 1][j] : Set{},\\n                     L = 0 <= j - 1 ? dp[i][j - 1] : Set{};\\n                Set cands;\\n                set_union(U.begin(), U.end(),\\n                          L.begin(), L.end(), inserter(cands, cands.end()));\\n                for (auto k: cands) {\\n                    k += A[i][j] == \\'(\\' ? 1 : -1;\\n                    if (0 <= k)\\n                        dp[i][j].insert(k);\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].find(0) != dp[M - 1][N - 1].end();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var D = go(i + 1, j, k)\\n            var R = go(i, j + 1, k)\\n            return D || R\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var m = mutableMapOf<String, Boolean>()\\n        fun go(i: Int = 0, j: Int = 0, k_: Int = 0): Boolean {\\n            if (i == M || j == N)\\n                return false\\n            var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n            if (k < 0)\\n                return false\\n            if (i == M - 1 && j == N - 1)\\n                return k == 0\\n            var key = \"$i,$j,$k\"\\n            if (!m.contains(key)) {\\n                var D = go(i + 1, j, k)\\n                var R = go(i, j + 1, k)\\n                m[key] = D || R\\n            }\\n            return m[key]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun hasValidPath(A: Array<CharArray>): Boolean {\\n        var M = A.size\\n        var N = A[0].size\\n        var dp = Array(M) { Array(N) { mutableSetOf<Int>() } }\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].add(1)\\n        for (i in 0 until M) {\\n            for (j in 0 until N) {\\n                var U = if (0 <= i - 1) dp[i - 1][j] else mutableSetOf<Int>()\\n                var L = if (0 <= j - 1) dp[i][j - 1] else mutableSetOf<Int>()\\n                var cands = U union L\\n                for (k_ in cands) {\\n                    var k = k_ + if (A[i][j] == \\'(\\') 1 else -1\\n                    if (0 <= k)\\n                        dp[i][j].add(k)\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].contains(0)\\n    }\\n}\\n```\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let D = go(i + 1, j, k),\\n            R = go(i, j + 1, k);\\n        return D || R;\\n    };\\n    return go();\\n};\\n```\n```\\nlet hasValidPath = (A, m = new Map()) => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let go = (i = 0, j = 0, k = 0) => {\\n        if (i == M || j == N)\\n            return false;\\n        k += A[i][j] == \\'(\\' ? 1 : -1;\\n        if (k < 0)\\n            return false;\\n        if (i == M - 1 && j == N - 1)\\n            return !k;\\n        let key = `${i},${j},${k}`;\\n        if (!m.has(key)) {\\n            let D = go(i + 1, j, k),\\n                R = go(i, j + 1, k);\\n            m.set(key, D || R);\\n        }\\n        return m.get(key);\\n    };\\n    return go();\\n};\\n```\n```\\nlet hasValidPath = A => {\\n    let M = A.length,\\n        N = A[0].length;\\n    let dp = [...Array(M)].map(_ => [...Array(N)].map(_ => new Set()));\\n    if (A[0][0] == \\'(\\')\\n        dp[0][0].add(1);\\n    for (let i = 0; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let U = 0 <= i - 1 ? dp[i - 1][j] : new Set(),\\n                L = 0 <= j - 1 ? dp[i][j - 1] : new Set();\\n            let cands = new Set([...U, ...L]);\\n            for (let k of cands) {\\n                k += A[i][j] == \\'(\\' ? 1 : -1;\\n                if (0 <= k)\\n                    dp[i][j].add(k);\\n            }\\n        }\\n    }\\n    return dp[M - 1][N - 1].has(0);\\n};\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        @cache\\n        def go(i = 0, j = 0, k = 0):\\n            if i == M or j == N:\\n                return False\\n            k += 1 if A[i][j] == \\'(\\' else -1\\n            if k < 0:\\n                return False\\n            if i == M - 1 and j == N - 1:\\n                return not k\\n            D = go(i + 1, j, k)\\n            R = go(i, j + 1, k)\\n            return D or R\\n        return go()\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, A: List[List[str]]) -> bool:\\n        M = len(A)\\n        N = len(A[0])\\n        dp = [[set() for _ in range(N)] for _ in range(M)]\\n        if A[0][0] == \\'(\\':\\n            dp[0][0].add(1)\\n        for i in range(M):\\n            for j in range(N):\\n                U = dp[i - 1][j] if 0 <= i - 1 else set()\\n                L = dp[i][j - 1] if 0 <= j - 1 else set()\\n                for k in U.union(L):\\n                    k += 1 if A[i][j] == \\'(\\' else -1\\n                    if 0 <= k:\\n                        dp[i][j].add(k)\\n        return 0 in dp[M - 1][N - 1]\\n```\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let D = go(A, i + 1, j, k);\\n            let R = go(A, i, j + 1, k);\\n            return D || R;\\n        }\\n        go(&A, 0, 0, 0)\\n    }\\n}\\n```\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        fn go(A: &VVC, i: usize, j: usize, mut k: i32, m: &mut HashMap::<String, bool>) -> bool {\\n            if i == A.len() || j == A[0].len() {\\n                return false;\\n            }\\n            k += if A[i][j] == \\'(\\' { 1 } else { -1 };\\n            if k < 0 {\\n                return false;\\n            }\\n            if i == A.len() - 1 && j == A[0].len() - 1 {\\n                return k == 0;\\n            }\\n            let key = format!(\"{},{},{}\", i, j, k);\\n            if !m.contains_key(&key) {\\n                let D = go(A, i + 1, j, k, m);\\n                let R = go(A, i, j + 1, k, m);\\n                m.insert(key.clone(), D || R);\\n            }\\n            *m.get(&key).unwrap()\\n        }\\n        let mut m = HashMap::new();\\n        go(&A, 0, 0, 0, &mut m)\\n    }\\n}\\n```\n```\\ntype VC = Vec<char>;\\ntype VVC = Vec<VC>;\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn has_valid_path(A: VVC) -> bool {\\n        let M = A.len();\\n        let N = A[0].len();\\n        let mut dp = vec![vec![HashSet::new(); N]; M];\\n        if A[0][0] == \\'(\\' {\\n            dp[0][0].insert(1);\\n        }\\n        for i in 0..M {\\n            for j in 0..N {\\n                let U = if 0 <= i as i32 - 1 { dp[i - 1][j].clone() } else { HashSet::new() };\\n                let L = if 0 <= j as i32 - 1 { dp[i][j - 1].clone() } else { HashSet::new() };\\n                let cands = U.union(&L);\\n                for k_ in cands {\\n                    let k = k_ + if A[i][j] == \\'(\\' { 1 } else { -1 };\\n                    if 0 <= k {\\n                        dp[i][j].insert(k);\\n                    }\\n                }\\n            }\\n        }\\n        dp[M - 1][N - 1].contains(&0)\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto D = go(i + 1, j, k),\\n                 R = go(i, j + 1, k);\\n            return D || R;\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using fun = function<bool(int, int, int)>;\\n    using Map = unordered_map<string, bool>;\\n    bool hasValidPath(VVC& A, Map m = {}) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto hash = [](auto i, auto j, auto k) {\\n            stringstream ss; ss << i << \",\" << j << \",\" << k;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j, auto k) {\\n            if (i == M || j == N)\\n                return false;\\n            k += A[i][j] == \\'(\\' ? 1 : -1;\\n            if (k < 0)\\n                return false;\\n            if (i == M - 1 && j == N - 1)\\n                return !k;\\n            auto key = hash(i, j, k);\\n            if (m.find(key) == m.end()) {\\n                auto D = go(i + 1, j, k),\\n                     R = go(i, j + 1, k);\\n                m[key] = D || R;\\n            }\\n            return m[key];\\n        };\\n        return go(0, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VC = vector<char>;\\n    using VVC = vector<VC>;\\n    using Set = unordered_set<int>;\\n    using VS = vector<Set>;\\n    using VVS = vector<VS>;\\n    bool hasValidPath(VVC& A) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        VVS dp(M, VS(N));\\n        if (A[0][0] == \\'(\\')\\n            dp[0][0].insert(1);\\n        for (auto i{ 0 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto U = 0 <= i - 1 ? dp[i - 1][j] : Set{},\\n                     L = 0 <= j - 1 ? dp[i][j - 1] : Set{};\\n                Set cands;\\n                set_union(U.begin(), U.end(),\\n                          L.begin(), L.end(), inserter(cands, cands.end()));\\n                for (auto k: cands) {\\n                    k += A[i][j] == \\'(\\' ? 1 : -1;\\n                    if (0 <= k)\\n                        dp[i][j].insert(k);\\n                }\\n            }\\n        }\\n        return dp[M - 1][N - 1].find(0) != dp[M - 1][N - 1].end();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136427,
                "title": "c-easy-to-understand-dp-code-3d-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<char>> &grid,int i,int j,int n,int m,vector<vector<vector<int>>> &dp,int count)\\n    {\\n        if(i>=n||j>=m)\\n        {\\n            return false;\\n        }\\n        if(count>(n+m)/2)\\n        {\\n            return dp[i][j][count]=false;\\n        }\\n        if(grid[i][j]==\\'(\\')\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count--;\\n        }\\n        if(count<0)\\n        {\\n            return false;\\n        }\\n        if(dp[i][j][count]!=-1)\\n        {\\n            return dp[i][j][count];\\n        }\\n        if(i==n-1&&j==m-1&&count==0)\\n        {\\n            return dp[i][j][count]=true;\\n        }\\n        bool ans=false;\\n        if(solve(grid,i+1,j,n,m,dp,count)||solve(grid,i,j+1,n,m,dp,count))\\n        {\\n            ans=true;\\n        }\\n        return dp[i][j][count]=ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(m+1,vector<int>(202,-1)));\\n        return solve(grid,0,0,n,m,dp,0);\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<char>> &grid,int i,int j,int n,int m,vector<vector<vector<int>>> &dp,int count)\\n    {\\n        if(i>=n||j>=m)\\n        {\\n            return false;\\n        }\\n        if(count>(n+m)/2)\\n        {\\n            return dp[i][j][count]=false;\\n        }\\n        if(grid[i][j]==\\'(\\')\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count--;\\n        }\\n        if(count<0)\\n        {\\n            return false;\\n        }\\n        if(dp[i][j][count]!=-1)\\n        {\\n            return dp[i][j][count];\\n        }\\n        if(i==n-1&&j==m-1&&count==0)\\n        {\\n            return dp[i][j][count]=true;\\n        }\\n        bool ans=false;\\n        if(solve(grid,i+1,j,n,m,dp,count)||solve(grid,i,j+1,n,m,dp,count))\\n        {\\n            ans=true;\\n        }\\n        return dp[i][j][count]=ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(m+1,vector<int>(202,-1)));\\n        return solve(grid,0,0,n,m,dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128202,
                "title": "c-simple-and-correct-solution-dp",
                "content": "**r :- rows, c :- columns, o :- number of opening brackets**\\nwhen we reach at the last index i.e (grid[m-1][n-1]) ,after following the path we check that \\n1- there should be closed bracket in cell [m-1][n-1].\\n2 - after reaching the last cell there should only be 1 opening bracket left that will be balanced by the closed bracket in the last cell.\\nif this 2 condition are true the we store true.\\n\\nFor optimization we use memoization to store the state of the recursion.\\n\\n**If you liked the solution . please upvote!!!** \\uD83D\\uDE0E\\n\\n\\tclass Solution {\\n\\tpublic:\\n    bool ans= false;\\n    int t[101][101][1001];\\n    void solve(vector<vector<char>>& g,int r,int c,int o)\\n    {\\n        if(t[r][c][o]!=0)\\n            return;\\n        if(r>g.size()-1||c>g[0].size()-1)\\n            return;\\n        if(r==g.size()-1&&c==g[0].size()-1)\\n        {\\n            if(g[r][c]==\\')\\'&& o==1)\\n                ans=true;\\n            return;\\n        }\\n            if(g[r][c]==\\'(\\')\\n            {\\n                int t = o+1;\\n                solve(g,r,c+1,t);\\n                solve(g,r+1,c,t);\\n            }\\n            else if(o>0 && g[r][c]==\\')\\')\\n            {\\n                int t = o-1;\\n                solve(g,r,c+1,t);\\n                solve(g,r+1,c,t);\\n            }\\n        t[r][c][o] = 1;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(t,0,sizeof(t));\\n        solve(grid,0,0,0);\\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    bool ans= false;\\n    int t[101][101][1001];\\n    void solve(vector<vector<char>>& g,int r,int c,int o)\\n    {\\n        if(t[r][c][o]!=0)\\n            return;\\n        if(r>g.size()-1||c>g[0].size()-1)\\n            return;\\n        if(r==g.size()-1&&c==g[0].size()-1)\\n        {\\n            if(g[r][c]==\\')\\'&& o==1)\\n                ans=true;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2067060,
                "title": "memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<char>>& grid,int count,int n,int m,int i,int j,vector<vector<vector<int>>>&dp){\\n        if(i<0 || i>=n || j<0 || j>=m)return false;\\n       // cout<<grid[i][j]<<count<<\" \";\\n        if(grid[i][j]==\\')\\'){\\n            if(count<=0)return 0;\\n            else count--;\\n        }\\n        \\n        \\n        if(grid[i][j]==\\'(\\')count++;\\n         \\n        \\n        if(i==n-1 && j==m-1){\\n            if(count==0){\\n                return 1;\\n            }\\n        }\\n        if(dp[i][j][count]!=-1)return dp[i][j][count];\\n        \\n        //down \\n        if(solve(grid,count,n,m,i+1,j,dp)==1)return dp[i][j][count] = 1;\\n        if(solve(grid,count,n,m,i,j+1,dp)==1)return dp[i][j][count]=1; //left\\n        \\n        \\n        \\n        \\n       \\n        return dp[i][j][count]=0;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n       vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n,-1)));\\n        int count=0;\\n       \\n        int sol = solve(grid,count,n,m,0,0,dp);\\n       \\n        \\n        if(sol==1)return true;\\n    \\n        return false;\\n    }\\n};\\n```\\nI\\'m so proud of me for solving this. Literally lost a night\\'s sleep over this one",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<char>>& grid,int count,int n,int m,int i,int j,vector<vector<vector<int>>>&dp){\\n        if(i<0 || i>=n || j<0 || j>=m)return false;\\n       // cout<<grid[i][j]<<count<<\" \";\\n        if(grid[i][j]==\\')\\'){\\n            if(count<=0)return 0;\\n            else count--;\\n        }\\n        \\n        \\n        if(grid[i][j]==\\'(\\')count++;\\n         \\n        \\n        if(i==n-1 && j==m-1){\\n            if(count==0){\\n                return 1;\\n            }\\n        }\\n        if(dp[i][j][count]!=-1)return dp[i][j][count];\\n        \\n        //down \\n        if(solve(grid,count,n,m,i+1,j,dp)==1)return dp[i][j][count] = 1;\\n        if(solve(grid,count,n,m,i,j+1,dp)==1)return dp[i][j][count]=1; //left\\n        \\n        \\n        \\n        \\n       \\n        return dp[i][j][count]=0;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n       vector<vector<vector<int>>>dp(n,vector<vector<int>>(m,vector<int>(m+n,-1)));\\n        int count=0;\\n       \\n        int sol = solve(grid,count,n,m,0,0,dp);\\n       \\n        \\n        if(sol==1)return true;\\n    \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2060185,
                "title": "the-one-optimization-to-speed-up-your-memoization",
                "content": "Intuition behind optimizing memoization-\\nThe path length in any scenario irrespective of the path we take would always be equal to n+m-1 since we can only move right or downwards and we\\'ll have to cover n depth and m width.\\nSince we know that the number of open and closed brackets would be same in the end we can conclude that at any moment, the open brackets would be less than or equal to (n+m-1)/2.\\nAs most of the solutions are using the no. of open brackets for memoization we can reduce the size of our vector signifcantly by making the max no. of open brackets as (n+m-1)/2 instead of n * m.\\n\\n``\\nclass Solution {\\npublic:\\nbool helper(int i,int j,int o,vector<vector<char>>&grid,vector<vector<vector<int>>>&memo){  \\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(o>(n+m)/2)  return false; \\n    if(i>=n or i<0 or j>=m or j<0)return false;\\n                                                                                                     if(i==n-1 and j==m-1){\\n        if(o==1)return true;\\n        return false;\\n    }         \\n    if(memo[i][j][o]!=-1)return memo[i][j][o];\\n    char curr=grid[i][j];\\n    \\n    if(curr==\\')\\'){\\n        if(o>=1)\\n             return memo[i][j][o]=helper(i+1,j,o-1,grid,memo) or helper(i,j+1,o-1,grid,memo);\\n        else return memo[i][j][o]=false;\\n    }\\n      else  return memo[i][j][o]=helper(i+1,j,o+1,grid,memo) or helper(i,j+1,o+1,grid,memo);\\n      \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<vector<int>>>memo(n,vector<vector<int>>(m,vector<int>((n+m)/2+1,-1)));\\n        if(grid[n-1][m-1]==\\'(\\')return false;\\n        \\n        return helper(0,0,0,grid,memo);\\n        \\n    }\\n};\\n``",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\nbool helper(int i,int j,int o,vector<vector<char>>&grid,vector<vector<vector<int>>>&memo){  \\n    int n=grid.size();\\n    int m=grid[0].size();\\n    if(o>(n+m)/2)  return false; \\n    if(i>=n or i<0 or j>=m or j<0)return false;\\n                                                                                                     if(i==n-1 and j==m-1){\\n        if(o==1)return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2050921,
                "title": "c-classic-dfs-dp",
                "content": "* **If at any point in our traversal we find that open has become negative then return false as there is no way to balance a `)` bracket if it arrives before `(`.** \\n \\n```\\nclass Solution {\\npublic:\\n    int r ,c ;\\n    int dp[101][101][1001] ;\\n    bool solve(int x , int y , vector<vector<char>>&grid , int open ){\\n        if(x >= r || y >= c) return false ;\\n        open += grid[x][y] == \\'(\\' ? 1 : -1 ;\\n        if(open < 0) return false ;\\n        if(x == r - 1 and y == c - 1 ) return (open == 0) ;\\n        \\n        if(dp[x][y][open] != -1) return dp[x][y][open] ;\\n        \\n        bool path1 = solve(x,y+1,grid,open) ;\\n        bool path2 = solve(x+1,y,grid,open) ;\\n        return dp[x][y][open] = (path1 or path2) ;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size() ;\\n        c = grid[0].size() ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(0,0,grid,0) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r ,c ;\\n    int dp[101][101][1001] ;\\n    bool solve(int x , int y , vector<vector<char>>&grid , int open ){\\n        if(x >= r || y >= c) return false ;\\n        open += grid[x][y] == \\'(\\' ? 1 : -1 ;\\n        if(open < 0) return false ;\\n        if(x == r - 1 and y == c - 1 ) return (open == 0) ;\\n        \\n        if(dp[x][y][open] != -1) return dp[x][y][open] ;\\n        \\n        bool path1 = solve(x,y+1,grid,open) ;\\n        bool path2 = solve(x+1,y,grid,open) ;\\n        return dp[x][y][open] = (path1 or path2) ;\\n        \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size() ;\\n        c = grid[0].size() ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        return solve(0,0,grid,0) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031616,
                "title": "simple-dp-memomization-faster-and-easy-to-understand",
                "content": "Simple Intution ,It is same as to find the Path from top left corner to right down corner but here the catch is to find the valid path which should statisfy the given conditions like **()** (parentheses)\\n\\nAnd there is a condition we should take care \\n1. The Path should not start with **)**. \\n2. The path should not end with **(**.\\n\\n**DP Approach**\\n* First take a variable lets say **start**  which will count the parentheses i.e if \"**(**\" then start++  if \"**)**\" start--.\\n* Traverse the all possible paths with right and down.\\n* Until it statisfy the condition i.e (n-1,m-1 and start=0)\\n* if the start is 0 at the end that means we got a path with equal no of parentheses.\\n* To Optimize the code Use Memomization.\\n\\n```\\nclass Solution {\\n    Boolean dp[][][];\\n    public boolean hasValidPath(char[][] grid) \\n    {\\n        dp=new Boolean[grid.length][grid[0].length][grid.length+grid[0].length];\\n        return helper(grid,0,0,0);\\n    }\\n    public boolean helper(char[][] grid,int i,int j,int start)\\n    {\\n        if(i>=grid.length || j>=grid[0].length) return false;\\n        if(grid[i][j]==\\'(\\')\\n            start++;\\n        else\\n            start--;\\n        if(start<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1) return start==0;\\n        if(dp[i][j][start]!=null) return dp[i][j][start];\\n        dp[i][j][start]=(helper(grid,i+1,j,start) || helper(grid,i,j+1,start));\\n        return dp[i][j][start];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Boolean dp[][][];\\n    public boolean hasValidPath(char[][] grid) \\n    {\\n        dp=new Boolean[grid.length][grid[0].length][grid.length+grid[0].length];\\n        return helper(grid,0,0,0);\\n    }\\n    public boolean helper(char[][] grid,int i,int j,int start)\\n    {\\n        if(i>=grid.length || j>=grid[0].length) return false;\\n        if(grid[i][j]==\\'(\\')\\n            start++;\\n        else\\n            start--;\\n        if(start<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1) return start==0;\\n        if(dp[i][j][start]!=null) return dp[i][j][start];\\n        dp[i][j][start]=(helper(grid,i+1,j,start) || helper(grid,i,j+1,start));\\n        return dp[i][j][start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028833,
                "title": "python-simple-dp-solution-top-down",
                "content": "Here is a simple solution\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n=len(grid), len(grid[0])\\n        \\n        # first value in the grid should be \\'(\\' and last value be \\')\\'\\n        if grid[0][0]!=\\'(\\' or grid[-1][-1]!=\\')\\':\\n            return False\\n\\n        @lru_cache(None)\\n        def dp(i,j,c):\\n            # When we reach the last cell, the number of open brackets should be 1.\\n            # \\')\\' from last cell balances it\\n            if i==m-1 and j==n-1:\\n                if c==1:\\n                    return True\\n                else:\\n                    return False\\n            # i,j should be within the range of m,n\\n            if i>=m or j>=n:\\n                return False\\n            \\n            res=False\\n            # From every cell, we can move right(j+1) or down(i+1)\\n            if grid[i][j]==\\'(\\':\\n                # When we encounter \\'(\\' we increment count by 1\\n                res=res or dp(i+1, j, c+1) or dp(i, j+1, c+1)\\n            else:\\n                # When we encounter \\')\\' number of of open brackets must be greater than 0\\n                if c>0:\\n                    # Decrement the count by 1\\n                    res=res or dp(i+1, j, c-1) or dp(i, j+1, c-1)\\n            return res\\n        return dp(0,0,0)\\n        \\n\\t",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Here is a simple solution\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n=len(grid), len(grid[0])\\n        \\n        # first value in the grid should be \\'(\\' and last value be \\')\\'\\n        if grid[0][0]!=\\'(\\' or grid[-1][-1]!=\\')\\':\\n            return False\\n\\n        @lru_cache(None)\\n        def dp(i,j,c):\\n            # When we reach the last cell, the number of open brackets should be 1.\\n            # \\')\\' from last cell balances it\\n            if i==m-1 and j==n-1:\\n                if c==1:\\n                    return True\\n                else:\\n                    return False\\n            # i,j should be within the range of m,n\\n            if i>=m or j>=n:\\n                return False\\n            \\n            res=False\\n            # From every cell, we can move right(j+1) or down(i+1)\\n            if grid[i][j]==\\'(\\':\\n                # When we encounter \\'(\\' we increment count by 1\\n                res=res or dp(i+1, j, c+1) or dp(i, j+1, c+1)\\n            else:\\n                # When we encounter \\')\\' number of of open brackets must be greater than 0\\n                if c>0:\\n                    # Decrement the count by 1\\n                    res=res or dp(i+1, j, c-1) or dp(i, j+1, c-1)\\n            return res\\n        return dp(0,0,0)\\n        \\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2026194,
                "title": "python-and-memorize",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\':\\n            return False\\n        if grid[-1][-1] == \\'(\\':\\n            return False\\n        if (m + n) % 2 == 0:\\n            return False\\n        \\n        halfLen = (m + n) // 2\\n        \\n        helper = [[set([]) for _ in range(n)] for _ in range(m)]\\n        helper[0][0].add(1)\\n        \\n        for c in range(1, n):\\n            for e in helper[0][c-1]:\\n                if halfLen >= e + (1 if grid[0][c] == \\'(\\' else -1) >= 0:\\n                    helper[0][c].add(  e + (1 if grid[0][c] == \\'(\\' else -1) )\\n            \\n        for r in range(1, m):\\n            lst = [e + ( 1 if grid[r][0] == \\'(\\' else -1 ) for e in helper[r-1][0] if halfLen >= e + (1 if grid[r][0] == \\'(\\' else -1) >= 0]\\n            for e in lst:\\n                helper[r][0].add(e)\\n            \\n            for c in range(1, n):\\n                lst = [e + ( 1 if grid[r][c] == \\'(\\' else -1 ) for e in helper[r-1][c].union(helper[r][c-1]) if halfLen >= e + (1 if grid[r][c] == \\'(\\' else -1) >= 0]\\n                \\n                for e in lst:\\n                    helper[r][c].add(e)\\n                    \\n        \\n        return 0 in helper[-1][-1]\\n                \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\':\\n            return False\\n        if grid[-1][-1] == \\'(\\':\\n            return False\\n        if (m + n) % 2 == 0:\\n            return False\\n        \\n        halfLen = (m + n) // 2\\n        \\n        helper = [[set([]) for _ in range(n)] for _ in range(m)]\\n        helper[0][0].add(1)\\n        \\n        for c in range(1, n):\\n            for e in helper[0][c-1]:\\n                if halfLen >= e + (1 if grid[0][c] == \\'(\\' else -1) >= 0:\\n                    helper[0][c].add(  e + (1 if grid[0][c] == \\'(\\' else -1) )\\n            \\n        for r in range(1, m):\\n            lst = [e + ( 1 if grid[r][0] == \\'(\\' else -1 ) for e in helper[r-1][0] if halfLen >= e + (1 if grid[r][0] == \\'(\\' else -1) >= 0]\\n            for e in lst:\\n                helper[r][0].add(e)\\n            \\n            for c in range(1, n):\\n                lst = [e + ( 1 if grid[r][c] == \\'(\\' else -1 ) for e in helper[r-1][c].union(helper[r][c-1]) if halfLen >= e + (1 if grid[r][c] == \\'(\\' else -1) >= 0]\\n                \\n                for e in lst:\\n                    helper[r][c].add(e)\\n                    \\n        \\n        return 0 in helper[-1][-1]\\n                \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024969,
                "title": "cpp-explanation-99-faster-using-0-1-knapsack-and-dp-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dp[101][101][101]; \\n    // dp[i][j][k] stores the ans at position i,j where the difference between the number of left and the right brackets is k\\n    int vis[101][101][101];\\n    // vis[i][j][k] stores of we ever visit the position i, j where the difference between the number of left and the right brackets is k\\n    int n, m;\\n    bool find(int x, int y, vector<vector<char>>&grid, int l, int r){\\n        if(r > l) return false; // for optimizatin if right brackets if > left bracketthen obviously we can\\'t reach to an ans eg:- ()) \\n        if(l > (n+m-1)/2) return false; // in our final ans l will be equals to (n+m-1)/2 in case it is more than our required value we are on the wrong path\\n        if(vis[x][y][l-r] != -1) return dp[x][y][l-r];  // using memorization\\n        vis[x][y][l-r] = 1; // mark this position as visited\\n        if(x == n-1 && y == m-1){   // if we reach at bottom right\\n            return dp[x][y][l-r] = (l == r);    // return if l==r or not\\n        }\\n        bool ans = false; \\n        if(x != n-1){ // if we can go down then try going down\\n            ans |= find(x+1, y, grid, l + (grid[x+1][y] == \\'(\\'), r + (grid[x+1][y] == \\')\\'));\\n        }\\n        if(ans) return dp[x][y][l-r] = ans; // if we find the ans return true no need to go to the right side now\\n        if(y != m-1){\\n            // in case we do not find the ans go right\\n            ans |= find(x, y+1, grid, l + (grid[x][y+1] == \\'(\\'), r + (grid[x][y+1] == \\')\\'));\\n        }\\n        return dp[x][y][l-r] = ans; //return the ans\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false; // if 1st grid is right bracket then return false;\\n        n = grid.size();\\n        m = grid[0].size();\\n        if((n + m - 1)&1) return false; // if the path contains odd number of grid return false\\n        memset(dp, false, sizeof(dp));\\n        memset(vis, -1, sizeof(vis));\\n        return find(0, 0, grid, 1, 0);  // return the ans\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dp[101][101][101]; \\n    // dp[i][j][k] stores the ans at position i,j where the difference between the number of left and the right brackets is k\\n    int vis[101][101][101];\\n    // vis[i][j][k] stores of we ever visit the position i, j where the difference between the number of left and the right brackets is k\\n    int n, m;\\n    bool find(int x, int y, vector<vector<char>>&grid, int l, int r){\\n        if(r > l) return false; // for optimizatin if right brackets if > left bracketthen obviously we can\\'t reach to an ans eg:- ()) \\n        if(l > (n+m-1)/2) return false; // in our final ans l will be equals to (n+m-1)/2 in case it is more than our required value we are on the wrong path\\n        if(vis[x][y][l-r] != -1) return dp[x][y][l-r];  // using memorization\\n        vis[x][y][l-r] = 1; // mark this position as visited\\n        if(x == n-1 && y == m-1){   // if we reach at bottom right\\n            return dp[x][y][l-r] = (l == r);    // return if l==r or not\\n        }\\n        bool ans = false; \\n        if(x != n-1){ // if we can go down then try going down\\n            ans |= find(x+1, y, grid, l + (grid[x+1][y] == \\'(\\'), r + (grid[x+1][y] == \\')\\'));\\n        }\\n        if(ans) return dp[x][y][l-r] = ans; // if we find the ans return true no need to go to the right side now\\n        if(y != m-1){\\n            // in case we do not find the ans go right\\n            ans |= find(x, y+1, grid, l + (grid[x][y+1] == \\'(\\'), r + (grid[x][y+1] == \\')\\'));\\n        }\\n        return dp[x][y][l-r] = ans; //return the ans\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false; // if 1st grid is right bracket then return false;\\n        n = grid.size();\\n        m = grid[0].size();\\n        if((n + m - 1)&1) return false; // if the path contains odd number of grid return false\\n        memset(dp, false, sizeof(dp));\\n        memset(vis, -1, sizeof(vis));\\n        return find(0, 0, grid, 1, 0);  // return the ans\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024123,
                "title": "java-dp-solution-with-explanation",
                "content": "\\n**Explanation**\\nFor each ceel A[i][j]\\nwe count the number of open parenthese for the path reaching A[i][j].\\nIf it\\'s negative, it\\'s not valid already.\\nFinally we check if there is a path to A[m-1][n-1] that has no open parenthese,\\nthat means a valid parentheses string path reaching A[m-1][n-1].\\n\\n\\n**Optimisation**\\nI usually don\\'t handle edge cases specially,\\nsince they can be correctly handled by itself.\\nAnd usually the short cut only improve edge case, not general case,\\n\\nHere are 3 quick fail case:\\nIf (n + m) % 2 == 0, the length of path to A[m-1][n-1] is odd, can return false.\\nIf A[-1][-1] == \\'(\\', no valid start can return false.\\nIf A[0][0] == \\')\\', no valid end, can return false.\\n\\n```\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```\\n\\nTrick 1:\\nA[i][j][0] for the path count -1,\\nA[i][j][1] for the path count 0, etc.\\nNo need to handle negative specially.\\n\\nTrick 2:\\nUse something like A[i+1] += A[i] instead of A[i] = A[i-1]\\nNo need to handle i == 0 and j == 0 specially.\\n\\nTrick 3:\\ndp[m][n - 1] and dp[m - 1][n] are from dp[m - 1][n - 1],\\nreturn dp[m][n - 1][1] for the result.\\n\\nBy help of @lee215",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public boolean hasValidPath(char[][] A) {\\n        int m = A.length, n = A[0].length;\\n        boolean[][][] dp = new boolean[m + 1][n + 1][103];\\n        dp[0][0][1] = true;\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                for (int k = 1; k <= 101; ++k) {\\n                    dp[i][j + 1][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                    dp[i + 1][j][k] |= dp[i][j][k + (A[i][j] == \\'(\\' ? -1 : 1)];\\n                }\\n        return dp[m][n - 1][1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022808,
                "title": "easy-dfs-java-soln",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        return helper(grid, 0, 0, 0, new Boolean[m][n][m + n]);\\n    }\\n    \\n    private boolean helper(char[][] grid, int i, int j, int bal, Boolean [][][] visit){\\n        if(i >= grid.length || j >= grid[0].length || bal < 0){\\n            return false;\\n        }\\n        \\n        if(visit[i][j][bal] != null){\\n            return visit[i][j][bal];\\n        }\\n        \\n        int updateBal = bal + (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if(i == grid.length - 1 && j == grid[0].length - 1 && updateBal == 0){\\n            return true;\\n        }\\n        \\n        boolean d = helper(grid, i + 1, j, updateBal, visit);\\n        boolean r = helper(grid, i, j + 1, updateBal, visit);\\n        visit[i][j][bal] = d || r;\\n        return d || r;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        return helper(grid, 0, 0, 0, new Boolean[m][n][m + n]);\\n    }\\n    \\n    private boolean helper(char[][] grid, int i, int j, int bal, Boolean [][][] visit){\\n        if(i >= grid.length || j >= grid[0].length || bal < 0){\\n            return false;\\n        }\\n        \\n        if(visit[i][j][bal] != null){\\n            return visit[i][j][bal];\\n        }\\n        \\n        int updateBal = bal + (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if(i == grid.length - 1 && j == grid[0].length - 1 && updateBal == 0){\\n            return true;\\n        }\\n        \\n        boolean d = helper(grid, i + 1, j, updateBal, visit);\\n        boolean r = helper(grid, i, j + 1, updateBal, visit);\\n        visit[i][j][bal] = d || r;\\n        return d || r;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022762,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    HashMap<String, Boolean> mem = new HashMap();\\n    public boolean hasValidPath(char[][] grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    \\n    boolean dfs(char[][] g, int r, int c, int v) {\\n        if (r == g.length-1 && c == g[0].length-1) {\\n            if (g[r][c] == \\'(\\') v++;\\n            else v--;\\n            if (v == 0) return true;\\n            else return false;\\n        } \\n        if (r < 0 || c < 0 || r>g.length-1 || c > g[0].length-1) return false;\\n        \\n        String key = (r * g.length + c) + \"_\" + v;\\n        if (mem.containsKey(key)) return mem.get(key);\\n        boolean ans = false;\\n        if (g[r][c] == \\'(\\') v++;\\n        else {\\n            v--;\\n            if (v < 0) {\\n                mem.put(key, false);\\n                return false;\\n            }\\n        }\\n        ans = ans || dfs(g, r+1,c,v);\\n        ans = ans || dfs(g, r, c+1, v);\\n\\n        mem.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Boolean> mem = new HashMap();\\n    public boolean hasValidPath(char[][] grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    \\n    boolean dfs(char[][] g, int r, int c, int v) {\\n        if (r == g.length-1 && c == g[0].length-1) {\\n            if (g[r][c] == \\'(\\') v++;\\n            else v--;\\n            if (v == 0) return true;\\n            else return false;\\n        } \\n        if (r < 0 || c < 0 || r>g.length-1 || c > g[0].length-1) return false;\\n        \\n        String key = (r * g.length + c) + \"_\" + v;\\n        if (mem.containsKey(key)) return mem.get(key);\\n        boolean ans = false;\\n        if (g[r][c] == \\'(\\') v++;\\n        else {\\n            v--;\\n            if (v < 0) {\\n                mem.put(key, false);\\n                return false;\\n            }\\n        }\\n        ans = ans || dfs(g, r+1,c,v);\\n        ans = ans || dfs(g, r, c+1, v);\\n\\n        mem.put(key, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022322,
                "title": "c-recursion-memoization-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int row, col;\\n    int dp[101][101][202];\\n    \\n    bool solve(vector<vector<char>>& grid, int i, int j, int score){\\n        // if out of grid, return false\\n         if(i >= row || j >= col) return false ;\\n        \\n        // calculate score\\n         if(grid[i][j] == \\'(\\') score++;\\n         else score--;\\n         \\n        // if score is negative than it means that this parentheses is not valid, return false\\n         if(score < 0) return false;\\n        \\n        // if we reach to the destination with score = 0, it is a valid path, return true;\\n         if(i == grid.size() - 1 && j == grid[0].size() - 1 && score == 0){\\n              return true;\\n         }\\n         \\n         // if we already know the answer, return that\\n         if(dp[i][j][score] != -1) return dp[i][j][score];\\n        \\n         // else calulate the answer in moving down, right, and calculate the answer and return\\n         return dp[i][j][score] = solve(grid, i + 1, j , score) || solve(grid, i , j + 1, score);\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n         row = grid.size(), col = grid[0].size();\\n         memset(dp,-1, sizeof(dp));\\n         return  solve(grid, 0,0, 0);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int row, col;\\n    int dp[101][101][202];\\n    \\n    bool solve(vector<vector<char>>& grid, int i, int j, int score){\\n        // if out of grid, return false\\n         if(i >= row || j >= col) return false ;\\n        \\n        // calculate score\\n         if(grid[i][j] == \\'(\\') score++;\\n         else score--;\\n         \\n        // if score is negative than it means that this parentheses is not valid, return false\\n         if(score < 0) return false;\\n        \\n        // if we reach to the destination with score = 0, it is a valid path, return true;\\n         if(i == grid.size() - 1 && j == grid[0].size() - 1 && score == 0){\\n              return true;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2021722,
                "title": "java-maintain-the-number-of-opening-and-closing-the-brackets-and-memoize-it",
                "content": "```\\nclass Solution {\\n    private int R;\\n    private int C;\\n    private int[][][] dp;\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        \\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        this.dp = new int[R+1][C+1][201];\\n        \\n        for(int[][] i : dp){\\n            for(int[] j : i){\\n                Arrays.fill(j, -1);\\n            }\\n        }\\n        \\n        if(find(0, 0, 0, 0, grid)) return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean find(int r, int c, int left, int right, char[][] grid){\\n        if(r < 0 || r >= R ||c < 0 || c >= C){\\n            return false;\\n        }\\n        \\n        if(grid[r][c] == \\'(\\'){\\n            left++;\\n        }else right++;\\n        \\n        if(left == right && r == R-1 && c == C-1){\\n            return true;\\n        }\\n        \\n        // System.out.println(r + \" \" + c + \" \" + left + \" \" + right + \" \");\\n        if(left >= right){\\n            if(dp[r][c][left-right] != -1){\\n                return dp[r][c][left-right] == 1 ? true : false;\\n            }\\n        }else return false;\\n        \\n        \\n        boolean isPossible = false;\\n        isPossible = find(r, c+1, left, right, grid) || find(r+1, c, left, right, grid);\\n        dp[r][c][left-right] = isPossible ==  true ? 1 : 0;\\n        \\n        return isPossible;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int R;\\n    private int C;\\n    private int[][][] dp;\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        \\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        this.dp = new int[R+1][C+1][201];\\n        \\n        for(int[][] i : dp){\\n            for(int[] j : i){\\n                Arrays.fill(j, -1);\\n            }\\n        }\\n        \\n        if(find(0, 0, 0, 0, grid)) return true;\\n        \\n        return false;\\n    }\\n    \\n    private boolean find(int r, int c, int left, int right, char[][] grid){\\n        if(r < 0 || r >= R ||c < 0 || c >= C){\\n            return false;\\n        }\\n        \\n        if(grid[r][c] == \\'(\\'){\\n            left++;\\n        }else right++;\\n        \\n        if(left == right && r == R-1 && c == C-1){\\n            return true;\\n        }\\n        \\n        // System.out.println(r + \" \" + c + \" \" + left + \" \" + right + \" \");\\n        if(left >= right){\\n            if(dp[r][c][left-right] != -1){\\n                return dp[r][c][left-right] == 1 ? true : false;\\n            }\\n        }else return false;\\n        \\n        \\n        boolean isPossible = false;\\n        isPossible = find(r, c+1, left, right, grid) || find(r+1, c, left, right, grid);\\n        dp[r][c][left-right] = isPossible ==  true ? 1 : 0;\\n        \\n        return isPossible;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020033,
                "title": "go-dp",
                "content": "```\\nvar dp[101][101][110]bool\\n\\nfunc hasValidPath(a [][]byte) bool {\\n    if a[0][0] == \\')\\' {\\n        return false\\n    }\\n    \\n    var n, m int = len(a), len(a[0])\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            for k := 0; k < 101; k++ {\\n                dp[i][j][k] = false\\n            }\\n        }\\n    }\\n    \\n    dp[0][0][1] = true\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if i - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open + 1]\\n                    }\\n                }\\n            }\\n            if j - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open + 1]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n - 1][m - 1][0]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar dp[101][101][110]bool\\n\\nfunc hasValidPath(a [][]byte) bool {\\n    if a[0][0] == \\')\\' {\\n        return false\\n    }\\n    \\n    var n, m int = len(a), len(a[0])\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            for k := 0; k < 101; k++ {\\n                dp[i][j][k] = false\\n            }\\n        }\\n    }\\n    \\n    dp[0][0][1] = true\\n    for i := 0; i < n; i++ {\\n        for j := 0; j < m; j++ {\\n            if i - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i - 1][j][open + 1]\\n                    }\\n                }\\n            }\\n            if j - 1 >= 0 {\\n                if a[i][j] == \\'(\\' {\\n                    for open := 1; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open - 1]\\n                    }\\n                } else {\\n                    for open := 0; open < 105; open ++ {\\n                        dp[i][j][open] = dp[i][j][open] || dp[i][j - 1][open + 1]\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    return dp[n - 1][m - 1][0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019810,
                "title": "python3-dfs-solution",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\': return False\\n        \\n        RC = [len(grid), len(grid[0])]\\n        seen = set()\\n        result = [False]\\n        \\n        def dfs(x, y, balance, seen):\\n            if result[0] == True: return\\n            R, C = RC[0], RC[1]\\n            \\n            if x == R - 1 and y == C - 1 and balance == 0:\\n                result[0] = True\\n                return\\n            \\n            for d in [[0,1], [1,0]]:\\n                new_x, new_y = x + d[0], y + d[1]\\n                \\n                if 0<=new_x<R and 0<=new_y<C:\\n                    \\n                    if grid[new_x][new_y] != \\'#\\':\\n                        prev_balance = balance\\n                        balance += 1 if grid[new_x][new_y] == \\'(\\' else -1\\n                        \\n                        if balance > -1 and balance < (R + C) // 2 + 1:\\n\\n                            if (new_x, new_y, balance) not in seen:\\n                                seen.add((new_x, new_y, balance))\\n                                \\n                                temp = grid[new_x][new_y]\\n                                grid[new_x][new_y] = \\'#\\'\\n                                dfs(new_x, new_y, balance, seen)\\n                                grid[new_x][new_y] = temp\\n                        \\n                        balance = prev_balance\\n        \\n        grid[0][0] = \\'#\\'\\n        seen.add((0,0,1))\\n        dfs(0, 0, 1, seen)\\n        \\n        return result[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\': return False\\n        \\n        RC = [len(grid), len(grid[0])]\\n        seen = set()\\n        result = [False]\\n        \\n        def dfs(x, y, balance, seen):\\n            if result[0] == True: return\\n            R, C = RC[0], RC[1]\\n            \\n            if x == R - 1 and y == C - 1 and balance == 0:\\n                result[0] = True\\n                return\\n            \\n            for d in [[0,1], [1,0]]:\\n                new_x, new_y = x + d[0], y + d[1]\\n                \\n                if 0<=new_x<R and 0<=new_y<C:\\n                    \\n                    if grid[new_x][new_y] != \\'#\\':\\n                        prev_balance = balance\\n                        balance += 1 if grid[new_x][new_y] == \\'(\\' else -1\\n                        \\n                        if balance > -1 and balance < (R + C) // 2 + 1:\\n\\n                            if (new_x, new_y, balance) not in seen:\\n                                seen.add((new_x, new_y, balance))\\n                                \\n                                temp = grid[new_x][new_y]\\n                                grid[new_x][new_y] = \\'#\\'\\n                                dfs(new_x, new_y, balance, seen)\\n                                grid[new_x][new_y] = temp\\n                        \\n                        balance = prev_balance\\n        \\n        grid[0][0] = \\'#\\'\\n        seen.add((0,0,1))\\n        dfs(0, 0, 1, seen)\\n        \\n        return result[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019487,
                "title": "simple-dfs-memo",
                "content": "We will create a valid variable to see if the current path is valid or not .\\nIf valid variable is positive it means we have more open bracket and hence we can close it but if it becomes negative at any point means close bracket are more and hence path is invalid.\\n\\nWe have a 3d dp of 3 variables row column and valid.\\n\\n```\\nint n,m;\\n    int dp[102][102][201];\\n    bool f(vector<vector<char>>&grid,int i,int j,int valid)\\n    {\\n        if(i<0 or i>=n or j<0 or j>=m)return false;\\n        if(grid[i][j]==\\'(\\')valid++;\\n        else valid--;\\n        if(valid<0)return false;\\n        if(i==n-1 and j==m-1)return valid==0;//we have reached the end see if valid= =0 means open==close bracket\\n        if(dp[i][j][valid]!=-1)\\n        {\\n            return dp[i][j][valid]==1;\\n        }\\n        return dp[i][j][valid]=f(grid,i+1,j,valid) or f(grid,i,j+1,valid);\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        n=grid.size();\\n        m=grid[0].size();\\n        return f(grid,0,0,0);   \\n    }\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint n,m;\\n    int dp[102][102][201];\\n    bool f(vector<vector<char>>&grid,int i,int j,int valid)\\n    {\\n        if(i<0 or i>=n or j<0 or j>=m)return false;\\n        if(grid[i][j]==\\'(\\')valid++;\\n        else valid--;\\n        if(valid<0)return false;\\n        if(i==n-1 and j==m-1)return valid==0;//we have reached the end see if valid= =0 means open==close bracket\\n        if(dp[i][j][valid]!=-1)\\n        {\\n            return dp[i][j][valid]==1;\\n        }\\n        return dp[i][j][valid]=f(grid,i+1,j,valid) or f(grid,i,j+1,valid);\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        n=grid.size();\\n        m=grid[0].size();\\n        return f(grid,0,0,0);   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018832,
                "title": "clean-python-solution",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        @cache\\n        \\n        def helper(i,j,cnt):\\n            if i<0 or j<0:\\n                return False\\n            \\n            if i==0 and j==0:\\n                if grid[i][j]==\"(\":\\n                    cnt-=1\\n                else:\\n                    cnt+=1\\n                return cnt==0\\n                \\n            \\n            if grid[i][j]==\")\":\\n                cnt+=1\\n            else:\\n                cnt-=1\\n                if cnt<0:\\n                    return False\\n                    \\n            \\n            return helper(i-1,j,cnt) or helper(i,j-1,cnt)\\n        \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        return helper(m-1,n-1,0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        @cache\\n        \\n        def helper(i,j,cnt):\\n            if i<0 or j<0:\\n                return False\\n            \\n            if i==0 and j==0:\\n                if grid[i][j]==\"(\":\\n                    cnt-=1\\n                else:\\n                    cnt+=1\\n                return cnt==0\\n                \\n            \\n            if grid[i][j]==\")\":\\n                cnt+=1\\n            else:\\n                cnt-=1\\n                if cnt<0:\\n                    return False\\n                    \\n            \\n            return helper(i-1,j,cnt) or helper(i,j-1,cnt)\\n        \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        return helper(m-1,n-1,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018364,
                "title": "java-dfs-memo-vs-dp-with-explanation",
                "content": "Share two approaches:\\n- DFS + memo (top-down)\\n- DP (bottom-up)\\n\\n#### DFS + memo\\n##### Steps\\n1. Track the `bal` to check if the path is valid\\n2. When `bal < 0`, prune it\\n3. If the `bal == 0` in the bottom-right corner, we find the valid path\\n\\nuse `memo` to enhance the performance.\\n\\n##### Solution\\n- time complexity: `O(mn(m+n))`\\n- space complexity: `O(mn(m+n))`\\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    Boolean[][][] memo = new Boolean[m][n][m + n];\\n    return dfs(grid, 0, 0, 0, memo);\\n}\\n\\nboolean dfs(char[][] grid, int i, int j, int bal, Boolean[][][] memo) {\\n    int m = grid.length, n = grid[0].length;\\n    if (i < 0 || i >= m || j < 0 || j >= n || bal < 0) return false;\\n    int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (i == m - 1 && j == n - 1 && bal + cur == 0) return true;\\n\\n    if (memo[i][j][bal] != null) return memo[i][j][bal];\\n    boolean valid = dfs(grid, i + 1, j, bal + cur, memo) || dfs(grid, i, j + 1, bal + cur, memo);\\n\\n    if (valid) memo[i][j][bal] = true;\\n    else memo[i][j][bal] = false;\\n    return valid;\\n}\\n```\\n------\\n#### DP\\n##### Steps\\n1. For every `grid[i][j]`, we track all possible `bal` \\n2. If the left or top of current grid has balance `bal`, then the current grid can have `bal +- 1` depends on the current grid is `(` or `)`\\n  Fomular is: \\n  ```\\n  grid[i][j][bal] = grid[i-1][j][bal-cur] || grid[i][j-1][bal-cur] where cur = grid[i][j] == 1 ? 1 : 0\\n  ```\\n3. If the `bal < 0`, prune it\\n4. If the `bal == 0` in the bottom-right corner, we find the valid path\\n\\nNote:\\nWe can implement it use 2D set or 3D array to track the balance\\n\\n##### Solution (2D Set)\\n- time complexity: `O(mn(m+n))`\\n- space complexity: `O(mn(m+n))`\\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] directions = new int[][]{{-1, 0}, {0, -1}};\\n\\n    Set<Integer>[][] dp = new HashSet[m][n];\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = new HashSet<>();\\n        }\\n    }\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int[] d : directions) {\\n                int x = i + d[0], y = j + d[1];\\n                if (x < 0 || y < 0) continue;\\n\\n                for (int bal : dp[x][y]) {\\n                    bal += cur;\\n                    if (bal < 0) continue;\\n                    dp[i][j].add(bal);\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1].contains(0);\\n}\\n```\\n\\n##### Solution (3D Array)\\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = new int[][]{{-1, 0}, {0, -1}};\\n    boolean[][][] dp = new boolean[m][n][m + n + 1];\\n\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0][1] = true;\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int bal = 0; bal < m + n; bal++) {\\n                if (i > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i - 1][j][bal - cur];\\n                }\\n                if (j > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i][j - 1][bal - cur];\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1][0];\\n}\\n```\\n\\nPleaes let me know if this explanation is helpful for you, thanks!",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    Boolean[][][] memo = new Boolean[m][n][m + n];\\n    return dfs(grid, 0, 0, 0, memo);\\n}\\n\\nboolean dfs(char[][] grid, int i, int j, int bal, Boolean[][][] memo) {\\n    int m = grid.length, n = grid[0].length;\\n    if (i < 0 || i >= m || j < 0 || j >= n || bal < 0) return false;\\n    int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n    if (i == m - 1 && j == n - 1 && bal + cur == 0) return true;\\n\\n    if (memo[i][j][bal] != null) return memo[i][j][bal];\\n    boolean valid = dfs(grid, i + 1, j, bal + cur, memo) || dfs(grid, i, j + 1, bal + cur, memo);\\n\\n    if (valid) memo[i][j][bal] = true;\\n    else memo[i][j][bal] = false;\\n    return valid;\\n}\\n```\n```\\n  grid[i][j][bal] = grid[i-1][j][bal-cur] || grid[i][j-1][bal-cur] where cur = grid[i][j] == 1 ? 1 : 0\\n  ```\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] directions = new int[][]{{-1, 0}, {0, -1}};\\n\\n    Set<Integer>[][] dp = new HashSet[m][n];\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            dp[i][j] = new HashSet<>();\\n        }\\n    }\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0].add(1);\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int[] d : directions) {\\n                int x = i + d[0], y = j + d[1];\\n                if (x < 0 || y < 0) continue;\\n\\n                for (int bal : dp[x][y]) {\\n                    bal += cur;\\n                    if (bal < 0) continue;\\n                    dp[i][j].add(bal);\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1].contains(0);\\n}\\n```\n```java\\npublic boolean hasValidPath(char[][] grid) {\\n    int m = grid.length, n = grid[0].length;\\n    int[][] dirs = new int[][]{{-1, 0}, {0, -1}};\\n    boolean[][][] dp = new boolean[m][n][m + n + 1];\\n\\n\\n    if (grid[0][0] == \\'(\\') dp[0][0][1] = true;\\n\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            int cur = grid[i][j] == \\'(\\' ? 1 : -1;\\n            for (int bal = 0; bal < m + n; bal++) {\\n                if (i > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i - 1][j][bal - cur];\\n                }\\n                if (j > 0 && bal - cur >= 0) {\\n                    dp[i][j][bal] |= dp[i][j - 1][bal - cur];\\n                }\\n            }\\n        }\\n    }\\n    return dp[m-1][n-1][0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018333,
                "title": "too-tight-bounds-tle-for-same-complexity-solutions",
                "content": "```\\nclass Solution {\\nprivate: \\n    unordered_map<int, unordered_map<int, unordered_map<int, int>>> dp;\\n    int r, c;\\n    bool valid(int x, int y, int dif, vector<vector<char>> &grid) {\\n        if (x < 0 || y < 0 || x >= r || y >= c) return false;\\n        if (grid[x][y] == \\'(\\') dif++;\\n        else dif--;\\n        if (dif < 0 || dif > (r + c) / 2)    return false;\\n        if (x == r - 1 && y == c - 1 && !dif)   return true;\\n        if (dp[x][y].find(dif) != dp[x][y].end())    return dp[x][y][dif];\\n        return dp[x][y][dif] = valid(x, y + 1, dif, grid) || valid(x + 1, y, dif, grid);\\n        \\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size(), c = grid[0].size();\\n        return valid(0, 0, 0, grid);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate: \\n    unordered_map<int, unordered_map<int, unordered_map<int, int>>> dp;\\n    int r, c;\\n    bool valid(int x, int y, int dif, vector<vector<char>> &grid) {\\n        if (x < 0 || y < 0 || x >= r || y >= c) return false;\\n        if (grid[x][y] == \\'(\\') dif++;\\n        else dif--;\\n        if (dif < 0 || dif > (r + c) / 2)    return false;\\n        if (x == r - 1 && y == c - 1 && !dif)   return true;\\n        if (dp[x][y].find(dif) != dp[x][y].end())    return dp[x][y][dif];\\n        return dp[x][y][dif] = valid(x, y + 1, dif, grid) || valid(x + 1, y, dif, grid);\\n        \\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        r = grid.size(), c = grid[0].size();\\n        return valid(0, 0, 0, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018259,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[102][102][204];\\n    int f(int r, int c, int o1, int o2, int n, int m, vector<vector<char>>& g){\\n        if(o1<o2){\\n         return 0;\\n        }\\n        if(dp[r][c][o1-o2]!=-1)return dp[r][c][o1-o2];\\n        int val = 0;\\n        if(r<n-1){\\n            val = val || f(r+1, c, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(c<m-1){\\n            val = val || f(r, c+1, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(r==n-1 && c == m-1){\\n            return o1 + (g[r][c] == \\'(\\') == o2 +( g[r][c] == \\')\\');\\n        }\\n        return dp[r][c][o1-o2] = val;     \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,0,0,n,m, grid);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[102][102][204];\\n    int f(int r, int c, int o1, int o2, int n, int m, vector<vector<char>>& g){\\n        if(o1<o2){\\n         return 0;\\n        }\\n        if(dp[r][c][o1-o2]!=-1)return dp[r][c][o1-o2];\\n        int val = 0;\\n        if(r<n-1){\\n            val = val || f(r+1, c, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(c<m-1){\\n            val = val || f(r, c+1, o1 + (g[r][c] == \\'(\\'), o2 + (g[r][c] == \\')\\'), n, m, g);\\n        }\\n        if(r==n-1 && c == m-1){\\n            return o1 + (g[r][c] == \\'(\\') == o2 +( g[r][c] == \\')\\');\\n        }\\n        return dp[r][c][o1-o2] = val;     \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return f(0,0,0,0,n,m, grid);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018247,
                "title": "python-simple-but-slow-using-bfs",
                "content": "```python\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Three quick failure cases\\n        if grid[0][0]==\")\": return False\\n        if grid[-1][-1]==\"(\": return False\\n        if (m+n)%2==0: return False\\n        \\n        # Let\\'s start!\\n        queue=[(0,0,1)] # row, col, acc.sum (must be 0 at the destination); assuming that \"(\"=1 and \")\"=-1\\n        visited=set()\\n        visited.add((0,0,1))\\n        while(queue):\\n            row, col, acc_sum = queue.pop(0)\\n            if row==m-1 and col==n-1 and acc_sum==0:\\n                return True\\n            \\n            # move down\\n            if row < m-1:\\n                next_item=1 if grid[row+1][col]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row+1, col, next_sum) not in visited:\\n                    queue.append((row+1, col, next_sum))\\n                    visited.add((row+1, col, next_sum))\\n            \\n            # move right\\n            if col < n-1:\\n                next_item=1 if grid[row][col+1]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row, col+1, next_sum) not in visited:\\n                    queue.append((row, col+1, next_sum))\\n                    visited.add((row, col+1, next_sum))\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        # Three quick failure cases\\n        if grid[0][0]==\")\": return False\\n        if grid[-1][-1]==\"(\": return False\\n        if (m+n)%2==0: return False\\n        \\n        # Let\\'s start!\\n        queue=[(0,0,1)] # row, col, acc.sum (must be 0 at the destination); assuming that \"(\"=1 and \")\"=-1\\n        visited=set()\\n        visited.add((0,0,1))\\n        while(queue):\\n            row, col, acc_sum = queue.pop(0)\\n            if row==m-1 and col==n-1 and acc_sum==0:\\n                return True\\n            \\n            # move down\\n            if row < m-1:\\n                next_item=1 if grid[row+1][col]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row+1, col, next_sum) not in visited:\\n                    queue.append((row+1, col, next_sum))\\n                    visited.add((row+1, col, next_sum))\\n            \\n            # move right\\n            if col < n-1:\\n                next_item=1 if grid[row][col+1]==\"(\" else -1\\n                next_sum = acc_sum+next_item\\n                if next_sum>=0 and (row, col+1, next_sum) not in visited:\\n                    queue.append((row, col+1, next_sum))\\n                    visited.add((row, col+1, next_sum))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018234,
                "title": "c-dp-recursive-memoization-full-explanation-o-nm-n-m",
                "content": "Before to explain my solution, let\\'s solve a simpler problem.\\n\\nHow to check if a parenthesis string is balanced, well this is a classic problem that can be solved using a stack but let\\'s try another approach.\\n\\nWe are going to maintain a int variable initialize with zero and traverse the string from left to right and for each character:\\n\\n* if the current char is \\'(\\' we add +1\\n* if the current char is \\')\\' we add -1\\n\\nIf at some point the sum becomes negative then the string is not balanced, also at the end the total sum needs to be zero (try different examples to convince you that is true).\\n\\nNow using this knowledge how can solve the problem?\\n\\nWe can use a dp approach similar to other grid problems for example [62. Unique Paths](https://leetcode.com/problems/unique-paths/)\\n\\ndp(i, j, s) = the path that finish at position (i, j) with sum s\\n\\nAs i stated before if the sum is negative we can return false, the other states are\\n\\n    dp(n - 1, m - 1, s) = if s == 0 return true otherwise false // Base case\\n    dp(i, j, s) = dp(i + 1, j, s + value of char in new position) or dp(i, j + 1, s + s + value of char in new position) // general case\\n\\nFinally, how many different states exist? i goes from [0, n) and j goes from [0, m) but the case of s is tricky, if you notice because only are allowed to move down or right the size of any path is n + m, this is more clear in the following example:\\n\\n![image](https://assets.leetcode.com/users/images/f84d5c25-68ae-4cc3-9b27-54e5db39556e_1651986492.763448.png)\\n\\nThen our final complexity is O(nm(n + m)).\\n\\nHere is my code:\\n```cpp\\nclass Solution {\\n    \\n    int n, m, memo[102][102][205];\\n\\n    int dp(vector<vector<char>>& grid, int i, int j, int sum) {\\n        if (i == n - 1 and j == m - 1) // Reach the final position\\n\\t\\t\\treturn (sum == 0); \\n        if (sum < 0) return false;\\n        if (memo[i][j][sum] != -1) return memo[i][j][sum];\\n\\t\\t\\n        if (i == n - 1 and j != m - 1) // Last row\\n            return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1));\\n        if (i != n - 1 and j == m - 1) // Lats column\\n            return memo[i][j][sum] = dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n\\t\\t\\t\\n        return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1)) or dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n    }\\n    \\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {        \\n        n = grid.size();\\n        m = grid[0].size();\\n        memset(memo, -1, sizeof(memo));\\n        return dp(grid, 0, 0, grid[0][0] == \\'(\\' ? 1 : -1);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int n, m, memo[102][102][205];\\n\\n    int dp(vector<vector<char>>& grid, int i, int j, int sum) {\\n        if (i == n - 1 and j == m - 1) // Reach the final position\\n\\t\\t\\treturn (sum == 0); \\n        if (sum < 0) return false;\\n        if (memo[i][j][sum] != -1) return memo[i][j][sum];\\n\\t\\t\\n        if (i == n - 1 and j != m - 1) // Last row\\n            return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1));\\n        if (i != n - 1 and j == m - 1) // Lats column\\n            return memo[i][j][sum] = dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n\\t\\t\\t\\n        return memo[i][j][sum] = dp(grid, i, j + 1, sum + (grid[i][j + 1] == \\'(\\'? 1 : -1)) or dp(grid, i + 1, j, sum + (grid[i + 1][j] == \\'(\\' ? 1 : -1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2018101,
                "title": "javascript-dfs",
                "content": "```js\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nconst hasValidPath = function (grid) {\\n  const memo = {}\\n  const dfs = (row, col, diff) => {\\n    const key = `${row}-${col}-${diff}`\\n    if (memo[key] !== undefined) {\\n      return memo[key]\\n    }\\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length) {\\n      return false\\n    }\\n    if (grid[row][col] === \\'(\\') {\\n      diff += 1\\n    } else {\\n      diff -= 1\\n    }\\n    if (diff < 0) {\\n      return false\\n    }\\n    if (row === grid.length - 1 && col === grid[row].length - 1 && diff === 0) {\\n      return true\\n    }\\n    let result = false\\n\\n    result = result || dfs(row + 1, col, diff)\\n    result = result || dfs(row, col + 1, diff)\\n    memo[key] = result\\n    return result\\n  }\\n  return dfs(0, 0, 0, 0)\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nconst hasValidPath = function (grid) {\\n  const memo = {}\\n  const dfs = (row, col, diff) => {\\n    const key = `${row}-${col}-${diff}`\\n    if (memo[key] !== undefined) {\\n      return memo[key]\\n    }\\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[row].length) {\\n      return false\\n    }\\n    if (grid[row][col] === \\'(\\') {\\n      diff += 1\\n    } else {\\n      diff -= 1\\n    }\\n    if (diff < 0) {\\n      return false\\n    }\\n    if (row === grid.length - 1 && col === grid[row].length - 1 && diff === 0) {\\n      return true\\n    }\\n    let result = false\\n\\n    result = result || dfs(row + 1, col, diff)\\n    result = result || dfs(row, col + 1, diff)\\n    memo[key] = result\\n    return result\\n  }\\n  return dfs(0, 0, 0, 0)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2018011,
                "title": "java-3d-dp",
                "content": "```\\nclass Solution {\\n    int counter = 0;\\n    Boolean[][][] dp = new Boolean[101][101][201];\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length-1;\\n        int col = grid[0].length-1;\\n        if(grid[0][0] !=\\'(\\' || grid[row][col] != \\')\\'){\\n            return false;\\n        }\\n        boolean res =  helper(grid, 0, 0, 0, 0, row, col);\\n        return res;\\n    }\\n    \\n    public boolean helper(char[][] grid, int i, int j, int open, int close, int row, int col){\\n        if(i<0 || j < 0 || i>row || j > col){\\n            \\n            return false;\\n        }\\n        else if((i==row) && (j==col) && (open==close+1)){\\n            dp[i][j][open - close] = true;\\n            return true;\\n        }\\n        else if(dp[i][j][open - close] != null){\\n            return dp[i][j][open - close];\\n        }\\n        else if(grid[i][j] == \\'(\\'){\\n            boolean res =  helper(grid, i+1, j, open+1, close, row, col) || helper(grid, i, j+1, open+1, close, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else if( (open > close) && (grid[i][j] == \\')\\')){\\n            boolean res = helper(grid, i+1, j, open, close+1, row, col) || helper(grid, i, j+1, open, close+1, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else{\\n            dp[i][j][open-close] = false;\\n            return false;\\n        }\\n\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int counter = 0;\\n    Boolean[][][] dp = new Boolean[101][101][201];\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length-1;\\n        int col = grid[0].length-1;\\n        if(grid[0][0] !=\\'(\\' || grid[row][col] != \\')\\'){\\n            return false;\\n        }\\n        boolean res =  helper(grid, 0, 0, 0, 0, row, col);\\n        return res;\\n    }\\n    \\n    public boolean helper(char[][] grid, int i, int j, int open, int close, int row, int col){\\n        if(i<0 || j < 0 || i>row || j > col){\\n            \\n            return false;\\n        }\\n        else if((i==row) && (j==col) && (open==close+1)){\\n            dp[i][j][open - close] = true;\\n            return true;\\n        }\\n        else if(dp[i][j][open - close] != null){\\n            return dp[i][j][open - close];\\n        }\\n        else if(grid[i][j] == \\'(\\'){\\n            boolean res =  helper(grid, i+1, j, open+1, close, row, col) || helper(grid, i, j+1, open+1, close, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else if( (open > close) && (grid[i][j] == \\')\\')){\\n            boolean res = helper(grid, i+1, j, open, close+1, row, col) || helper(grid, i, j+1, open, close+1, row, col);\\n            dp[i][j][open - close] = res;\\n            return res;\\n        }\\n        else{\\n            dp[i][j][open-close] = false;\\n            return false;\\n        }\\n\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018007,
                "title": "dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int vis[101][101][200], n, m;\\n    bool possible = 0;\\n    int fx[2] = {+1, +0};\\n    int fy[2] = {+0, +1};\\n    \\n    void dfs(int x, int y, int cum, vector<vector<char>>& grid) {  \\n        if (possible) return;\\n        vis[x][y][cum] = true;\\n        int sum = cum + (grid[x][y] == \\'(\\' ? 1 : -1);\\n        \\n        if (sum < 0) return ;\\n        \\n        if (x == n - 1 && y == m - 1) {\\n            possible |= (sum == 0);\\n            return ;\\n        }\\n                      \\n        for (int i = 0; i < 2; i++) {\\n            int nx = x + fx[i];\\n            int ny = y + fy[i];\\n            if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\\n            if (!vis[nx][ny][sum]) {\\n                dfs(nx, ny, sum, grid);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dfs(0, 0, 0, grid);\\n        return possible;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[101][101][200], n, m;\\n    bool possible = 0;\\n    int fx[2] = {+1, +0};\\n    int fy[2] = {+0, +1};\\n    \\n    void dfs(int x, int y, int cum, vector<vector<char>>& grid) {  \\n        if (possible) return;\\n        vis[x][y][cum] = true;\\n        int sum = cum + (grid[x][y] == \\'(\\' ? 1 : -1);\\n        \\n        if (sum < 0) return ;\\n        \\n        if (x == n - 1 && y == m - 1) {\\n            possible |= (sum == 0);\\n            return ;\\n        }\\n                      \\n        for (int i = 0; i < 2; i++) {\\n            int nx = x + fx[i];\\n            int ny = y + fy[i];\\n            if (nx < 0 || ny < 0 || nx >= n || ny >= m) continue;\\n            if (!vis[nx][ny][sum]) {\\n                dfs(nx, ny, sum, grid);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size();\\n        m = grid[0].size();\\n        dfs(0, 0, 0, grid);\\n        return possible;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017880,
                "title": "c-dp-solution-easy-to-understand",
                "content": "```\\nint dp[100][100][101];\\n    bool findans(int x,int y,vector<vector<char> >&grid,int all){\\n        if(x==grid.size()-1&&y==grid[0].size()-1){\\n            if(all==-1){\\n                return false;\\n            }\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            if(all+add==0){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(all<0){\\n            return false;\\n        }\\n        if(all>100){\\n            return false;\\n        }\\n        if(dp[x][y][all]!=-1){\\n            return dp[x][y][all];\\n        }\\n        // cout<<all<<\" \"<<x<<\" \"<<y<<endl;\\n        bool ans=false,ans2=false;\\n        if(x+1<grid.size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n           ans=findans(x+1,y,grid,all+add); \\n        }\\n        if(ans)return dp[x][y][all]= true;\\n        if(y+1<grid[0].size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            ans=findans(x,y+1,grid,all+add); \\n        }\\n        return dp[x][y][all]=ans;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return findans(0,0,grid,0);\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint dp[100][100][101];\\n    bool findans(int x,int y,vector<vector<char> >&grid,int all){\\n        if(x==grid.size()-1&&y==grid[0].size()-1){\\n            if(all==-1){\\n                return false;\\n            }\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            if(all+add==0){\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(all<0){\\n            return false;\\n        }\\n        if(all>100){\\n            return false;\\n        }\\n        if(dp[x][y][all]!=-1){\\n            return dp[x][y][all];\\n        }\\n        // cout<<all<<\" \"<<x<<\" \"<<y<<endl;\\n        bool ans=false,ans2=false;\\n        if(x+1<grid.size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n           ans=findans(x+1,y,grid,all+add); \\n        }\\n        if(ans)return dp[x][y][all]= true;\\n        if(y+1<grid[0].size()){\\n            int add=(grid[x][y]==\\'(\\'?1:-1);\\n            ans=findans(x,y+1,grid,all+add); \\n        }\\n        return dp[x][y][all]=ans;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        memset(dp,-1,sizeof(dp));\\n        return findans(0,0,grid,0);\\n    }\\n\\t```",
                "codeTag": "C++"
            },
            {
                "id": 2017845,
                "title": "python3-dp",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/9aa0edb0815f3e0a75a47808e1690ca424f169e5) for solutions of weekly 292. \\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def fn(i, j, v): \\n            \"\"\"Return True if value of v at (i, j) is possible.\"\"\"\\n            if i == m-1 and j == n-1: return v == 0 \\n            for ii, jj in (i+1, j), (i, j+1): \\n                if 0 <= ii < m and 0 <= jj < n: \\n                    if grid[ii][jj] == \\'(\\': vv = v+1\\n                    else: vv = v-1\\n                    if 0 <= vv <= min(ii+jj+1, m+n-ii-jj) and fn(ii, jj, vv): return True \\n            return False \\n        \\n        return fn(0, 0, 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def fn(i, j, v): \\n            \"\"\"Return True if value of v at (i, j) is possible.\"\"\"\\n            if i == m-1 and j == n-1: return v == 0 \\n            for ii, jj in (i+1, j), (i, j+1): \\n                if 0 <= ii < m and 0 <= jj < n: \\n                    if grid[ii][jj] == \\'(\\': vv = v+1\\n                    else: vv = v-1\\n                    if 0 <= vv <= min(ii+jj+1, m+n-ii-jj) and fn(ii, jj, vv): return True \\n            return False \\n        \\n        return fn(0, 0, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017770,
                "title": "recursion-memorization-c",
                "content": "```\\nclass Solution {\\nprivate:\\n    int dp[101][101][502];\\npublic:\\n    bool solve(int i,int j,vector<vector<char>> &grid,int close){\\n        if(i < 0 or j < 0 or i >= grid.size() or j >= grid[0].size()) return false;\\n        if(close < 0) return false;\\n        if(i == grid.size()-1 and j == grid[0].size()-1){\\n            close += grid[i][j] == \\')\\' ? -1 : 1;\\n            return close == 0;\\n        }\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        int new_close = grid[i][j] == \\')\\' ? close - 1 : close + 1;\\n        \\n        bool op1 = solve(i+1,j,grid,new_close);\\n        bool op2 = solve(i,j+1,grid,new_close);\\n        \\n        return dp[i][j][close] = (op1 or op2);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false;\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,0,grid,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dp[101][101][502];\\npublic:\\n    bool solve(int i,int j,vector<vector<char>> &grid,int close){\\n        if(i < 0 or j < 0 or i >= grid.size() or j >= grid[0].size()) return false;\\n        if(close < 0) return false;\\n        if(i == grid.size()-1 and j == grid[0].size()-1){\\n            close += grid[i][j] == \\')\\' ? -1 : 1;\\n            return close == 0;\\n        }\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        int new_close = grid[i][j] == \\')\\' ? close - 1 : close + 1;\\n        \\n        bool op1 = solve(i+1,j,grid,new_close);\\n        bool op2 = solve(i,j+1,grid,new_close);\\n        \\n        return dp[i][j][close] = (op1 or op2);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\') return false;\\n        memset(dp,-1,sizeof dp);\\n        return solve(0,0,grid,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2017763,
                "title": "why-recursion-is-not-working",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0]==\\')\\') return false;\\n        return path(grid,0,1,1)||path(grid,1,0,1);\\n    }\\n    public boolean path(char[][] grid,int i,int j,int cnt)\\n    {\\n        if(i>=grid.length || j>=grid[0].length) return false;\\n        if(grid[i][j]==\\')\\') cnt--;\\n        else cnt++;\\n        if(cnt<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1)\\n        {\\n            if(cnt!=0)return false;\\n            return true;\\n        }\\n        return path(grid,i+1,j,cnt)||path(grid,i,j+1,cnt);\\n    }\\n}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0]==\\')\\') return false;\\n        return path(grid,0,1,1)||path(grid,1,0,1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2017724,
                "title": "python-clean-top-down-dp-with-explanation-t-o-mn-m-n",
                "content": "A pretty straightforward while naive solution for this kind of problem would be traversing and backtracking. But since `1 <= m, n <= 100`, the naive solution has `T = O(comb(m + n - 2, m - 1))` worst-case time complexity, which is `comb(198, 99) > 2^193` in the case. That is certainly unbearable.\\n\\nWe can improve it hugely by using Dynamic Programming techniques.\\n\\nThe `DP(x, y, open_left_parentheses)` implies whether there is a valid Parentheses String Path starting from the pos `(x, y)` with some `open_left_parentheses`. \\n\\nAt every DP step, we examine the character at `grid[x][y]`:\\n\\n- If the current parenthesis is left `(`, we just increment the `open_left_parentheses` count by 1.\\n- If the current parenthesis is left `)`, we check if there are already some open left parentheses on the path so far.\\n  - If there is open `(`, we decrement the `open_left_parentheses` count by 1 to indicate the match of a pair of parentheses.\\n  - Otherwise, the current path is determined to be invalid (e.g. `)`, `()())`).\\n\\nThen we try moving downwards or rightwards if the next step is in still within borders. The DP function returns true if and only if **either** of the two direction could lead to a valid path.\\n\\n**Code:**\\n\\n```\\nfrom functools import cache\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        if grid[m-1][n-1] == \"(\":\\n            return False\\n        \\n        @cache\\n        def dp(x, y, o):\\n            if x == m - 1 and y == n - 1:\\n                return o == 1 # assert grid[m-1][n-1] == \")\"\\n            if grid[x][y] == \"(\":\\n                o += 1\\n            else: # \")\"\\n                if o == 0:\\n                    return False\\n                o -= 1\\n            if x + 1 < m and dp(x + 1, y, o):\\n                return True\\n            if y + 1 < n and dp(x, y + 1, o):\\n                return True\\n            # unreachable branch\\n                \\n        return dp(0, 0, 0)\\n```\\n\\n**Time complexity:**\\n\\n`T = O(m * n * (m + n))`\\n\\n(`o` in the `DP(x, y, o)` is at most `m + n`)",
                "solutionTags": [],
                "code": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m = len(grid)\\n        n = len(grid[0])\\n        if grid[m-1][n-1] == \"(\":\\n            return False\\n        \\n        @cache\\n        def dp(x, y, o):\\n            if x == m - 1 and y == n - 1:\\n                return o == 1 # assert grid[m-1][n-1] == \")\"\\n            if grid[x][y] == \"(\":\\n                o += 1\\n            else: # \")\"\\n                if o == 0:\\n                    return False\\n                o -= 1\\n            if x + 1 < m and dp(x + 1, y, o):\\n                return True\\n            if y + 1 < n and dp(x, y + 1, o):\\n                return True\\n            # unreachable branch\\n                \\n        return dp(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074317,
                "title": "bitmask-bottom-up-c-bitset-and-optional",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        typedef std::bitset<100> v1_t;\\n        typedef std::optional<v1_t> v_t;\\n        int m=grid.size(),n=grid[0].size();\\n        std::vector<std::vector<v_t>> dp(m,std::vector<v_t>(n));\\n        for(auto i=0;i<m;++i)for(auto j=0;j<n;++j)\\n        {\\n            v_t v1=std::nullopt,v2=std::nullopt;\\n            auto& u=dp[i][j];\\n            if(i==0&&j==0)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=1<<1;\\n                else\\n                    return false;\\n                continue;\\n            }\\n            if(i>0)\\n                v2=dp[i-1][j];\\n            if(j>0)\\n                v1=dp[i][j-1];\\n                \\n            if(grid[i][j]==\\')\\')\\n            {\\n                if(v1&&v1->none())\\n                    v1=std::nullopt;\\n                if(v2&&v2->none())\\n                    v2=std::nullopt;\\n            }\\n            \\n            if(v1&&v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1|*v2<<1;\\n                else\\n                    u=*v1>>1|*v2>>1;\\n            }\\n            else if(v1)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1;\\n                else\\n                    u=*v1>>1;\\n            }\\n            else if(v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v2<<1;\\n                else\\n                    u=*v2>>1;\\n            }\\n            else\\n                u=std::nullopt;\\n        }\\n        auto& v=dp[m-1][n-1];\\n        if(v)\\n            return v->test(0);\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        typedef std::bitset<100> v1_t;\\n        typedef std::optional<v1_t> v_t;\\n        int m=grid.size(),n=grid[0].size();\\n        std::vector<std::vector<v_t>> dp(m,std::vector<v_t>(n));\\n        for(auto i=0;i<m;++i)for(auto j=0;j<n;++j)\\n        {\\n            v_t v1=std::nullopt,v2=std::nullopt;\\n            auto& u=dp[i][j];\\n            if(i==0&&j==0)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=1<<1;\\n                else\\n                    return false;\\n                continue;\\n            }\\n            if(i>0)\\n                v2=dp[i-1][j];\\n            if(j>0)\\n                v1=dp[i][j-1];\\n                \\n            if(grid[i][j]==\\')\\')\\n            {\\n                if(v1&&v1->none())\\n                    v1=std::nullopt;\\n                if(v2&&v2->none())\\n                    v2=std::nullopt;\\n            }\\n            \\n            if(v1&&v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1|*v2<<1;\\n                else\\n                    u=*v1>>1|*v2>>1;\\n            }\\n            else if(v1)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v1<<1;\\n                else\\n                    u=*v1>>1;\\n            }\\n            else if(v2)\\n            {\\n                if(grid[i][j]==\\'(\\')\\n                    u=*v2<<1;\\n                else\\n                    u=*v2>>1;\\n            }\\n            else\\n                u=std::nullopt;\\n        }\\n        auto& v=dp[m-1][n-1];\\n        if(v)\\n            return v->test(0);\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002800,
                "title": "easy-peasy-c-using-recursion-memoisation-hard-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n    int m;\\n    int n;\\n    bool solve(int i , int j , int countopen , vector<vector<char>> &grid , vector<vector<vector<int>>> &dp){\\n        if(i<0 || i>=n || j<0 || j>=m) return false;\\n\\n        if(grid[i][j] == \\'(\\') countopen++;\\n\\n        else if(grid[i][j] == \\')\\') countopen--;\\n\\n        if(i == n-1 && j== m-1) return countopen==0;\\n\\n        if(countopen < 0) return false;\\n\\n        if(dp[i][j][countopen] != -1) return dp[i][j][countopen];\\n\\n        bool down = solve(i+1 , j , countopen , grid , dp);\\n        bool right = solve(i , j+1 , countopen , grid, dp);\\n\\n        return dp[i][j][countopen] = down || right;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n= grid.size();\\n        m= grid[0].size();\\n        vector<vector<vector<int>>> dp(n , vector<vector<int>>(m, vector<int>(201, -1)));\\n        return solve(0 , 0 , 0 , grid , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int m;\\n    int n;\\n    bool solve(int i , int j , int countopen , vector<vector<char>> &grid , vector<vector<vector<int>>> &dp){\\n        if(i<0 || i>=n || j<0 || j>=m) return false;\\n\\n        if(grid[i][j] == \\'(\\') countopen++;\\n\\n        else if(grid[i][j] == \\')\\') countopen--;\\n\\n        if(i == n-1 && j== m-1) return countopen==0;\\n\\n        if(countopen < 0) return false;\\n\\n        if(dp[i][j][countopen] != -1) return dp[i][j][countopen];\\n\\n        bool down = solve(i+1 , j , countopen , grid , dp);\\n        bool right = solve(i , j+1 , countopen , grid, dp);\\n\\n        return dp[i][j][countopen] = down || right;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n= grid.size();\\n        m= grid[0].size();\\n        vector<vector<vector<int>>> dp(n , vector<vector<int>>(m, vector<int>(201, -1)));\\n        return solve(0 , 0 , 0 , grid , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829609,
                "title": "c-top-down-3d-dp-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m;\\n    int n;\\n    vector<vector<vector<int>>> dp; \\n    vector<pair<int,int>> dirs{{1,0},{0,1}};\\n    bool solve(vector<vector<char>>& grid,int cr,int cc,int balance){\\n        if(balance<0) return false;\\n        if(cr==m-1 && cc==n-1) return (balance==0);\\n        if(dp[cr][cc][balance]!=-1) return dp[cr][cc][balance];\\n        bool answer=false;\\n        for(auto dir : dirs){\\n            int nr=cr+dir.first;\\n            int nc=cc+dir.second;\\n            if(nr>=0 &&nr<m && nc>=0 &&nc<n)\\n                answer|=solve(grid,nr,nc,balance+(grid[nr][nc]==\\'(\\')-(grid[nr][nc]==\\')\\'));\\n            if(answer) break;\\n        }\\n        return dp[cr][cc][balance]=answer;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        dp.resize(m,vector<vector<int>>(n,vector<int>(1000,-1)));\\n        return solve(grid,0,0,0+(grid[0][0]==\\'(\\')-(grid[0][0]==\\')\\'));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m;\\n    int n;\\n    vector<vector<vector<int>>> dp; \\n    vector<pair<int,int>> dirs{{1,0},{0,1}};\\n    bool solve(vector<vector<char>>& grid,int cr,int cc,int balance){\\n        if(balance<0) return false;\\n        if(cr==m-1 && cc==n-1) return (balance==0);\\n        if(dp[cr][cc][balance]!=-1) return dp[cr][cc][balance];\\n        bool answer=false;\\n        for(auto dir : dirs){\\n            int nr=cr+dir.first;\\n            int nc=cc+dir.second;\\n            if(nr>=0 &&nr<m && nc>=0 &&nc<n)\\n                answer|=solve(grid,nr,nc,balance+(grid[nr][nc]==\\'(\\')-(grid[nr][nc]==\\')\\'));\\n            if(answer) break;\\n        }\\n        return dp[cr][cc][balance]=answer;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        m=grid.size();\\n        n=grid[0].size();\\n        dp.resize(m,vector<vector<int>>(n,vector<int>(1000,-1)));\\n        return solve(grid,0,0,0+(grid[0][0]==\\'(\\')-(grid[0][0]==\\')\\'));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823909,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(rows * cols * (rows + cols))\\n * Space Complexity: O(rows * cols * (rows + cols))\\n * where `rows` is the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n public:\\n  bool hasValidPath(const vector<vector<char>> &grid) {\\n    constexpr int range = 2;\\n    constexpr char open = \\'(\\';\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool dp[range][cols][rows + cols];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0][0] = true;\\n    for (const vector<char> &row : grid) {\\n      for (int c = 0; c < cols; ++c) {\\n        const int cell = row[c] == open ? 1 : -1;\\n        for (int previous_cell = max(0, -cell); previous_cell < rows + cols; ++previous_cell) {\\n          const int current_cell = previous_cell + cell;\\n          if (dp[previous][c][previous_cell] || (c > 0 && dp[current][c - 1][previous_cell])) {\\n            dp[current][c][current_cell] = true;\\n          }\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][cols - 1][0];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols * (rows + cols))\\n * Space Complexity: O(rows * cols * (rows + cols))\\n * where `rows` is the number of the rows of the matrix `grid`\\n *       `cols` is the number of the columns of the matrix `grid`\\n */\\nclass Solution {\\n public:\\n  bool hasValidPath(const vector<vector<char>> &grid) {\\n    constexpr int range = 2;\\n    constexpr char open = \\'(\\';\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    bool dp[range][cols][rows + cols];\\n    memset(dp, 0, sizeof(dp));\\n    int previous = 0;\\n    int current = 1;\\n    dp[previous][0][0] = true;\\n    for (const vector<char> &row : grid) {\\n      for (int c = 0; c < cols; ++c) {\\n        const int cell = row[c] == open ? 1 : -1;\\n        for (int previous_cell = max(0, -cell); previous_cell < rows + cols; ++previous_cell) {\\n          const int current_cell = previous_cell + cell;\\n          if (dp[previous][c][previous_cell] || (c > 0 && dp[current][c - 1][previous_cell])) {\\n            dp[current][c][current_cell] = true;\\n          }\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      memset(dp[current], 0, sizeof(dp[current]));\\n    }\\n    return dp[previous][cols - 1][0];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808009,
                "title": "java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is simple..Just try all possible path !\\nBut  trying all possible path using DFS **always** have repeated sub problem which results can be stored and used later when faced again!\\n\\nThe `is_visited `   is used to store whether we have visisted the cell with `open` number of open brackets. if it is true then we have vissited and the further journey will not give any valid parenthesis.\\n\\n\\nThe dp combination is no.of.open brackets possible at any moment * i*j; \\n`is_visited = new boolean[201][grid.length][grid[0].length];\\n`\\n\\nEg : is_visited[10][12][15] can be taken as When we have 5 open brackets reamining at grid[12][15] and is we have encountered the secenario or not ! ... if the is_visited[10][12][15] is `false` then we have to explore this path ..if not we have already explored and exploring the same path is unnecessary. \\n\\n\\n# Complexity\\n- Time complexity: O( (m+n) * m * n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O( (m+n) * m * n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean[][][] is_visited ;\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] != \\'(\\' && grid[grid.length-1][grid[0].length-1] !=\\')\\') return false ;\\n        is_visited = new boolean[201][grid.length][grid[0].length];\\n        \\n        return algo(0 , 0 , grid ,0 );  \\n    }\\n    public boolean algo(int i , int j , char[][] grid , int open ){\\n        if( i>= grid.length || i< 0 || j>= grid[0].length || j<0) return false;\\n\\n        if(grid[i][j] == \\'(\\') open++; \\n        else open--;\\n        if( i== grid.length-1 && j== grid[0].length-1) {\\n            if(open != 0) return false ;\\n            return true;\\n        };\\n\\n        if(open < 0 || is_visited[open][i][j] != false) return false;\\n        //right \\n        if( algo(i+1 ,j ,grid , open)) return true;\\n        //down\\n        if(algo(i , j+1 , grid , open)) return true ;\\n        is_visited[open][i][j] = true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean[][][] is_visited ;\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] != \\'(\\' && grid[grid.length-1][grid[0].length-1] !=\\')\\') return false ;\\n        is_visited = new boolean[201][grid.length][grid[0].length];\\n        \\n        return algo(0 , 0 , grid ,0 );  \\n    }\\n    public boolean algo(int i , int j , char[][] grid , int open ){\\n        if( i>= grid.length || i< 0 || j>= grid[0].length || j<0) return false;\\n\\n        if(grid[i][j] == \\'(\\') open++; \\n        else open--;\\n        if( i== grid.length-1 && j== grid[0].length-1) {\\n            if(open != 0) return false ;\\n            return true;\\n        };\\n\\n        if(open < 0 || is_visited[open][i][j] != false) return false;\\n        //right \\n        if( algo(i+1 ,j ,grid , open)) return true;\\n        //down\\n        if(algo(i , j+1 , grid , open)) return true ;\\n        is_visited[open][i][j] = true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684064,
                "title": "c-recursive-solution",
                "content": "# Intuition\\nCan br done by recursive function because we have to check all cases.\\nSince overlapping subproblems are here, thus we can use DP \\n\\n# Approach\\n1. if m+n is even then length od string will be odd and that can\\'t be valid\\n2. In anywhere path if opening bracket numbers fall below zero, is also invalid path\\n3. if opening bracket number goes above (m+n)/2, this will be also invalid path.\\n4. if first char is \\')\\' or last char is \\'(\\', this will be also discarded\\n5. take or of both the cases (right and down).\\n6. memoise it vith 3-D dp array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>& grid, int i, int j, int m , int n, int open, vector<vector<vector<int>>> &dp){\\n        if(i==n-1 && j==m-1 ){\\n            if(open==0) return true;\\n            return false;\\n        } \\n        if(open<0 || open>(m+n)/2) return false;\\n\\n        if(dp[i][j][open]!=-1) return dp[i][j][open];\\n        bool a=false, b=false;\\n        if(j<m-1){\\n            if(grid[i][j+1]==\\'(\\') a=f(grid, i, j+1, m, n, open+1, dp);\\n            else a=f(grid, i, j+1, m, n, open-1, dp);\\n        }\\n        if(i<n-1){\\n            if(grid[i+1][j]==\\'(\\') b=f(grid, i+1, j, m, n, open+1, dp);\\n            else b=f(grid, i+1, j, m, n, open-1, dp);\\n        }\\n\\n        return dp[i][j][open]= a||b;\\n        \\n\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if((m+n)%2==0) return false;\\n        if(grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\') return false;\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m, vector<int>((m+n)/2+1, -1)));\\n        return f(grid, 0,0,m, n, 1, dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(vector<vector<char>>& grid, int i, int j, int m , int n, int open, vector<vector<vector<int>>> &dp){\\n        if(i==n-1 && j==m-1 ){\\n            if(open==0) return true;\\n            return false;\\n        } \\n        if(open<0 || open>(m+n)/2) return false;\\n\\n        if(dp[i][j][open]!=-1) return dp[i][j][open];\\n        bool a=false, b=false;\\n        if(j<m-1){\\n            if(grid[i][j+1]==\\'(\\') a=f(grid, i, j+1, m, n, open+1, dp);\\n            else a=f(grid, i, j+1, m, n, open-1, dp);\\n        }\\n        if(i<n-1){\\n            if(grid[i+1][j]==\\'(\\') b=f(grid, i+1, j, m, n, open+1, dp);\\n            else b=f(grid, i+1, j, m, n, open-1, dp);\\n        }\\n\\n        return dp[i][j][open]= a||b;\\n        \\n\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if((m+n)%2==0) return false;\\n        if(grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\') return false;\\n        vector<vector<vector<int>>> dp(n,vector<vector<int>>(m, vector<int>((m+n)/2+1, -1)));\\n        return f(grid, 0,0,m, n, 1, dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670177,
                "title": "why-it-should-be-dp-not-a-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI got tons of TLE with Backtracking and Passed after add memoizaion\\n\\nSure, I used params as dp way, shrink parmas size and limit string\\'s size (Like minus when `)` comes)\\n\\nBut as i thought, it doesn\\'t matter with DP or DFS, cause all the cases could be feed-forward `Right Or Down` and it\\'s constraints is `M*N <= 10**4`\\n\\nAnyone knows why it should be DP ?\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] != \"(\" or grid[-1][-1] != \")\":\\n            return False\\n        \\n        dp = defaultdict(lambda : -1)\\n\\n        \\n        def backtracking(i,j, stack):\\n            if dp[(i,j, stack)] != -1:\\n                return dp[(i,j, stack)]\\n            \\n            if i == m-1 and j == n-1:\\n                if len(stack)==0:\\n                    dp[(i,j, stack)]= True\\n                    return True\\n                dp[(i,j, stack)] = False\\n                return False\\n            \\n            \\n            if i+1 < m:\\n                if len(stack) and grid[i+1][j] == \")\":\\n                    if backtracking(i+1, j, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i+1][j] != \")\" ) or grid[i+1][j] == \"(\":\\n                    if backtracking(i+1, j, stack+grid[i+1][j]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n\\n            if j+1 < n:\\n                if len(stack) and grid[i][j+1] == \")\":\\n                    if backtracking(i, j+1, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i][j+1] != \")\" )  or grid[i][j+1] == \"(\":\\n                    if backtracking(i, j+1, stack+grid[i][j+1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n            dp[(i,j, stack)]= False\\n            return False\\n        \\n        return backtracking(0,0, grid[0][0])\\n                \\n\\n                \\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] != \"(\" or grid[-1][-1] != \")\":\\n            return False\\n        \\n        dp = defaultdict(lambda : -1)\\n\\n        \\n        def backtracking(i,j, stack):\\n            if dp[(i,j, stack)] != -1:\\n                return dp[(i,j, stack)]\\n            \\n            if i == m-1 and j == n-1:\\n                if len(stack)==0:\\n                    dp[(i,j, stack)]= True\\n                    return True\\n                dp[(i,j, stack)] = False\\n                return False\\n            \\n            \\n            if i+1 < m:\\n                if len(stack) and grid[i+1][j] == \")\":\\n                    if backtracking(i+1, j, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i+1][j] != \")\" ) or grid[i+1][j] == \"(\":\\n                    if backtracking(i+1, j, stack+grid[i+1][j]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n\\n            if j+1 < n:\\n                if len(stack) and grid[i][j+1] == \")\":\\n                    if backtracking(i, j+1, stack[:-1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n                elif (len(stack) == 0 and grid[i][j+1] != \")\" )  or grid[i][j+1] == \"(\":\\n                    if backtracking(i, j+1, stack+grid[i][j+1]):\\n                        dp[(i,j, stack)]= True\\n                        return True\\n            dp[(i,j, stack)]= False\\n            return False\\n        \\n        return backtracking(0,0, grid[0][0])\\n                \\n\\n                \\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3650686,
                "title": "simple-fast-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def hasValidPath(self, A):\\n        m, n = len(A), len(A[0])\\n        dp = defaultdict(set)\\n        dp[0, -1] = dp[-1, 0] = {0}\\n        for i in range(m):\\n            for j in range(n):\\n                d = 1 if A[i][j] == \\'(\\' else -1\\n                dp[i,j] |= {a + d for a in dp[i-1,j] | dp[i,j-1] if a + d >= 0}\\n        return 0 in dp[m - 1, n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644364,
                "title": "dp-with-sets",
                "content": "# Intuition\\n\\nEach path can be described by a walk $S$ on integers. If the the path goes through a field of the grid containing `\\'(\\'` then the walk steps up otherwise down. \\nSo $S_k$ is the difference of the opening and closing parantheses among the first $k$ element of the path.\\n\\nA path is valid if $S$ stays on the non-negative half-line.\\n\\n \\nFor each position in the grid let `dp[i][j]` be the set of final positions of possible valid paths connecting `0,0` and `i,j`.\\n\\nThe answer is `true` if $0\\\\in \\\\text{dp}_{m-1,n-1}$ and `false` otherwise.\\n\\nThe relation for computing `dp` is\\n$$\\n    \\\\text{dp}_{i,j} = \\\\{p+d\\\\colon p \\\\in \\\\text{dp}_{i-1, j}\\\\cup \\\\text{dp}_{i, j-1}\\\\}, \\\\quad\\\\text{where $d=\\\\pm1$ depending on  $\\\\text{grid}_{i,j}$}\\n$$\\n\\n# Complexity\\n- Time complexity: $$O(m*n*(m+n))$$, where $(m,n)$ is the size of the grid\\n\\n- Space complexity: $$O(n*(m+n))$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        if (m+n)&1==0 or grid[0][0]!=\"(\" or grid[-1][-1]!=\")\":\\n            return False\\n\\n        dp = [{0}] + [set() for _ in range(1, n)]\\n        for i in range(m):\\n            prev_set = set()\\n            all_empty = True\\n            for j in range(n):\\n                d = 1 if grid[i][j] == \"(\" else -1\\n                max_pos = n-j+m-i-2\\n                prev_set = {pos + d for pos in prev_set.union(dp[j]) if 0 <= pos + d <= max_pos}\\n                dp[j] = prev_set\\n                if prev_set:\\n                    all_empty = False\\n            if all_empty:\\n                return False\\n        return 0 in dp[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n\\n        if (m+n)&1==0 or grid[0][0]!=\"(\" or grid[-1][-1]!=\")\":\\n            return False\\n\\n        dp = [{0}] + [set() for _ in range(1, n)]\\n        for i in range(m):\\n            prev_set = set()\\n            all_empty = True\\n            for j in range(n):\\n                d = 1 if grid[i][j] == \"(\" else -1\\n                max_pos = n-j+m-i-2\\n                prev_set = {pos + d for pos in prev_set.union(dp[j]) if 0 <= pos + d <= max_pos}\\n                dp[j] = prev_set\\n                if prev_set:\\n                    all_empty = False\\n            if all_empty:\\n                return False\\n        return 0 in dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604560,
                "title": "c-bottomup-dp",
                "content": "```\\npublic class Solution {\\n    int MIN=-9999;\\n    public bool HasValidPath(char[][] grid) {\\n        int n=grid.Length; int m=grid[0].Length;\\n        HashSet<int>[] dp=new  HashSet<int>[m];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                HashSet<int> hs=new HashSet<int>();\\n                int t=grid[i][j] == \\'(\\' ? 1 :-1;\\n                if(i>0){\\n                    foreach(int s in dp[j])\\n                        if(s+t>=0) hs.Add(s+t);\\n                }\\n                \\n                if(j>0){\\n                    foreach(int s in dp[j-1])\\n                        if(s+t>=0)  hs.Add(s+t);\\n                }\\n                if(i==0 && j==0)\\n                    if(t>0 ) hs.Add(t); else return false;\\n                \\n                if(hs.Count==0)\\n                    hs.Add(MIN);\\n                \\n                dp[j]=hs;\\n                \\n            }\\n            \\n        }\\n        \\n        foreach(int s in dp[m-1])\\n            if(s==0)\\n                return true;\\n        \\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int MIN=-9999;\\n    public bool HasValidPath(char[][] grid) {\\n        int n=grid.Length; int m=grid[0].Length;\\n        HashSet<int>[] dp=new  HashSet<int>[m];\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                HashSet<int> hs=new HashSet<int>();\\n                int t=grid[i][j] == \\'(\\' ? 1 :-1;\\n                if(i>0){\\n                    foreach(int s in dp[j])\\n                        if(s+t>=0) hs.Add(s+t);\\n                }\\n                \\n                if(j>0){\\n                    foreach(int s in dp[j-1])\\n                        if(s+t>=0)  hs.Add(s+t);\\n                }\\n                if(i==0 && j==0)\\n                    if(t>0 ) hs.Add(t); else return false;\\n                \\n                if(hs.Count==0)\\n                    hs.Add(MIN);\\n                \\n                dp[j]=hs;\\n                \\n            }\\n            \\n        }\\n        \\n        foreach(int s in dp[m-1])\\n            if(s==0)\\n                return true;\\n        \\n        return false;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594206,
                "title": "python-easy-pfs",
                "content": "# bfs solution\\n  bfs solution but a bit slow \\n```\\nclass Solution(object):\\n    def hasValidPath(self, grid):\\n      #get number of rows and columns \\n      r,n=len(grid),len(grid[0])\\n      #start point     \\n      i,j=0,0 \\n      #direction down ,right   \\n      directions=[(1,0),(0,1)]\\n      #quick failure test cases \\n      if grid[0][0]==\")\": return False\\n      if grid[-1][-1]==\"(\": return False\\n      if (r+n)%2==0: return False     \\n      visited=set()\\n      # x,y,number of barenthese \\n      queue=[[i,j,0]]\\n      while queue:\\n        i,j,num=queue.pop(0)\\n        num+=1 if grid[i][j]==\"(\" else -1\\n        if i==r-1 and j==n-1 and not num:\\n            return True\\n        for x,y in  directions:\\n          next_x,next_y=x+i,j+y\\n          if 0<=next_x<r and 0<=next_y<n and num>=0 and (next_x,next_y,num) not in s:\\n              queue.append([next_x,next_y,num])\\n              s.add((next_x,next_y,num))\\n      return False\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def hasValidPath(self, grid):\\n      #get number of rows and columns \\n      r,n=len(grid),len(grid[0])\\n      #start point     \\n      i,j=0,0 \\n      #direction down ,right   \\n      directions=[(1,0),(0,1)]\\n      #quick failure test cases \\n      if grid[0][0]==\")\": return False\\n      if grid[-1][-1]==\"(\": return False\\n      if (r+n)%2==0: return False     \\n      visited=set()\\n      # x,y,number of barenthese \\n      queue=[[i,j,0]]\\n      while queue:\\n        i,j,num=queue.pop(0)\\n        num+=1 if grid[i][j]==\"(\" else -1\\n        if i==r-1 and j==n-1 and not num:\\n            return True\\n        for x,y in  directions:\\n          next_x,next_y=x+i,j+y\\n          if 0<=next_x<r and 0<=next_y<n and num>=0 and (next_x,next_y,num) not in s:\\n              queue.append([next_x,next_y,num])\\n              s.add((next_x,next_y,num))\\n      return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453294,
                "title": "java-o-m-n-m-n-c-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntotal forward and backward bracket in a valid path will be (M+N)/2 each.\\nincrease variable sum when forward bracket comes and add backward only when sum is greater than 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int M,N, MID;\\n    Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        M = grid.length;\\n        N = grid[0].length;\\n        MID = (M+N)/2;\\n        dp = new Boolean[M][N][MID+1];\\n        return rec(0, 0, grid, 0);\\n    }\\n\\n    boolean rec(int i, int j, char[][] grid, int sum) {\\n        if(i==M-1 && j==N-1) {\\n            if(sum==1 && grid[i][j]==\\')\\') {\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n        if(dp[i][j][sum]!=null)\\n        return dp[i][j][sum];\\n\\n        boolean ans = false;\\n        if(grid[i][j]==\\'(\\' && sum<MID) {\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum+1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum+1);\\n        } else if(grid[i][j]==\\')\\' && sum>0){\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum-1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum-1);\\n        }\\n        dp[i][j][sum]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int M,N, MID;\\n    Boolean[][][] dp;\\n    public boolean hasValidPath(char[][] grid) {\\n        M = grid.length;\\n        N = grid[0].length;\\n        MID = (M+N)/2;\\n        dp = new Boolean[M][N][MID+1];\\n        return rec(0, 0, grid, 0);\\n    }\\n\\n    boolean rec(int i, int j, char[][] grid, int sum) {\\n        if(i==M-1 && j==N-1) {\\n            if(sum==1 && grid[i][j]==\\')\\') {\\n                return true;\\n            }\\n            return false;\\n        }\\n        \\n        if(dp[i][j][sum]!=null)\\n        return dp[i][j][sum];\\n\\n        boolean ans = false;\\n        if(grid[i][j]==\\'(\\' && sum<MID) {\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum+1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum+1);\\n        } else if(grid[i][j]==\\')\\' && sum>0){\\n            if(i<M-1)\\n            ans = ans || rec(i+1,j, grid, sum-1);\\n            if(j<N-1)\\n            ans = ans || rec(i, j+1, grid, sum-1);\\n        }\\n        dp[i][j][sum]=ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439212,
                "title": "add-a-little-pruning-for-the-dp-solution-to-make-it-a-little-bit-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObservations:\\n1. if grid[0][0] == \")\" or grid[-1][-1] == \"(\", it would not work--> False\\n2. The total number of items in the path would be row + col -1. This number has to be even in order for the parenthese to be valid.\\n3. Using dp set, use defaultdict(set) is much faster\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn*(m + n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n \\n        row, col = len(grid), len(grid[0])\\n        if grid[0][0] == \")\" or grid[-1][-1] == \"(\" or (row + col - 1) % 2:\\n            return False\\n\\n        dp = defaultdict(set)\\n        dp[0, 0] = {1}\\n\\n        for r in range(row):\\n            for c in range(col):\\n                sign = 1 if grid[r][c] == \"(\" else -1\\n                dp[r, c] |= set([val + sign  for val in dp[(r -1, c)] | dp[(r, c- 1)] if val + sign >= 0])\\n        \\n        return 0 in dp[(row-1, col -1)]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n \\n        row, col = len(grid), len(grid[0])\\n        if grid[0][0] == \")\" or grid[-1][-1] == \"(\" or (row + col - 1) % 2:\\n            return False\\n\\n        dp = defaultdict(set)\\n        dp[0, 0] = {1}\\n\\n        for r in range(row):\\n            for c in range(col):\\n                sign = 1 if grid[r][c] == \"(\" else -1\\n                dp[r, c] |= set([val + sign  for val in dp[(r -1, c)] | dp[(r, c- 1)] if val + sign >= 0])\\n        \\n        return 0 in dp[(row-1, col -1)]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437743,
                "title": "java-easy-to-understand-dfs-dp",
                "content": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    private boolean solve(char[][] grid, int i, int j, int path){\\n        if(i == grid.length || j == grid[0].length) return false;\\n        path += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        if(i == grid.length - 1 && j == grid[0].length - 1)\\n            return path == 0;\\n        if(path < 0) return false;\\n        if(dp[i][j][path] != null) return dp[i][j][path];\\n        return dp[i][j][path] = solve(grid, i + 1, j, path) || solve(grid, i, j + 1, path);\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        dp = new Boolean[grid.length][grid[0].length][210];\\n        return solve(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    private boolean solve(char[][] grid, int i, int j, int path){\\n        if(i == grid.length || j == grid[0].length) return false;\\n        path += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        if(i == grid.length - 1 && j == grid[0].length - 1)\\n            return path == 0;\\n        if(path < 0) return false;\\n        if(dp[i][j][path] != null) return dp[i][j][path];\\n        return dp[i][j][path] = solve(grid, i + 1, j, path) || solve(grid, i, j + 1, path);\\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        dp = new Boolean[grid.length][grid[0].length][210];\\n        return solve(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386251,
                "title": "bottom-up-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(grid[0][0] == \\')\\' || grid[n-1][m-1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        // \\'(\\' -> + 1\\n        // \\')\\' -> -1\\n        vector<vector<vector<bool>>> dp(n,vector<vector<bool>> (m,vector<bool> (203,false)));\\n        \\n        dp[0][0][1] = true;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    continue;\\n                }\\n                \\n                for(int k=0;k<202;k++){\\n                    if(i>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k+1];\\n                        }\\n                        \\n                    }\\n                    if(j>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k+1];\\n                        }\\n                    }\\n                        \\n                }\\n                \\n            }\\n        }\\n        return dp[n-1][m-1][0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        if(grid[0][0] == \\')\\' || grid[n-1][m-1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        // \\'(\\' -> + 1\\n        // \\')\\' -> -1\\n        vector<vector<vector<bool>>> dp(n,vector<vector<bool>> (m,vector<bool> (203,false)));\\n        \\n        dp[0][0][1] = true;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 && j==0){\\n                    continue;\\n                }\\n                \\n                for(int k=0;k<202;k++){\\n                    if(i>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i-1][j][k+1];\\n                        }\\n                        \\n                    }\\n                    if(j>0){\\n                        if(grid[i][j] == \\'(\\'){\\n                            if(k>0){\\n                               dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k-1]; \\n                            }\\n                        }else{\\n                            dp[i][j][k] = dp[i][j][k] | dp[i][j-1][k+1];\\n                        }\\n                    }\\n                        \\n                }\\n                \\n            }\\n        }\\n        return dp[n-1][m-1][0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295403,
                "title": "easy-dfs-dp-solution-approach-cpp",
                "content": "# Intuition and Approach\\n* write simple dfs recursion for traversing.\\n* for valid parenthessis string keep a variable which is initialize from zero.it will increse by 1 if current cell char is \\'(\\' and decrease by 1 if current cell char is \\')\\'.\\n* whenever u find this variable becomes negative return false. because there must be one open bracket before we include one close bracket.\\n* if you reach to bottom right and your variable is zero then return true else return false.\\n* short your dfs calls by using or gate.\\n* take care of index if it goes beyond bounds.\\n* prepare a 3d dp array of size rows x cols x (rows+cols+1).\\n* (rows+ cols)==> for the variable which we initialize from zero. its max value is row + cols, because this is max no of moves to reach bottom right from top left.\\n* keep ans in dp whenever calculated before returning.\\n* check ans in dp before entering recursion.  \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check (vector<vector<char>>& grid,int m,int n,int i,int j,int flag,vector<vector<vector<int>>>& dp){\\n        \\n        if(flag<0 || i>=m || j>=n)return false;\\n        if(dp[i][j][flag]!=-1)return dp[i][j][flag];\\n        int temp=flag;\\n        if(grid[i][j]==\\'(\\')flag++;\\n        else flag--;\\n        if(i==m-1 && j==n-1){\\n            if(flag==0)return true;\\n            else return false;\\n        }\\n        \\n        return dp[i][j][temp]=(check(grid,m,n,i+1,j,flag,dp) || check(grid,m,n,i,j+1,flag,dp));\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int k=(m+n+10);\\n        int flag=0;\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n        return check(grid,grid.size(),grid[0].size(),0,0,flag,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check (vector<vector<char>>& grid,int m,int n,int i,int j,int flag,vector<vector<vector<int>>>& dp){\\n        \\n        if(flag<0 || i>=m || j>=n)return false;\\n        if(dp[i][j][flag]!=-1)return dp[i][j][flag];\\n        int temp=flag;\\n        if(grid[i][j]==\\'(\\')flag++;\\n        else flag--;\\n        if(i==m-1 && j==n-1){\\n            if(flag==0)return true;\\n            else return false;\\n        }\\n        \\n        return dp[i][j][temp]=(check(grid,m,n,i+1,j,flag,dp) || check(grid,m,n,i,j+1,flag,dp));\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int k=(m+n+10);\\n        int flag=0;\\n        vector<vector<vector<int>>>dp(m,vector<vector<int>>(n,vector<int>(k,-1)));\\n        return check(grid,grid.size(),grid[0].size(),0,0,flag,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236615,
                "title": "very-to-understand-simple-dfs-memoization",
                "content": "# Code\\n```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>>dp;\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        //initializing the dp form memoization\\n        dp.resize(grid.size()+1,vector<vector<int>>(grid[0].size()+1,vector<int>(205,-1)));\\n\\n        //row and col for traversing the grid\\n        int row = 0;\\n        int col = 0;\\n        \\n        //mainitng a variable to keep the track of the open and the close bracket\\n        int k = 0;\\n\\n        //fun function will return if there exist any path from top to bottom with valid vps\\n        return fun(grid,row,col,k);    \\n    }\\n    int fun(vector<vector<char>>&grid,int row,int col,int k)\\n    {\\n          if(row<0 or row>=grid.size() or col<0 or col>=grid[0].size())\\n          {\\n              return false;\\n          }\\n\\n          if(grid[row][col] == \\'(\\')\\n          {\\n              k++;\\n          }      \\n          else if(grid[row][col] == \\')\\')\\n          {\\n              k--;\\n          }\\n\\n          if(k < 0) //no of cloing brackets are now more than no of opening brackets return flase\\n          return false;\\n\\n          if(row == grid.size()-1 and col == grid[0].size()-1)   //if we reach the destination\\n          {\\n                if(k > 0)  //this means no of opening are more than closing \\n                return false;\\n\\n                if(k == 0)  //this means all the brackets are balances\\n                return true;\\n\\n                if(k < 0)   //no of closing brackets are more than no of opening brackets\\n                return false;\\n          }\\n          \\n          //if the state is currently computed\\n          if(dp[row][col][k]!=-1)\\n          return dp[row][col][k];\\n     \\n          //checking all the possibility \\n          int choise1 = fun(grid,row+1,col,k);\\n          int choise2 = fun(grid,row,col+1,k);\\n\\n          return dp[row][col][k] = choise1 or choise2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\nclass Solution {\\npublic:\\n    vector<vector<vector<int>>>dp;\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        //initializing the dp form memoization\\n        dp.resize(grid.size()+1,vector<vector<int>>(grid[0].size()+1,vector<int>(205,-1)));\\n\\n        //row and col for traversing the grid\\n        int row = 0;\\n        int col = 0;\\n        \\n        //mainitng a variable to keep the track of the open and the close bracket\\n        int k = 0;\\n\\n        //fun function will return if there exist any path from top to bottom with valid vps\\n        return fun(grid,row,col,k);    \\n    }\\n    int fun(vector<vector<char>>&grid,int row,int col,int k)\\n    {\\n          if(row<0 or row>=grid.size() or col<0 or col>=grid[0].size())\\n          {\\n              return false;\\n          }\\n\\n          if(grid[row][col] == \\'(\\')\\n          {\\n              k++;\\n          }      \\n          else if(grid[row][col] == \\')\\')\\n          {\\n              k--;\\n          }\\n\\n          if(k < 0) //no of cloing brackets are now more than no of opening brackets return flase\\n          return false;\\n\\n          if(row == grid.size()-1 and col == grid[0].size()-1)   //if we reach the destination\\n          {\\n                if(k > 0)  //this means no of opening are more than closing \\n                return false;\\n\\n                if(k == 0)  //this means all the brackets are balances\\n                return true;\\n\\n                if(k < 0)   //no of closing brackets are more than no of opening brackets\\n                return false;\\n          }\\n          \\n          //if the state is currently computed\\n          if(dp[row][col][k]!=-1)\\n          return dp[row][col][k];\\n     \\n          //checking all the possibility \\n          int choise1 = fun(grid,row+1,col,k);\\n          int choise2 = fun(grid,row,col+1,k);\\n\\n          return dp[row][col][k] = choise1 or choise2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3131177,
                "title": "c-dp-recursive-fast-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &grid, int i, int j, int open)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        if(open < 0)return false;\\n        if(dp[i][j][open]!=-1)return dp[i][j][open];\\n        if(i == n-1 && j == m-1)\\n        {\\n            if(grid[i][j] == \\')\\' && open == 1)return dp[i][j][open] = true;\\n            return dp[i][j][open] = false;\\n        }\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open+1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open+1);\\n        }\\n        else\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open-1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open-1);\\n        }\\n        return dp[i][j][open] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid){\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (m+n, -1)));\\n        return solve(dp, grid, 0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<vector<int>>> &dp, vector<vector<char>> &grid, int i, int j, int open)\\n    {\\n        int n = grid.size(), m = grid[0].size();\\n        if(open < 0)return false;\\n        if(dp[i][j][open]!=-1)return dp[i][j][open];\\n        if(i == n-1 && j == m-1)\\n        {\\n            if(grid[i][j] == \\')\\' && open == 1)return dp[i][j][open] = true;\\n            return dp[i][j][open] = false;\\n        }\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open+1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open+1);\\n        }\\n        else\\n        {\\n            if(i+1 < n)ans = ans | solve(dp, grid, i+1, j, open-1);\\n            if(j+1 < m)ans = ans | solve(dp, grid, i, j+1, open-1);\\n        }\\n        return dp[i][j][open] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid){\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>> (m, vector<int> (m+n, -1)));\\n        return solve(dp, grid, 0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3030477,
                "title": "best-optimised-c-coolution-please-upvote-if-u-like-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)+O(N+M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n, m;\\n    bool solve(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n           return open==0;\\n        }\\n        bool ans = solve(x+1, y, open, grid, dp) ||solve(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = ans;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return solve(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Stack",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    bool solve(int x, int y, int open, vector<vector<char>>& grid, vector<vector<vector<int>>> &dp)\\n    {\\n        if(x >= n || y >= m) return false;\\n        if(grid[x][y] == \\'(\\')\\n            open++;\\n        else\\n            open--;\\n        if(open < 0)\\n            return false;\\n        if(dp[x][y][open] != -1)\\n            return dp[x][y][open];\\n        if(x == n-1 && y == m-1)\\n        {\\n           return open==0;\\n        }\\n        bool ans = solve(x+1, y, open, grid, dp) ||solve(x, y+1, open, grid, dp);\\n        return dp[x][y][open] = ans;\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>> (m+1, vector<int> (201, -1)));\\n        return solve(0,0,0,grid,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019025,
                "title": "dfs-dp",
                "content": "# Intuition\\nsimple DP+DFS;\\n\\n# Approach\\nApply DFS and memoize all the places and count k which is count of \\'(\\' if current position in \\'(\\' then k++ else k--. if it goes to end and k==0 then we get a valid  parenthesis path other wise not a valid parenthesis;\\n\\n# Complexity\\n- Time complexity:\\nO(n*m*k);\\n\\n- Space complexity:\\no(n*m);\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[100][100][205];\\n    int n,m;\\n    bool getSolution(vector<vector<char>>& grid , int i, int j , int k){\\n        if(i>=n|| j>=m){\\n            return false;\\n        }\\n        if(grid[i][j]==\\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if(k<0){\\n            return false;\\n        }\\n        if(i==(n-1)&&j==(m-1)){\\n            return k==0;\\n        }\\n        int &ans=dp[i][j][k];\\n        if(ans!=-1){\\n            return ans;\\n        }\\n        return ans = getSolution(grid,i+1,j,k)| getSolution(grid,i,j+1,k);  \\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n    memset(dp,-1,sizeof(dp));\\n    return getSolution(grid,0,0,0);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100][100][205];\\n    int n,m;\\n    bool getSolution(vector<vector<char>>& grid , int i, int j , int k){\\n        if(i>=n|| j>=m){\\n            return false;\\n        }\\n        if(grid[i][j]==\\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if(k<0){\\n            return false;\\n        }\\n        if(i==(n-1)&&j==(m-1)){\\n            return k==0;\\n        }\\n        int &ans=dp[i][j][k];\\n        if(ans!=-1){\\n            return ans;\\n        }\\n        return ans = getSolution(grid,i+1,j,k)| getSolution(grid,i,j+1,k);  \\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n    memset(dp,-1,sizeof(dp));\\n    return getSolution(grid,0,0,0);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975133,
                "title": "python3-java-top-down-dp",
                "content": "```\\nPython3\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n = len(grid),len(grid[0])\\n        @cache\\n        def dp(r,c,k):\\n            if r == m or c == n:\\n                return False\\n            if grid[r][c] == \"(\":\\n                k += 1\\n            else:\\n                k -= 1\\n            if k < 0:\\n                return False\\n            if r == m-1 and c == n-1:\\n                return k == 0\\n            return dp(r+1,c,k) or dp(r,c+1,k)\\n        return dp(0,0,0)\\n```\\n```\\nJava\\n\\nclass Solution {\\n    int m,n;\\n    Boolean[][][] dp = new Boolean[100][100][200];\\n    public boolean dfs(int r,int c,int k,char[][] grid){\\n        if( r == m || c == n){\\n            return false;\\n        }\\n        if (grid[r][c] == \\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if( k < 0){\\n            return false;\\n        }\\n        if (r == m - 1 && c == n - 1){\\n            return k == 0 ? true : false;\\n        }\\n        if (dp[r][c][k] != null){\\n            return dp[r][c][k];\\n        }\\n        return dp[r][c][k] = dfs(r+1,c,k,grid) || dfs(r,c+1,k,grid);\\n        \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length ; n = grid[0].length;\\n        return dfs(0,0,0,grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nPython3\\n\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m,n = len(grid),len(grid[0])\\n        @cache\\n        def dp(r,c,k):\\n            if r == m or c == n:\\n                return False\\n            if grid[r][c] == \"(\":\\n                k += 1\\n            else:\\n                k -= 1\\n            if k < 0:\\n                return False\\n            if r == m-1 and c == n-1:\\n                return k == 0\\n            return dp(r+1,c,k) or dp(r,c+1,k)\\n        return dp(0,0,0)\\n```\n```\\nJava\\n\\nclass Solution {\\n    int m,n;\\n    Boolean[][][] dp = new Boolean[100][100][200];\\n    public boolean dfs(int r,int c,int k,char[][] grid){\\n        if( r == m || c == n){\\n            return false;\\n        }\\n        if (grid[r][c] == \\'(\\'){\\n            k++;\\n        }\\n        else{\\n            k--;\\n        }\\n        if( k < 0){\\n            return false;\\n        }\\n        if (r == m - 1 && c == n - 1){\\n            return k == 0 ? true : false;\\n        }\\n        if (dp[r][c][k] != null){\\n            return dp[r][c][k];\\n        }\\n        return dp[r][c][k] = dfs(r+1,c,k,grid) || dfs(r,c+1,k,grid);\\n        \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length ; n = grid[0].length;\\n        return dfs(0,0,0,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957808,
                "title": "3d-dynamic-programming-c-fast-simple-clean-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[101][101][201];\\n\\n    ll solve(vector<vector<char>>&grid,ll i,ll j,ll count,ll n,ll m){\\n        if(i==n-1 && j==m-1){\\n            if(grid[i][j]==\\'(\\' || count!=1){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        if(dp[i][j][count]!=-1){\\n            return dp[i][j][count];\\n        }\\n        bool answer=0;\\n        if(i+1<n){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i+1,j,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i+1,j,count-1,n,m);\\n            }\\n        }\\n        if(j+1<m){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i,j+1,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i,j+1,count-1,n,m);\\n            }\\n        }\\n        return dp[i][j][count]=answer;\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        ll n=grid.size(),m=grid[0].size();memset(dp,-1,sizeof(dp));\\n        return solve(grid,0,0,0,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[101][101][201];\\n\\n    ll solve(vector<vector<char>>&grid,ll i,ll j,ll count,ll n,ll m){\\n        if(i==n-1 && j==m-1){\\n            if(grid[i][j]==\\'(\\' || count!=1){\\n                return 0;\\n            }\\n            return 1;\\n        }\\n        if(dp[i][j][count]!=-1){\\n            return dp[i][j][count];\\n        }\\n        bool answer=0;\\n        if(i+1<n){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i+1,j,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i+1,j,count-1,n,m);\\n            }\\n        }\\n        if(j+1<m){\\n            if(grid[i][j]==\\'(\\'){\\n                answer+=solve(grid,i,j+1,count+1,n,m);\\n            }\\n            else if(count>0){\\n                answer+=solve(grid,i,j+1,count-1,n,m);\\n            }\\n        }\\n        return dp[i][j][count]=answer;\\n    }\\n\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        ll n=grid.size(),m=grid[0].size();memset(dp,-1,sizeof(dp));\\n        return solve(grid,0,0,0,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942771,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nvar hasValidPath = function(grid) {\\n  let visiting = new Set();\\n  let cache = new Set();\\n  return dfs([0, 0], grid, visiting, 0, cache);\\n};\\n\\nfunction dfs(cell, grid, visiting, currentSum, cache) {\\n  let [row, col] = cell;\\n  let val = grid[row][col] === \"(\" ? 1 : -1;\\n  let remainingSum = 0 - (currentSum + val);\\n  if (cache.has(`${row}_${col}_${remainingSum}`)) {\\n    return false;\\n  }\\n  if (currentSum + val < 0) {\\n    return false;\\n  }\\n  \\n  if (row === grid.length - 1 && col === grid[0].length - 1) {\\n    // reached the end\\n    return (currentSum + val === 0);\\n  }\\n  \\n  // add it to visiting\\n  visiting.add(`${row}_${col}`);\\n  \\n  // visit all neighbors\\n  for (let [i, j] of [[1, 0], [0, 1]]) {\\n    if (isValid(grid, row + i, col + j) &&\\n      !visiting.has(`${row + i}_${col + j}`)) {\\n      \\n      // add neighbor to search\\n      if (dfs([row + i, col + j], grid, visiting, currentSum + val, cache)) {\\n        return true;\\n      }\\n    }\\n  }\\n  \\n  visiting.delete(`${row}_${col}`);\\n  cache.add(`${row}_${col}_${remainingSum}`);\\n  \\n  return false;\\n}\\n\\nfunction isValid(grid, row, col) {\\n  if (row >= 0 && col >= 0 && row < grid.length && col < grid[0].length) {\\n    return true;\\n  }\\n  return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n\\n/**\\n * @param {character[][]} grid\\n * @return {boolean}\\n */\\nvar hasValidPath = function(grid) {\\n  let visiting = new Set();\\n  let cache = new Set();\\n  return dfs([0, 0], grid, visiting, 0, cache);\\n};\\n\\nfunction dfs(cell, grid, visiting, currentSum, cache) {\\n  let [row, col] = cell;\\n  let val = grid[row][col] === \"(\" ? 1 : -1;\\n  let remainingSum = 0 - (currentSum + val);\\n  if (cache.has(`${row}_${col}_${remainingSum}`)) {\\n    return false;\\n  }\\n  if (currentSum + val < 0) {\\n    return false;\\n  }\\n  \\n  if (row === grid.length - 1 && col === grid[0].length - 1) {\\n    // reached the end\\n    return (currentSum + val === 0);\\n  }\\n  \\n  // add it to visiting\\n  visiting.add(`${row}_${col}`);\\n  \\n  // visit all neighbors\\n  for (let [i, j] of [[1, 0], [0, 1]]) {\\n    if (isValid(grid, row + i, col + j) &&\\n      !visiting.has(`${row + i}_${col + j}`)) {\\n      \\n      // add neighbor to search\\n      if (dfs([row + i, col + j], grid, visiting, currentSum + val, cache)) {\\n        return true;\\n      }\\n    }\\n  }\\n  \\n  visiting.delete(`${row}_${col}`);\\n  cache.add(`${row}_${col}_${remainingSum}`);\\n  \\n  return false;\\n}\\n\\nfunction isValid(grid, row, col) {\\n  if (row >= 0 && col >= 0 && row < grid.length && col < grid[0].length) {\\n    return true;\\n  }\\n  return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937462,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        @lru_cache(None)\\n        def dfs(i,j,total):\\n            if grid[i][j] == \"(\":\\n                total += 1\\n            else:\\n                total -= 1  \\n \\n            if total < 0:\\n                return False\\n\\n            if i == m-1 and j == n-1 and total == 0:\\n                return True\\n\\n            if i+1 < m and dfs(i+1,j,total):\\n                return True\\n\\n            if j+1 < n and dfs(i,j+1,total):\\n                return True\\n\\n        return dfs(0,0,0)\\n\\n        \\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        @lru_cache(None)\\n        def dfs(i,j,total):\\n            if grid[i][j] == \"(\":\\n                total += 1\\n            else:\\n                total -= 1  \\n \\n            if total < 0:\\n                return False\\n\\n            if i == m-1 and j == n-1 and total == 0:\\n                return True\\n\\n            if i+1 < m and dfs(i+1,j,total):\\n                return True\\n\\n            if j+1 < n and dfs(i,j+1,total):\\n                return True\\n\\n        return dfs(0,0,0)\\n\\n        \\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724242,
                "title": "python-dfs-faster-than-100",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def dfs(y, x, t):\\n            if ans[0] or (y, x, t) in seen: return\\n            if x + y + 1 == l:\\n                if t == 0: ans[0] = True\\n                return\\n            if t + x + y + 1 > l: return\\n            seen.add((y, x, t))\\n            for yy, xx in (y + 1, x), (y, x + 1):\\n                if not (0 <= xx < n and 0 <= yy < m): continue\\n                tt = t + (-1) ** (grid[yy][xx] == \\')\\')\\n                if (yy, xx, tt) in seen or tt < 0: continue\\n                dfs(yy, xx, tt)\\n                \\n        m, n, l = len(grid), len(grid[0]), len(grid) + len(grid[0]) - 1\\n        if l % 2: return False\\n        seen, ans = set(), [False]\\n        dfs(0, -1, 0)\\n        return ans[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def dfs(y, x, t):\\n            if ans[0] or (y, x, t) in seen: return\\n            if x + y + 1 == l:\\n                if t == 0: ans[0] = True\\n                return\\n            if t + x + y + 1 > l: return\\n            seen.add((y, x, t))\\n            for yy, xx in (y + 1, x), (y, x + 1):\\n                if not (0 <= xx < n and 0 <= yy < m): continue\\n                tt = t + (-1) ** (grid[yy][xx] == \\')\\')\\n                if (yy, xx, tt) in seen or tt < 0: continue\\n                dfs(yy, xx, tt)\\n                \\n        m, n, l = len(grid), len(grid[0]), len(grid) + len(grid[0]) - 1\\n        if l % 2: return False\\n        seen, ans = set(), [False]\\n        dfs(0, -1, 0)\\n        return ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666464,
                "title": "greedy-dp-concepts",
                "content": "```\\nif it is \\'(\\' increment score else decrement it\\nif you don\\'t know why i am doing that check out these problems first \\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\nhttps://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/\\nhttps://leetcode.com/problems/valid-parenthesis-string/\\n\\n\\n\\nnow, for every valid cell, we can either move down or move right \\nat the end of the moves, i.e right end of the cell\\nif score == 0, we are good to go else return false;\\n\\nclass Solution {\\npublic:\\n    \\n    bool solve(int x, int y, int x_bound, int y_bound, int score,vector<vector<char>>&table, vector<vector<vector<int>>>&dp){\\n           // at each point score must be greater than or equal to 0\\n         bool move_down=false, move_right= false;\\n          \\n          if(x < x_bound && y < y_bound){\\n                   \\n                \\n                  if(table[x][y]==\\'(\\')++score;\\n                  else score --;\\n                  \\n                  if(score < 0)return false;\\n                 \\n                    if(dp[x][y][score]!=-1)return dp[x][y][score];\\n              \\n                   move_down = solve(x+1,y,x_bound,y_bound, score,table,dp);\\n                   move_right = solve(x, y+1, x_bound, y_bound, score, table,dp);\\n          }\\n          \\n          else if( (x==x_bound-1 && y==y_bound ) || (x==x_bound && y==y_bound-1)){\\n               \\n                 return score==0;\\n          }\\n          \\n        \\n          return dp[x][y][score]=move_down|| move_right;\\n           \\n          \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n         \\n        vector<vector<vector<int>>>dp(grid.size()+1, vector<vector<int>>(grid[0].size()+1,vector<int>(grid.size()+grid[0].size(),-1)));\\n        \\n        return solve(0,0,grid.size(), grid[0].size(),0,grid,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nif it is \\'(\\' increment score else decrement it\\nif you don\\'t know why i am doing that check out these problems first \\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/\\nhttps://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/\\nhttps://leetcode.com/problems/valid-parenthesis-string/\\n\\n\\n\\nnow, for every valid cell, we can either move down or move right \\nat the end of the moves, i.e right end of the cell\\nif score == 0, we are good to go else return false;\\n\\nclass Solution {\\npublic:\\n    \\n    bool solve(int x, int y, int x_bound, int y_bound, int score,vector<vector<char>>&table, vector<vector<vector<int>>>&dp){\\n           // at each point score must be greater than or equal to 0\\n         bool move_down=false, move_right= false;\\n          \\n          if(x < x_bound && y < y_bound){\\n                   \\n                \\n                  if(table[x][y]==\\'(\\')++score;\\n                  else score --;\\n                  \\n                  if(score < 0)return false;\\n                 \\n                    if(dp[x][y][score]!=-1)return dp[x][y][score];\\n              \\n                   move_down = solve(x+1,y,x_bound,y_bound, score,table,dp);\\n                   move_right = solve(x, y+1, x_bound, y_bound, score, table,dp);\\n          }\\n          \\n          else if( (x==x_bound-1 && y==y_bound ) || (x==x_bound && y==y_bound-1)){\\n               \\n                 return score==0;\\n          }\\n          \\n        \\n          return dp[x][y][score]=move_down|| move_right;\\n           \\n          \\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n         \\n        vector<vector<vector<int>>>dp(grid.size()+1, vector<vector<int>>(grid[0].size()+1,vector<int>(grid.size()+grid[0].size(),-1)));\\n        \\n        return solve(0,0,grid.size(), grid[0].size(),0,grid,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644712,
                "title": "simple-dfs-dp-solution-2-ways",
                "content": "Normal DFS + DP, Java/C++/JS folk friendly\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        dp = [[[-1] * (numRows + numCols + 1) for _ in range(numCols)] for _ in range(numRows)]\\n        \\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid, dp\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            if dp[row][col][balance] != -1:\\n                return dp[row][col][balance]\\n            dp[row][col][balance] = dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n            return dp[row][col][balance]\\n        \\n        return dfs(0, 0, 0)\\n```\\n\\nUsing @cache: Python-specific\\n\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            return dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n        \\n        return dfs(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        dp = [[[-1] * (numRows + numCols + 1) for _ in range(numCols)] for _ in range(numRows)]\\n        \\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid, dp\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            if dp[row][col][balance] != -1:\\n                return dp[row][col][balance]\\n            dp[row][col][balance] = dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n            return dp[row][col][balance]\\n        \\n        return dfs(0, 0, 0)\\n```\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        numRows, numCols = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(row: int, col: int, balance: int) -> bool:\\n            nonlocal grid\\n            if row >= numRows or col >= numCols:\\n                return 0\\n            if grid[row][col] == \\'(\\':\\n                balance += 1\\n            else:\\n                balance -= 1\\n            if balance < 0:\\n                return 0\\n            if row == numRows - 1 and col == numCols - 1:\\n                return balance == 0\\n            return dfs(row + 1, col, balance) or dfs(row, col + 1, balance)\\n        \\n        return dfs(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597457,
                "title": "python3",
                "content": "class Solution:\\n\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        cache = {}\\n        m,n = len(grid),len(grid[0])\\n        lRow,lCol = m-1,n-1\\n        \\n        def dfs(i,j,bal):\\n            if i in [-1,m] or j in [-1,n] or bal<0:\\n                return False\\n            if (i,j,bal) not in cache:\\n                updatedBal = bal+(1 if grid[i][j]==\\'(\\' else -1)\\n                if (i,j) == (lRow,lCol) and updatedBal==0:\\n                    return True\\n                valid = dfs(i+1,j,updatedBal) or dfs(i,j+1,updatedBal)\\n                cache[(i,j,bal)] = valid\\n            return cache[(i,j,bal)]\\n        \\n        return dfs(0,0,0)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        cache = {}",
                "codeTag": "Java"
            },
            {
                "id": 2489279,
                "title": "dp-cpp-solution",
                "content": "`****`\\nclass Solution {\\npublic:\\n    bool fun(vector<vector<char>> &grid,int i,int j,int a,int m,int n,vector<vector<vector<int>>> &dp){\\n        if(i==(m-1) && j==(n-1)){\\n            if(grid[i][j]==\\')\\' && a==1)\\n                return true;\\n            return false;\\n        }\\n        if(a<0)\\n            return false;\\n        if(dp[i][j][a]!=-1)\\n            return dp[i][j][a];\\n        int p=a;\\n        if(grid[i][j]==\\'(\\')\\n            p+=1;\\n        else\\n            p-=1;\\n        if(i<(m-1) && j<(n-1))\\n            return dp[i][j][a]=(fun(grid,i,j+1,p,m,n,dp) || fun(grid,i+1,j,p,m,n,dp));\\n        if(i<(m-1))\\n            return dp[i][j][a]=fun(grid,i+1,j,p,m,n,dp);\\n        else\\n            return dp[i][j][a]=fun(grid,i,j+1,p,m,n,dp);\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<vector<int>>> dp(m,vector<vector<int>>(n,vector<int>(m+n,-1)));\\n        return fun(grid,0,0,0,m,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool fun(vector<vector<char>> &grid,int i,int j,int a,int m,int n,vector<vector<vector<int>>> &dp){\\n        if(i==(m-1) && j==(n-1)){\\n            if(grid[i][j]==\\')\\' && a==1)\\n                return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2453497,
                "title": "rust-dynamic-programming",
                "content": "~~~\\n// the important step is to use the first index to trace: # of \\'(\\' - # of \\')\\' and\\n// to ignore those invalid cases where  # of \\'(\\' < # of \\')\\'\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut dp = vec![vec![vec![-1; m + n]; n] ; m];\\n        \\n        Self::solve(&grid, &mut dp, 0, 0, 0) == 1\\n    }\\n    \\n    fn solve(grid: &Vec<Vec<char>>, dp: &mut Vec<Vec<Vec<i32>>>, i: usize, j: usize, k: usize) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        if i == m || j == n { return 0 }\\n        \\n        let mut k = k as i32;\\n        k += if grid[i][j] == \\'(\\' { 1 } else { -1 };\\n        if (k < 0) { return 0 }\\n        let k = k as usize;\\n        \\n        if i == m - 1 && j == n - 1 { \\n            return if k == 0 { 1 } else { 0 }\\n        }\\n        \\n        if dp[i][j][k] != -1 { return dp[i][j][k] }\\n        dp[i][j][k] = if Self::solve(grid, dp, i + 1, j, k) == 1 || Self::solve(grid, dp, i, j + 1, k) == 1 { 1 } else { 0 };\\n        \\n        dp[i][j][k]\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Dynamic Programming"
                ],
                "code": "~~~\\n// the important step is to use the first index to trace: # of \\'(\\' - # of \\')\\' and\\n// to ignore those invalid cases where  # of \\'(\\' < # of \\')\\'\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        let mut dp = vec![vec![vec![-1; m + n]; n] ; m];\\n        \\n        Self::solve(&grid, &mut dp, 0, 0, 0) == 1\\n    }\\n    \\n    fn solve(grid: &Vec<Vec<char>>, dp: &mut Vec<Vec<Vec<i32>>>, i: usize, j: usize, k: usize) -> i32 {\\n        let (m, n) = (grid.len(), grid[0].len());\\n        if i == m || j == n { return 0 }\\n        \\n        let mut k = k as i32;\\n        k += if grid[i][j] == \\'(\\' { 1 } else { -1 };\\n        if (k < 0) { return 0 }\\n        let k = k as usize;\\n        \\n        if i == m - 1 && j == n - 1 { \\n            return if k == 0 { 1 } else { 0 }\\n        }\\n        \\n        if dp[i][j][k] != -1 { return dp[i][j][k] }\\n        dp[i][j][k] = if Self::solve(grid, dp, i + 1, j, k) == 1 || Self::solve(grid, dp, i, j + 1, k) == 1 { 1 } else { 0 };\\n        \\n        dp[i][j][k]\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2443083,
                "title": "simple-and-clean-python-solution-with-dp-o-mn-m-n",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        R, C = len(grid), len(grid[0])\\n        dp = [[[False for i in range(R+C+1)] for c in range(C+1)] for r in range(R+1)]\\n        dp[R][C-1][0] = True\\n        dp[R-1][C][0] = True\\n        for r in range(R-1, -1, -1):\\n            for c in range(C-1, -1, -1):\\n                for i in range(R+C):\\n                    nxt = [1,-1][grid[r][c] == \")\"]\\n                    dp[r][c][i] = dp[r+1][c][i+nxt] or dp[r][c+1][i+nxt]\\n        return dp[0][0][0]\\n                    \\n```\\n**EDIT:**\\nThe solution can be made 2 times faster by running the innermost loop only till ```(R+C)//2 + 1``` as the bracket overhead above it can never be fulfilled. It really makes a difference particularly in this question.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        R, C = len(grid), len(grid[0])\\n        dp = [[[False for i in range(R+C+1)] for c in range(C+1)] for r in range(R+1)]\\n        dp[R][C-1][0] = True\\n        dp[R-1][C][0] = True\\n        for r in range(R-1, -1, -1):\\n            for c in range(C-1, -1, -1):\\n                for i in range(R+C):\\n                    nxt = [1,-1][grid[r][c] == \")\"]\\n                    dp[r][c][i] = dp[r+1][c][i+nxt] or dp[r][c+1][i+nxt]\\n        return dp[0][0][0]\\n                    \\n```\n```(R+C)//2 + 1```",
                "codeTag": "Java"
            },
            {
                "id": 2379590,
                "title": "javascript-beat-100",
                "content": "```\\nvar hasValidPath = function (grid) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  let visited = {};\\n\\n  if ((m + n - 1) % 2 !== 0) return false;\\n  if (grid[0][0] !== \"(\" || grid[m - 1][n - 1] !== \")\") return false;\\n\\n  function helper(i, j, bal) {\\n    if (i >= m || j >= n) return false;\\n    if (bal > m + n - i - j) return false;\\n\\n    if (grid[i][j] === \"(\") bal++;\\n    else bal--;\\n    if (bal < 0) return false;\\n    if (i === m - 1 && j === n - 1) return bal === 0;\\n\\n    let key = `${i},${j},${bal}`;\\n    if (visited[key] !== undefined) return visited[key];\\n    return (visited[key] = helper(i + 1, j, bal) || helper(i, j + 1, bal));\\n  }\\n  return helper(0, 0, 0);\\n};",
                "solutionTags": [],
                "code": "```\\nvar hasValidPath = function (grid) {\\n  let m = grid.length;\\n  let n = grid[0].length;\\n  let visited = {};\\n\\n  if ((m + n - 1) % 2 !== 0) return false;\\n  if (grid[0][0] !== \"(\" || grid[m - 1][n - 1] !== \")\") return false;\\n\\n  function helper(i, j, bal) {\\n    if (i >= m || j >= n) return false;\\n    if (bal > m + n - i - j) return false;\\n\\n    if (grid[i][j] === \"(\") bal++;\\n    else bal--;\\n    if (bal < 0) return false;\\n    if (i === m - 1 && j === n - 1) return bal === 0;\\n\\n    let key = `${i},${j},${bal}`;\\n    if (visited[key] !== undefined) return visited[key];\\n    return (visited[key] = helper(i + 1, j, bal) || helper(i, j + 1, bal));\\n  }\\n  return helper(0, 0, 0);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2377927,
                "title": "simple-c-solution-no-showoff",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ans = false;\\n    int dp[100][100][200];\\n    bool solve(int i, int j, int balance, vector<vector<char>>& g) {\\n        \\n        if(balance < 0) return false;\\n\\n        if(i == g.size() - 1 && j == g[0].size() - 1)  return balance == 0;\\n        if(dp[i][j][balance] != -1) return dp[i][j][balance];\\n        \\n        \\n        \\n        bool ans = false;\\n        if(i + 1 < g.size()) {\\n            int newBalance = (g[i + 1][j] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i + 1, j, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        } \\n        \\n        if(j + 1 < g[0].size()) {\\n            int newBalance = (g[i][j + 1] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i, j + 1, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        }\\n        \\n        return dp[i][j][balance] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        int balance = g[0][0] == \\'(\\' ? 1 : -1;\\n        if(balance < 0) return false;\\n        return solve(0, 0, balance, g);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans = false;\\n    int dp[100][100][200];\\n    bool solve(int i, int j, int balance, vector<vector<char>>& g) {\\n        \\n        if(balance < 0) return false;\\n\\n        if(i == g.size() - 1 && j == g[0].size() - 1)  return balance == 0;\\n        if(dp[i][j][balance] != -1) return dp[i][j][balance];\\n        \\n        \\n        \\n        bool ans = false;\\n        if(i + 1 < g.size()) {\\n            int newBalance = (g[i + 1][j] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i + 1, j, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        } \\n        \\n        if(j + 1 < g[0].size()) {\\n            int newBalance = (g[i][j + 1] == \\'(\\' ? balance + 1 : balance - 1);\\n            if(newBalance >= 0) ans = ans or solve(i, j + 1, newBalance, g);\\n            if(ans) return dp[i][j][balance] = ans;\\n        }\\n        \\n        return dp[i][j][balance] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        int balance = g[0][0] == \\'(\\' ? 1 : -1;\\n        if(balance < 0) return false;\\n        return solve(0, 0, balance, g);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300021,
                "title": "leetcode-the-hard-way-dfs-dp-with-memo",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), mxN = 105;\\n        vector<vector<vector<int>>> dp(mxN, vector<vector<int>>(mxN, vector<int>(mxN * 2, -1)));\\n        function<bool(int, int, int)> dfs = [&](int i, int j, int k) -> bool {\\n            // out of bound - return false\\n            if (i == n || j == m) return false;\\n            // count the overall balance\\n            k += grid[i][j] == \\'(\\' ? 1 : -1;\\n            // negative balance - return false\\n            // e.g. ()) is invalid (k = -1)\\n            if (k < 0) return false;\\n            // if it reaches the target cell \\n            // and the balance is 0, e.g. ((()))\\n            // then return true \\n            if (i == n - 1 && j == m - 1 && k == 0) return true;\\n            // if the result is calculated before, return it directly\\n            if (dp[i][j][k] != -1) return dp[i][j][k];\\n            // otherwise, we either move right or move down\\n            return dp[i][j][k] = dfs(i + 1, j, k) || dfs(i, j + 1, k);\\n        };\\n        // starting from top left cell with balance = 0\\n        return dfs(0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size(), mxN = 105;\\n        vector<vector<vector<int>>> dp(mxN, vector<vector<int>>(mxN, vector<int>(mxN * 2, -1)));\\n        function<bool(int, int, int)> dfs = [&](int i, int j, int k) -> bool {\\n            // out of bound - return false\\n            if (i == n || j == m) return false;\\n            // count the overall balance\\n            k += grid[i][j] == \\'(\\' ? 1 : -1;\\n            // negative balance - return false\\n            // e.g. ()) is invalid (k = -1)\\n            if (k < 0) return false;\\n            // if it reaches the target cell \\n            // and the balance is 0, e.g. ((()))\\n            // then return true \\n            if (i == n - 1 && j == m - 1 && k == 0) return true;\\n            // if the result is calculated before, return it directly\\n            if (dp[i][j][k] != -1) return dp[i][j][k];\\n            // otherwise, we either move right or move down\\n            return dp[i][j][k] = dfs(i + 1, j, k) || dfs(i, j + 1, k);\\n        };\\n        // starting from top left cell with balance = 0\\n        return dfs(0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281138,
                "title": "c-solution",
                "content": "Approach:\\n```\\n#define vvvi vector<vector<vector<int>>>\\n#define vvc vector<vector<char>> \\n\\nclass Solution {\\npublic:\\n    \\n    bool f(int i, int j, int close, vvc &grid, vvvi &dp) {\\n        if(i < 0 || j < 0 || close < 0) return 0;\\n        \\n        // What did u encounter at current cell? \\n        // Rem: Traversing right to left in a potential Valid VPS\\n        if(grid[i][j] == \\')\\') close++;\\n        else close--;\\n        \\n        if(i == 0 and j == 0) {\\n            // Top-Left cell\\n            return (close == 0);\\n        }\\n        \\n        if(close < 0) return 0;\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        // Move up(i-1, j) or move left(i, j-1)\\n        // Now u should move up or left only when u are still satisfying vps\\n        \\n        return dp[i][j][close] = (f(i-1, j, close, grid, dp) || f(i, j-1, close, grid, dp));\\n    }\\n    \\n    \\n    // Idea is while moving left or right, go only where u can make a valid path\\n    // Check validity while choosing.\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvvi dp(m, vector<vector<int>> (n, vector<int> (201, -1)));\\n        \\n        // I am starting from bottom-right cell meaning back of a possible vps\\n        // So, I should encounter closing brackets from end )\\n        \\n        return f(m-1, n-1, 0, grid, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define vvvi vector<vector<vector<int>>>\\n#define vvc vector<vector<char>> \\n\\nclass Solution {\\npublic:\\n    \\n    bool f(int i, int j, int close, vvc &grid, vvvi &dp) {\\n        if(i < 0 || j < 0 || close < 0) return 0;\\n        \\n        // What did u encounter at current cell? \\n        // Rem: Traversing right to left in a potential Valid VPS\\n        if(grid[i][j] == \\')\\') close++;\\n        else close--;\\n        \\n        if(i == 0 and j == 0) {\\n            // Top-Left cell\\n            return (close == 0);\\n        }\\n        \\n        if(close < 0) return 0;\\n        \\n        if(dp[i][j][close] != -1) return dp[i][j][close];\\n        \\n        // Move up(i-1, j) or move left(i, j-1)\\n        // Now u should move up or left only when u are still satisfying vps\\n        \\n        return dp[i][j][close] = (f(i-1, j, close, grid, dp) || f(i, j-1, close, grid, dp));\\n    }\\n    \\n    \\n    // Idea is while moving left or right, go only where u can make a valid path\\n    // Check validity while choosing.\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        vvvi dp(m, vector<vector<int>> (n, vector<int> (201, -1)));\\n        \\n        // I am starting from bottom-right cell meaning back of a possible vps\\n        // So, I should encounter closing brackets from end )\\n        \\n        return f(m-1, n-1, 0, grid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174607,
                "title": "why-bfs-wth-backtracking-got-tle-how-can-i-memoise",
                "content": "class Solution {\\npublic:\\n    int m,n;\\n    int dx[2]={1,0};\\n    int dy[2]={0,1};\\n    vector<vector<int>>vis;\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        m=grid.size();\\n        n=grid[0].size();\\n        vis.resize(m,vector<int>(n,false));\\n        if(grid[0][0]==\\')\\')\\n        {\\n            return false;\\n        }\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,1}});\\n        vis[0][0]=true;\\n        while(!q.empty())\\n        {   \\n            auto it=q.front();\\n            q.pop();\\n            int i=it.first;\\n            int j=it.second.first;\\n            int cnt=it.second.second;\\n            if(i==m-1 && j==n-1 && cnt==0)\\n            {\\n                return true;\\n            }\\n            for(int k=0;k<2;k++)\\n            {\\n                int newi=i+dx[k];\\n                int newj=j+dy[k];\\n                if(newi>=0 && newi<m && newj>=0 && newj<n && grid[newi][newj]==\\')\\' && !vis[newi][newj])\\n                {\\n                    vis[newi][newj]=true;\\n                    q.push({newi,{newj,cnt-1}});\\n                    vis[newi][newj]=false;\\n                }\\n                else if(newi>=0 && newi<m && newj>=0 && newj<n && grid[newi][newj]==\\'(\\' && !vis[newi][newj])\\n                {\\n                    vis[newi][newj]=true;\\n                    q.push({newi,{newj,cnt+1}});\\n                    vis[newi][newj]=false;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int m,n;\\n    int dx[2]={1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2169233,
                "title": "python-go-blazing-fast-dp-w-backtracking-o-mn-m-n",
                "content": "*Python* solution w/ bitset in 321ms beat 98% :)\\n\\n```python\\ndef hasValidPath(self, grid):\\n    dp = [[0] * 101 for _ in range(101)]\\n    dp[0][1] = 1\\n    for i, row in enumerate(grid, 1):                               # O(M)\\n        for j, c in enumerate(row, 1):                              # O(N)\\n            dp[i][j] = dp[i][j - 1] | dp[i - 1][j]                  # O(M+N) bitset union\\n            dp[i][j] = dp[i][j] << 1 if c == \"(\" else dp[i][j] >> 1 # O(M+N) bitset shift\\n    return dp[i][j] & 1\\n```\\n\\n*Go* solution w/ bitset in 3ms beat 100% :)\\n\\n```go\\ntype bitset [2]uint64\\n\\nfunc (x *bitset) set0()        { x[0] = 1 }\\nfunc (x *bitset) get0() uint64 { return x[0] & 1 }\\nfunc (x *bitset) union(y bitset) bitset {\\n\\tvar z bitset\\n\\tz[0] = x[0] | y[0]\\n\\tz[1] = x[1] | y[1]\\n\\treturn z\\n}\\nfunc (x *bitset) lsh1() {\\n\\ty := x[0]\\n\\ty >>= 63\\n\\tx[0] <<= 1\\n\\tx[1] <<= 1\\n\\tx[1] |= y\\n}\\nfunc (x *bitset) rsh1() {\\n\\ty := x[1]\\n\\ty <<= 63\\n\\tx[1] >>= 1\\n\\tx[0] >>= 1\\n\\tx[0] |= y\\n}\\n\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm  = len(grid)\\n\\t\\tn  = len(grid[0])\\n\\t\\tdp [101][101]bitset\\n\\t)\\n\\tdp[0][1].set0()\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tdp[x][y] = dp[i][y].union(dp[x][j])\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tdp[x][y].lsh1()\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[x][y].rsh1()\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n].get0() == 1\\n}\\n```\\n\\n*Go* solution w/ boolean array\\n\\n```go\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm = len(grid)\\n\\t\\tn = len(grid[0])\\n\\t\\tl = m + n\\n\\t)\\n\\tdp := make([][][]bool, m+1)\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tdp[i] = make([][]bool, n+1)\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tdp[i][j] = make([]bool, l+1)\\n\\t\\t}\\n\\t}\\n\\tdp[0][1][0] = true\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tfor k := 0; k <= l; k++ {\\n\\t\\t\\t\\tdp[x][y][k] = dp[i][y][k] || dp[x][j][k]\\n\\t\\t\\t}\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tfor k := l; k >= 1; k-- {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k-1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[x][y][0] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor k := 0; k < l; k++ {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k+1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n][0]\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef hasValidPath(self, grid):\\n    dp = [[0] * 101 for _ in range(101)]\\n    dp[0][1] = 1\\n    for i, row in enumerate(grid, 1):                               # O(M)\\n        for j, c in enumerate(row, 1):                              # O(N)\\n            dp[i][j] = dp[i][j - 1] | dp[i - 1][j]                  # O(M+N) bitset union\\n            dp[i][j] = dp[i][j] << 1 if c == \"(\" else dp[i][j] >> 1 # O(M+N) bitset shift\\n    return dp[i][j] & 1\\n```\n```go\\ntype bitset [2]uint64\\n\\nfunc (x *bitset) set0()        { x[0] = 1 }\\nfunc (x *bitset) get0() uint64 { return x[0] & 1 }\\nfunc (x *bitset) union(y bitset) bitset {\\n\\tvar z bitset\\n\\tz[0] = x[0] | y[0]\\n\\tz[1] = x[1] | y[1]\\n\\treturn z\\n}\\nfunc (x *bitset) lsh1() {\\n\\ty := x[0]\\n\\ty >>= 63\\n\\tx[0] <<= 1\\n\\tx[1] <<= 1\\n\\tx[1] |= y\\n}\\nfunc (x *bitset) rsh1() {\\n\\ty := x[1]\\n\\ty <<= 63\\n\\tx[1] >>= 1\\n\\tx[0] >>= 1\\n\\tx[0] |= y\\n}\\n\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm  = len(grid)\\n\\t\\tn  = len(grid[0])\\n\\t\\tdp [101][101]bitset\\n\\t)\\n\\tdp[0][1].set0()\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tdp[x][y] = dp[i][y].union(dp[x][j])\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tdp[x][y].lsh1()\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[x][y].rsh1()\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n].get0() == 1\\n}\\n```\n```go\\nfunc hasValidPath(grid [][]byte) bool {\\n\\tvar (\\n\\t\\tm = len(grid)\\n\\t\\tn = len(grid[0])\\n\\t\\tl = m + n\\n\\t)\\n\\tdp := make([][][]bool, m+1)\\n\\tfor i := 0; i <= m; i++ {\\n\\t\\tdp[i] = make([][]bool, n+1)\\n\\t\\tfor j := 0; j <= n; j++ {\\n\\t\\t\\tdp[i][j] = make([]bool, l+1)\\n\\t\\t}\\n\\t}\\n\\tdp[0][1][0] = true\\n\\tfor i, x := 0, 1; i < m; i, x = i+1, x+1 {\\n\\t\\tfor j, y := 0, 1; j < n; j, y = j+1, y+1 {\\n\\t\\t\\tfor k := 0; k <= l; k++ {\\n\\t\\t\\t\\tdp[x][y][k] = dp[i][y][k] || dp[x][j][k]\\n\\t\\t\\t}\\n\\t\\t\\tif grid[i][j] == \\'(\\' {\\n\\t\\t\\t\\tfor k := l; k >= 1; k-- {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k-1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[x][y][0] = false\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor k := 0; k < l; k++ {\\n\\t\\t\\t\\t\\tdp[x][y][k] = dp[x][y][k+1]\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[m][n][0]\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2164785,
                "title": "python-lru-cache",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, x: List[List[str]]) -> bool:\\n        m,n=len(x),len(x[0])    \\n        @lru_cache(None)\\n        def f(i,j,c):\\n            if i==m-1 and j==n-1:return not c\\n            ans=False\\n            for d,e in ((i+1,j),(i,j+1)):\\n                if d<m and e<n:\\n                    if x[d][e]==\\'(\\':\\n                        ans=ans or f(d,e,c+1)\\n                    else:\\n                        if c:\\n                            ans=ans or f(d,e,c-1)\\n            return ans\\n        return False if x[0][0]==\\')\\' else f(0,0,1) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, x: List[List[str]]) -> bool:\\n        m,n=len(x),len(x[0])    \\n        @lru_cache(None)\\n        def f(i,j,c):\\n            if i==m-1 and j==n-1:return not c\\n            ans=False\\n            for d,e in ((i+1,j),(i,j+1)):\\n                if d<m and e<n:\\n                    if x[d][e]==\\'(\\':\\n                        ans=ans or f(d,e,c+1)\\n                    else:\\n                        if c:\\n                            ans=ans or f(d,e,c-1)\\n            return ans\\n        return False if x[0][0]==\\')\\' else f(0,0,1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159103,
                "title": "python-solution-easy-to-understand-caching",
                "content": "The way this solution works is\\n1. There is a stack variable which acts as a Counter, so if the value of stack is 0 it means the stack is empty. On \"(\" we increment the value (append) of stack and on \")\" we decrement the value (pop) from stack.\\n2. lru_cache is used to avoid the calculation of same values again (Memoization). \\n```\\nn,m=len(grid),len(grid[0])\\nstack=0\\n@lru_cache(None)\\ndef recursion(row,col,stack):\\n\\t#Checking the indexes are within the range\\n\\tif row<0 or row>=n or col<0 or col>=m:\\n\\t\\treturn False\\n\\n\\t#Check that on reaching the last block value of stack is 1 and the parenthesis is closing\\t\\n\\tif row==n-1 and col==m-1:\\n\\t\\tif stack==1 and grid[row][col]==\")\":\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t#Updating the stack based on the input\\n\\tif grid[row][col]==\"(\":\\n\\t\\tstack+=1\\n\\telse:\\n\\t\\tif stack:\\n\\t\\t\\tstack-=1\\n\\t\\telse:\\n\\t\\t\\treturn False\\n\\n\\tfor index in [[row+1,col],[row,col+1]]:\\n\\t#if a valid path is found we don\\'t calculate for other paths and return\\n\\t\\tif recursion(index[0],index[1],stack):\\n\\t\\t\\treturn True\\n\\treturn False\\nreturn recursion(0,0,stack)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "The way this solution works is\\n1. There is a stack variable which acts as a Counter, so if the value of stack is 0 it means the stack is empty. On \"(\" we increment the value (append) of stack and on \")\" we decrement the value (pop) from stack.\\n2. lru_cache is used to avoid the calculation of same values again (Memoization). \\n```\\nn,m=len(grid),len(grid[0])\\nstack=0\\n@lru_cache(None)\\ndef recursion(row,col,stack):\\n\\t#Checking the indexes are within the range\\n\\tif row<0 or row>=n or col<0 or col>=m:\\n\\t\\treturn False\\n\\n\\t#Check that on reaching the last block value of stack is 1 and the parenthesis is closing\\t\\n\\tif row==n-1 and col==m-1:\\n\\t\\tif stack==1 and grid[row][col]==\")\":\\n\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\t#Updating the stack based on the input\\n\\tif grid[row][col]==\"(\":\\n\\t\\tstack+=1\\n\\telse:\\n\\t\\tif stack:\\n\\t\\t\\tstack-=1\\n\\t\\telse:\\n\\t\\t\\treturn False\\n\\n\\tfor index in [[row+1,col],[row,col+1]]:\\n\\t#if a valid path is found we don\\'t calculate for other paths and return\\n\\t\\tif recursion(index[0],index[1],stack):\\n\\t\\t\\treturn True\\n\\treturn False\\nreturn recursion(0,0,stack)",
                "codeTag": "Python3"
            },
            {
                "id": 2130285,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\n    int dp[100][100][200];\\n    bool dfs(vector<vector<char>>& g, int x, int y, int balance) {\\n        if (x == g.size() || y == g[0].size())\\n            return false;\\n        if (g[x][y] == \\'(\\')\\n            balance++;\\n        else\\n            balance--;\\n        if (balance < 0)\\n            return false;\\n        if (x == g.size() - 1 && y == g[0].size() - 1)\\n            return balance == 0;\\n        if (dp[x][y][balance] == -1)\\n            dp[x][y][balance] = dfs(g, x + 1, y, balance) || dfs(g, x, y + 1, balance);\\n        return dp[x][y][balance];\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(g, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[100][100][200];\\n    bool dfs(vector<vector<char>>& g, int x, int y, int balance) {\\n        if (x == g.size() || y == g[0].size())\\n            return false;\\n        if (g[x][y] == \\'(\\')\\n            balance++;\\n        else\\n            balance--;\\n        if (balance < 0)\\n            return false;\\n        if (x == g.size() - 1 && y == g[0].size() - 1)\\n            return balance == 0;\\n        if (dp[x][y][balance] == -1)\\n            dp[x][y][balance] = dfs(g, x + 1, y, balance) || dfs(g, x, y + 1, balance);\\n        return dp[x][y][balance];\\n    }\\npublic:\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(g, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119954,
                "title": "java-recursion-with-memorization",
                "content": "It\\'s more like a top-down DP.\\n\\nI find that TLE is very strict. If I use set or map to memorize it will get TLE while 3D array pass.\\n\\n```\\n    public boolean hasValidPath(char[][] grid) {\\n        if (null==grid) {\\n            return false;\\n        }\\n        int rc=grid.length;\\n        int cc=grid[0].length;\\n        if (grid[0][0]!=\\'(\\'||grid[rc-1][cc-1]!=\\')\\') {\\n            return false;\\n        }\\n        int[][][] dp=new int[101][101][202];\\n        for (int i=0;i<101;i++) {\\n            for (int j=0;j<101;j++) {\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        int b=helper(1,0,0,rc,cc,grid,dp);\\n        return b==1;\\n    }\\n\\n    private int helper(int count, int ri, int ci, int rc, int cc, char[][] grid, int[][][] dp) {\\n        if (count<0) {\\n            return 0;\\n        }\\n        if (-1!=dp[ri][ci][count]) {\\n            return dp[ri][ci][count];\\n        }\\n        if (count==0&&ri==rc-1&&ci==cc-1) {\\n            return 1;\\n        }\\n        int ret=-1;\\n        if (ri<rc-1) {\\n            if (grid[ri+1][ci]==\\'(\\') {\\n                ret=helper(count+1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri+1][ci]==\\')\\') {\\n                ret=helper(count-1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1&&ci<cc-1) {\\n            if (grid[ri][ci+1]==\\'(\\') {\\n                ret=helper(count+1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri][ci+1]==\\')\\') {\\n                ret=helper(count-1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1) {\\n            dp[ri][ci][count]=0;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean hasValidPath(char[][] grid) {\\n        if (null==grid) {\\n            return false;\\n        }\\n        int rc=grid.length;\\n        int cc=grid[0].length;\\n        if (grid[0][0]!=\\'(\\'||grid[rc-1][cc-1]!=\\')\\') {\\n            return false;\\n        }\\n        int[][][] dp=new int[101][101][202];\\n        for (int i=0;i<101;i++) {\\n            for (int j=0;j<101;j++) {\\n                Arrays.fill(dp[i][j],-1);\\n            }\\n        }\\n        int b=helper(1,0,0,rc,cc,grid,dp);\\n        return b==1;\\n    }\\n\\n    private int helper(int count, int ri, int ci, int rc, int cc, char[][] grid, int[][][] dp) {\\n        if (count<0) {\\n            return 0;\\n        }\\n        if (-1!=dp[ri][ci][count]) {\\n            return dp[ri][ci][count];\\n        }\\n        if (count==0&&ri==rc-1&&ci==cc-1) {\\n            return 1;\\n        }\\n        int ret=-1;\\n        if (ri<rc-1) {\\n            if (grid[ri+1][ci]==\\'(\\') {\\n                ret=helper(count+1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri+1][ci]==\\')\\') {\\n                ret=helper(count-1,ri+1,ci,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1&&ci<cc-1) {\\n            if (grid[ri][ci+1]==\\'(\\') {\\n                ret=helper(count+1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n            if (ret!=1&&grid[ri][ci+1]==\\')\\') {\\n                ret=helper(count-1,ri,ci+1,rc,cc,grid,dp);\\n            }\\n        }\\n        if (ret!=1) {\\n            dp[ri][ci][count]=0;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2119317,
                "title": "c-beginners-dp-dfs-easy-understanding",
                "content": "TL DR : **if at any point open < 0 then the path is not balanced**\\n\\n**Q ) int dp[101][101][201] ? Why 201 ?**\\nA ) As the longest possible path from top left to bottom right is of (m+n-1) length.\\n(The path only ever moves down or right.)\\n\\nNow, we have to go from the top left to bottom right by moving either down or right, the first point we get is to have a valid parantheses, the count of open = close, so if at any point the count of open < 0, then the path is not balanced and we return false.\\n\\nHere the changing variables are i, j ( curr grid pos ) and the count of open and close brackets, it\\'ll be much complex to consider anothet variable for closed brackets count so we add +1 to open when we see a \\'( \\' & subtract -1 when we see a \\')\\'.\\n\\nfrom each position we can go either to the down (i+1, j) or right ( i, j+1), so we make 2 calls and we return true if either one of them returns true and assign it to dp[i][j][open].\\n\\nIf we somehow reach the bottom left, then we return true only when the count of open == 0 else we return false.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100][100][201];\\n    bool helper(vector<vector<char>>& grid, int i, int j, int open){\\n        if(i >= grid.size() || j >= grid[0].size()){\\n            return false;\\n        }\\n        \\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            open--;\\n        }\\n        if(open < 0){\\n            return false;\\n        }\\n        if(dp[i][j][open] != -1){\\n            return dp[i][j][open];\\n        }\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1){\\n            if(open == 0){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        int next = helper(grid, i+1, j, open) || helper(grid, i, j+1, open);\\n        return dp[i][j][open] = next;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\'){\\n            return false;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        bool ans = helper(grid, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100][100][201];\\n    bool helper(vector<vector<char>>& grid, int i, int j, int open){\\n        if(i >= grid.size() || j >= grid[0].size()){\\n            return false;\\n        }\\n        \\n        if(grid[i][j] == \\'(\\'){\\n            open++;\\n        }\\n        else{\\n            open--;\\n        }\\n        if(open < 0){\\n            return false;\\n        }\\n        if(dp[i][j][open] != -1){\\n            return dp[i][j][open];\\n        }\\n        if(i == grid.size() - 1 && j == grid[0].size() - 1){\\n            if(open == 0){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        int next = helper(grid, i+1, j, open) || helper(grid, i, j+1, open);\\n        return dp[i][j][open] = next;\\n    }\\n    \\n    \\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        if(grid[0][0] == \\')\\'){\\n            return false;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        bool ans = helper(grid, 0, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068029,
                "title": "python-dp-easy-top-down-recursive",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(i, j, trace):\\n            nonlocal m, n\\n            trace += (1 if grid[i][j] == \\'(\\' else -1)\\n            if trace < 0:\\n                return False\\n            if i == m-1 and j == n-1 and trace == 0:\\n                return True\\n            right = down = False\\n            if i + 1 < m:\\n                right = dfs(i+1, j, trace)\\n            if j + 1 < n:\\n                down = dfs(i, j+1, trace)\\n            return right or down\\n        \\n        return dfs(0,0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @cache\\n        def dfs(i, j, trace):\\n            nonlocal m, n\\n            trace += (1 if grid[i][j] == \\'(\\' else -1)\\n            if trace < 0:\\n                return False\\n            if i == m-1 and j == n-1 and trace == 0:\\n                return True\\n            right = down = False\\n            if i + 1 < m:\\n                right = dfs(i+1, j, trace)\\n            if j + 1 < n:\\n                down = dfs(i, j+1, trace)\\n            return right or down\\n        \\n        return dfs(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065236,
                "title": "c-dp-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int r,c;\\n    int dp[101][101][205];\\n    bool solve(vector<vector<char>>& g,int i,int j,int op){\\n        if(i<0 || i>=r || j<0 || j>=c) return false;\\n        if(g[i][j]==\\'(\\')op++;\\n        else op--;        \\n        if(op<0) return false;\\n        if(dp[i][j][op]!=-1) return  dp[i][j][op]==1;\\n        if(i==r-1 && j==c-1 && op==0){\\n           dp[i][j][op]=1; \\n           return true; \\n        }  \\n        return dp[i][j][op]=solve(g,i+1,j,op)||solve(g,i,j+1,op);        \\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        r=g.size(),c=g[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        if(g[0][0]==\\')\\' || g[r-1][c-1]==\\'(\\') return false;\\n        solve(g,0,0,0);\\n        return dp[r-1][c-1][0]==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r,c;\\n    int dp[101][101][205];\\n    bool solve(vector<vector<char>>& g,int i,int j,int op){\\n        if(i<0 || i>=r || j<0 || j>=c) return false;\\n        if(g[i][j]==\\'(\\')op++;\\n        else op--;        \\n        if(op<0) return false;\\n        if(dp[i][j][op]!=-1) return  dp[i][j][op]==1;\\n        if(i==r-1 && j==c-1 && op==0){\\n           dp[i][j][op]=1; \\n           return true; \\n        }  \\n        return dp[i][j][op]=solve(g,i+1,j,op)||solve(g,i,j+1,op);        \\n    }\\n    bool hasValidPath(vector<vector<char>>& g) {\\n        r=g.size(),c=g[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        if(g[0][0]==\\')\\' || g[r-1][c-1]==\\'(\\') return false;\\n        solve(g,0,0,0);\\n        return dp[r-1][c-1][0]==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046814,
                "title": "java-dfs-dp",
                "content": "\\n```\\nclass Solution {\\n    char[][] grid;\\n    int m, n;\\n    public static final char LFTPAR = \\'(\\';\\n    public static final char RGTPAR = \\')\\';\\n    public boolean hasValidPath(char[][] grid) {\\n        this.grid = grid;\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        \\n        Boolean[][][] dp = new Boolean[m][n][m+n+1];\\n        \\n        if (grid[0][0] == RGTPAR)\\n            return false;\\n        if (grid[m-1][n-1] == LFTPAR)\\n            return false;\\n        \\n        if ( (m + n) % 2 == 0)\\n            return false;\\n        \\n        return dfs(0, 0, 0, 0, dp);\\n    }\\n    private boolean dfs(int u, int v, int open, int close,  Boolean[][][] dp){\\n        if (grid[u][v] == LFTPAR){\\n            open++;\\n        } else {\\n            close++;\\n        }\\n        if (u == m-1 && v == n -1){\\n            return open == close;\\n        }\\n        if (open < close){\\n            return false;\\n        }\\n        if (dp[u][v][open-close] != null){\\n            return dp[u][v][open - close];\\n        }\\n        if (u == m - 1){\\n            if (grid[u][v] == LFTPAR){\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            } else {\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            }\\n        }\\n        if (v == n-1){\\n            if (grid[u][v] == LFTPAR){\\n                return dfs(u+1, v, open, close, dp);\\n            } else {\\n                return dfs(u+1, v, open, close, dp);\\n            }\\n        }\\n            \\n        boolean rslt = false;\\n        if (grid[u][v] == LFTPAR){\\n            rslt = dfs(u+1, v, open, close, dp) || \\n                    dfs(u, v+1, open, close, dp);\\n        } else {\\n            rslt = dfs(u, v+1, open, close, dp) ||\\n                    dfs(u + 1, v, open, close, dp);\\n        }\\n        dp[u][v][open-close] = rslt;\\n        return rslt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    char[][] grid;\\n    int m, n;\\n    public static final char LFTPAR = \\'(\\';\\n    public static final char RGTPAR = \\')\\';\\n    public boolean hasValidPath(char[][] grid) {\\n        this.grid = grid;\\n        this.m = grid.length;\\n        this.n = grid[0].length;\\n        \\n        Boolean[][][] dp = new Boolean[m][n][m+n+1];\\n        \\n        if (grid[0][0] == RGTPAR)\\n            return false;\\n        if (grid[m-1][n-1] == LFTPAR)\\n            return false;\\n        \\n        if ( (m + n) % 2 == 0)\\n            return false;\\n        \\n        return dfs(0, 0, 0, 0, dp);\\n    }\\n    private boolean dfs(int u, int v, int open, int close,  Boolean[][][] dp){\\n        if (grid[u][v] == LFTPAR){\\n            open++;\\n        } else {\\n            close++;\\n        }\\n        if (u == m-1 && v == n -1){\\n            return open == close;\\n        }\\n        if (open < close){\\n            return false;\\n        }\\n        if (dp[u][v][open-close] != null){\\n            return dp[u][v][open - close];\\n        }\\n        if (u == m - 1){\\n            if (grid[u][v] == LFTPAR){\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            } else {\\n                return dp[u][v][open-close] = dfs(u, v+1, open, close, dp);\\n            }\\n        }\\n        if (v == n-1){\\n            if (grid[u][v] == LFTPAR){\\n                return dfs(u+1, v, open, close, dp);\\n            } else {\\n                return dfs(u+1, v, open, close, dp);\\n            }\\n        }\\n            \\n        boolean rslt = false;\\n        if (grid[u][v] == LFTPAR){\\n            rslt = dfs(u+1, v, open, close, dp) || \\n                    dfs(u, v+1, open, close, dp);\\n        } else {\\n            rslt = dfs(u, v+1, open, close, dp) ||\\n                    dfs(u + 1, v, open, close, dp);\\n        }\\n        dp[u][v][open-close] = rslt;\\n        return rslt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046560,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\t\\t\\tm = len(grid)\\n\\t\\t\\tn = len(grid[0])\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i, j, cnt):\\n\\t\\t\\t\\tif i < 0 or i > m - 1 or j < 0 or j > n - 1 or grid[i][j] == \"#\":\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif grid[i][j] == \"(\":\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tif grid[i][j] == \")\":\\n\\t\\t\\t\\t\\tcnt -= 1\\n\\t\\t\\t\\tif cnt < 0:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif i == m - 1 and j == n - 1 and cnt == 0:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tcur = grid[i][j]\\n\\t\\t\\t\\tgrid[i][j] = \"#\"\\n\\t\\t\\t\\tif dfs(i + 1, j, cnt) or dfs(i, j + 1, cnt):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tgrid[i][j] = cur\\n\\t\\t\\treturn dfs(0, 0, 0)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef hasValidPath(self, grid: List[List[str]]) -> bool:\\n\\t\\t\\tm = len(grid)\\n\\t\\t\\tn = len(grid[0])\\n\\t\\t\\t@cache\\n\\t\\t\\tdef dfs(i, j, cnt):\\n\\t\\t\\t\\tif i < 0 or i > m - 1 or j < 0 or j > n - 1 or grid[i][j] == \"#\":\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif grid[i][j] == \"(\":\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\t\\tif grid[i][j] == \")\":\\n\\t\\t\\t\\t\\tcnt -= 1\\n\\t\\t\\t\\tif cnt < 0:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tif i == m - 1 and j == n - 1 and cnt == 0:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tcur = grid[i][j]\\n\\t\\t\\t\\tgrid[i][j] = \"#\"\\n\\t\\t\\t\\tif dfs(i + 1, j, cnt) or dfs(i, j + 1, cnt):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tgrid[i][j] = cur\\n\\t\\t\\treturn dfs(0, 0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 2046276,
                "title": "c-dp-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        bool f[m][n][101];\\n        for(int i=0;i<m;i++)for(int j=0;j<n;j++)for(int k=0;k<=100;k++)f[i][j][k]=false;\\n        if(grid[0][0]==\\')\\')return false;\\n        f[0][0][1]=true;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                for(int k=0;k<=100;k++)\\n                {\\n                    if(grid[i][j]==\\'(\\')\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k+1<=100)f[i][j][k+1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k+1<=100)f[i][j][k+1]=true;\\n                    }else\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k-1>=0)f[i][j][k-1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k-1>=0)f[i][j][k-1]=true;\\n                    }\\n                }\\n        return f[m-1][n-1][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        bool f[m][n][101];\\n        for(int i=0;i<m;i++)for(int j=0;j<n;j++)for(int k=0;k<=100;k++)f[i][j][k]=false;\\n        if(grid[0][0]==\\')\\')return false;\\n        f[0][0][1]=true;\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                for(int k=0;k<=100;k++)\\n                {\\n                    if(grid[i][j]==\\'(\\')\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k+1<=100)f[i][j][k+1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k+1<=100)f[i][j][k+1]=true;\\n                    }else\\n                    {\\n                        if(i-1>=0&&f[i-1][j][k]&&k-1>=0)f[i][j][k-1]=true;\\n                        if(j-1>=0&&f[i][j-1][k]&&k-1>=0)f[i][j][k-1]=true;\\n                    }\\n                }\\n        return f[m-1][n-1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039382,
                "title": "java-dp-bottom-up-approach",
                "content": "\\n```\\nclass Solution {\\n    \\n     Boolean dp[][][];\\n     public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length -1] == \\'(\\') return false;\\n        dp = new Boolean[grid.length][grid[0].length][101];\\n\\n        int rows = grid.length;\\n        int col = grid[0].length;\\n\\n        Arrays.fill(dp[rows - 1][col - 1],false);\\n        dp[rows - 1][col -1][0] = true;\\n\\n        for(int i = rows - 1;i>=0;i--){\\n            for(int j = col - 1;j>=0;j--){\\n                if(i == rows - 1 && j == col -1) continue;\\n                if(j + 1 < col){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i][j+1][k]!=null && dp[i][j+1][k]){\\n                            if(grid[i][j+1]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n                if(i+1 < rows){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i+1][j][k]!=null && dp[i+1][j][k]){\\n                            if(grid[i+1][j]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n\\n        return dp[0][0][1]!=null && dp[0][0][1];\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n     Boolean dp[][][];\\n     public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length -1] == \\'(\\') return false;\\n        dp = new Boolean[grid.length][grid[0].length][101];\\n\\n        int rows = grid.length;\\n        int col = grid[0].length;\\n\\n        Arrays.fill(dp[rows - 1][col - 1],false);\\n        dp[rows - 1][col -1][0] = true;\\n\\n        for(int i = rows - 1;i>=0;i--){\\n            for(int j = col - 1;j>=0;j--){\\n                if(i == rows - 1 && j == col -1) continue;\\n                if(j + 1 < col){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i][j+1][k]!=null && dp[i][j+1][k]){\\n                            if(grid[i][j+1]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n\\n                    }\\n                }\\n                if(i+1 < rows){\\n                    for(int k = 0; k <= 100; k++){\\n                        if(dp[i+1][j][k]!=null && dp[i+1][j][k]){\\n                            if(grid[i+1][j]==\\'(\\' ){\\n                                if(k-1>=0) {\\n                                    dp[i][j][k - 1] = true;\\n                                }\\n                            }else {\\n                                if(k+1<=100) {\\n                                dp[i][j][k+1] = true;\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n\\n        return dp[0][0][1]!=null && dp[0][0][1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039247,
                "title": "dfs-memorize",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Boolean[][][] memory = new Boolean[m][n][(m+n)/2 + 1];\\n        return dfs(0, 0, 0, grid, memory);\\n    }\\n    \\n    private boolean dfs(int leftCnt, int x, int y, char[][] grid, Boolean[][][] memory) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // boundary check\\n        if(x < 0 || y < 0 || x >= m || y >= n) {\\n            return false;\\n        }\\n        \\n        if(grid[x][y] == \\'(\\') {\\n            leftCnt++;\\n        } else if (grid[x][y] == \\')\\') {\\n            leftCnt--;\\n        }\\n        \\n            \\n        if(leftCnt < 0 || leftCnt > (m+n)/2) {\\n            // memory[x][y][leftCnt] = false;\\n            return false; \\n        }\\n        \\n       if(memory[x][y][leftCnt] != null) return memory[x][y][leftCnt]; \\n        \\n        if(x == m -1 && y == n -1 && leftCnt == 0) {\\n            memory[x][y][leftCnt]  = true;\\n            return true;\\n        }\\n        \\n        boolean valid =  dfs(leftCnt, x + 1, y, grid, memory) || dfs(leftCnt, x, y + 1, grid, memory);\\n        memory[x][y][leftCnt]  = valid;\\n        return valid;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Boolean[][][] memory = new Boolean[m][n][(m+n)/2 + 1];\\n        return dfs(0, 0, 0, grid, memory);\\n    }\\n    \\n    private boolean dfs(int leftCnt, int x, int y, char[][] grid, Boolean[][][] memory) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        // boundary check\\n        if(x < 0 || y < 0 || x >= m || y >= n) {\\n            return false;\\n        }\\n        \\n        if(grid[x][y] == \\'(\\') {\\n            leftCnt++;\\n        } else if (grid[x][y] == \\')\\') {\\n            leftCnt--;\\n        }\\n        \\n            \\n        if(leftCnt < 0 || leftCnt > (m+n)/2) {\\n            // memory[x][y][leftCnt] = false;\\n            return false; \\n        }\\n        \\n       if(memory[x][y][leftCnt] != null) return memory[x][y][leftCnt]; \\n        \\n        if(x == m -1 && y == n -1 && leftCnt == 0) {\\n            memory[x][y][leftCnt]  = true;\\n            return true;\\n        }\\n        \\n        boolean valid =  dfs(leftCnt, x + 1, y, grid, memory) || dfs(leftCnt, x, y + 1, grid, memory);\\n        memory[x][y][leftCnt]  = valid;\\n        return valid;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036439,
                "title": "python-faster-than-99-dp",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[-1][-1] == \"(\": return False\\n        if grid[0][0] == \")\": return False\\n        m, n = len(grid), len(grid[0])\\n        if (m+n) % 2 == 0: return False\\n        @cache\\n        def pos(i, j, cur):\\n            if cur == \")\": return False\\n            if i == m-1 and j == n-1:\\n                if cur == \"(\": return True\\n                return False\\n            if i >= m: return False\\n            if j >= n: return False\\n            if cur and grid[i][j] == \")\" and cur[-1] == \"(\":\\n                cur = cur[:-1]\\n            else:\\n                cur += grid[i][j]\\n            return pos(i+1, j, cur) or pos(i, j+1, cur)\\n        return pos(0,0,\"\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[-1][-1] == \"(\": return False\\n        if grid[0][0] == \")\": return False\\n        m, n = len(grid), len(grid[0])\\n        if (m+n) % 2 == 0: return False\\n        @cache\\n        def pos(i, j, cur):\\n            if cur == \")\": return False\\n            if i == m-1 and j == n-1:\\n                if cur == \"(\": return True\\n                return False\\n            if i >= m: return False\\n            if j >= n: return False\\n            if cur and grid[i][j] == \")\" and cur[-1] == \"(\":\\n                cur = cur[:-1]\\n            else:\\n                cur += grid[i][j]\\n            return pos(i+1, j, cur) or pos(i, j+1, cur)\\n        return pos(0,0,\"\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032799,
                "title": "help-needed-memo-with-tle",
                "content": "For the below JS code still getting a TLE\\nPlease help.\\n```\\nvar hasValidPath = function(a) {\\n    const [m, n] = [a.length-1, a[a.length-1].length - 1]\\n    const me = {}\\n    const getNeighbours = ([i, j]) => [[i+1, j], [i, j+1]].filter(([i, j]) => a[i]?.[j])\\n    const hasValidPathUtil = ([i, j], s) => {\\n        if(me[[i, j, s]] !== undefined) {\\n            return me[[i, j, s]]\\n        }\\n        let result = false;\\n        const val = a[i][j]\\n        if (val === \\'\\\\)\\') {\\n            if(s.length) s.pop()\\n            else {\\n                me[[i, j, s]] = result;\\n                return result;\\n            }\\n        } else {\\n            s.push(\\'\\\\(\\')\\n        }\\n        if(i === m && j === n && s.length === 0) {\\n            \\n            result = true\\n        } else {\\n            const neighbours = getNeighbours([i, j])\\n            for(let x = 0; x< neighbours.length; x++) {\\n                const [i, j] = neighbours[x]\\n                if(hasValidPathUtil([i, j], [...s])) {\\n                    result = true\\n                    break\\n                }\\n            }\\n        }\\n        me[[i, j, s]] = result;\\n        return result;\\n    }\\n\\n    let res = hasValidPathUtil([0, 0], [])\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar hasValidPath = function(a) {\\n    const [m, n] = [a.length-1, a[a.length-1].length - 1]\\n    const me = {}\\n    const getNeighbours = ([i, j]) => [[i+1, j], [i, j+1]].filter(([i, j]) => a[i]?.[j])\\n    const hasValidPathUtil = ([i, j], s) => {\\n        if(me[[i, j, s]] !== undefined) {\\n            return me[[i, j, s]]\\n        }\\n        let result = false;\\n        const val = a[i][j]\\n        if (val === \\'\\\\)\\') {\\n            if(s.length) s.pop()\\n            else {\\n                me[[i, j, s]] = result;\\n                return result;\\n            }\\n        } else {\\n            s.push(\\'\\\\(\\')\\n        }\\n        if(i === m && j === n && s.length === 0) {\\n            \\n            result = true\\n        } else {\\n            const neighbours = getNeighbours([i, j])\\n            for(let x = 0; x< neighbours.length; x++) {\\n                const [i, j] = neighbours[x]\\n                if(hasValidPathUtil([i, j], [...s])) {\\n                    result = true\\n                    break\\n                }\\n            }\\n        }\\n        me[[i, j, s]] = result;\\n        return result;\\n    }\\n\\n    let res = hasValidPathUtil([0, 0], [])\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2032444,
                "title": "3d-dynamic-programming-easy-to-understand",
                "content": "```\\nclass Solution {\\n    \\nint dp[101][101][210];\\npublic:\\n//     // Method 1: Backtracking\\n//     bool solve(vector<vector<char>> &grid, int m, int n, int i, int j, stack<char> &st, vector<vector<bool>> &vis)\\n//     {\\n//         char poop = \\'*\\';\\n//         if (st.empty())\\n//             st.push(grid[i][j]);\\n//         else\\n//         {\\n//             if (st.top() == \\'(\\' && grid[i][j] == \\')\\')\\n//             {\\n//                 st.pop();\\n//                 poop = \\'(\\';\\n//             }\\n//             else if (st.top() == \\')\\' && grid[i][j] == \\'(\\')\\n//                 return false;\\n//             else\\n//                 st.push(grid[i][j]);\\n//         }\\n        \\n//         // cout << \"i: \" << i << \" j: \" << j << endl;\\n//         if (i == m - 1 && j == n - 1)\\n//         {\\n//             if (st.empty())\\n//                 return true;\\n//         }\\n//         else\\n//         {\\n//             vector<pair<int, int>> dir = {{1, 0}, {0, 1}};\\n//             for (int a = 0; a < 2; a++)\\n//             {\\n//                 int ni = i + dir[a].first;\\n//                 int nj = j + dir[a].second;\\n                \\n//                 if (ni >= 0 && ni < m && nj >= 0 && nj < n && !vis[ni][nj])\\n//                 {\\n//                     vis[ni][nj] = true;\\n//                     if (solve(grid, m, n, ni, nj, st, vis) == true)\\n//                         return true;\\n//                     vis[ni][nj] = false;\\n//                 }\\n//             }\\n//         }\\n//         if (poop == \\'(\\')\\n//             st.push(\\'(\\');\\n//         else\\n//             st.pop();\\n//         return false;\\n//     }\\n//     bool hasValidPath(vector<vector<char>>& grid) {\\n//         int m = grid.size();\\n//         int n = grid[0].size();\\n        \\n//         vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        \\n//         stack<char> st;\\n        \\n//         vis[0][0] = true;\\n//         bool ans = solve(grid, m, n, 0, 0, st, vis);\\n//         vis[0][0] = true;\\n//         return ans;\\n//     }\\n \\n    // DP\\n    int solve(vector<vector<char>> &grid, int m, int n, int i, int j, int k)\\n    {\\n        if (i >= m || j >= n)\\n            return 0;\\n        \\n        // First we need to update k and then only see if dp[][][] != -1\\n        if (grid[i][j] == \\'(\\')\\n            k++;\\n        else\\n        {\\n            k--;\\n            if (k < 0)\\n                return 0;\\n        }\\n       \\n        if (dp[i][j][k] != -1)\\n            return dp[i][j][k];\\n        \\n        if (i == m - 1 && j == n - 1)\\n            return dp[i][j][k] = (k == 0);\\n        else       \\n        {\\n            int o1 = solve(grid, m, n, i + 1, j, k);\\n            int o2 = solve(grid, m, n, i, j + 1, k);\\n            \\n            dp[i][j][k] = (o1 | o2);\\n            return dp[i][j][k];\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solve(grid, m, n, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\nint dp[101][101][210];\\npublic:\\n//     // Method 1: Backtracking\\n//     bool solve(vector<vector<char>> &grid, int m, int n, int i, int j, stack<char> &st, vector<vector<bool>> &vis)\\n//     {\\n//         char poop = \\'*\\';\\n//         if (st.empty())\\n//             st.push(grid[i][j]);\\n//         else\\n//         {\\n//             if (st.top() == \\'(\\' && grid[i][j] == \\')\\')\\n//             {\\n//                 st.pop();\\n//                 poop = \\'(\\';\\n//             }\\n//             else if (st.top() == \\')\\' && grid[i][j] == \\'(\\')\\n//                 return false;\\n//             else\\n//                 st.push(grid[i][j]);\\n//         }\\n        \\n//         // cout << \"i: \" << i << \" j: \" << j << endl;\\n//         if (i == m - 1 && j == n - 1)\\n//         {\\n//             if (st.empty())\\n//                 return true;\\n//         }\\n//         else\\n//         {\\n//             vector<pair<int, int>> dir = {{1, 0}, {0, 1}};\\n//             for (int a = 0; a < 2; a++)\\n//             {\\n//                 int ni = i + dir[a].first;\\n//                 int nj = j + dir[a].second;\\n                \\n//                 if (ni >= 0 && ni < m && nj >= 0 && nj < n && !vis[ni][nj])\\n//                 {\\n//                     vis[ni][nj] = true;\\n//                     if (solve(grid, m, n, ni, nj, st, vis) == true)\\n//                         return true;\\n//                     vis[ni][nj] = false;\\n//                 }\\n//             }\\n//         }\\n//         if (poop == \\'(\\')\\n//             st.push(\\'(\\');\\n//         else\\n//             st.pop();\\n//         return false;\\n//     }\\n//     bool hasValidPath(vector<vector<char>>& grid) {\\n//         int m = grid.size();\\n//         int n = grid[0].size();\\n        \\n//         vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        \\n//         stack<char> st;\\n        \\n//         vis[0][0] = true;\\n//         bool ans = solve(grid, m, n, 0, 0, st, vis);\\n//         vis[0][0] = true;\\n//         return ans;\\n//     }\\n \\n    // DP\\n    int solve(vector<vector<char>> &grid, int m, int n, int i, int j, int k)\\n    {\\n        if (i >= m || j >= n)\\n            return 0;\\n        \\n        // First we need to update k and then only see if dp[][][] != -1\\n        if (grid[i][j] == \\'(\\')\\n            k++;\\n        else\\n        {\\n            k--;\\n            if (k < 0)\\n                return 0;\\n        }\\n       \\n        if (dp[i][j][k] != -1)\\n            return dp[i][j][k];\\n        \\n        if (i == m - 1 && j == n - 1)\\n            return dp[i][j][k] = (k == 0);\\n        else       \\n        {\\n            int o1 = solve(grid, m, n, i + 1, j, k);\\n            int o2 = solve(grid, m, n, i, j + 1, k);\\n            \\n            dp[i][j][k] = (o1 | o2);\\n            return dp[i][j][k];\\n        }\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        return solve(grid, m, n, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2032255,
                "title": "python-3-simple-recursive-memoization",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache(None)\\n        def helper(i, j, score):\\n            if i == m or j == n:\\n                return False\\n            if i == m - 1 and j == n - 1:\\n                return score == 1 and grid[i][j] == \\')\\'\\n            \\n            if grid[i][j] == \\'(\\':\\n                return helper(i + 1, j, score + 1) or helper(i, j + 1, score + 1)\\n            if score == 0:\\n                return False\\n            return helper(i + 1, j, score - 1) or helper(i, j + 1, score - 1)\\n        \\n        return helper(0, 0, 0)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache(None)\\n        def helper(i, j, score):\\n            if i == m or j == n:\\n                return False\\n            if i == m - 1 and j == n - 1:\\n                return score == 1 and grid[i][j] == \\')\\'\\n            \\n            if grid[i][j] == \\'(\\':\\n                return helper(i + 1, j, score + 1) or helper(i, j + 1, score + 1)\\n            if score == 0:\\n                return False\\n            return helper(i + 1, j, score - 1) or helper(i, j + 1, score - 1)\\n        \\n        return helper(0, 0, 0)",
                "codeTag": "Java"
            },
            {
                "id": 2032043,
                "title": "simple-python-solution-dp-o-mn-time-and-space-complexity",
                "content": "```\\n\"\"\"\\nBasic idea:\\n===========\\n1.  For a parenthesis to be valid:\\n    As we traverse the path, we count the total left and right brackets encountered so far.\\n    At any point along the path, the following must always be true:\\n\\n        total left brackets >= total right brackets \\n\\n2.  We define a list of lists of m x n dimensions named \"brackets\". \\n    Each element in \"brackets\" contains a set of tuples.\\n    Each tuple is defined as (total left brackets, total right brackets).\\n    The set represents all the possible combinations of the tuples at the current row / column.\\n\\n3.  brackets@current position = brackets@top + brackets@left\\n    => brackets[r][c] = brackets[r-1][c] + brackets[r+1][c]\\n    We allow addition only if before and after adding, total left brackets >= total right brackets.\\n\\n4.  At the bottom right of the grid, return:\\n    True - if there exists a tuple such that total left brackets == total right brackets;\\n    False- if there are no tuples where total left brackets == total right brackets.\\n\"\"\"\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def addBracket(r, c, prev_r, prev_c):\\n            nonlocal brackets\\n            if 0 <= prev_r < m and 0 <= prev_c < n:                \\n                for left, right in brackets[prev_r][prev_c]:\\n                    if left >= right:\\n                        new_left = left + (1 if grid[r][c] == \\'(\\' else 0)\\n                        new_right = right + (1 if grid[r][c] == \\')\\' else 0)\\n                        if new_left >= new_right:\\n                            brackets[r][c].add((new_left, new_right))\\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        brackets = [[set() for i in range(n)] for j in range(m)]\\n        brackets[0][0].add((1 if grid[0][0] == \\'(\\' else 0, 1 if grid[0][0] == \\')\\' else 0))\\n        for i in range(m):\\n            for j in range(n):\\n                addBracket(i, j, i-1, j)\\n                addBracket(i, j, i, j-1)\\n        \\n        pathFound = False\\n        for left, right in brackets[m-1][n-1]:\\n            if left == right:\\n                pathFound = True\\n                break\\n        return pathFound\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nBasic idea:\\n===========\\n1.  For a parenthesis to be valid:\\n    As we traverse the path, we count the total left and right brackets encountered so far.\\n    At any point along the path, the following must always be true:\\n\\n        total left brackets >= total right brackets \\n\\n2.  We define a list of lists of m x n dimensions named \"brackets\". \\n    Each element in \"brackets\" contains a set of tuples.\\n    Each tuple is defined as (total left brackets, total right brackets).\\n    The set represents all the possible combinations of the tuples at the current row / column.\\n\\n3.  brackets@current position = brackets@top + brackets@left\\n    => brackets[r][c] = brackets[r-1][c] + brackets[r+1][c]\\n    We allow addition only if before and after adding, total left brackets >= total right brackets.\\n\\n4.  At the bottom right of the grid, return:\\n    True - if there exists a tuple such that total left brackets == total right brackets;\\n    False- if there are no tuples where total left brackets == total right brackets.\\n\"\"\"\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def addBracket(r, c, prev_r, prev_c):\\n            nonlocal brackets\\n            if 0 <= prev_r < m and 0 <= prev_c < n:                \\n                for left, right in brackets[prev_r][prev_c]:\\n                    if left >= right:\\n                        new_left = left + (1 if grid[r][c] == \\'(\\' else 0)\\n                        new_right = right + (1 if grid[r][c] == \\')\\' else 0)\\n                        if new_left >= new_right:\\n                            brackets[r][c].add((new_left, new_right))\\n            \\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        brackets = [[set() for i in range(n)] for j in range(m)]\\n        brackets[0][0].add((1 if grid[0][0] == \\'(\\' else 0, 1 if grid[0][0] == \\')\\' else 0))\\n        for i in range(m):\\n            for j in range(n):\\n                addBracket(i, j, i-1, j)\\n                addBracket(i, j, i, j-1)\\n        \\n        pathFound = False\\n        for left, right in brackets[m-1][n-1]:\\n            if left == right:\\n                pathFound = True\\n                break\\n        return pathFound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031202,
                "title": "c-dfs-dp",
                "content": "```\\npublic class Solution\\n{\\n    private int[][][] dp = new int[100][][];\\n\\n    public bool DFS(char[][] grid, int i, int j, int k)\\n    {\\n        if (i >= grid.Length || j >= grid[0].Length)\\n        {\\n            return false;\\n        }\\n\\n        if (grid[i][j] == \\'(\\')\\n        {\\n            k++;\\n        }\\n        else\\n        {\\n            k--;\\n        }\\n\\n        if (k < 0)\\n        {\\n            return false;\\n        }\\n\\n        if (i == grid.Length - 1 && j == grid[0].Length - 1)\\n        {\\n            return k == 0;\\n        }\\n\\n        if (dp[i][j][k] != -1)\\n        {\\n            return Convert.ToBoolean(dp[i][j][k]);\\n        }\\n\\n        dp[i][j][k] = Convert.ToInt32(DFS(grid, i + 1, j, k) | DFS(grid, i, j + 1, k));\\n        return Convert.ToBoolean(dp[i][j][k]);\\n    }\\n    \\n    public bool HasValidPath(char[][] grid)\\n    {\\n        for (int i = 0; i < dp.Length; i++)\\n        {\\n            dp[i] = new int[100][];\\n            for (int j = 0; j < dp[i].Length; j++)\\n            {\\n                dp[i][j] = new int[205];\\n                Array.Fill(dp[i][j], -1);\\n            }\\n        }\\n        return DFS(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private int[][][] dp = new int[100][][];\\n\\n    public bool DFS(char[][] grid, int i, int j, int k)\\n    {\\n        if (i >= grid.Length || j >= grid[0].Length)\\n        {\\n            return false;\\n        }\\n\\n        if (grid[i][j] == \\'(\\')\\n        {\\n            k++;\\n        }\\n        else\\n        {\\n            k--;\\n        }\\n\\n        if (k < 0)\\n        {\\n            return false;\\n        }\\n\\n        if (i == grid.Length - 1 && j == grid[0].Length - 1)\\n        {\\n            return k == 0;\\n        }\\n\\n        if (dp[i][j][k] != -1)\\n        {\\n            return Convert.ToBoolean(dp[i][j][k]);\\n        }\\n\\n        dp[i][j][k] = Convert.ToInt32(DFS(grid, i + 1, j, k) | DFS(grid, i, j + 1, k));\\n        return Convert.ToBoolean(dp[i][j][k]);\\n    }\\n    \\n    public bool HasValidPath(char[][] grid)\\n    {\\n        for (int i = 0; i < dp.Length; i++)\\n        {\\n            dp[i] = new int[100][];\\n            for (int j = 0; j < dp[i].Length; j++)\\n            {\\n                dp[i][j] = new int[205];\\n                Array.Fill(dp[i][j], -1);\\n            }\\n        }\\n        return DFS(grid, 0, 0, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031136,
                "title": "c-solution",
                "content": "```\\nvoid right(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    while (Count > 0 && copy[Count-1] > 99){\\n        Count--;\\n    }\\n    for (int i = 0 ; i < Count ; i++){\\n        list[j][i] = copy[i]+1;\\n    }\\n    count[j] = Count;\\n}\\n\\nvoid left(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    int h = 0;\\n    while (h < Count && copy[h] < 1){\\n        h++;\\n    }\\n    count[j] = 0;\\n    for (; h < Count ; h++){\\n        list[j][count[j]] = copy[h]-1;\\n        count[j]++;\\n    }\\n}\\n\\nbool hasValidPath(char** grid, int gridSize, int* gridColSize){\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    if (grid[x][y] == \\'(\\' || grid[0][0] == \\')\\'  || (x+y) % 2 == 0){\\n        return false;\\n    }\\n    \\n    int** list = malloc(sizeof(int*)*(*gridColSize));\\n    for (int i = 0 ; i < (*gridColSize) ; i++){\\n        list[i] = malloc(sizeof(int)*100);\\n    }\\n    int* count = calloc(101,sizeof(int));\\n    list[y][0] = 1;\\n    count[y]++;\\n    \\n    for (int j = y-1 ; j >= 0 ; j--){\\n        if (list[j+1][0] >= 0){\\n            if (grid[x][j] == \\')\\'){\\n                list[j][0] = list[j+1][0]+1;\\n                count[j]++;\\n            } else {\\n                list[j][0] = list[j+1][0]-1;\\n                if (list[j][count[j]] >= 0){\\n                    count[j]++;\\n                }\\n            }\\n        } else {\\n            list[j][0] = -1;\\n        }\\n    }\\n    \\n    for (int i = x-1 ; i >= 0 ; i--){\\n        if (list[y][0] >= 0){\\n            if (grid[i][y] == \\')\\'){\\n                list[y][0]++;\\n            } else {\\n                list[y][0]--;\\n                if (list[y][0] < 0){\\n                    count[y]--;\\n                }\\n            }\\n        }\\n        for (int j = y-1 ; j >= 0 ; j--){\\n            if (grid[i][j] == \\')\\'){\\n                right( i, j, list, count);\\n            } else {\\n                left( i, j, list, count);\\n            }\\n        }\\n    }\\n    int ans = list[0][0];\\n    for (int i = 0 ; i < *gridColSize ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans == 0 ? true : false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid right(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    while (Count > 0 && copy[Count-1] > 99){\\n        Count--;\\n    }\\n    for (int i = 0 ; i < Count ; i++){\\n        list[j][i] = copy[i]+1;\\n    }\\n    count[j] = Count;\\n}\\n\\nvoid left(int i, int j, int** list, int* count){\\n    int copy[200];\\n    int Count = 0;\\n    int a = 0;\\n    int b = 0;\\n    while (a < count[j] || b < count[j+1]){\\n        if (a >= count[j]){\\n            while (b < count[j+1]){\\n                copy[Count] = list[j+1][b];\\n                Count++;\\n                b++;\\n            }\\n        } else if (b >= count[j+1]){\\n            while (a < count[j]){\\n                copy[Count] = list[j][a];\\n                Count++;\\n                a++;\\n            }\\n        } else if (list[j][a] > list[j+1][b]){\\n            copy[Count] = list[j+1][b];\\n            Count++;\\n            b++;\\n        } else if (list[j][a] < list[j+1][b]){\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n        } else {\\n            copy[Count] = list[j][a];\\n            Count++;\\n            a++;\\n            b++;\\n        }\\n    }\\n    int h = 0;\\n    while (h < Count && copy[h] < 1){\\n        h++;\\n    }\\n    count[j] = 0;\\n    for (; h < Count ; h++){\\n        list[j][count[j]] = copy[h]-1;\\n        count[j]++;\\n    }\\n}\\n\\nbool hasValidPath(char** grid, int gridSize, int* gridColSize){\\n    int x = gridSize-1;\\n    int y = *gridColSize-1;\\n    if (grid[x][y] == \\'(\\' || grid[0][0] == \\')\\'  || (x+y) % 2 == 0){\\n        return false;\\n    }\\n    \\n    int** list = malloc(sizeof(int*)*(*gridColSize));\\n    for (int i = 0 ; i < (*gridColSize) ; i++){\\n        list[i] = malloc(sizeof(int)*100);\\n    }\\n    int* count = calloc(101,sizeof(int));\\n    list[y][0] = 1;\\n    count[y]++;\\n    \\n    for (int j = y-1 ; j >= 0 ; j--){\\n        if (list[j+1][0] >= 0){\\n            if (grid[x][j] == \\')\\'){\\n                list[j][0] = list[j+1][0]+1;\\n                count[j]++;\\n            } else {\\n                list[j][0] = list[j+1][0]-1;\\n                if (list[j][count[j]] >= 0){\\n                    count[j]++;\\n                }\\n            }\\n        } else {\\n            list[j][0] = -1;\\n        }\\n    }\\n    \\n    for (int i = x-1 ; i >= 0 ; i--){\\n        if (list[y][0] >= 0){\\n            if (grid[i][y] == \\')\\'){\\n                list[y][0]++;\\n            } else {\\n                list[y][0]--;\\n                if (list[y][0] < 0){\\n                    count[y]--;\\n                }\\n            }\\n        }\\n        for (int j = y-1 ; j >= 0 ; j--){\\n            if (grid[i][j] == \\')\\'){\\n                right( i, j, list, count);\\n            } else {\\n                left( i, j, list, count);\\n            }\\n        }\\n    }\\n    int ans = list[0][0];\\n    for (int i = 0 ; i < *gridColSize ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans == 0 ? true : false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2030005,
                "title": "easy-and-intuitive-java-memoization-and-tabulation-codes",
                "content": "Method 1 : Memoization \\n\\n```\\nclass Solution {\\n    Boolean dp[][][];\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        dp = new Boolean[rows][cols][rows+cols];\\n        return hasValidPath(grid,0,0,rows,cols,0);\\n    }\\n    \\n    private boolean hasValidPath(char grid[][],int row,int col,int rows,int cols,int count){\\n        if(row>=rows||col>=cols) return false;\\n        \\n        char bracket = grid[row][col];\\n        \\n        if(bracket==\\'(\\') count++;\\n        else count--;\\n        \\n        if(count<0) return false;\\n        \\n        if(row==rows-1&&col==cols-1) return count==0;\\n        \\n        if(dp[row][col][count]!=null) return dp[row][col][count];\\n        \\n        return dp[row][col][count] = hasValidPath(grid,row,col+1,rows,cols,count)\\n                                   ||hasValidPath(grid,row+1,col,rows,cols,count);\\n    }\\n}\\n```\\n\\nMethod 2 : Tabulation\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[rows][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[row][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[row][col][count]|=dp[row][col+1][nextCount];\\n                        if(row+1<rows) dp[row][col][count]|=dp[row+1][col][nextCount];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```\\n\\nBoth codes have time and space complexity of O(rows*cols*(rows+cols))\\n\\nEdit : Method 2 space optimized , works in O(cols*(rows+cols)) space : \\n\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[2][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[0][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[0][col][count]|=dp[0][col+1][nextCount];\\n                        if(row+1<rows) dp[0][col][count]|=dp[1][col][nextCount];\\n                    }\\n                }\\n            }\\n            \\n            if(row>0){\\n                for(int col=cols-1;col>=0;col--){\\n                    for(int count = 0;count<rows+cols;count++){\\n                        dp[1][col][count] = dp[0][col][count];\\n                        dp[0][col][count] = false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    Boolean dp[][][];\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        dp = new Boolean[rows][cols][rows+cols];\\n        return hasValidPath(grid,0,0,rows,cols,0);\\n    }\\n    \\n    private boolean hasValidPath(char grid[][],int row,int col,int rows,int cols,int count){\\n        if(row>=rows||col>=cols) return false;\\n        \\n        char bracket = grid[row][col];\\n        \\n        if(bracket==\\'(\\') count++;\\n        else count--;\\n        \\n        if(count<0) return false;\\n        \\n        if(row==rows-1&&col==cols-1) return count==0;\\n        \\n        if(dp[row][col][count]!=null) return dp[row][col][count];\\n        \\n        return dp[row][col][count] = hasValidPath(grid,row,col+1,rows,cols,count)\\n                                   ||hasValidPath(grid,row+1,col,rows,cols,count);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[rows][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[row][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[row][col][count]|=dp[row][col+1][nextCount];\\n                        if(row+1<rows) dp[row][col][count]|=dp[row+1][col][nextCount];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        boolean dp[][][] = new boolean[2][cols][rows+cols];\\n        \\n        for(int row=rows-1;row>=0;row--){\\n            \\n            for(int col=cols-1;col>=0;col--){\\n                char bracket = grid[row][col];\\n                \\n                for(int count = 0;count<rows+cols;count++){\\n                    int nextCount = count;\\n                    if(bracket==\\'(\\') nextCount++;\\n                    else nextCount--;\\n                    \\n                    if(nextCount<0) continue;\\n                    \\n                    if(row==rows-1&&col==cols-1) dp[0][col][count] = (nextCount==0);\\n                    else if(nextCount<rows+cols){\\n                        if(col+1<cols) dp[0][col][count]|=dp[0][col+1][nextCount];\\n                        if(row+1<rows) dp[0][col][count]|=dp[1][col][nextCount];\\n                    }\\n                }\\n            }\\n            \\n            if(row>0){\\n                for(int col=cols-1;col>=0;col--){\\n                    for(int count = 0;count<rows+cols;count++){\\n                        dp[1][col][count] = dp[0][col][count];\\n                        dp[0][col][count] = false;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029706,
                "title": "brute-force",
                "content": "This works due to small constraints. Save all possible balances at every cell. Use these balances to populate all possible balances in the right and down cell. Then return true if 0 balance is possible in bottom right cell \\n\\n```import java.util.*;\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Set<Integer>[][] sets = new Set[m][n];\\n\\n        if (grid[0][0] != \\'(\\' || grid[m-1][n-1] != \\')\\') {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sets[i][j] = new HashSet<>();\\n                if(i == 0 && j == 0) {\\n                    sets[0][0].add(1);\\n                    continue;\\n                }\\n                int toAdd = grid[i][j] == \\')\\' ? -1 : 1;\\n\\n                if (i-1 >= 0) {\\n                    Iterator<Integer> it = sets[i-1][j].iterator();\\n                    while(it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                        \\n                    }\\n                }\\n                if (j-1 >= 0) {\\n                    Iterator<Integer> it = sets[i][j-1].iterator();\\n                    while (it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        return sets[m-1][n-1].contains(0);\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```import java.util.*;\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        Set<Integer>[][] sets = new Set[m][n];\\n\\n        if (grid[0][0] != \\'(\\' || grid[m-1][n-1] != \\')\\') {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                sets[i][j] = new HashSet<>();\\n                if(i == 0 && j == 0) {\\n                    sets[0][0].add(1);\\n                    continue;\\n                }\\n                int toAdd = grid[i][j] == \\')\\' ? -1 : 1;\\n\\n                if (i-1 >= 0) {\\n                    Iterator<Integer> it = sets[i-1][j].iterator();\\n                    while(it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                        \\n                    }\\n                }\\n                if (j-1 >= 0) {\\n                    Iterator<Integer> it = sets[i][j-1].iterator();\\n                    while (it.hasNext()) {\\n                        int val = it.next() + toAdd;\\n                        if (val >= 0) {\\n                            sets[i][j].add(val);\\n                        }\\n                    }\\n\\n                }\\n            }\\n        }\\n\\n        return sets[m-1][n-1].contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029374,
                "title": "java-dfs-solution",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        boolean[][][] visited = new boolean[grid.length][grid[0].length][grid.length + grid[0].length];\\n        return dfs(0, 0, grid, visited, 0);\\n    }\\n\\n    private boolean dfs(int col, int row, char[][] grid, boolean[][][] visited, int parenthesesCounter) {\\n        if (col > grid.length - 1 || row > grid[0].length - 1) return false;\\n        parenthesesCounter += grid[col][row] == \\'(\\' ? 1 : - 1;\\n        if (parenthesesCounter < 0 || parenthesesCounter > (grid.length + grid[0].length) / 2 || visited[col][row][parenthesesCounter]) return false;\\n        visited[col][row][parenthesesCounter] = true;\\n        if (col == grid.length - 1 && row == grid[0].length - 1 && parenthesesCounter == 0) return true;\\n        return dfs(col + 1, row, grid, visited, parenthesesCounter) || dfs(col, row + 1, grid, visited, parenthesesCounter);\\n\\t\\t}\\n\\t}\\n  \\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        boolean[][][] visited = new boolean[grid.length][grid[0].length][grid.length + grid[0].length];\\n        return dfs(0, 0, grid, visited, 0);\\n    }\\n\\n    private boolean dfs(int col, int row, char[][] grid, boolean[][][] visited, int parenthesesCounter) {\\n        if (col > grid.length - 1 || row > grid[0].length - 1) return false;\\n        parenthesesCounter += grid[col][row] == \\'(\\' ? 1 : - 1;\\n        if (parenthesesCounter < 0 || parenthesesCounter > (grid.length + grid[0].length) / 2 || visited[col][row][parenthesesCounter]) return false;\\n        visited[col][row][parenthesesCounter] = true;\\n        if (col == grid.length - 1 && row == grid[0].length - 1 && parenthesesCounter == 0) return true;\\n        return dfs(col + 1, row, grid, visited, parenthesesCounter) || dfs(col, row + 1, grid, visited, parenthesesCounter);\\n\\t\\t}\\n\\t}\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027606,
                "title": "java-dp-set",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        char L = \\'(\\';\\n        char R = \\')\\';\\n        \\n        if(!(grid[0][0] == L && grid[n - 1][m - 1] == R)) return false;\\n\\n        Set<Integer>[][] dp = new HashSet[n][m];\\n        Set<Integer> init = new HashSet<>();\\n        init.add(1);\\n        dp[0][0] = init;\\n        \\n        // top\\n        for(int j = 1; j < m; j++){\\n            Set<Integer> curr = new HashSet<>();\\n            \\n            if(grid[0][j] == R){\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[0][j] = curr;\\n        }\\n        \\n        // left\\n        for(int i = 1; i < n; i++){\\n            Set<Integer> curr = new HashSet<>();\\n            if(dp[i - 1][0].contains(-1)){\\n                curr.add(-1);\\n                dp[i][0] = curr;\\n                continue;\\n            }\\n            \\n            \\n            if(grid[i][0] == R){\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[i][0] = curr;\\n        }\\n        \\n        // regular\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                Set<Integer> curr = new HashSet<>();\\n                \\n                if(dp[i - 1][j].contains(-1) && dp[i][j - 1].contains(-1)){\\n                    curr.add(-1);\\n                    dp[i][j] = curr;\\n                    continue;\\n                }\\n                \\n                if(grid[i][j] == R){\\n                    for(int val : dp[i][j - 1]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                }else{\\n                    for(int val : dp[i][j - 1]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                }\\n                \\n                dp[i][j] = curr;\\n            }\\n        }\\n        \\n        return dp[n - 1][m - 1].contains(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        char L = \\'(\\';\\n        char R = \\')\\';\\n        \\n        if(!(grid[0][0] == L && grid[n - 1][m - 1] == R)) return false;\\n\\n        Set<Integer>[][] dp = new HashSet[n][m];\\n        Set<Integer> init = new HashSet<>();\\n        init.add(1);\\n        dp[0][0] = init;\\n        \\n        // top\\n        for(int j = 1; j < m; j++){\\n            Set<Integer> curr = new HashSet<>();\\n            \\n            if(grid[0][j] == R){\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[0][j - 1]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[0][j] = curr;\\n        }\\n        \\n        // left\\n        for(int i = 1; i < n; i++){\\n            Set<Integer> curr = new HashSet<>();\\n            if(dp[i - 1][0].contains(-1)){\\n                curr.add(-1);\\n                dp[i][0] = curr;\\n                continue;\\n            }\\n            \\n            \\n            if(grid[i][0] == R){\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val - 1);\\n                    }\\n                }\\n            }else{\\n                for(int val : dp[i - 1][0]){\\n                    if(val >= 0){\\n                        curr.add(val + 1);\\n                    }\\n                }\\n            }\\n            dp[i][0] = curr;\\n        }\\n        \\n        // regular\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                Set<Integer> curr = new HashSet<>();\\n                \\n                if(dp[i - 1][j].contains(-1) && dp[i][j - 1].contains(-1)){\\n                    curr.add(-1);\\n                    dp[i][j] = curr;\\n                    continue;\\n                }\\n                \\n                if(grid[i][j] == R){\\n                    for(int val : dp[i][j - 1]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val - 1 >= 0){\\n                            curr.add(val - 1);\\n                        }\\n                    }\\n                    \\n                }else{\\n                    for(int val : dp[i][j - 1]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                    \\n                    for(int val : dp[i - 1][j]){\\n                        if(val >= 0){\\n                            curr.add(val + 1);\\n                        }\\n                    }\\n                }\\n                \\n                dp[i][j] = curr;\\n            }\\n        }\\n        \\n        return dp[n - 1][m - 1].contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025540,
                "title": "one-pass-over-all-cells-88-speed",
                "content": "![image](https://assets.leetcode.com/users/images/43f1130f-7346-4900-a3ce-711a6a37be3d_1652181745.882908.png)\\n```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rows, cols = len(grid), len(grid[0])\\n        if ((rows + cols - 1) % 2 or grid[0][0] == \")\"\\n                or grid[rows - 1][cols - 1] == \"(\"):\\n            return False\\n        opened = [[set() for _ in range(cols)] for _ in range(rows)]\\n        opened[0][0].add(1)\\n        row = 0\\n        for col in range(1, cols):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row][col - 1])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row][col - 1]\\n                                        if n > 0)\\n        col = 0\\n        for row in range(1, rows):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row - 1][col])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row - 1][col]\\n                                        if n > 0)\\n        for row in range(1, rows):\\n            for col in range(1, cols):\\n                opened[row - 1][col].update(opened[row][col - 1])\\n                if grid[row][col] == \"(\":\\n                    opened[row][col].update(n + 1 for n in\\n                                            opened[row - 1][col])\\n                else:\\n                    opened[row][col].update(n - 1 for n in\\n                                            opened[row - 1][col] if n > 0)\\n        return 0 in opened[rows - 1][cols - 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        rows, cols = len(grid), len(grid[0])\\n        if ((rows + cols - 1) % 2 or grid[0][0] == \")\"\\n                or grid[rows - 1][cols - 1] == \"(\"):\\n            return False\\n        opened = [[set() for _ in range(cols)] for _ in range(rows)]\\n        opened[0][0].add(1)\\n        row = 0\\n        for col in range(1, cols):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row][col - 1])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row][col - 1]\\n                                        if n > 0)\\n        col = 0\\n        for row in range(1, rows):\\n            if grid[row][col] == \"(\":\\n                opened[row][col].update(n + 1 for n in opened[row - 1][col])\\n            else:\\n                opened[row][col].update(n - 1 for n in opened[row - 1][col]\\n                                        if n > 0)\\n        for row in range(1, rows):\\n            for col in range(1, cols):\\n                opened[row - 1][col].update(opened[row][col - 1])\\n                if grid[row][col] == \"(\":\\n                    opened[row][col].update(n + 1 for n in\\n                                            opened[row - 1][col])\\n                else:\\n                    opened[row][col].update(n - 1 for n in\\n                                            opened[row - 1][col] if n > 0)\\n        return 0 in opened[rows - 1][cols - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024346,
                "title": "java-hashsets-clean-code",
                "content": "```java\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Set<Integer>[][] dp = new Set[m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<Integer>();\\n            }   \\n        }\\n        dp[0][0].add(grid[0][0] == \\'(\\' ? 1 : -1);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int inc = grid[i][j] == \\'(\\' ? 1 : -1;\\n                if (i-1 >= 0) addValue(dp[i-1][j], dp[i][j], inc);\\n                if (j-1 >= 0) addValue(dp[i][j-1], dp[i][j], inc);\\n            }\\n        }\\n        \\n        return dp[m-1][n-1].contains(0);\\n    }\\n    \\n    private void addValue(Set<Integer> src, Set<Integer> dst, int inc) {\\n        for(Integer value : src) {\\n            if (value.intValue() < 0) continue;\\n            int val = value.intValue() + inc;\\n            if (val >= 0) dst.add(val);\\n        } \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Set<Integer>[][] dp = new Set[m][n];\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                dp[i][j] = new HashSet<Integer>();\\n            }   \\n        }\\n        dp[0][0].add(grid[0][0] == \\'(\\' ? 1 : -1);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                int inc = grid[i][j] == \\'(\\' ? 1 : -1;\\n                if (i-1 >= 0) addValue(dp[i-1][j], dp[i][j], inc);\\n                if (j-1 >= 0) addValue(dp[i][j-1], dp[i][j], inc);\\n            }\\n        }\\n        \\n        return dp[m-1][n-1].contains(0);\\n    }\\n    \\n    private void addValue(Set<Integer> src, Set<Integer> dst, int inc) {\\n        for(Integer value : src) {\\n            if (value.intValue() < 0) continue;\\n            int val = value.intValue() + inc;\\n            if (val >= 0) dst.add(val);\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024304,
                "title": "rust-dfs-hashmap-o-rows-cols-rows-cols",
                "content": "Simplify \\n`*f.get(&(r, c, cnt)).unwrap_or(&false);`\\nto\\n`f[&(r, c, cnt)];`\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        fn dfs(r: usize, c: usize, mut cnt: i32, grid: &Vec<Vec<char>>, f: &mut HashMap<(usize, usize, i32), bool>) -> bool {\\n            let rows = grid.len();\\n            let cols = grid[0].len();\\n            let mut ans = false;\\n            \\n            if r >= rows || c >= cols {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if grid[r][c] == \\'(\\' {\\n                cnt += 1;\\n            } else {\\n                cnt -= 1;\\n            }\\n            if cnt < 0 {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if r == rows - 1 && c == cols - 1 && cnt == 0 {\\n                f.insert((r,c,cnt), true);\\n                return true;\\n            }\\n            \\n            if f.contains_key(&(r, c, cnt)) {\\n                return f[&(r, c, cnt)];\\n            }\\n\\n            let ans = dfs(r+1, c, cnt, &grid, f) || dfs(r, c+1, cnt, &grid, f);\\n            f.insert((r,c,cnt), ans);\\n            ans\\n        }\\n        \\n        let mut f: HashMap<(usize, usize, i32), bool> = HashMap::new();\\n        \\n        let ans = dfs(0, 0, 0, &grid, &mut f);\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn has_valid_path(grid: Vec<Vec<char>>) -> bool {\\n        fn dfs(r: usize, c: usize, mut cnt: i32, grid: &Vec<Vec<char>>, f: &mut HashMap<(usize, usize, i32), bool>) -> bool {\\n            let rows = grid.len();\\n            let cols = grid[0].len();\\n            let mut ans = false;\\n            \\n            if r >= rows || c >= cols {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if grid[r][c] == \\'(\\' {\\n                cnt += 1;\\n            } else {\\n                cnt -= 1;\\n            }\\n            if cnt < 0 {\\n                f.insert((r,c,cnt), false);\\n                return false;\\n            }\\n            if r == rows - 1 && c == cols - 1 && cnt == 0 {\\n                f.insert((r,c,cnt), true);\\n                return true;\\n            }\\n            \\n            if f.contains_key(&(r, c, cnt)) {\\n                return f[&(r, c, cnt)];\\n            }\\n\\n            let ans = dfs(r+1, c, cnt, &grid, f) || dfs(r, c+1, cnt, &grid, f);\\n            f.insert((r,c,cnt), ans);\\n            ans\\n        }\\n        \\n        let mut f: HashMap<(usize, usize, i32), bool> = HashMap::new();\\n        \\n        let ans = dfs(0, 0, 0, &grid, &mut f);\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2023737,
                "title": "python-dp-memoization-simple-solution",
                "content": "```\\nclass Solution:\\n    def dp(self, grid, r, c, balance, lookup):\\n        if grid[r][c] == \\'(\\':\\n            balance += 1\\n        else:\\n            balance -= 1\\n        \\n        if r == len(grid)-1 and c == len(grid[0])-1:\\n            return balance == 0\\n        \\n        key = (r, c, balance)\\n        if key not in lookup:\\n            isValid = False\\n\\n            for dr, dc in [[r, c+1], [r+1, c]]:\\n                if dr < len(grid) and dc < len(grid[0]) and (balance > 0 or grid[dr][dc] == \\'(\\'):\\n                    if self.dp(grid, dr, dc, balance, lookup) or self.dp(grid, dr, dc, balance, lookup):\\n                        isValid = True\\n                        break\\n            lookup[key] = isValid\\n        return lookup[key]\\n    \\n    \\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\' or len(grid) == len(grid[0]) == 1:\\n            return False\\n        \\n        return self.dp(grid, 0, 0, 0, {})\\n        \\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self, grid, r, c, balance, lookup):\\n        if grid[r][c] == \\'(\\':\\n            balance += 1\\n        else:\\n            balance -= 1\\n        \\n        if r == len(grid)-1 and c == len(grid[0])-1:\\n            return balance == 0\\n        \\n        key = (r, c, balance)\\n        if key not in lookup:\\n            isValid = False\\n\\n            for dr, dc in [[r, c+1], [r+1, c]]:\\n                if dr < len(grid) and dc < len(grid[0]) and (balance > 0 or grid[dr][dc] == \\'(\\'):\\n                    if self.dp(grid, dr, dc, balance, lookup) or self.dp(grid, dr, dc, balance, lookup):\\n                        isValid = True\\n                        break\\n            lookup[key] = isValid\\n        return lookup[key]\\n    \\n    \\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        if grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\' or len(grid) == len(grid[0]) == 1:\\n            return False\\n        \\n        return self.dp(grid, 0, 0, 0, {})\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023546,
                "title": "java-dfs-memo",
                "content": "```java\\nclass Solution {\\n    private int m;\\n    private int n;\\n    private char[][] grid;\\n    private Map<String, Boolean> memo;\\n\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        this.grid = grid;\\n        memo = new HashMap<>();\\n\\n        // basic case: the path should start with \\'(\\' and end with \\')\\'\\n        if (grid[0][0] != \\'(\\' || grid[m - 1][n - 1] != \\')\\') {\\n            return false;\\n        }\\n\\n        // basic case: the count of value in the path should be even.\\n        // so m+n should be odd\\n        if ((m + n) % 2 == 0) {\\n            return false;\\n        }\\n\\n        // dfs\\n        return traverse(0, 0, 0);\\n    }\\n\\n\\n    private boolean traverse(int i, int j, int count) {\\n        if (i >= m || j >= n) {\\n            return false;\\n        }\\n\\n        // calculate the number of \\'(\\'\\n        char c = grid[i][j];\\n        if (c == \\'(\\') {\\n            count++;\\n        } else {\\n            // when encounter with \\')\\', offset one \\'(\\'\\n            count--;\\n        }\\n\\n        // arrive the end position\\n        if (i == m - 1 && j == n - 1) {\\n            // perfect pair\\n            if (count == 0) {\\n                return true;\\n            }\\n        }\\n\\n        // if count < 0, the path will start with \\')\\', illegal.\\n        // if count > (m + n - 1) / 2, there would be no enough \\')\\' left to offset the \\'(\\'\\n        if (count < 0 || count > (m + n - 1) / 2) {\\n            return false;\\n        }\\n\\n        // check the memo\\n        String key = generateKey(i, j, count);\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n\\n        // traverse next position. right or down.\\n        boolean ans = traverse(i, j + 1, count) || traverse(i + 1, j, count);\\n        // add to memo\\n        memo.put(key, ans);\\n        return ans;\\n    }\\n\\n    /**\\n     * generate some kind of key. we use \\'-\\' to split elements here.\\n     *\\n     * @param i\\n     * @param j\\n     * @param currentCount\\n     * @return\\n     */\\n    private String generateKey(int i, int j, int currentCount) {\\n        return i + \"-\" + j + \"-\" + currentCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    private int m;\\n    private int n;\\n    private char[][] grid;\\n    private Map<String, Boolean> memo;\\n\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        m = grid.length;\\n        n = grid[0].length;\\n        this.grid = grid;\\n        memo = new HashMap<>();\\n\\n        // basic case: the path should start with \\'(\\' and end with \\')\\'\\n        if (grid[0][0] != \\'(\\' || grid[m - 1][n - 1] != \\')\\') {\\n            return false;\\n        }\\n\\n        // basic case: the count of value in the path should be even.\\n        // so m+n should be odd\\n        if ((m + n) % 2 == 0) {\\n            return false;\\n        }\\n\\n        // dfs\\n        return traverse(0, 0, 0);\\n    }\\n\\n\\n    private boolean traverse(int i, int j, int count) {\\n        if (i >= m || j >= n) {\\n            return false;\\n        }\\n\\n        // calculate the number of \\'(\\'\\n        char c = grid[i][j];\\n        if (c == \\'(\\') {\\n            count++;\\n        } else {\\n            // when encounter with \\')\\', offset one \\'(\\'\\n            count--;\\n        }\\n\\n        // arrive the end position\\n        if (i == m - 1 && j == n - 1) {\\n            // perfect pair\\n            if (count == 0) {\\n                return true;\\n            }\\n        }\\n\\n        // if count < 0, the path will start with \\')\\', illegal.\\n        // if count > (m + n - 1) / 2, there would be no enough \\')\\' left to offset the \\'(\\'\\n        if (count < 0 || count > (m + n - 1) / 2) {\\n            return false;\\n        }\\n\\n        // check the memo\\n        String key = generateKey(i, j, count);\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n\\n        // traverse next position. right or down.\\n        boolean ans = traverse(i, j + 1, count) || traverse(i + 1, j, count);\\n        // add to memo\\n        memo.put(key, ans);\\n        return ans;\\n    }\\n\\n    /**\\n     * generate some kind of key. we use \\'-\\' to split elements here.\\n     *\\n     * @param i\\n     * @param j\\n     * @param currentCount\\n     * @return\\n     */\\n    private String generateKey(int i, int j, int currentCount) {\\n        return i + \"-\" + j + \"-\" + currentCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023471,
                "title": "c-simple-recursive-solution-with-dp",
                "content": "class Solution {\\n    int m, n;\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int>>> dp(100, vector<vector<int>> (100, vector<int> (205, -1)));\\n        return helper(grid, 0, 0, 0, dp);\\n    }\\n    \\n    bool helper(vector<vector<char>> &grid, int i, int j, int a, vector<vector<vector<int>>> &dp)\\n    {\\n        if(i >= m || j >= n)\\n            return !a && (i == m - 1 || j == n - 1);\\n        \\n        if(grid[i][j] == \\'(\\')\\n            a++;\\n        else\\n            a--;\\n        \\n        if(a < 0)\\n            return false;\\n        \\n        if(dp[i][j][a] != -1)\\n            return dp[i][j][a];\\n        \\n        return dp[i][j][a] = helper(grid, i + 1, j, a, dp) || helper(grid, i, j + 1, a, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    int m, n;\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        \\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<vector<int>>> dp(100, vector<vector<int>> (100, vector<int> (205, -1)));\\n        return helper(grid, 0, 0, 0, dp);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2023371,
                "title": "python3-solution-with-explanation-from-bottom-right-to-top-left",
                "content": "```\\ndef hasValidPath(self, grid: List[List[str]]) -> bool:\\n        # in this function we check how many \"(\" are needed at location [i][j]\\n        # starting from grid[m-1][n-1], and move up and left\\n        # if grid[m-1][n-1]==\"(\", there is no way to form a valid parentheses string path\\n        # else, the \"(\" needed is 1. so we start with 1\\n        # if grid[i][j]==\")\", add 1 to the value\\n        # if grid[i][j]==\"(\", minus 1 to the value\\n        # only keep records of values greater or equal to 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        # use a matrix brackets to keep records of how many \"(\" are needed at each location\\n        brackets = [[0]*n for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                brackets[i][j] = set()\\n            \\n        \\n        j = n-1\\n        i = m-1\\n        if grid[i][j]==\")\":\\n            # 1. initialize brackets[m-1][n-1]\\n            brackets[i][j].add(1)\\n            # 2. initialize the last column of values based on brackets[i+1][j]. note that we only need to keep values greater or equal to 0.\\n            i -= 1\\n            while i>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i+1][j])>0:\\n                        brackets[i][j].add(list(brackets[i+1][j])[0] + 1)\\n                else:\\n                    if len(brackets[i+1][j])>0:\\n                        if list(brackets[i+1][j])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i+1][j])[0] - 1)\\n                i -= 1\\n            # 3. initialize the last row of values based on brackets[i][j+1]\\n            j = n-2\\n            i = m-1\\n            while j>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i][j+1])>0:\\n                        brackets[i][j].add(list(brackets[i][j+1])[0] + 1)\\n                else:\\n                    if len(brackets[i][j+1])>0:\\n                        if list(brackets[i][j+1])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i][j+1])[0] - 1)\\n                j -= 1\\n            \\n            # 4. from brackets[m-2][n-2], for brackets[i][j]: obtain how many \"(\" are needed based on numbers from brackets[i][j+1] and brackets[i+1][j]\\n            i = m-2\\n            while i>=0:\\n                j = n-2\\n                while j>=0:\\n                    if grid[i][j]==\")\":\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            brackets[i][j].add(x + 1)\\n                        \\n                    else:\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            if x-1>=0:\\n                                brackets[i][j].add(x - 1)\\n                        \\n                    j -= 1\\n                i -= 1    \\n                \\n            # 5. if 0 is needed, then return True; otherwise, return False\\n            return (0 in brackets[0][0])\\n        else:\\n            # if the last element is \"(\", then there\\'s no way to form a valid parentheses string path\\n            return False\\n\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef hasValidPath(self, grid: List[List[str]]) -> bool:\\n        # in this function we check how many \"(\" are needed at location [i][j]\\n        # starting from grid[m-1][n-1], and move up and left\\n        # if grid[m-1][n-1]==\"(\", there is no way to form a valid parentheses string path\\n        # else, the \"(\" needed is 1. so we start with 1\\n        # if grid[i][j]==\")\", add 1 to the value\\n        # if grid[i][j]==\"(\", minus 1 to the value\\n        # only keep records of values greater or equal to 0\\n        m = len(grid)\\n        n = len(grid[0])\\n        # use a matrix brackets to keep records of how many \"(\" are needed at each location\\n        brackets = [[0]*n for i in range(m)]\\n        for i in range(m):\\n            for j in range(n):\\n                brackets[i][j] = set()\\n            \\n        \\n        j = n-1\\n        i = m-1\\n        if grid[i][j]==\")\":\\n            # 1. initialize brackets[m-1][n-1]\\n            brackets[i][j].add(1)\\n            # 2. initialize the last column of values based on brackets[i+1][j]. note that we only need to keep values greater or equal to 0.\\n            i -= 1\\n            while i>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i+1][j])>0:\\n                        brackets[i][j].add(list(brackets[i+1][j])[0] + 1)\\n                else:\\n                    if len(brackets[i+1][j])>0:\\n                        if list(brackets[i+1][j])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i+1][j])[0] - 1)\\n                i -= 1\\n            # 3. initialize the last row of values based on brackets[i][j+1]\\n            j = n-2\\n            i = m-1\\n            while j>=0:\\n                if grid[i][j]==\")\":\\n                    if len(brackets[i][j+1])>0:\\n                        brackets[i][j].add(list(brackets[i][j+1])[0] + 1)\\n                else:\\n                    if len(brackets[i][j+1])>0:\\n                        if list(brackets[i][j+1])[0] - 1>=0:\\n                            brackets[i][j].add(list(brackets[i][j+1])[0] - 1)\\n                j -= 1\\n            \\n            # 4. from brackets[m-2][n-2], for brackets[i][j]: obtain how many \"(\" are needed based on numbers from brackets[i][j+1] and brackets[i+1][j]\\n            i = m-2\\n            while i>=0:\\n                j = n-2\\n                while j>=0:\\n                    if grid[i][j]==\")\":\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            brackets[i][j].add(x + 1)\\n                        \\n                    else:\\n                        for x in brackets[i][j+1]|brackets[i+1][j]:\\n                            if x-1>=0:\\n                                brackets[i][j].add(x - 1)\\n                        \\n                    j -= 1\\n                i -= 1    \\n                \\n            # 5. if 0 is needed, then return True; otherwise, return False\\n            return (0 in brackets[0][0])\\n        else:\\n            # if the last element is \"(\", then there\\'s no way to form a valid parentheses string path\\n            return False\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2023210,
                "title": "3d-dp",
                "content": "int dp[105][105][105]; // dp[i][j][k]=> 0 or 1 accordingly if we are at i,j and have k opening bracket \\n    \\n    int sol(int x,int y,int ob,int cb,int &p,vector<vector<char>>& grid)\\n    {\\n        if(cb>ob || (ob>p || cb>p))\\n        {\\n            return 0;\\n        }\\n        \\n        if(x==grid.size()-1 && y==grid[0].size()-1)\\n        {\\n            if(ob==cb)\\n            {\\n                return 1;\\n            }\\n            \\n            return 0;\\n        }\\n        \\n        if(dp[x][y][ob]!=-1)\\n        {\\n            return dp[x][y][ob];\\n        }\\n        \\n        int ans=0;\\n        \\n        if(x+1<grid.size())\\n        {\\n            if(grid[x+1][y]==\\'(\\')\\n            ans=ans|sol(x+1,y,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x+1,y,ob,cb+1,p,grid);\\n        }\\n        \\n        if(y+1<grid[0].size())\\n        {\\n            if(grid[x][y+1]==\\'(\\')\\n            ans=ans|sol(x,y+1,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x,y+1,ob,cb+1,p,grid);\\n        }\\n        \\n        return dp[x][y][ob]=ans;\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)%2 || grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\')\\n        {\\n            return false;\\n        }\\n        \\n        int p=(n+m-1)/2; // this is the size of final valid string and it must have (n+m-1)/2 opening bracket and closing bracket and hence opening and closing bracket should not cross (n+m-1)/2.\\n\\n        return sol(0,0,1,0,p,grid);\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "int dp[105][105][105]; // dp[i][j][k]=> 0 or 1 accordingly if we are at i,j and have k opening bracket \\n    \\n    int sol(int x,int y,int ob,int cb,int &p,vector<vector<char>>& grid)\\n    {\\n        if(cb>ob || (ob>p || cb>p))\\n        {\\n            return 0;\\n        }\\n        \\n        if(x==grid.size()-1 && y==grid[0].size()-1)\\n        {\\n            if(ob==cb)\\n            {\\n                return 1;\\n            }\\n            \\n            return 0;\\n        }\\n        \\n        if(dp[x][y][ob]!=-1)\\n        {\\n            return dp[x][y][ob];\\n        }\\n        \\n        int ans=0;\\n        \\n        if(x+1<grid.size())\\n        {\\n            if(grid[x+1][y]==\\'(\\')\\n            ans=ans|sol(x+1,y,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x+1,y,ob,cb+1,p,grid);\\n        }\\n        \\n        if(y+1<grid[0].size())\\n        {\\n            if(grid[x][y+1]==\\'(\\')\\n            ans=ans|sol(x,y+1,ob+1,cb,p,grid);\\n            else\\n            ans=ans|sol(x,y+1,ob,cb+1,p,grid);\\n        }\\n        \\n        return dp[x][y][ob]=ans;\\n    }\\n    \\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=grid.size(),m=grid[0].size();\\n        if((n+m-1)%2 || grid[0][0]==\\')\\' || grid[n-1][m-1]==\\'(\\')\\n        {\\n            return false;\\n        }\\n        \\n        int p=(n+m-1)/2; // this is the size of final valid string and it must have (n+m-1)/2 opening bracket and closing bracket and hence opening and closing bracket should not cross (n+m-1)/2.\\n\\n        return sol(0,0,1,0,p,grid);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2022904,
                "title": "python-dfs-memo-ignoring-bad-paths-with-counters",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        size = m+n-1\\n        if size % 2 == 1 or grid[0][0] == \\')\\' or grid[m-1][n-1] == \\'(\\':\\n            return False\\n        \\n        @cache\\n        def trav(r, c, cnt, step):\\n            if grid[r][c] == \\'(\\':\\n                newCnt = cnt+1\\n            else:\\n                newCnt = cnt-1\\n            \\n            if step == size:\\n                if newCnt == 0:\\n                    return True\\n                return False\\n        \\n            diffs = [(0,1), (1,0)]\\n            for dr, dc in diffs:\\n                newR, newC = r+dr, c+dc\\n                \\n                if newR < m and newC < n:\\n                    if newCnt > 0:\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                    elif grid[newR][newC] == \\'(\\':\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                        \\n            return False\\n                    \\n        return trav(0, 0, 0, 1)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        \\n        size = m+n-1\\n        if size % 2 == 1 or grid[0][0] == \\')\\' or grid[m-1][n-1] == \\'(\\':\\n            return False\\n        \\n        @cache\\n        def trav(r, c, cnt, step):\\n            if grid[r][c] == \\'(\\':\\n                newCnt = cnt+1\\n            else:\\n                newCnt = cnt-1\\n            \\n            if step == size:\\n                if newCnt == 0:\\n                    return True\\n                return False\\n        \\n            diffs = [(0,1), (1,0)]\\n            for dr, dc in diffs:\\n                newR, newC = r+dr, c+dc\\n                \\n                if newR < m and newC < n:\\n                    if newCnt > 0:\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                    elif grid[newR][newC] == \\'(\\':\\n                        if trav(newR, newC, newCnt, step+1):\\n                            return True\\n                        \\n            return False\\n                    \\n        return trav(0, 0, 0, 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022500,
                "title": "java-bottom-up-dp-using-hashset",
                "content": "**Intuition**\\nFor any given cell (x,y), it is possible to have a valid string starting from (0,0) only if number of open brackets upto (x,y) are 0. A path is invalid if number of \\')\\' exceeds number of \\'(\\'. \\n\\n**Approach**\\nFor each cell (i,j) of dp array, maintain a hashset and store the number of open brackets, updating the values in the hashset from dp[i-1][j] and dp[i][j-1].\\nif current character is \\'(\\', then increment the values from hashsets of dp[i-1][j] and dp[i][j-1].\\nif current character is \\')\\', thendecrement the values from hashsets of dp[i-1][j] and dp[i][j-1], ignoring negative values.\\nTrue is returned only if hashset of last cell has 0.\\n**Code**\\n```\\nclass Solution {\\n    class hs{\\n        HashSet<Integer> s;\\n        public hs(){\\n            s = new HashSet<>();\\n        }\\n       \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        hs[][] dp = new hs[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j] = new hs();\\n            }\\n        }\\n        dp[0][0].s.add(1);\\n        for(int i=1;i<m;i++){\\n            int k = (grid[0][i]==\\'(\\'?1:-1);\\n            for(int x: dp[0][i-1].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[0][i].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            int k = (grid[i][0]==\\'(\\'?1:-1);\\n               \\n            for(int x: dp[i-1][0].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[i][0].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n               int k = (grid[i][j]==\\'(\\'?1:-1);\\n                for(int x: dp[i-1][j].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                }\\n                for(int x: dp[i][j-1].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                    }\\n                \\n            }\\n        }\\n        \\n        \\n        return dp[n-1][m-1].s.contains(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    class hs{\\n        HashSet<Integer> s;\\n        public hs(){\\n            s = new HashSet<>();\\n        }\\n       \\n    }\\n    public boolean hasValidPath(char[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        hs[][] dp = new hs[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dp[i][j] = new hs();\\n            }\\n        }\\n        dp[0][0].s.add(1);\\n        for(int i=1;i<m;i++){\\n            int k = (grid[0][i]==\\'(\\'?1:-1);\\n            for(int x: dp[0][i-1].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[0][i].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            int k = (grid[i][0]==\\'(\\'?1:-1);\\n               \\n            for(int x: dp[i-1][0].s){\\n                if(x+k<0){\\n                    continue;\\n                }\\n                dp[i][0].s.add(x+k);\\n                \\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n               int k = (grid[i][j]==\\'(\\'?1:-1);\\n                for(int x: dp[i-1][j].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                }\\n                for(int x: dp[i][j-1].s){\\n                    if(x+k<0){\\n                        continue;\\n                    }\\n                    dp[i][j].s.add(x+k);\\n                    }\\n                \\n            }\\n        }\\n        \\n        \\n        return dp[n-1][m-1].s.contains(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022400,
                "title": "getting-tle-don-t-know-why",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[101][101][202];\\n    int m, n;\\n    bool rec(int i , int j, int cnt, vector<vector<char>>& grid)\\n    {\\n        if(i >= m || j >= n || cnt < 0)return 0;\\n        if(i == m-1 && j == n-1){\\n            if(grid[i][j] == \\'(\\')cnt++;\\n            else cnt--;\\n            return cnt == 0;\\n        }\\n        if(dp[i][j][cnt]!=-1)return dp[i][j][cnt];\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')cnt++;\\n        else cnt--;\\n        ans = rec(i+1, j, cnt, grid) || rec(i,j+1, cnt, grid);\\n        if(cnt < 0)return false;\\n        return dp[i][j][cnt] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,0,grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101][202];\\n    int m, n;\\n    bool rec(int i , int j, int cnt, vector<vector<char>>& grid)\\n    {\\n        if(i >= m || j >= n || cnt < 0)return 0;\\n        if(i == m-1 && j == n-1){\\n            if(grid[i][j] == \\'(\\')cnt++;\\n            else cnt--;\\n            return cnt == 0;\\n        }\\n        if(dp[i][j][cnt]!=-1)return dp[i][j][cnt];\\n        bool ans = false;\\n        if(grid[i][j] == \\'(\\')cnt++;\\n        else cnt--;\\n        ans = rec(i+1, j, cnt, grid) || rec(i,j+1, cnt, grid);\\n        if(cnt < 0)return false;\\n        return dp[i][j][cnt] = ans;\\n    }\\n    bool hasValidPath(vector<vector<char>>& grid) \\n    {\\n        m = grid.size();\\n        n = grid[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,0,grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021904,
                "title": "python-easy-to-read-and-understand",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def check(i, j, x, memo=set()):\\n            if i >= n or j >= m:\\n                return False\\n            \\n\\t\\t\\t# x is the parenthesis score till now; add by 1 if the cell is ( else subtract by 1\\n            x += 1 if grid[i][j] == \\'(\\' else -1\\n            \\n\\t\\t\\t# If the score is negative then the sequence is already invalid\\n\\t\\t\\t# or if the score is greater than half of the path length then the sequence is invalid\\n\\t\\t\\t# or if it is already visited then return False\\n            if x < 0 or x > (m+n)//2 or (i,j,x) in memo:\\n                return False\\n            \\n            memo.add((i,j,x))\\n            \\n\\t\\t\\t\\n\\t\\t\\t# if it\\'s the last cell and score is 0 then it is a valid sequence\\n            if i == n-1 and j == m-1 and x == 0:\\n                return True\\n            \\n            return check(i+1, j, x, memo) or check(i, j+1, x, memo)\\n    \\n        n, m = len(grid), len(grid[0])\\n\\t\\t\\n\\t\\t# if the path length is odd: return False\\n\\t\\t# if the first cell is ): return False\\n\\t\\t# if the last cell is (: return False\\n        if (n+m-1)%2 or grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\':\\n            return False\\n        \\n        return check(0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        def check(i, j, x, memo=set()):\\n            if i >= n or j >= m:\\n                return False\\n            \\n\\t\\t\\t# x is the parenthesis score till now; add by 1 if the cell is ( else subtract by 1\\n            x += 1 if grid[i][j] == \\'(\\' else -1\\n            \\n\\t\\t\\t# If the score is negative then the sequence is already invalid\\n\\t\\t\\t# or if the score is greater than half of the path length then the sequence is invalid\\n\\t\\t\\t# or if it is already visited then return False\\n            if x < 0 or x > (m+n)//2 or (i,j,x) in memo:\\n                return False\\n            \\n            memo.add((i,j,x))\\n            \\n\\t\\t\\t\\n\\t\\t\\t# if it\\'s the last cell and score is 0 then it is a valid sequence\\n            if i == n-1 and j == m-1 and x == 0:\\n                return True\\n            \\n            return check(i+1, j, x, memo) or check(i, j+1, x, memo)\\n    \\n        n, m = len(grid), len(grid[0])\\n\\t\\t\\n\\t\\t# if the path length is odd: return False\\n\\t\\t# if the first cell is ): return False\\n\\t\\t# if the last cell is (: return False\\n        if (n+m-1)%2 or grid[0][0] == \\')\\' or grid[-1][-1] == \\'(\\':\\n            return False\\n        \\n        return check(0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021889,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        n=len(grid)-1\\n        m=len(grid[0])-1\\n        @cache\\n        def dp(i,j,o):\\n            if i==n and j==m:return o==0\\n            ni=i+1\\n            if ni<=n:\\n                if grid[ni][j]==\"(\":\\n                    if dp(ni,j,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(ni,j,o-1):return True\\n            nj=j+1\\n            if nj<=m:\\n                if grid[i][nj]==\"(\":\\n                    if dp(i,nj,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(i,nj,o-1):return True\\n            return False\\n        if grid[0][0]!=\"(\":return False\\n        return dp(0,0,1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        n=len(grid)-1\\n        m=len(grid[0])-1\\n        @cache\\n        def dp(i,j,o):\\n            if i==n and j==m:return o==0\\n            ni=i+1\\n            if ni<=n:\\n                if grid[ni][j]==\"(\":\\n                    if dp(ni,j,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(ni,j,o-1):return True\\n            nj=j+1\\n            if nj<=m:\\n                if grid[i][nj]==\"(\":\\n                    if dp(i,nj,o+1):return True\\n                elif (o-1)>=0:\\n                    if dp(i,nj,o-1):return True\\n            return False\\n        if grid[0][0]!=\"(\":return False\\n        return dp(0,0,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2021334,
                "title": "dfs-dp",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint dp[101][101][1001],m,n;\\n\\n\\t\\tint path(vector<vector<char>>&grid, int i, int j,int total){\\n\\t\\t\\tif(i==n or j==m) return 0;\\n\\t\\t\\tgrid[i][j]==\\')\\'?total--:total++;\\n\\t\\t\\tif(total<0) return 0;\\n\\t\\t\\tif(i == n-1 and j == m-1) return total==0;\\n\\t\\t\\tif(dp[i][j][total]!=-1) return dp[i][j][total];\\n\\t\\t\\treturn dp[i][j][total] = path(grid,i+1,j,total) or path(grid,i,j+1,total);\\n\\t\\t}\\n\\n\\t\\tbool hasValidPath(vector<vector<char>>& grid) {\\n\\t\\t\\t memset(dp,-1,sizeof dp);\\n\\t\\t\\t n = grid.size();\\n\\t\\t\\t m = grid[0].size();\\n\\t\\t\\t if(grid[0][0]==\\')\\') return false;\\n\\t\\t\\t return path(grid,0,0,0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint dp[101][101][1001],m,n;\\n\\n\\t\\tint path(vector<vector<char>>&grid, int i, int j,int total){\\n\\t\\t\\tif(i==n or j==m) return 0;\\n\\t\\t\\tgrid[i][j]==\\')\\'?total--:total++;\\n\\t\\t\\tif(total<0) return 0;\\n\\t\\t\\tif(i == n-1 and j == m-1) return total==0;\\n\\t\\t\\tif(dp[i][j][total]!=-1) return dp[i][j][total];\\n\\t\\t\\treturn dp[i][j][total] = path(grid,i+1,j,total) or path(grid,i,j+1,total);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2021274,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    public boolean valid(int r,  int c , int balance , char[][] grid){\\n        if(balance < 0) return false; // if closing brackets exceeds open then it can never be a valid path\\n        if(r == grid.length - 1 && c == grid[0].length - 1) return balance == 0; \\n        if(dp[r][c][balance] != null) return dp[r][c][balance];\\n        boolean res = false;\\n        if(r + 1 < grid.length){\\n            res |= valid(r + 1 , c , balance + (grid[r+1][c] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        if(c + 1 < grid[0].length){\\n            res |= valid(r, c + 1 , balance + (grid[r][c+1] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        dp[r][c][balance] = res;\\n        return res;\\n    }\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\') return false; // if first character in path is ) then its not a valid path\\n        dp = new Boolean[101][101][202];\\n        return valid(0,0,1,grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Boolean[][][] dp;\\n    public boolean valid(int r,  int c , int balance , char[][] grid){\\n        if(balance < 0) return false; // if closing brackets exceeds open then it can never be a valid path\\n        if(r == grid.length - 1 && c == grid[0].length - 1) return balance == 0; \\n        if(dp[r][c][balance] != null) return dp[r][c][balance];\\n        boolean res = false;\\n        if(r + 1 < grid.length){\\n            res |= valid(r + 1 , c , balance + (grid[r+1][c] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        if(c + 1 < grid[0].length){\\n            res |= valid(r, c + 1 , balance + (grid[r][c+1] == \\'(\\' ? 1 : -1) , grid);\\n        }\\n        dp[r][c][balance] = res;\\n        return res;\\n    }\\n    \\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\') return false; // if first character in path is ) then its not a valid path\\n        dp = new Boolean[101][101][202];\\n        return valid(0,0,1,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020914,
                "title": "c-17-fast-and-easy-to-understand-bottom-up-dp-using-bitset-and-bit-shifts-in-60ms",
                "content": "### [C++17] fast and easy-to-understand Bottom-Up DP using bitset and bit-shifts, in ~60ms\\n\\n#### Approach and Ideas:\\n##### helper ideas:\\n* parenthesis-path-sum:\\n  Let `(` be +1, and `)` be `-1`, then the parenthesis path sum is a simple sum of these `+1`s\\n  and `-1`s.\\n* classification of paths wrt the parenthesis-path-sum:\\n  A path is invalid if its path-sum becomes negative.\\n  A path is perfect if its path-sum is 0.\\n  A path is quasi-valid if its path-sum is positive.\\n#### Core Ideas:\\n1. DP:\\nLet f[r][c] be the set of integers where each integer representing the parenthesis-path-sum of\\nsome path(s) from [0][0] to [r][c]. In other words, f maps [r][c] to bitset<N>.\\nIn the general case, we have:\\n f[r][c] =\\n     a) add one element-wise, to (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\'(\\';\\n     b) subtract one element-wise, from (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\')\\'; Note that\\n     here we\\'ll remove all negative parenthesis-path-sums because they are invalid paths.\\nThe original problem becomes checking whether 0 is in the set at f[m-1][n-1].\\n\\n2. Accelerating the computation by ~25X, using bitset<N>:\\n* Using bitset<N> instead of unordered_set<int> to represent the set of valid\\nparenthesis-path-sums.\\n* Using bitset\\'s left-shifts `<<` for the element-wise `+1` operation, and using right-shifts\\n`>>` for the element-wise `-1` operation, and using the xor `^` operation to clear the bits.\\n\\n3. There are several cases where we can return early. Please see the code for details.\\n\\n##### Running time:\\n* Using bitset<100>:        59ms ~ 63ms\\n* using unordered_set<int>: ~1500ms\\n\\n\\n```\\n// 2267. Check if There Is a Valid Parentheses String Path\\n// Approach and Ideas:\\n// helper ideas:\\n// * parenthesis-path-sum:\\n//   Let `(` be +1, and `)` be `-1`, then the parenthesis path sum is a simple sum of these `+1`s\\n//   and `-1`s.\\n// * classification of paths wrt the parenthesis-path-sum:\\n//   A path is invalid if its path-sum becomes negative.\\n//   A path is perfect if its path-sum is 0.\\n//   A path is quasi-valid if its path-sum is positive.\\n//\\n// Core Ideas:\\n// 1. DP:\\n// Let f[r][c] be the set of integers where each integer representing the parenthesis-path-sum of\\n// some path(s) from [0][0] to [r][c]. In other words, f maps [r][c] to bitset<N>.\\n// In the general case, we have:\\n//  f[r][c] =\\n//      a) add one element-wise, to (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\'(\\';\\n//      b) subtract one element-wise, from (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\')\\'; Note that\\n//      here we\\'ll remove all negative parenthesis-path-sums because they are invalid paths.\\n// The original problem becomes checking whether 0 is in the set at f[m-1][n-1].\\n//\\n// 2. Accelerating the computation by ~25X, using bitset<N>:\\n// * Using bitset<N> instead of unordered_set<int> to represent the set of valid\\n// parenthesis-path-sums.\\n// * Using bitset\\'s left-shifts `<<` for the element-wise `+1` operation, and using right-shifts\\n// `>>` for the element-wise `-1` operation, and using the xor `^` operation to clear the bits.\\n//\\n// Running times:\\n// * Using bitset<100>:        59ms ~ 63ms\\n// * using unordered_set<int>: ~1500ms\\nclass Solution { // DP with BitSets and Shifts ops\\n    // the problem constraint says that: 1 <= m, n <= 100.\\n    // so there are at most 100 left-parentheses in a valid path.\\n    // We can adjust this constant if the problem-size goes up.\\n    constexpr static int ProblemSize = 100;\\n    using BitSet = bitset<ProblemSize>;\\n\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        const int maxPathLen = m + n - 1;\\n        if (maxPathLen & 1) { // if this is odd, it\\'s impossible to have valid parenthesis-path\\n            return false;\\n        }\\n\\n        // DP tables:\\n        // f is the `previous` row, g is the `current` row\\n        vector<BitSet> f(n), g(n);\\n        // initialize\\n        {\\n            if (ToNumeric(grid[0][0]) < 0) {\\n                return false; // if the starting point is invalid, all paths are invalid.\\n            }\\n            f[0][1] = true;\\n            for (int c = 1; c < n; ++c) {\\n                AddToEachElementAndRemoveInvalidElement(f[c - 1], ToNumeric(grid[0][c]), f[c]);\\n            }\\n        }\\n        // general cases for each row\\n        for (int r = 1; r < m; ++r) {\\n            // first element of the row\\n            AddToEachElementAndRemoveInvalidElement(f[0], ToNumeric(grid[r][0]), g[0]);\\n            bool allEmpty = (g[0].count() == 0);\\n            for (int c = 1; c < n; ++c) {\\n                int parenNumeric = ToNumeric(grid[r][c]);\\n                // paths from grid[r-1][c]\\n                AddToEachElementAndRemoveInvalidElement(f[c], parenNumeric, g[c]);\\n                // paths from grid[r][c-1]\\n                AddToEachElementAndRemoveInvalidElement(g[c - 1], parenNumeric, g[c]);\\n                allEmpty &= (g[c].count() == 0);\\n            }\\n            if (allEmpty) { // since this row is all empty, there won\\'t be valid path.\\n                return false; // so, return earlier.\\n            }\\n            g.swap(f);\\n            ClearEachSet(g);\\n        }\\n        // the set of the parenthesis-path-sums for the destination cell contains 0,\\n        // it means there is a valid parenthesis path.\\n        return f[n - 1][0];\\n    }\\n\\nprivate:\\n    static void ClearEachSet(vector<BitSet>& dpRow) {\\n        for (auto& theSet : dpRow) {\\n            theSet ^= theSet;\\n        }\\n    }\\n    static void AddToEachElementAndRemoveInvalidElement(\\n            const BitSet& originalSet,\\n            const int parenNumeric,\\n            BitSet& resultingSet) {\\n        if (parenNumeric == 1) { // +1: left-shift\\n            resultingSet |= (originalSet << 1);\\n        } else { // -1: right-shift\\n            resultingSet |= (originalSet >> 1);\\n        }\\n    }\\n\\n    static inline int ToNumeric(char parenthesis) {\\n        if (parenthesis == \\'(\\') {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// 2267. Check if There Is a Valid Parentheses String Path\\n// Approach and Ideas:\\n// helper ideas:\\n// * parenthesis-path-sum:\\n//   Let `(` be +1, and `)` be `-1`, then the parenthesis path sum is a simple sum of these `+1`s\\n//   and `-1`s.\\n// * classification of paths wrt the parenthesis-path-sum:\\n//   A path is invalid if its path-sum becomes negative.\\n//   A path is perfect if its path-sum is 0.\\n//   A path is quasi-valid if its path-sum is positive.\\n//\\n// Core Ideas:\\n// 1. DP:\\n// Let f[r][c] be the set of integers where each integer representing the parenthesis-path-sum of\\n// some path(s) from [0][0] to [r][c]. In other words, f maps [r][c] to bitset<N>.\\n// In the general case, we have:\\n//  f[r][c] =\\n//      a) add one element-wise, to (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\'(\\';\\n//      b) subtract one element-wise, from (f[r][c-1] U f[r-1][c]), if grid[r][c] == \\')\\'; Note that\\n//      here we\\'ll remove all negative parenthesis-path-sums because they are invalid paths.\\n// The original problem becomes checking whether 0 is in the set at f[m-1][n-1].\\n//\\n// 2. Accelerating the computation by ~25X, using bitset<N>:\\n// * Using bitset<N> instead of unordered_set<int> to represent the set of valid\\n// parenthesis-path-sums.\\n// * Using bitset\\'s left-shifts `<<` for the element-wise `+1` operation, and using right-shifts\\n// `>>` for the element-wise `-1` operation, and using the xor `^` operation to clear the bits.\\n//\\n// Running times:\\n// * Using bitset<100>:        59ms ~ 63ms\\n// * using unordered_set<int>: ~1500ms\\nclass Solution { // DP with BitSets and Shifts ops\\n    // the problem constraint says that: 1 <= m, n <= 100.\\n    // so there are at most 100 left-parentheses in a valid path.\\n    // We can adjust this constant if the problem-size goes up.\\n    constexpr static int ProblemSize = 100;\\n    using BitSet = bitset<ProblemSize>;\\n\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        const int m = grid.size(), n = grid[0].size();\\n        const int maxPathLen = m + n - 1;\\n        if (maxPathLen & 1) { // if this is odd, it\\'s impossible to have valid parenthesis-path\\n            return false;\\n        }\\n\\n        // DP tables:\\n        // f is the `previous` row, g is the `current` row\\n        vector<BitSet> f(n), g(n);\\n        // initialize\\n        {\\n            if (ToNumeric(grid[0][0]) < 0) {\\n                return false; // if the starting point is invalid, all paths are invalid.\\n            }\\n            f[0][1] = true;\\n            for (int c = 1; c < n; ++c) {\\n                AddToEachElementAndRemoveInvalidElement(f[c - 1], ToNumeric(grid[0][c]), f[c]);\\n            }\\n        }\\n        // general cases for each row\\n        for (int r = 1; r < m; ++r) {\\n            // first element of the row\\n            AddToEachElementAndRemoveInvalidElement(f[0], ToNumeric(grid[r][0]), g[0]);\\n            bool allEmpty = (g[0].count() == 0);\\n            for (int c = 1; c < n; ++c) {\\n                int parenNumeric = ToNumeric(grid[r][c]);\\n                // paths from grid[r-1][c]\\n                AddToEachElementAndRemoveInvalidElement(f[c], parenNumeric, g[c]);\\n                // paths from grid[r][c-1]\\n                AddToEachElementAndRemoveInvalidElement(g[c - 1], parenNumeric, g[c]);\\n                allEmpty &= (g[c].count() == 0);\\n            }\\n            if (allEmpty) { // since this row is all empty, there won\\'t be valid path.\\n                return false; // so, return earlier.\\n            }\\n            g.swap(f);\\n            ClearEachSet(g);\\n        }\\n        // the set of the parenthesis-path-sums for the destination cell contains 0,\\n        // it means there is a valid parenthesis path.\\n        return f[n - 1][0];\\n    }\\n\\nprivate:\\n    static void ClearEachSet(vector<BitSet>& dpRow) {\\n        for (auto& theSet : dpRow) {\\n            theSet ^= theSet;\\n        }\\n    }\\n    static void AddToEachElementAndRemoveInvalidElement(\\n            const BitSet& originalSet,\\n            const int parenNumeric,\\n            BitSet& resultingSet) {\\n        if (parenNumeric == 1) { // +1: left-shift\\n            resultingSet |= (originalSet << 1);\\n        } else { // -1: right-shift\\n            resultingSet |= (originalSet >> 1);\\n        }\\n    }\\n\\n    static inline int ToNumeric(char parenthesis) {\\n        if (parenthesis == \\'(\\') {\\n            return 1;\\n        } else {\\n            return -1;\\n        }\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020643,
                "title": "python-3-dp-with-pruning",
                "content": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\' or (m + n - 1) % 2: return False\\n        \\n        @lru_cache(None)\\n        def dp(x, y, ops):\\n\\t\\t\\t# if unpaired close bracket or remaining cannot match open brackets\\n            if ops < 0 or ops > (m + n - 1) // 2: return False\\n            if x == m - 1 and y == n - 1:\\n                return not ops\\n            \\n            for dx, dy in [(0, 1), (1, 0)]:\\n                nx, ny = x + dx, y + dy\\n                if not(0 <= nx < m and 0 <= ny < n): continue\\n                tmp = 1 if grid[nx][ny] == \\'(\\' else -1\\n                if dp(nx, ny, ops + tmp):\\n                    return True\\n            return False\\n        \\n        \\n        return dp(0, 0, 1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def hasValidPath(self, grid: List[List[str]]) -> bool:\\n        \\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == \\')\\' or (m + n - 1) % 2: return False\\n        \\n        @lru_cache(None)\\n        def dp(x, y, ops):\\n\\t\\t\\t# if unpaired close bracket or remaining cannot match open brackets\\n            if ops < 0 or ops > (m + n - 1) // 2: return False\\n            if x == m - 1 and y == n - 1:\\n                return not ops\\n            \\n            for dx, dy in [(0, 1), (1, 0)]:\\n                nx, ny = x + dx, y + dy\\n                if not(0 <= nx < m and 0 <= ny < n): continue\\n                tmp = 1 if grid[nx][ny] == \\'(\\' else -1\\n                if dp(nx, ny, ops + tmp):\\n                    return True\\n            return False\\n        \\n        \\n        return dp(0, 0, 1)",
                "codeTag": "Java"
            },
            {
                "id": 2020499,
                "title": "java-dp-o-mn-m-n-2",
                "content": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int MID = (row + col + 1) / 2;\\n        if(grid[0][0] != \\'(\\' || grid[row - 1][col - 1] != \\')\\') return false;\\n        boolean[][][] dp = new boolean[row][col][MID + 1];\\n        dp[0][0][1] = true;\\n        for(int i = 1; i < row; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[i][0] == \\'(\\' && j - 1 >= 0) {\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n                else if(grid[i][0] == \\')\\' && j + 1 <= MID) {\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < col; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[0][i] == \\'(\\' && j - 1 >= 0) {\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n                else if(grid[0][i] == \\')\\' && j + 1 <= MID) {\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++) {\\n            for(int j = 1; j < col; j++) {\\n                for(int k = 0; k <= MID; k++) {\\n                    if(grid[i][j] == \\'(\\' && k - 1 >= 0) {\\n                        dp[i][j][k] = dp[i - 1][j][k - 1] || dp[i][j - 1][k - 1];\\n                    }\\n                    else if(grid[i][j] == \\')\\' && k + 1 <= MID) {\\n                        dp[i][j][k] = dp[i - 1][j][k + 1] || dp[i][j - 1][k + 1];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        int row = grid.length;\\n        int col = grid[0].length;\\n        int MID = (row + col + 1) / 2;\\n        if(grid[0][0] != \\'(\\' || grid[row - 1][col - 1] != \\')\\') return false;\\n        boolean[][][] dp = new boolean[row][col][MID + 1];\\n        dp[0][0][1] = true;\\n        for(int i = 1; i < row; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[i][0] == \\'(\\' && j - 1 >= 0) {\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n                else if(grid[i][0] == \\')\\' && j + 1 <= MID) {\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < col; i++) {\\n            for(int j = 0; j <= MID; j++) {\\n                if(grid[0][i] == \\'(\\' && j - 1 >= 0) {\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n                else if(grid[0][i] == \\')\\' && j + 1 <= MID) {\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++) {\\n            for(int j = 1; j < col; j++) {\\n                for(int k = 0; k <= MID; k++) {\\n                    if(grid[i][j] == \\'(\\' && k - 1 >= 0) {\\n                        dp[i][j][k] = dp[i - 1][j][k - 1] || dp[i][j - 1][k - 1];\\n                    }\\n                    else if(grid[i][j] == \\')\\' && k + 1 <= MID) {\\n                        dp[i][j][k] = dp[i - 1][j][k + 1] || dp[i][j - 1][k + 1];\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[row - 1][col - 1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020475,
                "title": "my-c-solution-time-space-beat-100",
                "content": "A \\'(\\' will add the count by 1, and a \\')\\' will decrease the count by 1.\\nTrack whether a certain position in the matrix with a certain count has been visited or not to prune the dfs.\\n\\n```\\nclass Solution {\\nprivate:\\n    bool v[100][100][100];\\n    \\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    bool dfs(vector<vector<char>>& grid, int i, int j, int cnt) {\\n        if (i >= grid.size() || j >= grid[0].size()) {\\n            return false;\\n        }\\n        \\n        cnt += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if (cnt < 0 || cnt >= 100 || v[i][j][cnt]) {\\n            return false;\\n        }\\n                \\n        if (i == grid.size()-1 && j == grid[0].size()-1 && cnt == 0) {\\n            return true;\\n        }\\n        \\n        if (dfs(grid, i, j+1, cnt) || dfs(grid, i+1, j, cnt)) {\\n            return true;\\n        }\\n        else {\\n            v[i][j][cnt] = true;\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool v[100][100][100];\\n    \\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        return dfs(grid, 0, 0, 0);\\n    }\\n    \\n    bool dfs(vector<vector<char>>& grid, int i, int j, int cnt) {\\n        if (i >= grid.size() || j >= grid[0].size()) {\\n            return false;\\n        }\\n        \\n        cnt += (grid[i][j] == \\'(\\' ? 1 : -1);\\n        \\n        if (cnt < 0 || cnt >= 100 || v[i][j][cnt]) {\\n            return false;\\n        }\\n                \\n        if (i == grid.size()-1 && j == grid[0].size()-1 && cnt == 0) {\\n            return true;\\n        }\\n        \\n        if (dfs(grid, i, j+1, cnt) || dfs(grid, i+1, j, cnt)) {\\n            return true;\\n        }\\n        else {\\n            v[i][j][cnt] = true;\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020462,
                "title": "java-from-recursion-memoization-easy",
                "content": "Recursion-->>\\n\\n```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length-1]==\\'(\\')return false;\\n        return solve(0,0,grid,0);\\n    }\\n    public boolean solve(int i, int j ,char[][] grid,int open){\\n        if(i>=grid.length || j>=grid[0].length)return false;\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if(open<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1){\\n            if(open==0)\\n            return true;\\n        }\\n        \\n        \\n        \\n        if( solve(i+1,j,grid,open))\\n            return true;\\n        if( solve(i,j+1,grid,open))\\n            return true;\\n            \\n        return false;\\n        }\\n}\\n```\\n\\nMemoization -->>\\n\\n```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        if (grid[0][0] == \\')\\' || grid[grid.length - 1][grid[0].length - 1] == \\'(\\') return false;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Boolean[][][] dp = new Boolean[n][m][n + m];\\n        return solve(0, 0, grid, 0, dp);\\n    }\\n\\n    public boolean solve(int i, int j, char[][] grid, int open, Boolean[][][] dp) {\\n        if (i >= grid.length || j >= grid[0].length) return false;\\n\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0) return false;\\n\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            if (open == 0) return true;\\n        }\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n\\n        if (solve(i + 1, j, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n        if (solve(i, j + 1, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n\\n        return dp[i][j][open] = false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean hasValidPath(char[][] grid) {\\n        if(grid[0][0] == \\')\\' || grid[grid.length-1][grid[0].length-1]==\\'(\\')return false;\\n        return solve(0,0,grid,0);\\n    }\\n    public boolean solve(int i, int j ,char[][] grid,int open){\\n        if(i>=grid.length || j>=grid[0].length)return false;\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if(open<0) return false;\\n        if(i==grid.length-1 && j==grid[0].length-1){\\n            if(open==0)\\n            return true;\\n        }\\n        \\n        \\n        \\n        if( solve(i+1,j,grid,open))\\n            return true;\\n        if( solve(i,j+1,grid,open))\\n            return true;\\n            \\n        return false;\\n        }\\n}\\n```\n```\\nclass Solution {\\n\\n    public boolean hasValidPath(char[][] grid) {\\n        if (grid[0][0] == \\')\\' || grid[grid.length - 1][grid[0].length - 1] == \\'(\\') return false;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Boolean[][][] dp = new Boolean[n][m][n + m];\\n        return solve(0, 0, grid, 0, dp);\\n    }\\n\\n    public boolean solve(int i, int j, char[][] grid, int open, Boolean[][][] dp) {\\n        if (i >= grid.length || j >= grid[0].length) return false;\\n\\n        open += grid[i][j] == \\'(\\' ? 1 : -1;\\n        if (open < 0) return false;\\n\\n        if (i == grid.length - 1 && j == grid[0].length - 1) {\\n            if (open == 0) return true;\\n        }\\n        if (dp[i][j][open] != null) return dp[i][j][open];\\n\\n        if (solve(i + 1, j, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n        if (solve(i, j + 1, grid, open, dp)) {\\n            return dp[i][j][open] = true;\\n        }\\n\\n        return dp[i][j][open] = false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020399,
                "title": "c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int i, j, k;\\n        vector<vector<vector<bool>>> dp(rows, vector<vector<bool>> (cols, vector<bool> (rows + cols)));\\n        \\n        if(grid[0][0] == \\')\\' || grid[rows - 1][cols - 1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        dp[0][0][1] = true;\\n        for(i = 1; i < cols; i++){\\n            if(grid[0][i] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n            }\\n        }\\n        \\n        for(i = 1; i < rows; i++){\\n            if(grid[i][0] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n            }\\n        }\\n                \\n        for(i = 1; i < rows; i++){\\n            for(j = 1; j < cols; j++){\\n                if(grid[i][j] == \\')\\'){\\n                    for(k = 0; k < rows + cols - 1; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k + 1] || dp[i - 1][j][k + 1];\\n                    }\\n                }\\n                else{\\n                    for(k = 1; k < rows + cols; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k - 1] || dp[i - 1][j][k - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[rows - 1][cols - 1][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<char>>& grid) {\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        int i, j, k;\\n        vector<vector<vector<bool>>> dp(rows, vector<vector<bool>> (cols, vector<bool> (rows + cols)));\\n        \\n        if(grid[0][0] == \\')\\' || grid[rows - 1][cols - 1] == \\'(\\'){\\n            return false;\\n        }\\n        \\n        dp[0][0][1] = true;\\n        for(i = 1; i < cols; i++){\\n            if(grid[0][i] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[0][i][j] = dp[0][i - 1][j - 1];\\n                }\\n            }\\n        }\\n        \\n        for(i = 1; i < rows; i++){\\n            if(grid[i][0] == \\')\\'){\\n                for(j = 0; j < rows + cols - 1; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j + 1];\\n                }\\n            }\\n            else{\\n                for(j = 1; j < rows + cols; j++){\\n                    dp[i][0][j] = dp[i - 1][0][j - 1];\\n                }\\n            }\\n        }\\n                \\n        for(i = 1; i < rows; i++){\\n            for(j = 1; j < cols; j++){\\n                if(grid[i][j] == \\')\\'){\\n                    for(k = 0; k < rows + cols - 1; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k + 1] || dp[i - 1][j][k + 1];\\n                    }\\n                }\\n                else{\\n                    for(k = 1; k < rows + cols; k++){\\n                        dp[i][j][k] = dp[i][j - 1][k - 1] || dp[i - 1][j][k - 1];\\n                    }\\n                }\\n            }\\n        }\\n        return dp[rows - 1][cols - 1][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576750,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1570877,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1576729,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 2072858,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1922483,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            },
            {
                "id": 1732637,
                "content": [
                    {
                        "username": "StormAlex",
                        "content": "**How to read my post?**\\nJust match the Diagram number with the number mentioned in code.\\n\\nVariables used **r** =Total  rows, **c** = total columns, **x,y** are coordinates and **count** = No of opening brackets visited\\n\\n**Thought Process**\\n![image](https://assets.leetcode.com/users/images/64229d1d-1631-4f04-ba0c-b139882099d0_1652527273.4110048.png)\\n\\n**Let\\'s connect the thought with code:**\\n*Note: Thanks to @LarryNY for a easily understandable python code*\\n![image](https://assets.leetcode.com/users/images/1cee98cd-f0bb-4eb1-8396-c70ea0b82268_1652527350.5416386.png)\\n\\n**Important point:** @cache is a decorator in python which helps to memoize the recursive function. Without that decorator this code will give TLE. You can always try to memoize it in your own way.\\n\\n"
                    },
                    {
                        "username": "VVHack",
                        "content": "I tried solving this using BFS + caching and DFS + caching, DFS was much faster. Why was DFS faster? Is it because BFS tries to run all paths at the same time and find the shortest whereas DFS just looks for any valid path?"
                    },
                    {
                        "username": "taakasj",
                        "content": "There are many wrong test cases for this question.\\nFor ex: The expected output for input [[\"(\",\"(\"]] is \\'true\\' but the accepted response should be \\'false\\'\\n\\nAnother example : [[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\"],[\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\"],[\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\")\"],[\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\"],[\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\"],[\"(\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\"],[\")\",\"(\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\"],[\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\")\",\")\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\")\"],[\"(\",\")\",\"(\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\"(\"],[\")\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\")\",\")\",\"(\"],[\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\",\")\",\"(\",\"(\",\"(\"],[\"(\",\"(\",\"(\",\")\",\")\",\"(\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\")\",\")\",\")\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\")\",\"(\",\"(\",\"(\",\"(\",\"(\",\"(\",\")\"]] \\n\\nThe expected answer is \\'false\\' but correct answer should be \\'true\\'.\\n\\nIs everyone facing the same issue ?"
                    },
                    {
                        "username": "enigmaHere",
                        "content": "why is this approach not working\\n\\nclass Solution {\\n    public boolean hasValidPath(char[][] arr) {\\n        int r = arr.length;\\n        int c = arr[0].length;\\n        Byte dp[][] = new Byte[r][c];\\n        Stack<Character> stack = new Stack<Character>();\\n        if(arr[0][0] == \\'(\\')\\n            stack.push(\\'(\\');\\n        else\\n            return false;\\n        rec(arr,r,c,0,0,dp,stack);\\n        return (dp[0][0] == 0)? false : true;\\n\\n        // return dynamic(arr);\\n    }\\n\\n    Byte rec(char[][] arr,int r,int c,int x , int y,Byte[][] dp,Stack<Character> stack){\\n        if(x == r-1 && y == c-1)\\n            return (stack.empty())? (byte)1 : (byte)0;\\n        \\n        if(dp[x][y] != null)\\n            return dp[x][y];\\n\\n        byte right = 0,down = 0;\\n        //move right\\n        if(y < c-1){\\n            char ch = arr[x][y+1];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                right = rec(arr,r,c,x,y+1,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n\\n        //move down\\n        if(x < r-1){\\n            char ch = arr[x+1][y];\\n            if(ch == \\'(\\'){\\n                stack.push(ch);\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.pop();\\n            }\\n            else if(!stack.empty()){\\n                stack.pop();\\n                down = rec(arr,r,c,x+1,y,dp,stack);\\n                stack.push(\\'(\\');\\n            }\\n        }\\n        return dp[x][y] = (byte)Math.max((int)right , (int)down);\\n    }\\n\\n}"
                    },
                    {
                        "username": "bigfatcoder",
                        "content": "This is a classic medium problem. Shouldn\\'t be labelled as hard."
                    },
                    {
                        "username": "themaniac",
                        "content": "Why is this solution not accepted?\nI got TLE for it but others who have a similar solution got accepted?\nPlease let me know..\n\n `\nclass Solution {\npublic:\n    int dp[101][101][201];\n    bool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\n        \n        if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==')') {\n            return true;\n        }\n        if(i==grid.size() || j == grid[0].size()) return false;\n        \n        if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\n        \n        if (grid[i][j] == '(')\n            lefts++;\n        else if(grid[i][j]==')' && lefts>0)\n            lefts--;\n        else \n            return dp[i][j][lefts]=false;\n        \n        bool found = false;\n        if(i+1<grid.size())\n            found |= recurse( grid, i+1, j, lefts);\n        if(j+1<grid[0].size())\n            found |= recurse( grid, i, j+1, lefts);\n        \n        return dp[i][j][lefts]=found;\n            \n    }\n    bool hasValidPath(vector<vector<char>>& grid) {\n        memset(dp, -1, sizeof(dp));\n        return recurse(grid, 0, 0, 0);     \n    }\n};\n`"
                    },
                    {
                        "username": "agrawalishaan",
                        "content": "[@user7613o](/user7613o) Memoization does work"
                    },
                    {
                        "username": "vishal-",
                        "content": "You are modifying lefts and storing result in dp[i][j][lefts].\\n\\nUse a temp variable to store lefts before modfying.\\n\\n```\\nclass Solution {\\npublic:\\nint dp[101][101][201];\\nbool recurse(vector<vector<char>>& grid, int i, int j, int lefts) {\\n\\n    if(i==grid.size()-1 && j==grid[0].size()-1 && lefts==1 && grid[i][j]==\\')\\') {\\n        return true;\\n    }\\n    if(i==grid.size() || j == grid[0].size()) return false;\\n    \\n    if(dp[i][j][lefts]!=-1) return dp[i][j][lefts];\\n    \\n    // We can\\'t use dp[i][j][lefts] as we are modifying lefts,\\n    // store lefts value in another variable.\\n    int prev_lefts = lefts;\\n\\n    if (grid[i][j] == \\'(\\')\\n        lefts++;\\n    else if(grid[i][j]==\\')\\' && lefts>0)\\n        lefts--;\\n    else \\n        return dp[i][j][prev_lefts]=false;\\n    \\n    bool found = false;\\n    if(i+1<grid.size())\\n        found |= recurse( grid, i+1, j, lefts);\\n    if(j+1<grid[0].size())\\n        found |= recurse( grid, i, j+1, lefts);\\n    \\n    return dp[i][j][prev_lefts]=found;\\n        \\n}\\nbool hasValidPath(vector<vector<char>>& grid) {\\n    memset(dp, -1, sizeof(dp));\\n    return recurse(grid, 0, 0, 0);     \\n}\\n};\\n```"
                    },
                    {
                        "username": "user7613o",
                        "content": "bro memoization does not work in this qn you have to try tabulation form \\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Obstacle Removal to Reach Corner",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D integer array <code>grid</code> of size <code>m x n</code>. Each cell has one of two values:</p>\n\n<ul>\n\t<li><code>0</code> represents an <strong>empty</strong> cell,</li>\n\t<li><code>1</code> represents an <strong>obstacle</strong> that may be removed.</li>\n</ul>\n\n<p>You can move up, down, left, or right from and to an empty cell.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of <strong>obstacles</strong> to <strong>remove</strong> so you can move from the upper left corner </em><code>(0, 0)</code><em> to the lower right corner </em><code>(m - 1, n - 1)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png\" style=\"width: 605px; height: 246px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1,1],[1,1,0],[1,1,0]]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png\" style=\"width: 405px; height: 246px;\" />\n<pre>\n<strong>Input:</strong> grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid.length</code></li>\n\t<li><code>n == grid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>2 &lt;= m * n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>grid[i][j]</code> is either <code>0</code> <strong>or</strong> <code>1</code>.</li>\n\t<li><code>grid[0][0] == grid[m - 1][n - 1] == 0</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2086036,
                "title": "let-s-solve-this-problem-based-on-never-give-up-explained-failure-point",
                "content": "While giving the contest the first intuition which came to my mind is dp. Yes, Off-course after solving a bunch of dp problems in the beginning I am also the person who wants to see dp everywhere.\\n\\nSo, Here is my code for using dp which failed 2nd test case though. But still, I have written something which I can analyze.\\n```\\n\\nclass Solution {\\n    int [][]grid;\\n    int n,m;\\n    boolean [][]seen;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    int finalres;\\n    private boolean isValid(int i, int j) {\\n        return Math.min(i,j)>=0 && i<n && j<m && !seen[i][j];\\n    }\\n    \\n    private int solve(int i, int j, int cnt) {\\n        if(cnt>=finalres) return finalres;\\n        if(i == n-1 && j == m-1) {\\n            return cnt;\\n        }\\n        if(dp[i][j]!=Integer.MAX_VALUE) return dp[i][j];\\n        int res = n*m+1;\\n        seen[i][j]=true;\\n        for(int k=0;k<4;k++) {\\n            int newI = i+dx[k], newJ = j+dy[k];\\n            if(isValid(newI, newJ)) {\\n                res = Math.min(res, solve(newI, newJ, cnt+grid[i][j]));\\n            }\\n        }\\n        seen[i][j]=false;\\n        return dp[i][j]=Math.min(dp[i][j], res);\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.grid = grid;\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        this.seen = new boolean[n][m];\\n        dp = new int[n][m];\\n        finalres = n*m+1;\\n        for(int []row:dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        return solve(0,0,0);\\n    }\\n}\\n```\\n\\n**But It didn\\'t work.**\\n# Why?\\nsince once I store the result of (i,j) using path let\\'s say \"*path*\" then whenever I again come to (i,j), I just used the already saved result. So here is what my code assumes once we get the result for (i,j) then it\\'s the optimal. But there is the possibility that a path from a different *path* that contributed to saving the dp result will be coming with less cost(i.e. cost == the number of blockers that needs to remove). That\\'s why it\\'s failed.\\n\\n**Ok so let\\'s try another way**\\nSo at this point of time, I was confirmed that, dp wouldn\\'t help here. So what next I can try?\\nSince from (0,0) to (n-1,m-1) I can have multiple paths and I need the path which has the minimum number of blockers(not exactly the path just count). So yeah here I thought let\\'s do bfs so that each path will be running in the queue with their context and wouldn\\'t merge as in dp.\\n\\nSo here is the BFS code : \\n\\n```\\nclass Solution {\\n    int n,m;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    private boolean isValid(int i, int j) {\\n        return Math.min(i,j)>=0 && i<n && j<m;\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        dp = new int[n][m];\\n        for(int []row:dp)Arrays.fill(row,Integer.MAX_VALUE);\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n        int res = n*m+1;// At most i have to remove all the blockers.\\n        \\n        while(!queue.isEmpty()) {\\n            int thisLevel = queue.size();\\n            while(thisLevel-->0 ) {\\n                int []temp = queue.remove();\\n                int i=temp[0], j=temp[1];\\n                if(i==n-1 && j == m-1) {\\n                    res = Math.min(res, temp[2]);\\n                    continue;\\n                }\\n                \\n               for(int k=0;k<4;k++) {\\n                    int newI = i+dx[k], newJ = j+dy[k];\\n                   \\n                   // if newi and newj is valid and which is not increasing the cost for newi and newj which already i have achieved.\\n                    if(isValid(newI, newJ) && dp[newI][newJ]>temp[2]+grid[newI][newJ]) {\\n                        dp[newI][newJ]=temp[2]+grid[newI][newJ];\\n                        queue.add(new int[]{newI, newJ, dp[newI][newJ]});\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n**But again this code is given tle.**\\n# Why?\\nSo after doing analysis, I come to the point that, I was checking for any node (newI, newJ) which is going to be added to the queue that is, whether it is increasing the blocker count that I have already achieved for this node or not? Yeah, this is right and I should do that. But I skipped that If the same node (newI, newJ) is already in the queue with the greater number of blockers that we\\'re getting now.\\nSo why this is making an issue?\\nSince the node in the queue must be removed because we got a path to reach the (newI, newJ) with less blocker. If we don\\'t remove this path this path again will start adding the node in the queue which gives the result as TLE.\\nok so now let\\'s update it.\\n\\n```\\nclass Solution {\\n    int n,m;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    int [][]grid;\\n    private boolean isValid(int i, int j, int cost) {\\n        boolean valid = (Math.min(i,j)>=0 && i<n && j<m && dp[i][j]>cost+grid[i][j]);\\n        if(valid) dp[i][j]=cost+grid[i][j];\\n        return valid;\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.grid = grid;\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        dp = new int[n][m];\\n        for(int []row:dp)Arrays.fill(row,Integer.MAX_VALUE);\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n        int res = n*m+1;// At most i have to remove all the blockers.\\n        \\n        while(!queue.isEmpty()) {\\n            int thisLevel = queue.size();\\n            while(thisLevel-->0 ) {\\n                int []temp = queue.remove();\\n                int i=temp[0], j=temp[1];\\n                if(i==n-1 && j == m-1) {\\n                    res = Math.min(res, temp[2]);\\n                    continue;\\n                }\\n                \\n                if(temp[2]>dp[i][j]) {\\n                    // This is invalid path because we have achived better which already might be running in the queue\\n                    continue;\\n                }\\n                \\n               for(int k=0;k<4;k++) {\\n                    int newI = i+dx[k], newJ = j+dy[k];\\n                   \\n                   // if newi and newj is valid and which is not increasing the cost for newi and newj which already i have achieved.\\n                    if(isValid(newI, newJ, temp[2])) {\\n                        queue.add(new int[]{newI, newJ, dp[newI][newJ]});\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n**Aaahhha it\\'s accepted**\\nLater when I came to the discussion page and read some code. Then I remember this code is most likely the Dijkstra algorithm.\\n# So morel is\\nInstead of remembering the Algorithms just understand the actual concept and the problem for which any algorithms are made. Later in the future, you\\'ll be building the same algorithms again and again without remembering.\\n\\n**Please upvote if it\\'s fun and knowledgeable for you.**\\n\\nHappy coding!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    int [][]grid;\\n    int n,m;\\n    boolean [][]seen;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    int finalres;\\n    private boolean isValid(int i, int j) {\\n        return Math.min(i,j)>=0 && i<n && j<m && !seen[i][j];\\n    }\\n    \\n    private int solve(int i, int j, int cnt) {\\n        if(cnt>=finalres) return finalres;\\n        if(i == n-1 && j == m-1) {\\n            return cnt;\\n        }\\n        if(dp[i][j]!=Integer.MAX_VALUE) return dp[i][j];\\n        int res = n*m+1;\\n        seen[i][j]=true;\\n        for(int k=0;k<4;k++) {\\n            int newI = i+dx[k], newJ = j+dy[k];\\n            if(isValid(newI, newJ)) {\\n                res = Math.min(res, solve(newI, newJ, cnt+grid[i][j]));\\n            }\\n        }\\n        seen[i][j]=false;\\n        return dp[i][j]=Math.min(dp[i][j], res);\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.grid = grid;\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        this.seen = new boolean[n][m];\\n        dp = new int[n][m];\\n        finalres = n*m+1;\\n        for(int []row:dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        return solve(0,0,0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int n,m;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    private boolean isValid(int i, int j) {\\n        return Math.min(i,j)>=0 && i<n && j<m;\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        dp = new int[n][m];\\n        for(int []row:dp)Arrays.fill(row,Integer.MAX_VALUE);\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n        int res = n*m+1;// At most i have to remove all the blockers.\\n        \\n        while(!queue.isEmpty()) {\\n            int thisLevel = queue.size();\\n            while(thisLevel-->0 ) {\\n                int []temp = queue.remove();\\n                int i=temp[0], j=temp[1];\\n                if(i==n-1 && j == m-1) {\\n                    res = Math.min(res, temp[2]);\\n                    continue;\\n                }\\n                \\n               for(int k=0;k<4;k++) {\\n                    int newI = i+dx[k], newJ = j+dy[k];\\n                   \\n                   // if newi and newj is valid and which is not increasing the cost for newi and newj which already i have achieved.\\n                    if(isValid(newI, newJ) && dp[newI][newJ]>temp[2]+grid[newI][newJ]) {\\n                        dp[newI][newJ]=temp[2]+grid[newI][newJ];\\n                        queue.add(new int[]{newI, newJ, dp[newI][newJ]});\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int n,m;\\n    int []dx = new int[]{0,0,1,-1};\\n    int []dy = new int[]{1,-1,0,0};\\n    int [][]dp;\\n    int [][]grid;\\n    private boolean isValid(int i, int j, int cost) {\\n        boolean valid = (Math.min(i,j)>=0 && i<n && j<m && dp[i][j]>cost+grid[i][j]);\\n        if(valid) dp[i][j]=cost+grid[i][j];\\n        return valid;\\n    }\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        this.grid = grid;\\n        this.n = grid.length;\\n        this.m = grid[0].length;\\n        dp = new int[n][m];\\n        for(int []row:dp)Arrays.fill(row,Integer.MAX_VALUE);\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0,0});\\n        int res = n*m+1;// At most i have to remove all the blockers.\\n        \\n        while(!queue.isEmpty()) {\\n            int thisLevel = queue.size();\\n            while(thisLevel-->0 ) {\\n                int []temp = queue.remove();\\n                int i=temp[0], j=temp[1];\\n                if(i==n-1 && j == m-1) {\\n                    res = Math.min(res, temp[2]);\\n                    continue;\\n                }\\n                \\n                if(temp[2]>dp[i][j]) {\\n                    // This is invalid path because we have achived better which already might be running in the queue\\n                    continue;\\n                }\\n                \\n               for(int k=0;k<4;k++) {\\n                    int newI = i+dx[k], newJ = j+dy[k];\\n                   \\n                   // if newi and newj is valid and which is not increasing the cost for newi and newj which already i have achieved.\\n                    if(isValid(newI, newJ, temp[2])) {\\n                        queue.add(new int[]{newI, newJ, dp[newI][newJ]});\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085640,
                "title": "java-python-3-2-codes-shortest-path-bfs-w-brief-explanation-analysis-and-similar-problems",
                "content": "**Q & A**\\n\\nQ1: Why do we not need to keep track of which nodes we\\'ve already visited? Is this code perhaps already implicitly tracking the nodes we\\'ve visited? According to the implementation of Lazy Dijkstra [here](http://nmamano.com/blog/dijkstra/dijkstra.html), we need to keep track of which nodes we\\'ve already visited. \\nA1: The `PriorityQueue/heap` always keep track of the cell that we currently can reach with shortest path, and `grid[i][j] + o < dist[i][j]` makes sure we don\\'t need to visit the cell again if we can not reach it with less obstacles. \\nQ2: .Is it possible to optimize backtracking code with dp for this problem?\\n[@Mikey98](https://leetcode.com/Mikey98)   [@Adithya_U_Bhat](https://leetcode.com/Adithya_U_Bhat) contributed the following anwer.\\nA2: No. In this question `1 <= m, n <= 10`<sup>5</sup>, which is toooo big for backtracking; You cannot use dp here as there are 4 directions and revisiting a node again can give you minimum answer so dp fails here , remember one thing if its given 4 direction always go with graphs\\n\\n**End of Q & A**\\n\\n----\\n\\n**Method 1: Shortest Path**\\n\\n1. Initialize `dist` with `Integer.MAX_VALUE/math.inf`, and use `dist[i][j]` to indicate the currently minimum obstacles need to remove to reach `(i, j)`;\\n2. Starting from `(0, 0)`, put `[grid[0][0], 0, 0]` into a `PriorityQueue/heap` to begin to search by **Shortest Path**; Once we can reach any `(i, j)` from its neighbor with fewer obstacles, we update it with the less value and put the corresponding information array `[dist[i][j], i, j]` into `PriorityQueue/heap`, repeat till we find a path to `(m - 1, n - 1)`.\\n\\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        for (int[] di : dist) {\\n            Arrays.fill(di, Integer.MAX_VALUE);\\n        }\\n        dist[0][0] = grid[0][0];\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        pq.offer(new int[]{dist[0][0], 0,  0});\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int o = cur[0], r = cur[1], c = cur[2];\\n            if (r == m - 1 && c == n - 1) {\\n                return o;\\n            }\\n            for (int k = 0; k < 4; ++k) {\\n                int i = r + d[k], j = c + d[k + 1];\\n                if (0 <= i && i < m && 0 <= j && j < n && o + grid[i][j] < dist[i][j]) {\\n                    dist[i][j] = o + grid[i][j];\\n                    pq.offer(new int[]{dist[i][j], i, j});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n```\\n```python\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        dist = [[inf] * n for _ in range(m)]\\n        dist[0][0] = grid[0][0]\\n        hp = [(dist[0][0], 0, 0)]\\n        while hp:\\n            o, r, c = heappop(hp)\\n            if (r, c) == (m - 1, n - 1):\\n                return o\\n            for i, j in (r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1):\\n                if m > i >= 0 <= j < n and grid[i][j] + o < dist[i][j]:\\n                    dist[i][j] = grid[i][j] + o\\n                    heappush(hp, (dist[i][j], i, j))\\n```\\n\\n**Analysis:**\\n\\nTime: `O(m * n log(m * n))`, space: `O(m * n)`.\\n\\n----\\n\\n**Method 2: Modified BFS** -- credit to **@Doskarin**.\\n1. Initialize `dist` with `Integer.MAX_VALUE/math.inf`, and use `dist[i][j]` to indicate the currently minimum obstacles need to remove to reach `(i, j)`;\\n2. Starting from `(0, 0)`, put `[grid[0][0], 0, 0]` into a `Deque` to begin BFS, and use `dist` value to avoid duplicates;\\n3. **Whenever encountering an empty cell neighbor, the `dist` value is same and hence we can put it to the front of the `Deque`;**  Otherwise, put it to the back of the `Deque`;\\n4. Repeat 2. and 3. and update `dist` accordingly till the `Deque` is empty;\\n5. return `dist[m - 1][n - 1]` as solution.\\n\\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    private static final int M = Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        for (int[] di : dist) {\\n            Arrays.fill(di, M);\\n        }\\n        dist[0][0] = 0;\\n        Deque<int[]> dq = new ArrayDeque<>();\\n        dq.offer(new int[3]);\\n        while (!dq.isEmpty()) {\\n            int[] cur = dq.poll();\\n            int o = cur[0], r = cur[1], c = cur[2];\\n            for (int k = 0; k < 4; ++k) {\\n                int i = r + d[k], j = c + d[k + 1];\\n                if (0 <= i && i < m && 0 <= j && j < n && dist[i][j] == M) {\\n                    if (grid[i][j] == 1) {\\n                        dist[i][j] = o + 1;\\n                        dq.offer(new int[]{o + 1, i, j});\\n                    }else {\\n                        dist[i][j] = o;\\n                        dq.offerFirst(new int[]{o, i, j});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n```\\n```python\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        dist = [[inf] * n for _ in range(m)]\\n        dist[0][0] = 0\\n        dq = deque([(0, 0, 0)])\\n        while dq:\\n            o, r, c = dq.popleft()\\n            for i, j in (r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1):\\n                if m > i >= 0 <= j < n and dist[i][j] == inf:\\n                    if grid[i][j] == 1:\\n                        dist[i][j] = o + 1\\n                        dq.append((o + 1, i, j))\\n                    else:\\n                        dist[i][j] = o\\n                        dq.appendleft((o, i, j))    \\n        return dist[-1][-1]\\n```\\n**Analysis:**\\n\\nSince each cell is visited at most once, therefore\\n\\nTime & space: `O(m * n)`.\\n\\n----\\n\\nIn case you are NOT familiar with Bellman Ford and Dijkstra\\'s algorithm, the following links are excellent materials for you to learn:\\n\\n**Bellman Ford algorithm:**\\nhttps://algs4.cs.princeton.edu/44sp/\\nhttps://algs4.cs.princeton.edu/44sp/BellmanFordSP.java.html\\nhttps://web.stanford.edu/class/archive/cs/cs161/cs161.1168/lecture14.pdf\\nhttps://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\\nhttps://www.geeks for geeks.org/bellman-ford-algorithm-dp-23/(remove the 2 spaces among the links to make it valid)\\n\\n**Dijkstra\\'s algorithm:**\\nhttps://algs4.cs.princeton.edu/44sp/\\nhttps://algs4.cs.princeton.edu/44sp/DijkstraSP.java.html\\nhttps://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\\nhttps://www.geeks for geeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/ (remove the 2 spaces among the links to make it valid)\\n\\nSimilar problems:\\n\\n[407. Trapping Rain Water II](https://leetcode.com/problems/trapping-rain-water-ii)\\n[499. The Maze III](https://leetcode.com/problems/the-maze-iii)\\n[505. The Maze II](https://leetcode.com/problems/the-maze-ii)\\n[743. Network Delay Time](https://leetcode.com/problems/network-delay-time/)\\n[778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/description/)\\n[787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)\\n[1102. Path With Maximum Minimum Value](https://leetcode.com/problems/path-with-maximum-minimum-value) **Premium**\\n[1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/discuss/731767/JavaPython-3-2-codes%3A-Bellman-Ford-and-Dijkstra\\'s-algorithm-w-brief-explanation-and-analysis.)\\n[1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/discuss/909002/JavaPython-3-3-codes%3A-Binary-Search-Bellman-Ford-and-Dijkstra-w-brief-explanation-and-analysis.)\\n[2290. Minimum Obstacle Removal to Reach Corner](https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/discuss/2085640/JavaPython-3-Shortest-Path-w-brief-explanation-and-analysis.)",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        for (int[] di : dist) {\\n            Arrays.fill(di, Integer.MAX_VALUE);\\n        }\\n        dist[0][0] = grid[0][0];\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\\n        pq.offer(new int[]{dist[0][0], 0,  0});\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            int o = cur[0], r = cur[1], c = cur[2];\\n            if (r == m - 1 && c == n - 1) {\\n                return o;\\n            }\\n            for (int k = 0; k < 4; ++k) {\\n                int i = r + d[k], j = c + d[k + 1];\\n                if (0 <= i && i < m && 0 <= j && j < n && o + grid[i][j] < dist[i][j]) {\\n                    dist[i][j] = o + grid[i][j];\\n                    pq.offer(new int[]{dist[i][j], i, j});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n```\n```python\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        dist = [[inf] * n for _ in range(m)]\\n        dist[0][0] = grid[0][0]\\n        hp = [(dist[0][0], 0, 0)]\\n        while hp:\\n            o, r, c = heappop(hp)\\n            if (r, c) == (m - 1, n - 1):\\n                return o\\n            for i, j in (r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1):\\n                if m > i >= 0 <= j < n and grid[i][j] + o < dist[i][j]:\\n                    dist[i][j] = grid[i][j] + o\\n                    heappush(hp, (dist[i][j], i, j))\\n```\n```java\\n    private static final int[] d = {0, 1, 0, -1, 0};\\n    private static final int M = Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n];\\n        for (int[] di : dist) {\\n            Arrays.fill(di, M);\\n        }\\n        dist[0][0] = 0;\\n        Deque<int[]> dq = new ArrayDeque<>();\\n        dq.offer(new int[3]);\\n        while (!dq.isEmpty()) {\\n            int[] cur = dq.poll();\\n            int o = cur[0], r = cur[1], c = cur[2];\\n            for (int k = 0; k < 4; ++k) {\\n                int i = r + d[k], j = c + d[k + 1];\\n                if (0 <= i && i < m && 0 <= j && j < n && dist[i][j] == M) {\\n                    if (grid[i][j] == 1) {\\n                        dist[i][j] = o + 1;\\n                        dq.offer(new int[]{o + 1, i, j});\\n                    }else {\\n                        dist[i][j] = o;\\n                        dq.offerFirst(new int[]{o, i, j});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n```\n```python\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = map(len, (grid, grid[0]))\\n        dist = [[inf] * n for _ in range(m)]\\n        dist[0][0] = 0\\n        dq = deque([(0, 0, 0)])\\n        while dq:\\n            o, r, c = dq.popleft()\\n            for i, j in (r + 1, c), (r - 1, c), (r, c + 1), (r, c - 1):\\n                if m > i >= 0 <= j < n and dist[i][j] == inf:\\n                    if grid[i][j] == 1:\\n                        dist[i][j] = o + 1\\n                        dq.append((o + 1, i, j))\\n                    else:\\n                        dist[i][j] = o\\n                        dq.appendleft((o, i, j))    \\n        return dist[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2086235,
                "title": "0-1-bfs-c",
                "content": "**Solution in short :**\\nStandard 0-1 BFS.\\nUse deque and push the grid without obstacle to the front and the grid with obstacle to the end and do a normal BFS.\\n\\n**Intuition**\\nThe idea is similar to that of Djikstra. Dijkstra uses a set or priority queue because at every iteration edge with smallest cost is required. So an additional time of sorting the edges is involved at each step. Here we have a special weighted graph where every edge has a weight of either 0 or 1. In this kind of graph, Dijkstra can be further optimized to avoid sorting at every iteration.\\nFor every node that you visit, push all its **unvisited neighbours** to the queue in the following manner.\\n\\n* Every unvisited neighbour with cost 1 (having an obstacle), push to the end of the queue \\n* Every unvisited neighbour with cost 0 (having no obstacle), push to the beginning of the queue.\\n\\nBy the time you push a node to the queue, compute and store its distance in dp array.\\n\\n**I think it is enough to push any node only once in the queue using the visited flag. You can easily prove that the queue will always be sorted by the distances**\\n\\n\\n```\\nint dx[] = {1,-1,0,0};\\nint dy[] = {0,0,1,-1};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>> q;\\n        q.push_front({0,0});\\n        dp[0][0] = 0;\\n        while(q.size()) {\\n            pair<int,int> p = q.front();\\n            q.pop_front();\\n            int cx = p.first;\\n            int cy = p.second;\\n            for(int i=0;i<4;i++) {\\n                int tx = cx + dx[i];\\n                int ty = cy + dy[i];\\n                if(tx >=0 && tx < m && ty >=0 && ty < n) {                    \\n                    if(!vis[tx][ty]) {\\n                        dp[tx][ty] = dp[cx][cy] + (grid[tx][ty] == 1);\\n                        if(grid[tx][ty] == 1) {\\n                            q.push_back({tx,ty});\\n                        } else {\\n                            q.push_front({tx,ty});\\n                        }\\n                        vis[tx][ty] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nint dx[] = {1,-1,0,0};\\nint dy[] = {0,0,1,-1};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>> q;\\n        q.push_front({0,0});\\n        dp[0][0] = 0;\\n        while(q.size()) {\\n            pair<int,int> p = q.front();\\n            q.pop_front();\\n            int cx = p.first;\\n            int cy = p.second;\\n            for(int i=0;i<4;i++) {\\n                int tx = cx + dx[i];\\n                int ty = cy + dy[i];\\n                if(tx >=0 && tx < m && ty >=0 && ty < n) {                    \\n                    if(!vis[tx][ty]) {\\n                        dp[tx][ty] = dp[cx][cy] + (grid[tx][ty] == 1);\\n                        if(grid[tx][ty] == 1) {\\n                            q.push_back({tx,ty});\\n                        } else {\\n                            q.push_front({tx,ty});\\n                        }\\n                        vis[tx][ty] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088276,
                "title": "two-methods-0-1-bfs-dijkastras-algo-100-faster-resources-included",
                "content": "# **Dijkastras algo method**\\n* **When do we use dijkastras,**\\n    1. When there is a weighted graph and there are one or multiple destinations possible\\n*   **What do we do in this** \\n    1.We need to store the minimum distance between nodes \\n    2.In order to do this we use a data structure like set or a priority queue \\n*  **In questions point of view**  :-\\n1.   Consider the edge weight from a free node to obstacle node to be 1 and from free node to free node 0\\n2.   Now apply dijkastras algo\\n```\\n int m=grid.size(), n=grid[0].size();\\n        vector<int> dir={0,1,0,-1,0};\\n        vector<vector<int>> dist(m, vector<int> (n,INT_MAX));\\n        dist[0][0]=0;\\n        priority_queue<pair<int,pair<int,int>>, std::vector<pair<int,pair<int,int>>>, std::greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({0,{0,0}});\\n        while(!pq.empty())\\n        {\\n            auto v=pq.top();\\n            pq.pop();\\n            int i=v.second.first, j=v.second.second, d=v.first;\\n            for(int k=0;k<4;k++)\\n            {\\n                int x=i+dir[k], y=j+dir[k+1];\\n                if(x<0 || x>=m || y<0 || y>=n) continue;\\n                int wt;\\n                if(grid[x][y]==1)\\n                {\\n                    wt=1;\\n                }\\n                else\\n                {\\n                    wt=0;\\n                }\\n                \\n                if(d+wt<dist[x][y])\\n                {\\n                    dist[x][y]=d+wt;\\n                    pq.push({dist[x][y],{x,y}});\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];  \\n    }\\n```\\n\\t\\nThis approach gives us the answer but its time complexity is **(O(V+E)logN)**\\nExtra logN comes because of the use of Priority Queue\\n*TIME TO THINK* == > Do we really need dijkastras algo. No we don\\'t because we have only 2 different kinds of weights so we have a better and faster approach i.e 0-1 BFS.\\n\\n\\n# 0-1BFS Method\\n![image](https://assets.leetcode.com/users/images/5dfb0909-0ad5-4e16-a0c9-e331889fa4a1_1653894467.547596.png)\\n\\nLet me try to explain when we use 0-1 bfs and what are the advantages :-\\n* This is used when only two types of states/ weights are present\\n* This works using a deque so the complexity is **O(V+E)** like a normal bfs traversal\\n*   Links to refer for 0-1 BFS \\n      1. [https://cp-algorithms.com/graph/01_bfs.html](http://)\\n      2. [https://www.youtube.com/watch?v=SQOQ99stCas&list=PLauivoElc3ghxyYSr_sVnDUc_ynPk6iXE&index=14](http://)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n      int m=grid.size(), n=grid[0].size();\\n        vector<int> dir={0,1,0,-1,0};\\n        vector<vector<int>> dist(m, vector<int> (n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>>q;\\n        dist[0][0]=0;\\n        q.push_front({0,0});\\n        while(!q.empty())\\n        {\\n            auto cur=q.front();\\n            q.pop_front();\\n            int x=cur.first;\\n            int y=cur.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                int cx=x+dir[i];\\n                int cy=y+dir[i+1];\\n            if(cx>=0 and cy>=0 and cx<m and cy<n)\\n            {\\n                if(!vis[cx][cy])\\n                {\\n                    dist[cx][cy]=dist[x][y]+(grid[cx][cy]==1);\\n                    if(grid[cx][cy]==1)\\n                        q.push_back({cx,cy});//obstacle cell pushed at the end\\n                    else\\n                    q.push_front({cx,cy}); //empty cell pushed on top\\n                    vis[cx][cy] = true;\\n                }\\n            }\\n        }\\n    }\\n        return dist[m-1][n-1];\\n    }\\n};\\n```\\n\\nPlease do upvote if this helps!!!!",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n int m=grid.size(), n=grid[0].size();\\n        vector<int> dir={0,1,0,-1,0};\\n        vector<vector<int>> dist(m, vector<int> (n,INT_MAX));\\n        dist[0][0]=0;\\n        priority_queue<pair<int,pair<int,int>>, std::vector<pair<int,pair<int,int>>>, std::greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({0,{0,0}});\\n        while(!pq.empty())\\n        {\\n            auto v=pq.top();\\n            pq.pop();\\n            int i=v.second.first, j=v.second.second, d=v.first;\\n            for(int k=0;k<4;k++)\\n            {\\n                int x=i+dir[k], y=j+dir[k+1];\\n                if(x<0 || x>=m || y<0 || y>=n) continue;\\n                int wt;\\n                if(grid[x][y]==1)\\n                {\\n                    wt=1;\\n                }\\n                else\\n                {\\n                    wt=0;\\n                }\\n                \\n                if(d+wt<dist[x][y])\\n                {\\n                    dist[x][y]=d+wt;\\n                    pq.push({dist[x][y],{x,y}});\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];  \\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n      int m=grid.size(), n=grid[0].size();\\n        vector<int> dir={0,1,0,-1,0};\\n        vector<vector<int>> dist(m, vector<int> (n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>>q;\\n        dist[0][0]=0;\\n        q.push_front({0,0});\\n        while(!q.empty())\\n        {\\n            auto cur=q.front();\\n            q.pop_front();\\n            int x=cur.first;\\n            int y=cur.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                int cx=x+dir[i];\\n                int cy=y+dir[i+1];\\n            if(cx>=0 and cy>=0 and cx<m and cy<n)\\n            {\\n                if(!vis[cx][cy])\\n                {\\n                    dist[cx][cy]=dist[x][y]+(grid[cx][cy]==1);\\n                    if(grid[cx][cy]==1)\\n                        q.push_back({cx,cy});//obstacle cell pushed at the end\\n                    else\\n                    q.push_front({cx,cy}); //empty cell pushed on top\\n                    vis[cx][cy] = true;\\n                }\\n            }\\n        }\\n    }\\n        return dist[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086338,
                "title": "python-0-1-bfs",
                "content": "Classic 0-1 BFS implementation with a little caveat : we need to process elements in the queue with less obstacles first. This will make sure our destination will have the smallest obstacles removed.\\n\\nTime Complexity : ```O(R * C)``` - each cell in the grid is processed once as we traverse\\nSpace Complexity : ```O(R * C)``` - we need 2D helper array \"distance\" in order to record shortest obstacles removed for each cell\\n\\nCode\\n```\\nclass Solution(object):\\n    def minimumObstacles(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        R, C = len(grid), len(grid[0])\\n        \\n        d = [(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        distances = [[-1] * C for _ in range(R)]\\n        \\n        q = deque([(0, 0, 0)])\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                dist, r, c = q.popleft()\\n                \\n                for dr, dc in d:\\n                    rr, cc = r + dr, c + dc\\n\\t\\t\\t\\t\\t#Check if the cell is inbounds and has not been visited before\\n                    if 0 <= rr < R and 0 <= cc < C and distances[rr][cc] == -1:\\n                        \\n                        #If the cell is an obstacle - assign current distance + 1 to its value\\n\\t\\t\\t\\t\\t\\tif grid[rr][cc] == 1:\\n                            distances[rr][cc] = dist + 1\\n                            q.append((dist + 1, rr, cc))\\n                            \\n                        else:\\n                            #Make sure we process cells with less obstacles first hence appendleft\\n                            distances[rr][cc] = dist\\n                            q.appendleft((dist, rr, cc))\\n                            \\n        return distances[R - 1][C - 1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```O(R * C)```\n```O(R * C)```\n```\\nclass Solution(object):\\n    def minimumObstacles(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        R, C = len(grid), len(grid[0])\\n        \\n        d = [(1,0),(-1,0),(0,1),(0,-1)]\\n        \\n        distances = [[-1] * C for _ in range(R)]\\n        \\n        q = deque([(0, 0, 0)])\\n        \\n        while q:\\n            for _ in range(len(q)):\\n                dist, r, c = q.popleft()\\n                \\n                for dr, dc in d:\\n                    rr, cc = r + dr, c + dc\\n\\t\\t\\t\\t\\t#Check if the cell is inbounds and has not been visited before\\n                    if 0 <= rr < R and 0 <= cc < C and distances[rr][cc] == -1:\\n                        \\n                        #If the cell is an obstacle - assign current distance + 1 to its value\\n\\t\\t\\t\\t\\t\\tif grid[rr][cc] == 1:\\n                            distances[rr][cc] = dist + 1\\n                            q.append((dist + 1, rr, cc))\\n                            \\n                        else:\\n                            #Make sure we process cells with less obstacles first hence appendleft\\n                            distances[rr][cc] = dist\\n                            q.appendleft((dist, rr, cc))\\n                            \\n        return distances[R - 1][C - 1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085755,
                "title": "c-djkstra",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, 1e5 + 1));\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\\n        \\n        pq.push({grid[0][0], 0, 0});\\n        int dirs[4][2] = {{0, 1},{-1, 0},{1, 0},{0, -1}};\\n        while (!pq.empty()) {\\n            auto [c, i, j] = pq.top();\\n            pq.pop();\\n            \\n            if (i == n - 1 && j == m - 1) {\\n                return c;\\n            }\\n            \\n            for (auto &d: dirs) {\\n                int x = d[0] + i;\\n                int y = d[1] + j;\\n                \\n                if (x < 0 || y < 0 || x >= n || y >= m)\\n                    continue;\\n                \\n                if (dp[x][y] > grid[x][y] + c) {\\n                    dp[x][y] = grid[x][y] + c;\\n                    pq.push({grid[x][y] + c, x, y});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, 1e5 + 1));\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> pq;\\n        \\n        pq.push({grid[0][0], 0, 0});\\n        int dirs[4][2] = {{0, 1},{-1, 0},{1, 0},{0, -1}};\\n        while (!pq.empty()) {\\n            auto [c, i, j] = pq.top();\\n            pq.pop();\\n            \\n            if (i == n - 1 && j == m - 1) {\\n                return c;\\n            }\\n            \\n            for (auto &d: dirs) {\\n                int x = d[0] + i;\\n                int y = d[1] + j;\\n                \\n                if (x < 0 || y < 0 || x >= n || y >= m)\\n                    continue;\\n                \\n                if (dp[x][y] > grid[x][y] + c) {\\n                    dp[x][y] = grid[x][y] + c;\\n                    pq.push({grid[x][y] + c, x, y});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111406,
                "title": "minesweeper",
                "content": "I initially solved this problem using Djikstra (see the second approach below), though I find DFS approach more interesting (and it\\u2019s faster).\\n\\n#### Minesweeper\\nThis is a modified BFS, which reminds me of the Minesweeper game. We explore all empty cells, till we hit a wall of obstacles. We remove that wall, and explore new areas of empty cells. We repeat until we reach the destination, and the result is the number of walls we removed.\\n\\n![image](https://assets.leetcode.com/users/images/25ec20b1-b9ff-4718-811c-5866513728e5_1654415206.5237103.png)\\n\\n**C++**\\nWe can use a single deque, pushing empty cells to the front, and obstacles to the back. Instead, we use two queues in the code below - I think it may be a bit easier for me to understand the algorithm. \\n```cpp\\npair<int, int> dirs[4] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nint minimumObstacles(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), res = 0;\\n    deque<array<int, 2>> emp{{0, 0}}, obs;\\n    while (!emp.empty() || !obs.empty()) {\\n        if (emp.empty()) {\\n            ++res;\\n            swap(emp, obs);                \\n        }\\n        const auto [i, j] = emp.front(); emp.pop_front();\\n        if (i == m - 1 && j == n - 1)\\n            break;\\n        for (const auto [dx, dy] : dirs) {\\n            int x = i + dx, y = j + dy;\\n            if (min(x, y) >= 0 && x < m && y < n && g[x][y] >= 0) {\\n                if (g[x][y])\\n                    obs.push_back({x, y});\\n                else\\n                    emp.push_back({x, y});\\n                g[x][y] = -1;\\n            }\\n        } \\n    }\\n    return res;\\n}\\n```\\n\\n#### Djikstra\\nA shortest path here is the one with the least number of obstacles.\\n\\n**C++**\\n```cpp\\nvector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nint minimumObstacles(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> vis(m, vector<int>(n, INT_MIN));\\n    priority_queue<array<int, 3>> pq;\\n    pq.push({0, 0, 0});\\n    vis[0][0] = 0;\\n    while (!pq.empty() && (pq.top()[1] != m - 1 || pq.top()[2] != n - 1)) {\\n        auto [obs, i, j] = pq.top(); pq.pop();\\n        if (obs > vis[i][j])\\n            continue;\\n        for (auto [dx, dy] : dirs) {\\n            int x = i + dx, y = j + dy;\\n            if (min(x, y) >= 0 && x < m && y < n)\\n                if (vis[x][y] < obs - g[x][y]) {\\n                    vis[x][y] = obs - g[x][y];\\n                    pq.push({obs - g[x][y], x, y});\\n                }\\n        }\\n    }\\n    return -vis[m - 1][n - 1];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\npair<int, int> dirs[4] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nint minimumObstacles(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size(), res = 0;\\n    deque<array<int, 2>> emp{{0, 0}}, obs;\\n    while (!emp.empty() || !obs.empty()) {\\n        if (emp.empty()) {\\n            ++res;\\n            swap(emp, obs);                \\n        }\\n        const auto [i, j] = emp.front(); emp.pop_front();\\n        if (i == m - 1 && j == n - 1)\\n            break;\\n        for (const auto [dx, dy] : dirs) {\\n            int x = i + dx, y = j + dy;\\n            if (min(x, y) >= 0 && x < m && y < n && g[x][y] >= 0) {\\n                if (g[x][y])\\n                    obs.push_back({x, y});\\n                else\\n                    emp.push_back({x, y});\\n                g[x][y] = -1;\\n            }\\n        } \\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<pair<int, int>> dirs{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\nint minimumObstacles(vector<vector<int>>& g) {\\n    int m = g.size(), n = g[0].size();\\n    vector<vector<int>> vis(m, vector<int>(n, INT_MIN));\\n    priority_queue<array<int, 3>> pq;\\n    pq.push({0, 0, 0});\\n    vis[0][0] = 0;\\n    while (!pq.empty() && (pq.top()[1] != m - 1 || pq.top()[2] != n - 1)) {\\n        auto [obs, i, j] = pq.top(); pq.pop();\\n        if (obs > vis[i][j])\\n            continue;\\n        for (auto [dx, dy] : dirs) {\\n            int x = i + dx, y = j + dy;\\n            if (min(x, y) >= 0 && x < m && y < n)\\n                if (vis[x][y] < obs - g[x][y]) {\\n                    vis[x][y] = obs - g[x][y];\\n                    pq.push({obs - g[x][y], x, y});\\n                }\\n        }\\n    }\\n    return -vis[m - 1][n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086396,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& mat) {\\n         vector<pair<int,int>>d={{-1,0},{0,1},{1,0},{0,-1}};\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        dp[0][0]=0;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                int x=temp.first;\\n                int y=temp.second;\\n                for(auto it:d)\\n                {\\n                    int nx=x+it.first;\\n                    int ny=y+it.second;\\n                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&dp[x][y]+mat[nx][ny]<dp[nx][ny])\\n                    {\\n                        dp[nx][ny]=dp[x][y]+mat[nx][ny];\\n                         q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n                \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& mat) {\\n         vector<pair<int,int>>d={{-1,0},{0,1},{1,0},{0,-1}};\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        dp[0][0]=0;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                int x=temp.first;\\n                int y=temp.second;\\n                for(auto it:d)\\n                {\\n                    int nx=x+it.first;\\n                    int ny=y+it.second;\\n                    if(nx>=0&&ny>=0&&nx<n&&ny<m&&dp[x][y]+mat[nx][ny]<dp[nx][ny])\\n                    {\\n                        dp[nx][ny]=dp[x][y]+mat[nx][ny];\\n                         q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086516,
                "title": "java-c-o-mn-86ms-explained-updated-on-09-08-22",
                "content": "> **Update on 09/08/2022: C++ BFS solution added**\\n> \\n#### Foreword\\nI saw a lot of solutions with `O(MN*log(MN))`, but we can do better than that. \\nHere I am providing 2 solutions. I think solution 2 may be more straightforward.\\nBoth solutions run in `O(MN)`.\\n\\n#### Solution 1 (Java) - BFS + DFS\\nLet\\'s slowly expand the reachable areas with BFS eliminating walls and then explore with DFS.\\n\\n- Perform a BFS with each BFS layer with a counter (num of elimination required).\\n\\n- Within each BFS, we perform a DFS from each cell in the BFS queue.\\n- Within each DFS, we explore all the cells and enqueue all the walls we can reach back into the BFS queue.\\n- If we are able to reach the end and it is not a wall, we return the current counter.\\n- If not, then we do BFS again and destroy all the walls enqueued in step 1 by marking it as 0\\n- Remember to mark all the cells we\\'ve visited as seen to avoid infinite loop.\\n\\nThe time complexity of this BFS + DFS approach is O(MN) because each cell is only explored at most 2 times. \\n`Time O(MN)`\\n`Space O(MN)`\\n```Java\\nclass Solution {\\n    int m, n;\\n    public int minimumObstacles(int[][] grid) {\\n        m = grid.length; n = grid[0].length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{0, 0});\\n        for (int i = 0; ; i++){ // i = num of elimination required.\\n            for (int j = queue.size(); j > 0; j--){\\n                int[] p = queue.poll();\\n                grid[p[0]][p[1]] = 0; // eliminate this wall, mark it as 0\\n                if (explore(p[0], p[1], grid, queue))\\n                    return i;\\n            }\\n        }\\n    }\\n\\n    private boolean explore(int i, int j, int[][] grid, Queue<int[]> queue){\\n        if (i < 0 || j < 0 || i == m || j == n || grid[i][j] < 0)\\n            return false;\\n        if (grid[i][j] == 1){\\n            grid[i][j] = -1; // mark as seen so it doesn\\'t get enqueued again\\n            queue.add(new int[]{i, j});\\n            return false;\\n        }\\n        if (i+j == n+m-2)\\n            return true;\\n        grid[i][j] = -1;\\n        return explore(i + 1, j, grid, queue)\\n            || explore(i - 1, j, grid, queue)\\n            || explore(i, j + 1, grid, queue)\\n            || explore(i, j - 1, grid, queue);\\n    }\\n}\\n```\\n\\n#### Solution 2 (C++) - BFS\\nI was reviewing problem and now I found it more straight forward to just do BFS. \\nI have since switched from being a Java user to C++, hence the below.\\n\\nThe idea is more or less the same, but this time we mark it inside BFS. \\nMore details can be found in the comments below.\\n\\n`Time O(MN)`\\n`Space O(MN)`\\n```C++\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = size(grid), n = size(grid[0]);\\n        queue<pair<int,int>> q, nq;\\n        vector<vector<bool>> seen(m, vector<bool>(n));\\n        seen[0][0] = 1;\\n        q.push({0, 0});\\n        int dx[4]{0, 0, -1, 1};\\n        int dy[4]{1, -1, 0, 0};\\n        for (int i = 0; ;++i){\\n            while(!q.empty()){ // q is the current queue\\n                auto [x, y] = q.front();\\n                if (x+y==m+n-2){\\n                    return i;\\n                }\\n                q.pop();\\n                for (int k = 0; k < 4; ++k){ // explore all 4 directions\\n                    int nx = x + dx[k];\\n                    int ny = y + dy[k];\\n                    if (nx < 0 || ny < 0 || nx == m || ny == n || seen[nx][ny]){\\n                        continue;\\n                    }\\n                    if (grid[nx][ny]){ // if it is an obstacle, put it in for the next queue\\n                        nq.push({nx, ny});\\n                    }else{ // otherwise it is for the current queue\\n                        q.push({nx, ny});\\n                    }\\n                    seen[nx][ny] = 1; // mark it seen in both cases\\n                }\\n            }\\n            swap(q, nq);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```Java\\nclass Solution {\\n    int m, n;\\n    public int minimumObstacles(int[][] grid) {\\n        m = grid.length; n = grid[0].length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{0, 0});\\n        for (int i = 0; ; i++){ // i = num of elimination required.\\n            for (int j = queue.size(); j > 0; j--){\\n                int[] p = queue.poll();\\n                grid[p[0]][p[1]] = 0; // eliminate this wall, mark it as 0\\n                if (explore(p[0], p[1], grid, queue))\\n                    return i;\\n            }\\n        }\\n    }\\n\\n    private boolean explore(int i, int j, int[][] grid, Queue<int[]> queue){\\n        if (i < 0 || j < 0 || i == m || j == n || grid[i][j] < 0)\\n            return false;\\n        if (grid[i][j] == 1){\\n            grid[i][j] = -1; // mark as seen so it doesn\\'t get enqueued again\\n            queue.add(new int[]{i, j});\\n            return false;\\n        }\\n        if (i+j == n+m-2)\\n            return true;\\n        grid[i][j] = -1;\\n        return explore(i + 1, j, grid, queue)\\n            || explore(i - 1, j, grid, queue)\\n            || explore(i, j + 1, grid, queue)\\n            || explore(i, j - 1, grid, queue);\\n    }\\n}\\n```\n```C++\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = size(grid), n = size(grid[0]);\\n        queue<pair<int,int>> q, nq;\\n        vector<vector<bool>> seen(m, vector<bool>(n));\\n        seen[0][0] = 1;\\n        q.push({0, 0});\\n        int dx[4]{0, 0, -1, 1};\\n        int dy[4]{1, -1, 0, 0};\\n        for (int i = 0; ;++i){\\n            while(!q.empty()){ // q is the current queue\\n                auto [x, y] = q.front();\\n                if (x+y==m+n-2){\\n                    return i;\\n                }\\n                q.pop();\\n                for (int k = 0; k < 4; ++k){ // explore all 4 directions\\n                    int nx = x + dx[k];\\n                    int ny = y + dy[k];\\n                    if (nx < 0 || ny < 0 || nx == m || ny == n || seen[nx][ny]){\\n                        continue;\\n                    }\\n                    if (grid[nx][ny]){ // if it is an obstacle, put it in for the next queue\\n                        nq.push({nx, ny});\\n                    }else{ // otherwise it is for the current queue\\n                        q.push({nx, ny});\\n                    }\\n                    seen[nx][ny] = 1; // mark it seen in both cases\\n                }\\n            }\\n            swap(q, nq);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085913,
                "title": "why-tle-in-queue-vector-int-st",
                "content": "I had used **queue<vector< int>> st**, in contest, in the same code below, and it was not accepted and giving TLE, but if i am using **queue<pair<int,int>> st**, it is getting accepted. Why???\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> v;\\n    int n,m;\\n    vector<int> dx={-1,0,1,0};\\n    vector<int> dy={0,1,0,-1};\\n    void bfs(vector<vector<int>>& g){\\n        queue<pair<int,int>> st;\\n        v=vector<vector<int>>(n,vector<int>(m,INT_MAX));\\n        st.push({0,0});\\n        v[0][0]=0;\\n        while(!st.empty()){\\n            auto it=(st.front());\\n            st.pop();\\n            int i=it.first;\\n            int j=it.second;\\n            for(int z=0;z<4;z++){\\n                int x=i+dx[z];\\n                int y=j+dy[z];\\n                if(x<0||y<0||x>=n||y>=m||v[i][j]+g[x][y]>=v[x][y]) continue;\\n                v[x][y]=v[i][j]+g[x][y];\\n                st.push({x,y});\\n            }\\n        }\\n        return ;\\n    }\\n    int minimumObstacles(vector<vector<int>>& g) {\\n        n=g.size(),m=g[0].size();\\n        bfs(g);\\n        return v[n-1][m-1]; \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> v;\\n    int n,m;\\n    vector<int> dx={-1,0,1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2085733,
                "title": "java-a-very-simple-o-mn-bfs-solution-with-explanation-by-drying-run-examples",
                "content": "Please help to upvote if the post is helpful to you, it will help this post to go to top and more people can read it. Thank you.\\n\\nThe idea is that we will move to next obstacle cells in each step.\\n\\n**Dry run Example 1:**\\n![image](https://assets.leetcode.com/uploads/2022/04/06/example1drawio-1.png)\\nStep 0: states = [[0, 0]] // all empty cells can be reached from [0, 0]\\nStep 1: states = [[0, 1], [1, 0]] // all obstacle neighbors can be reached from Step 0\\nStep 2: states = [[2, 0], [1, 1], [0, 2]] // all obstacle neighbors can be reached from Step 1\\nNow, we can reach target cell from [1, 1] or [0, 2], so 2 will be the result (need to remove 1 cell in Step 1 and 1 cell in Step 2).\\n\\n**Dry run Example 2:**\\n![image](https://assets.leetcode.com/uploads/2022/04/06/example1drawio.png)\\nStep 0: states = [[0, 0], [1, 0], [2, 0], [2, 1], [2, 2], [1, 2], [0, 2], [0, 3], [0, 4],  [1, 4], [2, 4]] // all empty cells can be reached from [0, 0]\\nWe can reach target from step 0, so 0 will be the result\\n\\nHere\\'s the detail implementation\\n\\n```\\nclass Solution {\\n    \\n    int[] d = {-1, 0, 1, 0, -1};\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\t\\tQueue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        grid[0][0] = -1; // [0, 0]  was visited\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n\\t\\t\\tQueue<int[]> q2 = new LinkedList<>(); // q2 will store obstacle cells can be reached from q\\n            while (!q.isEmpty()) {\\n                int[] node = q.poll();\\n                if (node[0] == m - 1 && node[1] == n - 1) {\\n                    return step;\\n                }\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = node[0] + d[k];\\n                    int y = node[1] + d[k+1];\\n                    if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != -1) {\\n                        if (grid[x][y] == 0) {\\n                            q.add(new int[]{x, y});\\n                        } else { // grid[x][y] == 1 (obstacle)\\n                            q2.add(new int[]{x, y});\\n                        }\\n                        grid[x][y] = -1; // [x, y]  was visited\\n                    }\\n                }\\n            }\\n            q = q2;\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nTime complexity: O(mn)\\nSpace complexity: O(mn)",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] d = {-1, 0, 1, 0, -1};\\n    \\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\t\\tQueue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        grid[0][0] = -1; // [0, 0]  was visited\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n\\t\\t\\tQueue<int[]> q2 = new LinkedList<>(); // q2 will store obstacle cells can be reached from q\\n            while (!q.isEmpty()) {\\n                int[] node = q.poll();\\n                if (node[0] == m - 1 && node[1] == n - 1) {\\n                    return step;\\n                }\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = node[0] + d[k];\\n                    int y = node[1] + d[k+1];\\n                    if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] != -1) {\\n                        if (grid[x][y] == 0) {\\n                            q.add(new int[]{x, y});\\n                        } else { // grid[x][y] == 1 (obstacle)\\n                            q2.add(new int[]{x, y});\\n                        }\\n                        grid[x][y] = -1; // [x, y]  was visited\\n                    }\\n                }\\n            }\\n            q = q2;\\n            step++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085671,
                "title": "dijkstra-s-algo-java",
                "content": "```\\npublic int minimumObstacles(int[][] grid) {\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        int[][] dir = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int m = grid.length, n = grid[0].length;\\n        int[][] count = new int[m][n];\\n        for(int i = 0;i < m;i++) {\\n            Arrays.fill(count[i], Integer.MAX_VALUE);\\n        }\\n        count[0][0] = 0;\\n        q.offer(new int[]{0, 0, 0});\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0];\\n            int y = cur[1];\\n            int cost = cur[2];\\n            if(x == m - 1 && y == n - 1) {\\n                return cost;\\n            }\\n            for(int i = 0;i < 4;i++) {\\n                int nx = x + dir[i][0];\\n                int ny = y + dir[i][1];\\n                if(nx < 0 || ny < 0 || nx >= m || ny >= n) {\\n                    continue;\\n                }\\n                int now = cur[2];\\n                if(grid[nx][ny] == 1) {\\n                    now++;\\n                }\\n                if(now >= count[nx][ny]) {\\n                    continue;\\n                }\\n                \\n                count[nx][ny] = now;\\n                q.offer(new int[] {nx, ny, now});\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minimumObstacles(int[][] grid) {\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        int[][] dir = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int m = grid.length, n = grid[0].length;\\n        int[][] count = new int[m][n];\\n        for(int i = 0;i < m;i++) {\\n            Arrays.fill(count[i], Integer.MAX_VALUE);\\n        }\\n        count[0][0] = 0;\\n        q.offer(new int[]{0, 0, 0});\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int x = cur[0];\\n            int y = cur[1];\\n            int cost = cur[2];\\n            if(x == m - 1 && y == n - 1) {\\n                return cost;\\n            }\\n            for(int i = 0;i < 4;i++) {\\n                int nx = x + dir[i][0];\\n                int ny = y + dir[i][1];\\n                if(nx < 0 || ny < 0 || nx >= m || ny >= n) {\\n                    continue;\\n                }\\n                int now = cur[2];\\n                if(grid[nx][ny] == 1) {\\n                    now++;\\n                }\\n                if(now >= count[nx][ny]) {\\n                    continue;\\n                }\\n                \\n                count[nx][ny] = now;\\n                q.offer(new int[] {nx, ny, now});\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086607,
                "title": "python-easy-to-understand-dijkstra",
                "content": "Perhaps there can be slightly more efficient solutions, however i think this solution is very simple to understand and easy to implement.\\n\\nq - min heap which uses the number of obstacles so far as a key.\\ndist - array of shortest path distances to each cell.\\nobs - minimum number of obstacles we had to pass in order to get to the currect cell.\\n\\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        q = [(0, 0, 0)]\\n        dist = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                obs, x, y = heapq.heappop(q)\\n                if dist[x][y] < float(\\'inf\\'): continue\\n                obs += grid[x][y]\\n                dist[x][y] = obs\\n                if x + 1 < m: heapq.heappush(q, (obs, x + 1, y))\\n                if x > 0: heapq.heappush(q, (obs, x - 1, y))\\n                if y + 1 < n: heapq.heappush(q, (obs, x, y + 1))\\n                if y > 0: heapq.heappush(q, (obs, x, y - 1))\\n        return dist[m - 1][n - 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        q = [(0, 0, 0)]\\n        dist = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                obs, x, y = heapq.heappop(q)\\n                if dist[x][y] < float(\\'inf\\'): continue\\n                obs += grid[x][y]\\n                dist[x][y] = obs\\n                if x + 1 < m: heapq.heappush(q, (obs, x + 1, y))\\n                if x > 0: heapq.heappush(q, (obs, x - 1, y))\\n                if y + 1 < n: heapq.heappush(q, (obs, x, y + 1))\\n                if y > 0: heapq.heappush(q, (obs, x, y - 1))\\n        return dist[m - 1][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086125,
                "title": "solution-using-0-1-bfs",
                "content": "```\\nconst int dx[4]={0, 0, 1, -1};\\nconst int dy[4]={1, -1, 0, 0};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>> dist(n+1, vector<int>(m+1, 1e9));\\n        dist[0][0]=0;\\n        \\n        deque<pair<int, int>> qq;\\n        qq.push_front({0, 0});\\n        \\n        \\n        while(!qq.empty())\\n        {\\n            auto [x, y]=qq.front();\\n            qq.pop_front();\\n            \\n            for(int k=0; k<4; k++)\\n            {\\n                int xx=x+dx[k];\\n                int yy=y+dy[k];\\n                \\n                if(xx>=0 && yy>=0 && xx<n && yy<m && dist[xx][yy]>dist[x][y]+grid[xx][yy])\\n                {\\n                    dist[xx][yy]=dist[x][y]+grid[xx][yy];\\n                    if(grid[xx][yy])\\n                        qq.push_back({xx, yy});\\n                    else\\n                        qq.push_front({xx, yy});\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nconst int dx[4]={0, 0, 1, -1};\\nconst int dy[4]={1, -1, 0, 0};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>> dist(n+1, vector<int>(m+1, 1e9));\\n        dist[0][0]=0;\\n        \\n        deque<pair<int, int>> qq;\\n        qq.push_front({0, 0});\\n        \\n        \\n        while(!qq.empty())\\n        {\\n            auto [x, y]=qq.front();\\n            qq.pop_front();\\n            \\n            for(int k=0; k<4; k++)\\n            {\\n                int xx=x+dx[k];\\n                int yy=y+dy[k];\\n                \\n                if(xx>=0 && yy>=0 && xx<n && yy<m && dist[xx][yy]>dist[x][y]+grid[xx][yy])\\n                {\\n                    dist[xx][yy]=dist[x][y]+grid[xx][yy];\\n                    if(grid[xx][yy])\\n                        qq.push_back({xx, yy});\\n                    else\\n                        qq.push_front({xx, yy});\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097032,
                "title": "c-dfs-dijkstra-s-algorithm-without-priority-queue-vector-queue",
                "content": "Runtime: 894 ms, faster than 74.67% of C++ online submissions for Minimum Obstacle Removal to Reach Corner.\\nMemory Usage: 104.2 MB, less than 60.23% of C++ online submissions for Minimum Obstacle Removal to Reach Corner.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<vector<int >> dp(m + 1, vector<int>(n + 1, 10000001));\\n        queue<pair<int,int >> q;\\n        q.push({0, 0});\\n        \\n        dp[0][0] = 0;\\n        \\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, -1, 1};\\n        while(!q.empty()){\\n            auto curr = q.front(); q.pop();\\n            for(int i = 0; i < 4; i++){\\n                int x = dx[i] + curr.first, y = dy[i] + curr.second;\\n                \\n                if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] + dp[curr.first][curr.second] < dp[x][y]){\\n                    dp[x][y] = grid[x][y] + dp[curr.first][curr.second];\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```\\n\\nplease hit like. Thanks.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        vector<vector<int >> dp(m + 1, vector<int>(n + 1, 10000001));\\n        queue<pair<int,int >> q;\\n        q.push({0, 0});\\n        \\n        dp[0][0] = 0;\\n        \\n        int dx[] = {-1, 1, 0, 0};\\n        int dy[] = {0, 0, -1, 1};\\n        while(!q.empty()){\\n            auto curr = q.front(); q.pop();\\n            for(int i = 0; i < 4; i++){\\n                int x = dx[i] + curr.first, y = dy[i] + curr.second;\\n                \\n                if(x >= 0 && y >= 0 && x < m && y < n && grid[x][y] + dp[curr.first][curr.second] < dp[x][y]){\\n                    dp[x][y] = grid[x][y] + dp[curr.first][curr.second];\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        \\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086669,
                "title": "bfs-solution-using-multiset-c",
                "content": "**Hello guys,**\\nthis is a very simple explanation for `Minimum Obstacle Removal to Reach Corner` problem.\\n\\ninsert a[0][0] in multiset initially\\nnow get ms.begin(), it will give shortest distance path till now,\\n`pair<int,pair<int,int>>p=*ms.begin();`\\n`int x=p.second.first, y=p.second.second;` // current node\\'s position\\n\\nlet check for further path in all possible 4 directions means means (x-1,y), (x+1,y), (x,y-1) & (x,y+1)\\nand check if neighbour nodes are unvisited and theirs distance are greater `dis[x][y]+a[x][y]`\\n\\n**Here** `dis[x][y]` gives minimum number of Obstacle removal to reach (i,j)\\n\\n**for eg.**\\nwe are checking node (x-1,y) then,\\n```\\nif(x-1>=0 && vis[x-1][y]==0) { \\n\\tif(dis[x-1][y]>dis[x][y]+a[x][y]) // check if dis is greater\\n\\t{\\n\\t\\tdis[x-1][y]=dis[x][y]+a[x][y]; // update distance\\n\\t\\tms.insert({dis[x-1][y], {x-1,y}});\\n\\t}\\n}\\n```\\nwe get minimum number of Obstacle removal count in `dis[n-1][m-1]`\\n\\n**Code:**\\n\\n```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& a) {\\n        \\n        int n=a.size(), m=a[0].size();\\n        int node=n*m;\\n        \\n        int vis[n+1][m+1];\\n        memset(vis, 0, sizeof(vis));\\n        \\n        int dis[n+1][m+1];\\n        for(int i=0;i<=n;++i) for(int j=0;j<=m;++j) dis[i][j]=1e7;\\n        dis[0][0]=a[0][0];\\n        \\n        multiset<pair<int,pair<int,int>>>ms;\\n        ms.insert({dis[0][0],{0,0}});\\n        \\n        while(ms.size())\\n        {\\n            pair<int,pair<int,int>>p=*ms.begin();\\n            ms.erase(ms.begin());\\n            \\n            int d=p.first;\\n            int x=p.second.first, y=p.second.second;\\n            if(vis[x][y]) continue;\\n            vis[x][y]=1;\\n            \\n            if(x-1>=0 && vis[x-1][y]==0) {\\n                if(dis[x-1][y]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x-1][y]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x-1][y], {x-1,y}});\\n                }\\n            }\\n            if(x+1<n && vis[x+1][y]==0) {\\n                if(dis[x+1][y]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x+1][y]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x+1][y], {x+1,y}});\\n                }\\n            }\\n            if(y-1>=0 && vis[x][y-1]==0) {\\n                if(dis[x][y-1]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x][y-1]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x][y-1], {x,y-1}});\\n                }\\n            }\\n            if(y+1<m && vis[x][y+1]==0) {\\n                if(dis[x][y+1]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x][y+1]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x][y+1], {x,y+1}});\\n                }\\n            }\\n        }\\n        \\n        return dis[n-1][m-1];\\n        \\n    }\\n};\\n```\\n\\nThanks...",
                "solutionTags": [
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nif(x-1>=0 && vis[x-1][y]==0) { \\n\\tif(dis[x-1][y]>dis[x][y]+a[x][y]) // check if dis is greater\\n\\t{\\n\\t\\tdis[x-1][y]=dis[x][y]+a[x][y]; // update distance\\n\\t\\tms.insert({dis[x-1][y], {x-1,y}});\\n\\t}\\n}\\n```\n```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& a) {\\n        \\n        int n=a.size(), m=a[0].size();\\n        int node=n*m;\\n        \\n        int vis[n+1][m+1];\\n        memset(vis, 0, sizeof(vis));\\n        \\n        int dis[n+1][m+1];\\n        for(int i=0;i<=n;++i) for(int j=0;j<=m;++j) dis[i][j]=1e7;\\n        dis[0][0]=a[0][0];\\n        \\n        multiset<pair<int,pair<int,int>>>ms;\\n        ms.insert({dis[0][0],{0,0}});\\n        \\n        while(ms.size())\\n        {\\n            pair<int,pair<int,int>>p=*ms.begin();\\n            ms.erase(ms.begin());\\n            \\n            int d=p.first;\\n            int x=p.second.first, y=p.second.second;\\n            if(vis[x][y]) continue;\\n            vis[x][y]=1;\\n            \\n            if(x-1>=0 && vis[x-1][y]==0) {\\n                if(dis[x-1][y]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x-1][y]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x-1][y], {x-1,y}});\\n                }\\n            }\\n            if(x+1<n && vis[x+1][y]==0) {\\n                if(dis[x+1][y]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x+1][y]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x+1][y], {x+1,y}});\\n                }\\n            }\\n            if(y-1>=0 && vis[x][y-1]==0) {\\n                if(dis[x][y-1]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x][y-1]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x][y-1], {x,y-1}});\\n                }\\n            }\\n            if(y+1<m && vis[x][y+1]==0) {\\n                if(dis[x][y+1]>dis[x][y]+a[x][y])\\n                {\\n                    dis[x][y+1]=dis[x][y]+a[x][y];\\n                    ms.insert({dis[x][y+1], {x,y+1}});\\n                }\\n            }\\n        }\\n        \\n        return dis[n-1][m-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085938,
                "title": "why-dp-fails-explanation-and-dijkstra-s-algo-bfs-solution",
                "content": "This question was asked to me in Hackwithinfy 2022 1st round \\nIf it was given two direction we could always go with DP (graph also works) , but since its given 4 directions dp fails  , graph saves\\n\\nOne of the example where DP fails :\\n\\n0 1 0 0\\n0 0 0 0\\n1 1 1 0\\n\\nBecause here u revisit some states number of times as first visit might not give minimum answer ( but if u use DP u wont be allowed to visit again because u memoize it during first visit only ) \\n\\nBFS based implementation : \\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        vector<vector<bool>> vis(n+1,vector<bool>(m+1,false));\\n        int cnt = 0;\\n        if(grid[0][0]==1){\\n            cnt++;\\n        }\\n        \\n        pq.push({cnt,{0,0}});\\n        vis[0][0]=true;\\n        vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n        while(pq.empty()==false){\\n            long long x = pq.top().second.first;\\n            long long y = pq.top().second.second;\\n            long long dist = pq.top().first;\\n            pq.pop();\\n            if(x==n-1 && y==m-1){\\n                return dist;\\n            }\\n            for(auto &mov : dir){\\n                long long newx = x + mov[0];\\n                long long newy = y + mov[1];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && vis[newx][newy]==false){\\n                    if(grid[newx][newy]==0){\\n                        pq.push({dist,{newx,newy}});\\n                        vis[newx][newy]=true;\\n                    }\\n                    else{\\n                        pq.push({dist+1,{newx,newy}});\\n                        vis[newx][newy]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nShortest Path - Dijkstra\\'s algo\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<long long>> dist(n+1,vector<long long>(m+1,1e8));\\n        queue<pair<int,int>> q;\\n        int cnt = 0;\\n        if(grid[0][0]==1){\\n            cnt++;\\n        }\\n        q.push({0,0});\\n        dist[0][0]=cnt;\\n        vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n        while(q.empty()==false){\\n            long long x = q.front().first;\\n            long long y = q.front().second;\\n            q.pop();\\n            for(auto &mov : dir){\\n                long long newx = x + mov[0];\\n                long long newy = y + mov[1];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && dist[x][y]+grid[newx][newy]<dist[newx][newy]){\\n                    dist[newx][newy] = dist[x][y]+grid[newx][newy];\\n                    q.push({newx,newy});\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        vector<vector<bool>> vis(n+1,vector<bool>(m+1,false));\\n        int cnt = 0;\\n        if(grid[0][0]==1){\\n            cnt++;\\n        }\\n        \\n        pq.push({cnt,{0,0}});\\n        vis[0][0]=true;\\n        vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n        while(pq.empty()==false){\\n            long long x = pq.top().second.first;\\n            long long y = pq.top().second.second;\\n            long long dist = pq.top().first;\\n            pq.pop();\\n            if(x==n-1 && y==m-1){\\n                return dist;\\n            }\\n            for(auto &mov : dir){\\n                long long newx = x + mov[0];\\n                long long newy = y + mov[1];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && vis[newx][newy]==false){\\n                    if(grid[newx][newy]==0){\\n                        pq.push({dist,{newx,newy}});\\n                        vis[newx][newy]=true;\\n                    }\\n                    else{\\n                        pq.push({dist+1,{newx,newy}});\\n                        vis[newx][newy]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<long long>> dist(n+1,vector<long long>(m+1,1e8));\\n        queue<pair<int,int>> q;\\n        int cnt = 0;\\n        if(grid[0][0]==1){\\n            cnt++;\\n        }\\n        q.push({0,0});\\n        dist[0][0]=cnt;\\n        vector<vector<int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n        while(q.empty()==false){\\n            long long x = q.front().first;\\n            long long y = q.front().second;\\n            q.pop();\\n            for(auto &mov : dir){\\n                long long newx = x + mov[0];\\n                long long newy = y + mov[1];\\n                if(newx>=0 && newx<n && newy>=0 && newy<m && dist[x][y]+grid[newx][newy]<dist[newx][newy]){\\n                    dist[newx][newy] = dist[x][y]+grid[newx][newy];\\n                    q.push({newx,newy});\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705274,
                "title": "python-3-0-1-bfs-easy-to-understand",
                "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366676,
                "title": "solve-using-01-bfs",
                "content": "* We can solve this problem with Dijktra\\'s algo thats quite obvious but when the weights of the graph is not large or it limited to small number lets say k i.e. weight ranges from 1 to k we can use BFS. \\n* Here in this question its given that weight is either 0 or 1 so instead of using Dijktra we can go for 01 BFS. \\n* Attaching some video links and tutorial links which you can refer to understand this concept.\\n https://www.youtube.com/watch?v=Xqq7uELiYnE&t=63s\\n https://www.youtube.com/watch?v=4DiOHNuO8To\\n https://cp-algorithms.com/graph/01_bfs.html\\n\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dist = new int[n][m];\\n        \\n        for(int[] d: dist){\\n            Arrays.fill(d,Integer.MAX_VALUE);\\n        }\\n        \\n        int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n        \\n        LinkedList<int[]> q = new LinkedList<>();\\n        \\n        dist[0][0] = grid[0][0];\\n        \\n        q.addFirst(new int[]{dist[0][0],0,0});\\n        \\n        while(!q.isEmpty()){\\n            int sz=q.size();\\n            while(sz-->0){\\n                int[] cur = q.poll();\\n                int cost = cur[0], x = cur[1], y = cur[2];\\n                \\n                for(int k=0;k<4;k++){\\n                    int nx=x+dx[k];\\n                    int ny=y+dy[k];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<m && dist[nx][ny]>grid[nx][ny]+cost) {\\n                        dist[nx][ny]=grid[nx][ny]+cost;\\n                        \\n                        if(grid[nx][ny]==0){\\n                            q.addFirst(new int[]{dist[nx][ny],nx,ny});\\n                        }else{\\n                            q.addLast(new int[]{dist[nx][ny],nx,ny});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dist[n-1][m-1];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dist = new int[n][m];\\n        \\n        for(int[] d: dist){\\n            Arrays.fill(d,Integer.MAX_VALUE);\\n        }\\n        \\n        int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n        \\n        LinkedList<int[]> q = new LinkedList<>();\\n        \\n        dist[0][0] = grid[0][0];\\n        \\n        q.addFirst(new int[]{dist[0][0],0,0});\\n        \\n        while(!q.isEmpty()){\\n            int sz=q.size();\\n            while(sz-->0){\\n                int[] cur = q.poll();\\n                int cost = cur[0], x = cur[1], y = cur[2];\\n                \\n                for(int k=0;k<4;k++){\\n                    int nx=x+dx[k];\\n                    int ny=y+dy[k];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<m && dist[nx][ny]>grid[nx][ny]+cost) {\\n                        dist[nx][ny]=grid[nx][ny]+cost;\\n                        \\n                        if(grid[nx][ny]==0){\\n                            q.addFirst(new int[]{dist[nx][ny],nx,ny});\\n                        }else{\\n                            q.addLast(new int[]{dist[nx][ny],nx,ny});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dist[n-1][m-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207665,
                "title": "python-bfs-easy",
                "content": "here seen is used to track the state of the cells , i.e, the min number of obstacles removed from the start to reach current position.  it is pruning, removing the paths which demands equal or more obstables to reach the position.\\n\\n```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        q=[]\\n        heappush(q,[0,0,0]) ## [# obstacles, x, y]\\n        seen=[[float(\"inf\") for j in range(n)] for i in range(m)]\\n        seen[0][0]=0 ## min obstables on the path\\n        dirs=[0,1,0,-1,0]\\n        while q:\\n            obs,r,c=heappop(q)\\n            if r==m-1 and c==n-1:\\n                return obs\\n            for i in range(4):\\n                x,y=dirs[i],dirs[i+1]\\n                nr,nc=r+x,c+y\\n                if nr<0 or nr>=m or nc<0 or nc>=n:continue\\n                new_obs=obs+grid[nr][nc]\\n                if new_obs>=seen[nr][nc]:continue\\n                heappush(q, [new_obs,nr,nc])\\n                seen[nr][nc]=new_obs                \\n        return m+n-2",
                "solutionTags": [],
                "code": "here seen is used to track the state of the cells , i.e, the min number of obstacles removed from the start to reach current position.  it is pruning, removing the paths which demands equal or more obstables to reach the position.\\n\\n```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        q=[]\\n        heappush(q,[0,0,0]) ## [# obstacles, x, y]\\n        seen=[[float(\"inf\") for j in range(n)] for i in range(m)]\\n        seen[0][0]=0 ## min obstables on the path\\n        dirs=[0,1,0,-1,0]\\n        while q:\\n            obs,r,c=heappop(q)\\n            if r==m-1 and c==n-1:\\n                return obs\\n            for i in range(4):\\n                x,y=dirs[i],dirs[i+1]\\n                nr,nc=r+x,c+y\\n                if nr<0 or nr>=m or nc<0 or nc>=n:continue\\n                new_obs=obs+grid[nr][nc]\\n                if new_obs>=seen[nr][nc]:continue\\n                heappush(q, [new_obs,nr,nc])\\n                seen[nr][nc]=new_obs                \\n        return m+n-2",
                "codeTag": "Python3"
            },
            {
                "id": 2086710,
                "title": "c-simple-dijkstras-straight-forward-no-dp-matrix-clean-code",
                "content": "```\\n int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m =grid.size();\\n        int n=grid[0].size();\\n        \\n        int dx[4]={ 1 , -1 , 0 , 0};\\n        int dy[4]={ 0 , 0 , 1 , -1};\\n        \\n        priority_queue< pair<int , pair<int ,int>> , vector<pair<int , pair<int ,int>>> , greater<pair<int , pair<int ,int>>> > pq;\\n        \\n        pq.push({0 , {0,0}});\\n        \\n        // obs , x , y\\n        \\n        grid[0][0]=-1;\\n        \\n        // visited \\n        \\n        \\n         while(!pq.empty())\\n         {\\n             int obs= pq.top().first;\\n             int x=pq.top().second.first;\\n             \\n             int y=pq.top().second.second;\\n             \\n             pq.pop();\\n             \\n             if(x==m-1 && y==n-1)\\n             {\\n                 return obs;\\n             }\\n             \\n             for(int k=0;k<4;k++)\\n             {\\n                 int newx=x+dx[k];\\n                 int newy=y+dy[k];\\n                 \\n                 if(newx>=0 && newy>=0 && newx<m && newy<n && grid[newx][newy]!=-1)\\n                 {\\n                     pq.push({obs + grid[newx][newy] ,{newx , newy}});\\n                     grid[newx][newy]=-1;\\n                 }\\n             }\\n         }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m =grid.size();\\n        int n=grid[0].size();\\n        \\n        int dx[4]={ 1 , -1 , 0 , 0};\\n        int dy[4]={ 0 , 0 , 1 , -1};\\n        \\n        priority_queue< pair<int , pair<int ,int>> , vector<pair<int , pair<int ,int>>> , greater<pair<int , pair<int ,int>>> > pq;\\n        \\n        pq.push({0 , {0,0}});\\n        \\n        // obs , x , y\\n        \\n        grid[0][0]=-1;\\n        \\n        // visited \\n        \\n        \\n         while(!pq.empty())\\n         {\\n             int obs= pq.top().first;\\n             int x=pq.top().second.first;\\n             \\n             int y=pq.top().second.second;\\n             \\n             pq.pop();\\n             \\n             if(x==m-1 && y==n-1)\\n             {\\n                 return obs;\\n             }\\n             \\n             for(int k=0;k<4;k++)\\n             {\\n                 int newx=x+dx[k];\\n                 int newy=y+dy[k];\\n                 \\n                 if(newx>=0 && newy>=0 && newx<m && newy<n && grid[newx][newy]!=-1)\\n                 {\\n                     pq.push({obs + grid[newx][newy] ,{newx , newy}});\\n                     grid[newx][newy]=-1;\\n                 }\\n             }\\n         }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086192,
                "title": "c-100-memory-efficient-in-c-submissions",
                "content": "```\\n#define pii pair<int,int>\\n#define pipii pair<int,pii>\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    int x[4] = {0, 0, -1, 1};\\n    int y[4] = {1, -1, 0, 0};\\n    bool isValidLocation(int i, int j, int n, int m)\\n    {\\n        return (i>=0 && j>=0 && i<n && j<m);\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        priority_queue<pipii, vector<pipii>, greater<pipii>> q;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        q.push({0, {0, 0}});\\n        vis[0][0] = true;\\n        while(!q.empty())\\n        {\\n            pipii front = q.top();\\n            q.pop();\\n            \\n            if(front.S.F == n-1 && front.S.S == m-1)\\n                return front.F;\\n            \\n            for(int k=0; k<4; k++)\\n            {\\n                int cx = front.S.F + x[k];\\n                int cy = front.S.S + y[k];\\n                \\n                if(isValidLocation(cx, cy, n, m) && !vis[cx][cy])\\n                {\\n                    vis[cx][cy] = true;\\n                    \\n                    if(grid[cx][cy])\\n                        q.push({front.F+1, {cx, cy}});\\n                    else\\n                        q.push({front.F, {cx, cy}});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define pii pair<int,int>\\n#define pipii pair<int,pii>\\n#define F first\\n#define S second\\nclass Solution {\\npublic:\\n    int x[4] = {0, 0, -1, 1};\\n    int y[4] = {1, -1, 0, 0};\\n    bool isValidLocation(int i, int j, int n, int m)\\n    {\\n        return (i>=0 && j>=0 && i<n && j<m);\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        priority_queue<pipii, vector<pipii>, greater<pipii>> q;\\n        vector<vector<bool>> vis(n, vector<bool>(m, false));\\n        q.push({0, {0, 0}});\\n        vis[0][0] = true;\\n        while(!q.empty())\\n        {\\n            pipii front = q.top();\\n            q.pop();\\n            \\n            if(front.S.F == n-1 && front.S.S == m-1)\\n                return front.F;\\n            \\n            for(int k=0; k<4; k++)\\n            {\\n                int cx = front.S.F + x[k];\\n                int cy = front.S.S + y[k];\\n                \\n                if(isValidLocation(cx, cy, n, m) && !vis[cx][cy])\\n                {\\n                    vis[cx][cy] = true;\\n                    \\n                    if(grid[cx][cy])\\n                        q.push({front.F+1, {cx, cy}});\\n                    else\\n                        q.push({front.F, {cx, cy}});\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085899,
                "title": "dp-error",
                "content": "**Can some 1 tell me whats wrong with this dp approach**\\n\\nclass Solution {\\npublic:\\n    int mn=INT_MAX;\\nint f(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&dp){\\n    if(i==0 && j==0){\\n        return grid[i][j];\\n    }\\n    if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size()){\\n        return INT_MAX;\\n    }\\n    if(dp[i][j]!=-1){\\n        return dp[i][j];\\n\\n    }\\n    int cnt1=grid[i][j]+f(grid,i-1,j,dp);\\n    int cnt2=grid[i][j]+f(grid,i+1,j,dp);\\n    int cnt3=grid[i][j]+f(grid,i,j-1,dp);\\n    int cnt4=grid[i][j]+f(grid,i,j+1,dp);\\n     dp[i][j]=min(cnt1,min(cnt2,min(cnt3,cnt4)));\\n\\n}\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n   int n=grid[0].size();\\n        if(grid[0][0]!=0 || grid[m-1][n-1]!=0){\\n            return 0;\\n        }\\n   vector<vector<int>>dp(m,vector<int>(n,-1));\\n   int x=f(grid,m-1,n-1,dp);\\n return  x;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int mn=INT_MAX;\\nint f(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&dp){\\n    if(i==0 && j==0){\\n        return grid[i][j];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2085872,
                "title": "java-dijkstra-priority-queue",
                "content": "```\\nclass pair{\\n    int ii;\\n    int jj;\\n    int val;\\n    pair(int ii,int jj,int val){\\n        this.ii=ii;\\n        this.jj=jj;\\n        this.val=val;\\n    }\\n}\\nclass Solution {\\n    public boolean valid(int i,int j,int m,int n,boolean[][] visited){\\n        return i>=0&&j>=0&&i<m&&j<n&&!visited[i][j];\\n    }\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[][] dp=new int[m][n];\\n        boolean[][] visited=new boolean[m][n];\\n        PriorityQueue<pair> q=new PriorityQueue<pair>((a,b)->(a.val-b.val));\\n        q.add(new pair(0,0,0));\\n        visited[0][0]=true;\\n        while(q.size()!=0){\\n            pair p=q.poll();\\n            if(valid(p.ii-1,p.jj,m,n,visited)){\\n                dp[p.ii-1][p.jj]=grid[p.ii-1][p.jj]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii-1,p.jj,dp[p.ii-1][p.jj]));\\n                visited[p.ii-1][p.jj]=true;\\n            }\\n            if(valid(p.ii+1,p.jj,m,n,visited)){\\n                dp[p.ii+1][p.jj]=grid[p.ii+1][p.jj]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii+1,p.jj,dp[p.ii+1][p.jj]));\\n                visited[p.ii+1][p.jj]=true;\\n            }\\n            if(valid(p.ii,p.jj-1,m,n,visited)){\\n                dp[p.ii][p.jj-1]=grid[p.ii][p.jj-1]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii,p.jj-1,dp[p.ii][p.jj-1]));\\n                visited[p.ii][p.jj-1]=true;\\n            }\\n            if(valid(p.ii,p.jj+1,m,n,visited)){\\n                dp[p.ii][p.jj+1]=grid[p.ii][p.jj+1]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii,p.jj+1,dp[p.ii][p.jj+1]));\\n                visited[p.ii][p.jj+1]=true;\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass pair{\\n    int ii;\\n    int jj;\\n    int val;\\n    pair(int ii,int jj,int val){\\n        this.ii=ii;\\n        this.jj=jj;\\n        this.val=val;\\n    }\\n}\\nclass Solution {\\n    public boolean valid(int i,int j,int m,int n,boolean[][] visited){\\n        return i>=0&&j>=0&&i<m&&j<n&&!visited[i][j];\\n    }\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int[][] dp=new int[m][n];\\n        boolean[][] visited=new boolean[m][n];\\n        PriorityQueue<pair> q=new PriorityQueue<pair>((a,b)->(a.val-b.val));\\n        q.add(new pair(0,0,0));\\n        visited[0][0]=true;\\n        while(q.size()!=0){\\n            pair p=q.poll();\\n            if(valid(p.ii-1,p.jj,m,n,visited)){\\n                dp[p.ii-1][p.jj]=grid[p.ii-1][p.jj]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii-1,p.jj,dp[p.ii-1][p.jj]));\\n                visited[p.ii-1][p.jj]=true;\\n            }\\n            if(valid(p.ii+1,p.jj,m,n,visited)){\\n                dp[p.ii+1][p.jj]=grid[p.ii+1][p.jj]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii+1,p.jj,dp[p.ii+1][p.jj]));\\n                visited[p.ii+1][p.jj]=true;\\n            }\\n            if(valid(p.ii,p.jj-1,m,n,visited)){\\n                dp[p.ii][p.jj-1]=grid[p.ii][p.jj-1]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii,p.jj-1,dp[p.ii][p.jj-1]));\\n                visited[p.ii][p.jj-1]=true;\\n            }\\n            if(valid(p.ii,p.jj+1,m,n,visited)){\\n                dp[p.ii][p.jj+1]=grid[p.ii][p.jj+1]+dp[p.ii][p.jj];\\n                q.add(new pair(p.ii,p.jj+1,dp[p.ii][p.jj+1]));\\n                visited[p.ii][p.jj+1]=true;\\n            }\\n        }\\n        return dp[m-1][n-1];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085829,
                "title": "python-clean-simple-heap-dp",
                "content": "- Use min-heap to always get the minimum obstacle removed step at front\\n- Use a 2D table to memorize what is the mininum removed count for a cell\\n\\n```python\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        # minimum removed obstacles table\\n        dp = [[inf for _ in range(n)] for _ in range(m)]\\n        dp[0][0] = grid[0][0]\\n        \\n        # removed obstacles count, i, j\\n        heap = [(0, 0, 0)]\\n\\t\\t\\n        while heap:\\n            removed, i, j = heappop(heap)\\n            if i == m-1 and j == n-1:\\n                return removed\\n            for ii, jj in [(i, j+1), (i+1, j), (i, j-1), (i-1, j)]:\\n                if (0 <= ii < m and 0 <= jj < n) and grid[ii][jj] + removed < dp[ii][jj]:\\n                    dp[ii][jj] = grid[ii][jj] + removed\\n                    heappush(heap, (dp[ii][jj], ii, jj))\\n        return dp[-1][-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        # minimum removed obstacles table\\n        dp = [[inf for _ in range(n)] for _ in range(m)]\\n        dp[0][0] = grid[0][0]\\n        \\n        # removed obstacles count, i, j\\n        heap = [(0, 0, 0)]\\n\\t\\t\\n        while heap:\\n            removed, i, j = heappop(heap)\\n            if i == m-1 and j == n-1:\\n                return removed\\n            for ii, jj in [(i, j+1), (i+1, j), (i, j-1), (i-1, j)]:\\n                if (0 <= ii < m and 0 <= jj < n) and grid[ii][jj] + removed < dp[ii][jj]:\\n                    dp[ii][jj] = grid[ii][jj] + removed\\n                    heappush(heap, (dp[ii][jj], ii, jj))\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944516,
                "title": "c-dijkstra-algorithm-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(n*m*log(n*m))\\n\\n- Space complexity:O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>>v(n, vector<int>(m, 1e9));\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\\n        v[0][0]=grid[0][0];\\n        q.push({v[0][0], {0, 0}});\\n        while(!q.empty()){\\n            int wt=q.top().first, x=q.top().second.first, y=q.top().second.second;\\n            q.pop();\\n            int r[4]={1, 0, -1, 0};\\n            int c[4]={0, 1, 0, -1};\\n            for(int i=0; i<4; i++){\\n                int row=r[i]+x, col=c[i]+y;\\n                if(isvalid(row, col, n, m)){\\n                    if(wt+grid[row][col]<v[row][col]){\\n                        v[row][col]=grid[row][col]+wt;\\n                        q.push({v[row][col], {row, col}});\\n                    }\\n                }\\n            }\\n        }\\n        return v[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, int n, int m){\\n        return i>=0 && i<n && j>=0 && j<m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        vector<vector<int>>v(n, vector<int>(m, 1e9));\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>q;\\n        v[0][0]=grid[0][0];\\n        q.push({v[0][0], {0, 0}});\\n        while(!q.empty()){\\n            int wt=q.top().first, x=q.top().second.first, y=q.top().second.second;\\n            q.pop();\\n            int r[4]={1, 0, -1, 0};\\n            int c[4]={0, 1, 0, -1};\\n            for(int i=0; i<4; i++){\\n                int row=r[i]+x, col=c[i]+y;\\n                if(isvalid(row, col, n, m)){\\n                    if(wt+grid[row][col]<v[row][col]){\\n                        v[row][col]=grid[row][col]+wt;\\n                        q.push({v[row][col], {row, col}});\\n                    }\\n                }\\n            }\\n        }\\n        return v[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919143,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS 2D\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define pii pair<int, int>\\n#define maxn 100005\\nint fx[] = {-1, 1, 0, 0};\\nint fy[] = {0, 0, -1, 1};\\n\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> vis, dis;\\n\\n    bool valid(int x, int y)\\n    {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void bfs(int sx, int sy, vector<vector<int>>& grid)\\n    {\\n        vis[sx][sy] = 1;\\n        dis[sx][sy] = 0;\\n        deque<pii> q;\\n        q.push_front({sx, sy});\\n        while(!q.empty()) {\\n            pii top = q.front();\\n            int x = top.first;\\n            int y = top.second;\\n            q.pop_front();\\n            for(int k=0; k<4; k++) {\\n                int tx = x + fx[k];\\n                int ty = y + fy[k];\\n                if(valid(tx, ty)) {\\n                    vis[tx][ty] = 1;\\n                    if(grid[tx][ty] == 1) {\\n                        dis[tx][ty] = dis[x][y] + 1;\\n                        q.push_back({tx, ty});\\n                    }\\n                    else {\\n                        dis[tx][ty] = dis[x][y];\\n                        q.push_front({tx, ty});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<int> v;\\n        for(int j=0; j<m; j++) v.push_back(0);\\n        for(int i=0; i<n; i++) {\\n            vis.push_back(v);\\n            dis.push_back(v);\\n        }\\n\\n        bfs(0, 0, grid);\\n\\n        int ans = dis[n-1][m-1];\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n#define pii pair<int, int>\\n#define maxn 100005\\nint fx[] = {-1, 1, 0, 0};\\nint fy[] = {0, 0, -1, 1};\\n\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> vis, dis;\\n\\n    bool valid(int x, int y)\\n    {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void bfs(int sx, int sy, vector<vector<int>>& grid)\\n    {\\n        vis[sx][sy] = 1;\\n        dis[sx][sy] = 0;\\n        deque<pii> q;\\n        q.push_front({sx, sy});\\n        while(!q.empty()) {\\n            pii top = q.front();\\n            int x = top.first;\\n            int y = top.second;\\n            q.pop_front();\\n            for(int k=0; k<4; k++) {\\n                int tx = x + fx[k];\\n                int ty = y + fy[k];\\n                if(valid(tx, ty)) {\\n                    vis[tx][ty] = 1;\\n                    if(grid[tx][ty] == 1) {\\n                        dis[tx][ty] = dis[x][y] + 1;\\n                        q.push_back({tx, ty});\\n                    }\\n                    else {\\n                        dis[tx][ty] = dis[x][y];\\n                        q.push_front({tx, ty});\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        vector<int> v;\\n        for(int j=0; j<m; j++) v.push_back(0);\\n        for(int i=0; i<n; i++) {\\n            vis.push_back(v);\\n            dis.push_back(v);\\n        }\\n\\n        bfs(0, 0, grid);\\n\\n        int ans = dis[n-1][m-1];\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2438923,
                "title": "bfs-cpp-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        \\n        q.push({0,{0,0}});\\n        \\n        dist[0][0]=0;       \\n        while(!q.empty()){\\n            auto a=q.top();\\n            q.pop();\\n            \\n            int dis=a.first;\\n            int i=a.second.first,j=a.second.second;\\n            \\n            if(i+1<m){\\n                int d=dis+grid[i+1][j];\\n                if(d<dist[i+1][j]){\\n                    \\n                    dist[i+1][j]=d;\\n                    q.push({d,{i+1,j}});\\n                }\\n            }\\n            \\n            if(i-1>=0){\\n                int d=dis+grid[i-1][j];\\n                if(d<dist[i-1][j]){\\n                    \\n                    dist[i-1][j]=d;\\n                    q.push({d,{i-1,j}});\\n                }\\n            }\\n            \\n            if(j+1<n){\\n                 int d=dis+grid[i][j+1];\\n                if(d<dist[i][j+1]){\\n                    \\n                    dist[i][j+1]=d;\\n                    q.push({d,{i,j+1}});\\n                }\\n            }\\n            \\n            if(j-1>=0){\\n                 int d=dis+grid[i][j-1];\\n                if(d<dist[i][j-1]){\\n                    \\n                    dist[i][j-1]=d;\\n                    q.push({d,{i,j-1}});\\n                }\\n            }\\n        }\\n        \\n        return dist[m-1][n-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        \\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        \\n        q.push({0,{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 2308469,
                "title": "c-bfs-dijkstra",
                "content": "```\\n#define pi pair<int,int>\\n\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, vector<vector<int>> &grid, int m, int n) {\\n        return i >= 0 and i < m and j >= 0 and j < n and grid[i][j] != -1;\\n    }\\n    \\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m(size(grid)), n(size(grid[0]));\\n        \\n        int dir[] = {1,0,-1,0,1};\\n        \\n        priority_queue<pair<int,pi>, vector<pair<int,pi>>, greater<pair<int,pi>>> pq;\\n        vector<vector<int>> dist(m, vector<int>(n,INT_MAX));\\n        dist[0][0] = 0;\\n        pq.push({0,{0,0}});\\n        grid[0][0] = -1;\\n    \\n        while(!pq.empty()) {\\n            \\n            auto cell = pq.top();\\n            pq.pop();\\n            int prevdist = cell.first;\\n            int r = cell.second.first;\\n            int c = cell.second.second;\\n            \\n            if(r + c == m + n - 2) return prevdist;\\n            \\n            for(int i = 0; i < 4; i++) {\\n                int x = r + dir[i];\\n                int y = c + dir[i+1];\\n                \\n                if(isvalid(x,y,grid,m,n) and prevdist + grid[x][y] < dist[x][y]) {\\n                    \\n                    dist[x][y] = prevdist + grid[x][y];\\n                    pq.push({dist[x][y],{x,y}});\\n                    grid[x][y] = -1;\\n                }\\n            }\\n        }\\n        \\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pi pair<int,int>\\n\\nclass Solution {\\npublic:\\n    bool isvalid(int i, int j, vector<vector<int>> &grid, int m, int n) {\\n        return i >= 0 and i < m and j >= 0 and j < n and grid[i][j] != -1;\\n    }\\n    \\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m(size(grid)), n(size(grid[0]));\\n        \\n        int dir[] = {1,0,-1,0,1};\\n        \\n        priority_queue<pair<int,pi>, vector<pair<int,pi>>, greater<pair<int,pi>>> pq;\\n        vector<vector<int>> dist(m, vector<int>(n,INT_MAX));\\n        dist[0][0] = 0;\\n        pq.push({0,{0,0}});\\n        grid[0][0] = -1;\\n    \\n        while(!pq.empty()) {\\n            \\n            auto cell = pq.top();\\n            pq.pop();\\n            int prevdist = cell.first;\\n            int r = cell.second.first;\\n            int c = cell.second.second;\\n            \\n            if(r + c == m + n - 2) return prevdist;\\n            \\n            for(int i = 0; i < 4; i++) {\\n                int x = r + dir[i];\\n                int y = c + dir[i+1];\\n                \\n                if(isvalid(x,y,grid,m,n) and prevdist + grid[x][y] < dist[x][y]) {\\n                    \\n                    dist[x][y] = prevdist + grid[x][y];\\n                    pq.push({dist[x][y],{x,y}});\\n                    grid[x][y] = -1;\\n                }\\n            }\\n        }\\n        \\n        \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127967,
                "title": "c-solution-minesweeper-bfs-traversal",
                "content": "So, this is my first post around here. For this solution, I took inspiration from **\"votrubac\\'s\"** explanation. \\nThe code is as follows:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int i,int j,int n,int m)\\n    {\\n        if(i<0||j<0) return false;\\n        if(i>=n||j>=m) return false;\\n        return true;\\n    }\\n    \\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={-1,0,1,0};\\n    \\n    // function\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m,-1));\\n        int wall=0;                         // minesweeper wall\\n        queue<pair<int,int>> obs,trs;       // obs == obstacle queue  &   trs == traversal queue\\n        \\n        \\n        // bfs starts\\n        \\n        vis[0][0]=wall;\\n        //q.push({0,0});\\n        trs.push({0,0});\\n        while(!trs.empty())\\n        {\\n            int a=trs.size();\\n            for(int i=0;i<a;i++)\\n            {\\n\\t\\t\\t\\t// visiting all the 4 adjacent cells\\n                for(int j=0;j<4;j++)\\n                {\\n                    if(isValid(trs.front().first+dy[j],trs.front().second+dx[j],n,m))\\n                    {\\n                        if(grid[trs.front().first+dy[j]][trs.front().second+dx[j]]==1&& vis[trs.front().first+dy[j]][trs.front().second+dx[j]]==-1)\\n                        {\\n                            vis[trs.front().first+dy[j]][trs.front().second+dx[j]]=wall+1;\\n                            obs.push({trs.front().first+dy[j],trs.front().second+dx[j]});\\n                        }\\n                        else if(grid[trs.front().first+dy[j]][trs.front().second+dx[j]]==0&& vis[trs.front().first+dy[j]][trs.front().second+dx[j]]==-1)\\n                        {\\n                            vis[trs.front().first+dy[j]][trs.front().second+dx[j]]=wall;\\n                            trs.push({trs.front().first+dy[j],trs.front().second+dx[j]});\\n                        }\\n                    }\\n                }\\n                trs.pop();\\n            }\\n            if(vis[n-1][m-1]!=-1)\\n            {\\n                return vis[n-1][m-1];\\n            }\\n            \\n            \\n            // swapping trs and obs when trs is empty but obs is not to simulate that a wall has been reached \\n            // ans we need to break it to get past\\n            \\n            if(trs.empty())\\n            {\\n                while(!obs.empty())\\n                {\\n                    trs.push(obs.front());\\n                    obs.pop();\\n                }\\n                wall++;\\n            }\\n        }\\n        \\n        // bfs ends here\\n        \\n        return vis[n-1][m-1];\\n    }\\n};\\n```\\n\\nSo, this was my code. Thank you.\\nAnd a special thanks to https://leetcode.com/votrubac/",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(int i,int j,int n,int m)\\n    {\\n        if(i<0||j<0) return false;\\n        if(i>=n||j>=m) return false;\\n        return true;\\n    }\\n    \\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={-1,0,1,0};\\n    \\n    // function\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m,-1));\\n        int wall=0;                         // minesweeper wall\\n        queue<pair<int,int>> obs,trs;       // obs == obstacle queue  &   trs == traversal queue\\n        \\n        \\n        // bfs starts\\n        \\n        vis[0][0]=wall;\\n        //q.push({0,0});\\n        trs.push({0,0});\\n        while(!trs.empty())\\n        {\\n            int a=trs.size();\\n            for(int i=0;i<a;i++)\\n            {\\n\\t\\t\\t\\t// visiting all the 4 adjacent cells\\n                for(int j=0;j<4;j++)\\n                {\\n                    if(isValid(trs.front().first+dy[j],trs.front().second+dx[j],n,m))\\n                    {\\n                        if(grid[trs.front().first+dy[j]][trs.front().second+dx[j]]==1&& vis[trs.front().first+dy[j]][trs.front().second+dx[j]]==-1)\\n                        {\\n                            vis[trs.front().first+dy[j]][trs.front().second+dx[j]]=wall+1;\\n                            obs.push({trs.front().first+dy[j],trs.front().second+dx[j]});\\n                        }\\n                        else if(grid[trs.front().first+dy[j]][trs.front().second+dx[j]]==0&& vis[trs.front().first+dy[j]][trs.front().second+dx[j]]==-1)\\n                        {\\n                            vis[trs.front().first+dy[j]][trs.front().second+dx[j]]=wall;\\n                            trs.push({trs.front().first+dy[j],trs.front().second+dx[j]});\\n                        }\\n                    }\\n                }\\n                trs.pop();\\n            }\\n            if(vis[n-1][m-1]!=-1)\\n            {\\n                return vis[n-1][m-1];\\n            }\\n            \\n            \\n            // swapping trs and obs when trs is empty but obs is not to simulate that a wall has been reached \\n            // ans we need to break it to get past\\n            \\n            if(trs.empty())\\n            {\\n                while(!obs.empty())\\n                {\\n                    trs.push(obs.front());\\n                    obs.pop();\\n                }\\n                wall++;\\n            }\\n        }\\n        \\n        // bfs ends here\\n        \\n        return vis[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105588,
                "title": "c-classic-bfs-problem-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    const int dx[4] = {-1,0,1,0} ;\\n    const int dy[4] = {0,1,0,-1} ;\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int r = grid.size() , c = grid[0].size() ;\\n        vector<vector<int>> dp(r,vector<int>(c,r*c)) ;\\n        \\n        queue<pair<int,int>>q ; q.push({0,0}) ; dp[0][0] = 0 ;\\n        while(q.size()){\\n            \\n            auto [i,j] = q.front() ; q.pop() ;\\n\\t\\t\\t//itr loop iterates for every direction up , right , down, left \\n            for(int itr = 0 ; itr < 4 ; ++itr ){\\n                int ii = i + dx[itr] , jj = j + dy[itr] ;\\n                if(ii >= 0 and jj >= 0 and ii < r and jj < c){\\n                    if(dp[ii][jj] > dp[i][j] + (grid[ii][jj] == 1)){\\n\\t\\t\\t\\t\\t//if a better path is available only then explore it !\\n                        dp[ii][jj] = dp[i][j] + (grid[ii][jj] == 1) ;\\n                        q.push({ii,jj}) ;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return dp[r - 1][c - 1] ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int dx[4] = {-1,0,1,0} ;\\n    const int dy[4] = {0,1,0,-1} ;\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int r = grid.size() , c = grid[0].size() ;\\n        vector<vector<int>> dp(r,vector<int>(c,r*c)) ;\\n        \\n        queue<pair<int,int>>q ; q.push({0,0}) ; dp[0][0] = 0 ;\\n        while(q.size()){\\n            \\n            auto [i,j] = q.front() ; q.pop() ;\\n\\t\\t\\t//itr loop iterates for every direction up , right , down, left \\n            for(int itr = 0 ; itr < 4 ; ++itr ){\\n                int ii = i + dx[itr] , jj = j + dy[itr] ;\\n                if(ii >= 0 and jj >= 0 and ii < r and jj < c){\\n                    if(dp[ii][jj] > dp[i][j] + (grid[ii][jj] == 1)){\\n\\t\\t\\t\\t\\t//if a better path is available only then explore it !\\n                        dp[ii][jj] = dp[i][j] + (grid[ii][jj] == 1) ;\\n                        q.push({ii,jj}) ;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return dp[r - 1][c - 1] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099932,
                "title": "python-bfs-o-m-n-very-interesting-approach-faster-than-95",
                "content": "Imagine this algorithm as water, it flows as much as it can.\\nIf it fills every reachable space, it\\'s pressure will increase and it will break every wall it currently touches.\\nAnd again, it flows as much as it can, if it doesn\\'t reach end, it breaks another layer of walls...\\n\\n```\\n#Already occupied space\\nused = set([(0,0)])\\n\\n#Unreached space\\nbfs = collections.deque([(0,0)])\\n#Current walls\\nwalls = collections.deque()\\n\\n#Directions\\ndirs = [(0,1),(1,0),(-1,0),(0,-1)]\\n#Size\\nm,n = len(grid), len(grid[0])\\n#Counter of broken walls\\nout = 0\\n\\n#Single iteration of outer while loop representes Water Expansion + Breaking 1 layer of wall\\nwhile True:\\n\\n\\t#Breadth first search all space and mark all walls to another queue\\n\\twhile bfs:\\n\\t\\tx,y = bfs.popleft()\\n\\t\\tif x == m-1 and y == n-1:\\n\\t\\t\\treturn out\\n\\t\\tfor d in dirs:\\n\\t\\t\\ta = (d[0]+x, d[1]+y)\\n\\t\\t\\t#Illegal, continue\\n\\t\\t\\tif a[0] < 0 or a[0] >= m or a[1] < 0 or a[1] >= n or a in used:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t#Wall, mark it in second queue\\n\\t\\t\\telif grid[a[0]][a[1]] == 1:\\n\\t\\t\\t\\twalls.append(a)\\n\\t\\t\\t#Space, expand\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbfs.append(a)\\n\\t\\t\\tused.add(a)\\n\\t#It filled everything but it didn\\'t reach end, so we break 1 layer and repeat process\\n\\tout += 1\\n\\t#Now the walls are the space we expand to, and new walls become empty\\n\\tbfs = walls\\n\\twalls = collections.deque()\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\n#Already occupied space\\nused = set([(0,0)])\\n\\n#Unreached space\\nbfs = collections.deque([(0,0)])\\n#Current walls\\nwalls = collections.deque()\\n\\n#Directions\\ndirs = [(0,1),(1,0),(-1,0),(0,-1)]\\n#Size\\nm,n = len(grid), len(grid[0])\\n#Counter of broken walls\\nout = 0\\n\\n#Single iteration of outer while loop representes Water Expansion + Breaking 1 layer of wall\\nwhile True:\\n\\n\\t#Breadth first search all space and mark all walls to another queue\\n\\twhile bfs:\\n\\t\\tx,y = bfs.popleft()\\n\\t\\tif x == m-1 and y == n-1:\\n\\t\\t\\treturn out\\n\\t\\tfor d in dirs:\\n\\t\\t\\ta = (d[0]+x, d[1]+y)\\n\\t\\t\\t#Illegal, continue\\n\\t\\t\\tif a[0] < 0 or a[0] >= m or a[1] < 0 or a[1] >= n or a in used:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t#Wall, mark it in second queue\\n\\t\\t\\telif grid[a[0]][a[1]] == 1:\\n\\t\\t\\t\\twalls.append(a)\\n\\t\\t\\t#Space, expand\\n\\t\\t\\telse:\\n\\t\\t\\t\\tbfs.append(a)\\n\\t\\t\\tused.add(a)\\n\\t#It filled everything but it didn\\'t reach end, so we break 1 layer and repeat process\\n\\tout += 1\\n\\t#Now the walls are the space we expand to, and new walls become empty\\n\\tbfs = walls\\n\\twalls = collections.deque()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2093145,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\n\\npublic class Solution {\\n\\n    private static final record Point(int row, int column, int removedObstacles){}\\n    int rows;\\n    int columns;\\n    private static final int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    public int minimumObstacles(int[][] matrix) {\\n        rows = matrix.length;\\n        columns = matrix[0].length;\\n        return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n    }\\n\\n    private int findPathWithMinObstaclesBy01BreadthFirstSearch(int[][] matrix) {\\n        LinkedList<Point> queue = new LinkedList<>();\\n        queue.add(new Point(0, 0, matrix[0][0]));\\n\\n        int[][] minRemovedObstacles = new int[rows][columns];\\n        for (int r = 0; r < rows; ++r) {\\n            Arrays.fill(minRemovedObstacles[r], Integer.MAX_VALUE);\\n        }\\n        minRemovedObstacles[0][0] = 0;\\n\\n        while (!queue.isEmpty()) {\\n\\n            Point current = queue.poll();\\n            if (current.row == rows - 1 && current.column == columns - 1) {\\n                break;\\n            }\\n\\n            for (int[] move : moves) {\\n                int nextRow = current.row + move[0];\\n                int nextColumn = current.column + move[1];\\n\\n                if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                    Point next = new Point(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                    minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                    if (matrix[nextRow][nextColumn] == 0) {\\n                        queue.addFirst(next);\\n                    } else {\\n                        queue.addLast(next);\\n                    }\\n                }\\n            }\\n        }\\n        return minRemovedObstacles[rows - 1][columns - 1];\\n    }\\n\\n    private boolean isInMatrix(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar minimumObstacles = function (matrix) {\\n    this.moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    this.rows = matrix.length;\\n    this.columns = matrix[0].length;\\n    return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n};\\n\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nfunction findPathWithMinObstaclesBy01BreadthFirstSearch(matrix) {\\n    const queue = new DoubleEndedQueue();\\n    queue.addFront(new Point(0, 0, matrix[0][0]));\\n\\n    const minRemovedObstacles = Array.from(new Array(this.rows), () => new Array(this.columns).fill(Number.MAX_SAFE_INTEGER));\\n    minRemovedObstacles[0][0] = 0;\\n\\n    while (!queue.isEmpty()) {\\n\\n        const current = queue.removeFront();\\n        if (current.row === this.rows - 1 && current.column === this.columns - 1) {\\n            break;\\n        }\\n\\n        for (let move of this.moves) {\\n            let nextRow = current.row + move[0];\\n            let nextColumn = current.column + move[1];\\n\\n            if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                const next = new Point(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                if (matrix[nextRow][nextColumn] === 0) {\\n                    queue.addFront(next);\\n                } else {\\n                    queue.addBack(next);\\n                }\\n            }\\n        }\\n    }\\n    return minRemovedObstacles[rows - 1][columns - 1];\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column \\n * @return {boolean}\\n */\\nfunction isInMatrix(row, column) {\\n    return row >= 0 && row < this.rows && column >= 0 && column < this.columns;\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column \\n * @param {number} removedObstacles\\n */\\nfunction Point(row, column, removedObstacles) {\\n    this.row = row;\\n    this.column = column;\\n    this.removedObstacles = removedObstacles;\\n}\\n\\nfunction QueueNode(value) {\\n    this.value = value;\\n    this.next = null;\\n    this.previous = null;\\n}\\n\\nclass DoubleEndedQueue {\\n\\n    constructor() {\\n        this.size = 0;\\n        this.front = null;\\n        this.back = null;\\n    }\\n\\n    addFront(value) {\\n        let node = new QueueNode(value);\\n\\n        if (this.size === 0) {\\n            this.front = node;\\n            this.back = this.front;\\n        } else {\\n            this.front.previous = node;\\n            node.next = this.front;\\n            this.front = node;\\n        }\\n        ++this.size;\\n    }\\n\\n    addBack(value) {\\n        let node = new QueueNode(value);\\n\\n        if (this.size === 0) {\\n            this.back = node;\\n            this.front = this.back;\\n        } else {\\n            this.back.next = node;\\n            node.previous = this.back;\\n            this.back = node;\\n        }\\n        ++this.size;\\n    }\\n\\n    removeFront() {\\n        if (this.size === 0) {\\n            throw \"List is empty.\";\\n        }\\n\\n        let storeFront = this.front;\\n        if (--this.size > 0) {\\n            this.front = this.front.next;\\n            this.front.previous = null;\\n        } else {\\n            this.front = null;\\n            this.back = null;\\n        }\\n        return storeFront.value;\\n    }\\n\\n    removeBack() {\\n        if (this.size === 0) {\\n            throw \"List is empty.\";\\n        }\\n\\n        let storeBack = this.back;\\n        if (--this.size > 0) {\\n            this.back = this.back.previous;\\n            this.back.next = null;\\n        } else {\\n            this.front = null;\\n            this.back = null;\\n        }\\n        return storeBack.value;\\n    }\\n\\n    isEmpty() {\\n        return this.size === 0;\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <array>\\n#include <queue>\\n#include <vector>\\nusing namespace std;\\n\\nstruct Point {\\n    \\n    int row{};\\n    int column{};\\n    int removedObstacles{};\\n    \\n    Point(int row, int column, int removedObstacles) : row {row}, column {column}, removedObstacles {removedObstacles}{}\\n\\n    Point() = default;\\n    virtual ~Point() = default; //virtual: no derived structs but for the sake of good practice.\\n\\n    Point(const Point& point) = default;\\n    Point& operator=(const Point& point) = default;\\n\\n    Point(Point&& point) noexcept = default;\\n    Point& operator=(Point&& point) noexcept = default;\\n};\\n\\nclass Solution {\\n    \\n    size_t rows;\\n    size_t columns;\\n    inline static const array<array<int, 2>, 4> moves{ {{-1, 0}, {1, 0}, {0, -1}, {0, 1}} };\\n\\npublic:\\n    int minimumObstacles(vector<vector<int>>& matrix) {\\n        rows = matrix.size();\\n        columns = matrix[0].size();\\n        return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n    }\\n\\nprivate:\\n    int findPathWithMinObstaclesBy01BreadthFirstSearch(const vector<vector<int>>& matrix) {\\n        deque<Point> queue;\\n        queue.push_back(Point(0, 0, matrix[0][0]));\\n\\n        vector<vector<int>> minRemovedObstacles(rows, vector<int>(columns, INT_MAX));\\n        minRemovedObstacles[0][0] = 0;\\n\\n        while (!queue.empty()) {\\n\\n            Point current = queue.front();\\n            queue.pop_front();\\n\\n            if (current.row == rows - 1 && current.column == columns - 1) {\\n                break;\\n            }\\n\\n            for (const auto& move : moves) {\\n                int nextRow = current.row + move[0];\\n                int nextColumn = current.column + move[1];\\n\\n                if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                    Point next(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                    minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                    if (matrix[nextRow][nextColumn] == 0) {\\n                        queue.push_front(next);\\n                    } else {\\n                        queue.push_back(next);\\n                    }\\n                }\\n            }\\n        }\\n        return minRemovedObstacles[rows - 1][columns - 1];\\n    }\\n\\n    bool isInMatrix(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nimport java.util.Arrays;\\nimport java.util.LinkedList;\\n\\npublic class Solution {\\n\\n    private static final record Point(int row, int column, int removedObstacles){}\\n    int rows;\\n    int columns;\\n    private static final int[][] moves = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    public int minimumObstacles(int[][] matrix) {\\n        rows = matrix.length;\\n        columns = matrix[0].length;\\n        return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n    }\\n\\n    private int findPathWithMinObstaclesBy01BreadthFirstSearch(int[][] matrix) {\\n        LinkedList<Point> queue = new LinkedList<>();\\n        queue.add(new Point(0, 0, matrix[0][0]));\\n\\n        int[][] minRemovedObstacles = new int[rows][columns];\\n        for (int r = 0; r < rows; ++r) {\\n            Arrays.fill(minRemovedObstacles[r], Integer.MAX_VALUE);\\n        }\\n        minRemovedObstacles[0][0] = 0;\\n\\n        while (!queue.isEmpty()) {\\n\\n            Point current = queue.poll();\\n            if (current.row == rows - 1 && current.column == columns - 1) {\\n                break;\\n            }\\n\\n            for (int[] move : moves) {\\n                int nextRow = current.row + move[0];\\n                int nextColumn = current.column + move[1];\\n\\n                if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                    Point next = new Point(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                    minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                    if (matrix[nextRow][nextColumn] == 0) {\\n                        queue.addFirst(next);\\n                    } else {\\n                        queue.addLast(next);\\n                    }\\n                }\\n            }\\n        }\\n        return minRemovedObstacles[rows - 1][columns - 1];\\n    }\\n\\n    private boolean isInMatrix(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar minimumObstacles = function (matrix) {\\n    this.moves = [[-1, 0], [1, 0], [0, -1], [0, 1]];\\n    this.rows = matrix.length;\\n    this.columns = matrix[0].length;\\n    return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n};\\n\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nfunction findPathWithMinObstaclesBy01BreadthFirstSearch(matrix) {\\n    const queue = new DoubleEndedQueue();\\n    queue.addFront(new Point(0, 0, matrix[0][0]));\\n\\n    const minRemovedObstacles = Array.from(new Array(this.rows), () => new Array(this.columns).fill(Number.MAX_SAFE_INTEGER));\\n    minRemovedObstacles[0][0] = 0;\\n\\n    while (!queue.isEmpty()) {\\n\\n        const current = queue.removeFront();\\n        if (current.row === this.rows - 1 && current.column === this.columns - 1) {\\n            break;\\n        }\\n\\n        for (let move of this.moves) {\\n            let nextRow = current.row + move[0];\\n            let nextColumn = current.column + move[1];\\n\\n            if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                const next = new Point(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                if (matrix[nextRow][nextColumn] === 0) {\\n                    queue.addFront(next);\\n                } else {\\n                    queue.addBack(next);\\n                }\\n            }\\n        }\\n    }\\n    return minRemovedObstacles[rows - 1][columns - 1];\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column \\n * @return {boolean}\\n */\\nfunction isInMatrix(row, column) {\\n    return row >= 0 && row < this.rows && column >= 0 && column < this.columns;\\n}\\n\\n/**\\n * @param {number} row\\n * @param {number} column \\n * @param {number} removedObstacles\\n */\\nfunction Point(row, column, removedObstacles) {\\n    this.row = row;\\n    this.column = column;\\n    this.removedObstacles = removedObstacles;\\n}\\n\\nfunction QueueNode(value) {\\n    this.value = value;\\n    this.next = null;\\n    this.previous = null;\\n}\\n\\nclass DoubleEndedQueue {\\n\\n    constructor() {\\n        this.size = 0;\\n        this.front = null;\\n        this.back = null;\\n    }\\n\\n    addFront(value) {\\n        let node = new QueueNode(value);\\n\\n        if (this.size === 0) {\\n            this.front = node;\\n            this.back = this.front;\\n        } else {\\n            this.front.previous = node;\\n            node.next = this.front;\\n            this.front = node;\\n        }\\n        ++this.size;\\n    }\\n\\n    addBack(value) {\\n        let node = new QueueNode(value);\\n\\n        if (this.size === 0) {\\n            this.back = node;\\n            this.front = this.back;\\n        } else {\\n            this.back.next = node;\\n            node.previous = this.back;\\n            this.back = node;\\n        }\\n        ++this.size;\\n    }\\n\\n    removeFront() {\\n        if (this.size === 0) {\\n            throw \"List is empty.\";\\n        }\\n\\n        let storeFront = this.front;\\n        if (--this.size > 0) {\\n            this.front = this.front.next;\\n            this.front.previous = null;\\n        } else {\\n            this.front = null;\\n            this.back = null;\\n        }\\n        return storeFront.value;\\n    }\\n\\n    removeBack() {\\n        if (this.size === 0) {\\n            throw \"List is empty.\";\\n        }\\n\\n        let storeBack = this.back;\\n        if (--this.size > 0) {\\n            this.back = this.back.previous;\\n            this.back.next = null;\\n        } else {\\n            this.front = null;\\n            this.back = null;\\n        }\\n        return storeBack.value;\\n    }\\n\\n    isEmpty() {\\n        return this.size === 0;\\n    }\\n}\\n```\n```\\n#include <array>\\n#include <queue>\\n#include <vector>\\nusing namespace std;\\n\\nstruct Point {\\n    \\n    int row{};\\n    int column{};\\n    int removedObstacles{};\\n    \\n    Point(int row, int column, int removedObstacles) : row {row}, column {column}, removedObstacles {removedObstacles}{}\\n\\n    Point() = default;\\n    virtual ~Point() = default; //virtual: no derived structs but for the sake of good practice.\\n\\n    Point(const Point& point) = default;\\n    Point& operator=(const Point& point) = default;\\n\\n    Point(Point&& point) noexcept = default;\\n    Point& operator=(Point&& point) noexcept = default;\\n};\\n\\nclass Solution {\\n    \\n    size_t rows;\\n    size_t columns;\\n    inline static const array<array<int, 2>, 4> moves{ {{-1, 0}, {1, 0}, {0, -1}, {0, 1}} };\\n\\npublic:\\n    int minimumObstacles(vector<vector<int>>& matrix) {\\n        rows = matrix.size();\\n        columns = matrix[0].size();\\n        return findPathWithMinObstaclesBy01BreadthFirstSearch(matrix);\\n    }\\n\\nprivate:\\n    int findPathWithMinObstaclesBy01BreadthFirstSearch(const vector<vector<int>>& matrix) {\\n        deque<Point> queue;\\n        queue.push_back(Point(0, 0, matrix[0][0]));\\n\\n        vector<vector<int>> minRemovedObstacles(rows, vector<int>(columns, INT_MAX));\\n        minRemovedObstacles[0][0] = 0;\\n\\n        while (!queue.empty()) {\\n\\n            Point current = queue.front();\\n            queue.pop_front();\\n\\n            if (current.row == rows - 1 && current.column == columns - 1) {\\n                break;\\n            }\\n\\n            for (const auto& move : moves) {\\n                int nextRow = current.row + move[0];\\n                int nextColumn = current.column + move[1];\\n\\n                if (isInMatrix(nextRow, nextColumn) && minRemovedObstacles[nextRow][nextColumn] > current.removedObstacles + matrix[nextRow][nextColumn]) {\\n                    Point next(nextRow, nextColumn, current.removedObstacles + matrix[nextRow][nextColumn]);\\n                    minRemovedObstacles[nextRow][nextColumn] = next.removedObstacles;\\n\\n                    if (matrix[nextRow][nextColumn] == 0) {\\n                        queue.push_front(next);\\n                    } else {\\n                        queue.push_back(next);\\n                    }\\n                }\\n            }\\n        }\\n        return minRemovedObstacles[rows - 1][columns - 1];\\n    }\\n\\n    bool isInMatrix(int row, int column) {\\n        return row >= 0 && row < rows && column >= 0 && column < columns;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2089402,
                "title": "simple-dijkastras-algorithm-using-priority-queue-c",
                "content": "class Solution {\\n    \\n    bool isSafe(int x,int y,int n,int m){\\n        \\n        if(x<0 or y<0 or x>=n or y>=m) return false;\\n        return true;\\n    }\\n    \\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        dist[0][0]=0;\\n        priority_queue <tuple<int,int,int>, vector<tuple<int,int,int>>, greater<tuple<int,int,int>> > pq; \\n        pq.push({0,0,0}); // weight , x cor, y cor\\n        \\n        while(!pq.empty()){\\n            \\n            int wt,x,y;\\n            tie(wt,x,y) = pq.top();\\n            pq.pop();\\n            if(isSafe(x-1,y,n,m) and dist[x-1][y]>wt+grid[x][y]){\\n                \\n                dist[x-1][y]=wt+grid[x][y];\\n                pq.push(make_tuple(dist[x-1][y],x-1,y));\\n            }\\n            \\n            if(isSafe(x+1,y,n,m) and dist[x+1][y]>wt+grid[x][y]){\\n                \\n                dist[x+1][y]=wt+grid[x][y];\\n                pq.push(make_tuple(dist[x+1][y],x+1,y));\\n            }\\n            \\n            if(isSafe(x,y-1,n,m) and dist[x][y-1]>wt+grid[x][y]){\\n                \\n                dist[x][y-1]=wt+grid[x][y];\\n                pq.push(make_tuple(dist[x][y-1],x,y-1));\\n            }\\n            \\n            if(isSafe(x,y+1,n,m) and dist[x][y+1]>wt+grid[x][y]){\\n                \\n                dist[x][y+1]=wt+grid[x][y];\\n                pq.push(make_tuple(dist[x][y+1],x,y+1));\\n            }\\n            \\n        }\\n        return dist[n-1][m-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    \\n    bool isSafe(int x,int y,int n,int m){\\n        \\n        if(x<0 or y<0 or x>=n or y>=m) return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2087604,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Priority Queue***\\n\\n* ***Time Complexity : O(N * M)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    struct node\\n    {\\n        int a;   // this will store minimum obstacle\\n        \\n        int b;   // this will store the x cordinate of cell\\n        \\n        int c;   // this will store the y cordinate of cell\\n        \\n        node(int x, int y, int z)\\n        {\\n            a = x;\\n            \\n            b = y;\\n            \\n            c = z;\\n        }\\n    };\\n    \\n    struct mycomp\\n    {\\n        bool operator() (node* &node1, node* &node2)\\n        {\\n            return node1 -> a > node2 -> a;\\n        }\\n    };\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        vector<int> dx = {-1, 0, 1, 0};\\n    \\n        vector<int> dy = {0, 1, 0, -1};\\n\\t\\t\\n\\t\\t// declare a min. heap\\n        \\n        priority_queue<node*, vector<node*>, mycomp> pq;\\n        \\n        node* new_node = new node(0, 0, 0);\\n        \\n        pq.push(new_node);\\n        \\n        grid[0][0] = -1;\\n        \\n        while(!pq.empty())\\n        {\\n            node* curr_node = pq.top();\\n            \\n            int min_obstacle = curr_node -> a;\\n            \\n            int x = curr_node -> b;\\n            \\n            int y = curr_node -> c;\\n            \\n            pq.pop();\\n\\t\\t\\t\\n\\t\\t\\t// if last cell is reached\\n            \\n            if(x == n - 1 && y == m - 1)\\n            {\\n                return min_obstacle;\\n            }\\n            \\n            for(int k = 0; k < 4; k++)\\n            {\\n                int new_row = x + dx[k];\\n                \\n                int new_col = y + dy[k];\\n                \\n                if(new_row >= 0 && new_col >= 0 && new_row < n && new_col < m && grid[new_row][new_col] != -1)\\n                {\\n                    node* new_node = new node(min_obstacle + grid[new_row][new_col], new_row, new_col);\\n                    \\n                    pq.push(new_node);\\n                    \\n                    grid[new_row][new_col] = -1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct node\\n    {\\n        int a;   // this will store minimum obstacle\\n        \\n        int b;   // this will store the x cordinate of cell\\n        \\n        int c;   // this will store the y cordinate of cell\\n        \\n        node(int x, int y, int z)\\n        {\\n            a = x;\\n            \\n            b = y;\\n            \\n            c = z;\\n        }\\n    };\\n    \\n    struct mycomp\\n    {\\n        bool operator() (node* &node1, node* &node2)\\n        {\\n            return node1 -> a > node2 -> a;\\n        }\\n    };\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        vector<int> dx = {-1, 0, 1, 0};\\n    \\n        vector<int> dy = {0, 1, 0, -1};\\n\\t\\t\\n\\t\\t// declare a min. heap\\n        \\n        priority_queue<node*, vector<node*>, mycomp> pq;\\n        \\n        node* new_node = new node(0, 0, 0);\\n        \\n        pq.push(new_node);\\n        \\n        grid[0][0] = -1;\\n        \\n        while(!pq.empty())\\n        {\\n            node* curr_node = pq.top();\\n            \\n            int min_obstacle = curr_node -> a;\\n            \\n            int x = curr_node -> b;\\n            \\n            int y = curr_node -> c;\\n            \\n            pq.pop();\\n\\t\\t\\t\\n\\t\\t\\t// if last cell is reached\\n            \\n            if(x == n - 1 && y == m - 1)\\n            {\\n                return min_obstacle;\\n            }\\n            \\n            for(int k = 0; k < 4; k++)\\n            {\\n                int new_row = x + dx[k];\\n                \\n                int new_col = y + dy[k];\\n                \\n                if(new_row >= 0 && new_col >= 0 && new_row < n && new_col < m && grid[new_row][new_col] != -1)\\n                {\\n                    node* new_node = new node(min_obstacle + grid[new_row][new_col], new_row, new_col);\\n                    \\n                    pq.push(new_node);\\n                    \\n                    grid[new_row][new_col] = -1;\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086041,
                "title": "dijkstra-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dx = {0, 0, 1, -1};\\n    vector<int> dy = {1, -1, 0, 0};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<int>> res(row, vector<int>(col, INT_MAX));\\n        res[0][0] = 0;\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, std::greater<tuple<int, int, int>>> pq;\\n        pq.push({grid[0][0], 0, 0});\\n        \\n        while (!pq.empty()) {\\n            auto [current, x, y] = pq.top();\\n            pq.pop();\\n            \\n            if (x == row - 1 && y == col - 1) {\\n                return current + grid[x][y]; // reached destination\\n            }\\n            \\n            for (int i = 0; i < 4; i++) {\\n                auto xx = x + dx[i];\\n                auto yy = y + dy[i];\\n                \\n                if (xx < 0 || yy < 0 || xx >= row || yy >= col) continue;\\n                \\n                if (res[xx][yy] > current + grid[xx][yy]) {\\n                    res[xx][yy] = current+ grid[xx][yy]; // new path more optimal\\n                    pq.push({current + grid[xx][yy], xx, yy});\\n                }\\n            }\\n        }\\n        \\n        return res[row - 1][col - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dx = {0, 0, 1, -1};\\n    vector<int> dy = {1, -1, 0, 0};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        vector<vector<int>> res(row, vector<int>(col, INT_MAX));\\n        res[0][0] = 0;\\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, std::greater<tuple<int, int, int>>> pq;\\n        pq.push({grid[0][0], 0, 0});\\n        \\n        while (!pq.empty()) {\\n            auto [current, x, y] = pq.top();\\n            pq.pop();\\n            \\n            if (x == row - 1 && y == col - 1) {\\n                return current + grid[x][y]; // reached destination\\n            }\\n            \\n            for (int i = 0; i < 4; i++) {\\n                auto xx = x + dx[i];\\n                auto yy = y + dy[i];\\n                \\n                if (xx < 0 || yy < 0 || xx >= row || yy >= col) continue;\\n                \\n                if (res[xx][yy] > current + grid[xx][yy]) {\\n                    res[xx][yy] = current+ grid[xx][yy]; // new path more optimal\\n                    pq.push({current + grid[xx][yy], xx, yy});\\n                }\\n            }\\n        }\\n        \\n        return res[row - 1][col - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086012,
                "title": "c-dijkstra-s-algorithm-easy-to-understand-clean-simple",
                "content": "In the given question, **Dijkstra Algo** can be used to solve it. \\n* Consider all the blockages as weights of value **1** and non blocked cells as weights of value **0**. \\n* Now consider the matrix as a graph with each node connected to up, down,left and right node.\\n* Now the question boils down to calculate the shortest sum of weight/dist from start node to end node.\\n\\n****\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(int i,int j,int n,int m)\\n    {\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        vector<vector<int>> dir= {{1,0},{-1,0},{0,1},{0,-1}}; //this would be used to traverse a node\\'s up, down, left and right\\n\\t\\t\\n\\t\\t//taking row and column size\\n        int n = grid.size();  \\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));  \\n        multiset< pair<int, pair<int,int>>> q; //{dist,{i,j}}\\n        //instead of multiset, priority queue can also be used\\n        \\n\\t\\t//Since source is (0,0) , the distance would be 0 for source \\n\\t\\tdist[0][0]=0;\\n        q.insert({0,{0,0}});\\n        \\n        while(!q.empty())\\n        {\\n            int nodeDist = (q.begin())->first;\\n            int nodex = (q.begin())->second.first;\\n            int nodey = (q.begin())->second.second;\\n            q.erase(q.begin());\\n            \\n            for(auto &it:dir)\\n            {\\n                int i = nodex + it[0];\\n                int j = nodey + it[1];\\n                if(isPossible(i,j,n,m))\\n                {\\n                    int childDist = grid[i][j];\\n                    if(nodeDist+childDist<dist[i][j])\\n                    {\\n                        dist[i][j]=nodeDist+childDist;\\n                        q.insert({dist[i][j],{i,j}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(int i,int j,int n,int m)\\n    {\\n        return i>=0 and j>=0 and i<n and j<m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        vector<vector<int>> dir= {{1,0},{-1,0},{0,1},{0,-1}}; //this would be used to traverse a node\\'s up, down, left and right\\n\\t\\t\\n\\t\\t//taking row and column size\\n        int n = grid.size();  \\n        int m = grid[0].size();\\n        \\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));  \\n        multiset< pair<int, pair<int,int>>> q; //{dist,{i,j}}\\n        //instead of multiset, priority queue can also be used\\n        \\n\\t\\t//Since source is (0,0) , the distance would be 0 for source \\n\\t\\tdist[0][0]=0;\\n        q.insert({0,{0,0}});\\n        \\n        while(!q.empty())\\n        {\\n            int nodeDist = (q.begin())->first;\\n            int nodex = (q.begin())->second.first;\\n            int nodey = (q.begin())->second.second;\\n            q.erase(q.begin());\\n            \\n            for(auto &it:dir)\\n            {\\n                int i = nodex + it[0];\\n                int j = nodey + it[1];\\n                if(isPossible(i,j,n,m))\\n                {\\n                    int childDist = grid[i][j];\\n                    if(nodeDist+childDist<dist[i][j])\\n                    {\\n                        dist[i][j]=nodeDist+childDist;\\n                        q.insert({dist[i][j],{i,j}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085884,
                "title": "using-0-1-bfs-and-obstacle-removal-simple-c-solution-with-comments",
                "content": "The idea is very similar to what we do in 0-1 BFS and Obstacle Elimination Questions.\\n\\nFor each cell we will mark the minimum no of obstacles broken by a path which passes through it. And if any other path visits which has broken lesser obstacles we allow it to visit the cell again else don\\'t.\\n\\nIn terms of adding cells to Queue we will give prefarance to cells which are already 0 and add them to front since they would not add anything to our answer similar to what we do in 0-1 bfs.\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n       int  m = grid.size();\\n       int n = grid[0].size();\\n       \\n        int vis[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++) vis[i][j] =-1;\\n        }\\n        // Creating a Deque since we need double sided insertion\\n        deque<pair<int,pair<int,int>>> q;\\n        q.push_front({0,{0,0}});\\n        int dx[]={1,0,-1,0};\\n        int dy[]={0,1,0,-1};\\n        while(!q.empty())\\n        {\\n            pair<int,pair<int,int>> p =q.front(); q.pop_front();\\n            \\n            if(p.second.first == m-1 && p.second.second == n-1)\\n            {\\n               return p.first; \\n              \\n            }\\n            \\n            int x=p.second.first; int y=p.second.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                \\n                if(nx>=0 && nx<m && ny>=0 && ny< n)\\n                {\\n\\t\\t\\t\\t// if the cell is empty\\n                    if(grid[nx][ny] == 0  && (vis[nx][ny]==-1 || vis[nx][ny] > p.first))\\n                    {\\n                        q.push_front({p.first,{nx,ny}});\\n                        vis[nx][ny]=p.first;\\n                    }\\n\\t\\t\\t\\t\\t// if cell has obstacle we will need to add 1 to answer.\\n                    else if(grid[nx][ny] ==1 && ((vis[nx][ny]==-1 || vis[nx][ny] > p.first+1)))\\n                    {\\n                        q.push_back({p.first+1,{nx,ny}});\\n                        vis[nx][ny]=p.first+1;\\n                    }\\n                }\\n            }\\n             \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n       int  m = grid.size();\\n       int n = grid[0].size();\\n       \\n        int vis[m][n];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++) vis[i][j] =-1;\\n        }\\n        // Creating a Deque since we need double sided insertion\\n        deque<pair<int,pair<int,int>>> q;\\n        q.push_front({0,{0,0}});\\n        int dx[]={1,0,-1,0};\\n        int dy[]={0,1,0,-1};\\n        while(!q.empty())\\n        {\\n            pair<int,pair<int,int>> p =q.front(); q.pop_front();\\n            \\n            if(p.second.first == m-1 && p.second.second == n-1)\\n            {\\n               return p.first; \\n              \\n            }\\n            \\n            int x=p.second.first; int y=p.second.second;\\n            for(int i=0;i<4;i++)\\n            {\\n                int nx=x+dx[i];\\n                int ny=y+dy[i];\\n                \\n                if(nx>=0 && nx<m && ny>=0 && ny< n)\\n                {\\n\\t\\t\\t\\t// if the cell is empty\\n                    if(grid[nx][ny] == 0  && (vis[nx][ny]==-1 || vis[nx][ny] > p.first))\\n                    {\\n                        q.push_front({p.first,{nx,ny}});\\n                        vis[nx][ny]=p.first;\\n                    }\\n\\t\\t\\t\\t\\t// if cell has obstacle we will need to add 1 to answer.\\n                    else if(grid[nx][ny] ==1 && ((vis[nx][ny]==-1 || vis[nx][ny] > p.first+1)))\\n                    {\\n                        q.push_back({p.first+1,{nx,ny}});\\n                        vis[nx][ny]=p.first+1;\\n                    }\\n                }\\n            }\\n             \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085875,
                "title": "c-priority-queue-bfs-easy-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        int arr[4]  = {1,-1,0,0};\\n        int brr[4] = {0,0,-1,1};\\n        int r = grid.size();\\n        int c = grid[0].size();\\n      priority_queue< pair<int,pair<int,int>>, vector<  pair<int,pair<int,int>>>, greater<>>pq;\\n       \\n        pq.push({0,{0,0}});\\n        grid[0][0]= -1;\\n        while(pq.size()>0)\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int an = it.first;\\n            int x  =it.second.first;\\n            int y  = it.second.second;\\n             if(x==r-1 && y==c-1)\\n                        return an;\\n                \\n            for(int  i = 0;i<4;i++)\\n            {\\n                int xx = x + arr[i];\\n                int yy = y  + brr[i];\\n                if(xx>=0 && xx<r && yy>=0 && yy<c && grid[xx][yy]!=-1)\\n                {\\n                    if(xx==r-1 && yy==c-1)\\n                        return an;\\n                    \\n                    if(grid[xx][yy]==0)\\n                    {\\n                        pq.push({an,{xx,yy}});\\n                    }\\n                    else if(grid[xx][yy]==1)\\n                    {\\n                        pq.push({an+1, {xx,yy}});\\n                    }\\n                    grid[xx][yy] = -1;\\n                    \\n                }\\n            }\\n           \\n        }\\n        return -1;\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        int arr[4]  = {1,-1,0,0};\\n        int brr[4] = {0,0,-1,1};\\n        int r = grid.size();\\n        int c = grid[0].size();\\n      priority_queue< pair<int,pair<int,int>>, vector<  pair<int,pair<int,int>>>, greater<>>pq;\\n       \\n        pq.push({0,{0,0}});\\n        grid[0][0]= -1;\\n        while(pq.size()>0)\\n        {\\n            auto it = pq.top();\\n            pq.pop();\\n            int an = it.first;\\n            int x  =it.second.first;\\n            int y  = it.second.second;\\n             if(x==r-1 && y==c-1)\\n                        return an;\\n                \\n            for(int  i = 0;i<4;i++)\\n            {\\n                int xx = x + arr[i];\\n                int yy = y  + brr[i];\\n                if(xx>=0 && xx<r && yy>=0 && yy<c && grid[xx][yy]!=-1)\\n                {\\n                    if(xx==r-1 && yy==c-1)\\n                        return an;\\n                    \\n                    if(grid[xx][yy]==0)\\n                    {\\n                        pq.push({an,{xx,yy}});\\n                    }\\n                    else if(grid[xx][yy]==1)\\n                    {\\n                        pq.push({an+1, {xx,yy}});\\n                    }\\n                    grid[xx][yy] = -1;\\n                    \\n                }\\n            }\\n           \\n        }\\n        return -1;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085797,
                "title": "dijkstra-s-algo-c",
                "content": "# **Only use Dijkstra\\'S with optimize ways:**\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int m=v[0].size();\\n        set<pair<int,pair<int,int>> >st;\\n        st.insert({v[0][0],{0,0}});\\n        \\n        int dx[]={-1,1,0,0};\\n        int dy[]={0,0,-1,1};\\n        \\n        int dis[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dis[i][j]=1e9;\\n            }\\n        }\\n        \\n        \\n        bool vis[n][m];\\n        memset(vis,false,sizeof(vis));\\n        while(!st.empty()){\\n            int x,y,w;\\n            auto it=st.begin();\\n            x=it->second.first;\\n            y=it->second.second;\\n            w=it->first;\\n            st.erase(st.begin());\\n            if(dis[x][y]<w) continue;\\n            if(vis[x][y]) continue;\\n            dis[x][y]=min(dis[x][y],w);\\n            if(x==n-1 and y==m-1) return w; \\n            vis[x][y]=true;\\n            for(int i=0;i<4;i++){\\n                int nx,ny;\\n                nx=x+dx[i];\\n                ny=y+dy[i];\\n                if(nx>=0 and ny>=0 and nx<n and ny<m){\\n                    if(dis[nx][ny]>w+v[nx][ny])\\n                    {st.insert({w+v[nx][ny],{nx,ny}}); dis[nx][ny]=w+v[nx][ny]; }\\n                }\\n            }\\n            \\n        }\\n        \\n        return dis[n-1][m-1];\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& v) {\\n        int n=v.size();\\n        int m=v[0].size();\\n        set<pair<int,pair<int,int>> >st;\\n        st.insert({v[0][0],{0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3913393,
                "title": "easy-to-understand-approach-using-simple-bfs-and-priority-queue",
                "content": "# Complexity\\n- Time complexity:\\n O(n * m)\\nn->Number of rows of the grid\\nm->Number of columns of the grid\\n\\n- Space complexity:\\nO(n * m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0)); //declare a visited array\\n        priority_queue<pair<int,pair<int,int>>,\\n        vector<pair<int,pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> q;\\n        q.push({0,{0,0}});\\n        vis[0][0]=1;\\n        while(!q.empty()){\\n            int wt=q.top().first;\\n            int r=q.top().second.first;\\n            int c=q.top().second.second;\\n            q.pop();\\n            if(r==n-1 && c== m-1) return wt; //return weight if the final cell is found\\n            int dir[]={-1,1,0,0};//direction array for row\\n            int dic[]={0,0,1,-1};//direction array for column\\n            for(int i=0;i<4;i++){\\n                int row=dir[i]+r;\\n                int col=dic[i]+c;\\n                if(row>=0 && row<n && col>=0 && col<m && \\n                !vis[row][col]){\\n    //(wt+grid[row][col]) denotes the weight of the next cell \\n                q.push({wt+grid[row][col],{row,col}});\\n                vis[row][col]=1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0)); //declare a visited array\\n        priority_queue<pair<int,pair<int,int>>,\\n        vector<pair<int,pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> q;\\n        q.push({0,{0,0}});\\n        vis[0][0]=1;\\n        while(!q.empty()){\\n            int wt=q.top().first;\\n            int r=q.top().second.first;\\n            int c=q.top().second.second;\\n            q.pop();\\n            if(r==n-1 && c== m-1) return wt; //return weight if the final cell is found\\n            int dir[]={-1,1,0,0};//direction array for row\\n            int dic[]={0,0,1,-1};//direction array for column\\n            for(int i=0;i<4;i++){\\n                int row=dir[i]+r;\\n                int col=dic[i]+c;\\n                if(row>=0 && row<n && col>=0 && col<m && \\n                !vis[row][col]){\\n    //(wt+grid[row][col]) denotes the weight of the next cell \\n                q.push({wt+grid[row][col],{row,col}});\\n                vis[row][col]=1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841206,
                "title": "hhm-simple-dijkstra-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDijkstra according to no of obstacles\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake dist[] array which contains no of obstacles till each coordinate in the path and apply dijkstra accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//dijkstra according to no of obstacles\\n//make dist[] array which contains no of obstacles till each coordinate in the path\\n\\nclass Solution {\\n    class tuple{\\n        int a,b,c;\\n        tuple(int a,int b,int c){\\n            this.a=a;\\n            this.b=b;\\n            this.c=c;\\n        }\\n    }\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int dist[][]=new int[m][n];\\n        for(int i[]:dist){\\n            Arrays.fill(i,1000000);\\n        }\\n        dist[0][0]=0;\\n        //(number of Obstacles removed till then,x,y)\\n        PriorityQueue<tuple>q=new PriorityQueue<>((z,v)->z.a-v.a);\\n        q.offer(new tuple(0,0,0));\\n        int rx[]={-1,1,0,0};\\n        int ry[]={0,0,-1,1};\\n        while(!q.isEmpty()){\\n            tuple t=q.poll();\\n            for(int i=0;i<4;i++)\\n            {\\n                int x=rx[i]+t.b;\\n                int y=ry[i]+t.c;\\n                if(x>=0&&y>=0&&x<m&&y<n){\\n                    if(grid[x][y]==0){\\n                        if(dist[x][y]>t.a){\\n                        dist[x][y]=t.a;\\n                        q.offer(new tuple(dist[x][y],x,y));\\n                        }\\n                    }\\n                    else{\\n                        if(dist[x][y]>t.a+1){\\n                            dist[x][y]=t.a+1;\\n                            q.offer(new tuple(dist[x][y],x,y));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//dijkstra according to no of obstacles\\n//make dist[] array which contains no of obstacles till each coordinate in the path\\n\\nclass Solution {\\n    class tuple{\\n        int a,b,c;\\n        tuple(int a,int b,int c){\\n            this.a=a;\\n            this.b=b;\\n            this.c=c;\\n        }\\n    }\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length,n=grid[0].length;\\n        int dist[][]=new int[m][n];\\n        for(int i[]:dist){\\n            Arrays.fill(i,1000000);\\n        }\\n        dist[0][0]=0;\\n        //(number of Obstacles removed till then,x,y)\\n        PriorityQueue<tuple>q=new PriorityQueue<>((z,v)->z.a-v.a);\\n        q.offer(new tuple(0,0,0));\\n        int rx[]={-1,1,0,0};\\n        int ry[]={0,0,-1,1};\\n        while(!q.isEmpty()){\\n            tuple t=q.poll();\\n            for(int i=0;i<4;i++)\\n            {\\n                int x=rx[i]+t.b;\\n                int y=ry[i]+t.c;\\n                if(x>=0&&y>=0&&x<m&&y<n){\\n                    if(grid[x][y]==0){\\n                        if(dist[x][y]>t.a){\\n                        dist[x][y]=t.a;\\n                        q.offer(new tuple(dist[x][y],x,y));\\n                        }\\n                    }\\n                    else{\\n                        if(dist[x][y]>t.a+1){\\n                            dist[x][y]=t.a+1;\\n                            q.offer(new tuple(dist[x][y],x,y));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834388,
                "title": "java-easy-just-like-shortest-path",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n\\n\\n\\n\\n\\n```\\n//<---------DFS  ---- TLE ----approach>\\n\\nclass Solution {\\n    int min_removal= Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(0,0,grid,0,visited);\\n        return min_removal;\\n    }\\n    public void  dfs(int i,int j, int[][] grid,int count,boolean[][] visited)\\n \\n        // if we are on the last index then we will return min removal\\n        \\n        if(i<0 ||  j<0 || i>=grid.length || j>=grid[0].length || visited[i][j]==true){\\n            return;\\n        }\\n        if(i==grid.length-1 && j==grid[0].length-1){\\n            min_removal = Math.min(min_removal,count);\\n            return;\\n        }\\n        visited[i][j]= true;\\n        //we can remove as much obstcale we can but we need to return minimum;\\n        if(grid[i][j]==1){\\n            count++;\\n        }\\n        //dfs\\n        dfs(i+1,j,grid,count,visited);\\n        dfs(i-1,j,grid,count,visited);\\n        dfs(i,j+1,grid,count,visited);\\n        dfs(i,j-1,grid,count,visited);\\n        visited[i][j] = false;\\n\\n    }\\n}\\n\\n\\n\\n\\n//<-----------------------Bfs approach --------------------->\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public class pair{\\n        int r;\\n        int c;\\n        int val;\\n        pair(int r,int c,int val){\\n            this.r = r;\\n            this.c = c;\\n            this.val = val;\\n        }\\n    }\\n    int min = Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        //The shortest number of removal we can go for it\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b)->a.val-b.val);\\n    \\n        pq.add(new pair(0,0,0));\\n        while(!pq.isEmpty()){\\n            pair rs =pq.poll();\\n            int i = rs.r;\\n            int j  = rs.c;\\n            int step =rs.val;\\n            if(i==grid.length-1 && j==grid[0].length-1){\\n                min = Math.min(min,step);\\n            }\\n            if(isValid(i+1,j,grid,visited)){\\n                visited[i+1][j]=true;\\n                if(grid[i+1][j]==1){\\n                    pq.add(new pair(i+1,j,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i+1,j,step));\\n                }\\n            }\\n            if(isValid(i-1,j,grid,visited)){\\n                visited[i-1][j]=true;\\n                if(grid[i-1][j]==1){\\n                    pq.add(new pair(i-1,j,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i-1,j,step));\\n                }\\n            }\\n            if(isValid(i,j+1,grid,visited)){\\n                visited[i][j+1]=true;\\n                if(grid[i][j+1]==1){\\n                    pq.add(new pair(i,j+1,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i,j+1,step));\\n                }\\n            }\\n            if(isValid(i,j-1,grid,visited)){\\n                visited[i][j-1]=true;\\n                if(grid[i][j-1]==1){\\n                    pq.add(new pair(i,j-1,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i,j-1,step));\\n                }\\n            }\\n        }\\n        return min;\\n\\n        \\n    }\\n    public boolean isValid(int i,int j, int[][] grid,boolean[][] visited){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || visited[i][j]==true){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n//<---------DFS  ---- TLE ----approach>\\n\\nclass Solution {\\n    int min_removal= Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        dfs(0,0,grid,0,visited);\\n        return min_removal;\\n    }\\n    public void  dfs(int i,int j, int[][] grid,int count,boolean[][] visited)\\n \\n        // if we are on the last index then we will return min removal\\n        \\n        if(i<0 ||  j<0 || i>=grid.length || j>=grid[0].length || visited[i][j]==true){\\n            return;\\n        }\\n        if(i==grid.length-1 && j==grid[0].length-1){\\n            min_removal = Math.min(min_removal,count);\\n            return;\\n        }\\n        visited[i][j]= true;\\n        //we can remove as much obstcale we can but we need to return minimum;\\n        if(grid[i][j]==1){\\n            count++;\\n        }\\n        //dfs\\n        dfs(i+1,j,grid,count,visited);\\n        dfs(i-1,j,grid,count,visited);\\n        dfs(i,j+1,grid,count,visited);\\n        dfs(i,j-1,grid,count,visited);\\n        visited[i][j] = false;\\n\\n    }\\n}\\n\\n\\n\\n\\n//<-----------------------Bfs approach --------------------->\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public class pair{\\n        int r;\\n        int c;\\n        int val;\\n        pair(int r,int c,int val){\\n            this.r = r;\\n            this.c = c;\\n            this.val = val;\\n        }\\n    }\\n    int min = Integer.MAX_VALUE;\\n    public int minimumObstacles(int[][] grid) {\\n        //The shortest number of removal we can go for it\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        PriorityQueue<pair> pq = new PriorityQueue<>((a,b)->a.val-b.val);\\n    \\n        pq.add(new pair(0,0,0));\\n        while(!pq.isEmpty()){\\n            pair rs =pq.poll();\\n            int i = rs.r;\\n            int j  = rs.c;\\n            int step =rs.val;\\n            if(i==grid.length-1 && j==grid[0].length-1){\\n                min = Math.min(min,step);\\n            }\\n            if(isValid(i+1,j,grid,visited)){\\n                visited[i+1][j]=true;\\n                if(grid[i+1][j]==1){\\n                    pq.add(new pair(i+1,j,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i+1,j,step));\\n                }\\n            }\\n            if(isValid(i-1,j,grid,visited)){\\n                visited[i-1][j]=true;\\n                if(grid[i-1][j]==1){\\n                    pq.add(new pair(i-1,j,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i-1,j,step));\\n                }\\n            }\\n            if(isValid(i,j+1,grid,visited)){\\n                visited[i][j+1]=true;\\n                if(grid[i][j+1]==1){\\n                    pq.add(new pair(i,j+1,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i,j+1,step));\\n                }\\n            }\\n            if(isValid(i,j-1,grid,visited)){\\n                visited[i][j-1]=true;\\n                if(grid[i][j-1]==1){\\n                    pq.add(new pair(i,j-1,step+1));\\n                }\\n                else{\\n                    pq.add(new pair(i,j-1,step));\\n                }\\n            }\\n        }\\n        return min;\\n\\n        \\n    }\\n    public boolean isValid(int i,int j, int[][] grid,boolean[][] visited){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || visited[i][j]==true){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738536,
                "title": "fast-compact-elegant-and-clean-dijkstra-solution",
                "content": "The idea is to consider obstacles as cells having weights of 1 and others as 0.\\nThen simply find the shortest path to the bottom-right corner using the weight as priority(essence of dijkstra)\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int row = grid.size(), col = grid[0].size(), oo = INT_MAX;\\n        using T = tuple<int, int, int>;\\n        \\n        vector<pair<int, int> > directions = { {0,1}, {0,-1}, {1,0}, {-1,0} };\\n        vector<vector<int>>distance(row, vector<int>(col, oo));\\n        priority_queue<T, vector<T>, greater<T>> pq;\\n        \\n        pq.push({0,0,0});\\n        distance[0][0] = 0;\\n        \\n        while(!pq.empty()){\\n             \\n            auto [dist, r, c] = pq.top();  pq.pop();\\n            \\n            if(row-1 ==r and col-1 == c)return dist;\\n            \\n            if(distance[r][c] != dist) continue;\\n            \\n            for(auto& dir : directions){\\n                  int x = dir.first + r, y = dir.second + c;\\n                  if(min(x,y) < 0 or x >=row or y>= col) continue;\\n                  \\n                  if(dist + grid[x][y] < distance[x][y]){\\n                       pq.push({distance[x][y] = dist + grid[x][y], x, y});\\n                  }\\n            }\\n        }\\n        \\n        return distance[row-1][col-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int row = grid.size(), col = grid[0].size(), oo = INT_MAX;\\n        using T = tuple<int, int, int>;\\n        \\n        vector<pair<int, int> > directions = { {0,1}, {0,-1}, {1,0}, {-1,0} };\\n        vector<vector<int>>distance(row, vector<int>(col, oo));\\n        priority_queue<T, vector<T>, greater<T>> pq;\\n        \\n        pq.push({0,0,0});\\n        distance[0][0] = 0;\\n        \\n        while(!pq.empty()){\\n             \\n            auto [dist, r, c] = pq.top();  pq.pop();\\n            \\n            if(row-1 ==r and col-1 == c)return dist;\\n            \\n            if(distance[r][c] != dist) continue;\\n            \\n            for(auto& dir : directions){\\n                  int x = dir.first + r, y = dir.second + c;\\n                  if(min(x,y) < 0 or x >=row or y>= col) continue;\\n                  \\n                  if(dist + grid[x][y] < distance[x][y]){\\n                       pq.push({distance[x][y] = dist + grid[x][y], x, y});\\n                  }\\n            }\\n        }\\n        \\n        return distance[row-1][col-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730827,
                "title": "shortest-paths-problem-0-1-bfs-easy-to-understand",
                "content": "**Intuition and Approach :** \\nImagine the problem as the obstacles in the path are the weights and we have to find the path with lowest weight aka the shortest path . Then it reduces down to shortest path problem in a weighted graph where you can apply dijsktra or further optimize it by 0-1 BFS because we just have 0 and 1 weighted paths .\\nSo we can get our answer in TC of O(n*m) and also space complexity is O(n*m) for storing the levels and for our deque .\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i , int j , vector<vector<int>>&grid){\\n         return (i >= 0 && j >= 0 && i < grid.size() && j < grid[0].size());\\n    }\\n    \\n    int X[4] = {0,0,1,-1};\\n    int Y[4] = {1,-1,0,0};\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size() ;\\n        \\n        deque<pair<int,int>> dq ;\\n        \\n        vector<int>level(m*n,1e6);\\n        \\n        vector<vector<int>> mp(n , vector<int>(m , 0));\\n        \\n        int k = 0 ;\\n        for(int i=0 ; i<n ; ++i){\\n            for(int j=0 ; j<m ; ++j){\\n                mp[i][j] = k++;\\n            }\\n        }\\n        \\n        \\n        dq.push_back({0,0});\\n        level[mp[0][0]] = 0 ; \\n        \\n        while(!dq.empty()){\\n            auto curr = dq.front(); \\n            int x = curr.first , y = curr.second ;\\n            dq.pop_front();\\n            if(x == n-1 && y == m-1) return level[mp[n-1][m-1]];\\n            \\n            for(int i = 0 ; i < 4 ; ++i){\\n                int newx = x + X[i] , newy = y + Y[i] ;\\n                if(isValid(newx,newy,grid)){\\n                    if(level[mp[x][y]] + grid[newx][newy] < level[mp[newx][newy]]){\\n                        \\n                        level[mp[newx][newy]] = level[mp[x][y]] + grid[newx][newy];\\n                        \\n                        if(grid[newx][newy] == 1){\\n                            dq.push_back({newx,newy});\\n                        }else{\\n                            dq.push_front({newx,newy});\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return level[mp[n-1][m-1]];\\n        \\n        \\n        \\n    }\\n};\\n```\\n\\n**For Further Reading:** https://cp-algorithms.com/graph/01_bfs.html\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int i , int j , vector<vector<int>>&grid){\\n         return (i >= 0 && j >= 0 && i < grid.size() && j < grid[0].size());\\n    }\\n    \\n    int X[4] = {0,0,1,-1};\\n    int Y[4] = {1,-1,0,0};\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size() , m = grid[0].size() ;\\n        \\n        deque<pair<int,int>> dq ;\\n        \\n        vector<int>level(m*n,1e6);\\n        \\n        vector<vector<int>> mp(n , vector<int>(m , 0));\\n        \\n        int k = 0 ;\\n        for(int i=0 ; i<n ; ++i){\\n            for(int j=0 ; j<m ; ++j){\\n                mp[i][j] = k++;\\n            }\\n        }\\n        \\n        \\n        dq.push_back({0,0});\\n        level[mp[0][0]] = 0 ; \\n        \\n        while(!dq.empty()){\\n            auto curr = dq.front(); \\n            int x = curr.first , y = curr.second ;\\n            dq.pop_front();\\n            if(x == n-1 && y == m-1) return level[mp[n-1][m-1]];\\n            \\n            for(int i = 0 ; i < 4 ; ++i){\\n                int newx = x + X[i] , newy = y + Y[i] ;\\n                if(isValid(newx,newy,grid)){\\n                    if(level[mp[x][y]] + grid[newx][newy] < level[mp[newx][newy]]){\\n                        \\n                        level[mp[newx][newy]] = level[mp[x][y]] + grid[newx][newy];\\n                        \\n                        if(grid[newx][newy] == 1){\\n                            dq.push_back({newx,newy});\\n                        }else{\\n                            dq.push_front({newx,newy});\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return level[mp[n-1][m-1]];\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915997,
                "title": "using-set-similar-like-dijkastra",
                "content": "# Intuition\\nbasically i saw the hint in te box ..\\n\\n# Approach\\nmaking a graph with nodes as matrix points and edges cost is the matrix value and now using dijkastra algortihm like approach. Here the only different thing i did was to use a single dimensional array instead of a multidimensional array.\\n\\n# Complexity\\n- Time complexity:\\nnlogn\\n\\n- Space complexity:\\nm*n \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n      int m=grid.size();\\n      int n=grid[0].size();\\n      int i,j;\\n      vector<vector<pair< int, int> >> adj(m*n);\\n\\n      for(i=0;i<m;i++){\\n          for(j=0;j<n;j++){\\n      \\n      int c=n*i+j;\\n    \\n           if(i!=0){\\n            adj[c].push_back(make_pair(grid[i-1][j],n*(i-1)+j));\\n           }\\n           if(i!=m-1){\\n           adj[c].push_back(make_pair(grid[i+1][j],n*(i+1)+j));\\n           }\\n           if(j!=0){\\n           adj[c].push_back(make_pair(grid[i][j-1],n*i+j-1));\\n           }\\n           if(j!=n-1){\\n           adj[c].push_back(make_pair(grid[i][j+1],n*i+j+1 ));\\n           }\\n\\n          }\\n      }\\n\\n      set<pair<int,int>> s;\\n      \\n      s.insert(make_pair(0,0));\\n      vector<int> visited(m*n);\\n      for(i=0;i<m*n;i++){\\n          visited[i]=0;\\n      }\\n      visited[0]=1;\\n    \\n      while(s.empty()!=1){\\n       \\n       pair<int,int> p=*(s.begin());\\n\\n       visited[p.second]=1;\\n       if(p.second==m*n-1){\\n           return p.first;\\n       }\\n       s.erase(s.begin());\\n      for(j=0;j<adj[p.second].size();j++){\\n\\n         \\n           if(visited[adj[p.second][j].second]==0){\\n             s.insert(make_pair(p.first+adj[p.second][j].first,adj[p.second][j].second));\\n            \\n           }\\n      }\\n\\n\\n      }\\n\\n\\n     return (n+m-3);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n      int m=grid.size();\\n      int n=grid[0].size();\\n      int i,j;\\n      vector<vector<pair< int, int> >> adj(m*n);\\n\\n      for(i=0;i<m;i++){\\n          for(j=0;j<n;j++){\\n      \\n      int c=n*i+j;\\n    \\n           if(i!=0){\\n            adj[c].push_back(make_pair(grid[i-1][j],n*(i-1)+j));\\n           }\\n           if(i!=m-1){\\n           adj[c].push_back(make_pair(grid[i+1][j],n*(i+1)+j));\\n           }\\n           if(j!=0){\\n           adj[c].push_back(make_pair(grid[i][j-1],n*i+j-1));\\n           }\\n           if(j!=n-1){\\n           adj[c].push_back(make_pair(grid[i][j+1],n*i+j+1 ));\\n           }\\n\\n          }\\n      }\\n\\n      set<pair<int,int>> s;\\n      \\n      s.insert(make_pair(0,0));\\n      vector<int> visited(m*n);\\n      for(i=0;i<m*n;i++){\\n          visited[i]=0;\\n      }\\n      visited[0]=1;\\n    \\n      while(s.empty()!=1){\\n       \\n       pair<int,int> p=*(s.begin());\\n\\n       visited[p.second]=1;\\n       if(p.second==m*n-1){\\n           return p.first;\\n       }\\n       s.erase(s.begin());\\n      for(j=0;j<adj[p.second].size();j++){\\n\\n         \\n           if(visited[adj[p.second][j].second]==0){\\n             s.insert(make_pair(p.first+adj[p.second][j].first,adj[p.second][j].second));\\n            \\n           }\\n      }\\n\\n\\n      }\\n\\n\\n     return (n+m-3);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698821,
                "title": "tc-93-simple-dijkstra-python",
                "content": "```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n    #find the min cost path from (0,0) to (m-1, n-1)\\n    m = len(grid); n = len(grid[0])\\n    \\n    heap = [[grid[0][0], 0, 0]]\\n    visited = [[0]*n for _ in range(m)]\\n    visited[0][0] = 1\\n    while heap:\\n        c_cost, c_i, c_j = heappop(heap)\\n        if (c_i,c_j) == (m-1,n-1):\\n            return c_cost\\n        for n_i,n_j in [[c_i-1,c_j], [c_i,c_j+1], [c_i+1,c_j], [c_i,c_j-1]]:\\n            if 0<=n_i<m and 0<=n_j<n and not visited[n_i][n_j]:\\n                visited[n_i][n_j] = 1\\n                heappush(heap, [c_cost + grid[n_i][n_j], n_i, n_j])\\n    \\n    return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n    #find the min cost path from (0,0) to (m-1, n-1)\\n    m = len(grid); n = len(grid[0])\\n    \\n    heap = [[grid[0][0], 0, 0]]\\n    visited = [[0]*n for _ in range(m)]\\n    visited[0][0] = 1\\n    while heap:\\n        c_cost, c_i, c_j = heappop(heap)\\n        if (c_i,c_j) == (m-1,n-1):\\n            return c_cost\\n        for n_i,n_j in [[c_i-1,c_j], [c_i,c_j+1], [c_i+1,c_j], [c_i,c_j-1]]:\\n            if 0<=n_i<m and 0<=n_j<n and not visited[n_i][n_j]:\\n                visited[n_i][n_j] = 1\\n                heappush(heap, [c_cost + grid[n_i][n_j], n_i, n_j])\\n    \\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2332889,
                "title": "faster-than-94-dijkastras-python",
                "content": "![image](https://assets.leetcode.com/users/images/6a346351-6041-471a-ae66-2dd6e49e4f96_1658769406.335623.png)\\n```\\nclass Solution:\\n    def minimumObstacles(self, g: List[List[int]]) -> int:\\n        n=len(g)\\n        m=len(g[0])\\n        d=[(0,0,0)]\\n        heapify(d)\\n        v={(0,0):0}\\n        while d:\\n            w,x,y=heappop(d)\\n            if x==n-1 and y==m-1:\\n                return w\\n            for i,j in [(1,0),(-1,0),(0,1),(0,-1)]:\\n                o=i+x\\n                p=j+y\\n                if o<n and p<m and o>=0 and p>=0 and (o,p)not in v:\\n                    v[(o,p)]=0\\n                    heappush(d,(g[o][p]+w,o,p))",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minimumObstacles(self, g: List[List[int]]) -> int:\\n        n=len(g)\\n        m=len(g[0])\\n        d=[(0,0,0)]\\n        heapify(d)\\n        v={(0,0):0}",
                "codeTag": "Java"
            },
            {
                "id": 2313936,
                "title": "python3-dijkstra-s-algo",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7a598e64fb507fc966a3025d8edd0c8e7caf0bec) for solutions of weekly 295. \\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dist = [[inf]*n for _ in range(m)]\\n        dist[0][0] = 0\\n        pq = [(0, 0, 0)]\\n        while pq: \\n            x, i, j = heappop(pq)\\n            if i == m-1 and j == n-1: return x\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and x + grid[ii][jj] < dist[ii][jj]: \\n                    dist[ii][jj] = x + grid[ii][jj]\\n                    heappush(pq, (dist[ii][jj], ii, jj))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dist = [[inf]*n for _ in range(m)]\\n        dist[0][0] = 0\\n        pq = [(0, 0, 0)]\\n        while pq: \\n            x, i, j = heappop(pq)\\n            if i == m-1 and j == n-1: return x\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and x + grid[ii][jj] < dist[ii][jj]: \\n                    dist[ii][jj] = x + grid[ii][jj]\\n                    heappush(pq, (dist[ii][jj], ii, jj))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303474,
                "title": "c-0-1-bfs-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n       \\n        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n, 0));\\n        deque<pair<int, int>> q;\\n        \\n        q.push_front({0, 0});\\n        dp[0][0] = 0;\\n        \\n        int dx[] = {1, -1, 0, 0};\\n        int dy[] = {0, 0, 1, -1};\\n        \\n        while (!q.empty())\\n        {\\n            pair<int, int> p = q.front();\\n            q.pop_front();\\n            \\n            int x = p.first, y = p.second;\\n            for (int i = 0; i < 4; i++)\\n            {\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if (xx >= 0 && yy >= 0 && xx < m && yy < n)\\n                {\\n                    if(!vis[xx][yy])\\n                    {\\n                        dp[xx][yy] = dp[x][y] + (grid[xx][yy] == 1);\\n                        grid[xx][yy] ? q.push_back({xx, yy}) : q.push_front({xx, yy});\\n                    }\\n                    vis[xx][yy] = true;\\n                }    \\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        int m = grid.size(), n = grid[0].size();\\n       \\n        vector<vector<int>> dp(m, vector<int>(n, INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n, 0));\\n        deque<pair<int, int>> q;\\n        \\n        q.push_front({0, 0});\\n        dp[0][0] = 0;\\n        \\n        int dx[] = {1, -1, 0, 0};\\n        int dy[] = {0, 0, 1, -1};\\n        \\n        while (!q.empty())\\n        {\\n            pair<int, int> p = q.front();\\n            q.pop_front();\\n            \\n            int x = p.first, y = p.second;\\n            for (int i = 0; i < 4; i++)\\n            {\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if (xx >= 0 && yy >= 0 && xx < m && yy < n)\\n                {\\n                    if(!vis[xx][yy])\\n                    {\\n                        dp[xx][yy] = dp[x][y] + (grid[xx][yy] == 1);\\n                        grid[xx][yy] ? q.push_back({xx, yy}) : q.push_front({xx, yy});\\n                    }\\n                    vis[xx][yy] = true;\\n                }    \\n            }\\n        }\\n        return dp[m - 1][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300713,
                "title": "c-dijkastras",
                "content": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {1 , 0 , -1 , 0};\\n    int dy[4] = {0 , 1 , 0 , -1};\\n    int minimumObstacles(vector<vector<int>> &a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        priority_queue<pair<int , pair<int , int>> , vector<pair<int , pair<int , int>>> , greater<pair<int , pair<int , int>>>> q;\\n        vector<vector<int>> dist(n , vector<int>(m , 1e9));\\n        dist[0][0] = 0;\\n        q.push({0 , {0 , 0}});\\n        while(!q.empty()) {\\n            pair<int , pair<int , int>> p = q.top();\\n            q.pop();\\n            int cost = p.first;\\n            int x = p.second.first , y = p.second.second;\\n            for(int i=0 ; i<4 ; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                if(nx >= 0 && ny >= 0 && nx < n && ny < m) {\\n                    if(a[nx][ny] && dist[nx][ny] > cost + 1) {\\n                        dist[nx][ny] = cost + 1;\\n                        q.push({cost + 1 , {nx , ny}});\\n                    } else if(!a[nx][ny] && dist[nx][ny] > cost) {\\n                        dist[nx][ny] = cost;\\n                        q.push({cost , {nx , ny}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4] = {1 , 0 , -1 , 0};\\n    int dy[4] = {0 , 1 , 0 , -1};\\n    int minimumObstacles(vector<vector<int>> &a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        priority_queue<pair<int , pair<int , int>> , vector<pair<int , pair<int , int>>> , greater<pair<int , pair<int , int>>>> q;\\n        vector<vector<int>> dist(n , vector<int>(m , 1e9));\\n        dist[0][0] = 0;\\n        q.push({0 , {0 , 0}});\\n        while(!q.empty()) {\\n            pair<int , pair<int , int>> p = q.top();\\n            q.pop();\\n            int cost = p.first;\\n            int x = p.second.first , y = p.second.second;\\n            for(int i=0 ; i<4 ; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                if(nx >= 0 && ny >= 0 && nx < n && ny < m) {\\n                    if(a[nx][ny] && dist[nx][ny] > cost + 1) {\\n                        dist[nx][ny] = cost + 1;\\n                        q.push({cost + 1 , {nx , ny}});\\n                    } else if(!a[nx][ny] && dist[nx][ny] > cost) {\\n                        dist[nx][ny] = cost;\\n                        q.push({cost , {nx , ny}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253061,
                "title": "python-bfs-min-heap",
                "content": "```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\t# 1) Set variables: BFS related variables:\\n\\tROWS, COLS = len(grid), len(grid[0])\\n\\tdirections = [[0,1], [0,-1], [1,0], [-1,0]]\\n\\tdestination = (ROWS-1, COLS-1)\\n\\tvisited = set()\\n\\tqueue = []          \\n\\n\\t# 2) Initiate variables:\\n\\t# row, col, and obstacles:\\n\\tqueue.append((0, 0, 0))\\n\\tvisited.add((0, 0))\\n\\n\\t# Create min heap:\\n\\theapq.heapify(queue)\\n\\n\\t# 3) Perform BFS loop:\\n\\twhile queue:\\n\\t\\t# a) Unpack data from heap:\\n\\t\\tobsc, row, col = heapq.heappop(queue)\\n\\n\\t\\t# a) Check if destination is reached:\\n\\t\\tif (row, col) == destination:\\n\\t\\t\\treturn obsc\\n\\n\\t\\t# b) Explore neighbour directions:\\n\\t\\tfor rd, cd in directions:\\n\\t\\t\\tr = rd + row\\n\\t\\t\\tc = cd + col\\n\\n\\t\\t\\t# c) Check boundaries and visited cells:\\n\\t\\t\\tif r in range(0, ROWS) and c in range(0, COLS) and (r, c) not in visited:\\n\\t\\t\\t\\t# Increase number of obstacles to remove if\\n\\t\\t\\t\\t# any of the neighbour cells is an obstacle:\\n\\t\\t\\t\\tnewObsc = obsc + grid[r][c]\\n\\n\\t\\t\\t\\t# Add new number of obstacles, if any, to\\n\\t\\t\\t\\t# min heap so it will be sorted accordingly:\\n\\t\\t\\t\\theapq.heappush(queue, (newObsc, r, c))\\n\\t\\t\\t\\tvisited.add((r, c))\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\t# 1) Set variables: BFS related variables:\\n\\tROWS, COLS = len(grid), len(grid[0])\\n\\tdirections = [[0,1], [0,-1], [1,0], [-1,0]]\\n\\tdestination = (ROWS-1, COLS-1)\\n\\tvisited = set()\\n\\tqueue = []          \\n\\n\\t# 2) Initiate variables:\\n\\t# row, col, and obstacles:\\n\\tqueue.append((0, 0, 0))\\n\\tvisited.add((0, 0))\\n\\n\\t# Create min heap:\\n\\theapq.heapify(queue)\\n\\n\\t# 3) Perform BFS loop:\\n\\twhile queue:\\n\\t\\t# a) Unpack data from heap:\\n\\t\\tobsc, row, col = heapq.heappop(queue)\\n\\n\\t\\t# a) Check if destination is reached:\\n\\t\\tif (row, col) == destination:\\n\\t\\t\\treturn obsc\\n\\n\\t\\t# b) Explore neighbour directions:\\n\\t\\tfor rd, cd in directions:\\n\\t\\t\\tr = rd + row\\n\\t\\t\\tc = cd + col\\n\\n\\t\\t\\t# c) Check boundaries and visited cells:\\n\\t\\t\\tif r in range(0, ROWS) and c in range(0, COLS) and (r, c) not in visited:\\n\\t\\t\\t\\t# Increase number of obstacles to remove if\\n\\t\\t\\t\\t# any of the neighbour cells is an obstacle:\\n\\t\\t\\t\\tnewObsc = obsc + grid[r][c]\\n\\n\\t\\t\\t\\t# Add new number of obstacles, if any, to\\n\\t\\t\\t\\t# min heap so it will be sorted accordingly:\\n\\t\\t\\t\\theapq.heappush(queue, (newObsc, r, c))\\n\\t\\t\\t\\tvisited.add((r, c))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2175710,
                "title": "python-easy-to-read-and-undertand-01-bfs",
                "content": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == 0:\\n            q = [(0, 0, 0)]\\n        else:\\n            q = [(0, 0, 1)]\\n        visit = set()\\n        \\n        while q:\\n            cost, x, y = q.pop(0)\\n            #print(x, y, cost)\\n            if x == m-1 and y == n-1:\\n                return cost\\n            if x > 0 and (x-1, y) not in visit:\\n                visit.add((x-1, y))\\n                if grid[x-1][y] == 0:\\n                    q.insert(0, (cost, x-1, y))\\n                else:\\n                    q.append((cost+1, x-1, y))\\n            if y > 0 and (x, y-1) not in visit:\\n                visit.add((x, y-1))\\n                if grid[x][y-1] == 0:\\n                    q.insert(0, (cost, x, y-1))\\n                else:\\n                    q.append((cost+1, x, y-1))\\n            if x < m-1 and (x+1, y) not in visit:\\n                visit.add((x+1, y))\\n                if grid[x+1][y] == 0:\\n                    q.insert(0, (cost, x+1, y))\\n                else:\\n                    q.append((cost+1, x+1, y))\\n            if y < n-1 and (x, y+1) not in visit:\\n                visit.add((x, y+1))\\n                if grid[x][y+1] == 0:\\n                    q.insert(0, (cost, x, y+1))\\n                else:\\n                    q.append((cost+1, x, y+1))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == 0:\\n            q = [(0, 0, 0)]\\n        else:\\n            q = [(0, 0, 1)]\\n        visit = set()\\n        \\n        while q:\\n            cost, x, y = q.pop(0)\\n            #print(x, y, cost)\\n            if x == m-1 and y == n-1:\\n                return cost\\n            if x > 0 and (x-1, y) not in visit:\\n                visit.add((x-1, y))\\n                if grid[x-1][y] == 0:\\n                    q.insert(0, (cost, x-1, y))\\n                else:\\n                    q.append((cost+1, x-1, y))\\n            if y > 0 and (x, y-1) not in visit:\\n                visit.add((x, y-1))\\n                if grid[x][y-1] == 0:\\n                    q.insert(0, (cost, x, y-1))\\n                else:\\n                    q.append((cost+1, x, y-1))\\n            if x < m-1 and (x+1, y) not in visit:\\n                visit.add((x+1, y))\\n                if grid[x+1][y] == 0:\\n                    q.insert(0, (cost, x+1, y))\\n                else:\\n                    q.append((cost+1, x+1, y))\\n            if y < n-1 and (x, y+1) not in visit:\\n                visit.add((x, y+1))\\n                if grid[x][y+1] == 0:\\n                    q.insert(0, (cost, x, y+1))\\n                else:\\n                    q.append((cost+1, x, y+1))",
                "codeTag": "Java"
            },
            {
                "id": 2144721,
                "title": "straightforward-java-bfs",
                "content": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        \\n        int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n\\n\\n        q.add(new int[]{0, 0});\\n        \\n        int[][] dist = new int[m][n];\\n        for (int[] row: dist) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        dist[0][0] = 0;\\n        \\n        while (!q.isEmpty()) {\\n            \\n\\n            int[] curr = q.poll();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int newrow = curr[0] + dir[i][0];\\n                int newcol = curr[1] + dir[i][1];\\n\\n\\n                if (newrow < 0 || newcol < 0 || newrow >= grid.length || newcol >= grid[0].length) {\\n                    // skipped while:\\n                    // out of bound\\n                    continue; \\n                }\\n\\n\\n                if (grid[newrow][newcol] == 1) {\\n                    if (dist[curr[0]][curr[1]] + 1 < dist[newrow][newcol]) {\\n                        dist[newrow][newcol] = dist[curr[0]][curr[1]] + 1;\\n                        q.add(new int[]{newrow, newcol});\\n                    }\\n                } else if (grid[newrow][newcol] == 0) {\\n                    if (dist[curr[0]][curr[1]] < dist[newrow][newcol]) {\\n                        dist[newrow][newcol] = dist[curr[0]][curr[1]];\\n                        q.add(new int[]{newrow, newcol});\\n                    }\\n                } \\n            }\\n\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        \\n        int[][] dir = new int[][]{{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\\n\\n\\n        q.add(new int[]{0, 0});\\n        \\n        int[][] dist = new int[m][n];\\n        for (int[] row: dist) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        dist[0][0] = 0;\\n        \\n        while (!q.isEmpty()) {\\n            \\n\\n            int[] curr = q.poll();\\n\\n            for (int i = 0; i < 4; i++) {\\n                int newrow = curr[0] + dir[i][0];\\n                int newcol = curr[1] + dir[i][1];\\n\\n\\n                if (newrow < 0 || newcol < 0 || newrow >= grid.length || newcol >= grid[0].length) {\\n                    // skipped while:\\n                    // out of bound\\n                    continue; \\n                }\\n\\n\\n                if (grid[newrow][newcol] == 1) {\\n                    if (dist[curr[0]][curr[1]] + 1 < dist[newrow][newcol]) {\\n                        dist[newrow][newcol] = dist[curr[0]][curr[1]] + 1;\\n                        q.add(new int[]{newrow, newcol});\\n                    }\\n                } else if (grid[newrow][newcol] == 0) {\\n                    if (dist[curr[0]][curr[1]] < dist[newrow][newcol]) {\\n                        dist[newrow][newcol] = dist[curr[0]][curr[1]];\\n                        q.add(new int[]{newrow, newcol});\\n                    }\\n                } \\n            }\\n\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136101,
                "title": "c-bfs-dijkstras-0-1-bfs",
                "content": "**DFS *(Accecpted)***\\n**Note -** for example like `[[0, 1], [0, 1]]` in this case `(1, 1)` cell visit twice, 1st time from `(0, 1)` cell with cost `2` and 2nd time from `(1, 0)` cell with cost `1` even though `1` is better, queue contains both. Meanwhile `dp` got updated at time of `enqueue`, so the `savior` condition will not allow those expensive paths.\\n\\n**for CPP users avoid using vector**\\n\\n*Time complexity :* `greater than O(H * W)` cause a cell can be visited more than once, or it might be `O(V + E)` \\u2248 `O(H * (W - 1)) + O(W * (H - 1))` \\nwhere  `H = grid.size(), W = grid[0].size(), V = no. of vertices, E = no. of edges`\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        queue<tuple<int, int, int>> q;\\n        q.push(make_tuple(0, 0, grid[0][0]));\\n        \\n        while (!q.empty()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                auto [r, c, cost] = q.front();\\n                q.pop();\\n\\n                if (r == H - 1 && c == W - 1) {\\n                    ans = min(ans, cost);\\n                    continue;\\n                }\\n\\n                if (dp[r][c] < cost)  // saved me from getting TLE\\n                    continue;\\n\\n                for (auto [x, y] : DIR) \\n                    if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W) \\n                        if (cost + grid[r + x][c + y] < dp[r + x][c + y]) {\\n                            dp[r + x][c + y] = cost + grid[r + x][c + y];\\n                            q.push(make_tuple(r + x, c + y, cost + grid[r + x][c + y]));\\n                        }\\n            }\\n        }      \\n        \\n        return dp[H - 1][W - 1];\\n    }\\n};\\n```\\n**Dijktras *(Accepted)***\\n*Time complexity :* `O(H * W * Log(H * W))`\\n```\\nclass Solution {\\n\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;\\n        pq.push(make_tuple(0, 0, grid[0][0]));\\n        int ans = INF;\\n        \\n        while (!pq.empty()) {\\n            auto [cost, r, c] = pq.top();\\n            pq.pop();\\n            \\n            if (r == H - 1 && c == W - 1) {\\n                ans = cost;\\n                break;\\n            }\\n            \\n            for (auto [x, y] : DIR) \\n                if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W) \\n                    if (cost + grid[r + x][c + y] < dp[r + x][c + y]) {\\n                        dp[r + x][c + y] = cost + grid[r + x][c + y];\\n                        pq.push(make_tuple(cost + grid[r + x][c + y], r + x, c + y));\\n                    }\\n        }      \\n        \\n        // return dp[H - 1][W - 1]; // it will also work obviously \\n        return ans;\\n    }\\n};\\n```\\n**Modified BFS or 0-1 BFS (Accepted)**\\n*Time complexity :* O(H * W)\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        deque<pair<int, int>> dq;\\n        dp[0][0] = 0;\\n        dq.push_front(make_pair(0, 0));\\n        \\n        while (!dq.empty()) {\\n            auto [r, c] = dq.front();\\n            dq.pop_front();\\n            \\n            if (r == H - 1 && c == W - 1)\\n                return dp[r][c];\\n            \\n            for (auto [x, y] : DIR) \\n                if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W && grid[r + x][c + y] != 2) {\\n                    if (!grid[r + x][c + y])\\n                        dq.push_front({r + x, c + y});\\n                    else\\n                        dq.push_back({r + x, c + y});\\n                    \\n                    dp[r + x][c + y] = dp[r][c] + grid[r + x][c + y];\\n                    grid[r + x][c + y] = 2;\\n                }\\n        }\\n        \\n        return dp[H - 1][W - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        queue<tuple<int, int, int>> q;\\n        q.push(make_tuple(0, 0, grid[0][0]));\\n        \\n        while (!q.empty()) {\\n            for (int i = q.size(); i > 0; i--) {\\n                auto [r, c, cost] = q.front();\\n                q.pop();\\n\\n                if (r == H - 1 && c == W - 1) {\\n                    ans = min(ans, cost);\\n                    continue;\\n                }\\n\\n                if (dp[r][c] < cost)  // saved me from getting TLE\\n                    continue;\\n\\n                for (auto [x, y] : DIR) \\n                    if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W) \\n                        if (cost + grid[r + x][c + y] < dp[r + x][c + y]) {\\n                            dp[r + x][c + y] = cost + grid[r + x][c + y];\\n                            q.push(make_tuple(r + x, c + y, cost + grid[r + x][c + y]));\\n                        }\\n            }\\n        }      \\n        \\n        return dp[H - 1][W - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;\\n        pq.push(make_tuple(0, 0, grid[0][0]));\\n        int ans = INF;\\n        \\n        while (!pq.empty()) {\\n            auto [cost, r, c] = pq.top();\\n            pq.pop();\\n            \\n            if (r == H - 1 && c == W - 1) {\\n                ans = cost;\\n                break;\\n            }\\n            \\n            for (auto [x, y] : DIR) \\n                if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W) \\n                    if (cost + grid[r + x][c + y] < dp[r + x][c + y]) {\\n                        dp[r + x][c + y] = cost + grid[r + x][c + y];\\n                        pq.push(make_tuple(cost + grid[r + x][c + y], r + x, c + y));\\n                    }\\n        }      \\n        \\n        // return dp[H - 1][W - 1]; // it will also work obviously \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const auto INF = int(1e5) + 5;\\n        const vector<pair<int, int>> DIR = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        int H = (int) grid.size(), W = (int) grid[0].size();\\n        // vector<vector<int>> dp(H, vector<int> (W, INF));\\n        int dp[H][W];\\n        \\n        for (int i = 0; i < H; i++)\\n            for (int j = 0; j < W; j++)\\n                dp[i][j] = INF;\\n        \\n        deque<pair<int, int>> dq;\\n        dp[0][0] = 0;\\n        dq.push_front(make_pair(0, 0));\\n        \\n        while (!dq.empty()) {\\n            auto [r, c] = dq.front();\\n            dq.pop_front();\\n            \\n            if (r == H - 1 && c == W - 1)\\n                return dp[r][c];\\n            \\n            for (auto [x, y] : DIR) \\n                if (r + x >= 0 && c + y >= 0 && r + x < H && c + y < W && grid[r + x][c + y] != 2) {\\n                    if (!grid[r + x][c + y])\\n                        dq.push_front({r + x, c + y});\\n                    else\\n                        dq.push_back({r + x, c + y});\\n                    \\n                    dp[r + x][c + y] = dp[r][c] + grid[r + x][c + y];\\n                    grid[r + x][c + y] = 2;\\n                }\\n        }\\n        \\n        return dp[H - 1][W - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125920,
                "title": "dijekstra",
                "content": "\\tclass Node{\\n    public:\\n    int r,c,w;\\n    Node(int row,int col,int weight){\\n        r=row;\\n        c=col;\\n        w=weight;\\n    }\\n\\t};\\n\\tclass comparator{\\n    public:\\n    bool operator()(Node &a,Node&b){\\n        return a.w>b.w;\\n    }\\n\\t};\\n\\tclass Solution {\\n\\tpublic:\\n    vector<vector<int>>dir={{0,1},{0,-1},{1,0},{-1,0}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>matrix(n,vector<int>(m,INT_MAX));\\n        priority_queue<Node,vector<Node>,comparator>pq;\\n   \\n      if(grid[0][0]==0){\\n          pq.push({0,0,0});\\n          matrix[0][0]=0;\\n      }else{\\n          pq.push({0,0,1});\\n          matrix[0][0]=1;\\n      }  \\n      while(!pq.empty()){\\n       Node curr=pq.top();\\n          pq.pop();\\n          if(curr.r==n-1 && curr.c==m-1){\\n              if(grid[n-1][m-1]==1)\\n                  return curr.w+1;\\n              else \\n                  return curr.w;\\n          }\\n          for(auto &x:dir){\\n              int r=curr.r+x[0];\\n              int c=curr.c+x[1];\\n              if(r>=0 && c>=0 && r<n && c<m && matrix[curr.r][curr.c]+grid[r][c]<matrix[r][c]){\\n                  matrix[r][c]=matrix[curr.r][curr.c]+grid[r][c];\\n                  pq.push({r,c,matrix[r][c]});\\n              }\\n          }\\n              \\n      }\\n      return -1;  \\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    vector<vector<int>>dir={{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2118287,
                "title": "java-simple-bfs",
                "content": "This isn\\'t a hard problem, just a simple bfs.\\n\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dirs = new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        \\n        Queue<State> q = new PriorityQueue<>((a, b) -> a.removed - b.removed);\\n        q.add(new State(0, 0, 0));\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        visited[0][0] = true;\\n        \\n        while (!q.isEmpty()) {\\n            State state = q.poll();\\n            \\n            if (state.r == n - 1 && state.c == m - 1)\\n                return state.removed;\\n            \\n            for (int[] d : dirs) {\\n                int nr = state.r + d[0];\\n                int nc = state.c + d[1];\\n                \\n                if (nr < 0 || nc < 0 || nr == n || nc == m || visited[nr][nc])\\n                    continue;\\n                \\n                visited[nr][nc] = true;\\n                \\n                State next = new State(nr, nc, state.removed);\\n                \\n                if (grid[nr][nc] == 1)\\n                    next.removed++;\\n                \\n                q.add(next);\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    class State {\\n        int r;\\n        int c;\\n        int removed;\\n        \\n        State(int r, int c, int removed) {\\n            this.r = r;\\n            this.c = c;\\n            this.removed = removed;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        int[][] dirs = new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        \\n        Queue<State> q = new PriorityQueue<>((a, b) -> a.removed - b.removed);\\n        q.add(new State(0, 0, 0));\\n        \\n        boolean[][] visited = new boolean[n][m];\\n        visited[0][0] = true;\\n        \\n        while (!q.isEmpty()) {\\n            State state = q.poll();\\n            \\n            if (state.r == n - 1 && state.c == m - 1)\\n                return state.removed;\\n            \\n            for (int[] d : dirs) {\\n                int nr = state.r + d[0];\\n                int nc = state.c + d[1];\\n                \\n                if (nr < 0 || nc < 0 || nr == n || nc == m || visited[nr][nc])\\n                    continue;\\n                \\n                visited[nr][nc] = true;\\n                \\n                State next = new State(nr, nc, state.removed);\\n                \\n                if (grid[nr][nc] == 1)\\n                    next.removed++;\\n                \\n                q.add(next);\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    class State {\\n        int r;\\n        int c;\\n        int removed;\\n        \\n        State(int r, int c, int removed) {\\n            this.r = r;\\n            this.c = c;\\n            this.removed = removed;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116006,
                "title": "simple-java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    int[][] dirt = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        pq.offer(new int[]{0, 0, 0});\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            if (cur[0] == m - 1 && cur[1] == n - 1) return cur[2];\\n            for (int[] d : dirt) {\\n                int x = d[0] + cur[0], y = d[1] + cur[1];\\n                if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\\n                    visited[x][y] = true;\\n                    if (grid[x][y] == 1) {\\n                        pq.offer(new int[]{x, y, cur[2] + 1});\\n                    } else {\\n                        pq.offer(new int[]{x, y, cur[2]});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dirt = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        \\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        pq.offer(new int[]{0, 0, 0});\\n        while (!pq.isEmpty()) {\\n            int[] cur = pq.poll();\\n            if (cur[0] == m - 1 && cur[1] == n - 1) return cur[2];\\n            for (int[] d : dirt) {\\n                int x = d[0] + cur[0], y = d[1] + cur[1];\\n                if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y]) {\\n                    visited[x][y] = true;\\n                    if (grid[x][y] == 1) {\\n                        pq.offer(new int[]{x, y, cur[2] + 1});\\n                    } else {\\n                        pq.offer(new int[]{x, y, cur[2]});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115349,
                "title": "c-bfs-dynamic-programming-solution-with-explanation",
                "content": "Intution:At very first instance this problem looks like a Dynamic programming problem.But Dynamic programming will not work here because here we have neighbours in four directions so minimum value for each node is also dependent on path from which it is arrived there (because we are marking previous nodes as visited ).\\n\\n**Upvote if you liked post.**\\nDynamic Programmig solution(Gives Wrong Answer)\\n```\\nclass Solution {\\n\\n    int dfs(vector<vector<int>>& grid,int r,int c, vector<vector<int>> &visited,vector<vector<int>> &mp)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size())return INT_MAX-1;\\n        if(visited[r][c]!=-1)return visited[r][c];\\n        if(mp[r][c]!=-1)return INT_MAX-1;\\n        if(r==grid.size()-1 && c==grid[0].size()-1)return  grid[r][c];\\n        int count=INT_MAX-1;\\n        int x=grid[r][c];\\n        mp[r][c]=1;\\n      //  visited[r][c]=INT_MAX-1;\\n        count=min(count,dfs(grid,r+1,c,visited,mp));\\n        count=min(count,dfs(grid,r,c-1,visited,mp));\\n        count=min(count,dfs(grid,r,c+1,visited,mp));\\n        \\n        count=min(count,dfs(grid,r-1,c,visited,mp));\\n        mp[r][c]=-1;\\n        count+=x;\\n        return visited[r][c]=count;\\n        \\n    }\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        vector<vector<int>>visited(grid.size(),vector<int>(grid[0].size(),-1));\\n        vector<vector<int>>mp(grid.size(),vector<int>(grid[0].size(),-1));\\n        int ans= dfs(grid,0,0,visited,mp);\\n       /* for(int i=0;i<visited.size();i++)\\n        {\\n            for(int j=0;j<visited[0].size();j++)\\n            {\\n                cout<<visited[i][j]<<\" \";\\n            }\\n            cout<<endl;\\n        }*/\\n        return ans;\\n    }\\n};\\n```\\nDijakastras Algorithm(Accepted)\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int weight,r,c;\\n        vector<vector<int>>visited(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        q.push(pair<int,pair<int,int>>(0,pair<int,int>(0,0)));\\n        visited[0][0]=0;\\n        while(!q.empty())\\n        {\\n            weight=q.top().first;\\n            r=q.top().second.first;\\n            c=q.top().second.second;\\n            if(r==grid.size()-1 && c==grid[0].size()-1)return weight;\\n            q.pop();\\n            weight+=grid[r][c];\\n            if(r-1>=0 && visited[r-1][c]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r-1,c)));\\n                visited[r-1][c]=weight;\\n            }\\n            if(c-1>=0 && visited[r][c-1]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r,c-1)));\\n                visited[r][c-1]=weight;\\n            }\\n             if(r+1<grid.size() && visited[r+1][c]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r+1,c)));\\n                visited[r+1][c]=weight;\\n            }\\n            if(c+1<grid[0].size() && visited[r][c+1]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r,c+1)));\\n                visited[r][c+1]=weight;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    int dfs(vector<vector<int>>& grid,int r,int c, vector<vector<int>> &visited,vector<vector<int>> &mp)\\n    {\\n        if(r<0 || r>=grid.size() || c<0 || c>=grid[0].size())return INT_MAX-1;\\n        if(visited[r][c]!=-1)return visited[r][c];\\n        if(mp[r][c]!=-1)return INT_MAX-1;\\n        if(r==grid.size()-1 && c==grid[0].size()-1)return  grid[r][c];\\n        int count=INT_MAX-1;\\n        int x=grid[r][c];\\n        mp[r][c]=1;\\n      //  visited[r][c]=INT_MAX-1;\\n        count=min(count,dfs(grid,r+1,c,visited,mp));\\n        count=min(count,dfs(grid,r,c-1,visited,mp));\\n        count=min(count,dfs(grid,r,c+1,visited,mp));\\n        \\n        count=min(count,dfs(grid,r-1,c,visited,mp));\\n        mp[r][c]=-1;\\n        count+=x;\\n        return visited[r][c]=count;\\n        \\n    }\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        vector<vector<int>>visited(grid.size(),vector<int>(grid[0].size(),-1));\\n        vector<vector<int>>mp(grid.size(),vector<int>(grid[0].size(),-1));\\n        int ans= dfs(grid,0,0,visited,mp);\\n       /* for(int i=0;i<visited.size();i++)\\n        {\\n            for(int j=0;j<visited[0].size();j++)\\n            {\\n                cout<<visited[i][j]<<\" \";\\n            }\\n            cout<<endl;\\n        }*/\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int weight,r,c;\\n        vector<vector<int>>visited(grid.size(),vector<int>(grid[0].size(),INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>q;\\n        q.push(pair<int,pair<int,int>>(0,pair<int,int>(0,0)));\\n        visited[0][0]=0;\\n        while(!q.empty())\\n        {\\n            weight=q.top().first;\\n            r=q.top().second.first;\\n            c=q.top().second.second;\\n            if(r==grid.size()-1 && c==grid[0].size()-1)return weight;\\n            q.pop();\\n            weight+=grid[r][c];\\n            if(r-1>=0 && visited[r-1][c]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r-1,c)));\\n                visited[r-1][c]=weight;\\n            }\\n            if(c-1>=0 && visited[r][c-1]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r,c-1)));\\n                visited[r][c-1]=weight;\\n            }\\n             if(r+1<grid.size() && visited[r+1][c]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r+1,c)));\\n                visited[r+1][c]=weight;\\n            }\\n            if(c+1<grid[0].size() && visited[r][c+1]>weight)\\n            {\\n                q.push(pair<int,pair<int,int>>(weight,pair<int,int>(r,c+1)));\\n                visited[r][c+1]=weight;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2106773,
                "title": "c-dijkstra-s-algorithm-implementation-based-on-set-stl",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Approach : Dijkstra\\'s Algorithm ; Implementation Based On Set: STL\\n    // Time Complexity : o(mnlog(mn)) ; Space Complexity : O(mn)\\n    \\n    // Steps :\\n    \\n    // 1) Initialise the distances of all grid elements as INT_MAX in dp array\\n    // 2) Insert source into set where <distance, u, v>\\n    // 3) While set doesn\\'t become empty do,\\n    //   i) extract minimum distance from set, let extracted be (i, j)\\n    //   ii) loop through all the adjacents to (i, j) i.e. check in 4 directions \\n    //   iii) if(dp[x][y] > grid[x][y] + weight) \\n    //       # here, grid[x][y] is edge\\'s weight from (i,j)-->(x,y) \\n    //       # weight is minimum distance till (i,j)\\n    //       # dist[v] > dist[u] + cost (standard relaxation condition from dijkstra)\\n    //       # dp[x][y] > weight + grid[x][y]\\n    //       a) Update distance of dp[x][y] = grid[x][y] + weight\\n    //       b) If (dp[x][y], x, y) already in set remove them and insert with updated distances\\n    //       c) If (dp[x][y], x, y) not in set, insert it in set \\n    // 4) Finally, return distance of destination that will be minimum i.e dp[n-1][m-1]\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n       \\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n\\n        set<tuple<int,int,int>> st;\\n\\n        st.insert({0,0,0});\\n        dp[0][0] = 0;\\n        \\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        \\n        \\n        while(!st.empty()){\\n            auto tmp = *(st.begin());\\n            st.erase(st.begin());\\n          \\n            int weight = get<0>(tmp);\\n            \\n            for(int k = 0 ; k < 4 ; k++){\\n                int x = dx[k] + get<1>(tmp);\\n                int y = dy[k] + get<2> (tmp);\\n                if(x >= 0 && x < n && y >= 0 && y < m){\\n                    if(dp[x][y] > grid[x][y] + weight){\\n                        if(dp[x][y] != INT_MAX) st.erase({dp[x][y], x, y});\\n                        dp[x][y] = grid[x][y] + weight;\\n                        st.insert({dp[x][y], x, y});\\n                    } \\n                }\\n            }\\n        }\\n        \\n        return dp[n-1][m-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Approach : Dijkstra\\'s Algorithm ; Implementation Based On Set: STL\\n    // Time Complexity : o(mnlog(mn)) ; Space Complexity : O(mn)\\n    \\n    // Steps :\\n    \\n    // 1) Initialise the distances of all grid elements as INT_MAX in dp array\\n    // 2) Insert source into set where <distance, u, v>\\n    // 3) While set doesn\\'t become empty do,\\n    //   i) extract minimum distance from set, let extracted be (i, j)\\n    //   ii) loop through all the adjacents to (i, j) i.e. check in 4 directions \\n    //   iii) if(dp[x][y] > grid[x][y] + weight) \\n    //       # here, grid[x][y] is edge\\'s weight from (i,j)-->(x,y) \\n    //       # weight is minimum distance till (i,j)\\n    //       # dist[v] > dist[u] + cost (standard relaxation condition from dijkstra)\\n    //       # dp[x][y] > weight + grid[x][y]\\n    //       a) Update distance of dp[x][y] = grid[x][y] + weight\\n    //       b) If (dp[x][y], x, y) already in set remove them and insert with updated distances\\n    //       c) If (dp[x][y], x, y) not in set, insert it in set \\n    // 4) Finally, return distance of destination that will be minimum i.e dp[n-1][m-1]\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n       \\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n\\n        set<tuple<int,int,int>> st;\\n\\n        st.insert({0,0,0});\\n        dp[0][0] = 0;\\n        \\n        int dx[4] = {0,0,1,-1};\\n        int dy[4] = {1,-1,0,0};\\n        \\n        \\n        while(!st.empty()){\\n            auto tmp = *(st.begin());\\n            st.erase(st.begin());\\n          \\n            int weight = get<0>(tmp);\\n            \\n            for(int k = 0 ; k < 4 ; k++){\\n                int x = dx[k] + get<1>(tmp);\\n                int y = dy[k] + get<2> (tmp);\\n                if(x >= 0 && x < n && y >= 0 && y < m){\\n                    if(dp[x][y] > grid[x][y] + weight){\\n                        if(dp[x][y] != INT_MAX) st.erase({dp[x][y], x, y});\\n                        dp[x][y] = grid[x][y] + weight;\\n                        st.insert({dp[x][y], x, y});\\n                    } \\n                }\\n            }\\n        }\\n        \\n        return dp[n-1][m-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093694,
                "title": "c-solution",
                "content": "```\\nvoid input(int** grid, int gridSize, int gridColSize, int** list, int* count, int i, int j, int now){\\n    if (i < 0 || j < 0 || i >= gridSize || j >= gridColSize || grid[i][j] > 1){\\n        return;\\n    }\\n    if (grid[i][j] == 1){\\n        list[*count][0] = i;\\n        list[*count][1] = j;\\n        *count += 1;\\n        grid[i][j] = now+1;\\n        return;\\n    }\\n    grid[i][j] = now;\\n    input(grid, gridSize, gridColSize, list, count, i+1, j, now);\\n    input(grid, gridSize, gridColSize, list, count, i-1, j, now);\\n    input(grid, gridSize, gridColSize, list, count, i, j+1, now);\\n    input(grid, gridSize, gridColSize, list, count, i, j-1, now);\\n    return;\\n}\\n\\n\\nint minimumObstacles(int** grid, int gridSize, int* gridColSize){\\n    int p = gridSize*(*gridColSize);\\n    int** list = malloc(sizeof(int*)*p);\\n    for (int i = 0 ; i < p ; i++){\\n        list[i] = malloc(sizeof(int)*2);\\n    }\\n    int end = 0;\\n    int count = 0; \\n    int start = 0;\\n    int now = 2;\\n    input(grid, gridSize, *gridColSize, list, &count, 0, 0, now);\\n    while (grid[gridSize-1][*gridColSize-1] == 0){\\n        end = count;\\n        now++;\\n        for ( ; start < end ; start++){\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0]+1, list[start][1], now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0]-1, list[start][1], now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0], list[start][1]+1, now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0], list[start][1]-1, now);\\n        }\\n    }\\n    int ans = grid[gridSize-1][*gridColSize-1]-2;\\n    for (int i = 0 ; i < p ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid input(int** grid, int gridSize, int gridColSize, int** list, int* count, int i, int j, int now){\\n    if (i < 0 || j < 0 || i >= gridSize || j >= gridColSize || grid[i][j] > 1){\\n        return;\\n    }\\n    if (grid[i][j] == 1){\\n        list[*count][0] = i;\\n        list[*count][1] = j;\\n        *count += 1;\\n        grid[i][j] = now+1;\\n        return;\\n    }\\n    grid[i][j] = now;\\n    input(grid, gridSize, gridColSize, list, count, i+1, j, now);\\n    input(grid, gridSize, gridColSize, list, count, i-1, j, now);\\n    input(grid, gridSize, gridColSize, list, count, i, j+1, now);\\n    input(grid, gridSize, gridColSize, list, count, i, j-1, now);\\n    return;\\n}\\n\\n\\nint minimumObstacles(int** grid, int gridSize, int* gridColSize){\\n    int p = gridSize*(*gridColSize);\\n    int** list = malloc(sizeof(int*)*p);\\n    for (int i = 0 ; i < p ; i++){\\n        list[i] = malloc(sizeof(int)*2);\\n    }\\n    int end = 0;\\n    int count = 0; \\n    int start = 0;\\n    int now = 2;\\n    input(grid, gridSize, *gridColSize, list, &count, 0, 0, now);\\n    while (grid[gridSize-1][*gridColSize-1] == 0){\\n        end = count;\\n        now++;\\n        for ( ; start < end ; start++){\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0]+1, list[start][1], now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0]-1, list[start][1], now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0], list[start][1]+1, now);\\n            input(grid, gridSize, *gridColSize, list, &count, list[start][0], list[start][1]-1, now);\\n        }\\n    }\\n    int ans = grid[gridSize-1][*gridColSize-1]-2;\\n    for (int i = 0 ; i < p ; i++){\\n        free(list[i]);\\n    }\\n    free(list);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2091038,
                "title": "c-0-1-bfs-dijkstra",
                "content": "```\\n//0-1 BFS\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define pii pair<int,int>\\n    #define inf 1e9+9\\n    #define f first\\n    #define s second\\n    \\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,1,-1};\\n    vector<vector<pii>> buildGraph(vector<vector<int>>& grid,int n, int m){\\n        vector<vector<pii>> graph(n*m+1);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int currCell = i*m+j;\\n                \\n                \\n                for(int d=0;d<4;d++){//all direction\\n                    int newR = i+dx[d];\\n                    int newC = j+dy[d];\\n                    \\n                    if(newR>=0 and newR<n and newC >= 0 and newC<m){\\n                        int newCell = newR*m+newC;\\n                        graph[currCell].push_back({newCell,grid[newR][newC]});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return graph;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<pii>> graph = buildGraph(grid,n,m);\\n        \\n        vi dist(n*m,inf);\\n        deque<int> dq;//curr node and wt\\n        \\n        dq.push_back(0);\\n        dist[0]=0;\\n        \\n        while(!dq.empty()){\\n            \\n            auto curr = dq.front();\\n            dq.pop_front();\\n            \\n            for(auto child: graph[curr]){\\n                int child_v = child.f;\\n                int wt = child.s;\\n                \\n                if(dist[curr]+wt < dist[child_v]){\\n                    dist[child_v] = dist[curr]+wt;\\n                    \\n                    if(wt == 1){\\n                        dq.push_back(child_v);\\n                    }\\n                    else{\\n                        dq.push_front(child_v);\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        return dist[n*m-1];\\n    }\\n};\\n```\\n\\n\\n```\\n//Dijkstra\\n\\nstruct cmp{\\n    bool operator() (const pair<int,int> &a,const pair<int,int> &b) const  {\\n        return a.second < b.second;\\n    }  \\n};\\n\\n\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define pii pair<long long,long long>\\n    #define inf 1e9+9\\n    #define f first\\n    #define s second\\n    #define ll long long\\n    \\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,1,-1};\\n    \\n    vector<vector<pii>> buildGraph(vector<vector<int>>& grid,int n, int m){\\n        vector<vector<pii>> graph(n*m+1);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int currCell = i*m+j;\\n                \\n                \\n                for(int d=0;d<4;d++){//all direction\\n                    int newR = i+dx[d];\\n                    int newC = j+dy[d];\\n                    \\n                    if(newR>=0 and newR<n and newC >= 0 and newC<m){\\n                        int newCell = newR*m+newC;\\n                        graph[currCell].push_back({newCell,grid[newR][newC]});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return graph;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<pii>> graph = buildGraph(grid,n,m);\\n   \\n        //Dijistras algorithm\\n        \\n        /*\\n        1) build graph\\n        2) multiset(sort according to incraseing order of weight)\\n        3) ms.insert({0,0}) // curr node weight\\n        \\n        */\\n        vi vis(n*m,0);\\n        vi dist(n*m,inf);\\n        multiset<pii , cmp> ms;//node,weight\\n        ms.insert({0,0});\\n        dist[0] = 0;\\n        \\n        while(not ms.empty()){\\n            pii curr_node = *ms.begin();\\n            ms.erase(ms.begin());\\n            int v = curr_node.f;\\n            int dt = curr_node.s;\\n            if(vis[v]){\\n                continue;\\n            }\\n            vis[v] = 1;\\n            for(pii &child: graph[v]){\\n                int child_v = child.f;\\n                int wt = child.s;\\n                \\n                if(dist[v]+wt < dist[child_v]){\\n                    dist[child_v] = dist[v]+wt ;\\n                    ms.insert({child_v,dist[child_v]});\\n                }\\n            }\\n        }\\n        return dist[n*m-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//0-1 BFS\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define pii pair<int,int>\\n    #define inf 1e9+9\\n    #define f first\\n    #define s second\\n    \\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,1,-1};\\n    vector<vector<pii>> buildGraph(vector<vector<int>>& grid,int n, int m){\\n        vector<vector<pii>> graph(n*m+1);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int currCell = i*m+j;\\n                \\n                \\n                for(int d=0;d<4;d++){//all direction\\n                    int newR = i+dx[d];\\n                    int newC = j+dy[d];\\n                    \\n                    if(newR>=0 and newR<n and newC >= 0 and newC<m){\\n                        int newCell = newR*m+newC;\\n                        graph[currCell].push_back({newCell,grid[newR][newC]});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return graph;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<pii>> graph = buildGraph(grid,n,m);\\n        \\n        vi dist(n*m,inf);\\n        deque<int> dq;//curr node and wt\\n        \\n        dq.push_back(0);\\n        dist[0]=0;\\n        \\n        while(!dq.empty()){\\n            \\n            auto curr = dq.front();\\n            dq.pop_front();\\n            \\n            for(auto child: graph[curr]){\\n                int child_v = child.f;\\n                int wt = child.s;\\n                \\n                if(dist[curr]+wt < dist[child_v]){\\n                    dist[child_v] = dist[curr]+wt;\\n                    \\n                    if(wt == 1){\\n                        dq.push_back(child_v);\\n                    }\\n                    else{\\n                        dq.push_front(child_v);\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        return dist[n*m-1];\\n    }\\n};\\n```\n```\\n//Dijkstra\\n\\nstruct cmp{\\n    bool operator() (const pair<int,int> &a,const pair<int,int> &b) const  {\\n        return a.second < b.second;\\n    }  \\n};\\n\\n\\nclass Solution {\\npublic:\\n    #define vi vector<int>\\n    #define pii pair<long long,long long>\\n    #define inf 1e9+9\\n    #define f first\\n    #define s second\\n    #define ll long long\\n    \\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,1,-1};\\n    \\n    vector<vector<pii>> buildGraph(vector<vector<int>>& grid,int n, int m){\\n        vector<vector<pii>> graph(n*m+1);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int currCell = i*m+j;\\n                \\n                \\n                for(int d=0;d<4;d++){//all direction\\n                    int newR = i+dx[d];\\n                    int newC = j+dy[d];\\n                    \\n                    if(newR>=0 and newR<n and newC >= 0 and newC<m){\\n                        int newCell = newR*m+newC;\\n                        graph[currCell].push_back({newCell,grid[newR][newC]});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return graph;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<pii>> graph = buildGraph(grid,n,m);\\n   \\n        //Dijistras algorithm\\n        \\n        /*\\n        1) build graph\\n        2) multiset(sort according to incraseing order of weight)\\n        3) ms.insert({0,0}) // curr node weight\\n        \\n        */\\n        vi vis(n*m,0);\\n        vi dist(n*m,inf);\\n        multiset<pii , cmp> ms;//node,weight\\n        ms.insert({0,0});\\n        dist[0] = 0;\\n        \\n        while(not ms.empty()){\\n            pii curr_node = *ms.begin();\\n            ms.erase(ms.begin());\\n            int v = curr_node.f;\\n            int dt = curr_node.s;\\n            if(vis[v]){\\n                continue;\\n            }\\n            vis[v] = 1;\\n            for(pii &child: graph[v]){\\n                int child_v = child.f;\\n                int wt = child.s;\\n                \\n                if(dist[v]+wt < dist[child_v]){\\n                    dist[child_v] = dist[v]+wt ;\\n                    ms.insert({child_v,dist[child_v]});\\n                }\\n            }\\n        }\\n        return dist[n*m-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089483,
                "title": "c-dijkstra-algorithm-0-1-bfs-both-clean-code",
                "content": "This is my Dijkstra Algo Approach\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        vector<vector<int >> distance(n + 1, vector<int>(m + 1, INT_MAX)), vis(n + 1, vector<int>(m + 1, 0));\\n        pq.push({0, {0, 0}});\\n        distance[0][0] = 0;\\n        \\n        while(!pq.empty()){\\n            pair<int, pair<int, int>> currPath = pq.top();\\n            pq.pop();\\n            \\n            int dis = currPath.first;\\n            int x = currPath.second.first;\\n            int y = currPath.second.second;\\n            if(vis[x][y])\\n                continue;\\n            \\n            vis[x][y] = 1;\\n            int dx[] = {-1, 1, 0, 0};\\n            int dy[] = {0, 0, -1, 1};\\n            \\n            for(int i = 0; i < 4; ++i){\\n                int newx = dx[i] + x, newy = dy[i] + y;\\n                if(newx >= 0 and newy >= 0 and newx < n and newy < m){\\n                    int weight = grid[newx][newy];\\n                    if(dis + weight < distance[newx][newy]){\\n                        distance[newx][newy] = dis + weight;\\n                        \\n                        pq.push({distance[newx][newy], {newx, newy}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return distance[n - 1][m - 1];\\n    }\\n};\\n```\\n\\nThis is my BFS Approach\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int >> dis(n + 1, vector<int>(m + 1, INT_MAX));\\n        queue<pair<int,int >> q;\\n        q.push({0, 0});\\n        \\n        dis[0][0] = 0;\\n        \\n        while(!q.empty()){\\n            pair<int, int> curr = q.front();\\n            q.pop();\\n            \\n            int dx[] = {-1, 1, 0, 0};\\n            int dy[] = {0, 0, -1, 1};\\n            \\n            for(int i = 0; i < 4; ++i){\\n                int newx = dx[i] + curr.first, newy = dy[i] + curr.second;\\n                \\n                if(newx >= 0 and newy >= 0 and newx < n and newy < m){\\n                    int weight = grid[newx][newy];\\n                    int coming = dis[curr.first][curr.second];\\n                    if(coming + weight < dis[newx][newy]){\\n                        dis[newx][newy] = coming + weight;\\n                        q.push({newx, newy});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dis[n - 1][m - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        priority_queue<pair<int, pair<int,int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        vector<vector<int >> distance(n + 1, vector<int>(m + 1, INT_MAX)), vis(n + 1, vector<int>(m + 1, 0));\\n        pq.push({0, {0, 0}});\\n        distance[0][0] = 0;\\n        \\n        while(!pq.empty()){\\n            pair<int, pair<int, int>> currPath = pq.top();\\n            pq.pop();\\n            \\n            int dis = currPath.first;\\n            int x = currPath.second.first;\\n            int y = currPath.second.second;\\n            if(vis[x][y])\\n                continue;\\n            \\n            vis[x][y] = 1;\\n            int dx[] = {-1, 1, 0, 0};\\n            int dy[] = {0, 0, -1, 1};\\n            \\n            for(int i = 0; i < 4; ++i){\\n                int newx = dx[i] + x, newy = dy[i] + y;\\n                if(newx >= 0 and newy >= 0 and newx < n and newy < m){\\n                    int weight = grid[newx][newy];\\n                    if(dis + weight < distance[newx][newy]){\\n                        distance[newx][newy] = dis + weight;\\n                        \\n                        pq.push({distance[newx][newy], {newx, newy}});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return distance[n - 1][m - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        \\n        vector<vector<int >> dis(n + 1, vector<int>(m + 1, INT_MAX));\\n        queue<pair<int,int >> q;\\n        q.push({0, 0});\\n        \\n        dis[0][0] = 0;\\n        \\n        while(!q.empty()){\\n            pair<int, int> curr = q.front();\\n            q.pop();\\n            \\n            int dx[] = {-1, 1, 0, 0};\\n            int dy[] = {0, 0, -1, 1};\\n            \\n            for(int i = 0; i < 4; ++i){\\n                int newx = dx[i] + curr.first, newy = dy[i] + curr.second;\\n                \\n                if(newx >= 0 and newy >= 0 and newx < n and newy < m){\\n                    int weight = grid[newx][newy];\\n                    int coming = dis[curr.first][curr.second];\\n                    if(coming + weight < dis[newx][newy]){\\n                        dis[newx][newy] = coming + weight;\\n                        q.push({newx, newy});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dis[n - 1][m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089476,
                "title": "c-easy-to-understand-simple-solution-using-dijkstra-s-algorithm",
                "content": "**Time Complexity O(NlogN)**\\n\\n```\\n//dijkstra\\'s Algorithm\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>> > pq;\\n        vector<pair<int,int>> dir(4);\\n        dir[0]={0,1};\\n        dir[1]={0,-1};\\n        dir[2]={1,0};\\n        dir[3]={-1,0};\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int> > dis(n,vector<int> (m,INT_MAX));\\n        vector<vector<bool> > vis(n,vector<bool> (m,false));\\n        pq.push({0,{0,0}});\\n        dis[0][0]=0;\\n        while(!pq.empty())\\n        {\\n            pair<int,pair<int,int>> ele=pq.top();\\n            pq.pop();\\n            int x,y,cost;\\n            cost=ele.first;\\n            x=ele.second.first;\\n            y=ele.second.second;\\n            vis[x][y]=true;\\n            if(x==n-1&&y==m-1)\\n            return cost;\\n            for(auto pr:dir)\\n            {\\n                int next_x,next_y;\\n                next_x=x+pr.first;\\n                next_y=y+pr.second;\\n                if(next_x>=0&&next_x<n&&next_y>=0&&next_y<m&&cost+grid[next_x][next_y]<dis[next_x][next_y]&&!vis[next_x][next_y])\\n                {\\n                    dis[next_x][next_y]=cost+grid[next_x][next_y];\\n                    pq.push({dis[next_x][next_y],{next_x,next_y}});\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n//dijkstra\\'s Algorithm\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>> > pq;\\n        vector<pair<int,int>> dir(4);\\n        dir[0]={0,1};\\n        dir[1]={0,-1};\\n        dir[2]={1,0};\\n        dir[3]={-1,0};\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int> > dis(n,vector<int> (m,INT_MAX));\\n        vector<vector<bool> > vis(n,vector<bool> (m,false));\\n        pq.push({0,{0,0}});\\n        dis[0][0]=0;\\n        while(!pq.empty())\\n        {\\n            pair<int,pair<int,int>> ele=pq.top();\\n            pq.pop();\\n            int x,y,cost;\\n            cost=ele.first;\\n            x=ele.second.first;\\n            y=ele.second.second;\\n            vis[x][y]=true;\\n            if(x==n-1&&y==m-1)\\n            return cost;\\n            for(auto pr:dir)\\n            {\\n                int next_x,next_y;\\n                next_x=x+pr.first;\\n                next_y=y+pr.second;\\n                if(next_x>=0&&next_x<n&&next_y>=0&&next_y<m&&cost+grid[next_x][next_y]<dis[next_x][next_y]&&!vis[next_x][next_y])\\n                {\\n                    dis[next_x][next_y]=cost+grid[next_x][next_y];\\n                    pq.push({dis[next_x][next_y],{next_x,next_y}});\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088400,
                "title": "java-dijsktra-s-algo-bfs",
                "content": "```\\nclass Solution {\\n    int[][] dir = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        dp[0][0] = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b)->dp[a[0]][a[1]]-dp[b[0]][b[1]]);\\n        \\n        pq.offer(new int[]{0, 0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] curr = pq.poll();\\n            \\n            if(curr[0] == m-1 && curr[1] == n-1)\\n                return dp[m-1][n-1];\\n            for(int j=0;j<4;j++){\\n                int x = dir[j][0]+curr[0];\\n                int y = dir[j][1]+curr[1];\\n                \\n                \\n                if(x<0 || y<0 || x >= m || y >= n)\\n                    continue;\\n                \\n                if(dp[x][y] > dp[curr[0]][curr[1]]+grid[curr[0]][curr[1]]){\\n                     dp[x][y] = dp[curr[0]][curr[1]]+grid[curr[0]][curr[1]];\\n                     pq.offer(new int[]{x, y});\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = new int[][]{{1,0},{0,1},{-1,0},{0,-1}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] dp = new int[m][n];\\n        \\n        for(int i=0;i<m;i++)\\n            Arrays.fill(dp[i], Integer.MAX_VALUE);\\n        \\n        dp[0][0] = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b)->dp[a[0]][a[1]]-dp[b[0]][b[1]]);\\n        \\n        pq.offer(new int[]{0, 0});\\n        \\n        while(!pq.isEmpty()){\\n            \\n            int[] curr = pq.poll();\\n            \\n            if(curr[0] == m-1 && curr[1] == n-1)\\n                return dp[m-1][n-1];\\n            for(int j=0;j<4;j++){\\n                int x = dir[j][0]+curr[0];\\n                int y = dir[j][1]+curr[1];\\n                \\n                \\n                if(x<0 || y<0 || x >= m || y >= n)\\n                    continue;\\n                \\n                if(dp[x][y] > dp[curr[0]][curr[1]]+grid[curr[0]][curr[1]]){\\n                     dp[x][y] = dp[curr[0]][curr[1]]+grid[curr[0]][curr[1]];\\n                     pq.offer(new int[]{x, y});\\n                }\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087864,
                "title": "c-shortes-path-dijkstra-s",
                "content": "\\ttypedef tuple<int,int,int>tp;\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumObstacles(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size(),m = grid[0].size();\\n\\t\\t\\tint dir[4][2] = {{-1,0},{0,-1},{1,0},{0,1}};\\n\\t\\t\\tvector<vector<int>>cost(n,vector<int>(m,INT_MAX));\\n\\t\\t\\tpriority_queue<tp,vector<tp>,greater<tp>>q;\\n\\t\\t\\tq.push({grid[0][0],0,0});\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tauto [c,x,y] = q.top();q.pop();\\n\\t\\t\\t\\tif(x==n-1 and y==m-1) return c;\\n\\t\\t\\t\\tfor(auto &d:dir){\\n\\t\\t\\t\\t\\tint i = d[0]+x,j = d[1]+y;\\n\\t\\t\\t\\t\\tif(i<0 or j<0 or i==n or j==m) continue;\\n\\t\\t\\t\\t\\tif(cost[i][j]>c+grid[i][j]){\\n\\t\\t\\t\\t\\t\\tcost[i][j] = c+grid[i][j];\\n\\t\\t\\t\\t\\t\\tq.push({c+grid[i][j],i,j});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumObstacles(vector<vector<int>>& grid) {\\n\\t\\t\\tint n = grid.size(),m = grid[0].size();\\n\\t\\t\\tint dir[4][2] = {{-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2087637,
                "title": "python-concise-solution-with-greedy-bfs",
                "content": "Just run a greedy BFS, Starting from cell `(0,0)` , push any unvisited adjacent empty cell to the front of the queue  and the unvisited wall cells to the back of the queue (We prefer paths with the most number of empty cells, pushing empty cells to the front of the queue ensure all the nearby empty cells would be visited first because they all have the same total weight as the current cell , when we have no empty cells that can be visited left, we will move to the nearest wall cells to continue exploring other possible paths.\\n\\n```python\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        from collections import deque \\n        q = deque([(0,0,0)])\\n        n, m = len(grid), len(grid[0])\\n        while q:\\n            i,j,v = q.popleft() \\n            if grid[i][j] != -1:\\n                grid[i][j] = -1\\n                if i == n-1 and j == m-1:\\n                    return v\\n                for (x,y) in (i+1,j),(i,j+1), (i-1, j), (i,j-1):\\n                    if 0 <= x < n and 0 <= y < m :\\n                        if grid[x][y] != -1:\\n                            getattr(q, f\\'append{\"\" if grid[x][y] else \"left\"}\\' )((x,y,v+grid[x][y]))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        from collections import deque \\n        q = deque([(0,0,0)])\\n        n, m = len(grid), len(grid[0])\\n        while q:\\n            i,j,v = q.popleft() \\n            if grid[i][j] != -1:\\n                grid[i][j] = -1\\n                if i == n-1 and j == m-1:\\n                    return v\\n                for (x,y) in (i+1,j),(i,j+1), (i-1, j), (i,j-1):\\n                    if 0 <= x < n and 0 <= y < m :\\n                        if grid[x][y] != -1:\\n                            getattr(q, f\\'append{\"\" if grid[x][y] else \"left\"}\\' )((x,y,v+grid[x][y]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087374,
                "title": "c-dijkstra",
                "content": "Dijkstra algorithm: two 4-connected cells in the grid have an edge of length\\n\\n- `0` if target cell doesn\\'t have an obstacle\\n- `1` if target cell has an obstacle\\n\\n**Code:**\\n\\n```\\npublic class Solution {\\n    \\n    public int MinimumObstacles(int[][] grid) {\\n        PriorityQueue<(int r, int c), int> agenda = new ();\\n        \\n        agenda.Enqueue((0, 0), grid[0][0]);\\n        \\n        Dictionary<(int r, int c), int> visited = new() {\\n            {(0, 0), grid[0][0]},  \\n        };\\n        \\n        while (agenda.Count > 0) {\\n            var node = agenda.Dequeue();\\n            \\n            for (int d = 0; d < 4; ++d) {\\n                int nr = node.r + (d - 1) % 2;\\n                int nc = node.c + (d - 2) % 2;\\n                \\n                if (nr < 0 || nr >= grid.Length || nc < 0 || nc >= grid[nr].Length)\\n                    continue;\\n                \\n                int cost = visited[(node.r, node.c)] + grid[node.r][node.c];\\n                \\n                if (visited.TryGetValue((nr, nc), out int oldCost) && oldCost <= cost)\\n                    continue;\\n                \\n                if (!visited.TryAdd((nr, nc), cost))\\n                    visited[(nr, nc)] = cost;\\n                \\n                agenda.Enqueue((nr, nc), cost);\\n            }\\n        }\\n        \\n        return visited[(grid.Length - 1, grid[grid.Length - 1].Length - 1)];\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public int MinimumObstacles(int[][] grid) {\\n        PriorityQueue<(int r, int c), int> agenda = new ();\\n        \\n        agenda.Enqueue((0, 0), grid[0][0]);\\n        \\n        Dictionary<(int r, int c), int> visited = new() {\\n            {(0, 0), grid[0][0]},  \\n        };\\n        \\n        while (agenda.Count > 0) {\\n            var node = agenda.Dequeue();\\n            \\n            for (int d = 0; d < 4; ++d) {\\n                int nr = node.r + (d - 1) % 2;\\n                int nc = node.c + (d - 2) % 2;\\n                \\n                if (nr < 0 || nr >= grid.Length || nc < 0 || nc >= grid[nr].Length)\\n                    continue;\\n                \\n                int cost = visited[(node.r, node.c)] + grid[node.r][node.c];\\n                \\n                if (visited.TryGetValue((nr, nc), out int oldCost) && oldCost <= cost)\\n                    continue;\\n                \\n                if (!visited.TryAdd((nr, nc), cost))\\n                    visited[(nr, nc)] = cost;\\n                \\n                agenda.Enqueue((nr, nc), cost);\\n            }\\n        }\\n        \\n        return visited[(grid.Length - 1, grid[grid.Length - 1].Length - 1)];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087258,
                "title": "c-using-max-heap-t-o-n-m-s-o-n-m",
                "content": "Start from the end (x=m-1, y=n-1) and do the BFS things, but this time, will always pick the minimum block count to go through.\\n\\nUsing the example 1:\\n```\\n| |x|x|\\n|x|x| |\\n|x|x| |\\n```\\nWe will create the dp grid as:\\n```\\n|2|2|1|\\n|2|1|0|\\n|2|1|0|\\n```\\n\\nThe time complexity will be O(m\\\\*n) (assume m = size of x & n = size of y) because we\\'ll always goes to each grid once.\\nThe space complexity will be O(n\\\\*n) because we need dp[x][y] to save minimum count.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        pair<int,int> dirs[4] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n        // dp to save each grid\\'s min block count\\n        vector<vector<int>> dp (m, vector<int> (n, -1));\\n        // Min heap with {level, x, y} (level = block count)\\n        priority_queue<tuple<int,int,int>> pq;\\n        pq.push({0, m-1, n-1});\\n        dp[m-1][n-1] = 0;\\n        \\n        while (!pq.empty()) {\\n            // get top from min heap, current level is the minimam\\n            int level = -get<0>(pq.top());\\n            int x = get<1>(pq.top()), y = get<2>(pq.top());\\n            pq.pop();\\n            // 4 directions\\n            for (auto & dir: dirs) {\\n                int next_x = x + dir.first;\\n                int next_y = y + dir.second;\\n                \\n                // check if goes to dp[0][0]\\n                if (next_x == 0 && next_y == 0) return level + grid[next_x][next_y];\\n                \\n                if (next_x < m && next_y < n && next_x >= 0 && next_y >= 0 && dp[next_x][next_y] == -1) {\\n                    // if there is block, add 1 to previous level, else same as previous level\\n                    dp[next_x][next_y] = level + grid[next_x][next_y];\\n                    // priority default as max heap, therefor we negative level to get min heap\\n                    pq.push({-dp[next_x][next_y], next_x, next_y}); \\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n| |x|x|\\n|x|x| |\\n|x|x| |\\n```\n```\\n|2|2|1|\\n|2|1|0|\\n|2|1|0|\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        pair<int,int> dirs[4] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n        // dp to save each grid\\'s min block count\\n        vector<vector<int>> dp (m, vector<int> (n, -1));\\n        // Min heap with {level, x, y} (level = block count)\\n        priority_queue<tuple<int,int,int>> pq;\\n        pq.push({0, m-1, n-1});\\n        dp[m-1][n-1] = 0;\\n        \\n        while (!pq.empty()) {\\n            // get top from min heap, current level is the minimam\\n            int level = -get<0>(pq.top());\\n            int x = get<1>(pq.top()), y = get<2>(pq.top());\\n            pq.pop();\\n            // 4 directions\\n            for (auto & dir: dirs) {\\n                int next_x = x + dir.first;\\n                int next_y = y + dir.second;\\n                \\n                // check if goes to dp[0][0]\\n                if (next_x == 0 && next_y == 0) return level + grid[next_x][next_y];\\n                \\n                if (next_x < m && next_y < n && next_x >= 0 && next_y >= 0 && dp[next_x][next_y] == -1) {\\n                    // if there is block, add 1 to previous level, else same as previous level\\n                    dp[next_x][next_y] = level + grid[next_x][next_y];\\n                    // priority default as max heap, therefor we negative level to get min heap\\n                    pq.push({-dp[next_x][next_y], next_x, next_y}); \\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087005,
                "title": "c-simple-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>v(n,vector<int>(m,INT_MAX));\\n        v[0][0]=0;\\n        queue<pair<int,int>>q;\\n        int dir[][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n        q.push({0,0});\\n        while(!q.empty())\\n        {\\n            auto [x,y]=q.front();\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int r=x+dir[i][0],c=y+dir[i][1];\\n                if(r<0 || c<0 || r>=n || c>=m || v[x][y]+grid[r][c]>=v[r][c])\\n                {\\n                    continue;\\n                }\\n                v[r][c]=v[x][y]+grid[r][c];\\n                q.push({r,c});\\n            }\\n        }\\n        return v[n-1][m-1];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>v(n,vector<int>(m,INT_MAX));\\n        v[0][0]=0;\\n        queue<pair<int,int>>q;\\n        int dir[][2]={{1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2086685,
                "title": "please-help-me-find-the-tle-issue-in-my-code",
                "content": "I am getting TLE in my code, anyone kindly help.\\n\\n```\\nclass Solution {\\npublic:\\n    set<pair<int, int>> visited;\\n    vector<int> dirs = {1, 0, -1, 0, 1};\\n    \\n   \\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> q;\\n        q.push({0, 0, 0});\\n        int res = m*n;\\n        visited.insert({0, 0});\\n        while(!q.empty()){\\n            int u  =q.top()[1];\\n            int v = q.top()[2];\\n            int val = q.top()[0];\\n            q.pop();\\n            for (int i = 0; i<4; i++){\\n                int nu = u+dirs[i], nv = v+dirs[i+1];\\n                if (nu>=0 and nu<m and nv>=0 and nv<n and visited.find({nu, nv})==visited.end()){\\n                    if (nu == m-1 and nv == n-1){\\n                        res = min(res, val+grid[nu][nv]);\\n                        continue;\\n                    }\\n                    visited.insert({nu, nv});\\n                    q.push({val+grid[nu][nv], nu, nv});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    set<pair<int, int>> visited;\\n    vector<int> dirs = {1, 0, -1, 0, 1};\\n    \\n   \\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> q;\\n        q.push({0, 0, 0});\\n        int res = m*n;\\n        visited.insert({0, 0});\\n        while(!q.empty()){\\n            int u  =q.top()[1];\\n            int v = q.top()[2];\\n            int val = q.top()[0];\\n            q.pop();\\n            for (int i = 0; i<4; i++){\\n                int nu = u+dirs[i], nv = v+dirs[i+1];\\n                if (nu>=0 and nu<m and nv>=0 and nv<n and visited.find({nu, nv})==visited.end()){\\n                    if (nu == m-1 and nv == n-1){\\n                        res = min(res, val+grid[nu][nv]);\\n                        continue;\\n                    }\\n                    visited.insert({nu, nv});\\n                    q.push({val+grid[nu][nv], nu, nv});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086214,
                "title": "javascript-simple-bfs-with-updating-distance",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumObstacles = function(grid) {\\n    let dx=[[0,1],[0,-1],[1,0],[-1,0]];\\n    let distance=[];\\n    for(let i=0;i<grid.length;i++){\\n        distance[i]=[];\\n        for(let j=0;j<grid[i].length;j++){\\n            distance[i][j]=Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    return bfs(0,0);\\n    \\n    function bfs(row,col){\\n        let queue=[];\\n        distance[row][col]=0;\\n        queue.push([row,col]);\\n        while(queue.length>0){\\n            let element = queue.shift();\\n            let row = element[0];\\n            let col = element[1];\\n            let originalDist = distance[row][col];\\n            for(let d=0;d<dx.length;d++){\\n                let i = row + dx[d][0];\\n                let j = col + dx[d][1];\\n                if(i>=0 && i<=grid.length-1 && j>=0 && j<=grid[i].length-1){\\n                    let dist = originalDist;\\n                    if(grid[i][j]===1){\\n                        dist++;\\n                    }\\n                    if(distance[i][j]>dist){//Update distance for this neighbour node if the new distance is smaller than the previous distance\\n                        queue.push([i,j]);\\n                        distance[i][j]=dist;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        //return the minimum distance for last cell after completing the process\\n        return distance[(grid.length-1)][(grid[row].length-1)];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar minimumObstacles = function(grid) {\\n    let dx=[[0,1],[0,-1],[1,0],[-1,0]];\\n    let distance=[];\\n    for(let i=0;i<grid.length;i++){\\n        distance[i]=[];\\n        for(let j=0;j<grid[i].length;j++){\\n            distance[i][j]=Number.MAX_SAFE_INTEGER;\\n        }\\n    }\\n    return bfs(0,0);\\n    \\n    function bfs(row,col){\\n        let queue=[];\\n        distance[row][col]=0;\\n        queue.push([row,col]);\\n        while(queue.length>0){\\n            let element = queue.shift();\\n            let row = element[0];\\n            let col = element[1];\\n            let originalDist = distance[row][col];\\n            for(let d=0;d<dx.length;d++){\\n                let i = row + dx[d][0];\\n                let j = col + dx[d][1];\\n                if(i>=0 && i<=grid.length-1 && j>=0 && j<=grid[i].length-1){\\n                    let dist = originalDist;\\n                    if(grid[i][j]===1){\\n                        dist++;\\n                    }\\n                    if(distance[i][j]>dist){//Update distance for this neighbour node if the new distance is smaller than the previous distance\\n                        queue.push([i,j]);\\n                        distance[i][j]=dist;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        //return the minimum distance for last cell after completing the process\\n        return distance[(grid.length-1)][(grid[row].length-1)];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2086179,
                "title": "python-heap-bfs-solution",
                "content": "so the Algorithm will run like :  to  reach (i,j)th position of array, how much obstacles needs to be cleared\\n\\nalgorithm steps:\\n1. find next node which is unvisited with the lowest cost (used heap for searching)\\n2. if node is destination: return the cost\\n3. else: add children of that node into the heap\\n\\nTime Complexity : O(n^2)\\nSpace Complexity: O(n^2)\\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        visited = [[False]*m for _ in range(n)]\\n        \\n        paths = [ (0,-1),(-1,0),(0,1),(1,0)]\\n        \\n        queue = [(0,0,0)]  #val, x,y will be pushed\\n\\n        while queue:\\n            val,i,j = heappop(queue)\\n            if i == n-1 and j==m-1:\\n                return val + grid[i][j]\\n\\n            for x,y in paths:\\n                x1 = i+x\\n                y1 = j+y\\n                \\n                if (x1>=0 and x1<n and y1>=0 and y1<m and not visited[x1][y1]):\\n                    visited[x1][y1] = True\\n                    heappush(queue, (val + grid[x1][y1], x1, y1))\\n                    \\n        return -1\\n```\\n\\nin case of any clarification please add comment\\nupvode if you like it..",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        visited = [[False]*m for _ in range(n)]\\n        \\n        paths = [ (0,-1),(-1,0),(0,1),(1,0)]\\n        \\n        queue = [(0,0,0)]  #val, x,y will be pushed\\n\\n        while queue:\\n            val,i,j = heappop(queue)\\n            if i == n-1 and j==m-1:\\n                return val + grid[i][j]\\n\\n            for x,y in paths:\\n                x1 = i+x\\n                y1 = j+y\\n                \\n                if (x1>=0 and x1<n and y1>=0 and y1<m and not visited[x1][y1]):\\n                    visited[x1][y1] = True\\n                    heappush(queue, (val + grid[x1][y1], x1, y1))\\n                    \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085965,
                "title": "simple-bfs",
                "content": "I missed one line in the contest and got an TLE, but figured it out after the contest. :(\\n\\nThe idea is to find the \\'layer\\' in each step and process them in **q**. For the cells in the neighborhood of the cell from current layer (whose grid[i][j] == 1), we store them in **p**. The first layer is the connected component of (0, 0) with all grid[i][j] == 0. After processing one layer, we increase count by 1 meaning that we remove an obstacle.\\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        visited = [[True] * n for _ in  range(m)]\\n        visited[0][0] = False\\n        q = deque([(0, 0)])\\n        count = 0\\n        while True:\\n            p = deque([])\\n            while q:\\n                i, j = q.popleft()\\n                if i == m - 1 and j == n - 1:\\n                    return count\\n                for di, dj in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\\n                    if 0 <= di < m and 0 <= dj < n and visited[di][dj]:\\n                        visited[di][dj] = False\\n                        if grid[di][dj] == 0:\\n                            q.append((di, dj))\\n                        else:\\n                            p.append((di, dj))\\n            q = p\\n            count += 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        visited = [[True] * n for _ in  range(m)]\\n        visited[0][0] = False\\n        q = deque([(0, 0)])\\n        count = 0\\n        while True:\\n            p = deque([])\\n            while q:\\n                i, j = q.popleft()\\n                if i == m - 1 and j == n - 1:\\n                    return count\\n                for di, dj in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]:\\n                    if 0 <= di < m and 0 <= dj < n and visited[di][dj]:\\n                        visited[di][dj] = False\\n                        if grid[di][dj] == 0:\\n                            q.append((di, dj))\\n                        else:\\n                            p.append((di, dj))\\n            q = p\\n            count += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085951,
                "title": "ordered-bfs-python-o-m-n-time-and-space-commented",
                "content": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        noOfObstaclesToReach = [[-1]*n for _ in range(m)]   # s: O(m*n)\\n\\t\\tnoOfObstaclesToReach[0][0] = grid[0][0]\\n        nodeQueue = deque([(0,0)])                          # s: O(m*n)\\n        directions = [0,1,0,-1,0]\\n        \\n        while len(nodeQueue) > 0 and noOfObstaclesToReach[m-1][n-1] == -1:\\n            currNodeX, currNodeY = nodeQueue.popleft()      # each node gets in and out atmost once - O(m*n)\\n            for i in range(4):                              # O(1)\\n                neighborX, neighborY = currNodeX + directions[i], currNodeY + directions[i+1]\\n                if 0 <= neighborX < m and 0 <= neighborY < n and noOfObstaclesToReach[neighborX][neighborY] == -1:    # unvisited valid nodes\\n                    if grid[neighborX][neighborY] == 0:                # node without obstacle added to the beginning\\n                        noOfObstaclesToReach[neighborX][neighborY] = noOfObstaclesToReach[currNodeX][currNodeY]\\n                        nodeQueue.appendleft((neighborX, neighborY))\\n                    else:                                              # node with obstacle added to the end\\n                        noOfObstaclesToReach[neighborX][neighborY] = noOfObstaclesToReach[currNodeX][currNodeY] + 1\\n                        nodeQueue.append((neighborX, neighborY))\\n        return noOfObstaclesToReach[m-1][n-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        noOfObstaclesToReach = [[-1]*n for _ in range(m)]   # s: O(m*n)\\n\\t\\tnoOfObstaclesToReach[0][0] = grid[0][0]\\n        nodeQueue = deque([(0,0)])                          # s: O(m*n)\\n        directions = [0,1,0,-1,0]\\n        \\n        while len(nodeQueue) > 0 and noOfObstaclesToReach[m-1][n-1] == -1:\\n            currNodeX, currNodeY = nodeQueue.popleft()      # each node gets in and out atmost once - O(m*n)\\n            for i in range(4):                              # O(1)\\n                neighborX, neighborY = currNodeX + directions[i], currNodeY + directions[i+1]\\n                if 0 <= neighborX < m and 0 <= neighborY < n and noOfObstaclesToReach[neighborX][neighborY] == -1:    # unvisited valid nodes\\n                    if grid[neighborX][neighborY] == 0:                # node without obstacle added to the beginning\\n                        noOfObstaclesToReach[neighborX][neighborY] = noOfObstaclesToReach[currNodeX][currNodeY]\\n                        nodeQueue.appendleft((neighborX, neighborY))\\n                    else:                                              # node with obstacle added to the end\\n                        noOfObstaclesToReach[neighborX][neighborY] = noOfObstaclesToReach[currNodeX][currNodeY] + 1\\n                        nodeQueue.append((neighborX, neighborY))\\n        return noOfObstaclesToReach[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085897,
                "title": "c-bfs-without-priority-queue-o-n-m",
                "content": "Instead of having a priority queue we can make an array of vector and then we will start from 0. Here the index of vector array denotes the steps required to reach last cell. We will increment the index from position 0 which means we will move only when all the cells reachable in 0 steps are processed. \\nIn this way we can remove the use of priority queue.\\n```\\n#pragma GCC optimize(\"O3,unroll-loops\")\\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\\nclass Solution\\n{\\npublic:\\n    int n, m;\\n    bool valid(int i, int j)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n            return true;\\n        return false;\\n    }\\n    int minimumObstacles(vector<vector<int>> &g)\\n    {\\n        n = g.size(), m = g[0].size();\\n        int dp[n][m];\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++)\\n                dp[i][j] = INT_MAX;\\n        dp[n - 1][m - 1] = 0;\\n        int ind = 0;\\n        vector<vector<int>> v[100005];\\n        v[0].push_back({n - 1, m - 1});\\n        while (1)\\n        {\\n            if (v[ind].size() == 0)\\n                ind++;\\n            if (v[ind].size() == 0)\\n                break;\\n            vector<int> x = v[ind].back();\\n            v[ind].pop_back();\\n            int i = x[0] - 1, j = x[1];\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0] + 1, j = x[1];\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0], j = x[1] - 1;\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0], j = x[1] + 1;\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#pragma GCC optimize(\"O3,unroll-loops\")\\n#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")\\nclass Solution\\n{\\npublic:\\n    int n, m;\\n    bool valid(int i, int j)\\n    {\\n        if (i >= 0 && i < n && j >= 0 && j < m)\\n            return true;\\n        return false;\\n    }\\n    int minimumObstacles(vector<vector<int>> &g)\\n    {\\n        n = g.size(), m = g[0].size();\\n        int dp[n][m];\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++)\\n                dp[i][j] = INT_MAX;\\n        dp[n - 1][m - 1] = 0;\\n        int ind = 0;\\n        vector<vector<int>> v[100005];\\n        v[0].push_back({n - 1, m - 1});\\n        while (1)\\n        {\\n            if (v[ind].size() == 0)\\n                ind++;\\n            if (v[ind].size() == 0)\\n                break;\\n            vector<int> x = v[ind].back();\\n            v[ind].pop_back();\\n            int i = x[0] - 1, j = x[1];\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0] + 1, j = x[1];\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0], j = x[1] - 1;\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n            i = x[0], j = x[1] + 1;\\n            if (valid(i, j) && dp[i][j] > dp[x[0]][x[1]] + g[i][j])\\n            {\\n                dp[i][j] = dp[x[0]][x[1]] + g[i][j];\\n                v[dp[i][j]].push_back({i, j});\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085714,
                "title": "c-o-n-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        deque <array<int, 3>> Q;\\n        int vis[n][m];\\n        memset(vis, -1, sizeof vis);\\n        Q.push_back({0, 0, 0});\\n        vis[0][0] = 0;\\n        const int dx[] = {1, -1, 0, 0};\\n        const int dy[] = {0, 0, 1, -1};\\n        auto inside = [&](int x, int y) {\\n          return x >= 0 and x < n and y >=0 and y < m;\\n        };\\n        while (!Q.empty()) {\\n          auto [x, y, d] = Q.front();\\n          Q.pop_front();\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (inside(xx, yy) and vis[xx][yy] == -1) {\\n              if (a[xx][yy]) {\\n                vis[xx][yy] = vis[x][y] + 1;\\n                Q.push_back({xx, yy, 1});\\n              } else {\\n                vis[xx][yy] = vis[x][y];\\n                Q.push_front({xx, yy, 0});\\n              }\\n            }\\n          }\\n        }\\n        return vis[n - 1][m - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        deque <array<int, 3>> Q;\\n        int vis[n][m];\\n        memset(vis, -1, sizeof vis);\\n        Q.push_back({0, 0, 0});\\n        vis[0][0] = 0;\\n        const int dx[] = {1, -1, 0, 0};\\n        const int dy[] = {0, 0, 1, -1};\\n        auto inside = [&](int x, int y) {\\n          return x >= 0 and x < n and y >=0 and y < m;\\n        };\\n        while (!Q.empty()) {\\n          auto [x, y, d] = Q.front();\\n          Q.pop_front();\\n          for (int i = 0; i < 4; ++i) {\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            if (inside(xx, yy) and vis[xx][yy] == -1) {\\n              if (a[xx][yy]) {\\n                vis[xx][yy] = vis[x][y] + 1;\\n                Q.push_back({xx, yy, 1});\\n              } else {\\n                vis[xx][yy] = vis[x][y];\\n                Q.push_front({xx, yy, 0});\\n              }\\n            }\\n          }\\n        }\\n        return vis[n - 1][m - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2085676,
                "title": "java-dijkstra",
                "content": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            return a[2] - b[2];\\n        });\\n        int[][] dirs = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\\n        pq.add(new int[]{0, 0, 0});\\n        while (pq.size() != 0) {\\n            int[] rem = pq.remove();\\n            if (rem[0] == grid.length - 1 && rem[1] == grid[0].length - 1) {\\n                return rem[2];\\n            }\\n            for (int[] dir : dirs) {\\n                int nr = rem[0] + dir[0];\\n                int nc = rem[1] + dir[1];\\n                if (nr >= 0 && nc >= 0 && nr < grid.length && nc < grid[0].length && !visited[nr][nc]) {\\n                    visited[nr][nc] = true;\\n                    pq.add(new int[]{nr, nc, rem[2] + grid[nr][nc]});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\\n            return a[2] - b[2];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2085648,
                "title": "python-use-heap-to-find-the-next-step",
                "content": "This question is similar to [1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)\\n\\nQuestion 1293 is to find the shortest path. We use BFS, and FIFO queue can help us find the next step is the step with shortest path.\\n\\nFor this question, we need to find the path with minimal obstacles removal. We can use heap to find the next step with smallest k, while k means the number of obstacle we have removed. For search itself, we can copy the BFS function with a visited set to make sure we wont visit same place twice. \\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        heap = list()\\n        heapq.heappush(heap, (0, 0, 0))\\n        visited = set()\\n        visited.add((0,0))\\n        \\n        while len(heap) > 0:\\n            k, i, j = heapq.heappop(heap)\\n            if i == m-1 and j == n-1:\\n                return k\\n            for di,dj in [(-1,0), (1,0), (0,-1), (0,1)]:\\n                i1 = i + di\\n                j1 = j + dj\\n                if 0 <= i1 < m and 0<= j1 < n:\\n                    if (i1,j1) not in visited:\\n                        visited.add((i1,j1))\\n                        heapq.heappush(heap, (k+grid[i1][j1], i1, j1))\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        heap = list()\\n        heapq.heappush(heap, (0, 0, 0))\\n        visited = set()\\n        visited.add((0,0))\\n        \\n        while len(heap) > 0:\\n            k, i, j = heapq.heappop(heap)\\n            if i == m-1 and j == n-1:\\n                return k\\n            for di,dj in [(-1,0), (1,0), (0,-1), (0,1)]:\\n                i1 = i + di\\n                j1 = j + dj\\n                if 0 <= i1 < m and 0<= j1 < n:\\n                    if (i1,j1) not in visited:\\n                        visited.add((i1,j1))\\n                        heapq.heappush(heap, (k+grid[i1][j1], i1, j1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088485,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//use abbreviations when needed\\n#define pii pair<int,pair<int,int>>\\n\\nclass Solution \\n{\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        //directions(top,right,bottom,left)\\n        //eases the task of traversing adjacent cells\\n        int dx[4]={0,1,0,-1};\\n        int dy[4]={-1,0,1,0};\\n\\n        int m,n;\\n        m=grid.size();\\n        n=grid[0].size();\\n        \\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\\n        vector<vector<int>> dis(m,vector<int>(n,INT_MAX));\\n\\n        pq.push({0,{0,0}});\\n        dis[0][0]=0;\\n\\n        while(!pq.empty())\\n        {\\n            //d for distance and c for coordinates\\n            auto [d,c]=pq.top();\\n            pq.pop();\\n\\n            if(c.first==m-1 && c.second==n-1)\\n            {\\n                return d;\\n            }\\n\\n            for(int i=0;i<4;i++)\\n            {\\n                int x=c.first+dx[i];\\n                int y=c.second+dy[i];\\n\\n                if(x<0 || x>=m || y<0 || y>=n)\\n                {\\n                    continue;\\n                }\\n\\n                int currd=d+grid[x][y];\\n\\n                if(currd<dis[x][y])\\n                {\\n                    dis[x][y]=currd;\\n                    pq.push({currd,{x,y}});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//use abbreviations when needed\\n#define pii pair<int,pair<int,int>>\\n\\nclass Solution \\n{\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        //directions(top,right,bottom,left)\\n        //eases the task of traversing adjacent cells\\n        int dx[4]={0,1,0,-1};\\n        int dy[4]={-1,0,1,0};\\n\\n        int m,n;\\n        m=grid.size();\\n        n=grid[0].size();\\n        \\n        priority_queue<pii,vector<pii>,greater<pii>> pq;\\n        vector<vector<int>> dis(m,vector<int>(n,INT_MAX));\\n\\n        pq.push({0,{0,0}});\\n        dis[0][0]=0;\\n\\n        while(!pq.empty())\\n        {\\n            //d for distance and c for coordinates\\n            auto [d,c]=pq.top();\\n            pq.pop();\\n\\n            if(c.first==m-1 && c.second==n-1)\\n            {\\n                return d;\\n            }\\n\\n            for(int i=0;i<4;i++)\\n            {\\n                int x=c.first+dx[i];\\n                int y=c.second+dy[i];\\n\\n                if(x<0 || x>=m || y<0 || y>=n)\\n                {\\n                    continue;\\n                }\\n\\n                int currd=d+grid[x][y];\\n\\n                if(currd<dis[x][y])\\n                {\\n                    dis[x][y]=currd;\\n                    pq.push({currd,{x,y}});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066270,
                "title": "0-1-bfs-typical-example-great-learning-opportunity-python-deque-beats-86",
                "content": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        dq = collections.deque([(0,0,0)])\\n        R  = len(grid)\\n        C  = len(grid[0])\\n        visited = set([(0,0)])\\n        dirs = [(1,0),(0,1),(0,-1),(-1,0)]\\n        \\n        while dq:\\n            r,c,obs = dq.popleft()\\n            if r == R-1 and c == C-1:\\n                return obs\\n            for d in dirs:\\n                dr,dc = d\\n                nr,nc = r+dr,c+dc\\n                \\n                if 0<=nr<R and 0<=nc<C and (nr,nc) not in visited:\\n                    visited.add((nr,nc))\\n                    if grid[nr][nc] == 1:\\n                        dq.append((nr,nc,obs+1))\\n                    else:\\n                        dq.appendleft((nr,nc,obs))",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        dq = collections.deque([(0,0,0)])\\n        R  = len(grid)\\n        C  = len(grid[0])\\n        visited = set([(0,0)])\\n        dirs = [(1,0),(0,1),(0,-1),(-1,0)]\\n        \\n        while dq:\\n            r,c,obs = dq.popleft()\\n            if r == R-1 and c == C-1:\\n                return obs\\n            for d in dirs:\\n                dr,dc = d\\n                nr,nc = r+dr,c+dc\\n                \\n                if 0<=nr<R and 0<=nc<C and (nr,nc) not in visited:\\n                    visited.add((nr,nc))\\n                    if grid[nr][nc] == 1:\\n                        dq.append((nr,nc,obs+1))\\n                    else:\\n                        dq.appendleft((nr,nc,obs))",
                "codeTag": "Java"
            },
            {
                "id": 4060368,
                "title": "c-dijkstra-algo-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dist(n,vector<int>(m,1e9));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({0,{0,0}});\\n        dist[0][0]=0;\\n        int dr[4]={-1,0,1,0};\\n        int dc[4]={0,1,0,-1};\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int cost=it.first;\\n            int r=it.second.first;\\n            int c=it.second.second;\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<m){\\n                    int cst=grid[nr][nc];\\n                    if(cost+cst<dist[nr][nc]){\\n                        dist[nr][nc]=cost+cst;\\n                        pq.push({dist[nr][nc],{nr,nc}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> dist(n,vector<int>(m,1e9));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,\\n        greater<pair<int,pair<int,int>>>> pq;\\n        pq.push({0,{0,0}});\\n        dist[0][0]=0;\\n        int dr[4]={-1,0,1,0};\\n        int dc[4]={0,1,0,-1};\\n        while(!pq.empty()){\\n            auto it=pq.top();\\n            int cost=it.first;\\n            int r=it.second.first;\\n            int c=it.second.second;\\n            pq.pop();\\n            for(int i=0;i<4;i++){\\n                int nr=r+dr[i];\\n                int nc=c+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<m){\\n                    int cst=grid[nr][nc];\\n                    if(cost+cst<dist[nr][nc]){\\n                        dist[nr][nc]=cost+cst;\\n                        pq.push({dist[nr][nc],{nr,nc}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055534,
                "title": "bfs-deque-cpp-explained",
                "content": "# Intuition\\nThe goal of this problem is for us to travel from the cell (0,0) in the matrix to cell (n-1,m-1) n=number of rows m=number of columns and we have to choose such path where we need to remove either 0 or the minimum breakers that some cell might have.\\n\\n# Approach\\nThe approach that comes to mind seeing this grid problem is of dynamic programming but having tried that and getting WA gave an intuition  that we cannot assume that a path that is optimal for now will remain optimal for the rest of the traversal.\\n\\nSo the problems that led to take a deque instead of queue as the data structure of choice was we have to take both an empty cell and a cell with blockers because maybe the cell that is empty is trying to trick us and when we go further inside the matrix we might see we had one blocker to remove above if we haven\\'t chosen the empty cell now we have 3.\\n\\nSo we need to add both empty cell and blocker cell now there is a matter of preference that we should consider too.\\nWe have to take the empty cell whenever necessary if it doesn\\'t provide the optimal answer go for the blocker.\\nThus the birth of deque.\\n\\nNow take another matrix that will store the answer of every path we are going to traverse and give us the answer at the cell (n-1)(m-1).\\n\\nWhile using bfs we see whenever we find a empty cell we push it in front and blocker at the back.\\nGo on traversing till the deque is not empty.\\n\\n# Complexity\\n- Time complexity:\\nO((n*m)log(n*m));\\n\\n- Space complexity:O(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n       vector<pair<int,int>> directions={{-1,0},{1,0},{0,1},{0,-1}};\\n       int n=grid.size();\\n       int m=grid[0].size();\\n      vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n      vector<vector<int>> visited(n,vector<int>(m,0));\\n      deque<pair<int,int>> q;\\n      q.push_front({0,0});\\n      visited[0][0]=1;\\n      dp[0][0]=0;\\n      while(!q.empty()){\\n        auto curr=q.front();\\n        q.pop_front();\\n        for(auto direct:directions){\\n          int rrow=curr.first+direct.first;\\n          int ccol=curr.second+direct.second;\\n          if(rrow>=0 and rrow<n and ccol>=0 and ccol<m){\\n            if(!visited[rrow][ccol]){\\n              visited[rrow][ccol]=1;\\n              dp[rrow][ccol]=dp[curr.first][curr.second]+(grid[rrow][ccol]==1);\\n              if(grid[rrow][ccol]==1){\\n                q.push_back({rrow,ccol});\\n              }else q.push_front({rrow,ccol});\\n            }\\n          }\\n        }\\n      }\\n      return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n       vector<pair<int,int>> directions={{-1,0},{1,0},{0,1},{0,-1}};\\n       int n=grid.size();\\n       int m=grid[0].size();\\n      vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n      vector<vector<int>> visited(n,vector<int>(m,0));\\n      deque<pair<int,int>> q;\\n      q.push_front({0,0});\\n      visited[0][0]=1;\\n      dp[0][0]=0;\\n      while(!q.empty()){\\n        auto curr=q.front();\\n        q.pop_front();\\n        for(auto direct:directions){\\n          int rrow=curr.first+direct.first;\\n          int ccol=curr.second+direct.second;\\n          if(rrow>=0 and rrow<n and ccol>=0 and ccol<m){\\n            if(!visited[rrow][ccol]){\\n              visited[rrow][ccol]=1;\\n              dp[rrow][ccol]=dp[curr.first][curr.second]+(grid[rrow][ccol]==1);\\n              if(grid[rrow][ccol]==1){\\n                q.push_back({rrow,ccol});\\n              }else q.push_front({rrow,ccol});\\n            }\\n          }\\n        }\\n      }\\n      return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033903,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int dx[4] = {0,1,0,-1};\\n        int dy[4] = {1,0,-1,0};\\n        vector<vector<int>> obs(n, vector<int>(m, INT_MAX));\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        obs[0][0] = 0;\\n        \\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n            \\n            for(int i=0; i<4; ++i){\\n                int x1 = x+dx[i], y1 = y+dy[i];\\n                if(x1<0 || x1>=n || y1<0 || y1>=m) continue;\\n                int blocks = obs[x][y] + grid[x1][y1];\\n                if(blocks >= obs[x1][y1]) continue;\\n                \\n                obs[x1][y1] = blocks;\\n                q.push({x1,y1});\\n            }\\n        }\\n        return obs[n-1][m-1];\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        int dx[4] = {0,1,0,-1};\\n        int dy[4] = {1,0,-1,0};\\n        vector<vector<int>> obs(n, vector<int>(m, INT_MAX));\\n        \\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        obs[0][0] = 0;\\n        \\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n            \\n            for(int i=0; i<4; ++i){\\n                int x1 = x+dx[i], y1 = y+dy[i];\\n                if(x1<0 || x1>=n || y1<0 || y1>=m) continue;\\n                int blocks = obs[x][y] + grid[x1][y1];\\n                if(blocks >= obs[x1][y1]) continue;\\n                \\n                obs[x1][y1] = blocks;\\n                q.push({x1,y1});\\n            }\\n        }\\n        return obs[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005542,
                "title": "easy-to-understand-python-solution-using-heap",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n*m*log(n*m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\n        heap = [(0,0,0)]\\n\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        seen = set()\\n        dirs = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n\\n        res = float(\\'inf\\')\\n\\n        while heap:\\n            obstacles, x, y = heapq.heappop(heap)\\n            if (x,y) in seen:\\n                continue\\n            seen.add((x,y))\\n            if x == rows - 1 and y == cols - 1:\\n                return obstacles\\n            for dr, dc in dirs:\\n                r = x + dr\\n                c = y + dc\\n                if 0<=r< rows and 0<=c<cols and (r,c) not in seen:\\n                    if grid[r][c] == 1:\\n                        heapq.heappush(heap,(obstacles + 1, r,c))\\n                    else:\\n                        heapq.heappush(heap,(obstacles, r,c))\\n        \\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\n        heap = [(0,0,0)]\\n\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        \\n        seen = set()\\n        dirs = [(0, 1), (1, 0), (-1, 0), (0, -1)]\\n\\n        res = float(\\'inf\\')\\n\\n        while heap:\\n            obstacles, x, y = heapq.heappop(heap)\\n            if (x,y) in seen:\\n                continue\\n            seen.add((x,y))\\n            if x == rows - 1 and y == cols - 1:\\n                return obstacles\\n            for dr, dc in dirs:\\n                r = x + dr\\n                c = y + dc\\n                if 0<=r< rows and 0<=c<cols and (r,c) not in seen:\\n                    if grid[r][c] == 1:\\n                        heapq.heappush(heap,(obstacles + 1, r,c))\\n                    else:\\n                        heapq.heappush(heap,(obstacles, r,c))\\n        \\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992021,
                "title": "easy-to-catch-beginners-friendly-c-beats-80-iit-roorkee",
                "content": "# Complexity\\n- Time complexity:O(N*N)\\n- Space complexity:O(N*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        dp[0][0]=0;\\n        pq.push({0,{0,0}});\\n        int ar[]={1,-1,0,0};\\n        int br[]={0,0,1,-1};\\n        while(!pq.empty())\\n        {\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            pq.pop();\\n            if((x==(n-1))&&(y==(m-1)))\\n            {\\n                return dp[x][y];\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int r=x+ar[i];\\n                int c=y+br[i];\\n                if((r>=0)&&(c>=0)&&(r<n)&&(c<m))\\n                {\\n                    if(grid[r][c]==1)\\n                    {\\n                        if(dp[r][c]>1+dp[x][y])\\n                        {\\n                            dp[r][c]=1+dp[x][y];\\n                            pq.push({dp[r][c],{r,c}});\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(dp[r][c]>dp[x][y])\\n                        {\\n                            dp[r][c]=dp[x][y];\\n                            pq.push({dp[r][c],{r,c}});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid)\\n    {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        dp[0][0]=0;\\n        pq.push({0,{0,0}});\\n        int ar[]={1,-1,0,0};\\n        int br[]={0,0,1,-1};\\n        while(!pq.empty())\\n        {\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            pq.pop();\\n            if((x==(n-1))&&(y==(m-1)))\\n            {\\n                return dp[x][y];\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int r=x+ar[i];\\n                int c=y+br[i];\\n                if((r>=0)&&(c>=0)&&(r<n)&&(c<m))\\n                {\\n                    if(grid[r][c]==1)\\n                    {\\n                        if(dp[r][c]>1+dp[x][y])\\n                        {\\n                            dp[r][c]=1+dp[x][y];\\n                            pq.push({dp[r][c],{r,c}});\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(dp[r][c]>dp[x][y])\\n                        {\\n                            dp[r][c]=dp[x][y];\\n                            pq.push({dp[r][c],{r,c}});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989312,
                "title": "dijkstra-java-with-inline-comments-and-intuition",
                "content": "# Intuition\\nfind all routes from src to dest \\ncount all the obstacles along the way\\nroute having min number of obstacles + ( shortest one) along the way should be the best one?\\nthink about - minimum number of obstacles to remove \\n?dijkstra - consider obstacle path as cost to be paid \\n0 - path with no cost\\n1 - path with 1 cost\\nAdd the obstacle removal cost to distance \\nDijkstra - use PQ \\n\\n\\n# Complexity\\n**- Time complexity:**\\nInitializing the dist array with Integer.MAX_VALUE takes O(m * n), where m is the number of rows and n is the number of columns in the grid.\\nThe PriorityQueue (pq) can have at most m * n elements, and in the worst case, all cells are processed, so the loop will run a maximum of m * n times.\\nInside the loop, you have a loop that iterates over the four directions, which is a constant factor.\\nOverall, the time complexity of the code is **O(m * n + log(m * n))**, where log(m * n) comes from the PriorityQueue operations.\\n**- Space complexity:**\\nO(m * n) \\n# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dirs = {{0,1},{1,0},{0, -1}, {-1, 0}};\\n        // to capture the distance\\n        int[][] dist = new int[m][n];\\n        // initially populate the distance with Infinity\\n        for(int[]arr: dist) Arrays.fill(arr, Integer.MAX_VALUE);\\n        // Create PQ to hold grid positions and their distances\\n        // PQ will store {x, y, dist} as triplets sorted by dist asc \\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        // add starting position to the queue which is upper left cornter\\n        // (0,0) with distance set to zero\\n        pq.offer(new int[]{0, 0, 0});\\n        dist[0][0] = 0;\\n        while(!pq.isEmpty()){\\n            int[] current = pq.poll(); // poll the one with smallest distance\\n            int x = current[0];\\n            int y = current[1];\\n            int distance = current[2];\\n            // check if we have reached destination\\n            if(x == m-1 && y==n-1) return distance;\\n            // now from current cell move in all 4 directions\\n            // below for loop creates new coordinates of the cell\\n            for(int[]dir: dirs) {\\n                int nx = x + dir[0]; //new x\\n                int ny = y + dir[1]; //new y\\n                //validate out of grid coordinates and reject them\\n                if(nx<0 || nx>=m || ny<0 || ny>=n) continue;\\n                //for valid coordinates re-compute the distance from previous source i.e {x, y}\\n                if(dist[nx][ny]> distance + grid[nx][ny]) {\\n                    dist[nx][ny] = distance + grid[nx][ny];\\n                    pq.offer(new int[]{nx, ny, dist[nx][ny]});\\n                }\\n            }\\n\\n        }\\n\\n        // dist[][] will contain the cost of reaching to m-1, n-1\\n        return dist[m-1][n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dirs = {{0,1},{1,0},{0, -1}, {-1, 0}};\\n        // to capture the distance\\n        int[][] dist = new int[m][n];\\n        // initially populate the distance with Infinity\\n        for(int[]arr: dist) Arrays.fill(arr, Integer.MAX_VALUE);\\n        // Create PQ to hold grid positions and their distances\\n        // PQ will store {x, y, dist} as triplets sorted by dist asc \\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        // add starting position to the queue which is upper left cornter\\n        // (0,0) with distance set to zero\\n        pq.offer(new int[]{0, 0, 0});\\n        dist[0][0] = 0;\\n        while(!pq.isEmpty()){\\n            int[] current = pq.poll(); // poll the one with smallest distance\\n            int x = current[0];\\n            int y = current[1];\\n            int distance = current[2];\\n            // check if we have reached destination\\n            if(x == m-1 && y==n-1) return distance;\\n            // now from current cell move in all 4 directions\\n            // below for loop creates new coordinates of the cell\\n            for(int[]dir: dirs) {\\n                int nx = x + dir[0]; //new x\\n                int ny = y + dir[1]; //new y\\n                //validate out of grid coordinates and reject them\\n                if(nx<0 || nx>=m || ny<0 || ny>=n) continue;\\n                //for valid coordinates re-compute the distance from previous source i.e {x, y}\\n                if(dist[nx][ny]> distance + grid[nx][ny]) {\\n                    dist[nx][ny] = distance + grid[nx][ny];\\n                    pq.offer(new int[]{nx, ny, dist[nx][ny]});\\n                }\\n            }\\n\\n        }\\n\\n        // dist[][] will contain the cost of reaching to m-1, n-1\\n        return dist[m-1][n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985864,
                "title": "java-simple-solution-with-dijkestra-very-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n- Space complexity:\\nO(M*N)\\n\\n# Code\\n```\\n\\nclass Solution {\\n       int[][] dirs = {{0,1},{0,-1}, {1,0},{-1,0}};\\n\\n         int[][] dist = null;\\n    public int minimumObstacles(int[][] grid) {\\n  int m = grid.length;\\n        int n = grid[0].length;\\n\\n        dist = new int[m][n];\\n\\n        for (int[] disArray : dist) {\\n            Arrays.fill(disArray, (int)1e9);\\n        }\\n\\n        dist[0][0] = grid[0][0];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[2] - b[2]));\\n       \\n        pq.offer(new int[]{ 0,  0, dist[0][0]});\\n\\n        while (!pq.isEmpty()) {\\n\\n            int[] cur = pq.poll();\\n\\n            int x = cur[0];\\n            int y = cur[1];\\n            int currCost = cur[2];\\n\\n            if (x == m - 1 && y == n - 1) {\\n                return currCost;\\n            }\\n\\n            for (int[] dir : dirs) {\\n\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx >=0 && nx<m && ny >=0 && ny<n && currCost + grid[nx][ny] < dist[nx][ny]) {\\n                    dist[nx][ny] = currCost + grid[nx][ny];\\n                    pq.offer(new int[]{nx, ny,dist[nx][ny]});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n       int[][] dirs = {{0,1},{0,-1}, {1,0},{-1,0}};\\n\\n         int[][] dist = null;\\n    public int minimumObstacles(int[][] grid) {\\n  int m = grid.length;\\n        int n = grid[0].length;\\n\\n        dist = new int[m][n];\\n\\n        for (int[] disArray : dist) {\\n            Arrays.fill(disArray, (int)1e9);\\n        }\\n\\n        dist[0][0] = grid[0][0];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[2] - b[2]));\\n       \\n        pq.offer(new int[]{ 0,  0, dist[0][0]});\\n\\n        while (!pq.isEmpty()) {\\n\\n            int[] cur = pq.poll();\\n\\n            int x = cur[0];\\n            int y = cur[1];\\n            int currCost = cur[2];\\n\\n            if (x == m - 1 && y == n - 1) {\\n                return currCost;\\n            }\\n\\n            for (int[] dir : dirs) {\\n\\n                int nx = x + dir[0];\\n                int ny = y + dir[1];\\n                if (nx >=0 && nx<m && ny >=0 && ny<n && currCost + grid[nx][ny] < dist[nx][ny]) {\\n                    dist[nx][ny] = currCost + grid[nx][ny];\\n                    pq.offer(new int[]{nx, ny,dist[nx][ny]});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983119,
                "title": "cpp-solution-using-dijkstra-s-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n         int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> cost(n , vector<int> (m , INT_MAX));\\n        set<pair<int , pair<int , int>>> store;\\n        cost[0][0] = 0;\\n        store.insert({0 , {0 , 0}});\\n        int ROW[] = {0 , 0 , 1 , -1};\\n        int COL[] = {1 , -1 , 0 , 0};\\n        while(!store.empty())\\n        {\\n            auto begin = *(store.begin());\\n            int posCost = begin.first;\\n            int i = begin.second.first;\\n            int j = begin.second.second;\\n            store.erase(begin);\\n            if(i == n-1 && j == m-1) return posCost;\\n            for(int x = 0 ; x < 4 ; x++)\\n            {\\n                int I = i + ROW[x];\\n                int J = j + COL[x];\\n                if(I < 0 || J < 0 || I >= n || J >= m || cost[I][J] < posCost + 1) continue;\\n                if(grid[i][j] == 1)\\n                {\\n                    cost[I][J] = posCost + 1;\\n                    store.insert({posCost+1 , {I , J}});   \\n                }\\n                else\\n                {\\n                    cost[I][J] = posCost;\\n                    store.insert({posCost , {I , J}});   \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n         int n = grid.size();\\n        int m = grid[0].size();\\n        vector<vector<int>> cost(n , vector<int> (m , INT_MAX));\\n        set<pair<int , pair<int , int>>> store;\\n        cost[0][0] = 0;\\n        store.insert({0 , {0 , 0}});\\n        int ROW[] = {0 , 0 , 1 , -1};\\n        int COL[] = {1 , -1 , 0 , 0};\\n        while(!store.empty())\\n        {\\n            auto begin = *(store.begin());\\n            int posCost = begin.first;\\n            int i = begin.second.first;\\n            int j = begin.second.second;\\n            store.erase(begin);\\n            if(i == n-1 && j == m-1) return posCost;\\n            for(int x = 0 ; x < 4 ; x++)\\n            {\\n                int I = i + ROW[x];\\n                int J = j + COL[x];\\n                if(I < 0 || J < 0 || I >= n || J >= m || cost[I][J] < posCost + 1) continue;\\n                if(grid[i][j] == 1)\\n                {\\n                    cost[I][J] = posCost + 1;\\n                    store.insert({posCost+1 , {I , J}});   \\n                }\\n                else\\n                {\\n                    cost[I][J] = posCost;\\n                    store.insert({posCost , {I , J}});   \\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979419,
                "title": "using-dijkstra-bfs-step-wise-commented-code",
                "content": "\\n# Approach\\nThe code uses a $priority$ $queue$ to perform a $modified$ $Dijkstra\\'s$ $algorithm$ to find the shortest path while keeping track of the number of obstacles encountered along the way. \\n\\nIt explores all possible directions from each cell and updates the priority queue with the new cell\\'s information. The algorithm terminates when the bottom-right corner is reached, and it returns the minimum number of obstacles encountered on that path.\\n\\n\\n\\n\\n\\n# Code\\n```\\n#define ppi pair<int, pair<int, int>>\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int dr[4] = {-1, 0, 1, 0}; // Direction arrays for moving up, right, down, left\\n        int dc[4] = {0, 1, 0, -1};\\n        int m = grid.size(); // Number of rows in the grid\\n        int n = grid[0].size(); // Number of columns in the grid\\n\\n        priority_queue<ppi, vector<ppi>, greater<ppi>> minh; // Priority queue to store path information\\n        vector<vector<int>> vis(m, vector<int>(n, 0)); // Matrix to keep track of visited cells\\n        \\n        // Push the starting cell (0, 0) into the priority queue\\n        if (grid[0][0] == 0)\\n            minh.push({0, {0, 0}});\\n        else\\n            minh.push({1, {0, 0}});\\n        vis[0][0] = 1; // Mark the starting cell as visited\\n        \\n        while (!minh.empty()) {\\n            auto it = minh.top(); // Get the current cell from the priority queue\\n            int r = it.second.first; // Row of the current cell\\n            int c = it.second.second; // Column of the current cell\\n            int count = it.first; // Number of obstacles encountered so far\\n            minh.pop(); // Remove the current cell from the priority queue\\n            \\n            // Explore all four possible directions\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + dr[i]; // New row after moving in direction i\\n                int nc = c + dc[i]; // New column after moving in direction i\\n                \\n                // Check if the new cell is within the grid boundaries and not visited yet\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !vis[nr][nc]) {\\n                    vis[nr][nc] = 1; // Mark the new cell as visited\\n                    \\n                    if (nr == m - 1 && nc == n - 1) // Check if the new cell is the destination\\n                        return count;\\n                    \\n                    // Push the new cell into the priority queue with updated obstacle count\\n                    if (grid[nr][nc] == 0)\\n                        minh.push({count, {nr, nc}});\\n                    else\\n                        minh.push({count + 1, {nr, nc}});\\n                }\\n            }\\n        }\\n        return 0; // If no path is found, return 0\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ppi pair<int, pair<int, int>>\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int dr[4] = {-1, 0, 1, 0}; // Direction arrays for moving up, right, down, left\\n        int dc[4] = {0, 1, 0, -1};\\n        int m = grid.size(); // Number of rows in the grid\\n        int n = grid[0].size(); // Number of columns in the grid\\n\\n        priority_queue<ppi, vector<ppi>, greater<ppi>> minh; // Priority queue to store path information\\n        vector<vector<int>> vis(m, vector<int>(n, 0)); // Matrix to keep track of visited cells\\n        \\n        // Push the starting cell (0, 0) into the priority queue\\n        if (grid[0][0] == 0)\\n            minh.push({0, {0, 0}});\\n        else\\n            minh.push({1, {0, 0}});\\n        vis[0][0] = 1; // Mark the starting cell as visited\\n        \\n        while (!minh.empty()) {\\n            auto it = minh.top(); // Get the current cell from the priority queue\\n            int r = it.second.first; // Row of the current cell\\n            int c = it.second.second; // Column of the current cell\\n            int count = it.first; // Number of obstacles encountered so far\\n            minh.pop(); // Remove the current cell from the priority queue\\n            \\n            // Explore all four possible directions\\n            for (int i = 0; i < 4; i++) {\\n                int nr = r + dr[i]; // New row after moving in direction i\\n                int nc = c + dc[i]; // New column after moving in direction i\\n                \\n                // Check if the new cell is within the grid boundaries and not visited yet\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !vis[nr][nc]) {\\n                    vis[nr][nc] = 1; // Mark the new cell as visited\\n                    \\n                    if (nr == m - 1 && nc == n - 1) // Check if the new cell is the destination\\n                        return count;\\n                    \\n                    // Push the new cell into the priority queue with updated obstacle count\\n                    if (grid[nr][nc] == 0)\\n                        minh.push({count, {nr, nc}});\\n                    else\\n                        minh.push({count + 1, {nr, nc}});\\n                }\\n            }\\n        }\\n        return 0; // If no path is found, return 0\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977719,
                "title": "don-t-think-just-start-applying-dijkstra-simple-thought",
                "content": "Don\\'t even think twice \\nApply Dijkstra in grid problem where all four direction movement is possible.\\nin first thought anyone will come up with some sort of recursive dfs solution with memoization but the thing here is to avoid revisiting the same cell again and again we need a visited array and here we f*** ek up bcz now u can\\'t actually memoize bcz u r changing state of visited array and that leads us to store visited array state as well that isn\\'t going to work and simple dfs with back track will give tle \\n\\nSo only way to solve this thing simply is to dijkstra algo with priority queue\\n\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& g) \\n    {\\n        using p=pair<int, pair<int,int>>;\\n        priority_queue<p,vector<p>, greater<p>>pq;\\n        int n; int m;\\n        n=g.size();\\n        m=g[0].size();\\n        vector<vector<int>> dis(n, vector<int>(m,1e5+1));\\n        vector<vector<int>> v(n, vector<int>(m,0));\\n\\n        if(g[0][0]==1) \\n        {\\n            dis[0][0]=1;\\n            pq.push({1,{0,0}});\\n        }\\n        else \\n        {\\n            pq.push({0,{0,0}});\\n            dis[0][0]=0;\\n        }\\n        int dx[4]={0,0,-1,1};\\n        int dy[4]={-1,1,0,0};\\n        int ans=INT_MAX;\\n        while(!pq.empty())\\n        {\\n            auto p= pq.top();\\n            pq.pop();\\n            int c=p.first;\\n            int x=p.second.first;\\n            int y=p.second.second;\\n            if(x==n-1 && y==m-1)\\n            {\\n                ans= c;\\n                break;\\n            }\\n            if(v[x][y]) continue;  // if already visited the ignore \\n            v[x][y]=1;\\n            for(int i=0; i<4; i++)\\n            {\\n                int l=x+dx[i];\\n                int r=y+dy[i];\\n                if(l>=0 && l<n && r>=0 && r<m)\\n                {\\n                    int t=c;\\n                    if(g[l][r]) t=c+1;// need to remove obstacle\\n                    \\n                    if(dis[l][r]>t && v[l][r]==0)\\n                    {\\n                        dis[l][r]=t;\\n                        pq.push({t,{l,r}});\\n                    }\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& g) \\n    {\\n        using p=pair<int, pair<int,int>>;\\n        priority_queue<p,vector<p>, greater<p>>pq;\\n        int n; int m;\\n        n=g.size();\\n        m=g[0].size();\\n        vector<vector<int>> dis(n, vector<int>(m,1e5+1));\\n        vector<vector<int>> v(n, vector<int>(m,0));\\n\\n        if(g[0][0]==1) \\n        {\\n            dis[0][0]=1;\\n            pq.push({1,{0,0}});\\n        }\\n        else \\n        {\\n            pq.push({0,{0,0}});\\n            dis[0][0]=0;\\n        }\\n        int dx[4]={0,0,-1,1};\\n        int dy[4]={-1,1,0,0};\\n        int ans=INT_MAX;\\n        while(!pq.empty())\\n        {\\n            auto p= pq.top();\\n            pq.pop();\\n            int c=p.first;\\n            int x=p.second.first;\\n            int y=p.second.second;\\n            if(x==n-1 && y==m-1)\\n            {\\n                ans= c;\\n                break;\\n            }\\n            if(v[x][y]) continue;  // if already visited the ignore \\n            v[x][y]=1;\\n            for(int i=0; i<4; i++)\\n            {\\n                int l=x+dx[i];\\n                int r=y+dy[i];\\n                if(l>=0 && l<n && r>=0 && r<m)\\n                {\\n                    int t=c;\\n                    if(g[l][r]) t=c+1;// need to remove obstacle\\n                    \\n                    if(dis[l][r]>t && v[l][r]==0)\\n                    {\\n                        dis[l][r]=t;\\n                        pq.push({t,{l,r}});\\n                    }\\n                }\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964565,
                "title": "easy-to-understand-dijkstra-algorithm-python",
                "content": "# Complexity\\n- Time complexity: O(m\\xD7nlog(m\\xD7n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m\\xD7n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom heapq import heappush, heappop\\nfrom typing import List\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n\\n        heap = [(grid[0][0], 0, 0)]\\n        visited = set((0, 0))\\n        \\n        while heap:\\n            obstacles, x, y = heappop(heap)\\n            \\n            if (x, y) == (m-1, n-1):\\n                return obstacles\\n            \\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                \\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\\n                    visited.add((nx, ny))\\n        \\n                    heappush(heap, (obstacles + grid[nx][ny], nx, ny))\\n\\n        return 0\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop\\nfrom typing import List\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        m, n = len(grid), len(grid[0])\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n\\n        heap = [(grid[0][0], 0, 0)]\\n        visited = set((0, 0))\\n        \\n        while heap:\\n            obstacles, x, y = heappop(heap)\\n            \\n            if (x, y) == (m-1, n-1):\\n                return obstacles\\n            \\n            for dx, dy in directions:\\n                nx, ny = x + dx, y + dy\\n                \\n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\\n                    visited.add((nx, ny))\\n        \\n                    heappush(heap, (obstacles + grid[nx][ny], nx, ny))\\n\\n        return 0\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948515,
                "title": "simple-striver-like-solution-short-and-easy-c-dijkstra-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust maintain a pq, the int d, is basically the count of how many obstacles remove as we only have 0/1 in grid, if we encounter a d(i.e count) smaller than what we have then we just update our dist matrix that stores counts basically.\\n\\nGo through the code, its pretty self explainatory !\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        pq.push({grid[0][0],0,0});\\n        dis[0][0]=grid[0][0];\\n        vis[0][0]=1;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,-1,0,1};\\n        while(!pq.empty()){\\n            int d=pq.top()[0];\\n            int r=pq.top()[1];\\n            int c=pq.top()[2];\\n            pq.pop();\\n            vis[r][c]=1;\\n            for(int k=0;k<4;k++){\\n                int nr=r+drow[k];\\n                int nc=c+dcol[k];\\n                if(nr<n and nc<m and nr>=0 and nc>=0 and !vis[nr][nc] and d+grid[nr][nc]<dis[nr][nc]){\\n                    dis[nr][nc]=d+grid[nr][nc];\\n                    pq.push({dis[nr][nc],nr,nc});\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>dis(n,vector<int>(m,INT_MAX));\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        pq.push({grid[0][0],0,0});\\n        dis[0][0]=grid[0][0];\\n        vis[0][0]=1;\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,-1,0,1};\\n        while(!pq.empty()){\\n            int d=pq.top()[0];\\n            int r=pq.top()[1];\\n            int c=pq.top()[2];\\n            pq.pop();\\n            vis[r][c]=1;\\n            for(int k=0;k<4;k++){\\n                int nr=r+drow[k];\\n                int nc=c+dcol[k];\\n                if(nr<n and nc<m and nr>=0 and nc>=0 and !vis[nr][nc] and d+grid[nr][nc]<dis[nr][nc]){\\n                    dis[nr][nc]=d+grid[nr][nc];\\n                    pq.push({dis[nr][nc],nr,nc});\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933602,
                "title": "bfs-dfs-combined-solution-python-thought-process",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe naive intution for this problem is to use bfs or dfs to find all the path then figure out the path with minimum blocks to break. However, this will run into TLE or MLE. The reason is we some path are unnecessary. For example, for grid[x][y] if there is a path already been there with 0 breaks, other path with breaks larger than this shall not being added to the queue. \\n\\nThus, instead of a normal visit set to store visited cell, we need another state to store the breaks, which results in (x,y,breaks). We can check if the current path has a break less than current break state, if it is, we could add it, else it would be wrose and we dont need to add it into queue.\\n\\nThis method is logical correct. However, this might still not pass the test since sometimes it takes too much steps before the best path to find the way, and before that, multiple worse path has been visited this cell. So, how do we make the best path to the fastest to get to the end? \\n\\nIt took me a day to figure out some priority is needed. Inspired by another brilliant solution, I realized that we could add to queue depends on its breaks. If we haven\\'t break block in this step, we could add it to the front, else we could add this to the end. By doing this, we could allow the \\'best\\' path always goes first and prevent \\'bad\\' ways goes first.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def valid(x,y):\\n            return 0<=x<m and 0<=y<n\\n        from collections import deque\\n        #define state: blk has removed\\n        q = deque()\\n        q.append((0,0,0))\\n        vmap=[[math.inf]*n for _ in range(m)]\\n        dirct=((1,0),(0,1),(-1,0),(0,-1))\\n        while len(q)>0:\\n            x,y,blk = q.popleft()\\n            for dx, dy in dirct:\\n                nx, ny = x+dx, y+dy\\n                if valid(nx,ny):\\n                    nblk = blk+grid[nx][ny]\\n                    if vmap[nx][ny]>nblk :\\n                        if nblk==blk:\\n                            vmap[nx][ny]=nblk\\n                            q.appendleft((nx,ny,nblk))\\n                        else:\\n                            vmap[nx][ny]=nblk\\n                            q.append((nx,ny,nblk))\\n        return vmap[m-1][n-1]\\n\\n  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        def valid(x,y):\\n            return 0<=x<m and 0<=y<n\\n        from collections import deque\\n        #define state: blk has removed\\n        q = deque()\\n        q.append((0,0,0))\\n        vmap=[[math.inf]*n for _ in range(m)]\\n        dirct=((1,0),(0,1),(-1,0),(0,-1))\\n        while len(q)>0:\\n            x,y,blk = q.popleft()\\n            for dx, dy in dirct:\\n                nx, ny = x+dx, y+dy\\n                if valid(nx,ny):\\n                    nblk = blk+grid[nx][ny]\\n                    if vmap[nx][ny]>nblk :\\n                        if nblk==blk:\\n                            vmap[nx][ny]=nblk\\n                            q.appendleft((nx,ny,nblk))\\n                        else:\\n                            vmap[nx][ny]=nblk\\n                            q.append((nx,ny,nblk))\\n        return vmap[m-1][n-1]\\n\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926393,
                "title": "trick-use-bfs-as-path-increasing-simultaneously-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntake the visited path explore all the path and then mask it as visited with the priority _queue data structure \\n\\n\\n**main trick if region grow simultaneously , think of haviG using of bfs**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nvis array mark for the assign \\npair<int,pair<int,int>>  for the dis, curX, curY;\\nmove all possible dirrections and then if reach at last derive the mini\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m)-vis matrix + size of priority_queue\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![upvote me please.png](https://assets.leetcode.com/users/images/e9583054-622d-4251-89ab-9dbaf6fa632d_1692354104.8582044.png)\\n\\n**UPVOTE TO GET THE HARD LEVEL SOLUTION**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int x_d[4]={-1,0,1,0};\\n    int mini=INT_MAX;\\n    int y_d[4]={0,1,0,-1};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n         q.push({0,{0,0}});\\n        vis[0][0]=1;\\n        \\n        while(!q.empty())\\n        {\\n             int sz=q.size();\\n            while(sz--)\\n            {\\n                int oldx=q.top().second.first;\\n                int oldy=q.top().second.second;\\n                int steps=q.top().first;\\n                q.pop();\\n                \\n                if(oldx==n-1 && oldy==m-1) {\\n                  mini=min(mini,steps);\\n                }\\n                \\n                for(int i=0;i<4;++i)\\n                {\\n                    int newx=oldx+x_d[i];\\n                    int newy=oldy+y_d[i];\\n                    if(newx>=0 && newx<n && newy>=0 && newy<m && !vis[newx][newy])\\n                    {\\n                        vis[newx][newy]=1;\\n                       if(grid[newx][newy]==1)\\n                       {\\n                           q.push({steps+1,{newx,newy}});\\n                           \\n                       }else\\n                       {\\n                           q.push({steps,{newx,newy}});\\n                               \\n                       }\\n                       \\n                    }        \\n                \\n\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int x_d[4]={-1,0,1,0};\\n    int mini=INT_MAX;\\n    int y_d[4]={0,1,0,-1};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> q;\\n         q.push({0,{0,0}});\\n        vis[0][0]=1;\\n        \\n        while(!q.empty())\\n        {\\n             int sz=q.size();\\n            while(sz--)\\n            {\\n                int oldx=q.top().second.first;\\n                int oldy=q.top().second.second;\\n                int steps=q.top().first;\\n                q.pop();\\n                \\n                if(oldx==n-1 && oldy==m-1) {\\n                  mini=min(mini,steps);\\n                }\\n                \\n                for(int i=0;i<4;++i)\\n                {\\n                    int newx=oldx+x_d[i];\\n                    int newy=oldy+y_d[i];\\n                    if(newx>=0 && newx<n && newy>=0 && newy<m && !vis[newx][newy])\\n                    {\\n                        vis[newx][newy]=1;\\n                       if(grid[newx][newy]==1)\\n                       {\\n                           q.push({steps+1,{newx,newy}});\\n                           \\n                       }else\\n                       {\\n                           q.push({steps,{newx,newy}});\\n                               \\n                       }\\n                       \\n                    }        \\n                \\n\\n                }\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876861,
                "title": "python-heap-use-is-it-really-hard-explained",
                "content": "# Approach\\nIf you can break down the problem into smaller ideas u will find its a simple djisktra problem where we need to find the best path with min no of obstacles(treat obstacles as the cost)\\nNow how we summing up the no of obstacles? \\n`0 -> empty cell`\\n`1 -> brick in cell`\\n\\nso keep a track of obstacles removed yet till we reach a specific cell by summing up the `current cell val + path val` and always update the cell if we can reach it in more efficient manner i.e less no of obstacles.\\n\\nFinally return the last Cell value as it is the min of number of cells required to remove upto this cell.\\n\\n**You can either use visited set (like in solution) or use the condition:-**\\n```\\nif obRemove[r][c] > obstacles + grid[r][c]:\\n    obRemove[r][c] = obstacles + grid[r][c]\\n    heapq.heappush(bag, (obRemove[r][c], r, c))\\n```\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        directions = [(1, 0), (0, 1), (0, -1), (-1, 0)]\\n        bag = []\\n        obRemove = [[inf]*COLS for _ in range(ROWS)]\\n        visited = set()\\n        obRemove[0][0] = grid[0][0]\\n        heapq.heappush(bag, (obRemove[0][0], 0, 0))\\n        visited.add((0, 0))\\n        while bag:\\n            obstacles, i, j = heapq.heappop(bag)\\n            for dr, dc in directions:\\n                r = i + dr\\n                c = j + dc\\n                if r in range(ROWS) and c in range(COLS) and (r, c) not in visited:\\n                    ob = obstacles + grid[r][c]\\n                    obRemove[r][c] = min(obRemove[r][c], ob)\\n                    visited.add((r, c))\\n                    heapq.heappush(bag, (obRemove[r][c], r, c))\\n        return obRemove[-1][-1]\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nif obRemove[r][c] > obstacles + grid[r][c]:\\n    obRemove[r][c] = obstacles + grid[r][c]\\n    heapq.heappush(bag, (obRemove[r][c], r, c))\\n```\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        directions = [(1, 0), (0, 1), (0, -1), (-1, 0)]\\n        bag = []\\n        obRemove = [[inf]*COLS for _ in range(ROWS)]\\n        visited = set()\\n        obRemove[0][0] = grid[0][0]\\n        heapq.heappush(bag, (obRemove[0][0], 0, 0))\\n        visited.add((0, 0))\\n        while bag:\\n            obstacles, i, j = heapq.heappop(bag)\\n            for dr, dc in directions:\\n                r = i + dr\\n                c = j + dc\\n                if r in range(ROWS) and c in range(COLS) and (r, c) not in visited:\\n                    ob = obstacles + grid[r][c]\\n                    obRemove[r][c] = min(obRemove[r][c], ob)\\n                    visited.add((r, c))\\n                    heapq.heappush(bag, (obRemove[r][c], r, c))\\n        return obRemove[-1][-1]\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854323,
                "title": "dijekstra-algorithm-solution-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        //dis[i][j] reprsent theminimum obstacles we have to remove to reach (i,j) from (0,0)\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vector<vector<int>>dis(n,vector<int>(m,1e9));\\n        dis[0][0] = grid[0][0];\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        while(pq.empty() == false){\\n            int distance = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            pq.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m){\\n                    if(dis[nrow][ncol] > (distance + (grid[nrow][ncol] == 1))){\\n                        dis[nrow][ncol] =distance + (grid[nrow][ncol] == 1);\\n                        pq.push({dis[nrow][ncol],{nrow,ncol}});\\n                    }\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];//dis[i][j] represent the minimum no of obstacles you have to remove \\n        //to reach to (i,j) from (0,0)\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        //dis[i][j] reprsent theminimum obstacles we have to remove to reach (i,j) from (0,0)\\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        pq.push({grid[0][0],{0,0}});\\n        vector<vector<int>>dis(n,vector<int>(m,1e9));\\n        dis[0][0] = grid[0][0];\\n        int delrow[] = {0,-1,0,+1};\\n        int delcol[] = {+1,0,-1,0};\\n        while(pq.empty() == false){\\n            int distance = pq.top().first;\\n            int row = pq.top().second.first;\\n            int col = pq.top().second.second;\\n            pq.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = row + delrow[i];\\n                int ncol = col + delcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<m){\\n                    if(dis[nrow][ncol] > (distance + (grid[nrow][ncol] == 1))){\\n                        dis[nrow][ncol] =distance + (grid[nrow][ncol] == 1);\\n                        pq.push({dis[nrow][ncol],{nrow,ncol}});\\n                    }\\n                }\\n            }\\n        }\\n        return dis[n-1][m-1];//dis[i][j] represent the minimum no of obstacles you have to remove \\n        //to reach to (i,j) from (0,0)\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795343,
                "title": "simple-c-solution",
                "content": "# Intuition\\nthis is a simple dijkastra related problem just find the minimum path sum from {0,0} to {n-1,m-1} \\n\\nif you cannot reach the last corner just return -1.\\nTip:try to reduce as much space as possible.Initially I used vector in priority queue it gave tle so i used pair<int,pair<int,int>> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n       priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>dq;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        dq.push({0,{0,0}});\\n       \\n        while(!dq.empty()){\\n            int i=dq.top().second.first,j=dq.top().second.second,d=dq.top().first;\\n            if(i==n-1&&j==m-1)return d;\\n            dq.pop();\\n           \\n            if(vis[i][j]==0){\\n                vis[i][j]=1;\\n              \\n                if(i+1<n&&vis[i+1][j]==0){\\n                  dq.push({d+grid[i+1][j],{i+1,j}});  \\n                }\\n                if(i-1>=0&&vis[i-1][j]==0){\\n                    dq.push({d+grid[i-1][j],{i-1,j}});\\n                }\\n                if(j+1<m&&vis[i][j+1]==0){\\n                   dq.push({d+grid[i][j+1],{i,j+1}}); \\n                }\\n                 if(j-1>=0&&vis[i][j-1]==0){\\n                    dq.push({d+grid[i][j-1],{i,j-1}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n       priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>dq;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        dq.push({0,{0,0}});\\n       \\n        while(!dq.empty()){\\n            int i=dq.top().second.first,j=dq.top().second.second,d=dq.top().first;\\n            if(i==n-1&&j==m-1)return d;\\n            dq.pop();\\n           \\n            if(vis[i][j]==0){\\n                vis[i][j]=1;\\n              \\n                if(i+1<n&&vis[i+1][j]==0){\\n                  dq.push({d+grid[i+1][j],{i+1,j}});  \\n                }\\n                if(i-1>=0&&vis[i-1][j]==0){\\n                    dq.push({d+grid[i-1][j],{i-1,j}});\\n                }\\n                if(j+1<m&&vis[i][j+1]==0){\\n                   dq.push({d+grid[i][j+1],{i,j+1}}); \\n                }\\n                 if(j-1>=0&&vis[i][j-1]==0){\\n                    dq.push({d+grid[i][j-1],{i,j-1}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766288,
                "title": "java-solutions-using-0-1-bfs-and-dijkstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        return dijkstra(grid);\\n    }\\n\\n    // implement using 0 - 1 BFS\\n    // BFS since we need to calculate MIN obstacles to remove\\n    // if we encounter a 1 i.e an obstacle put it at the back of the queue\\n    // we need to process 1 if we run out of cells with 0 and didn\\'t reach \\n    // the end (m - 1, n - 1)\\n    // run BFS by popping from the front i.e preference to zeros\\n    // when all zeros are exhausted we will encounter a 1 and if we \\n    // encounter a zero again we will switch to processing 0 \\n    // since we append the cell with zero in the front\\n    // and for each 1 encountered increment the count.\\n\\n    private int zeroOneBFS(int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int dirs[][] = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\n        boolean[][] visited = new boolean[m][n];\\n\\n        Deque<int[]> queue = new LinkedList<>();\\n\\n        \\n        queue.offer(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n\\n        while (!queue.isEmpty()){\\n            int[] curr = queue.removeFirst();\\n\\n            int r = curr[0], c = curr[1], k = curr[2];\\n\\n            if (r == m - 1 && c == n - 1)\\n                return k;\\n\\n            for (int[] d : dirs){\\n                int nr = r + d[0], nc = c + d[1];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc]){                    \\n                    visited[nr][nc] = true;\\n                    if (grid[nr][nc] == 0){\\n                        queue.addFirst(new int[]{nr, nc, k});\\n                    } else {\\n                        queue.addLast(new int[]{nr, nc, k + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    //using dijkstra\\n    // increment the cost ans use it is a priority value \\n    // when end is reched return the obstacles removed.\\n\\n    private int dijkstra(int[][] grid) {\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n\\n        int m = grid.length, n = grid[0].length;\\n\\n        boolean[][] visited = new boolean[m][n];\\n\\n        pq.offer(new int[]{0, 0, grid[0][0]});\\n\\n        visited[0][0] = true;\\n\\n        int dirs[][] = {{1,0}, {0,1}, {-1,0}, {0,-1}};\\n\\n        while (!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n\\n            int r = curr[0], c = curr[1], k = curr[2];\\n\\n            if (r == m - 1 && c == n - 1)\\n                return k;\\n\\n            for (int[] d : dirs){\\n                int nr = r + d[0], nc = c + d[1];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc]){                  visited[nr][nc] = true;\\n                    if (grid[nr][nc] == 0){\\n                        pq.offer(new int[]{nr, nc, k});\\n                    } else {\\n                        pq.offer(new int[]{nr, nc, k + 1});\\n                    }\\n                } \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        return dijkstra(grid);\\n    }\\n\\n    // implement using 0 - 1 BFS\\n    // BFS since we need to calculate MIN obstacles to remove\\n    // if we encounter a 1 i.e an obstacle put it at the back of the queue\\n    // we need to process 1 if we run out of cells with 0 and didn\\'t reach \\n    // the end (m - 1, n - 1)\\n    // run BFS by popping from the front i.e preference to zeros\\n    // when all zeros are exhausted we will encounter a 1 and if we \\n    // encounter a zero again we will switch to processing 0 \\n    // since we append the cell with zero in the front\\n    // and for each 1 encountered increment the count.\\n\\n    private int zeroOneBFS(int[][] grid){\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int dirs[][] = {{1,0},{0,1},{-1,0},{0,-1}};\\n\\n        boolean[][] visited = new boolean[m][n];\\n\\n        Deque<int[]> queue = new LinkedList<>();\\n\\n        \\n        queue.offer(new int[]{0, 0, grid[0][0]});\\n        visited[0][0] = true;\\n\\n        while (!queue.isEmpty()){\\n            int[] curr = queue.removeFirst();\\n\\n            int r = curr[0], c = curr[1], k = curr[2];\\n\\n            if (r == m - 1 && c == n - 1)\\n                return k;\\n\\n            for (int[] d : dirs){\\n                int nr = r + d[0], nc = c + d[1];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc]){                    \\n                    visited[nr][nc] = true;\\n                    if (grid[nr][nc] == 0){\\n                        queue.addFirst(new int[]{nr, nc, k});\\n                    } else {\\n                        queue.addLast(new int[]{nr, nc, k + 1});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    //using dijkstra\\n    // increment the cost ans use it is a priority value \\n    // when end is reched return the obstacles removed.\\n\\n    private int dijkstra(int[][] grid) {\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n\\n        int m = grid.length, n = grid[0].length;\\n\\n        boolean[][] visited = new boolean[m][n];\\n\\n        pq.offer(new int[]{0, 0, grid[0][0]});\\n\\n        visited[0][0] = true;\\n\\n        int dirs[][] = {{1,0}, {0,1}, {-1,0}, {0,-1}};\\n\\n        while (!pq.isEmpty()){\\n            int[] curr = pq.poll();\\n\\n            int r = curr[0], c = curr[1], k = curr[2];\\n\\n            if (r == m - 1 && c == n - 1)\\n                return k;\\n\\n            for (int[] d : dirs){\\n                int nr = r + d[0], nc = c + d[1];\\n                if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc]){                  visited[nr][nc] = true;\\n                    if (grid[nr][nc] == 0){\\n                        pq.offer(new int[]{nr, nc, k});\\n                    } else {\\n                        pq.offer(new int[]{nr, nc, k + 1});\\n                    }\\n                } \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765002,
                "title": "simple-java-solution-with-bfs",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int [][]distance = new int[m][n];\\n        int [][]directions = {{0, 1}, {0, -1}, {1, 0},{-1, 0}};\\n        for(int []arr : distance) Arrays.fill(arr, Integer.MAX_VALUE);\\n        Deque<triple> dq = new ArrayDeque<>();\\n        dq.add(new triple(0, 0, 0));\\n        distance[0][0] = 0;\\n        while(!dq.isEmpty()){\\n            triple curr = dq.remove();\\n            int x = curr.x;\\n            int y = curr.y;\\n            int obs = curr.obs;\\n            for(int []dir : directions){\\n                int xx = x + dir[0];\\n                int yy = y + dir[1];\\n                if(xx < 0 || xx >= m || yy < 0 || yy >= n){ continue;}\\n                if(grid[xx][yy] + obs < distance[xx][yy]){\\n                    distance[xx][yy] = grid[xx][yy] + obs;\\n                    if(grid[xx][yy] == 0) dq.addFirst(new triple(xx,yy,distance[xx][yy]));\\n                    else dq.addLast(new triple(xx,yy,distance[xx][yy]));\\n                }\\n            }\\n        }\\n        return distance[m-1][n-1];\\n    }\\n}\\nclass triple {\\n    int x, y, obs;\\n    triple(int x, int y, int obs){\\n        this.x = x;\\n        this.y = y;\\n        this.obs = obs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int [][]distance = new int[m][n];\\n        int [][]directions = {{0, 1}, {0, -1}, {1, 0},{-1, 0}};\\n        for(int []arr : distance) Arrays.fill(arr, Integer.MAX_VALUE);\\n        Deque<triple> dq = new ArrayDeque<>();\\n        dq.add(new triple(0, 0, 0));\\n        distance[0][0] = 0;\\n        while(!dq.isEmpty()){\\n            triple curr = dq.remove();\\n            int x = curr.x;\\n            int y = curr.y;\\n            int obs = curr.obs;\\n            for(int []dir : directions){\\n                int xx = x + dir[0];\\n                int yy = y + dir[1];\\n                if(xx < 0 || xx >= m || yy < 0 || yy >= n){ continue;}\\n                if(grid[xx][yy] + obs < distance[xx][yy]){\\n                    distance[xx][yy] = grid[xx][yy] + obs;\\n                    if(grid[xx][yy] == 0) dq.addFirst(new triple(xx,yy,distance[xx][yy]));\\n                    else dq.addLast(new triple(xx,yy,distance[xx][yy]));\\n                }\\n            }\\n        }\\n        return distance[m-1][n-1];\\n    }\\n}\\nclass triple {\\n    int x, y, obs;\\n    triple(int x, int y, int obs){\\n        this.x = x;\\n        this.y = y;\\n        this.obs = obs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764025,
                "title": "python3-minheap-solution-very-easy-and-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        R,C=len(grid),len(grid[0])\\n        minHeap=[]\\n        heappush(minHeap,[0,0,0])\\n        visited=[[0]*C for _ in range(R)]\\n        while minHeap:\\n            minObstacles,r,c=heappop(minHeap)\\n            if r==R-1 and c==C-1:\\n                return minObstacles\\n            for newR,newC in [[r+1,c],[r-1,c],[r,c+1],[r,c-1]]:\\n                if newR in range(R) and newC in range(C) and visited[newR][newC]==0:\\n                    if grid[newR][newC]:\\n                        heappush(minHeap,[minObstacles+1,newR,newC])\\n                    else:\\n                        heappush(minHeap,[minObstacles,newR,newC])\\n                    visited[newR][newC]=1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        R,C=len(grid),len(grid[0])\\n        minHeap=[]\\n        heappush(minHeap,[0,0,0])\\n        visited=[[0]*C for _ in range(R)]\\n        while minHeap:\\n            minObstacles,r,c=heappop(minHeap)\\n            if r==R-1 and c==C-1:\\n                return minObstacles\\n            for newR,newC in [[r+1,c],[r-1,c],[r,c+1],[r,c-1]]:\\n                if newR in range(R) and newC in range(C) and visited[newR][newC]==0:\\n                    if grid[newR][newC]:\\n                        heappush(minHeap,[minObstacles+1,newR,newC])\\n                    else:\\n                        heappush(minHeap,[minObstacles,newR,newC])\\n                    visited[newR][newC]=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763692,
                "title": "my-solution",
                "content": "**1. Use the `std::priority_queue`**\\n```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n public:\\n  int minimumObstacles(const vector<vector<int>> &grid) {\\n    using pq_node_t = tuple<int, int, int>;   // {the number of erased obtacles, the row, the column}\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    pq.emplace(0, 0, 0);\\n    while (!pq.empty()) {\\n      const auto [e, r, c] = pq.top();\\n      if (r == rows - 1 && c == cols - 1) {\\n        return e;\\n      }\\n      pq.pop();\\n      if (visited[r][c]) {\\n        continue;\\n      }\\n      visited[r][c] = true;\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {\\n          pq.emplace(e + grid[nr][nc], nr, nc);\\n        }\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```\\n**2. Use the `0-1 BFS`**\\n```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n public:\\n  int minimumObstacles(const vector<vector<int>> &grid) {\\n    using dq_node_t = tuple<int, int, int>;   // {the number of erased obtacles, the row, the column}\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    deque<dq_node_t> dq;\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    dq.emplace_back(0, 0, 0);\\n    while (!dq.empty()) {\\n      const auto [e, r, c] = dq.front();\\n      if (r == rows - 1 && c == cols - 1) {\\n        return e;\\n      }\\n      dq.pop_front();\\n      if (visited[r][c]) {\\n        continue;\\n      }\\n      visited[r][c] = true;\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {\\n          if (grid[nr][nc] == 0) {\\n            dq.emplace_front(e, nr, nc);\\n          } else {\\n            dq.emplace_back(e + 1, nr, nc);\\n          }\\n        }\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(rows * cols * log(rows * cols))\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n public:\\n  int minimumObstacles(const vector<vector<int>> &grid) {\\n    using pq_node_t = tuple<int, int, int>;   // {the number of erased obtacles, the row, the column}\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    pq.emplace(0, 0, 0);\\n    while (!pq.empty()) {\\n      const auto [e, r, c] = pq.top();\\n      if (r == rows - 1 && c == cols - 1) {\\n        return e;\\n      }\\n      pq.pop();\\n      if (visited[r][c]) {\\n        continue;\\n      }\\n      visited[r][c] = true;\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {\\n          pq.emplace(e + grid[nr][nc], nr, nc);\\n        }\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(rows * cols)\\n * Space Complexity: O(rows * cols)\\n * where `rows` is the number of the rows of the grid `grid`\\n *       `cols` is the number of the columns of the grid `grid`\\n */\\nclass Solution {\\n public:\\n  int minimumObstacles(const vector<vector<int>> &grid) {\\n    using dq_node_t = tuple<int, int, int>;   // {the number of erased obtacles, the row, the column}\\n    constexpr int directions[] = {0, 1, 0, -1, 0};\\n    constexpr int n_directions = 4;\\n    const int rows = static_cast<int>(grid.size());\\n    const int cols = static_cast<int>(grid.front().size());\\n    deque<dq_node_t> dq;\\n    bool visited[rows][cols];\\n    memset(visited, 0, sizeof(visited));\\n    dq.emplace_back(0, 0, 0);\\n    while (!dq.empty()) {\\n      const auto [e, r, c] = dq.front();\\n      if (r == rows - 1 && c == cols - 1) {\\n        return e;\\n      }\\n      dq.pop_front();\\n      if (visited[r][c]) {\\n        continue;\\n      }\\n      visited[r][c] = true;\\n      for (int d = 0; d < n_directions; ++d) {\\n        const int nr = r + directions[d];\\n        const int nc = c + directions[d + 1];\\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {\\n          if (grid[nr][nc] == 0) {\\n            dq.emplace_front(e, nr, nc);\\n          } else {\\n            dq.emplace_back(e + 1, nr, nc);\\n          }\\n        }\\n      }\\n    }\\n    throw \"impossible path\";\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702294,
                "title": "c-dijkstra-simple-observation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const int R[4]={-1,1,0,0};\\n    const int C[4]={0,0,-1,1};\\n    //wall=>cost=1\\n    // else cost=0; \\n    void dijkstra(int srcx,int srcy,vector<vector<int>>&grid,vector<vector<int>>&dist,int n,int m){\\n         dist[srcx][srcy]=(grid[srcx][srcy]==1);\\n         set<array<int,3>> toExplore;\\n         toExplore.insert({0,srcx,srcy});\\n         while(toExplore.size()){\\n             array<int,3> top=*toExplore.begin();\\n             int distancesofar=top[0];\\n             int x=top[1];\\n             int y=top[2];\\n             toExplore.erase(top);\\n             for(int dr=0;dr<4;dr++){\\n                 int newx=x+C[dr];\\n                 int newy=y+R[dr];\\n                 if(!(newx>=0 and newx<=n-1 and newy>=0 and newy<=m-1)){\\n                     continue;\\n                 }\\n                 int addeddist=(grid[newx][newy]==1);\\n                 int newdist=addeddist+dist[x][y];\\n                 if(dist[newx][newy]>newdist){\\n                     toExplore.erase({dist[newx][newy],newx,newy});\\n                     dist[newx][newy]=newdist;\\n                     toExplore.insert({dist[newx][newy],newx,newy});\\n                 }\\n             }\\n         }\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dijkstra(0,0,grid,dist,n,m);\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int R[4]={-1,1,0,0};\\n    const int C[4]={0,0,-1,1};\\n    //wall=>cost=1\\n    // else cost=0; \\n    void dijkstra(int srcx,int srcy,vector<vector<int>>&grid,vector<vector<int>>&dist,int n,int m){\\n         dist[srcx][srcy]=(grid[srcx][srcy]==1);\\n         set<array<int,3>> toExplore;\\n         toExplore.insert({0,srcx,srcy});\\n         while(toExplore.size()){\\n             array<int,3> top=*toExplore.begin();\\n             int distancesofar=top[0];\\n             int x=top[1];\\n             int y=top[2];\\n             toExplore.erase(top);\\n             for(int dr=0;dr<4;dr++){\\n                 int newx=x+C[dr];\\n                 int newy=y+R[dr];\\n                 if(!(newx>=0 and newx<=n-1 and newy>=0 and newy<=m-1)){\\n                     continue;\\n                 }\\n                 int addeddist=(grid[newx][newy]==1);\\n                 int newdist=addeddist+dist[x][y];\\n                 if(dist[newx][newy]>newdist){\\n                     toExplore.erase({dist[newx][newy],newx,newy});\\n                     dist[newx][newy]=newdist;\\n                     toExplore.insert({dist[newx][newy],newx,newy});\\n                 }\\n             }\\n         }\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dijkstra(0,0,grid,dist,n,m);\\n        return dist[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669169,
                "title": "faster-than-100-djikstra-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is a problem of finding the path with minimal weight from a point to another, therefore djikstra algorithm is perfectly fitted for this.\\nThe grid can be considered as a graph, where each cell is connected to its 4 neighbours with a weights that is either 0 if the neighbour cell is empty, and 1 if the neighbour cell contains an obstacle.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe djikstra algorithm works by considering each time the available unexplored edge with minimal weight. It is very similar to the BFS algorithm, but instead of using a simple queue, a heap is normally used to maintain ordering of weights.\\nBut in this case, we only have two weights for each edge : 0 (no obstacle) and 1. Using a heap structure for this is a huge overkill.\\n**Instead of using a heap to maintain the ordering of the edges to look at, we will use two queues** : \\n- A queue for edges with a weight of 0\\n- A queue for edges with a weight of 1\\n\\nWith this two queues, we only need to look at the leftmost edge (the one that was pushed the earlier) in the ZERO QUEUE if it isn\\'t empty, and if it is, we will look at the leftmost edge in the ONE QUEUE.\\n\\nThe algorithm ends when we reach the final cell.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumObstacles(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        explored = [[False]*len(grid[0]) for i in range(len(grid))]\\n        explored[0][0] = True\\n\\n        zero_queue = collections.deque()\\n        one_queue = collections.deque()\\n        zero_queue.append((0, 0, 0))\\n\\n        while zero_queue or one_queue:\\n            \\n            x, y, w = zero_queue.popleft() if zero_queue else one_queue.popleft()   \\n\\n            if x == len(grid)-1 and y == len(grid[0])-1:\\n                return w\\n\\n            if x > 0 and not explored[x-1][y]:\\n                explored[x-1][y] = True\\n                if grid[x-1][y]:\\n                    one_queue.append((x-1, y, w+1))\\n                else:\\n                    zero_queue.append((x-1, y, w))\\n            if x<len(grid)-1 and not explored[x+1][y]:\\n                explored[x+1][y] = True\\n                if grid[x+1][y]:\\n                    one_queue.append((x+1, y, w+1))\\n                else:\\n                    zero_queue.append((x+1, y, w))\\n            if y > 0 and not explored[x][y-1]:\\n                explored[x][y-1] = True\\n                if grid[x][y-1]:\\n                    one_queue.append((x, y-1, w+1))\\n                else:\\n                    zero_queue.append((x, y-1, w))\\n            if y<len(grid[0])-1 and not explored[x][y+1]:\\n                explored[x][y+1] = True\\n                if grid[x][y+1]:\\n                    one_queue.append((x, y+1, w+1))\\n                else:\\n                    zero_queue.append((x, y+1, w))\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumObstacles(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n\\n        explored = [[False]*len(grid[0]) for i in range(len(grid))]\\n        explored[0][0] = True\\n\\n        zero_queue = collections.deque()\\n        one_queue = collections.deque()\\n        zero_queue.append((0, 0, 0))\\n\\n        while zero_queue or one_queue:\\n            \\n            x, y, w = zero_queue.popleft() if zero_queue else one_queue.popleft()   \\n\\n            if x == len(grid)-1 and y == len(grid[0])-1:\\n                return w\\n\\n            if x > 0 and not explored[x-1][y]:\\n                explored[x-1][y] = True\\n                if grid[x-1][y]:\\n                    one_queue.append((x-1, y, w+1))\\n                else:\\n                    zero_queue.append((x-1, y, w))\\n            if x<len(grid)-1 and not explored[x+1][y]:\\n                explored[x+1][y] = True\\n                if grid[x+1][y]:\\n                    one_queue.append((x+1, y, w+1))\\n                else:\\n                    zero_queue.append((x+1, y, w))\\n            if y > 0 and not explored[x][y-1]:\\n                explored[x][y-1] = True\\n                if grid[x][y-1]:\\n                    one_queue.append((x, y-1, w+1))\\n                else:\\n                    zero_queue.append((x, y-1, w))\\n            if y<len(grid[0])-1 and not explored[x][y+1]:\\n                explored[x][y+1] = True\\n                if grid[x][y+1]:\\n                    one_queue.append((x, y+1, w+1))\\n                else:\\n                    zero_queue.append((x, y+1, w))\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632746,
                "title": "bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n   int minimumObstacles(vector<vector<int>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n\\n    int rr[] = {-1, 0, 1, 0};\\n    int cc[] = {0, 1, 0, -1};\\n\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    vector<vector<int>> distance(n, vector<int>(m, 1e9));\\n    distance[0][0] = 1;\\n\\n    deque<pair<int, int>> q;\\n    q.push_back({0, 0});\\n\\n    while (!q.empty())\\n    {\\n        int row = q.front().first;\\n        int col = q.front().second;\\n        q.pop_front();\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            int r = row + rr[i];\\n            int c = col + cc[i];\\n\\n            if (r < n and r >= 0 and c < m and c >= 0 and !visited[r][c])\\n            {\\n                visited[r][c] = 1;\\n                if (grid[r][c] == 1)\\n                {\\n                    q.push_back({r, c});\\n                    distance[r][c] = 1 + distance[row][col];\\n                }\\n                else\\n                {\\n                    q.push_front({r, c});\\n                    distance[r][c] = distance[row][col];\\n                }\\n            }\\n        }\\n    }\\n\\n    return distance[n - 1][m - 1] - 1;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minimumObstacles(vector<vector<int>> &grid)\\n{\\n    int n = grid.size();\\n    int m = grid[0].size();\\n\\n    int rr[] = {-1, 0, 1, 0};\\n    int cc[] = {0, 1, 0, -1};\\n\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    vector<vector<int>> distance(n, vector<int>(m, 1e9));\\n    distance[0][0] = 1;\\n\\n    deque<pair<int, int>> q;\\n    q.push_back({0, 0});\\n\\n    while (!q.empty())\\n    {\\n        int row = q.front().first;\\n        int col = q.front().second;\\n        q.pop_front();\\n\\n        for (int i = 0; i < 4; i++)\\n        {\\n            int r = row + rr[i];\\n            int c = col + cc[i];\\n\\n            if (r < n and r >= 0 and c < m and c >= 0 and !visited[r][c])\\n            {\\n                visited[r][c] = 1;\\n                if (grid[r][c] == 1)\\n                {\\n                    q.push_back({r, c});\\n                    distance[r][c] = 1 + distance[row][col];\\n                }\\n                else\\n                {\\n                    q.push_front({r, c});\\n                    distance[r][c] = distance[row][col];\\n                }\\n            }\\n        }\\n    }\\n\\n    return distance[n - 1][m - 1] - 1;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3618313,
                "title": "java-0-1-bfs-deque",
                "content": "```\\nclass Solution {\\n    int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\\n    public int minimumObstacles(int[][] grid) {\\n        \\n        int endX = grid.length - 1;\\n        int endY = grid[0].length - 1;\\n        \\n        //0-1 BFS traversal(dequeue rather than priority queue)\\n        int[][] dist = new int[endX + 1][endY + 1];\\n        \\n        for(int[] arr : dist){\\n            Arrays.fill(arr,Integer.MAX_VALUE);\\n        }\\n        \\n        Deque<Pair> dq = new ArrayDeque<Pair>();\\n        \\n        dq.addFirst(new Pair(0,0,0));\\n        dist[0][0] = 0;\\n        \\n        while(!dq.isEmpty()){\\n            \\n            Pair last = dq.removeFirst();\\n            \\n            int x = last.x;\\n            int y = last.y;\\n            int obs = last.obs;\\n            \\n            for(int[] dir : directions){\\n                \\n                int xx = x + dir[0];\\n                int yy = y + dir[1];\\n                \\n                if(xx < 0 || yy < 0 || xx > endX || yy > endY){\\n                    continue;\\n                }\\n                \\n                if(dist[xx][yy] > grid[xx][yy] + obs){\\n                    \\n                    dist[xx][yy] = grid[xx][yy] + obs;\\n                        \\n                    if(grid[xx][yy] == 0){\\n                        //add first\\n                        dq.addFirst(new Pair(xx,yy,dist[xx][yy]));\\n                        \\n                    }else if(grid[xx][yy] == 1){\\n                        //add last\\n                         dq.addLast(new Pair(xx,yy,dist[xx][yy]));\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return dist[endX][endY];\\n    }\\n}\\n\\nclass Pair{\\n    int x;\\n    int y;\\n    int obs;\\n    \\n    public Pair(int x , int y, int obs){\\n        this.x = x;\\n        this.y = y;\\n        this.obs = obs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\\n    public int minimumObstacles(int[][] grid) {\\n        \\n        int endX = grid.length - 1;\\n        int endY = grid[0].length - 1;\\n        \\n        //0-1 BFS traversal(dequeue rather than priority queue)\\n        int[][] dist = new int[endX + 1][endY + 1];\\n        \\n        for(int[] arr : dist){\\n            Arrays.fill(arr,Integer.MAX_VALUE);\\n        }\\n        \\n        Deque<Pair> dq = new ArrayDeque<Pair>();\\n        \\n        dq.addFirst(new Pair(0,0,0));\\n        dist[0][0] = 0;\\n        \\n        while(!dq.isEmpty()){\\n            \\n            Pair last = dq.removeFirst();\\n            \\n            int x = last.x;\\n            int y = last.y;\\n            int obs = last.obs;\\n            \\n            for(int[] dir : directions){\\n                \\n                int xx = x + dir[0];\\n                int yy = y + dir[1];\\n                \\n                if(xx < 0 || yy < 0 || xx > endX || yy > endY){\\n                    continue;\\n                }\\n                \\n                if(dist[xx][yy] > grid[xx][yy] + obs){\\n                    \\n                    dist[xx][yy] = grid[xx][yy] + obs;\\n                        \\n                    if(grid[xx][yy] == 0){\\n                        //add first\\n                        dq.addFirst(new Pair(xx,yy,dist[xx][yy]));\\n                        \\n                    }else if(grid[xx][yy] == 1){\\n                        //add last\\n                         dq.addLast(new Pair(xx,yy,dist[xx][yy]));\\n                    }\\n                    \\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n        return dist[endX][endY];\\n    }\\n}\\n\\nclass Pair{\\n    int x;\\n    int y;\\n    int obs;\\n    \\n    public Pair(int x , int y, int obs){\\n        this.x = x;\\n        this.y = y;\\n        this.obs = obs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579908,
                "title": "0-1-bfs-c-readable-variable-names",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    //check for valid index\\n    bool isValid(int r, int c, const vector<vector<int>>& grid)\\n    {\\n        return r >= 0 && c >= 0 \\n            && r < grid.size() && c < grid.front().size();\\n    }\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        if(grid.empty())\\n            return 0;\\n        \\n        int nRows = grid.size();\\n        int nCols = grid.front().size();\\n        \\n        deque<pair<int,int>> dque;\\n        //initialize all costs to INT_MAX\\n        vector<vector<int>> min_cost(nRows, vector<int>(nCols, INT_MAX));\\n        \\n        //set the starting position cost to zero\\n        min_cost[0][0] = 0;\\n        dque.push_front({0,0});\\n        \\n        while(!dque.empty())\\n        {\\n            int curr_r = dque.front().first;\\n            int curr_c = dque.front().second;\\n            int curr_cost = min_cost[curr_r][curr_c];\\n            dque.pop_front();\\n            \\n            //found target\\n            if(curr_r== nRows-1 && curr_c == nCols-1)\\n                return min_cost[curr_r][curr_c];\\n            \\n            \\n            array<array<int,2>,4> directions{{{0,1}, {1,0}, {0,-1},{-1,0}}};\\n            \\n            for(auto d : directions)\\n            {\\n                int r = curr_r + d[0];\\n                int c = curr_c + d[1];\\n                \\n                //if invalid cells or if cell already visited\\n                if(!isValid(r,c,grid) || grid[r][c] == 2)\\n                    continue;\\n                \\n            \\n                // if this neigboring cell is not an obstacle,then its cost\\n                // is the same as the current cell\\n                int neighbor_local_cost = grid[r][c] == 0? curr_cost : curr_cost + 1;\\n                min_cost[r][c] = neighbor_local_cost;\\n                \\n                //mark as visited\\n                grid[r][c] = 2;\\n                \\n        \\n                if(neighbor_local_cost == curr_cost)\\n                    dque.push_front({r,c});\\n                else\\n                    dque.push_back({r,c}); \\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    //check for valid index\\n    bool isValid(int r, int c, const vector<vector<int>>& grid)\\n    {\\n        return r >= 0 && c >= 0 \\n            && r < grid.size() && c < grid.front().size();\\n    }\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) \\n    {\\n        if(grid.empty())\\n            return 0;\\n        \\n        int nRows = grid.size();\\n        int nCols = grid.front().size();\\n        \\n        deque<pair<int,int>> dque;\\n        //initialize all costs to INT_MAX\\n        vector<vector<int>> min_cost(nRows, vector<int>(nCols, INT_MAX));\\n        \\n        //set the starting position cost to zero\\n        min_cost[0][0] = 0;\\n        dque.push_front({0,0});\\n        \\n        while(!dque.empty())\\n        {\\n            int curr_r = dque.front().first;\\n            int curr_c = dque.front().second;\\n            int curr_cost = min_cost[curr_r][curr_c];\\n            dque.pop_front();\\n            \\n            //found target\\n            if(curr_r== nRows-1 && curr_c == nCols-1)\\n                return min_cost[curr_r][curr_c];\\n            \\n            \\n            array<array<int,2>,4> directions{{{0,1}, {1,0}, {0,-1},{-1,0}}};\\n            \\n            for(auto d : directions)\\n            {\\n                int r = curr_r + d[0];\\n                int c = curr_c + d[1];\\n                \\n                //if invalid cells or if cell already visited\\n                if(!isValid(r,c,grid) || grid[r][c] == 2)\\n                    continue;\\n                \\n            \\n                // if this neigboring cell is not an obstacle,then its cost\\n                // is the same as the current cell\\n                int neighbor_local_cost = grid[r][c] == 0? curr_cost : curr_cost + 1;\\n                min_cost[r][c] = neighbor_local_cost;\\n                \\n                //mark as visited\\n                grid[r][c] = 2;\\n                \\n        \\n                if(neighbor_local_cost == curr_cost)\\n                    dque.push_front({r,c});\\n                else\\n                    dque.push_back({r,c}); \\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565304,
                "title": "minheap-bfs-easy-to-understand",
                "content": "# Intuition\\nusing priority queue in Breadth first search to find the path with least number of obstacles removed path.\\n\\n# Approach\\ninitialized  min heap with initial number of obstacles as 0,coordinates and present cell values.\\nBy iterating the que till end we will pop the values based on minimum number os obstacles path . \\nby Repeatedly popping and applying bfs to that respective cell at a particular point of time we will reach the Last coordinate , then we will return our number of obstacles removed count.\\n\\n# Complexity\\n- Time complexity:\\n O(M*N) where M=len(grid) and N= len(grid[0])\\n\\n- Space complexity:\\n O(N) used for Que  and Visit set.\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        direc=[(1,0),(0,1),(-1,0),(0,-1)]\\n\\n        que=[[grid[0][0],grid[0][0],0,0]]\\n        \\n        visit=set()\\n        z=[]\\n        while que:\\n\\n\\n            for i in range(len(que)):\\n                obs,val,i,j=heapq.heappop(que)\\n    \\n                if i==len(grid)-1 and j==len(grid[0])-1:\\n                    return obs\\n\\n                if (i,j) in visit:\\n                    continue\\n\\n                visit.add((i,j))\\n\\n                \\n\\n                for r,c in direc:\\n                    row=r+i\\n                    col=c+j\\n\\n                    if row>=0 and col >=0 and row<len(grid) and col<len(grid[0]):\\n\\n                        heapq.heappush(que,(obs+grid[row][col],grid[row][col],row,col))\\n       \\n                    \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)",
                    "Iterator"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        direc=[(1,0),(0,1),(-1,0),(0,-1)]\\n\\n        que=[[grid[0][0],grid[0][0],0,0]]\\n        \\n        visit=set()\\n        z=[]\\n        while que:\\n\\n\\n            for i in range(len(que)):\\n                obs,val,i,j=heapq.heappop(que)\\n    \\n                if i==len(grid)-1 and j==len(grid[0])-1:\\n                    return obs\\n\\n                if (i,j) in visit:\\n                    continue\\n\\n                visit.add((i,j))\\n\\n                \\n\\n                for r,c in direc:\\n                    row=r+i\\n                    col=c+j\\n\\n                    if row>=0 and col >=0 and row<len(grid) and col<len(grid[0]):\\n\\n                        heapq.heappush(que,(obs+grid[row][col],grid[row][col],row,col))\\n       \\n                    \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552657,
                "title": "simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        M = len(grid)\\n        N = len(grid[0])\\n\\n        def dfs(row, col): # search through obstacle free path\\n            if (row, col) == (M-1, N-1):\\n                return True\\n            for d in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\\n                nrow, ncol = row + d[0], col + d[1]\\n                if (0 <= nrow < M) and (0 <= ncol < N) and ((nrow, ncol) not in visited):\\n                    if grid[nrow][ncol]:\\n                        obstacles.append((nrow, ncol))\\n                        visited.add((nrow, ncol))\\n                    else:\\n                        visited.add((nrow, ncol))\\n                        if dfs(nrow, ncol):\\n                            return True\\n            return False\\n        current = [(0, 0)]\\n        visited = set(current)\\n        for num_obstacles in count():\\n            obstacles = []\\n            for row, col in current:\\n                if dfs(row, col):\\n                    return num_obstacles\\n            current = obstacles\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        M = len(grid)\\n        N = len(grid[0])\\n\\n        def dfs(row, col): # search through obstacle free path\\n            if (row, col) == (M-1, N-1):\\n                return True\\n            for d in [(-1, 0), (0, 1), (1, 0), (0, -1)]:\\n                nrow, ncol = row + d[0], col + d[1]\\n                if (0 <= nrow < M) and (0 <= ncol < N) and ((nrow, ncol) not in visited):\\n                    if grid[nrow][ncol]:\\n                        obstacles.append((nrow, ncol))\\n                        visited.add((nrow, ncol))\\n                    else:\\n                        visited.add((nrow, ncol))\\n                        if dfs(nrow, ncol):\\n                            return True\\n            return False\\n        current = [(0, 0)]\\n        visited = set(current)\\n        for num_obstacles in count():\\n            obstacles = []\\n            for row, col in current:\\n                if dfs(row, col):\\n                    return num_obstacles\\n            current = obstacles\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551415,
                "title": "simple-c-solution-with-clear-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nque looks like shortest path type. que can be solved using dijkstra with small variation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. here we will have a 2-D arr and v[r][c] -> no of obstacle removed to reach the {r,c}.in original dijkstra v[r][c] ->  shortest distance to reach {r,c}. (we can use dijkstra algo). \\n2. in priority_queue we will store {v[r][c],{r,c}}.\\nremember in original dijkstra we store the {distnace,node} but in matrix node is nothing but {r,c}.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m*log(n*m))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n         priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        vector <vector<int>> v(n,vector<int>(m,1e9));\\n        \\n        v[0][0]=grid[0][0];\\n        //in simple dijkstra we store{dist,node} -> in matrix node is given by {r,c} \\n        pq.push({v[0][0],{0,0}}); // {dist,{r,c}}\\n        int delrow[4] = {-1,0,1,0};\\n        int delcol[4] = {0,1,0,-1};\\n\\n        while(!pq.empty()){\\n            int dist = pq.top().first;\\n            int r = pq.top().second.first;\\n            int c = pq.top().second.second;\\n            pq.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = r+delrow[i];\\n                int ncol = c+delcol[i];\\n\\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0){\\n                    if(dist+grid[nrow][ncol] < v[nrow][ncol]){\\n                        v[nrow][ncol] = dist+grid[nrow][ncol];\\n                        pq.push({v[nrow][ncol],{nrow,ncol}});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return v[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n         priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n\\n        vector <vector<int>> v(n,vector<int>(m,1e9));\\n        \\n        v[0][0]=grid[0][0];\\n        //in simple dijkstra we store{dist,node} -> in matrix node is given by {r,c} \\n        pq.push({v[0][0],{0,0}}); // {dist,{r,c}}\\n        int delrow[4] = {-1,0,1,0};\\n        int delcol[4] = {0,1,0,-1};\\n\\n        while(!pq.empty()){\\n            int dist = pq.top().first;\\n            int r = pq.top().second.first;\\n            int c = pq.top().second.second;\\n            pq.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nrow = r+delrow[i];\\n                int ncol = c+delcol[i];\\n\\n                if(nrow<n && nrow>=0 && ncol<m && ncol>=0){\\n                    if(dist+grid[nrow][ncol] < v[nrow][ncol]){\\n                        v[nrow][ncol] = dist+grid[nrow][ncol];\\n                        pq.push({v[nrow][ncol],{nrow,ncol}});\\n                    }\\n                }\\n            }\\n        }\\n\\n        return v[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525763,
                "title": "easy-bfs-runtime-178-ms-beats-72-73",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] arr) {\\n        \\n        int n = arr.length, m = arr[0].length;\\n\\n        Queue< int[] > queue = new LinkedList<>();\\n\\n        queue.add(new int[]{0,0});\\n\\n        int[][] cnt = new int[n][m];\\n\\n        for(int[] a : cnt) Arrays.fill(a,1000000);\\n\\n        cnt[0][0] = 0;\\n\\n        while(!queue.isEmpty()){\\n\\n            int[] cur = queue.remove();\\n\\n            int i = cur[0], j = cur[1];\\n            int add = 0;\\n            if(arr[i][j] == 1) add++;\\n\\n            if(i + 1 < n && cnt[i + 1][j] > cnt[i][j] + add){\\n                cnt[i + 1][j] = cnt[i][j] + add;\\n                queue.add(new int[]{i + 1, j});\\n            }\\n            if(j + 1 < m && cnt[i][j + 1] > cnt[i][j] + add){\\n                cnt[i][j + 1] = cnt[i][j] + add;\\n                queue.add(new int[]{i,j + 1});\\n            }\\n            if(i - 1 >= 0 && cnt[i - 1][j] > cnt[i][j] + add){\\n                cnt[i - 1][j] = cnt[i][j] + add;\\n                queue.add(new int[]{i - 1, j});\\n            }\\n            if(j - 1>= 0 && cnt[i][j - 1] > cnt[i][j] + add){\\n                cnt[i][j - 1] = cnt[i][j] + add;\\n                queue.add(new int[]{i, j - 1});\\n            }\\n        }\\n\\n        return cnt[n - 1][m -1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] arr) {\\n        \\n        int n = arr.length, m = arr[0].length;\\n\\n        Queue< int[] > queue = new LinkedList<>();\\n\\n        queue.add(new int[]{0,0});\\n\\n        int[][] cnt = new int[n][m];\\n\\n        for(int[] a : cnt) Arrays.fill(a,1000000);\\n\\n        cnt[0][0] = 0;\\n\\n        while(!queue.isEmpty()){\\n\\n            int[] cur = queue.remove();\\n\\n            int i = cur[0], j = cur[1];\\n            int add = 0;\\n            if(arr[i][j] == 1) add++;\\n\\n            if(i + 1 < n && cnt[i + 1][j] > cnt[i][j] + add){\\n                cnt[i + 1][j] = cnt[i][j] + add;\\n                queue.add(new int[]{i + 1, j});\\n            }\\n            if(j + 1 < m && cnt[i][j + 1] > cnt[i][j] + add){\\n                cnt[i][j + 1] = cnt[i][j] + add;\\n                queue.add(new int[]{i,j + 1});\\n            }\\n            if(i - 1 >= 0 && cnt[i - 1][j] > cnt[i][j] + add){\\n                cnt[i - 1][j] = cnt[i][j] + add;\\n                queue.add(new int[]{i - 1, j});\\n            }\\n            if(j - 1>= 0 && cnt[i][j - 1] > cnt[i][j] + add){\\n                cnt[i][j - 1] = cnt[i][j] + add;\\n                queue.add(new int[]{i, j - 1});\\n            }\\n        }\\n\\n        return cnt[n - 1][m -1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508793,
                "title": "bfs-pq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is esay to use template. It makes me think a hard problem as tag, actually should be easier than most of the medium problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- while bfs, need to add the number of blocks, if there is, add 1\\n- if no block, just add 0 into the pq\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        steps = 1 if grid[0][0] else 0\\n        pq = [(steps, 0, 0)]\\n        visited = set([(0, 0)])\\n        while pq:\\n            n, x, y = heappop(pq)\\n            if x == ROWS - 1 and y == COLS - 1:\\n                return n\\n            for dr, dc in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                r, c = x + dr, y + dc\\n                if 0 <= r < ROWS and 0 <= c < COLS and (r, c) not in visited:\\n                    visited.add((r, c))\\n                    if grid[r][c]:\\n                        heappush(pq, (n + 1, r, c))\\n                    else:\\n                        heappush(pq, (n, r, c))\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        steps = 1 if grid[0][0] else 0\\n        pq = [(steps, 0, 0)]\\n        visited = set([(0, 0)])\\n        while pq:\\n            n, x, y = heappop(pq)\\n            if x == ROWS - 1 and y == COLS - 1:\\n                return n\\n            for dr, dc in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\\n                r, c = x + dr, y + dc\\n                if 0 <= r < ROWS and 0 <= c < COLS and (r, c) not in visited:\\n                    visited.add((r, c))\\n                    if grid[r][c]:\\n                        heappush(pq, (n + 1, r, c))\\n                    else:\\n                        heappush(pq, (n, r, c))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489271,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>d={{1,0},{-1,0},{0,1},{0,-1}};\\n    int m,n;\\n    int minimumObstacles(vector<vector<int>>& arr) {\\n        m=arr.size();\\n        n=arr[0].size();\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        priority_queue<pair<int,vector<int>>,vector<pair<int,vector<int>>>,\\n        greater<pair<int,vector<int>>>>pq;\\n        dist[0][0]=0;\\n        pq.push({0,{0,0}});\\n        while(!pq.empty())\\n        {\\n            int dis=pq.top().first;\\n            int cr=pq.top().second[0];\\n            int cc=pq.top().second[1];\\n            pq.pop();\\n            if(dist[cr][cc]<dis)\\n            {\\n                continue;\\n            }\\n            for(int i=0;i<d.size();i++)\\n            {\\n                int row=cr+d[i][0];\\n                int col=cc+d[i][1];\\n                if(isvalid(row,col) and dis+arr[row][col]<dist[row][col])\\n                {\\n                    dist[row][col]=dis+arr[row][col];\\n                    pq.push({dist[row][col],{row,col}});\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];\\n    }\\n    bool isvalid(int &row,int &col)\\n    {\\n        if(row<0 or col<0 or row>=m or col>=n)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>d={{1,0},{-1,0},{0,1},{0,-1}};\\n    int m,n;\\n    int minimumObstacles(vector<vector<int>>& arr) {\\n        m=arr.size();\\n        n=arr[0].size();\\n        vector<vector<int>>dist(m,vector<int>(n,INT_MAX));\\n        priority_queue<pair<int,vector<int>>,vector<pair<int,vector<int>>>,\\n        greater<pair<int,vector<int>>>>pq;\\n        dist[0][0]=0;\\n        pq.push({0,{0,0}});\\n        while(!pq.empty())\\n        {\\n            int dis=pq.top().first;\\n            int cr=pq.top().second[0];\\n            int cc=pq.top().second[1];\\n            pq.pop();\\n            if(dist[cr][cc]<dis)\\n            {\\n                continue;\\n            }\\n            for(int i=0;i<d.size();i++)\\n            {\\n                int row=cr+d[i][0];\\n                int col=cc+d[i][1];\\n                if(isvalid(row,col) and dis+arr[row][col]<dist[row][col])\\n                {\\n                    dist[row][col]=dis+arr[row][col];\\n                    pq.push({dist[row][col],{row,col}});\\n                }\\n            }\\n        }\\n        return dist[m-1][n-1];\\n    }\\n    bool isvalid(int &row,int &col)\\n    {\\n        if(row<0 or col<0 or row>=m or col>=n)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417154,
                "title": "dijkstra-s-algo-on-grid",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nshortest path from 0 to n-1 in 0/1 weighted graph\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n       \\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int dr[] = {1,0,-1,0};\\n        int dc[] = {0,1,0,-1};\\n\\n        set<pair<int,pair<int,int>>> st;\\n        st.insert({0,{0,0}});\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        dist[0][0] = 0;\\n        while(!st.empty()){\\n            auto it = *(st.begin());\\n            int wt = it.first;\\n            int x = it.second.first;\\n            int y = it.second.second;\\n            st.erase(it);\\n\\n            for(int k = 0; k < 4; k++){\\n                int nr = x+dr[k];\\n                int nc = y+dc[k];\\n                if(nr >= 0 and nr < n and nc >= 0 and nc < m){\\n                    int adjwt = grid[nr][nc];\\n                    if(adjwt+wt < dist[nr][nc]){\\n                        dist[nr][nc] = adjwt+wt;\\n                        st.insert({dist[nr][nc],{nr,nc}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n       \\n\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int dr[] = {1,0,-1,0};\\n        int dc[] = {0,1,0,-1};\\n\\n        set<pair<int,pair<int,int>>> st;\\n        st.insert({0,{0,0}});\\n        vector<vector<int>> dist(n,vector<int>(m,INT_MAX));\\n        dist[0][0] = 0;\\n        while(!st.empty()){\\n            auto it = *(st.begin());\\n            int wt = it.first;\\n            int x = it.second.first;\\n            int y = it.second.second;\\n            st.erase(it);\\n\\n            for(int k = 0; k < 4; k++){\\n                int nr = x+dr[k];\\n                int nc = y+dc[k];\\n                if(nr >= 0 and nr < n and nc >= 0 and nc < m){\\n                    int adjwt = grid[nr][nc];\\n                    if(adjwt+wt < dist[nr][nc]){\\n                        dist[nr][nc] = adjwt+wt;\\n                        st.insert({dist[nr][nc],{nr,nc}});\\n                    }\\n                }\\n            }\\n        }\\n        return dist[n-1][m-1];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402238,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ; //{x, y}\\nclass Solution {\\n    int m, n ;\\n    int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}} ;\\n    vector<vector<int>> gothrough(vector<vector<int>>&grid, vector<vector<bool>>&visited, int x0, int y0){\\n        queue<PII>q ;\\n        q.push({x0, y0}) ;\\n        vector<vector<int>>ret ;\\n        while(!q.empty()){\\n            int sz = q.size() ;\\n            for(int len = 0; len < sz; len++)\\n            {\\n                auto [x, y] = q.front() ;\\n                q.pop() ;\\n                for(int k = 0; k < 4; k++){\\n                    int xx = x + dirs[k][0] ;\\n                    int yy = y + dirs[k][1] ;\\n                    if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                        continue ;\\n                    if(visited[xx][yy])\\n                        continue ;\\n                    visited[xx][yy] = true ;\\n                    if(grid[xx][yy] == 1)\\n                        ret.push_back({xx,yy}) ;\\n                    else{\\n                        if(xx == m-1 && yy == n-1){\\n                            ret.push_back({xx, yy}) ;\\n                            return ret ;\\n                        }\\n                        q.push({xx,yy}) ;    \\n                    }\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        m = grid.size() ;\\n        n = grid[0].size() ;\\n        vector<vector<bool>>visited(m, vector<bool>(n)) ;\\n        queue<PII>q ;\\n        q.push({0,0}) ;\\n        visited[0][0] = true ;\\n        int step = 0 ;\\n        while(!q.empty())\\n        {\\n            int sz = q.size() ;\\n            for(int len = 0; len < sz; len++)\\n            {\\n                auto [x,y] = q.front() ;\\n                q.pop() ;\\n                for(int k = 0; k < 4; k++){\\n                    int xx = x + dirs[k][0] ;\\n                    int yy = y + dirs[k][1] ;\\n                    if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                        continue ;\\n                    if(visited[xx][yy])\\n                        continue ;\\n                    visited[xx][yy] = true ;\\n                    if(grid[xx][yy] == 1)\\n                        q.push({xx, yy}) ;\\n                    else{\\n                        if(xx == m-1 && yy == n-1)\\n                            return step ;\\n                        auto next = gothrough(grid, visited, xx, yy) ;\\n                        for(int i = next.size()-1; i >=0; i--){\\n                            if(next[i][0] == m-1 && next[i][1] == n-1)\\n                                return step ;\\n                            q.push({next[i][0], next[i][1]}) ;\\n                        }\\n                    }\\n                }\\n            }\\n            step++ ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nusing PII = pair<int, int> ; //{x, y}\\nclass Solution {\\n    int m, n ;\\n    int dirs[4][2] = {{0,1},{0,-1},{1,0},{-1,0}} ;\\n    vector<vector<int>> gothrough(vector<vector<int>>&grid, vector<vector<bool>>&visited, int x0, int y0){\\n        queue<PII>q ;\\n        q.push({x0, y0}) ;\\n        vector<vector<int>>ret ;\\n        while(!q.empty()){\\n            int sz = q.size() ;\\n            for(int len = 0; len < sz; len++)\\n            {\\n                auto [x, y] = q.front() ;\\n                q.pop() ;\\n                for(int k = 0; k < 4; k++){\\n                    int xx = x + dirs[k][0] ;\\n                    int yy = y + dirs[k][1] ;\\n                    if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                        continue ;\\n                    if(visited[xx][yy])\\n                        continue ;\\n                    visited[xx][yy] = true ;\\n                    if(grid[xx][yy] == 1)\\n                        ret.push_back({xx,yy}) ;\\n                    else{\\n                        if(xx == m-1 && yy == n-1){\\n                            ret.push_back({xx, yy}) ;\\n                            return ret ;\\n                        }\\n                        q.push({xx,yy}) ;    \\n                    }\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        m = grid.size() ;\\n        n = grid[0].size() ;\\n        vector<vector<bool>>visited(m, vector<bool>(n)) ;\\n        queue<PII>q ;\\n        q.push({0,0}) ;\\n        visited[0][0] = true ;\\n        int step = 0 ;\\n        while(!q.empty())\\n        {\\n            int sz = q.size() ;\\n            for(int len = 0; len < sz; len++)\\n            {\\n                auto [x,y] = q.front() ;\\n                q.pop() ;\\n                for(int k = 0; k < 4; k++){\\n                    int xx = x + dirs[k][0] ;\\n                    int yy = y + dirs[k][1] ;\\n                    if(xx < 0 || yy < 0 || xx >= m || yy >= n)\\n                        continue ;\\n                    if(visited[xx][yy])\\n                        continue ;\\n                    visited[xx][yy] = true ;\\n                    if(grid[xx][yy] == 1)\\n                        q.push({xx, yy}) ;\\n                    else{\\n                        if(xx == m-1 && yy == n-1)\\n                            return step ;\\n                        auto next = gothrough(grid, visited, xx, yy) ;\\n                        for(int i = next.size()-1; i >=0; i--){\\n                            if(next[i][0] == m-1 && next[i][1] == n-1)\\n                                return step ;\\n                            q.push({next[i][0], next[i][1]}) ;\\n                        }\\n                    }\\n                }\\n            }\\n            step++ ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298141,
                "title": "c-simple-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n, m;\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        this->n = grid.size();\\n        this->m = grid[0].size();\\n        vector<vector<int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        auto comp = [&] (vector<int>& a, vector<int>& b) {\\n            return a[2] > b[2];\\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(comp)> q(comp);\\n        vector<vector<int>> visited(n, vector<int>(m, n * m));\\n        visited[0][0] = 0;\\n        q.push({0, 0, 0});\\n        while (!q.empty()) {\\n            if (q.top()[0] == n - 1 && q.top()[1] == m - 1) return q.top()[2];\\n            vector<int> curr = q.top();\\n            q.pop();\\n            for (auto& d : dir) {\\n                int x = curr[0] + d[0], y = curr[1] + d[1];\\n                if (isbound(x, y) && curr[2] + grid[x][y] < visited[x][y]) {\\n                    visited[x][y] = curr[2] + grid[x][y];\\n                    q.push({x, y, visited[x][y]});\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    bool isbound(int x, int y) {\\n        if (x < 0 || x >= n || y < 0 || y >= m) return false;\\n        return true;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n, m;\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        this->n = grid.size();\\n        this->m = grid[0].size();\\n        vector<vector<int>> dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n        auto comp = [&] (vector<int>& a, vector<int>& b) {\\n            return a[2] > b[2];\\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(comp)> q(comp);\\n        vector<vector<int>> visited(n, vector<int>(m, n * m));\\n        visited[0][0] = 0;\\n        q.push({0, 0, 0});\\n        while (!q.empty()) {\\n            if (q.top()[0] == n - 1 && q.top()[1] == m - 1) return q.top()[2];\\n            vector<int> curr = q.top();\\n            q.pop();\\n            for (auto& d : dir) {\\n                int x = curr[0] + d[0], y = curr[1] + d[1];\\n                if (isbound(x, y) && curr[2] + grid[x][y] < visited[x][y]) {\\n                    visited[x][y] = curr[2] + grid[x][y];\\n                    q.push({x, y, visited[x][y]});\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    bool isbound(int x, int y) {\\n        if (x < 0 || x >= n || y < 0 || y >= m) return false;\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292761,
                "title": "easy-to-understand",
                "content": "\\n\\n\\n# Code\\n```\\nstruct node{\\n    int x,y,remove;\\n    node(int _x,int _y, int _remove){\\n        x=_x;\\n        y=_y;\\n        remove=_remove;\\n    }\\n};\\nclass Solution {\\npublic:\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        deque<node> q;\\n        q.push_front(node(0,0,0));\\n        vector<vector<int>> d(n,vector<int>(m,m*n));\\n        while(!q.empty()){\\n            int x= q.front().x;\\n            int y= q.front().y;\\n            int rv=q.front().remove;\\n            q.pop_front();\\n            int dx[]={1,-1,0,0};\\n            int dy[]={0,0,1,-1};\\n\\n            for(int i=0;i<4;i++){\\n                int newX= x+dx[i];\\n                int newY= y+ dy[i];\\n                if(newX>=0 && newY >=0 && newX<n && newY <m){\\n                    if(grid[newX][newY] + rv < d[newX][newY]){\\n                        d[newX][newY] = grid[newX][newY] + rv;\\n                        if(grid[newX][newY]==0){\\n                            q.push_front(node(newX,newY,grid[newX][newY] + rv));\\n                        }\\n                        else{\\n                            q.push_back(node(newX,newY,grid[newX][newY] + rv));\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n        return d[n-1][m-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct node{\\n    int x,y,remove;\\n    node(int _x,int _y, int _remove){\\n        x=_x;\\n        y=_y;\\n        remove=_remove;\\n    }\\n};\\nclass Solution {\\npublic:\\n\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        deque<node> q;\\n        q.push_front(node(0,0,0));\\n        vector<vector<int>> d(n,vector<int>(m,m*n));\\n        while(!q.empty()){\\n            int x= q.front().x;\\n            int y= q.front().y;\\n            int rv=q.front().remove;\\n            q.pop_front();\\n            int dx[]={1,-1,0,0};\\n            int dy[]={0,0,1,-1};\\n\\n            for(int i=0;i<4;i++){\\n                int newX= x+dx[i];\\n                int newY= y+ dy[i];\\n                if(newX>=0 && newY >=0 && newX<n && newY <m){\\n                    if(grid[newX][newY] + rv < d[newX][newY]){\\n                        d[newX][newY] = grid[newX][newY] + rv;\\n                        if(grid[newX][newY]==0){\\n                            q.push_front(node(newX,newY,grid[newX][newY] + rv));\\n                        }\\n                        else{\\n                            q.push_back(node(newX,newY,grid[newX][newY] + rv));\\n                        }\\n                    }\\n                }\\n\\n            }\\n        }\\n        return d[n-1][m-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231443,
                "title": "bfs-using-priority-queue-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(MxNxLog(MxN))\\n\\n- Space complexity:\\n  O(MxN)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinimumObstacles(int[][] grid) {\\n            bool[,] visited = new bool[grid.Length, grid[0].Length];\\n            PriorityQueue<(int row, int col, int obs), int> q = new PriorityQueue<(int, int, int), int>();\\n            q.Enqueue((0, 0, 0), grid[0][0]);\\n            while (q.Count > 0){\\n                int r = q.Peek().row;\\n                int c = q.Peek().col;\\n                int obs = q.Peek().obs;\\n                q.Dequeue();\\n\\n                if (r == grid.Length - 1 && c == grid[0].Length - 1){\\n                    return obs;\\n                }\\n                if (!visited[r, c]){\\n                    visited[r, c] = true;\\n                    if(grid[r][c] == 1){\\n                        obs = obs+1;\\n                    }\\n                    if (r - 1 >= 0){\\n                        q.Enqueue((r - 1, c, obs), obs);\\n                    }\\n                    if (r + 1 <= grid.Length - 1){\\n                        q.Enqueue((r + 1, c, obs), obs);\\n                    }\\n                    if (c - 1 >= 0){\\n                        q.Enqueue((r, c - 1, obs), obs);\\n                    }\\n                    if (c + 1 <= grid[0].Length - 1){\\n                        q.Enqueue((r, c + 1, obs), obs);\\n                    }\\n                }\\n            }\\n            return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinimumObstacles(int[][] grid) {\\n            bool[,] visited = new bool[grid.Length, grid[0].Length];\\n            PriorityQueue<(int row, int col, int obs), int> q = new PriorityQueue<(int, int, int), int>();\\n            q.Enqueue((0, 0, 0), grid[0][0]);\\n            while (q.Count > 0){\\n                int r = q.Peek().row;\\n                int c = q.Peek().col;\\n                int obs = q.Peek().obs;\\n                q.Dequeue();\\n\\n                if (r == grid.Length - 1 && c == grid[0].Length - 1){\\n                    return obs;\\n                }\\n                if (!visited[r, c]){\\n                    visited[r, c] = true;\\n                    if(grid[r][c] == 1){\\n                        obs = obs+1;\\n                    }\\n                    if (r - 1 >= 0){\\n                        q.Enqueue((r - 1, c, obs), obs);\\n                    }\\n                    if (r + 1 <= grid.Length - 1){\\n                        q.Enqueue((r + 1, c, obs), obs);\\n                    }\\n                    if (c - 1 >= 0){\\n                        q.Enqueue((r, c - 1, obs), obs);\\n                    }\\n                    if (c + 1 <= grid[0].Length - 1){\\n                        q.Enqueue((r, c + 1, obs), obs);\\n                    }\\n                }\\n            }\\n            return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185255,
                "title": "uniform-cost-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int kt[100001],F[100001];\\npriority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> A; \\n    void check(int x,int y,int value,vector<vector<int>>& grid)\\n    {\\n        if(x>=0&&x<=grid[0].size()-1&&y>=0&&y<=grid.size()-1&&kt[y*grid[0].size()+x]==0&&F[y*grid[0].size()+x]>value+grid[y][x])\\n        {\\n            F[y*grid[0].size()+x]=value+grid[y][x];\\n            A.push(make_tuple(value+grid[y][x],x,y));\\n        }\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int value,x,y;\\n        A.push(make_tuple(0,0,0));\\n        memset(F,127,sizeof(F));\\n        while(A.empty()==0)\\n        {\\n            value=get<0>(A.top());\\n            x=get<1>(A.top());\\n            y=get<2>(A.top());\\n            A.pop();\\n            if(x==grid[0].size()-1&&y==grid.size()-1) return value;\\n            if(kt[y*grid[0].size()+x]==0)\\n            {\\n                kt[y*grid[0].size()+x]=1;\\n                check(x+1,y,value,grid);\\n                check(x-1,y,value,grid);\\n                check(x,y+1,value,grid);\\n                check(x,y-1,value,grid);\\n            }   \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kt[100001],F[100001];\\npriority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>> A; \\n    void check(int x,int y,int value,vector<vector<int>>& grid)\\n    {\\n        if(x>=0&&x<=grid[0].size()-1&&y>=0&&y<=grid.size()-1&&kt[y*grid[0].size()+x]==0&&F[y*grid[0].size()+x]>value+grid[y][x])\\n        {\\n            F[y*grid[0].size()+x]=value+grid[y][x];\\n            A.push(make_tuple(value+grid[y][x],x,y));\\n        }\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int value,x,y;\\n        A.push(make_tuple(0,0,0));\\n        memset(F,127,sizeof(F));\\n        while(A.empty()==0)\\n        {\\n            value=get<0>(A.top());\\n            x=get<1>(A.top());\\n            y=get<2>(A.top());\\n            A.pop();\\n            if(x==grid[0].size()-1&&y==grid.size()-1) return value;\\n            if(kt[y*grid[0].size()+x]==0)\\n            {\\n                kt[y*grid[0].size()+x]=1;\\n                check(x+1,y,value,grid);\\n                check(x-1,y,value,grid);\\n                check(x,y+1,value,grid);\\n                check(x,y-1,value,grid);\\n            }   \\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179327,
                "title": "c-2-solution-dijkstra-and-0-1-bfs-o-n",
                "content": "**1. Djjkstra\\'s Algorithm: O(NlogN)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        pq.push({0, {0, 0}});\\n        vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        vis[0][0] = true;\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int cost = it.first;\\n            if(it.second.first == m - 1 and it.second.second == n - 1) return cost;\\n            for(auto dir : dirs){\\n                int nx = it.second.first + dir[0];\\n                int ny = it.second.second + dir[1];\\n                if(nx >= 0 and nx < m and ny >= 0 and ny < n and !vis[nx][ny]){\\n                    vis[nx][ny] = true;\\n                    pq.push({cost + grid[nx][ny], {nx, ny}});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**2. 0-1 BFS: 0(N)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        deque<vector<int>> dq;\\n        dq.push_front({grid[0][0], 0, 0});\\n        vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        vis[0][0] = true;\\n        while(!dq.empty()){\\n            auto it = dq.front();\\n            dq.pop_front();\\n            if(it[1] == m - 1 and it[2] == n - 1) return it[0];\\n            for(auto dir : dirs){\\n                int nx = it[1] + dir[0];\\n                int ny = it[2] + dir[1];\\n                if(nx >= 0 and nx < m and ny >= 0 and ny < n and !vis[nx][ny]){\\n                    vis[nx][ny] = true;\\n                    if(grid[nx][ny] == 1) dq.push_back({1 + it[0], nx, ny});\\n                    else dq.push_front({it[0], nx, ny});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;\\n        pq.push({0, {0, 0}});\\n        vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        vis[0][0] = true;\\n        while(!pq.empty()){\\n            auto it = pq.top();\\n            pq.pop();\\n            int cost = it.first;\\n            if(it.second.first == m - 1 and it.second.second == n - 1) return cost;\\n            for(auto dir : dirs){\\n                int nx = it.second.first + dir[0];\\n                int ny = it.second.second + dir[1];\\n                if(nx >= 0 and nx < m and ny >= 0 and ny < n and !vis[nx][ny]){\\n                    vis[nx][ny] = true;\\n                    pq.push({cost + grid[nx][ny], {nx, ny}});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        deque<vector<int>> dq;\\n        dq.push_front({grid[0][0], 0, 0});\\n        vector<vector<bool>> vis(m, vector<bool> (n, false));\\n        vis[0][0] = true;\\n        while(!dq.empty()){\\n            auto it = dq.front();\\n            dq.pop_front();\\n            if(it[1] == m - 1 and it[2] == n - 1) return it[0];\\n            for(auto dir : dirs){\\n                int nx = it[1] + dir[0];\\n                int ny = it[2] + dir[1];\\n                if(nx >= 0 and nx < m and ny >= 0 and ny < n and !vis[nx][ny]){\\n                    vis[nx][ny] = true;\\n                    if(grid[nx][ny] == 1) dq.push_back({1 + it[0], nx, ny});\\n                    else dq.push_front({it[0], nx, ny});\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163655,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int i,int j,int n,int m)\\n    {\\n        return (i<=n-1 and j<=m-1) and (i>=0 and j>=0);\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            int drow[4]={-1,0,1,0};\\n            int dcol[4]={0,1,0,-1};\\n            if(grid[0][0]==0)\\n            pq.push({0,{0,0}});\\n            else\\n            pq.push({1,{0,0}});\\n            vis[0][0]=true;\\n            while(!pq.empty())\\n            {\\n                auto curr=pq.top();\\n                pq.pop();\\n                // /cout<<\"hi \";\\n                int dist=curr.first;\\n                int row=curr.second.first;\\n                int col=curr.second.second;\\n                // cout<<row<<\" \"<<col<<\"\\\\n\";\\n                // cout<<dist<<\" \";\\n                if(row==n-1 and col==m-1)\\n                return dist;\\n\\n                for(int i=0;i<4;i++)\\n                {\\n                    if(isValid(row+drow[i],col+dcol[i],n,m) and grid[row+drow[i]][col+dcol[i]]==1 and vis[row+drow[i]][col+dcol[i]]==false)\\n                    {\\n                        // cout<<\"hi\";\\n\\n                        vis[row+drow[i]][col+dcol[i]]=true;\\n                        pq.push({dist+1,{row+drow[i],col+dcol[i]}});\\n                    }\\n                    else if(isValid(row+drow[i],col+dcol[i],n,m) and grid[row+drow[i]][col+dcol[i]]==0 and vis[row+drow[i]][col+dcol[i]]==false)\\n                    {\\n                       vis[row+drow[i]][col+dcol[i]]=true;\\n                        pq.push({dist,{row+drow[i],col+dcol[i]}});\\n                    }\\n                }\\n            }\\n\\n            return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int i,int j,int n,int m)\\n    {\\n        return (i<=n-1 and j<=m-1) and (i>=0 and j>=0);\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n            int drow[4]={-1,0,1,0};\\n            int dcol[4]={0,1,0,-1};\\n            if(grid[0][0]==0)\\n            pq.push({0,{0,0}});\\n            else\\n            pq.push({1,{0,0}});\\n            vis[0][0]=true;\\n            while(!pq.empty())\\n            {\\n                auto curr=pq.top();\\n                pq.pop();\\n                // /cout<<\"hi \";\\n                int dist=curr.first;\\n                int row=curr.second.first;\\n                int col=curr.second.second;\\n                // cout<<row<<\" \"<<col<<\"\\\\n\";\\n                // cout<<dist<<\" \";\\n                if(row==n-1 and col==m-1)\\n                return dist;\\n\\n                for(int i=0;i<4;i++)\\n                {\\n                    if(isValid(row+drow[i],col+dcol[i],n,m) and grid[row+drow[i]][col+dcol[i]]==1 and vis[row+drow[i]][col+dcol[i]]==false)\\n                    {\\n                        // cout<<\"hi\";\\n\\n                        vis[row+drow[i]][col+dcol[i]]=true;\\n                        pq.push({dist+1,{row+drow[i],col+dcol[i]}});\\n                    }\\n                    else if(isValid(row+drow[i],col+dcol[i],n,m) and grid[row+drow[i]][col+dcol[i]]==0 and vis[row+drow[i]][col+dcol[i]]==false)\\n                    {\\n                       vis[row+drow[i]][col+dcol[i]]=true;\\n                        pq.push({dist,{row+drow[i],col+dcol[i]}});\\n                    }\\n                }\\n            }\\n\\n            return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3139576,
                "title": "dijkstra-s-algorithm",
                "content": "```python\\ndef minimumObstacles(self, grid: list[list[int]]) -> int:\\n\\tROWS, COLS = len(grid), len(grid[0])\\n\\tdistances = [[float(\"inf\")]*COLS for _ in range(ROWS)]\\n\\tdistances[0][0] = 0\\n\\tdirections = [(1,0),(-1,0),(0,1),(0,-1)]\\n\\tqueue = [[distances[0][0], 0, 0]]\\n\\n\\twhile queue:\\n\\t\\tdist, i, j = heapq.heappop(queue)\\n\\t\\tif dist > distances[i][j]: continue\\n\\t\\tdistances[i][j] = dist\\n\\t\\tfor rd, cd in directions:\\n\\t\\t\\trr, cc = i + rd, j + cd\\n\\t\\t\\tif rr >= 0 and rr < ROWS and cc >= 0 and cc < COLS:\\n\\t\\t\\t\\tnew_dist = dist + grid[rr][cc]\\n\\t\\t\\t\\tif new_dist < distances[rr][cc]:\\n\\t\\t\\t\\t\\tdistances[rr][cc] = new_dist\\n\\t\\t\\t\\t\\theapq.heappush(queue, [distances[rr][cc], rr, cc])\\n\\t\\tif i == ROWS-1 and j == COLS-1:\\n\\t\\t\\tbreak\\n\\treturn distances[ROWS-1][COLS-1] if distances[ROWS-1][COLS-1] != float(\"inf\") else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef minimumObstacles(self, grid: list[list[int]]) -> int:\\n\\tROWS, COLS = len(grid), len(grid[0])\\n\\tdistances = [[float(\"inf\")]*COLS for _ in range(ROWS)]\\n\\tdistances[0][0] = 0\\n\\tdirections = [(1,0),(-1,0),(0,1),(0,-1)]\\n\\tqueue = [[distances[0][0], 0, 0]]\\n\\n\\twhile queue:\\n\\t\\tdist, i, j = heapq.heappop(queue)\\n\\t\\tif dist > distances[i][j]: continue\\n\\t\\tdistances[i][j] = dist\\n\\t\\tfor rd, cd in directions:\\n\\t\\t\\trr, cc = i + rd, j + cd\\n\\t\\t\\tif rr >= 0 and rr < ROWS and cc >= 0 and cc < COLS:\\n\\t\\t\\t\\tnew_dist = dist + grid[rr][cc]\\n\\t\\t\\t\\tif new_dist < distances[rr][cc]:\\n\\t\\t\\t\\t\\tdistances[rr][cc] = new_dist\\n\\t\\t\\t\\t\\theapq.heappush(queue, [distances[rr][cc], rr, cc])\\n\\t\\tif i == ROWS-1 and j == COLS-1:\\n\\t\\t\\tbreak\\n\\treturn distances[ROWS-1][COLS-1] if distances[ROWS-1][COLS-1] != float(\"inf\") else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3127544,
                "title": "java-dijkestra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {0, grid[0][0]});\\n        visited[0][0] = true;\\n        \\n        while(!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            int r = curr[0] / n;\\n            int c = curr[0] % n;\\n            int cost = curr[1];\\n            if(r == m - 1 && c == n - 1)\\n                return cost;\\n\\n            for(int[] d : dir) {\\n                int row = r + d[0];\\n                int col = c + d[1];\\n                if(!valid(m, n, row, col) || visited[row][col]) \\n                    continue;\\n  \\n                visited[row][col] = true;\\n                int cell = row * n + col;\\n                pq.offer(new int[] {cell, cost + grid[row][col]});\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    public boolean valid(int m, int n, int r, int c) {\\n        return r >= 0 && c >= 0 && r < m && c < n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        boolean[][] visited = new boolean[m][n];\\n        Queue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n        pq.offer(new int[] {0, grid[0][0]});\\n        visited[0][0] = true;\\n        \\n        while(!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            int r = curr[0] / n;\\n            int c = curr[0] % n;\\n            int cost = curr[1];\\n            if(r == m - 1 && c == n - 1)\\n                return cost;\\n\\n            for(int[] d : dir) {\\n                int row = r + d[0];\\n                int col = c + d[1];\\n                if(!valid(m, n, row, col) || visited[row][col]) \\n                    continue;\\n  \\n                visited[row][col] = true;\\n                int cell = row * n + col;\\n                pq.offer(new int[] {cell, cost + grid[row][col]});\\n            }\\n        }\\n\\n        return -1;\\n    }\\n    public boolean valid(int m, int n, int r, int c) {\\n        return r >= 0 && c >= 0 && r < m && c < n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109851,
                "title": "simple-bfs-using-heap",
                "content": "we can insert (0, 0, 0) in a queue where first `0` signifies the removals and the remaining two are `(i, j)` of matrix.\\n\\nwe maintain `visited` map (with key as index of matrix) that stores the minimum number of removals we need to do to reach to that index from `(0, 0)`\\nNow, we do a bfs and go to its neighbors, identify the number of removals and insert it back into heap. We repeat this process unless the last cell is obtained.\\n```\\nimport heapq\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        we can try to solve this problem using priority queue \\n        and breadth first search\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        heap = []\\n        heapq.heappush(heap, (0, 0, 0))\\n        visited = {(0, 0): 0}\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j-1), (i,j+1)]\\n\\n        while len(heap):\\n            removal, i, j = heapq.heappop(heap)\\n            if (i, j) == (m-1, n-1):\\n                return removal\\n            for x, y in get_neis(i, j):\\n                if is_valid(x, y):\\n                    val = grid[x][y]\\n                    if visited.get((x,y), float(\\'inf\\')) > removal + val:\\n                        visited[(x,y)] = removal + val\\n                        heapq.heappush(heap, (removal+val, x, y))\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        \"\"\"\\n        we can try to solve this problem using priority queue \\n        and breadth first search\\n        \"\"\"\\n        m, n = len(grid), len(grid[0])\\n        heap = []\\n        heapq.heappush(heap, (0, 0, 0))\\n        visited = {(0, 0): 0}\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        def get_neis(i, j):\\n            return [(i+1,j), (i-1,j), (i,j-1), (i,j+1)]\\n\\n        while len(heap):\\n            removal, i, j = heapq.heappop(heap)\\n            if (i, j) == (m-1, n-1):\\n                return removal\\n            for x, y in get_neis(i, j):\\n                if is_valid(x, y):\\n                    val = grid[x][y]\\n                    if visited.get((x,y), float(\\'inf\\')) > removal + val:\\n                        visited[(x,y)] = removal + val\\n                        heapq.heappush(heap, (removal+val, x, y))\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067580,
                "title": "simple-dijakstra",
                "content": "```\\nclass Solution {\\npublic:\\n    bool issafe(int r,int c, set<pair<int,int>> &vis,vector<vector<int>>& grid )\\n    {\\n        if (vis.find({r,c})!=vis.end())\\n            return false;\\n        if (r<0 or r>=grid.size() or c<0 or c>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n    set<pair<int,int>> visited;\\n    priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n    pq.push({0,{0,0}});\\n    int r=grid.size()-1;\\n    visited.insert({0,0});\\n    int c=grid[0].size()-1;\\n    vector<vector<int>> directions={{0,-1},{0,1},{-1,0},{1,0}};\\n    while(pq.size()>0)\\n    {\\n        pair<int,pair<int,int>> p=pq.top();\\n        pq.pop();\\n        if (p.second.first==r && p.second.second==c)\\n            return p.first;\\n        int cr=p.second.first;\\n        int cc=p.second.second;\\n        for (int i=0;i<directions.size();i++)\\n        {\\n            int nr=directions[i][0]+cr;\\n            int nc=directions[i][1]+cc;\\n            if (issafe(nr,nc,visited,grid)==false)\\n                continue;\\n            visited.insert({nr,nc});\\n            int cost=grid[nr][nc]==1?1:0;\\n            cost+=p.first;\\n            pq.push({cost,{nr,nc}});\\n        }\\n        \\n        \\n    }\\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool issafe(int r,int c, set<pair<int,int>> &vis,vector<vector<int>>& grid )\\n    {\\n        if (vis.find({r,c})!=vis.end())\\n            return false;\\n        if (r<0 or r>=grid.size() or c<0 or c>=grid[0].size())\\n            return false;\\n        return true;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n    set<pair<int,int>> visited;\\n    priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n    pq.push({0,{0,0}});\\n    int r=grid.size()-1;\\n    visited.insert({0,0});\\n    int c=grid[0].size()-1;\\n    vector<vector<int>> directions={{0,-1},{0,1},{-1,0},{1,0}};\\n    while(pq.size()>0)\\n    {\\n        pair<int,pair<int,int>> p=pq.top();\\n        pq.pop();\\n        if (p.second.first==r && p.second.second==c)\\n            return p.first;\\n        int cr=p.second.first;\\n        int cc=p.second.second;\\n        for (int i=0;i<directions.size();i++)\\n        {\\n            int nr=directions[i][0]+cr;\\n            int nc=directions[i][1]+cc;\\n            if (issafe(nr,nc,visited,grid)==false)\\n                continue;\\n            visited.insert({nr,nc});\\n            int cost=grid[nr][nc]==1?1:0;\\n            cost+=p.first;\\n            pq.push({cost,{nr,nc}});\\n        }\\n        \\n        \\n    }\\n        return 0;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046965,
                "title": "c-dijkstra",
                "content": "# Intuition\\nDijkstra from last cell as source. Consider number of obstacles to minimise.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N * M (log(n * M)))\\n\\n- Space complexity:\\nO(N * M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<int, int> > dis;\\n    unordered_map<int, unordered_map<int, bool> > f;\\n    \\n    int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    \\n    struct cmp {\\n        bool operator()(const pair<pair<int, int>, int>& a, const pair<pair<int, int>, int>& b) {\\n            return a.second > b.second;\\n        }\\n    };\\n    \\n    void assign(int n, int m) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dis[i][j] = 1000000;\\n            }\\n        }\\n    }\\n    \\n    bool isValid(int r, int c, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        return r >= 0 && r < n && c >= 0 && c < m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        assign(n, m);\\n        priority_queue<pair<pair<int, int> , int>, vector<pair<pair<int, int>, int> >, cmp> q;\\n        \\n        q.push({{n - 1, m - 1}, 0});\\n        \\n        dis[n - 1][m - 1] = 0;\\n        \\n        while (!q.empty()) {\\n            pair<pair<int, int>, int> node = q.top();\\n            q.pop();\\n            \\n            int r = node.first.first;\\n            int c = node.first.second;\\n            int wt = node.second;\\n            \\n            //cout<<r<<\" \"<<c<<\" \"<<wt<<endl;\\n            if (f[r][c]) {\\n                continue;\\n            }\\n            \\n            for (int d = 0; d < 4; d++) {\\n                int n_r = r + dir[d][0];\\n                int n_c = c + dir[d][1];\\n                \\n                if (!f[n_r][n_c] && isValid(n_r, n_c, grid)) {\\n                    if (grid[n_r][n_c] == 1) {\\n                        if (dis[n_r][n_c] > dis[r][c] + 1) {\\n                            dis[n_r][n_c] = dis[r][c] + 1;\\n                            q.push({{n_r, n_c}, dis[n_r][n_c]});\\n                        }\\n                    } else {\\n                        if (dis[n_r][n_c] > dis[r][c]) {\\n                            dis[n_r][n_c] = dis[r][c];\\n                            q.push({{n_r, n_c}, dis[n_r][n_c]});\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            f[r][c] = true;\\n            \\n        }\\n        \\n        return dis[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<int, int> > dis;\\n    unordered_map<int, unordered_map<int, bool> > f;\\n    \\n    int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    \\n    struct cmp {\\n        bool operator()(const pair<pair<int, int>, int>& a, const pair<pair<int, int>, int>& b) {\\n            return a.second > b.second;\\n        }\\n    };\\n    \\n    void assign(int n, int m) {\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                dis[i][j] = 1000000;\\n            }\\n        }\\n    }\\n    \\n    bool isValid(int r, int c, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        return r >= 0 && r < n && c >= 0 && c < m;\\n    }\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        assign(n, m);\\n        priority_queue<pair<pair<int, int> , int>, vector<pair<pair<int, int>, int> >, cmp> q;\\n        \\n        q.push({{n - 1, m - 1}, 0});\\n        \\n        dis[n - 1][m - 1] = 0;\\n        \\n        while (!q.empty()) {\\n            pair<pair<int, int>, int> node = q.top();\\n            q.pop();\\n            \\n            int r = node.first.first;\\n            int c = node.first.second;\\n            int wt = node.second;\\n            \\n            //cout<<r<<\" \"<<c<<\" \"<<wt<<endl;\\n            if (f[r][c]) {\\n                continue;\\n            }\\n            \\n            for (int d = 0; d < 4; d++) {\\n                int n_r = r + dir[d][0];\\n                int n_c = c + dir[d][1];\\n                \\n                if (!f[n_r][n_c] && isValid(n_r, n_c, grid)) {\\n                    if (grid[n_r][n_c] == 1) {\\n                        if (dis[n_r][n_c] > dis[r][c] + 1) {\\n                            dis[n_r][n_c] = dis[r][c] + 1;\\n                            q.push({{n_r, n_c}, dis[n_r][n_c]});\\n                        }\\n                    } else {\\n                        if (dis[n_r][n_c] > dis[r][c]) {\\n                            dis[n_r][n_c] = dis[r][c];\\n                            q.push({{n_r, n_c}, dis[n_r][n_c]});\\n                        }\\n                    }\\n                }\\n            }\\n            \\n            f[r][c] = true;\\n            \\n        }\\n        \\n        return dis[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3044361,
                "title": "python-solution-slowish-yet-very-efficient-bfs",
                "content": "\\n![Screenshot 2023-01-13 at 10.19.29.png](https://assets.leetcode.com/users/images/39a3d388-6e3e-4eb6-a562-5792b23fff3e_1673598286.6098428.png)\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm is O(mn) because each point is visited once and the number of operations per point is constant. \\nAlso a note that the use of deque from python collections library is to improve the time complexity from O(mn) to O(m+n).\\n\\n- Space complexity:\\nThe space complexity is also O(mn) because it stores the distances of all points in the grid.\\n# Code\\n```\\nfrom collections import deque\\nfrom typing import List\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dist = [[float(\\'inf\\')] * n for _ in range(m)]\\n        dist[0][0] = 0\\n        q = deque([(0, 0)])\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        while q:\\n            x, y = q.popleft()\\n            for dx, dy in directions:\\n                i, j = x + dx, y + dy\\n                if 0 <= i < m and 0 <= j < n:\\n                    if grid[i][j] == 0:\\n                        if dist[i][j] > dist[x][y]:\\n                            dist[i][j] = dist[x][y]\\n                            q.append((i, j))\\n                    else:\\n                        if dist[i][j] > dist[x][y] + 1:\\n                            dist[i][j] = dist[x][y] + 1\\n                            q.append((i, j))\\n        return dist[m-1][n-1]\\n```\\n**Explanation**: This solution\\'s implementation of a Breadth-First Search algorithm starts by initializing the distance of the starting point to 0 and adding it to the queue. Then it repeatedly pops the next point in the queue and updates the distance of the neighbors if it is shorter than the current distance. Finally, it returns the distance of the end point.\\n\\nMore LeetCode solutions of mine at https://github.com/aurimas13/Solutions-To-Problems",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nfrom typing import List\\n\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dist = [[float(\\'inf\\')] * n for _ in range(m)]\\n        dist[0][0] = 0\\n        q = deque([(0, 0)])\\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n        while q:\\n            x, y = q.popleft()\\n            for dx, dy in directions:\\n                i, j = x + dx, y + dy\\n                if 0 <= i < m and 0 <= j < n:\\n                    if grid[i][j] == 0:\\n                        if dist[i][j] > dist[x][y]:\\n                            dist[i][j] = dist[x][y]\\n                            q.append((i, j))\\n                    else:\\n                        if dist[i][j] > dist[x][y] + 1:\\n                            dist[i][j] = dist[x][y] + 1\\n                            q.append((i, j))\\n        return dist[m-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042466,
                "title": "c-dijkstra-solution-accurate-and-simple",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const vector<vector<int>> dir{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int N = grid.size();\\n        const int M = grid[0].size();\\n        vector<vector<int>> count(N, vector<int>(M, INT_MAX));\\n        priority_queue<Data, vector<Data>, Comp> q;\\n        count[0][0] = 0;\\n        q.push(make_data(0, 0, 0));\\n        int curr_r, curr_c;\\n\\n        while (q.empty() == false)\\n        {\\n            auto [cnt, r, c] = q.top();\\n            q.pop();\\n\\n            for (const vector<int>& d : dir)\\n            {\\n                curr_r = r + d[0];\\n                curr_c = c + d[1];\\n\\n                if (inRange(N, M, curr_r, curr_c) && count[curr_r][curr_c] > cnt + grid[curr_r][curr_c])\\n                    count[curr_r][curr_c] = cnt + grid[curr_r][curr_c], q.push(make_data(count[curr_r][curr_c], curr_r, curr_c));\\n            } \\n        }\\n\\n        return count[N - 1][M - 1];\\n\\n    }\\n\\nprivate:\\n    struct Data\\n    {\\n        int count;\\n        int row;\\n        int col;\\n        Data(const int& i, const int& j, const int& k) : count(i), row(j), col(k) {} \\n    };\\n\\n    Data make_data(const int& i, const int& j, const int& k) { return Data(i, j, k); }\\n\\n    class Comp\\n    {\\n    public:\\n        inline bool operator()(const Data& d1, const Data& d2) { return d1.count >= d2.count; }\\n    };\\n\\n    inline bool inRange(const int& N, const int& M, const int& row, const int& col) { return row >= 0 && row < N && col >= 0 && col < M; }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const vector<vector<int>> dir{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int N = grid.size();\\n        const int M = grid[0].size();\\n        vector<vector<int>> count(N, vector<int>(M, INT_MAX));\\n        priority_queue<Data, vector<Data>, Comp> q;\\n        count[0][0] = 0;\\n        q.push(make_data(0, 0, 0));\\n        int curr_r, curr_c;\\n\\n        while (q.empty() == false)\\n        {\\n            auto [cnt, r, c] = q.top();\\n            q.pop();\\n\\n            for (const vector<int>& d : dir)\\n            {\\n                curr_r = r + d[0];\\n                curr_c = c + d[1];\\n\\n                if (inRange(N, M, curr_r, curr_c) && count[curr_r][curr_c] > cnt + grid[curr_r][curr_c])\\n                    count[curr_r][curr_c] = cnt + grid[curr_r][curr_c], q.push(make_data(count[curr_r][curr_c], curr_r, curr_c));\\n            } \\n        }\\n\\n        return count[N - 1][M - 1];\\n\\n    }\\n\\nprivate:\\n    struct Data\\n    {\\n        int count;\\n        int row;\\n        int col;\\n        Data(const int& i, const int& j, const int& k) : count(i), row(j), col(k) {} \\n    };\\n\\n    Data make_data(const int& i, const int& j, const int& k) { return Data(i, j, k); }\\n\\n    class Comp\\n    {\\n    public:\\n        inline bool operator()(const Data& d1, const Data& d2) { return d1.count >= d2.count; }\\n    };\\n\\n    inline bool inRange(const int& N, const int& M, const int& row, const int& col) { return row >= 0 && row < N && col >= 0 && col < M; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034684,
                "title": "golang-priority-queue",
                "content": "```go\\ntype PriorityQueue [][3]int\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i][0] < pq[j][0] }\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  *pq = append(*pq, x.([3]int))\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc (pq PriorityQueue) Top() interface{} {\\n  return pq[0]\\n}\\n\\nfunc minimumObstacles(grid [][]int) int {\\n  m, n := len(grid), len(grid[0])\\n  var pq PriorityQueue\\n  var res int\\n  heap.Push(&pq, [3]int{grid[0][0], 0, 0})\\n  directions := [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}\\n  visited := make([][]bool, m)\\n  for i := 0; i < len(visited); i++ {\\n    visited[i] = make([]bool, n)\\n  }\\n  visited[0][0] = true\\n  for pq.Len() > 0 {\\n    top := heap.Pop(&pq).([3]int)\\n    x, y := top[1], top[2]\\n    if x == m-1 && y == n-1 {\\n      res = top[0]\\n      break\\n    }\\n    for _, dir := range directions {\\n      x1, y1 := x + dir[0], y + dir[1]\\n      if x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && !visited[x1][y1] {\\n        visited[x1][y1] = true\\n        heap.Push(&pq, [3]int{top[0] + grid[x1][y1], x1, y1})\\n      }\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```go\\ntype PriorityQueue [][3]int\\n\\nfunc (pq PriorityQueue) Len() int           { return len(pq) }\\nfunc (pq PriorityQueue) Less(i, j int) bool { return pq[i][0] < pq[j][0] }\\nfunc (pq PriorityQueue) Swap(i, j int)      { pq[i], pq[j] = pq[j], pq[i] }\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n  *pq = append(*pq, x.([3]int))\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n  old := *pq\\n  n := len(old)\\n  item := old[n-1]\\n  *pq = old[:n-1]\\n  return item\\n}\\n\\nfunc (pq PriorityQueue) Top() interface{} {\\n  return pq[0]\\n}\\n\\nfunc minimumObstacles(grid [][]int) int {\\n  m, n := len(grid), len(grid[0])\\n  var pq PriorityQueue\\n  var res int\\n  heap.Push(&pq, [3]int{grid[0][0], 0, 0})\\n  directions := [4][2]int{{0, -1}, {-1, 0}, {0, 1}, {1, 0}}\\n  visited := make([][]bool, m)\\n  for i := 0; i < len(visited); i++ {\\n    visited[i] = make([]bool, n)\\n  }\\n  visited[0][0] = true\\n  for pq.Len() > 0 {\\n    top := heap.Pop(&pq).([3]int)\\n    x, y := top[1], top[2]\\n    if x == m-1 && y == n-1 {\\n      res = top[0]\\n      break\\n    }\\n    for _, dir := range directions {\\n      x1, y1 := x + dir[0], y + dir[1]\\n      if x1 >= 0 && x1 < m && y1 >= 0 && y1 < n && !visited[x1][y1] {\\n        visited[x1][y1] = true\\n        heap.Push(&pq, [3]int{top[0] + grid[x1][y1], x1, y1})\\n      }\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2981077,
                "title": "python-simple-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        distance = collections.defaultdict(int)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                distance[(i,j)] = float(\"inf\")\\n\\n        distance[(0,0)] = grid[0][0]\\n\\n        stack = [(0,0,0)]\\n\\n        while stack:\\n            weight, i, j = heapq.heappop(stack)\\n\\n            if i == m-1 and j == n-1:\\n                return weight\\n\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0 <= ni < m and 0 <= nj < n and distance[(ni,nj)] > weight + grid[ni][nj]:\\n                    distance[(ni,nj)] = weight + grid[ni][nj]\\n                    heapq.heappush(stack,(weight+grid[ni][nj],ni,nj))\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        distance = collections.defaultdict(int)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                distance[(i,j)] = float(\"inf\")\\n\\n        distance[(0,0)] = grid[0][0]\\n\\n        stack = [(0,0,0)]\\n\\n        while stack:\\n            weight, i, j = heapq.heappop(stack)\\n\\n            if i == m-1 and j == n-1:\\n                return weight\\n\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0 <= ni < m and 0 <= nj < n and distance[(ni,nj)] > weight + grid[ni][nj]:\\n                    distance[(ni,nj)] = weight + grid[ni][nj]\\n                    heapq.heappush(stack,(weight+grid[ni][nj],ni,nj))\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980448,
                "title": "python-simple-dfs-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        dict1 = collections.defaultdict(dict)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0:\\n                    dict1[(i,j)][(i-1,j)] = grid[i-1][j]\\n                if i+1 < m:\\n                    dict1[(i,j)][(i+1,j)] = grid[i+1][j]\\n                if j > 0:\\n                    dict1[(i,j)][(i,j-1)] = grid[i][j-1]\\n                if j+1 < n:\\n                    dict1[(i,j)][(i,j+1)] = grid[i][j+1]\\n\\n\\n        stack, visited = [(grid[0][0],0,0)], set()\\n\\n        visited.add((0,0))\\n\\n        while stack:\\n            weight, i, j = heapq.heappop(stack)\\n\\n            if i == m-1 and j == n-1:\\n                return weight\\n\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0 <= ni < m and 0 <= nj < n and (ni,nj) not in visited:\\n                    heapq.heappush(stack,(weight+dict1[(i,j)][(ni,nj)],ni,nj))\\n                    visited.add((ni,nj))\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid):\\n        m, n = len(grid), len(grid[0])\\n\\n        dict1 = collections.defaultdict(dict)\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if i > 0:\\n                    dict1[(i,j)][(i-1,j)] = grid[i-1][j]\\n                if i+1 < m:\\n                    dict1[(i,j)][(i+1,j)] = grid[i+1][j]\\n                if j > 0:\\n                    dict1[(i,j)][(i,j-1)] = grid[i][j-1]\\n                if j+1 < n:\\n                    dict1[(i,j)][(i,j+1)] = grid[i][j+1]\\n\\n\\n        stack, visited = [(grid[0][0],0,0)], set()\\n\\n        visited.add((0,0))\\n\\n        while stack:\\n            weight, i, j = heapq.heappop(stack)\\n\\n            if i == m-1 and j == n-1:\\n                return weight\\n\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0 <= ni < m and 0 <= nj < n and (ni,nj) not in visited:\\n                    heapq.heappush(stack,(weight+dict1[(i,j)][(ni,nj)],ni,nj))\\n                    visited.add((ni,nj))\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970933,
                "title": "java-simple-bfs",
                "content": "```\\nclass Solution\\n{\\n    private int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    public int minimumObstacles(int[][] grid) \\n    {\\n        int n = grid.length, m = grid[0].length;\\n        \\n        Integer[][] removal = new Integer[n][m]; \\n        removal[0][0] =  grid[0][0];\\n        \\n        Queue<int[]> qu = new LinkedList<>();\\n        qu.add(new int[]{0, 0});\\n        \\n        while(!qu.isEmpty())\\n        {\\n            int[] curr = qu.remove();\\n            \\n            for(int[] dir : dirs)\\n            {\\n                int i = curr[0] + dir[0];\\n                int j = curr[1] + dir[1];\\n                if(i < n && j < m && i >= 0 && j >= 0)\\n                {\\n                    int nextEntry =  removal[curr[0]][curr[1]] + grid[i][j];\\n                    update_Removals(i, j, curr, removal, qu, nextEntry);\\n                }\\n            }\\n        }\\n        return removal[n - 1][m - 1];\\n    }\\n    \\n    private void update_Removals(int i, int j, int[] curr, Integer[][] removal, Queue<int[]> qu, int nextEntry)\\n    {\\n        if(removal[i][j] == null || removal[i][j] > nextEntry){\\n            removal[i][j] = nextEntry;\\n            qu.add(new int[]{i, j});\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    private int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    \\n    public int minimumObstacles(int[][] grid) \\n    {\\n        int n = grid.length, m = grid[0].length;\\n        \\n        Integer[][] removal = new Integer[n][m]; \\n        removal[0][0] =  grid[0][0];\\n        \\n        Queue<int[]> qu = new LinkedList<>();\\n        qu.add(new int[]{0, 0});\\n        \\n        while(!qu.isEmpty())\\n        {\\n            int[] curr = qu.remove();\\n            \\n            for(int[] dir : dirs)\\n            {\\n                int i = curr[0] + dir[0];\\n                int j = curr[1] + dir[1];\\n                if(i < n && j < m && i >= 0 && j >= 0)\\n                {\\n                    int nextEntry =  removal[curr[0]][curr[1]] + grid[i][j];\\n                    update_Removals(i, j, curr, removal, qu, nextEntry);\\n                }\\n            }\\n        }\\n        return removal[n - 1][m - 1];\\n    }\\n    \\n    private void update_Removals(int i, int j, int[] curr, Integer[][] removal, Queue<int[]> qu, int nextEntry)\\n    {\\n        if(removal[i][j] == null || removal[i][j] > nextEntry){\\n            removal[i][j] = nextEntry;\\n            qu.add(new int[]{i, j});\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952513,
                "title": "simple-fast-easy-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>> ,greater<pair<int,pair<int,int>>> >pq;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        pq.push({0,{0,0}});\\n        vis[0][0]=1;\\n        int nrow[]={-1,0,+1,0};\\n        int ncol[]={0,+1,0,-1};\\n        while(!pq.empty())\\n        {\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            int obstacle=pq.top().first;\\n            pq.pop();\\n            if(x==n-1 && y==m-1)\\n            {\\n                return obstacle;\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int xnode=x+nrow[i];\\n                int ynode=y+ncol[i];\\n                if(xnode>=0 && xnode<n && ynode>=0 && ynode<m && vis[xnode][ynode]==0)\\n                {\\n                    if(grid[xnode][ynode]==0)\\n                    {\\n                        pq.push({obstacle,{xnode,ynode}});\\n                    }\\n                    else\\n                    {\\n                        pq.push({obstacle+1,{xnode,ynode}});\\n                    }\\n                    vis[xnode][ynode]=1;\\n                }\\n            }\\n\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>> ,greater<pair<int,pair<int,int>>> >pq;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        pq.push({0,{0,0}});\\n        vis[0][0]=1;\\n        int nrow[]={-1,0,+1,0};\\n        int ncol[]={0,+1,0,-1};\\n        while(!pq.empty())\\n        {\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            int obstacle=pq.top().first;\\n            pq.pop();\\n            if(x==n-1 && y==m-1)\\n            {\\n                return obstacle;\\n            }\\n            for(int i=0;i<4;i++)\\n            {\\n                int xnode=x+nrow[i];\\n                int ynode=y+ncol[i];\\n                if(xnode>=0 && xnode<n && ynode>=0 && ynode<m && vis[xnode][ynode]==0)\\n                {\\n                    if(grid[xnode][ynode]==0)\\n                    {\\n                        pq.push({obstacle,{xnode,ynode}});\\n                    }\\n                    else\\n                    {\\n                        pq.push({obstacle+1,{xnode,ynode}});\\n                    }\\n                    vis[xnode][ynode]=1;\\n                }\\n            }\\n\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945217,
                "title": "java-bfs-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        boolean vis[][]=new boolean[m][n];\\n        \\n        // max priority queue\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        if(grid[0][0]==0)\\n        pq.add(new int[]{0,0,0});\\n        else\\n        pq.add(new int[]{1,0,0});\\n\\n        vis[0][0]=true;\\n        int[][] directions = new int[][] {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n\\n        while(!pq.isEmpty()){\\n            int current[]=pq.poll();\\n            // if reached to last index\\n            if(current[1]==m-1 && current[2]==n-1)\\n            return current[0];\\n            \\n            for(int dir[] :directions){\\n                int delrow=current[1]+dir[0];\\n                int delcol=current[2]+dir[1];\\n\\n                if(delrow<0 || delcol<0 || delrow==m ||delcol==n ||vis[delrow][delcol])\\n                continue;\\n                vis[delrow][delcol]=true;\\n\\n                if(grid[delrow][delcol]==1)\\n                pq.add(new int[] {current[0]+1,delrow,delcol});\\n                else\\n                pq.add(new int[]{current[0],delrow,delcol});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        boolean vis[][]=new boolean[m][n];\\n        \\n        // max priority queue\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        if(grid[0][0]==0)\\n        pq.add(new int[]{0,0,0});\\n        else\\n        pq.add(new int[]{1,0,0});\\n\\n        vis[0][0]=true;\\n        int[][] directions = new int[][] {{-1, 0}, {0, -1}, {1, 0}, {0, 1}};\\n\\n        while(!pq.isEmpty()){\\n            int current[]=pq.poll();\\n            // if reached to last index\\n            if(current[1]==m-1 && current[2]==n-1)\\n            return current[0];\\n            \\n            for(int dir[] :directions){\\n                int delrow=current[1]+dir[0];\\n                int delcol=current[2]+dir[1];\\n\\n                if(delrow<0 || delcol<0 || delrow==m ||delcol==n ||vis[delrow][delcol])\\n                continue;\\n                vis[delrow][delcol]=true;\\n\\n                if(grid[delrow][delcol]==1)\\n                pq.add(new int[] {current[0]+1,delrow,delcol});\\n                else\\n                pq.add(new int[]{current[0],delrow,delcol});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939990,
                "title": "using-0-1-bfs",
                "content": "# Intuition\\nCan be converted into O-1 BFS\\n\\n# Approach\\nAdd the free cell at front and obstacles cells t back of deque.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nimport java.util.*;\\n class Pair{\\n    int a ;\\n    int b;\\n    int c;\\n    Pair(int a ,int b){\\n        this.a = a;\\n        this.b= b;\\n    }\\n    Pair(int a,int b ,int c){\\n        this.a= a;\\n        this.b= b;\\n        this.c= c;\\n    }\\n}\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] distance = new int[n][m];\\n        for(int i=0;i<n;i++){\\n          for(int j=0;j<m;j++){\\n              distance[i][j]= Integer.MAX_VALUE;\\n          }\\n        }\\n    Deque<Pair> dequeue = new LinkedList<>();\\n    dequeue.add(new Pair(0,0,0));\\n    ArrayList<Pair> list = new ArrayList<>();\\n    list.add(new Pair(1,0));\\n    list.add(new Pair(-1,0));\\n    list.add(new Pair(0,1));\\n    list.add(new Pair(0,-1));\\n    distance[0][0]=0;\\n    while(!dequeue.isEmpty()){\\n        int x = dequeue.peekFirst().a;\\n        int y = dequeue.peekFirst().b;\\n        int obs = dequeue.peekFirst().c;\\n        dequeue.poll();\\n         for(Pair i:list){\\n             int r = x+i.a;\\n             int c = y+i.b;\\n             if(r>=0 && r<n && c>=0 &&c<m){\\n             if(grid[r][c]==0){\\n                 if(obs<distance[r][c]){\\n                 distance[r][c] = obs;\\n                dequeue.addFirst(new Pair(r,c,distance[r][c]));\\n                }\\n             }\\n            else{\\n                if(obs+1<distance[r][c]){\\n                    distance[r][c] =obs+1;\\n                dequeue.addLast(new Pair(r,c,distance[r][c]));\\n                }\\n            }\\n            }\\n            }\\n         }\\nreturn distance[n-1][m-1];\\n}\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[][] distance = new int[n][m];\\n        for(int i=0;i<n;i++){\\n          for(int j=0;j<m;j++){\\n              distance[i][j]= Integer.MAX_VALUE;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2915062,
                "title": "python-3-heap-easy-to-understand-with-comments",
                "content": "![image.png](https://assets.leetcode.com/users/images/e4d1cb6b-cee7-485a-a53e-51230590f939_1671119959.431977.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        \\n        drt     = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n        visited = set()\\n        row_n   = len(grid)\\n        col_n   = len(grid[0])\\n\\n        # number of obstacles removed, obstacle in cell, r, c\\n        hpf = [(grid[0][0], grid[0][0], 0, 0,)] \\n        heapify(hpf)\\n\\n        while hpf:  # heap will always give to us cell with:\\n                    # 1. minimum obstacles removed\\n                    # 2. cell without obstacle\\n            # n - number of obstacles removed, v - obstacle in cell, \\n            # r - cell\\'s row, c - cell\\'s column\\n            (n, v, r, c) = heappop(hpf) \\n\\n            if (r, c) == (row_n - 1, col_n -1): return n\\n            if (r, c) in visited:               continue\\n            visited.add((r, c))\\n\\n            for r_dlt, c_dlt in drt:\\n                r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                if 0 <= r_adj < row_n and \\\\\\n                   0 <= c_adj < col_n:\\n                    heappush(hpf, (n + v, grid[r_adj][c_adj], r_adj, c_adj))\\n\\n        return -1  # actually we don\\'t need this,\\n                   # because code will always reach the bottom-right corner\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        \\n        drt     = [[-1, 0], [0, -1], [1, 0], [0, 1]]\\n        visited = set()\\n        row_n   = len(grid)\\n        col_n   = len(grid[0])\\n\\n        # number of obstacles removed, obstacle in cell, r, c\\n        hpf = [(grid[0][0], grid[0][0], 0, 0,)] \\n        heapify(hpf)\\n\\n        while hpf:  # heap will always give to us cell with:\\n                    # 1. minimum obstacles removed\\n                    # 2. cell without obstacle\\n            # n - number of obstacles removed, v - obstacle in cell, \\n            # r - cell\\'s row, c - cell\\'s column\\n            (n, v, r, c) = heappop(hpf) \\n\\n            if (r, c) == (row_n - 1, col_n -1): return n\\n            if (r, c) in visited:               continue\\n            visited.add((r, c))\\n\\n            for r_dlt, c_dlt in drt:\\n                r_adj, c_adj = r + r_dlt, c + c_dlt\\n\\n                if 0 <= r_adj < row_n and \\\\\\n                   0 <= c_adj < col_n:\\n                    heappush(hpf, (n + v, grid[r_adj][c_adj], r_adj, c_adj))\\n\\n        return -1  # actually we don\\'t need this,\\n                   # because code will always reach the bottom-right corner\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849513,
                "title": "python-dijkstra-s-algo-optimized-with-0-1-bfs",
                "content": "Not sure why it\\'s tagged `HARD`. It\\'s just Dijkstra\\'s algo.\\n\\nThe same input example. Just added some text.\\n\\n![image](https://assets.leetcode.com/users/images/3b0d6073-3792-4dd8-963b-01be2ddc2462_1669450466.257272.png)\\n\\n**The story**\\nimagine that you have a maze with rooms. In order to enter a room you have to pay either 0 or 1 coins.\\nYour goal is to find the cheapest route from [0,0] to [ROWS - 1, COLS - 1].\\n\\nYou are located at room [0,0] and paid 0 coins. Entering room [ROWS - 1, COLS - 1] costs 0 coins.\\n\\n**DSA**\\nNow that we understand what we have and what we need let\\'s apply our knowledge.\\n\\nHow to represent the data that we have: room coordinates, cost, and price so far???\\nA room is [x,y], cost is either 0 or 1, and price is an integer.\\n\\nWhen you see that there is some connection between items and that connection has a property it should immediately trigger n\\u0336o\\u0336t\\u0336 \\u0336D\\u0336P\\u0336 that the data can be represented as **a graph**.\\n\\nSpecifically **a weighted graph**, where a vertex is a room with [x,y] coordinate and an edge - the cost [0 or 1] to enter the room.\\n\\n![image](https://assets.leetcode.com/users/images/a1fea158-3664-4ea3-a53c-887e5ee13aa1_1669451292.0073655.png)\\n\\n**The question** left to answer: how to find the cheapest way from node [0,0] to [ROWS - 1, COLS - 1]?\\n\\n**The answer**: [Dijkstra\\'s algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\\n*For a given source node in the graph, the algorithm finds the shortest path between that node and every other.\\u200A It can also be **used for finding the shortest paths from a single node to a single destination node** by stopping the algorithm once the shortest path to the destination node has been determined.*\\n\\n*For example, if the **nodes represent cities** and **edge path costs** represent driving distances between pairs of cities connected by a direct road (for simplicity, ignore red lights, stop signs, toll roads and other obstructions), Dijkstra\\'s algorithm can be used to find the shortest route between one city and all other cities.*\\n\\nBack to our problem:\\n\\nDijkstra uses heap to find the shortest path. Thus `O(E + VlogV)`\\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        dist = defaultdict(lambda: float(inf)) # price to get from [0,0] to [x,y]\\n        dist[(0,0)] = 0 # you start here. [0,0] your price arriving at [0,0] = 0\\n        \\n        heap = [(0,0,0)] # d,r,c. Min heap. Ordered by price to [r,c]\\n        \\n        while heap:\\n            d,r,c = heappop(heap)\\n            \\n            for dr,dc in [(0,1),(1,0),(-1,0),(0,-1)]:\\n                nr,nc = r+dr,c+dc # explore up,down,left,right\\n                if 0 <= nc < COLS and 0 <= nr < ROWS and d + grid[nr][nc] < dist[(nr,nc)]: # if found cheaper way to [nc,nr] -> update disctances (probably should be prices) and explore [nr,nc]\\n                    dist[(nr,nc)] = d + grid[nr][nc] # set dist[(nr,nc)] to a lower price\\n                    heappush(heap, (dist[(nr,nc)],nr,nc))\\n        \\n        return dist[(ROWS - 1, COLS - 1)]\\n```\\n\\n**How to optimize it???**\\nAs you can see we use only 2 coin values `0` or `1`.\\n\\nThere is a `0-1 BFS` algo .Why 0-1? Because this is like Dijkstra\\'s algo, but uses only 0 or 1 weights.\\nIf we do not need more than 0/1 values we can replace the heap `VlogV` with a `deque`.\\nDeque is used this way: if you need to place 0, you place it in front of the queue. if you need to add 1 - you add it to the end. Kind of custom heap with only 2 possible values 0 or 1 and thus we get O(1) for push/pop or `V` instead of `VlogV`. For `0-1 BFS` TC should be O(E+V).\\n\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        dist = defaultdict(lambda: float(inf))\\n        dist[(0,0)] = 0\\n        \\n        queue = deque([(0,0)])\\n        visited = set()\\n        \\n        while queue:\\n            r,c = queue.popleft()\\n            for dr,dc in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                nr,nc = r+dr,c+dc # ...\\n                if 0 <= nr < ROWS and 0 <= nc < COLS and (nr,nc) not in visited:\\n                    if dist[(r,c)] + grid[nr][nc] < dist[(nr,nc)]: # found better price?\\n                        dist[(nr,nc)] = dist[(r,c)] + grid[nr][nc]\\n                    \\n                    if grid[nr][nc] == 0: # if cost = 0 -> put in front of the queue\\n                        queue.appendleft((nr,nc))\\n                    else: # cost = 1, add to back\\n                        queue.append((nr,nc))\\n                        \\n                    visited.add((nr,nc))\\n        \\n        return dist[(ROWS - 1, COLS - 1)]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        dist = defaultdict(lambda: float(inf)) # price to get from [0,0] to [x,y]\\n        dist[(0,0)] = 0 # you start here. [0,0] your price arriving at [0,0] = 0\\n        \\n        heap = [(0,0,0)] # d,r,c. Min heap. Ordered by price to [r,c]\\n        \\n        while heap:\\n            d,r,c = heappop(heap)\\n            \\n            for dr,dc in [(0,1),(1,0),(-1,0),(0,-1)]:\\n                nr,nc = r+dr,c+dc # explore up,down,left,right\\n                if 0 <= nc < COLS and 0 <= nr < ROWS and d + grid[nr][nc] < dist[(nr,nc)]: # if found cheaper way to [nc,nr] -> update disctances (probably should be prices) and explore [nr,nc]\\n                    dist[(nr,nc)] = d + grid[nr][nc] # set dist[(nr,nc)] to a lower price\\n                    heappush(heap, (dist[(nr,nc)],nr,nc))\\n        \\n        return dist[(ROWS - 1, COLS - 1)]\\n```\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        \\n        dist = defaultdict(lambda: float(inf))\\n        dist[(0,0)] = 0\\n        \\n        queue = deque([(0,0)])\\n        visited = set()\\n        \\n        while queue:\\n            r,c = queue.popleft()\\n            for dr,dc in [(0,1),(0,-1),(1,0),(-1,0)]:\\n                nr,nc = r+dr,c+dc # ...\\n                if 0 <= nr < ROWS and 0 <= nc < COLS and (nr,nc) not in visited:\\n                    if dist[(r,c)] + grid[nr][nc] < dist[(nr,nc)]: # found better price?\\n                        dist[(nr,nc)] = dist[(r,c)] + grid[nr][nc]\\n                    \\n                    if grid[nr][nc] == 0: # if cost = 0 -> put in front of the queue\\n                        queue.appendleft((nr,nc))\\n                    else: # cost = 1, add to back\\n                        queue.append((nr,nc))\\n                        \\n                    visited.add((nr,nc))\\n        \\n        return dist[(ROWS - 1, COLS - 1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837300,
                "title": "bfs-dequeue",
                "content": "# Intuition\\nGet minumum distance bewteen node like 0 and 1 BFS travesal in tree to get level.\\n\\n# Approach\\nPush node which is 0 at front of queue and 1 at end of queue becuase all node with 0 have same distance or level so they can processed simulatniously in BFS traversal.\\n\\n# Complexity\\n- Time complexity:\\no m*n\\n\\n- Space complexity:\\no m*n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length , n=grid[0].length;\\n\\n        int[][] dist = new int[m][n];\\n        for(int[] x : dist){\\n            Arrays.fill(x,Integer.MAX_VALUE);\\n        }\\n        Deque<int[]> dq= new LinkedList<>();\\n        dq.offer(new int[]{0,0});\\n        dist[0][0] = grid[0][0] ;\\n\\n        int[][] dir= {{0,1},{0,-1},{1,0},{-1,0}};\\n\\n        while(!dq.isEmpty()){\\n            int[] curr= dq.pop();\\n            for(int[] x : dir){\\n                int nx =curr[0] + x[0];\\n                int ny = curr[1] + x[1];\\n                if(nx >=0 && nx < m && ny >=0 && ny < n){\\n                      if(dist[nx][ny] > dist[curr[0]][curr[1]]+grid[nx][ny]) {\\n                          dist[nx][ny] = dist[curr[0]][curr[1]]+grid[nx][ny];\\n                          if(grid[nx][ny] == 1)\\n                            dq.addLast(new int[]{nx,ny});\\n                          else  \\n                            dq.add(new int[]{nx,ny});\\n                      } \\n                }\\n            }\\n        }\\n\\n        return dist[m-1][n-1] ==Integer.MAX_VALUE ? -1 : dist[m-1][n-1] ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        int m=grid.length , n=grid[0].length;\\n\\n        int[][] dist = new int[m][n];\\n        for(int[] x : dist){\\n            Arrays.fill(x,Integer.MAX_VALUE);\\n        }\\n        Deque<int[]> dq= new LinkedList<>();\\n        dq.offer(new int[]{0,0});\\n        dist[0][0] = grid[0][0] ;\\n\\n        int[][] dir= {{0,1},{0,-1},{1,0},{-1,0}};\\n\\n        while(!dq.isEmpty()){\\n            int[] curr= dq.pop();\\n            for(int[] x : dir){\\n                int nx =curr[0] + x[0];\\n                int ny = curr[1] + x[1];\\n                if(nx >=0 && nx < m && ny >=0 && ny < n){\\n                      if(dist[nx][ny] > dist[curr[0]][curr[1]]+grid[nx][ny]) {\\n                          dist[nx][ny] = dist[curr[0]][curr[1]]+grid[nx][ny];\\n                          if(grid[nx][ny] == 1)\\n                            dq.addLast(new int[]{nx,ny});\\n                          else  \\n                            dq.add(new int[]{nx,ny});\\n                      } \\n                }\\n            }\\n        }\\n\\n        return dist[m-1][n-1] ==Integer.MAX_VALUE ? -1 : dist[m-1][n-1] ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834113,
                "title": "c-failed-bfs-binary-search",
                "content": "Now I see, this problem can also be modeled as the graph problem. Consider each cell as the node and there will be an between two nodes if they are adjacent, and cost of the edge would be `1` if in the edge (u, v) `v` or `u` cell is blocked. \\n\\nAnd we run dijkstra on the graph, and get the minimum cost. \\n\\n```cpp\\nclass Node {\\npublic:\\n    int x;\\n    int y;\\n    int k;\\n};\\n\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<int>> mat;\\n    bool isPossible(int K) {\\n        queue<Node> q;\\n        auto isValidCell = [&] (const int &a, const int &b) {\\n            return (a >= 0 && b >= 0 && a < n && b < m);\\n        };\\n        //start cell can also have the obstacle\\n        q.push({0, 0, mat[0][0] == 1});\\n        vector<vector<vector<bool>>> seen(n, vector<vector<bool>>(m, vector<bool>(K + 1, false))) ;\\n        seen[0][0][mat[0][0] == 1] = true;\\n        while(q.size() > 0) {\\n            int N = q.size();\\n            while (N--) {\\n                Node node = q.front();\\n                q.pop();\\n                if (node.x == n - 1 && node.y == m - 1 && node.k <= K) return true;\\n                int dir[] = {-1, 0, 1, 0, -1};\\n                for (int k = 0; k < 4; ++k) {\\n                    int cur_k = node.k;\\n                    int u = node.x + dir[k];\\n                    int v = node.y + dir[k + 1];\\n                    if (isValidCell(u, v)) {\\n                        if (mat[u][v]) ++cur_k;\\n                        if (cur_k <= K && !seen[u][v][cur_k]) {\\n                            q.push({u, v, cur_k});\\n                            seen[u][v][cur_k] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        mat = grid;\\n        n = grid.size();\\n        m = grid[0].size();\\n        int low = 0;\\n        int high = m + n;\\n        int ans = high;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (isPossible(mid)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Node {\\npublic:\\n    int x;\\n    int y;\\n    int k;\\n};\\n\\nclass Solution {\\npublic:\\n    int n;\\n    int m;\\n    vector<vector<int>> mat;\\n    bool isPossible(int K) {\\n        queue<Node> q;\\n        auto isValidCell = [&] (const int &a, const int &b) {\\n            return (a >= 0 && b >= 0 && a < n && b < m);\\n        };\\n        //start cell can also have the obstacle\\n        q.push({0, 0, mat[0][0] == 1});\\n        vector<vector<vector<bool>>> seen(n, vector<vector<bool>>(m, vector<bool>(K + 1, false))) ;\\n        seen[0][0][mat[0][0] == 1] = true;\\n        while(q.size() > 0) {\\n            int N = q.size();\\n            while (N--) {\\n                Node node = q.front();\\n                q.pop();\\n                if (node.x == n - 1 && node.y == m - 1 && node.k <= K) return true;\\n                int dir[] = {-1, 0, 1, 0, -1};\\n                for (int k = 0; k < 4; ++k) {\\n                    int cur_k = node.k;\\n                    int u = node.x + dir[k];\\n                    int v = node.y + dir[k + 1];\\n                    if (isValidCell(u, v)) {\\n                        if (mat[u][v]) ++cur_k;\\n                        if (cur_k <= K && !seen[u][v][cur_k]) {\\n                            q.push({u, v, cur_k});\\n                            seen[u][v][cur_k] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        mat = grid;\\n        n = grid.size();\\n        m = grid[0].size();\\n        int low = 0;\\n        int high = m + n;\\n        int ans = high;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if (isPossible(mid)) {\\n                ans = min(ans, mid);\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805432,
                "title": "python-dfs",
                "content": "```\\n\\tdef minimumObstacles(self, grid: List[List[int]]) -> int:\\n        # DFS with some extra properties??\\n        # Minimum number of obstacles removed...\\n        \\n        visited = set([(0,0)])\\n        q = deque([ [grid[0][0], [0,0]] ])\\n        \\n        while q:    \\n            v = q.popleft()\\n            x, y = v[1]\\n            if y == len(grid[0])-1 and x == len(grid)-1:\\n                return v[0]\\n            if x > 0:\\n                if (x-1, y) not in visited:\\n                    if grid[x-1][y]:\\n                        q.append([v[0]+1, [x-1, y]])\\n                    else:\\n                        q.appendleft([v[0], [x-1, y]])\\n                    visited.add((x-1, y))\\n            if y > 0:\\n                if (x, y-1) not in visited:\\n                    if grid[x][y-1]:\\n                        q.append([v[0]+1, [x, y-1]])\\n                    else:\\n                        q.appendleft([v[0], [x, y-1]])\\n                    visited.add((x, y-1))\\n                \\n            if x < len(grid)-1:\\n                if (x+1, y) not in visited:\\n                    if grid[x+1][y]:\\n                        q.append([v[0]+1, [x+1, y]])\\n                    else:\\n                        q.appendleft([v[0], [x+1, y]])\\n                    visited.add((x+1, y))\\n            \\n            if y < len(grid[0])-1:\\n                if (x, y+1) not in visited:\\n                    if grid[x][y+1]:\\n                        q.append([v[0]+1, [x, y+1]])\\n                    else:\\n                        q.appendleft([v[0], [x, y+1]])\\n                    visited.add((x, y+1))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef minimumObstacles(self, grid: List[List[int]]) -> int:\\n        # DFS with some extra properties??\\n        # Minimum number of obstacles removed...\\n        \\n        visited = set([(0,0)])\\n        q = deque([ [grid[0][0], [0,0]] ])\\n        \\n        while q:    \\n            v = q.popleft()\\n            x, y = v[1]\\n            if y == len(grid[0])-1 and x == len(grid)-1:\\n                return v[0]\\n            if x > 0:\\n                if (x-1, y) not in visited:\\n                    if grid[x-1][y]:\\n                        q.append([v[0]+1, [x-1, y]])\\n                    else:\\n                        q.appendleft([v[0], [x-1, y]])\\n                    visited.add((x-1, y))\\n            if y > 0:\\n                if (x, y-1) not in visited:\\n                    if grid[x][y-1]:\\n                        q.append([v[0]+1, [x, y-1]])\\n                    else:\\n                        q.appendleft([v[0], [x, y-1]])\\n                    visited.add((x, y-1))\\n                \\n            if x < len(grid)-1:\\n                if (x+1, y) not in visited:\\n                    if grid[x+1][y]:\\n                        q.append([v[0]+1, [x+1, y]])\\n                    else:\\n                        q.appendleft([v[0], [x+1, y]])\\n                    visited.add((x+1, y))\\n            \\n            if y < len(grid[0])-1:\\n                if (x, y+1) not in visited:\\n                    if grid[x][y+1]:\\n                        q.append([v[0]+1, [x, y+1]])\\n                    else:\\n                        q.appendleft([v[0], [x, y+1]])\\n                    visited.add((x, y+1))\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2762315,
                "title": "java-beat-25-dijsktra-template",
                "content": "```\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] distFromStart = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(distFromStart[i], -1);\\n        }\\n\\n        distFromStart[0][0] = grid[0][0];\\n        Queue<State> pq = new PriorityQueue<>((a, b) -> a.maxFromStart - b.maxFromStart);\\n        pq.offer(new State(0, 0, grid[0][0]));\\n\\n        while (!pq.isEmpty()) {\\n            //no matter which points, only check from start to which point is more close.\\n            State cur = pq.poll();\\n            int cx = cur.x, cy = cur.y, curFromStart = cur.maxFromStart;\\n            if (cx == m - 1 && cy == n - 1) return curFromStart;\\n\\n            for (int[] adj : getAdjs(grid, cx, cy, m, n)) {\\n                int nx = adj[0];\\n                int ny = adj[1];\\n\\n                int timeFromStart = distFromStart[cx][cy] + grid[nx][ny];\\n                //find the shorter time or deal with the initial reachable situation.\\n                if (timeFromStart < distFromStart[nx][ny] || distFromStart[nx][ny] == -1) {\\n                    distFromStart[nx][ny] = timeFromStart;\\n                    pq.offer(new State(nx, ny, timeFromStart));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    //!!! no need to build graph, only need to return 4 directions\\' adj nodes.\\n    List<int[]> getAdjs(int[][] g, int x, int y, int m, int n) {\\n        List<int[]> adjs = new ArrayList<>();\\n        for (int[] d : dirs) {\\n            int nx = x + d[0];\\n            int ny = y + d[1];\\n\\n            if (nx >= m || ny >= n || nx < 0 || ny < 0) {\\n                continue;\\n            }\\n            adjs.add(new int[]{nx, ny});\\n        }\\n        return adjs;\\n    }\\n\\n\\n    class State {\\n        int x, y;\\n        int maxFromStart;\\n\\n        State(int x, int y, int maxFromStart) {\\n            this.x = x;\\n            this.y = y;\\n            this.maxFromStart = maxFromStart;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] distFromStart = new int[m][n];\\n\\n        for (int i = 0; i < m; i++) {\\n            Arrays.fill(distFromStart[i], -1);\\n        }\\n\\n        distFromStart[0][0] = grid[0][0];\\n        Queue<State> pq = new PriorityQueue<>((a, b) -> a.maxFromStart - b.maxFromStart);\\n        pq.offer(new State(0, 0, grid[0][0]));\\n\\n        while (!pq.isEmpty()) {\\n            //no matter which points, only check from start to which point is more close.\\n            State cur = pq.poll();\\n            int cx = cur.x, cy = cur.y, curFromStart = cur.maxFromStart;\\n            if (cx == m - 1 && cy == n - 1) return curFromStart;\\n\\n            for (int[] adj : getAdjs(grid, cx, cy, m, n)) {\\n                int nx = adj[0];\\n                int ny = adj[1];\\n\\n                int timeFromStart = distFromStart[cx][cy] + grid[nx][ny];\\n                //find the shorter time or deal with the initial reachable situation.\\n                if (timeFromStart < distFromStart[nx][ny] || distFromStart[nx][ny] == -1) {\\n                    distFromStart[nx][ny] = timeFromStart;\\n                    pq.offer(new State(nx, ny, timeFromStart));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    //!!! no need to build graph, only need to return 4 directions\\' adj nodes.\\n    List<int[]> getAdjs(int[][] g, int x, int y, int m, int n) {\\n        List<int[]> adjs = new ArrayList<>();\\n        for (int[] d : dirs) {\\n            int nx = x + d[0];\\n            int ny = y + d[1];\\n\\n            if (nx >= m || ny >= n || nx < 0 || ny < 0) {\\n                continue;\\n            }\\n            adjs.add(new int[]{nx, ny});\\n        }\\n        return adjs;\\n    }\\n\\n\\n    class State {\\n        int x, y;\\n        int maxFromStart;\\n\\n        State(int x, int y, int maxFromStart) {\\n            this.x = x;\\n            this.y = y;\\n            this.maxFromStart = maxFromStart;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760115,
                "title": "java-99",
                "content": "```\\nclass Solution {\\n        public int minimumObstacles(int[][] A) {\\n            int m = A.length, n = A[0].length;\\n            Integer[][] visited = new Integer[m][n];\\n            int[][] dirs = new int[][] { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };\\n\\n            ArrayDeque<int[]> q = new ArrayDeque<>();\\n            q.offer(new int[] { 0, 0, 0 });\\n            visited[0][0] = A[0][0];\\n            int p[], r, c;\\n            while (!q.isEmpty()) {\\n                p = q.poll();\\n                if (p[0] == m-1 && p[1] == n-1)\\n                    return visited[m-1][n-1];\\n\\n                for (int[] dir : dirs) {\\n                    r = p[0] + dir[0];\\n                    c = p[1] + dir[1];\\n                    if (r < 0 || c < 0 || r >= m || c >= n || visited[r][c] != null)\\n                        continue;\\n\\n                    visited[r][c] = A[r][c] + visited[p[0]][p[1]];\\n                    if (A[r][c] == 1)\\n                        q.offer(new int[] { r, c });\\n                    else\\n                        q.offerFirst(new int[] { r, c });\\n                }\\n            }\\n\\n            return visited[m-1][n-1];\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public int minimumObstacles(int[][] A) {\\n            int m = A.length, n = A[0].length;\\n            Integer[][] visited = new Integer[m][n];\\n            int[][] dirs = new int[][] { {-1, 0}, {0, 1}, {1, 0}, {0, -1} };\\n\\n            ArrayDeque<int[]> q = new ArrayDeque<>();\\n            q.offer(new int[] { 0, 0, 0 });\\n            visited[0][0] = A[0][0];\\n            int p[], r, c;\\n            while (!q.isEmpty()) {\\n                p = q.poll();\\n                if (p[0] == m-1 && p[1] == n-1)\\n                    return visited[m-1][n-1];\\n\\n                for (int[] dir : dirs) {\\n                    r = p[0] + dir[0];\\n                    c = p[1] + dir[1];\\n                    if (r < 0 || c < 0 || r >= m || c >= n || visited[r][c] != null)\\n                        continue;\\n\\n                    visited[r][c] = A[r][c] + visited[p[0]][p[1]];\\n                    if (A[r][c] == 1)\\n                        q.offer(new int[] { r, c });\\n                    else\\n                        q.offerFirst(new int[] { r, c });\\n                }\\n            }\\n\\n            return visited[m-1][n-1];\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759748,
                "title": "c-two-approaches-dijkstra-s-0-1-bfs",
                "content": "\\t// Dijkstra\\'s\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumObstacles(vector<vector<int>>& grid) {\\n\\t\\t\\tint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \\n\\t\\t\\tint m = grid.size();\\n\\t\\t\\tint n = grid[0].size();\\n\\t\\t\\tvector<vector<int>> dist(m, vector<int>(n, INT_MAX));\\n\\t\\t\\tset<pair<int, pair<int,int>>> PQ;\\n\\t\\t\\tPQ.insert({0, {0, 0}});\\n\\t\\t\\tdist[0][0] = 0;\\n\\t\\t\\twhile(!PQ.empty()) {\\n\\t\\t\\t\\tpair<int, pair<int,int>> curr = *PQ.begin();\\n\\t\\t\\t\\tPQ.erase(PQ.begin());\\n\\t\\t\\t\\tint ux = curr.second.first;\\n\\t\\t\\t\\tint uy = curr.second.second;\\n\\n\\t\\t\\t\\tfor(auto dir: dirs) {\\n\\t\\t\\t\\t\\tint vx = ux + dir[0];\\n\\t\\t\\t\\t\\tint vy = uy + dir[1];\\n\\n\\t\\t\\t\\t\\tif(vx < 0 || vy < 0 || vx >= m || vy >= n) \\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\tint cost = dist[ux][uy] + grid[vx][vy];\\n\\n\\t\\t\\t\\t\\tif(cost < dist[vx][vy]) {\\n\\t\\t\\t\\t\\t\\tauto iter = PQ.find({dist[vx][vy], {vx, vy}});\\n\\t\\t\\t\\t\\t\\tif(iter != PQ.end())\\n\\t\\t\\t\\t\\t\\t\\tPQ.erase(iter);\\n\\t\\t\\t\\t\\t\\tdist[vx][vy] = cost;\\n\\t\\t\\t\\t\\t\\tPQ.insert({dist[vx][vy], {vx, vy}});\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dist[m - 1][n - 1];\\n\\t\\t}\\n\\t};\\n\\t\\n\\t// 0-1 BFS - Better Approach\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minimumObstacles(vector<vector<int>>& grid) {\\n\\t\\t\\tint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \\n\\t\\t\\tint m = grid.size();\\n\\t\\t\\tint n = grid[0].size();\\n\\t\\t\\tvector<vector<bool>> visited(m, vector<bool>(n));\\n\\t\\t\\tvector<vector<int>> dist(m, vector<int>(n, INT_MAX));\\n\\t\\t\\tdeque<pair<int, int>> PQ;\\n\\t\\t\\tPQ.push_back({0, 0});\\n\\t\\t\\tvisited[0][0] = true;\\n\\t\\t\\tdist[0][0] = 0;\\n\\n\\t\\t\\twhile(!PQ.empty()) {\\n\\t\\t\\t\\tpair<int, int> curr = PQ.front();\\n\\t\\t\\t\\tPQ.pop_front();\\n\\n\\t\\t\\t\\tint ux = curr.first;\\n\\t\\t\\t\\tint uy = curr.second;\\n\\n\\t\\t\\t\\tfor(auto dir: dirs) {\\n\\t\\t\\t\\t\\tint vx = ux + dir[0];\\n\\t\\t\\t\\t\\tint vy = uy + dir[1];\\n\\n\\t\\t\\t\\t\\tif(vx < 0 || vy < 0 || vx >= m || vy >= n) \\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\tif(!visited[vx][vy]) {\\n\\t\\t\\t\\t\\t\\tvisited[vx][vy] = true;\\n\\n\\t\\t\\t\\t\\t\\tdist[vx][vy] = dist[ux][uy] + grid[vx][vy];\\n\\t\\t\\t\\t\\t\\tif(grid[vx][vy])\\n\\t\\t\\t\\t\\t\\t\\tPQ.push_back({vx, vy});\\n\\t\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t\\t\\tPQ.push_front({vx, vy});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dist[m - 1][n - 1];\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minimumObstacles(vector<vector<int>>& grid) {\\n\\t\\t\\tint dirs[4][2] = {{-1, 0}",
                "codeTag": "Java"
            },
            {
                "id": 2759408,
                "title": "java-solution-using-dijkstras",
                "content": "```\\nclass Solution {\\n   private static final int[][] directions = {{0,1},{0,-1}, {1,0},{-1,0}};\\n    private int[][] dist = null;\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        dist = new int[m][n];\\n\\n        for (int[] disArray : dist) {\\n            Arrays.fill(disArray, Integer.MAX_VALUE);\\n        }\\n\\n        dist[0][0] = grid[0][0];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[2] - b[2]));\\n        // X, Y, Distance\\n        pq.offer(new int[]{ 0,  0, dist[0][0]});\\n\\n        while (!pq.isEmpty()) {\\n\\n            int[] cur = pq.poll();\\n\\n            int x = cur[0];\\n            int y = cur[1];\\n            int currCost = cur[2];\\n            //if we reached to destination then return cost\\n            if (x == m - 1 && y == n - 1) {\\n                return currCost;\\n            }\\n            //finding all valid routes and adding shortest path in queue\\n            for (int[] dir : directions) { \\n                int nextX = x + dir[0];\\n                int nextY = y + dir[1];\\n                if (nextX >=0 && nextX<m && nextY >=0 && nextY<n && currCost + grid[nextX][nextY] < dist[nextX][nextY]) {\\n                    dist[nextX][nextY] = currCost + grid[nextX][nextY];\\n                    pq.offer(new int[]{nextX, nextY,dist[nextX][nextY]});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   private static final int[][] directions = {{0,1},{0,-1}, {1,0},{-1,0}};\\n    private int[][] dist = null;\\n    public int minimumObstacles(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        dist = new int[m][n];\\n\\n        for (int[] disArray : dist) {\\n            Arrays.fill(disArray, Integer.MAX_VALUE);\\n        }\\n\\n        dist[0][0] = grid[0][0];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> (a[2] - b[2]));\\n        // X, Y, Distance\\n        pq.offer(new int[]{ 0,  0, dist[0][0]});\\n\\n        while (!pq.isEmpty()) {\\n\\n            int[] cur = pq.poll();\\n\\n            int x = cur[0];\\n            int y = cur[1];\\n            int currCost = cur[2];\\n            //if we reached to destination then return cost\\n            if (x == m - 1 && y == n - 1) {\\n                return currCost;\\n            }\\n            //finding all valid routes and adding shortest path in queue\\n            for (int[] dir : directions) { \\n                int nextX = x + dir[0];\\n                int nextY = y + dir[1];\\n                if (nextX >=0 && nextX<m && nextY >=0 && nextY<n && currCost + grid[nextX][nextY] < dist[nextX][nextY]) {\\n                    dist[nextX][nextY] = currCost + grid[nextX][nextY];\\n                    pq.offer(new int[]{nextX, nextY,dist[nextX][nextY]});\\n                }\\n            }\\n        }\\n        return dist[m - 1][n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759360,
                "title": "python-modified-bfs",
                "content": "\\tclass Solution:\\n\\t\\tdef minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t\\n\\t\\t\\tdirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t\\tque = deque([(0, 0, 0)])\\n\\t\\t\\tobs = [[-1] * len(grid[0]) for _ in range(len(grid))]\\n\\t\\t\\tobs[0][0] = 0\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\tx, y, cur_obs = que.popleft()\\n\\t\\t\\t\\tfor i in directions:\\n\\t\\t\\t\\t\\tn_x = x + i[0]\\n\\t\\t\\t\\t\\tn_y = y + i[1]\\n\\t\\t\\t\\t\\tif  0 <= n_x < len(grid) and 0 <= n_y < len(grid[0]) and obs[n_x][n_y] == -1:\\n\\t\\t\\t\\t\\t\\tif grid[n_x][n_y] == 1:\\n\\t\\t\\t\\t\\t\\t\\tobs[n_x][n_y] = cur_obs + 1\\n\\t\\t\\t\\t\\t\\t\\tque.append((n_x, n_y, cur_obs+1))\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tobs[n_x][n_y] = cur_obs\\n\\t\\t\\t\\t\\t\\t\\tque.appendleft((n_x, n_y, cur_obs))    \\n\\t\\t\\treturn obs[-1][-1]\\n\\t\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minimumObstacles(self, grid: List[List[int]]) -> int:\\n\\t\\t\\t\\n\\t\\t\\tdirections = [(0, 1), (0, -1), (1, 0), (-1, 0)]\\n\\t\\t\\tque = deque([(0, 0, 0)])\\n\\t\\t\\tobs = [[-1] * len(grid[0]) for _ in range(len(grid))]\\n\\t\\t\\tobs[0][0] = 0\\n\\t\\t\\t\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\tx, y, cur_obs = que.popleft()\\n\\t\\t\\t\\tfor i in directions:\\n\\t\\t\\t\\t\\tn_x = x + i[0]\\n\\t\\t\\t\\t\\tn_y = y + i[1]\\n\\t\\t\\t\\t\\tif  0 <= n_x < len(grid) and 0 <= n_y < len(grid[0]) and obs[n_x][n_y] == -1:\\n\\t\\t\\t\\t\\t\\tif grid[n_x][n_y] == 1:\\n\\t\\t\\t\\t\\t\\t\\tobs[n_x][n_y] = cur_obs + 1\\n\\t\\t\\t\\t\\t\\t\\tque.append((n_x, n_y, cur_obs+1))\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tobs[n_x][n_y] = cur_obs\\n\\t\\t\\t\\t\\t\\t\\tque.appendleft((n_x, n_y, cur_obs))    \\n\\t\\t\\treturn obs[-1][-1]\\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2759214,
                "title": "bfs-min-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        \\n        \\n        int r =  grid.length;\\n        int c = grid[0].length;\\n        \\n        boolean [][] visited = new boolean[r][c];\\n        \\n        //keep the min obstracle priority queue\\n        Queue< int [] > q = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n        \\n        //priority queue contains i, j, and minimul obstracle till i, j\\n        \\n        q.add(new int[]{0,0,grid[0][0]});\\n        \\n        int [][] dir = {{1,0},{-1,0}, {0, 1},{0, -1}};\\n        \\n        visited[0][0] = true;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int [] p = q.poll();\\n            \\n            \\n            //reached destination return min number of obstracle \\n            if(p[0] == r -1 && p[1] == c-1){\\n                return p[2];\\n            }\\n            \\n            for( int [] d : dir){\\n                \\n                int newi = d[0] + p[0];\\n                int newj = d[1] + p[1];\\n                \\n                if(newi < 0 || newi > r-1 || newj < 0 || newj > c-1 || visited[newi][newj]) continue;\\n                \\n                q.add(new int[]{newi,newj,p[2] + grid[newi][newj]});\\n                \\n                visited[newi][newj] = true;\\n                \\n            }\\n            \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumObstacles(int[][] grid) {\\n        \\n        \\n        int r =  grid.length;\\n        int c = grid[0].length;\\n        \\n        boolean [][] visited = new boolean[r][c];\\n        \\n        //keep the min obstracle priority queue\\n        Queue< int [] > q = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n        \\n        //priority queue contains i, j, and minimul obstracle till i, j\\n        \\n        q.add(new int[]{0,0,grid[0][0]});\\n        \\n        int [][] dir = {{1,0},{-1,0}, {0, 1},{0, -1}};\\n        \\n        visited[0][0] = true;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int [] p = q.poll();\\n            \\n            \\n            //reached destination return min number of obstracle \\n            if(p[0] == r -1 && p[1] == c-1){\\n                return p[2];\\n            }\\n            \\n            for( int [] d : dir){\\n                \\n                int newi = d[0] + p[0];\\n                int newj = d[1] + p[1];\\n                \\n                if(newi < 0 || newi > r-1 || newj < 0 || newj > c-1 || visited[newi][newj]) continue;\\n                \\n                q.add(new int[]{newi,newj,p[2] + grid[newi][newj]});\\n                \\n                visited[newi][newj] = true;\\n                \\n            }\\n            \\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757806,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\n  struct cmp {\\n    bool operator()(const std::tuple<int, int, int> &a,\\n                    const std::tuple<int, int, int> &b) const {\\n        return std::get<2>(a) > std::get<2>(b);\\n    } \\n  };\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        unordered_map<int, int> seen;\\n\\t\\t// min priority_queue\\n        std::priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, std::greater<>> q;\\n        q.push(make_tuple(0,0,0));\\n        int x, y, b, m = grid.size(), n = grid[0].size(),\\n        d[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n        const std::string del=\":\";\\n        int ans = 999999;\\n        seen[0] = 0;\\n        while (q.empty()==false) {\\n            tie(b,x, y) = q.top(); q.pop();\\n            if ((x == m-1) && (y == n-1)) {\\n                if (ans > b) {\\n                    ans = b;\\n                }\\n                continue;\\n            }\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + d[i][0], ny= y + d[i][1];\\n                if ((nx<0)||(ny<0)||(nx>=m)||(ny>=n)) continue;\\n                auto it = seen.find((nx*n)+ny);\\n                if (grid[nx][ny]==1) {\\n                    if ((it == seen.end()) ||\\n                        (it->second > b+1)) {\\n                        seen[(nx*n)+ny]=b+1;\\n                        q.push(make_tuple(b+1,nx, ny));\\n                    }\\n                } else {\\n                    if ((it == seen.end())||(it->second > b)) {\\n                        seen[(nx*n)+ny]=b;\\n                        q.push(make_tuple(b, nx, ny));\\n                    }                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  struct cmp {\\n    bool operator()(const std::tuple<int, int, int> &a,\\n                    const std::tuple<int, int, int> &b) const {\\n        return std::get<2>(a) > std::get<2>(b);\\n    } \\n  };\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        unordered_map<int, int> seen;\\n\\t\\t// min priority_queue\\n        std::priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, std::greater<>> q;\\n        q.push(make_tuple(0,0,0));\\n        int x, y, b, m = grid.size(), n = grid[0].size(),\\n        d[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n        const std::string del=\":\";\\n        int ans = 999999;\\n        seen[0] = 0;\\n        while (q.empty()==false) {\\n            tie(b,x, y) = q.top(); q.pop();\\n            if ((x == m-1) && (y == n-1)) {\\n                if (ans > b) {\\n                    ans = b;\\n                }\\n                continue;\\n            }\\n            for (int i = 0; i < 4; i++) {\\n                int nx = x + d[i][0], ny= y + d[i][1];\\n                if ((nx<0)||(ny<0)||(nx>=m)||(ny>=n)) continue;\\n                auto it = seen.find((nx*n)+ny);\\n                if (grid[nx][ny]==1) {\\n                    if ((it == seen.end()) ||\\n                        (it->second > b+1)) {\\n                        seen[(nx*n)+ny]=b+1;\\n                        q.push(make_tuple(b+1,nx, ny));\\n                    }\\n                } else {\\n                    if ((it == seen.end())||(it->second > b)) {\\n                        seen[(nx*n)+ny]=b;\\n                        q.push(make_tuple(b, nx, ny));\\n                    }                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735178,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nint dx[] = {1,-1,0,0};\\nint dy[] = {0,0,1,-1};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>> q;\\n        q.push_front({0,0});\\n        dp[0][0] = 0;\\n        while(q.size()) {\\n            pair<int,int> p = q.front();\\n            q.pop_front();\\n            int cx = p.first;\\n            int cy = p.second;\\n            for(int i=0;i<4;i++) {\\n                int tx = cx + dx[i];\\n                int ty = cy + dy[i];\\n                if(tx >=0 && tx < m && ty >=0 && ty < n) {                    \\n                    if(!vis[tx][ty]) {\\n                        dp[tx][ty] = dp[cx][cy] + (grid[tx][ty] == 1);\\n                        if(grid[tx][ty] == 1) {\\n                            q.push_back({tx,ty});\\n                        } else {\\n                            q.push_front({tx,ty});\\n                        }\\n                        vis[tx][ty] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint dx[] = {1,-1,0,0};\\nint dy[] = {0,0,1,-1};\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> dp(m, vector<int>(n,INT_MAX));\\n        vector<vector<bool>> vis(m, vector<bool>(n,0));\\n        deque<pair<int,int>> q;\\n        q.push_front({0,0});\\n        dp[0][0] = 0;\\n        while(q.size()) {\\n            pair<int,int> p = q.front();\\n            q.pop_front();\\n            int cx = p.first;\\n            int cy = p.second;\\n            for(int i=0;i<4;i++) {\\n                int tx = cx + dx[i];\\n                int ty = cy + dy[i];\\n                if(tx >=0 && tx < m && ty >=0 && ty < n) {                    \\n                    if(!vis[tx][ty]) {\\n                        dp[tx][ty] = dp[cx][cy] + (grid[tx][ty] == 1);\\n                        if(grid[tx][ty] == 1) {\\n                            q.push_back({tx,ty});\\n                        } else {\\n                            q.push_front({tx,ty});\\n                        }\\n                        vis[tx][ty] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return dp[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685403,
                "title": "c-djikstra-s-ez",
                "content": "```\\n#define triple tuple<int,int,int>\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<triple,vector<triple>,greater<>> pq;\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n        pq.push({grid[0][0],0,0});\\n        int dirs[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\\n        while(!pq.empty()) {\\n            auto [c,i,j] = pq.top();\\n            pq.pop();\\n            if(i==n-1 and j==m-1) return c;\\n            for(int k=0; k<4; k++) {\\n                int nx = i+dirs[k][0];\\n                int ny = j+dirs[k][1];\\n                if(nx>=0 and nx<n and ny>=0 and ny<m and grid[nx][ny]+c < dp[nx][ny]) {\\n                    pq.push({grid[nx][ny]+c,nx,ny});\\n                    dp[nx][ny]=grid[nx][ny]+c;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define triple tuple<int,int,int>\\nclass Solution {\\npublic:\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        priority_queue<triple,vector<triple>,greater<>> pq;\\n        int n=grid.size(),m=grid[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,INT_MAX));\\n        pq.push({grid[0][0],0,0});\\n        int dirs[4][2]={{0,1},{0,-1},{1,0},{-1,0}};\\n        while(!pq.empty()) {\\n            auto [c,i,j] = pq.top();\\n            pq.pop();\\n            if(i==n-1 and j==m-1) return c;\\n            for(int k=0; k<4; k++) {\\n                int nx = i+dirs[k][0];\\n                int ny = j+dirs[k][1];\\n                if(nx>=0 and nx<n and ny>=0 and ny<m and grid[nx][ny]+c < dp[nx][ny]) {\\n                    pq.push({grid[nx][ny]+c,nx,ny});\\n                    dp[nx][ny]=grid[nx][ny]+c;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674456,
                "title": "c-0-1-bfs",
                "content": "reuse grid to store the min distance, and visit status. store a nagtive number x = -dis -1\\n```\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int n=grid.size(), m = grid[0].size();\\n        const vector<pair<int,int>> dirs = {{0,1}, {0, -1}, {1, 0}, {-1,0}};\\n        deque<tuple<int,int,int>> q; //-dis, i, j\\n        q.emplace_back(grid[0][0] = -1,0,0);\\n        while(!q.empty()){\\n            auto [dis, i, j] = q.front(); q.pop_front();            \\n            if(i == n-1 && j == m-1) return -dis-1; \\n            for(auto [di, dj] : dirs){\\n                int x = i+di, y = j+dj;\\n                if(x<0 || x>=n || y<0 || y>=m || grid[x][y] < 0) continue;\\n                int dis2 = dis - grid[x][y];\\n                if(dis2 == dis) q.emplace_front(dis2, x, y);\\n                else q.emplace_back(dis2, x, y);           \\n                grid[x][y] = dis2;\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "reuse grid to store the min distance, and visit status. store a nagtive number x = -dis -1\\n```\\n    int minimumObstacles(vector<vector<int>>& grid) {\\n        const int n=grid.size(), m = grid[0].size();\\n        const vector<pair<int,int>> dirs = {{0,1}, {0, -1}, {1, 0}, {-1,0}};\\n        deque<tuple<int,int,int>> q; //-dis, i, j\\n        q.emplace_back(grid[0][0] = -1,0,0);\\n        while(!q.empty()){\\n            auto [dis, i, j] = q.front(); q.pop_front();            \\n            if(i == n-1 && j == m-1) return -dis-1; \\n            for(auto [di, dj] : dirs){\\n                int x = i+di, y = j+dj;\\n                if(x<0 || x>=n || y<0 || y>=m || grid[x][y] < 0) continue;\\n                int dis2 = dis - grid[x][y];\\n                if(dis2 == dis) q.emplace_front(dis2, x, y);\\n                else q.emplace_back(dis2, x, y);           \\n                grid[x][y] = dis2;\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1976557,
                "content": [
                    {
                        "username": "Saiteja6",
                        "content": "all 54 test cases were executed successfully but still giving tle any suggestions to avoid this"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "What is the problem in this approach ,it is giving TLE  for large input\\n\\n if(r==grid.length-1 && c==grid[0].length-1){\\n            ans=Math.min(ans,obs);\\n            return;\\n        }\\n        vis[r][c]=true;\\n        if(grid[r][c]==1){\\n            solve(r-1,c,vis,grid,obs+1);\\n            solve(r+1,c,vis,grid,obs+1);\\n            solve(r,c-1,vis,grid,obs+1);\\n            solve(r,c+1,vis,grid,obs+1);\\n        }\\n        else{\\n             solve(r-1,c,vis,grid,obs);\\n            solve(r+1,c,vis,grid,obs);\\n            solve(r,c-1,vis,grid,obs);\\n            solve(r,c+1,vis,grid,obs);\\n        }\\n        vis[r][c]=false;"
                    },
                    {
                        "username": "navneetjain",
                        "content": "This looks like a DFS approach. We dont have to traverse every path but instead we should traverse path with current minimum obstacle. So, it should be modified dijkstra shortest path"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I think you forgot to put the condition that if you are at the a particular cell than that cell is previously traversed or not."
                    },
                    {
                        "username": "layyy",
                        "content": "similar question as path with minimum effort"
                    },
                    {
                        "username": "Ansh_5",
                        "content": "Shouldn\\'t be marked as hard. Simple Dijkstra algorithm."
                    }
                ]
            },
            {
                "id": 1654854,
                "content": [
                    {
                        "username": "Saiteja6",
                        "content": "all 54 test cases were executed successfully but still giving tle any suggestions to avoid this"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "What is the problem in this approach ,it is giving TLE  for large input\\n\\n if(r==grid.length-1 && c==grid[0].length-1){\\n            ans=Math.min(ans,obs);\\n            return;\\n        }\\n        vis[r][c]=true;\\n        if(grid[r][c]==1){\\n            solve(r-1,c,vis,grid,obs+1);\\n            solve(r+1,c,vis,grid,obs+1);\\n            solve(r,c-1,vis,grid,obs+1);\\n            solve(r,c+1,vis,grid,obs+1);\\n        }\\n        else{\\n             solve(r-1,c,vis,grid,obs);\\n            solve(r+1,c,vis,grid,obs);\\n            solve(r,c-1,vis,grid,obs);\\n            solve(r,c+1,vis,grid,obs);\\n        }\\n        vis[r][c]=false;"
                    },
                    {
                        "username": "navneetjain",
                        "content": "This looks like a DFS approach. We dont have to traverse every path but instead we should traverse path with current minimum obstacle. So, it should be modified dijkstra shortest path"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I think you forgot to put the condition that if you are at the a particular cell than that cell is previously traversed or not."
                    },
                    {
                        "username": "layyy",
                        "content": "similar question as path with minimum effort"
                    },
                    {
                        "username": "Ansh_5",
                        "content": "Shouldn\\'t be marked as hard. Simple Dijkstra algorithm."
                    }
                ]
            },
            {
                "id": 2071886,
                "content": [
                    {
                        "username": "Saiteja6",
                        "content": "all 54 test cases were executed successfully but still giving tle any suggestions to avoid this"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "What is the problem in this approach ,it is giving TLE  for large input\\n\\n if(r==grid.length-1 && c==grid[0].length-1){\\n            ans=Math.min(ans,obs);\\n            return;\\n        }\\n        vis[r][c]=true;\\n        if(grid[r][c]==1){\\n            solve(r-1,c,vis,grid,obs+1);\\n            solve(r+1,c,vis,grid,obs+1);\\n            solve(r,c-1,vis,grid,obs+1);\\n            solve(r,c+1,vis,grid,obs+1);\\n        }\\n        else{\\n             solve(r-1,c,vis,grid,obs);\\n            solve(r+1,c,vis,grid,obs);\\n            solve(r,c-1,vis,grid,obs);\\n            solve(r,c+1,vis,grid,obs);\\n        }\\n        vis[r][c]=false;"
                    },
                    {
                        "username": "navneetjain",
                        "content": "This looks like a DFS approach. We dont have to traverse every path but instead we should traverse path with current minimum obstacle. So, it should be modified dijkstra shortest path"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I think you forgot to put the condition that if you are at the a particular cell than that cell is previously traversed or not."
                    },
                    {
                        "username": "layyy",
                        "content": "similar question as path with minimum effort"
                    },
                    {
                        "username": "Ansh_5",
                        "content": "Shouldn\\'t be marked as hard. Simple Dijkstra algorithm."
                    }
                ]
            },
            {
                "id": 2056447,
                "content": [
                    {
                        "username": "Saiteja6",
                        "content": "all 54 test cases were executed successfully but still giving tle any suggestions to avoid this"
                    },
                    {
                        "username": "shivanshnema_04",
                        "content": "What is the problem in this approach ,it is giving TLE  for large input\\n\\n if(r==grid.length-1 && c==grid[0].length-1){\\n            ans=Math.min(ans,obs);\\n            return;\\n        }\\n        vis[r][c]=true;\\n        if(grid[r][c]==1){\\n            solve(r-1,c,vis,grid,obs+1);\\n            solve(r+1,c,vis,grid,obs+1);\\n            solve(r,c-1,vis,grid,obs+1);\\n            solve(r,c+1,vis,grid,obs+1);\\n        }\\n        else{\\n             solve(r-1,c,vis,grid,obs);\\n            solve(r+1,c,vis,grid,obs);\\n            solve(r,c-1,vis,grid,obs);\\n            solve(r,c+1,vis,grid,obs);\\n        }\\n        vis[r][c]=false;"
                    },
                    {
                        "username": "navneetjain",
                        "content": "This looks like a DFS approach. We dont have to traverse every path but instead we should traverse path with current minimum obstacle. So, it should be modified dijkstra shortest path"
                    },
                    {
                        "username": "nikhil97agra",
                        "content": "I think you forgot to put the condition that if you are at the a particular cell than that cell is previously traversed or not."
                    },
                    {
                        "username": "layyy",
                        "content": "similar question as path with minimum effort"
                    },
                    {
                        "username": "Ansh_5",
                        "content": "Shouldn\\'t be marked as hard. Simple Dijkstra algorithm."
                    }
                ]
            }
        ]
    },
    {
        "title": "Naming a Company",
        "question_content": "<p>You are given an array of strings <code>ideas</code> that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:</p>\n\n<ol>\n\t<li>Choose 2 <strong>distinct</strong> names from <code>ideas</code>, call them <code>idea<sub>A</sub></code> and <code>idea<sub>B</sub></code>.</li>\n\t<li>Swap the first letters of <code>idea<sub>A</sub></code> and <code>idea<sub>B</sub></code> with each other.</li>\n\t<li>If <strong>both</strong> of the new names are not found in the original <code>ideas</code>, then the name <code>idea<sub>A</sub> idea<sub>B</sub></code> (the <strong>concatenation</strong> of <code>idea<sub>A</sub></code> and <code>idea<sub>B</sub></code>, separated by a space) is a valid company name.</li>\n\t<li>Otherwise, it is not a valid name.</li>\n</ol>\n\n<p>Return <em>the number of <strong>distinct</strong> valid names for the company</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> ideas = [&quot;coffee&quot;,&quot;donuts&quot;,&quot;time&quot;,&quot;toffee&quot;]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The following selections are valid:\n- (&quot;coffee&quot;, &quot;donuts&quot;): The company name created is &quot;doffee conuts&quot;.\n- (&quot;donuts&quot;, &quot;coffee&quot;): The company name created is &quot;conuts doffee&quot;.\n- (&quot;donuts&quot;, &quot;time&quot;): The company name created is &quot;tonuts dime&quot;.\n- (&quot;donuts&quot;, &quot;toffee&quot;): The company name created is &quot;tonuts doffee&quot;.\n- (&quot;time&quot;, &quot;donuts&quot;): The company name created is &quot;dime tonuts&quot;.\n- (&quot;toffee&quot;, &quot;donuts&quot;): The company name created is &quot;doffee tonuts&quot;.\nTherefore, there are a total of 6 distinct company names.\n\nThe following are some examples of invalid selections:\n- (&quot;coffee&quot;, &quot;time&quot;): The name &quot;toffee&quot; formed after swapping already exists in the original array.\n- (&quot;time&quot;, &quot;toffee&quot;): Both names are still the same after swapping and exist in the original array.\n- (&quot;coffee&quot;, &quot;toffee&quot;): Both names formed after swapping already exist in the original array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ideas = [&quot;lack&quot;,&quot;back&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no valid selections. Therefore, 0 is returned.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= ideas.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= ideas[i].length &lt;= 10</code></li>\n\t<li><code>ideas[i]</code> consists of lowercase English letters.</li>\n\t<li>All the strings in <code>ideas</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2141038,
                "title": "python-explanation-with-pictures-group",
                "content": "Group strings from `ideas` into different sets by their initials. \\nFor example: \\n- set c = {\"offee\", \"hord\", \"ome\", ...}\\n- set b = {\"offee\", \"ee\", \"uffalo\", ...}\\n\\n![image](https://assets.leetcode.com/users/images/c4304736-aa77-479a-98fc-7d9285fbfdc7_1655009463.6922119.png)\\n\\n\\nFor two words `A = a + suffix_a, B = b + suffix_b` with different initials `a, b`, if the suffix of `A (suffix_a)` appears in both sets, they can\\'t form a valid name. Thus we just need to find out the number of unique suffix from `set A` and `set B` .\\n\\n- \"offee\" appears in both sets thus it can\\'t form a valid name.\\n- \"hord\", \"ome\", \"ee\" and \"uffalo\" are unique suffixes. \\n \\n\"\"hord\" with \"ee\", \"hord\" with \"uffalo\", \"ome\" with \"ee\", \"ome\" with \"uffalo\", thus we can make a total of `2 * 2` valid names. Consider we can change the order to double the valid words, multiply the answer by `2`.\\n\\n![image](https://assets.leetcode.com/users/images/0560ca4d-3688-4026-9b0e-e7705616e96b_1655006487.4373498.png)\\n\\n\\n```\\ndef distinctNames(self, ideas: List[str]) -> int:\\n        # Group strings by their initials\\n        A = [set() for _ in range(26)]\\n        for idea in ideas:\\n            A[ord(idea[0]) - ord(\\'a\\')].add(idea[1:])\\n        \\n        ans = 0\\n        # Calculate number of valid names from every initial pair.\\n        for i in range(25):\\n            for j in range(i + 1, 26):\\n                k = len(A[i] & A[j]) # Number of duplicated suffixes\\n                ans += 2 * (len(A[i]) - k) * (len(A[j]) - k)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef distinctNames(self, ideas: List[str]) -> int:\\n        # Group strings by their initials\\n        A = [set() for _ in range(26)]\\n        for idea in ideas:\\n            A[ord(idea[0]) - ord(\\'a\\')].add(idea[1:])\\n        \\n        ans = 0\\n        # Calculate number of valid names from every initial pair.\\n        for i in range(25):\\n            for j in range(i + 1, 26):\\n                k = len(A[i] & A[j]) # Number of duplicated suffixes\\n                ans += 2 * (len(A[i]) - k) * (len(A[j]) - k)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2141172,
                "title": "java-c-python-group-by-first-letter",
                "content": "# **Explanation**\\nAny `idea = first letter + postfix string`.\\nWe can group all ideas by their first letter.\\n\\nIf two ideas `ideas[i]` and `ideas[j]` share a common postfix string,\\nthen `ideas[i]` can not pair with any idea starts with `ideas[j][0]`\\nand  `ideas[j]` can not pair with any idea starts with `ideas[i][0]`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long distinctNames(String[] ideas) {\\n        HashSet<Integer>[] count = new HashSet[26];\\n        for (int i = 0; i < 26; ++i)\\n            count[i] = new HashSet<>();\\n        for (String s : ideas)\\n            count[s.charAt(0) - \\'a\\'].add(s.substring(1).hashCode());\\n        long res = 0;\\n        for (int i = 0; i < 26; ++i)\\n            for (int j = i + 1; j < 26; ++j) {\\n                long c1 = 0, c2 = 0;\\n                for (int c : count[i])\\n                    if (!count[j].contains(c)) c1++;\\n                for (int c : count[j])\\n                    if (!count[i].contains(c)) c2++;\\n                res += c1 * c2;\\n            }\\n        return res * 2;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> count[26];\\n        for (auto& s: ideas)\\n            count[s[0] - \\'a\\'].insert(s.substr(1));\\n        long long res = 0;\\n        for(int i = 0; i < 26; ++i)\\n            for(int j = i + 1; j < 26; ++j) {   \\n                long long c1 = 0L, c2 = 0L;\\n                for (auto& c: count[i])\\n                    if (!count[j].count(c)) c1++;\\n                for (auto& c: count[j])\\n                    if (!count[i].count(c)) c2++;\\n                res += c1 * c2;\\n            }\\n        return res * 2;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def distinctNames(self, ideas):\\n        count = defaultdict(set)\\n        for a in ideas:\\n            count[a[0]].add(hash(a[1:]))\\n        res = 0\\n        for a, seta in count.items():\\n            for b, setb in count.items():\\n                if a >= b: continue\\n                same = len(seta & setb)\\n                res += (len(seta) - same) * (len(setb) - same)\\n        return res * 2\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long distinctNames(String[] ideas) {\\n        HashSet<Integer>[] count = new HashSet[26];\\n        for (int i = 0; i < 26; ++i)\\n            count[i] = new HashSet<>();\\n        for (String s : ideas)\\n            count[s.charAt(0) - \\'a\\'].add(s.substring(1).hashCode());\\n        long res = 0;\\n        for (int i = 0; i < 26; ++i)\\n            for (int j = i + 1; j < 26; ++j) {\\n                long c1 = 0, c2 = 0;\\n                for (int c : count[i])\\n                    if (!count[j].contains(c)) c1++;\\n                for (int c : count[j])\\n                    if (!count[i].contains(c)) c2++;\\n                res += c1 * c2;\\n            }\\n        return res * 2;\\n    }\\n```\n```cpp\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> count[26];\\n        for (auto& s: ideas)\\n            count[s[0] - \\'a\\'].insert(s.substr(1));\\n        long long res = 0;\\n        for(int i = 0; i < 26; ++i)\\n            for(int j = i + 1; j < 26; ++j) {   \\n                long long c1 = 0L, c2 = 0L;\\n                for (auto& c: count[i])\\n                    if (!count[j].count(c)) c1++;\\n                for (auto& c: count[j])\\n                    if (!count[i].count(c)) c2++;\\n                res += c1 * c2;\\n            }\\n        return res * 2;\\n    }\\n```\n```py\\n    def distinctNames(self, ideas):\\n        count = defaultdict(set)\\n        for a in ideas:\\n            count[a[0]].add(hash(a[1:]))\\n        res = 0\\n        for a, seta in count.items():\\n            for b, setb in count.items():\\n                if a >= b: continue\\n                same = len(seta & setb)\\n                res += (len(seta) - same) * (len(setb) - same)\\n        return res * 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3162541,
                "title": "simple-diagram-example-for-intuition",
                "content": "##### This is a more detailed version of Lee\\'s solution to help with the intuition. Solution credits to @Lee215. \\n- Refer to his solution [here](https://leetcode.com/problems/naming-a-company/solutions/2141172/java-c-python-group-by-first-letter/?orderBy=most_votes). \\n\\n# Idea\\n- Use a list of hash sets to group together names that start with the same character. \\n    -   The size of the list will be $$26$$ for every alphabet letter. \\n- Using nested for loops, iterative through the list by comparing words from two different characters. \\n- For each comparison, find total valid mappings. Double this value at the end since names can be flipped.  \\n# Example\\n- List `ideas` consists of `[\"cart\", \"cow\", \"code\", \"dog\", \"dart\" \"girl\", \"gum\", \"log\", \"leet\", \"tart\", \"tow\"]`\\n- The array of hash sets for `ideas` looks like this:\\n\\n![1.jfif](https://assets.leetcode.com/users/images/07f0878f-42b9-4bcf-aa4a-860b72ee1dee_1675909614.8040257.jpeg)\\n- Notice we only save the substring of the name without the first letter.\\n\\n![1.jfif](https://assets.leetcode.com/users/images/c9905dcb-c94d-4aee-bcec-bf1fe8945bca_1675909857.930991.jpeg)\\n- The above shows that once `i` checks `j`, `j` will not need to check `i` in `j`\\'s iteration because that would lead to double counting. Every valid name will be distinct. \\n- Now let us consider a single iteration in detail: \\n\\n![1.jfif](https://assets.leetcode.com/users/images/173404f1-ed81-47cb-ba9d-d242716f2632_1675910800.6700606.jpeg)\\n![1.jfif](https://assets.leetcode.com/users/images/59a969d2-6929-4a9f-a28c-c788071d780a_1675910824.121568.jpeg)\\n![1.jfif](https://assets.leetcode.com/users/images/8b6db6b1-80fb-43aa-a904-17f6589f561c_1675910856.9439409.jpeg)\\n- Let us consider another iteration: \\n\\n![1.jfif](https://assets.leetcode.com/users/images/5af7a7a0-6dff-4d2d-afa7-9cc7140e68e5_1675911169.8656006.jpeg)\\n- We see that by iteratively performing this mapping algorithm, we can get all valid, distinct names. \\n\\n\\n\\n# Code\\n```\\nlong long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> map[26]; \\n        for (string& name : ideas){\\n            map[name[0]-\\'a\\'].insert(name.substr(1)); \\n        }\\n        long long res = 0;\\n        for (int i = 0; i < 25; i++){\\n            for (int j = i+1; j < 26; j++){\\n                int total1 = 0, total2 = 0;\\n                for (auto& substring : map[i]){\\n                    if (map[j].find(substring) == map[j].end()){\\n                        total1++;\\n                    }\\n                }\\n                for (auto& substring : map[j]){\\n                    if (map[i].find(substring) == map[i].end()){\\n                        total2++;\\n                    }\\n                }\\n                res += total1*total2;\\n            }\\n        }\\n        return res*2;\\n    }\\n```\\n\\n\\n\\n\\n### Pleas upvote if this was helpful. Thanks!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\nlong long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> map[26]; \\n        for (string& name : ideas){\\n            map[name[0]-\\'a\\'].insert(name.substr(1)); \\n        }\\n        long long res = 0;\\n        for (int i = 0; i < 25; i++){\\n            for (int j = i+1; j < 26; j++){\\n                int total1 = 0, total2 = 0;\\n                for (auto& substring : map[i]){\\n                    if (map[j].find(substring) == map[j].end()){\\n                        total1++;\\n                    }\\n                }\\n                for (auto& substring : map[j]){\\n                    if (map[i].find(substring) == map[i].end()){\\n                        total2++;\\n                    }\\n                }\\n                res += total1*total2;\\n            }\\n        }\\n        return res*2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162477,
                "title": "clean-codes-full-explanation-set-of-array-c-java-python3",
                "content": "# Intuition :\\n-  Here we are counting the number of distinct pairs of names, where two names are considered distinct if they have different initial characters or different suffixes (the part after the first character).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Explanation to Approach :\\n- First group the names by their first characters, and then for each pair of groups, count the number of distinct pairs that can be formed between them. \\n- Now compute the number of common suffixes between the two groups, and then subtracting that from the total number of pairs that can be formed between the two groups. \\n- Add the result to the overall answer.\\n- Use a Set[] array named \"suffixes\" to store the suffixes for each group of names, with one Set for each of the 26 possible initial characters (a-z). \\n- The suffix for a name is computed as the substring of the name starting from the second character.\\n- Finally, return the value of the \"ans\" variable, which holds the total number of distinct pairs of names.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)+O(26^2) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] with Comments :\\n```C++ []\\nclass Solution\\n{\\n    public:\\n        long long distinctNames(vector<string> &ideas) {\\n            long long ans = 0;\\n\\n            // Group strings by initials\\n            unordered_set<string> suffixes[26];\\n\\n            for (const string &idea : ideas)\\n                suffixes[idea[0] - \\'a\\'].insert(idea.substr(1));\\n\\n            for (int i = 0; i < 25; ++i)\\n                for (int j = i + 1; j < 26; ++j) {\\n                    int count = 0;\\n                    for (const string &suffix : suffixes[i])\\n                        if (suffixes[j].count(suffix))\\n                            ++count;\\n                    ans += 2 * (suffixes[i].size() - count) * (suffixes[j].size() - count);\\n                }\\n            return ans;\\n        }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public long distinctNames(String[] ideas) {\\n    long ans = 0;\\n    // Group strings by initials\\n    Set<String>[] suffixes = new Set[26];\\n\\n    for (int i = 0; i < 26; ++i)\\n      suffixes[i] = new HashSet<>();\\n\\n    for (final String idea : ideas)\\n      suffixes[idea.charAt(0) - \\'a\\'].add(idea.substring(1));\\n\\n    for (int i = 0; i < 25; ++i)\\n      for (int j = i + 1; j < 26; ++j) {\\n        int count = 0;\\n        for (final String suffix : suffixes[i])\\n          if (suffixes[j].contains(suffix))\\n            ++count;\\n        ans += 2 * (suffixes[i].size() - count) * (suffixes[j].size() - count);\\n      }\\n\\n    return ans;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def distinctNames(self, ideas: List[str]) -> int:\\n    ans = 0\\n    # Group strings by initials\\n    suffixes = [set() for _ in range(26)]\\n\\n    for idea in ideas:\\n      suffixes[ord(idea[0]) - ord(\\'a\\')].add(idea[1:])\\n\\n    for i in range(25):\\n      for j in range(i + 1, 26):\\n        count = len(suffixes[i] & suffixes[j])\\n        ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)\\n\\n    return ans\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/eb67281b-7963-4449-851c-7daa770840f6_1675909541.9250734.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution\\n{\\n    public:\\n        long long distinctNames(vector<string> &ideas) {\\n            long long ans = 0;\\n\\n            // Group strings by initials\\n            unordered_set<string> suffixes[26];\\n\\n            for (const string &idea : ideas)\\n                suffixes[idea[0] - \\'a\\'].insert(idea.substr(1));\\n\\n            for (int i = 0; i < 25; ++i)\\n                for (int j = i + 1; j < 26; ++j) {\\n                    int count = 0;\\n                    for (const string &suffix : suffixes[i])\\n                        if (suffixes[j].count(suffix))\\n                            ++count;\\n                    ans += 2 * (suffixes[i].size() - count) * (suffixes[j].size() - count);\\n                }\\n            return ans;\\n        }\\n};\\n```\n```Java []\\nclass Solution {\\n  public long distinctNames(String[] ideas) {\\n    long ans = 0;\\n    // Group strings by initials\\n    Set<String>[] suffixes = new Set[26];\\n\\n    for (int i = 0; i < 26; ++i)\\n      suffixes[i] = new HashSet<>();\\n\\n    for (final String idea : ideas)\\n      suffixes[idea.charAt(0) - \\'a\\'].add(idea.substring(1));\\n\\n    for (int i = 0; i < 25; ++i)\\n      for (int j = i + 1; j < 26; ++j) {\\n        int count = 0;\\n        for (final String suffix : suffixes[i])\\n          if (suffixes[j].contains(suffix))\\n            ++count;\\n        ans += 2 * (suffixes[i].size() - count) * (suffixes[j].size() - count);\\n      }\\n\\n    return ans;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def distinctNames(self, ideas: List[str]) -> int:\\n    ans = 0\\n    # Group strings by initials\\n    suffixes = [set() for _ in range(26)]\\n\\n    for idea in ideas:\\n      suffixes[ord(idea[0]) - ord(\\'a\\')].add(idea[1:])\\n\\n    for i in range(25):\\n      for j in range(i + 1, 26):\\n        count = len(suffixes[i] & suffixes[j])\\n        ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)\\n\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140967,
                "title": "count-pairs",
                "content": "We can create only 26 new ideas out of the existing one. For each idea, take it\\'s first letter, and track which of 26 new ideas are valid in `cnt`.\\n\\nFor `[\"coffee\", \"toffee\", \"cat\"]`, `cnt[\\'c\\'][\\'t\\']` is equal `1` and `cnt[\\'t\\'][\\'c\\']` is zero: \\n- One new idea (`\"tat\"`) appears by replacing `\\'c\\'` with `\\'t\\'` (`\"toffee\"` is not new).\\n- No new ideas emerge when replacing  `\\'t\\'` with `\\'c\\'` (`\"coffee\"` is not new).\\n \\nTherefore, no company names can be created by combining ideas that start with `\\'c\\'` and `\\'t\\'`.\\n\\nTo sum up, `cnt[i][j]` is a number of new ideas when replacing character `i` with `j`. `cnt[j][i]` - new ideas when replacing `j` with `i`.\\n\\nTherefore, we can form  `cnt[i][j] * cnt[j][i]` company names.\\n\\n**Java**\\nTo beat TLE, we need to avoid creating bunch of new strings. For that purpose, we use an array of hash sets, which maps the first letter to hash set of suffixes.\\n\\nThen, we use suffixes to determine new ideas, and those suffixes do not change. \\n\\n```java\\npublic long distinctNames(String[] ideas) {\\n    long res = 0, cnt[][] = new long[26][26];\\n    Set<String>[] s = new HashSet[26];\\n    for (int i = 0; i < 26; ++i)\\n        s[i] = new HashSet<>();    \\n    for (var idea : ideas)\\n        s[idea.charAt(0) - \\'a\\'].add(idea.substring(1));\\n    for (int i = 0; i < 26; ++i)\\n        for (var suff : s[i])\\n            for (int j = 0; j < 26; ++j)\\n                cnt[i][j] += s[j].contains(suff) ? 0 : 1;\\n    for (int i = 0; i < 26; ++i)\\n        for (int j = 0; j < 26; ++j)\\n            res += cnt[i][j] * cnt[j][i];\\n    return res;\\n}\\n```\\n**C++**\\n```cpp\\nlong long distinctNames(vector<string>& ideas) {\\n    long long res = 0, cnt[26][26] = {};\\n    unordered_set<string> s[26];\\n    for (auto &idea : ideas)\\n        s[idea[0] - \\'a\\'].insert(idea.substr(1));\\n    for (int i = 0; i < 26; ++i)\\n        for (auto &suff : s[i])\\n            for (int j = 0; j < 26; ++j)\\n                cnt[i][j] += s[j].count(suff) == 0;\\n    for (int i = 0; i < 26; ++i)\\n        for (int j = 0; j < 26; ++j)\\n            res += cnt[i][j] * cnt[j][i];\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic long distinctNames(String[] ideas) {\\n    long res = 0, cnt[][] = new long[26][26];\\n    Set<String>[] s = new HashSet[26];\\n    for (int i = 0; i < 26; ++i)\\n        s[i] = new HashSet<>();    \\n    for (var idea : ideas)\\n        s[idea.charAt(0) - \\'a\\'].add(idea.substring(1));\\n    for (int i = 0; i < 26; ++i)\\n        for (var suff : s[i])\\n            for (int j = 0; j < 26; ++j)\\n                cnt[i][j] += s[j].contains(suff) ? 0 : 1;\\n    for (int i = 0; i < 26; ++i)\\n        for (int j = 0; j < 26; ++j)\\n            res += cnt[i][j] * cnt[j][i];\\n    return res;\\n}\\n```\n```cpp\\nlong long distinctNames(vector<string>& ideas) {\\n    long long res = 0, cnt[26][26] = {};\\n    unordered_set<string> s[26];\\n    for (auto &idea : ideas)\\n        s[idea[0] - \\'a\\'].insert(idea.substr(1));\\n    for (int i = 0; i < 26; ++i)\\n        for (auto &suff : s[i])\\n            for (int j = 0; j < 26; ++j)\\n                cnt[i][j] += s[j].count(suff) == 0;\\n    for (int i = 0; i < 26; ++i)\\n        for (int j = 0; j < 26; ++j)\\n            res += cnt[i][j] * cnt[j][i];\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2140991,
                "title": "c-understandable-clean-2d-a-r-r-a-y",
                "content": "Lets create a 2D vector arr of size `26 x 26` in which every `arr[i][j]` store whether the word starting with i-\\'a\\' can swap with symbol j+\\'a\\' .\\n  For eg. for ideas =  [\"coffee\",\"donuts\",\"time\",\"toffee\"] \\n  the created array will have  `arr[2][3] = 1(shows that c can be replced with d ),arr[3][2] =1,arr[3][19]=1,arr[19][2] = 1,arr[19][3]=2` i.e.1+1(from time and toffee) \\n\\n# Space Complexity : O(n) (considering 26x26 array as constant space)\\n# Time Complexity : O(n)  \\n# \\n```\\nunordered_map<string,bool> hm;\\n        for(int i=0;i<ideas.size();i++){      \\n             hm[ideas[i]] = true;\\n        }\\n        \\n        vector<vector<long long >> dict(26,vector<long long >(26,0)); \\n        \\n        for(int i =0;i<ideas.size();i++){\\n            \\n            string word = ideas[i].substr(1);\\n            \\n            int in = ideas[i][0]-\\'a\\';\\n            \\n              for(int j = 0;j<26;j++){\\n                  char y = (\\'a\\'+j);\\n                  string temp = y + word;\\n                  \\n                  if(hm.count(temp)==0){\\n                      dict[in][j] += 1;\\n                  }   \\n              }}\\n        \\n        long long count = 0;\\n        for(int i=0;i<26;i++){\\n            \\n              for(int j = 0;j<26;j++){\\n                  if(i==j)continue;\\n                  if(dict[i][j]>0){\\n                      count += (dict[j][i]*dict[i][j]);   \\n                  }\\n              }  \\n        }\\n        \\n        return count;\\n```\\n\\nPlease upvote if it helped  : )",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nunordered_map<string,bool> hm;\\n        for(int i=0;i<ideas.size();i++){      \\n             hm[ideas[i]] = true;\\n        }\\n        \\n        vector<vector<long long >> dict(26,vector<long long >(26,0)); \\n        \\n        for(int i =0;i<ideas.size();i++){\\n            \\n            string word = ideas[i].substr(1);\\n            \\n            int in = ideas[i][0]-\\'a\\';\\n            \\n              for(int j = 0;j<26;j++){\\n                  char y = (\\'a\\'+j);\\n                  string temp = y + word;\\n                  \\n                  if(hm.count(temp)==0){\\n                      dict[in][j] += 1;\\n                  }   \\n              }}\\n        \\n        long long count = 0;\\n        for(int i=0;i<26;i++){\\n            \\n              for(int j = 0;j<26;j++){\\n                  if(i==j)continue;\\n                  if(dict[i][j]>0){\\n                      count += (dict[j][i]*dict[i][j]);   \\n                  }\\n              }  \\n        }\\n        \\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162547,
                "title": "c-using-hash-table-o-n-26-solution-clean-and-concise",
                "content": "# Code\\n# **PLEASE DO UPVOTE !**\\n**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& s) {\\n        int n = s.size();\\n        unordered_map<string,bool> mp;\\n        for(auto x:s)\\n        {\\n            mp[x]=true;\\n        }\\n        vector<vector<long long >> dict(26,vector<long long> (26,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            string str=s[i].substr(1);\\n            int in=s[i][0]-\\'a\\';\\n            cout<<in<<endl;\\n            for(int j=0;j<26;j++){\\n                char ch=j+\\'a\\';\\n                string res=ch+str;\\n                if(mp.count(res)==0){\\n                    dict[in][j]+=1;\\n                }\\n            }\\n        }\\n        long long cnt=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++){\\n                if(dict[i][j]>0 and i!=j)\\n                {\\n                    cnt+=dict[i][j]*dict[j][i];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& s) {\\n        int n = s.size();\\n        unordered_map<string,bool> mp;\\n        for(auto x:s)\\n        {\\n            mp[x]=true;\\n        }\\n        vector<vector<long long >> dict(26,vector<long long> (26,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            string str=s[i].substr(1);\\n            int in=s[i][0]-\\'a\\';\\n            cout<<in<<endl;\\n            for(int j=0;j<26;j++){\\n                char ch=j+\\'a\\';\\n                string res=ch+str;\\n                if(mp.count(res)==0){\\n                    dict[in][j]+=1;\\n                }\\n            }\\n        }\\n        long long cnt=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++){\\n                if(dict[i][j]>0 and i!=j)\\n                {\\n                    cnt+=dict[i][j]*dict[j][i];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3162336,
                "title": "explained-java-solution",
                "content": "\\n  eg. [\"coffee\",\"donuts\",\"time\",\"toffee\"]\\n  \\n => **Create an array of list and store according to first char after removing the first char**\\n```\\n*   arr[2] = { offee } // represents c\\n*   arr[3] = { onuts } // represents d\\n*   arr[19] = { ime, offee } //represents t\\n```\\n\\n => **now apply the HashSet part operation**\\n  ```\\nset.addAll(arr[i]);\\nset.addAll(arr[j]);\\n  \\n  ```\\nFor every possible pair of distinct characters the number of distinct names are : \\n**`disName += 2 * (arr[i].size() - set.size()) * (arr[j].size() - set.size());`**\\n\\n* `(arr[i].size() - set.size())` - number of distinct strings that are present for second character but not in first character\\n* `(arr[j].size() - set.size())` - number of distinct strings that are present for first character but not in second character\\n\\n##### Code : \\n ```\\nclass Solution {\\n        public long distinctNames(String[] ideas) {\\n        List<String> arr[] = new ArrayList[26];               // create array of ArrayList\\n        long disName = 0;                                     // Instead ArrayList, HashSet can be used\\n        for(int i = 0; i < 26; i++)                           // assign new ArrayList to each index\\n            arr[i] = new ArrayList<>();\\n\\n        for(String s : ideas)\\n            arr[s.charAt(0) - \\'a\\'].add(s.substring(1));       // store each string A/C to its 1st char\\n\\n        for(int i = 0; i < 25; i++) {\\n            for(int j = i + 1; j < 26; j++) {\\n                Set<String> set = new HashSet<>();            // store all strings of arr[i] & arr[j]\\n\\n                set.addAll(arr[i]);\\n                set.addAll(arr[j]);\\n                disName += (arr[i].size() - set.size()) * (arr[j].size() - set.size());     // no. of pairs possible\\n            }\\n        }\\n\\n        return disName * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n*   arr[2] = { offee } // represents c\\n*   arr[3] = { onuts } // represents d\\n*   arr[19] = { ime, offee } //represents t\\n```\n```\\nset.addAll(arr[i]);\\nset.addAll(arr[j]);\\n  \\n  ```\n```\\nclass Solution {\\n        public long distinctNames(String[] ideas) {\\n        List<String> arr[] = new ArrayList[26];               // create array of ArrayList\\n        long disName = 0;                                     // Instead ArrayList, HashSet can be used\\n        for(int i = 0; i < 26; i++)                           // assign new ArrayList to each index\\n            arr[i] = new ArrayList<>();\\n\\n        for(String s : ideas)\\n            arr[s.charAt(0) - \\'a\\'].add(s.substring(1));       // store each string A/C to its 1st char\\n\\n        for(int i = 0; i < 25; i++) {\\n            for(int j = i + 1; j < 26; j++) {\\n                Set<String> set = new HashSet<>();            // store all strings of arr[i] & arr[j]\\n\\n                set.addAll(arr[i]);\\n                set.addAll(arr[j]);\\n                disName += (arr[i].size() - set.size()) * (arr[j].size() - set.size());     // no. of pairs possible\\n            }\\n        }\\n\\n        return disName * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150949,
                "title": "c-2-intuitive-approaches-w-maps-and-2d-array",
                "content": "**Using Unordered map and set**\\nIn this method, we use unordered map with *key* as *char* and value as an *unordered_set*. For each prefix character, we insert its remaining suffix string in its value set. Now, for every character, we find the common suffixes with every other character. We wont be able to swap the characters having the same suffixes. \\nFor ex. \\n```\\n\\t\\tideas = [\"coffee\",\"cone\",\"chips\",\"time\",\"toffee\"]\\n\\t\\tc    -> [\"offee\",\"one\",\"hips\"]\\n\\t\\tt    -> [\"offee\",\"ime\"]\\n```\\nNow, the common suffix in `\\'c\\'` and` \\'t\\'` is `offee`, thus we cant make a name with it, but we can make a valid name with the remaining suffixes. \\nThus, total valid names will be (2x1)x2 = 4\\n\\n**This method is a bit costly with space and time**\\n\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map <char,unordered_set<string>> mp;\\n        for(auto u : ideas) mp[u[0]].insert(u.substr(1,u.size()-1));\\n        \\n        long long ans = 0;\\n        \\n        for(int i = 0; i<26; i++){\\n            for(int j = i+1; j<26; j++){\\n                unordered_set <string> s1 = mp[i+\\'a\\'], s2 = mp[j+\\'a\\'];\\n                \\n                int comm = 0;\\n                for(auto u : s1)\\n                    if(s2.find(u)!=s2.end()) comm++;\\n                \\n                ans += (long long)(s1.size()-comm)*(long long)(s2.size()-comm)*2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n****\\n****\\n**Using 2d array**\\nThis method does not uses any *unordered_set* as value of *unordered_map*, instead, we use a 2d array to store if we could swap two characters or not. \\n`dp[i][j] = 1`, tells us that we can swap i<sup>th</sup> character with j<sup>th</sup> character. \\nFor ex,\\n```\\n\\t\\tideas = [\"coffee\",\"cone\",\"chips\",\"time\",\"toffee\"]\\n\\t\\tc    -> [\"offee\",\"one\",\"hips\"]\\n\\t\\tt    -> [\"offee\",\"ime\"]\\n```\\nWe iterate over ideas, and try swapping first character of each element with every character and check if the new character is already in ideas or not. If it is not present in ideas, we increment `dp[original_char][swapped_char]`.\\nWe add `dp[i][j]*dp[j][i] `to our answer, that ensure that answer is incremented only when` i->j` and` j->i`, both are valid swappings.  \\n\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map <string,int> mp;\\n        for(auto u : ideas) mp[u]++;\\n        \\n        vector <vector <int>> dp(26,vector<int>(26,0));\\n        for(int i = 0; i<ideas.size(); i++){\\n            string temp = ideas[i];\\n            char ch1 = temp[0];\\n            for(int j = 0; j<26; j++){\\n                temp[0] = j+\\'a\\';\\n                if(mp.find(temp)==mp.end()) \\n                    dp[ch1-\\'a\\'][j]++;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(int i = 0; i<26; i++){\\n            for(int j = 0; j<26; j++){\\n                ans += dp[i][j]*dp[j][i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t\\tideas = [\"coffee\",\"cone\",\"chips\",\"time\",\"toffee\"]\\n\\t\\tc    -> [\"offee\",\"one\",\"hips\"]\\n\\t\\tt    -> [\"offee\",\"ime\"]\\n```\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map <char,unordered_set<string>> mp;\\n        for(auto u : ideas) mp[u[0]].insert(u.substr(1,u.size()-1));\\n        \\n        long long ans = 0;\\n        \\n        for(int i = 0; i<26; i++){\\n            for(int j = i+1; j<26; j++){\\n                unordered_set <string> s1 = mp[i+\\'a\\'], s2 = mp[j+\\'a\\'];\\n                \\n                int comm = 0;\\n                for(auto u : s1)\\n                    if(s2.find(u)!=s2.end()) comm++;\\n                \\n                ans += (long long)(s1.size()-comm)*(long long)(s2.size()-comm)*2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n\\t\\tideas = [\"coffee\",\"cone\",\"chips\",\"time\",\"toffee\"]\\n\\t\\tc    -> [\"offee\",\"one\",\"hips\"]\\n\\t\\tt    -> [\"offee\",\"ime\"]\\n```\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map <string,int> mp;\\n        for(auto u : ideas) mp[u]++;\\n        \\n        vector <vector <int>> dp(26,vector<int>(26,0));\\n        for(int i = 0; i<ideas.size(); i++){\\n            string temp = ideas[i];\\n            char ch1 = temp[0];\\n            for(int j = 0; j<26; j++){\\n                temp[0] = j+\\'a\\';\\n                if(mp.find(temp)==mp.end()) \\n                    dp[ch1-\\'a\\'][j]++;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for(int i = 0; i<26; i++){\\n            for(int j = 0; j<26; j++){\\n                ans += dp[i][j]*dp[j][i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140916,
                "title": "python3-short-counting",
                "content": "**Explanation**:\\n* `m[x][y]` denotes the number of strings that are currently starting with `y` but may also start with `x` since the same string starting with `x` is not present in the given list\\n\\n**Short**:\\n   ```\\n    def distinctNames(self, A: List[str]) -> int:\\n        m, ans, A = defaultdict(lambda: defaultdict(int)), 0, set(A)\\n        for w in A:\\n            for x in ascii_lowercase:\\n                if x + w[1:] not in A: m[x][w[0]] += 1\\n        for w in A:\\n            for x in ascii_lowercase:\\n                if x + w[1:] not in A: ans += m[w[0]][x]\\n        return ans\\n```\\n**Shorter**:\\n   ```\\n    def distinctNames(self, A: List[str]) -> int:\\n        m, A, s = defaultdict(Counter), set(A), ascii_lowercase\\n        for w in A:\\n            for x in s:\\n                if x + w[1:] not in A: m[x][w[0]] += 1\\n        return sum(m[w[0]][x] if x + w[1:] not in A else 0 for x in s for w in A)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def distinctNames(self, A: List[str]) -> int:\\n        m, ans, A = defaultdict(lambda: defaultdict(int)), 0, set(A)\\n        for w in A:\\n            for x in ascii_lowercase:\\n                if x + w[1:] not in A: m[x][w[0]] += 1\\n        for w in A:\\n            for x in ascii_lowercase:\\n                if x + w[1:] not in A: ans += m[w[0]][x]\\n        return ans\\n```\n```\\n    def distinctNames(self, A: List[str]) -> int:\\n        m, A, s = defaultdict(Counter), set(A), ascii_lowercase\\n        for w in A:\\n            for x in s:\\n                if x + w[1:] not in A: m[x][w[0]] += 1\\n        return sum(m[w[0]][x] if x + w[1:] not in A else 0 for x in s for w in A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3163150,
                "title": "putta-easy-solution-c-hashmap-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSwap the first letters of ideaA and ideaB with each other.\\nThere are only 26 alphabets in English we can we make use of this.\\n\\n\\n# Complexity\\n- Time complexity:$$O(n*26*26)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<char,set<string>> mp; //creating a unordered_map w[0] as key and w[1 to n] as value stored in a set.\\n        for(int i=0;i<ideas.size();i++){\\n            mp[ideas[i][0]].insert(ideas[i].substr(1));\\n        } \\n        long long ans =0,samesuffix=0;\\n        for(int i =97;i<122;i++){          //iterating through 26 alphabets\\n            for(int j=i+1;j<123;j++){\\n                samesuffix=0;\\n                for(auto it3:mp[i]){   // checking if 2 map value set words have same w[1 to n ]\\n                    if( mp[j].find(it3) !=  mp[j].end() ) \\n                        samesuffix++;   // incrementing samesuffix\\n                }\\n                ans += 2*( mp[i].size()-samesuffix)*(mp[j].size()-samesuffix); //updating the ans by removing the samesuffix words .\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<char,set<string>> mp; //creating a unordered_map w[0] as key and w[1 to n] as value stored in a set.\\n        for(int i=0;i<ideas.size();i++){\\n            mp[ideas[i][0]].insert(ideas[i].substr(1));\\n        } \\n        long long ans =0,samesuffix=0;\\n        for(int i =97;i<122;i++){          //iterating through 26 alphabets\\n            for(int j=i+1;j<123;j++){\\n                samesuffix=0;\\n                for(auto it3:mp[i]){   // checking if 2 map value set words have same w[1 to n ]\\n                    if( mp[j].find(it3) !=  mp[j].end() ) \\n                        samesuffix++;   // incrementing samesuffix\\n                }\\n                ans += 2*( mp[i].size()-samesuffix)*(mp[j].size()-samesuffix); //updating the ans by removing the samesuffix words .\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162902,
                "title": "understanding-about-the-fastest-solution-why-hints-were-grouping-by-suffix",
                "content": "Input: ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]\\n\\n# Method 1:\\n\\nGroup ideas by first char, and store the suffix\\n\\n```\\nc: [offee]\\nd: [onuts]\\nt: [ime, offee]\\n```\\n\\nFor different group here, if they have different suffix, they can form a pair.\\n\\n`c: [offee] v.s. d: [onuts]`\\n\\n-> can form 1 * 1 * 2 (e.g. `uniq key 1 size * uniq key 2 size * 2`)\\n\\n`c: [offee] v.s. t:[ime, offee]`\\n\\n-> offee appear in both, can\\'t form any valid group\\n\\n`d: [onuts] v.s. t:[ime, offee]`\\n\\n-> can form 1 * 2 * 2\\n\\nOverall doing so, the outer comparison loop is constant:\\n`O(first char set * first char set) = O(26 * 26)`\\n\\nBut inside the loop, to find the difference set of suffix, it takes\\n`O(unique_suffix_cnt)`\\n\\n# Method 2: suffix as key\\n\\n```\\noffee: [c, t]\\nonuts: [d]\\nime:   [t]\\n\\ngroup offee v.s. onuts creates 2 * 1 * 2\\ngroup offee v.s. ime creates 1 * 0 * 2\\ngroup onuts v.s. ime creates 1 * 1 * 2\\n\\n```\\n\\nThis will get a TLE because the `O(unique_suffix_cnt * unique_suffix_cnt)` in outer loop, And inside to find the difference set of first char, it\\'s constant `O(26 + 26)`\\n\\n# Method 3 (optimal): further improve on method2\\n\\nHow to not looping on uniq_suffix_cnt * uniq_suffix_cnt of combination in method 2?\\n\\nYou gather a `counter[c1][c2][2]`, where\\n\\nfor any char pairs `{c1, c2}`\\n\\n- `cnt[c1][c2][0]`: how many suffix only having c2 but not c1 as first char\\n- `cnt[c1][c2][1]`: how many suffix only having c1 but not c2 as first char\\n\\nThen when you gather the result, it will be a loop on O(26 * 26) again...\\n\\n```txt\\noffee: [c, t]\\nonuts: [d]\\nime: [t]\\n\\n\\nchars pairs| suffix only have one of the char\\n    {c, d} | {offee}    e.g. there is no doffee exists, only coffee\\n    {c, t} | {ime}      e.g. there is no cime exists, only time\\n    {d, t} | {ime}      e.g. there is no dime exists, only time\\n```\\n\\n```cpp\\n  long long distinctNames(vector<string>& ideas) /*optimal method 3*/ {\\n    std::unordered_map<std::string_view, std::bitset<26>> suffixToFirstChars;\\n    for (std::string_view idea : ideas) {\\n      suffixToFirstChars[idea.substr(1)].set(idea[0] - \\'a\\');\\n    }\\n\\n    std::array<std::array<std::array<int, 2>, 26>, 26> cnt{};\\n    for (const auto& [suffix, firstCharSet] : suffixToFirstChars) {\\n      for (int i = 0; i < 26; ++i) {\\n        for (int j = i + 1; j < 26; ++j) {\\n          if (bool containOnlyOne =\\n                  firstCharSet.test(i) ^ firstCharSet.test(j)) {\\n            // for a suffix and 2 different chars, if such suffix\\n            // only contain one of the char, we record it in cnt\\n            // for any char pairs {c1, c2}\\n            // cnt[c1][c2][0]: how many suffix only having c2 as first char\\n            // cnt[c1][c2][1]: how many suffix only having c1 as first char\\n            ++cnt[i][j][firstCharSet.test(i)];\\n          }\\n        }\\n      }\\n    }\\n    long long ans = 0;\\n    for (int i = 0; i < 26; ++i) {\\n      for (int j = i + 1; j < 26; ++j) {\\n        ans += 2ll * cnt[i][j][0] * cnt[i][j][1];\\n      }\\n    }\\n    return ans;\\n  }\\n```\\n\\n```cpp\\n  long long distinctNames_method_1(vector<string>& ideas) {\\n      std::unordered_map<char, std::set<std::string_view>> firstChar2Suffix;\\n      for (std::string_view idea : ideas) {\\n          firstChar2Suffix[idea[0]].insert(idea.substr(1));\\n      }\\n      std::vector<char> keys;\\n      const int groupSz = firstChar2Suffix.size();\\n      keys.reserve(groupSz);\\n      for (const auto& p : firstChar2Suffix) {\\n          keys.push_back(p.first);\\n      }\\n      long long res = 0;\\n      for (int i = 0; i < groupSz; ++i) {\\n          for (int j = i + 1; j < groupSz; ++j) {\\n              const auto& set1 = firstChar2Suffix[keys[i]];\\n              const auto& set2 = firstChar2Suffix[keys[j]];\\n              std::vector<std::string_view> unionSet;\\n              std::set_union(set1.begin(), set1.end(), set2.begin(), set2.end(),\\n                  std::back_inserter(unionSet));\\n              res += (set1.size() - unionSet.size()) * (set2.size() -\\n  unionSet.size()) * 2;\\n          }\\n      }\\n      return res;\\n  }\\n```\\n\\n```cpp\\n  long long distinctNames_method_2(vector<string>& ideas) {\\n      std::unordered_map<std::string_view, std::bitset<26>> suffixToFirstChars;\\n      for (std::string_view idea : ideas) {\\n          suffixToFirstChars[idea.substr(1)].set(idea[0] - \\'a\\');\\n      }\\n      std::vector<std::string_view> keys;\\n      const int groupSz = suffixToFirstChars.size();\\n      keys.reserve(groupSz);\\n      for (const auto& p : suffixToFirstChars) {\\n          keys.push_back(p.first);\\n      }\\n      long long res = 0;\\n      for (int i = 0; i < groupSz; ++i) {\\n          for (int j = i + 1; j < groupSz; ++j) {\\n              const auto& firstCharsSet1 = suffixToFirstChars[keys[i]];\\n              const auto& firstCharsSet2 = suffixToFirstChars[keys[j]];\\n              const auto unionSetSz = (firstCharsSet1 & firstCharsSet2).count();\\n              res += (firstCharsSet1.count() - unionSetSz) *\\n  (firstCharsSet2.count() - unionSetSz) * 2;\\n          }\\n      }\\n      return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nc: [offee]\\nd: [onuts]\\nt: [ime, offee]\\n```\n```\\noffee: [c, t]\\nonuts: [d]\\nime:   [t]\\n\\ngroup offee v.s. onuts creates 2 * 1 * 2\\ngroup offee v.s. ime creates 1 * 0 * 2\\ngroup onuts v.s. ime creates 1 * 1 * 2\\n\\n```\n```txt\\noffee: [c, t]\\nonuts: [d]\\nime: [t]\\n\\n\\nchars pairs| suffix only have one of the char\\n    {c, d} | {offee}    e.g. there is no doffee exists, only coffee\\n    {c, t} | {ime}      e.g. there is no cime exists, only time\\n    {d, t} | {ime}      e.g. there is no dime exists, only time\\n```\n```cpp\\n  long long distinctNames(vector<string>& ideas) /*optimal method 3*/ {\\n    std::unordered_map<std::string_view, std::bitset<26>> suffixToFirstChars;\\n    for (std::string_view idea : ideas) {\\n      suffixToFirstChars[idea.substr(1)].set(idea[0] - \\'a\\');\\n    }\\n\\n    std::array<std::array<std::array<int, 2>, 26>, 26> cnt{};\\n    for (const auto& [suffix, firstCharSet] : suffixToFirstChars) {\\n      for (int i = 0; i < 26; ++i) {\\n        for (int j = i + 1; j < 26; ++j) {\\n          if (bool containOnlyOne =\\n                  firstCharSet.test(i) ^ firstCharSet.test(j)) {\\n            // for a suffix and 2 different chars, if such suffix\\n            // only contain one of the char, we record it in cnt\\n            // for any char pairs {c1, c2}\\n            // cnt[c1][c2][0]: how many suffix only having c2 as first char\\n            // cnt[c1][c2][1]: how many suffix only having c1 as first char\\n            ++cnt[i][j][firstCharSet.test(i)];\\n          }\\n        }\\n      }\\n    }\\n    long long ans = 0;\\n    for (int i = 0; i < 26; ++i) {\\n      for (int j = i + 1; j < 26; ++j) {\\n        ans += 2ll * cnt[i][j][0] * cnt[i][j][1];\\n      }\\n    }\\n    return ans;\\n  }\\n```\n```cpp\\n  long long distinctNames_method_1(vector<string>& ideas) {\\n      std::unordered_map<char, std::set<std::string_view>> firstChar2Suffix;\\n      for (std::string_view idea : ideas) {\\n          firstChar2Suffix[idea[0]].insert(idea.substr(1));\\n      }\\n      std::vector<char> keys;\\n      const int groupSz = firstChar2Suffix.size();\\n      keys.reserve(groupSz);\\n      for (const auto& p : firstChar2Suffix) {\\n          keys.push_back(p.first);\\n      }\\n      long long res = 0;\\n      for (int i = 0; i < groupSz; ++i) {\\n          for (int j = i + 1; j < groupSz; ++j) {\\n              const auto& set1 = firstChar2Suffix[keys[i]];\\n              const auto& set2 = firstChar2Suffix[keys[j]];\\n              std::vector<std::string_view> unionSet;\\n              std::set_union(set1.begin(), set1.end(), set2.begin(), set2.end(),\\n                  std::back_inserter(unionSet));\\n              res += (set1.size() - unionSet.size()) * (set2.size() -\\n  unionSet.size()) * 2;\\n          }\\n      }\\n      return res;\\n  }\\n```\n```cpp\\n  long long distinctNames_method_2(vector<string>& ideas) {\\n      std::unordered_map<std::string_view, std::bitset<26>> suffixToFirstChars;\\n      for (std::string_view idea : ideas) {\\n          suffixToFirstChars[idea.substr(1)].set(idea[0] - \\'a\\');\\n      }\\n      std::vector<std::string_view> keys;\\n      const int groupSz = suffixToFirstChars.size();\\n      keys.reserve(groupSz);\\n      for (const auto& p : suffixToFirstChars) {\\n          keys.push_back(p.first);\\n      }\\n      long long res = 0;\\n      for (int i = 0; i < groupSz; ++i) {\\n          for (int j = i + 1; j < groupSz; ++j) {\\n              const auto& firstCharsSet1 = suffixToFirstChars[keys[i]];\\n              const auto& firstCharsSet2 = suffixToFirstChars[keys[j]];\\n              const auto unionSetSz = (firstCharsSet1 & firstCharsSet2).count();\\n              res += (firstCharsSet1.count() - unionSetSz) *\\n  (firstCharsSet2.count() - unionSetSz) * 2;\\n          }\\n      }\\n      return res;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162589,
                "title": "c-slow-but-understandable-map-of-sets-clean-and-concise-code",
                "content": "\\n\\n# Code\\n\\n# Please Do Upvote!!!!\\n##### Connect with me on Linkedin -> https://www.linkedin.com/in/md-kamran-55b98521a/\\n\\n```\\n\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas){\\n\\n      \\n        unordered_map<int, unordered_set<string>>mpp;\\n        long long res = 0;\\n\\n\\n        for(auto &it : ideas) mpp[it[0]].insert(it.substr(1,it.size()-1));        \\n\\n        \\n        for(int i = 0; i < 26; i++)\\n        {\\n            for(int j = i+1; j < 26; j++)\\n            {\\n                unordered_set<string>temp1 = mpp[i+\\'a\\'], temp2 = mpp[j+\\'a\\'];\\n                \\n                long long val = 0;\\n\\n                for(auto &it : temp1)\\n                {\\n                  if(temp2.find(it) != temp2.end()) val++;\\n                }\\n\\n                \\n                res += 1LL*((temp1.size()- val)*(temp2.size()- val))*2;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/b2a4e5a3-9cd3-4e16-953b-975627b163a1_1675912812.4756923.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas){\\n\\n      \\n        unordered_map<int, unordered_set<string>>mpp;\\n        long long res = 0;\\n\\n\\n        for(auto &it : ideas) mpp[it[0]].insert(it.substr(1,it.size()-1));        \\n\\n        \\n        for(int i = 0; i < 26; i++)\\n        {\\n            for(int j = i+1; j < 26; j++)\\n            {\\n                unordered_set<string>temp1 = mpp[i+\\'a\\'], temp2 = mpp[j+\\'a\\'];\\n                \\n                long long val = 0;\\n\\n                for(auto &it : temp1)\\n                {\\n                  if(temp2.find(it) != temp2.end()) val++;\\n                }\\n\\n                \\n                res += 1LL*((temp1.size()- val)*(temp2.size()- val))*2;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162523,
                "title": "python-solution-in-o-n-time-complexity-clever-solution-using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        hashMap = collections.defaultdict(set)\\n        for w in ideas:\\n            hashMap[w[0]].add(w[1:])\\n        \\n        res = 0\\n        for char1 in hashMap:\\n            for char2 in hashMap:\\n                if char1 == char2:\\n                    continue\\n                intersect = 0\\n\\n                for w in hashMap[char1]:\\n                    if w in hashMap[char2]:\\n                        intersect += 1\\n                \\n                distinct1 = len(hashMap[char1]) - intersect\\n                distinct2 = len(hashMap[char2]) - intersect\\n\\n                res += distinct1*distinct2\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        hashMap = collections.defaultdict(set)\\n        for w in ideas:\\n            hashMap[w[0]].add(w[1:])\\n        \\n        res = 0\\n        for char1 in hashMap:\\n            for char2 in hashMap:\\n                if char1 == char2:\\n                    continue\\n                intersect = 0\\n\\n                for w in hashMap[char1]:\\n                    if w in hashMap[char2]:\\n                        intersect += 1\\n                \\n                distinct1 = len(hashMap[char1]) - intersect\\n                distinct2 = len(hashMap[char2]) - intersect\\n\\n                res += distinct1*distinct2\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163268,
                "title": "fast-java-solution",
                "content": "# JAVA Code\\n\\n``` JAVA []\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<Integer>[] count = new HashSet[26];\\n        for (int i = 0; i < 26; ++i)\\n            count[i] = new HashSet<>();\\n        for (String s : ideas)\\n            count[s.charAt(0) - \\'a\\'].add(s.substring(1).hashCode());\\n        long res = 0;\\n        for (int i = 0; i < 26; ++i)\\n            for (int j = i + 1; j < 26; ++j) {\\n                long c1 = 0, c2 = 0;\\n                for (int c : count[i])\\n                    if (!count[j].contains(c)) c1++;\\n                for (int c : count[j])\\n                    if (!count[i].contains(c)) c2++;\\n                res += c1 * c2;\\n            }\\n        return res * 2;\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/c5781ec6-933a-41a3-bef3-36b78d88f324_1675926810.1178758.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<Integer>[] count = new HashSet[26];\\n        for (int i = 0; i < 26; ++i)\\n            count[i] = new HashSet<>();\\n        for (String s : ideas)\\n            count[s.charAt(0) - \\'a\\'].add(s.substring(1).hashCode());\\n        long res = 0;\\n        for (int i = 0; i < 26; ++i)\\n            for (int j = i + 1; j < 26; ++j) {\\n                long c1 = 0, c2 = 0;\\n                for (int c : count[i])\\n                    if (!count[j].contains(c)) c1++;\\n                for (int c : count[j])\\n                    if (!count[i].contains(c)) c2++;\\n                res += c1 * c2;\\n            }\\n        return res * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315350,
                "title": "python3-10-lines-dict-w-example-and-explanation-t-m-99-65",
                "content": "Suppose, as an example, \\n```\\n         ideas = [azz, byy, cxx, cww, bww, avv]\\n```\\nHere\\'s the plan:\\n                          \\nWe construct a dict with each initial as the key and the set of suffixes accompanying that initial. For our example:\\n\\n```\\n        dct = {a:[zz,vv], b:[yy,ww], c:[xx,ww]}\\n```                        \\nNext, for each of the six pairs of prefixes in`dct`--`a,b`,`a,c`, and `b,c`--  we figure out the number of valid names. (Actually, there are twelve pairs, but we will deal with that at the end). \\n\\nFor the pair`a,b` we get:\\n```\\n    a, b -> ayy and bzz, ayy and bvv, aww and bzz, aww and bvv\\n```\\nwhich is (2 `a` suffixes) x (2 `b` suffixes) = 4. \\n                            \\n\\nContinuing, for the pair`a,c` we get:\\n```\\n    a, c -> axx and czz, axx and cvv, aww and czz, aww and cvv.\\n```\\nSo again, 2 x 2 = 4. \\n\\nAnd finally, for the pair`a,c` we get:\\n```\\n    b, c -> bxx and cyy, {bxx and cww, bww and cyy, bww and cww.}\\n``` \\nhas only one valid answer. The suffixes in the {} are invalid. The reason is that`ww`is in both suffixes. When we remove that common suffix from both sets, we have 1 x 1 = 1.\\n                        \\nFinally, we determine the answer to return. The sum of valid pairs is 4 + 4 + 1 = 9, and each valid pair can be reversed to give another pair with the same count, so we return the answer 2 x 9 = 18.\\n```\\nclass Solution:         \\n    def distinctNames(self, ideas: List[str]) -> int:\\n\\n        dct, ans = defaultdict(set), 0\\n\\n        for idea in ideas:                  # <-- construct the dict w/ \\n            dct[idea[0]].add(idea[1:])      #     w/ initial:{suffixes} and sort\\n                                            #     the items to get a list of \\n        d = sorted(dct.items())             #     tuples to help do the counting\\n\\n        for init1, suff1 in d:              # <-- evaluate the number for each pair \\n            for init2, suff2 in d:          #     of initials\\n                if init2 >= init1: break\\n\\n                c = len(suff1&suff2)        # <-- determine the count of suffixes in \\n                ans += ((len(suff1)-c)*     #     common, and subtract that count\\n                        (len(suff2)-c))     #     from the count of each suffix  \\n                                            #     count before multiplying.\\n\\n        return ans * 2                      # <-- finally, return the sum times 2.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n         ideas = [azz, byy, cxx, cww, bww, avv]\\n```\n```\\n        dct = {a:[zz,vv], b:[yy,ww], c:[xx,ww]}\\n```\n```\\n    a, b -> ayy and bzz, ayy and bvv, aww and bzz, aww and bvv\\n```\n```\\n    a, c -> axx and czz, axx and cvv, aww and czz, aww and cvv.\\n```\n```\\n    b, c -> bxx and cyy, {bxx and cww, bww and cyy, bww and cww.}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163694,
                "title": "c-set-map-brute-force-all-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Idea :** \\n- Brute force is easy  for all the pairs  check for those which are present in our vector are invlaid else valid so it can be simply done by using two loops but will be O(n^2)  so tle.\\n- Optimal can be done by some how eliminatig the repetition we are doing i.e we know there are only 26 letters that  a word  can start  from and we know if first letter of two strings are same they will be still the same after swaping so we don\\'t need them for our company name i.e they are invalid and  also if two strings having first letter different and rest  same they also cant be used because swapping them will result in two strings which are present already e.g coffee and toffee  swap c and t --> toffee and coffee so again they become one another so these are the two things where we are doing repetiton while they are not giving us some answer so if we make groups on the basis of first letter and check if suffix part is differnt of two groups they will be counted else not .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlgo:\\n- Take a set or map of 26 size which will store groups of strings where a group is based on first letter and we will store only suffix part . Set will automatically eleimate duolicates (so one thing is gone).\\n- Then we know only 26 letters are there so using two loops of size 25 X 26 just like doing brute force n*n we will check for a group i if it contains group j\\'s suffix strings or not if not count them  and vice-versa for i in j . \\n- Then no.of ditinct grouping = ci*cj *2 (2 is beacuse e.g `xah` `oor `and `oor` `xah` both can used as company names so mutually 2 times )\\n# Complexity\\n- Time complexity:$$O(n*m*25*26)$$ where n=ideas.size and m= ideas[i].size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N*26)$$ N=no.of strings in ideas vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**Brute Force**\\n```\\n#define ll long long \\n    long long distinctNames(vector<string>& ideas) {\\n        map<string,int>mp;\\n        int c=0,n=ideas.size();\\n        for(auto s:ideas)mp[s]++;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                string s1=ideas[i],s2=ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(mp[s1] or mp[s2]);\\n                else c++;\\n            }\\n        }\\n        return c;\\n    }\\n```\\n**Optimal**\\n\\n```C++ []\\n#define ll long long \\n    long long distinctNames(vector<string>& ideas) {\\n       unordered_set<string>st[26];\\n       ll ans=0;\\n       for(auto s:ideas){\\n           st[s[0]-\\'a\\'].insert(s.substr(1));\\n       }\\n       for(int i=0;i<25;i++){\\n           for(int j=i+1;j<26;j++){\\n               ll c1=0,c2=0;\\n               for(auto x:st[i])c1+=(!st[j].count(x));\\n               for(auto x:st[j])c2+=(!st[i].count(x));\\n               ans+=(c1*c2);\\n           }\\n       }\\n       ans*=2ll;\\n       return ans;\\n    }\\n```\\n\\n```C++ []\\n\\n#define ll long long \\n// Using map rest is same just wanna try \\n    long long distinctNames(vector<string>& ideas) {\\n       unordered_map<int,unordered_map<string,int>>mp;\\n       ll ans=0;\\n       for(auto s:ideas){\\n           mp[s[0]-\\'a\\'][(s.substr(1))]++;\\n       }\\n       for(int i=0;i<25;i++){\\n           for(int j=i+1;j<26;j++){\\n               ll c1=0,c2=0;\\n               for(auto x:mp[i])c1+=(!mp[j].count(x.first));\\n               for(auto x:mp[j])c2+=(!mp[i].count(x.first));\\n               ans+=(c1*c2*2ll);\\n           }\\n       }\\n     \\n       return ans;\\n    }\\n```\\n\\n\\n\\n# UPVOTE IF HELPFUL \\uD83D\\uDD3C\\uD83D\\uDD3C\\uD83D\\uDD3C\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "String Matching"
                ],
                "code": "```\\n#define ll long long \\n    long long distinctNames(vector<string>& ideas) {\\n        map<string,int>mp;\\n        int c=0,n=ideas.size();\\n        for(auto s:ideas)mp[s]++;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                string s1=ideas[i],s2=ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(mp[s1] or mp[s2]);\\n                else c++;\\n            }\\n        }\\n        return c;\\n    }\\n```\n```C++ []\\n#define ll long long \\n    long long distinctNames(vector<string>& ideas) {\\n       unordered_set<string>st[26];\\n       ll ans=0;\\n       for(auto s:ideas){\\n           st[s[0]-\\'a\\'].insert(s.substr(1));\\n       }\\n       for(int i=0;i<25;i++){\\n           for(int j=i+1;j<26;j++){\\n               ll c1=0,c2=0;\\n               for(auto x:st[i])c1+=(!st[j].count(x));\\n               for(auto x:st[j])c2+=(!st[i].count(x));\\n               ans+=(c1*c2);\\n           }\\n       }\\n       ans*=2ll;\\n       return ans;\\n    }\\n```\n```C++ []\\n\\n#define ll long long \\n// Using map rest is same just wanna try \\n    long long distinctNames(vector<string>& ideas) {\\n       unordered_map<int,unordered_map<string,int>>mp;\\n       ll ans=0;\\n       for(auto s:ideas){\\n           mp[s[0]-\\'a\\'][(s.substr(1))]++;\\n       }\\n       for(int i=0;i<25;i++){\\n           for(int j=i+1;j<26;j++){\\n               ll c1=0,c2=0;\\n               for(auto x:mp[i])c1+=(!mp[j].count(x.first));\\n               for(auto x:mp[j])c2+=(!mp[i].count(x.first));\\n               ans+=(c1*c2*2ll);\\n           }\\n       }\\n     \\n       return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163468,
                "title": "java-double-map-fully-explained-must-read",
                "content": "# Intuition\\nFor every given word in the array `ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]` we want to find out what possible transformations it has. For example if have the word `coffee` we want to transform it to all possible words with different starting characters.\\n\\na -> aoffee\\nb -> boffee\\n...\\n\\nOne optimization to make is that we only need to transform the word `coffee` to start with characters that exist in our `ideas` array. We only have 3 types of starting characters: `[c, d, t]`, so the transformation will be:\\n\\nd -> doffee\\nt -> toffee\\n\\nWhenever we make the transformations, we remove invalid ones. Note that `toffee` is invalid because it exists in the words array. - use a set for O(1) check.\\n\\nNow after making all the transformations, we need to multiply the inverse permutation of the transformation. Explanation:\\n\\nTo get to doffee we started from `c` -> `d`\\nThe inverse would be `d` -> `c`\\n\\nMultiplying them would account for all possible transformations between these two characters.\\n\\nContinue for all possible character transformation sets and assemble the results as we go.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        int n = ideas.length;\\n        Set<Character> uniqueChars = new HashSet<>();\\n        Set<String> ideasSet = Arrays.stream(ideas).collect(Collectors.toSet());\\n        for(int i = 0; i < n; i++) {\\n            uniqueChars.add(ideas[i].charAt(0));\\n        }\\n\\n        Map<Character, Map<Character, Integer>> charToCharToWordMap = new HashMap<>();\\n        for(String word : ideas) {\\n            char startingChar = word.charAt(0);\\n            charToCharToWordMap.computeIfAbsent(startingChar, k -> new HashMap<>());\\n            for(char c : uniqueChars) {\\n                String transformedWord = c + word.substring(1);\\n                if(!ideasSet.contains(transformedWord)) {\\n                    charToCharToWordMap.get(startingChar).computeIfAbsent(c, k -> 0);\\n                    charToCharToWordMap.get(startingChar).compute(c, (k, v) -> v + 1);\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for(char startingChar : charToCharToWordMap.keySet()) {\\n            for(char transformChar : charToCharToWordMap.get(startingChar).keySet()) {\\n                int transformationsFront = charToCharToWordMap.get(startingChar).get(transformChar);\\n                if(!charToCharToWordMap.containsKey(transformChar) || !charToCharToWordMap.get(transformChar).containsKey(startingChar)) continue;\\n                int transformationsBackward = charToCharToWordMap.get(transformChar).get(startingChar);\\n                ans += transformationsFront * transformationsBackward;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        int n = ideas.length;\\n        Set<Character> uniqueChars = new HashSet<>();\\n        Set<String> ideasSet = Arrays.stream(ideas).collect(Collectors.toSet());\\n        for(int i = 0; i < n; i++) {\\n            uniqueChars.add(ideas[i].charAt(0));\\n        }\\n\\n        Map<Character, Map<Character, Integer>> charToCharToWordMap = new HashMap<>();\\n        for(String word : ideas) {\\n            char startingChar = word.charAt(0);\\n            charToCharToWordMap.computeIfAbsent(startingChar, k -> new HashMap<>());\\n            for(char c : uniqueChars) {\\n                String transformedWord = c + word.substring(1);\\n                if(!ideasSet.contains(transformedWord)) {\\n                    charToCharToWordMap.get(startingChar).computeIfAbsent(c, k -> 0);\\n                    charToCharToWordMap.get(startingChar).compute(c, (k, v) -> v + 1);\\n                }\\n            }\\n        }\\n\\n        long ans = 0;\\n        for(char startingChar : charToCharToWordMap.keySet()) {\\n            for(char transformChar : charToCharToWordMap.get(startingChar).keySet()) {\\n                int transformationsFront = charToCharToWordMap.get(startingChar).get(transformChar);\\n                if(!charToCharToWordMap.containsKey(transformChar) || !charToCharToWordMap.get(transformChar).containsKey(startingChar)) continue;\\n                int transformationsBackward = charToCharToWordMap.get(transformChar).get(startingChar);\\n                ans += transformationsFront * transformationsBackward;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141087,
                "title": "c-explained",
                "content": "```\\n//Like if it helps you :)\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& v) {\\n        int n=v.size();\\n        unordered_set<string> u(v.begin(),v.end()); \\n        int mp[26][26]={0}; // mp[i][j] Store how many first letter i are good with having first letter j\\n        vector<vector<int>> d(n,vector<int>(26,0));   //Store whether string at i th index can have first letter as one of the [\\'a\\'...\\'z\\'] 26 alphabets\\n        for(int i=0;i<n;++i)\\n        {\\n            string r=v[i];\\n            for(int j=0;j<26;++j)\\n            {\\n                r[0]=\\'a\\'+j;\\n                if(u.find(r)==u.end())\\n                {\\n                    d[i][j]=1;\\n                    mp[v[i][0]-\\'a\\'][j]++;      //storing all the strings with first letter same as ith string which are good with having first letter\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //as jth alphabet\\n                }\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            for(int j=0;j<26;++j)\\n            {\\n                if(d[i][j])\\n                    ans+=mp[j][v[i][0]-\\'a\\'];  //since d[i][j]=1 therefore the ith index string can take j as first letter therefore we add\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  //all the string starting with \\'a\\'+j who are also good with having current ith strings first letter \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Like if it helps you :)\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& v) {\\n        int n=v.size();\\n        unordered_set<string> u(v.begin(),v.end()); \\n        int mp[26][26]={0}; // mp[i][j] Store how many first letter i are good with having first letter j\\n        vector<vector<int>> d(n,vector<int>(26,0));   //Store whether string at i th index can have first letter as one of the [\\'a\\'...\\'z\\'] 26 alphabets\\n        for(int i=0;i<n;++i)\\n        {\\n            string r=v[i];\\n            for(int j=0;j<26;++j)\\n            {\\n                r[0]=\\'a\\'+j;\\n                if(u.find(r)==u.end())\\n                {\\n                    d[i][j]=1;\\n                    mp[v[i][0]-\\'a\\'][j]++;      //storing all the strings with first letter same as ith string which are good with having first letter\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t //as jth alphabet\\n                }\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;++i)\\n        {\\n            for(int j=0;j<26;++j)\\n            {\\n                if(d[i][j])\\n                    ans+=mp[j][v[i][0]-\\'a\\'];  //since d[i][j]=1 therefore the ith index string can take j as first letter therefore we add\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  //all the string starting with \\'a\\'+j who are also good with having current ith strings first letter \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162509,
                "title": "c-java-python-simple-solution-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(26*26*n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(2+(26*26))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long DistinctNames(string[] ideas) {\\n        long distinctCompany = 0;\\n        Dictionary<char, HashSet<string>> dict = new Dictionary<char, HashSet<string>>();\\n        //Initially map the key as first letter from the hint of question and value is string\\n        foreach(var idea in ideas){\\n        if (!dict.ContainsKey(idea[0])){\\n            dict.Add(idea[0], new HashSet<string>());\\n            }\\n            dict[idea[0]].Add(idea);\\n        }\\n        Dictionary<char,Dictionary<char,long>> set = new Dictionary<char,Dictionary<char, long>>();\\n        //Generate All possible combinations of the company name\\n        foreach(var idea1 in dict.Keys)\\n        {\\n            set.Add(idea1, new Dictionary<char, long>());\\n            foreach(var idea2 in dict.Keys)\\n            {\\n                if (idea1 == idea2){\\n                    continue;\\n                }\\n                set[idea1].Add(idea2, 0);\\n                foreach(var str in dict[idea2])\\n                {\\n                    var posCompany = $\"{idea1}\" + str.Substring(1);\\n                    if (!dict[idea1].Contains(posCompany)){\\n                        set[idea1][idea2]++;\\n                    }\\n                }\\n            }\\n        }\\n        // Compute the which all are distinct.\\n        foreach (var idea1 in dict.Keys)\\n        {\\n            foreach (var idea2 in dict.Keys)\\n            {\\n                if (idea1 == idea2) continue;\\n                distinctCompany += set[idea1][idea2] * set[idea2][idea1];\\n            }\\n        }\\n        return distinctCompany;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public long DistinctNames(string[] ideas) {\\n        long distinctCompany = 0;\\n        Dictionary<char, HashSet<string>> dict = new Dictionary<char, HashSet<string>>();\\n        //Initially map the key as first letter from the hint of question and value is string\\n        foreach(var idea in ideas){\\n        if (!dict.ContainsKey(idea[0])){\\n            dict.Add(idea[0], new HashSet<string>());\\n            }\\n            dict[idea[0]].Add(idea);\\n        }\\n        Dictionary<char,Dictionary<char,long>> set = new Dictionary<char,Dictionary<char, long>>();\\n        //Generate All possible combinations of the company name\\n        foreach(var idea1 in dict.Keys)\\n        {\\n            set.Add(idea1, new Dictionary<char, long>());\\n            foreach(var idea2 in dict.Keys)\\n            {\\n                if (idea1 == idea2){\\n                    continue;\\n                }\\n                set[idea1].Add(idea2, 0);\\n                foreach(var str in dict[idea2])\\n                {\\n                    var posCompany = $\"{idea1}\" + str.Substring(1);\\n                    if (!dict[idea1].Contains(posCompany)){\\n                        set[idea1][idea2]++;\\n                    }\\n                }\\n            }\\n        }\\n        // Compute the which all are distinct.\\n        foreach (var idea1 in dict.Keys)\\n        {\\n            foreach (var idea2 in dict.Keys)\\n            {\\n                if (idea1 == idea2) continue;\\n                distinctCompany += set[idea1][idea2] * set[idea2][idea1];\\n            }\\n        }\\n        return distinctCompany;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147565,
                "title": "python-faster-than-100-groupby-detailed-explanation",
                "content": "Idea and explanation:\\n- create a dict \\'names\\' that stores all the distinct first letters available in ideas along with the following suffixes. \\n- \\'arr\\' stores list of all distinct first-letter prefix available in ideas\\n- pick two letters, a and b, from \\'arr\\' and count all the possible words that can be formed by interchanging both their suffixes in names[a] and names[b]\\n- multiplying  count by 2 as the new word formed might be \"newword1 newword2\" or \"newword2 newword1\"\\n\\n- Eg: [\"coffee\",\"donuts\",\"time\",\"toffee\"]\\n\\t names={\\'c\\':(\\'offee\\'), \\'d\\':(\\'onuts\\'), \\'t\\':(\\'ime\\',\\'offee\\')}\\n\\t arr=[\\'c\\', \\'d\\', \\'t\\']\\n\\t\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        \\n        names=defaultdict(set)\\n        res=0  \\n        \\n        #to store first letter as key and followed suffix as val\\n        for i in ideas:\\n            names[i[0]].add(i[1:])\\n            \\n        #list of distinct first-letters available in ideas (may or may not contain all alphabets,depends upon elements in ideas)\\n        arr=list(names.keys())\\n        ans,n=0,len(arr)\\n        \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                #a,b => 2 distinct first letters\\n                a,b=arr[i],arr[j]\\n                # adding the number of distinct posssible suffixes and multiplying by 2 as the new word formed might be \"newword1 newword2\" or \"newword2 newword1\"\\n                res+=len(names[a]-names[b])*len(names[b]-names[a])*2\\n                \\n        return res\\n\\t\\n```\\n\\n### **Runtime:** 1004 ms, faster than 100.00% of Python3 online submissions for Naming a Company.\\n### **Memory Usage:** 28.9 MB, less than 25.00% of Python3 online submissions for Naming a Company\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        \\n        names=defaultdict(set)\\n        res=0  \\n        \\n        #to store first letter as key and followed suffix as val\\n        for i in ideas:\\n            names[i[0]].add(i[1:])\\n            \\n        #list of distinct first-letters available in ideas (may or may not contain all alphabets,depends upon elements in ideas)\\n        arr=list(names.keys())\\n        ans,n=0,len(arr)\\n        \\n        for i in range(n):\\n            for j in range(i+1,n):\\n                #a,b => 2 distinct first letters\\n                a,b=arr[i],arr[j]\\n                # adding the number of distinct posssible suffixes and multiplying by 2 as the new word formed might be \"newword1 newword2\" or \"newword2 newword1\"\\n                res+=len(names[a]-names[b])*len(names[b]-names[a])*2\\n                \\n        return res\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141435,
                "title": "c-easy-hash-map-beat-100-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n\\t\\t// char -> {string1[1:], string2[1:], ...}\\n        unordered_map<char, unordered_set<string>> hashMap;\\n        for (auto& idea : ideas) {\\n            hashMap[idea[0]].insert(idea.substr(1));\\n        }\\n        long long res = 0;\\n\\t\\t// iterate all char pairs\\n\\t\\t// i.e., a->b, a->c, ... y->z\\n        for (int i = 0; i < 26; ++i) {\\n            for (int j = i + 1; j < 26; ++j) {\\n                char a = i + \\'a\\';\\n                char b = j + \\'a\\';\\n                auto& setA = hashMap[a];\\n                auto& setB = hashMap[b];\\n\\t\\t\\t\\t// count the intersections between two groups\\n                int intersect = 0;\\n                for (auto& s : setA) {\\n                    if (setB.find(s) != setB.end()) intersect++;\\n                }\\n\\t\\t\\t\\t// to get the # of string[1:] in both groups without any intersections\\n                int setADiff = setA.size() - intersect;\\n                int setBDiff = setB.size() - intersect;\\n\\t\\t\\t\\t// *2: a->b & b->a\\n                res += (long long)setADiff * setBDiff * 2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n\\t\\t// char -> {string1[1:], string2[1:], ...}\\n        unordered_map<char, unordered_set<string>> hashMap;\\n        for (auto& idea : ideas) {\\n            hashMap[idea[0]].insert(idea.substr(1));\\n        }\\n        long long res = 0;\\n\\t\\t// iterate all char pairs\\n\\t\\t// i.e., a->b, a->c, ... y->z\\n        for (int i = 0; i < 26; ++i) {\\n            for (int j = i + 1; j < 26; ++j) {\\n                char a = i + \\'a\\';\\n                char b = j + \\'a\\';\\n                auto& setA = hashMap[a];\\n                auto& setB = hashMap[b];\\n\\t\\t\\t\\t// count the intersections between two groups\\n                int intersect = 0;\\n                for (auto& s : setA) {\\n                    if (setB.find(s) != setB.end()) intersect++;\\n                }\\n\\t\\t\\t\\t// to get the # of string[1:] in both groups without any intersections\\n                int setADiff = setA.size() - intersect;\\n                int setBDiff = setB.size() - intersect;\\n\\t\\t\\t\\t// *2: a->b & b->a\\n                res += (long long)setADiff * setBDiff * 2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164471,
                "title": "java-hashtable-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\nThe idea is to group the words based on their first characters.\\nWe will have the first characters as **keys** and the suffices of the words after the first characters as the **values**.\\n\\nSay we have `time` and `toffee`. \\nOur mapping would look something like: `\\'t\\' -> {\\'ofee\", \"ime\"}`\\n\\nThen we would try to form words by iterating over the map.\\nFor a current first character, we would try to form words with the suffices of the rest of the first characters.\\n\\n---\\n\\n### Code:\\n``` java []\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        // map each first character to its suffix\\n        // {c=[offee], d=[onuts], t=[ime, offee]}\\n        Map<Character, Set<String>> map = new HashMap<>();\\n        for (String s : ideas) {\\n            map.putIfAbsent(s.charAt(0), new HashSet<>());\\n            map.get(s.charAt(0)).add(s.substring(1, s.length()));\\n        }\\n\\n        long ans = 0;\\n        // for each first character, we would try to form a word \\n        // with the suffices of every other first characters\\n        // for \\'c\\', we would try to make a word with suffix of \\'d\\' and \\'t\\'\\n        // that is \\'c\\' with \"onuts\" and then \\'c\\' with \"offee\", \"ime\"\\n        for (char c1 : map.keySet()) {\\n            for (char c2 : map.keySet()) {\\n                // we don\\'t want to make word with suffix of the same character\\n                // no word making for \\'c\\' with \"offee\" of \\'c\\' again\\n                if (c1 == c2) {\\n                    continue;   // so skip\\n                }\\n\\n                // now we know other characters might have same suffices like current character\\n                // like \"offee\" is present for both \\'c\\' and \\'t\\'\\n                // therefore to count the number of duplicacies we will initialize a variable\\n                int common = 0;\\n                // now we would go through all the suffices of current character\\n                // and see if the other character has a same suffix or not\\n                for (String suffix : map.get(c1)) {\\n                    // if yes, we found a duplicate\\n                    // that means, if we swap first characters, the pair is going to be same\\n                    // example: \\'c\\' and \\'t\\' has suffix \"offee\"\\n                    // swapping \\'c\\' and \\'t\\' would give us the same word again\\n                    if (map.get(c2).contains(suffix)) {\\n                        common++;   // so increment the variable\\n                    }\\n                }\\n                \\n                // now we need the number of distinct suffices in both sets\\n                // i.e. nothing but number of suffices minus common suffices\\n                // because we don\\'t want to consider common suffices which would lead same word\\n                int distinct1 = map.get(c1).size() - common;\\n                int distinct2 = map.get(c2).size() - common;\\n                // number of distinct combinations is product of the \\n                // number of distinct suffices from both sets\\n                ans += distinct1 * distinct2;   // add that value to answer variable\\n\\n                // why did\\'t we I multiply by 2?\\n                // Say we are at \\'c\\', it\\'ll do the computations for \\'d\\' and \\'t\\'\\n                // when we are d, it\\'ll do the computations of \\'c\\' and \\'t\\'\\n                // when we are at \\'t\\', we would do the computations for \\'c\\' and \\'d\\'\\n                // that is, we are checking twice. \\'d\\' with \\'c\\' and then again \\'c\\' with \\'d\\'.\\n                // so our looping is going to handle that situation\\n            }\\n        }\\n\\n        // at the end return the answer variable storing the number of unique combinations\\n        return ans;\\n    }\\n}\\n```\\n### Clean solution:\\n``` java []\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        Map<Character, Set<String>> map = new HashMap<>();\\n        for (String s : ideas) {\\n            map.putIfAbsent(s.charAt(0), new HashSet<>());\\n            map.get(s.charAt(0)).add(s.substring(1, s.length()));\\n        }\\n\\n        long ans = 0;\\n        for (char c1 : map.keySet()) {\\n            for (char c2 : map.keySet()) {\\n                if (c1 == c2) {\\n                    continue;   \\n                }\\n\\n                int common = 0;\\n                for (String suffix : map.get(c1)) {\\n                    if (map.get(c2).contains(suffix)) {\\n                        common++;   \\n                    }\\n                }\\n                \\n                int distinct1 = map.get(c1).size() - common;\\n                int distinct2 = map.get(c2).size() - common;\\n                ans += distinct1 * distinct2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n---\\n## Complexity analysis:\\n---\\n#### Time complexity:\\n\\nLet\\'s say we have `n` words (sounds sus) in the given array `ideas`. We loop through the array to populate our hashmap costing an $$O(n)$$.\\n\\nThen we iterate over the keyset of the map which stores characters. At max there can be $$26$$ characters. We has a nested for loop again inside it traversing the keyset. So we have a $$O(26^2)$$ so far.\\n\\nInside the previous loop, we iterate over the set which contains the suffices of the characters that can be $$n$$ at max.\\n\\nSo this makes up a $$O(26^2 * n)$$\\n\\nTherefore total **Time complexity**: $$O(n + 26^2*n)$$\\n\\n---\\n#### Space complexity:\\nWe can have at max $$26$$ characters in the keyset and each of them can have $$n$$ suffices mapped to them.\\n\\nTherefore **Space complexity**: $$O(26*n) => O(n)$$\\n\\n---\\n\\n\\u2714\\uFE0F ***You can watch the video by NeetCode on youtube to understand the solution*** \\u2714\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        // map each first character to its suffix\\n        // {c=[offee], d=[onuts], t=[ime, offee]}\\n        Map<Character, Set<String>> map = new HashMap<>();\\n        for (String s : ideas) {\\n            map.putIfAbsent(s.charAt(0), new HashSet<>());\\n            map.get(s.charAt(0)).add(s.substring(1, s.length()));\\n        }\\n\\n        long ans = 0;\\n        // for each first character, we would try to form a word \\n        // with the suffices of every other first characters\\n        // for \\'c\\', we would try to make a word with suffix of \\'d\\' and \\'t\\'\\n        // that is \\'c\\' with \"onuts\" and then \\'c\\' with \"offee\", \"ime\"\\n        for (char c1 : map.keySet()) {\\n            for (char c2 : map.keySet()) {\\n                // we don\\'t want to make word with suffix of the same character\\n                // no word making for \\'c\\' with \"offee\" of \\'c\\' again\\n                if (c1 == c2) {\\n                    continue;   // so skip\\n                }\\n\\n                // now we know other characters might have same suffices like current character\\n                // like \"offee\" is present for both \\'c\\' and \\'t\\'\\n                // therefore to count the number of duplicacies we will initialize a variable\\n                int common = 0;\\n                // now we would go through all the suffices of current character\\n                // and see if the other character has a same suffix or not\\n                for (String suffix : map.get(c1)) {\\n                    // if yes, we found a duplicate\\n                    // that means, if we swap first characters, the pair is going to be same\\n                    // example: \\'c\\' and \\'t\\' has suffix \"offee\"\\n                    // swapping \\'c\\' and \\'t\\' would give us the same word again\\n                    if (map.get(c2).contains(suffix)) {\\n                        common++;   // so increment the variable\\n                    }\\n                }\\n                \\n                // now we need the number of distinct suffices in both sets\\n                // i.e. nothing but number of suffices minus common suffices\\n                // because we don\\'t want to consider common suffices which would lead same word\\n                int distinct1 = map.get(c1).size() - common;\\n                int distinct2 = map.get(c2).size() - common;\\n                // number of distinct combinations is product of the \\n                // number of distinct suffices from both sets\\n                ans += distinct1 * distinct2;   // add that value to answer variable\\n\\n                // why did\\'t we I multiply by 2?\\n                // Say we are at \\'c\\', it\\'ll do the computations for \\'d\\' and \\'t\\'\\n                // when we are d, it\\'ll do the computations of \\'c\\' and \\'t\\'\\n                // when we are at \\'t\\', we would do the computations for \\'c\\' and \\'d\\'\\n                // that is, we are checking twice. \\'d\\' with \\'c\\' and then again \\'c\\' with \\'d\\'.\\n                // so our looping is going to handle that situation\\n            }\\n        }\\n\\n        // at the end return the answer variable storing the number of unique combinations\\n        return ans;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        Map<Character, Set<String>> map = new HashMap<>();\\n        for (String s : ideas) {\\n            map.putIfAbsent(s.charAt(0), new HashSet<>());\\n            map.get(s.charAt(0)).add(s.substring(1, s.length()));\\n        }\\n\\n        long ans = 0;\\n        for (char c1 : map.keySet()) {\\n            for (char c2 : map.keySet()) {\\n                if (c1 == c2) {\\n                    continue;   \\n                }\\n\\n                int common = 0;\\n                for (String suffix : map.get(c1)) {\\n                    if (map.get(c2).contains(suffix)) {\\n                        common++;   \\n                    }\\n                }\\n                \\n                int distinct1 = map.get(c1).size() - common;\\n                int distinct2 = map.get(c2).size() - common;\\n                ans += distinct1 * distinct2;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141445,
                "title": "c-tc-o-n-sc-o-n-counting-swaps",
                "content": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        int n = ideas.size();\\n        unordered_set<string> idea;\\n        for(int i=0; i<n; i++)\\n            idea.insert(ideas[i]);\\n        \\n        vector<vector<int>> count(26, vector<int>(26));\\n        \\n        for(int i=0; i<n; i++){\\n            string temp = ideas[i];\\n            int s = ideas[i][0]-\\'a\\';\\n            for(int j=0; j<26; j++){\\n                temp[0] = j+\\'a\\';\\n                if(idea.find(temp) == idea.end()){\\n                    count[s][j]++;\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        for(int i=0; i<26; i++){\\n            for(int j=0; j<26; j++){\\n                res += count[i][j]*count[j][i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        int n = ideas.size();\\n        unordered_set<string> idea;\\n        for(int i=0; i<n; i++)\\n            idea.insert(ideas[i]);\\n        \\n        vector<vector<int>> count(26, vector<int>(26));\\n        \\n        for(int i=0; i<n; i++){\\n            string temp = ideas[i];\\n            int s = ideas[i][0]-\\'a\\';\\n            for(int j=0; j<26; j++){\\n                temp[0] = j+\\'a\\';\\n                if(idea.find(temp) == idea.end()){\\n                    count[s][j]++;\\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        for(int i=0; i<26; i++){\\n            for(int j=0; j<26; j++){\\n                res += count[i][j]*count[j][i];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140922,
                "title": "c-dp-counting-pairs",
                "content": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string, bool> m;\\n        set<char> charSet;\\n        \\n        for (string& idea : ideas) {\\n            m[idea] = true;\\n            charSet.insert(idea[0]);\\n        }\\n        \\n        vector<vector<long long>> dp(26, vector<long long>(26,0));\\n        \\n        for (string& idea : ideas) {\\n            char startingChar = idea[0];\\n            for (char targetChar : charSet) {\\n                idea[0] = targetChar;\\n                if (m.count(idea) == 0) {\\n                    dp[startingChar-\\'a\\'][targetChar-\\'a\\']++; \\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        \\n        for (char startingChar : charSet) {\\n            for (char targetChar : charSet) {\\n                if (startingChar != targetChar) {\\n                    res += dp[startingChar-\\'a\\'][targetChar-\\'a\\'] * dp[targetChar-\\'a\\'][startingChar-\\'a\\'];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string, bool> m;\\n        set<char> charSet;\\n        \\n        for (string& idea : ideas) {\\n            m[idea] = true;\\n            charSet.insert(idea[0]);\\n        }\\n        \\n        vector<vector<long long>> dp(26, vector<long long>(26,0));\\n        \\n        for (string& idea : ideas) {\\n            char startingChar = idea[0];\\n            for (char targetChar : charSet) {\\n                idea[0] = targetChar;\\n                if (m.count(idea) == 0) {\\n                    dp[startingChar-\\'a\\'][targetChar-\\'a\\']++; \\n                }\\n            }\\n        }\\n        \\n        long long res = 0;\\n        \\n        for (char startingChar : charSet) {\\n            for (char targetChar : charSet) {\\n                if (startingChar != targetChar) {\\n                    res += dp[startingChar-\\'a\\'][targetChar-\\'a\\'] * dp[targetChar-\\'a\\'][startingChar-\\'a\\'];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164171,
                "title": "explained-in-easy-language-for-beginner-fast-and-efficient-code",
                "content": "# Intuition\\nThe brute force approach for this problem will be to check every pair for the given situation that wether the any of the strings already exits in the array after swaping their first letter.\\n\\nThis approach will be of O(n^2) time complexity and O(n) space complexity for storing a hashmap of the ideas.\\n\\n->We can optimize it by not checking for pairs which have common prefix (first letter) and common suffix (i.e. rest of the string expect the first letter).\\n\\nWe can use this optimization to create another approach that will be of better time complexity.\\n\\n# Approach\\nIn this approach we will create a unordered map with the prefix as the key and a set of suffixes will the value of the key.\\nAs in the first test case the map look something like this:-\\n{\\nc : (offee),\\nd : (onuts),\\nt : (ime,offee)\\n}\\nIn the worst case there will be 26 entries(sets) in the map.\\nNow we only have to compare sets with different prefixes because words with common prefix do not satisfy the condition of the problem.\\nFor example (time and toffee) will never satisfy the situation.\\n\\nNow we will compare every set with another set. To do so we will run a loop from a to z.\\n\\nWe also have to for common suffixes in a set because they also do not satisfy the situation.\\n\\nWe can find the number of name that can be made form a set by this formula:-\\nnames=2*(number of elements in 1st set - number of mutual suffixes)*(number of elements in 2nd set - number of mutual suffixes)\\n2 because each pair will make 2 names.\\n\\n# Complexity\\n- Time complexity:  O(n*m)\\n1. Where m is the average number of elements in a stack and n is the number of elements in the arrray.\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    long long distinctNames(vector<string>& ideas) {\\n        //unordered map and set because finding an element will be  of O(1)\\n        unordered_map<char,unordered_set<string>> m;\\n        long long res=0;\\n        //creating the map with 1st letter as key and the rest will be in the set \\n        for (auto idea:ideas) m[idea[0]].insert(idea.substr(1));\\n        for(char i=\\'a\\';i<\\'z\\';i++){ //this loop will run from a to y \\n            for(char j=i+1;j<=\\'z\\';j++){\\n                int mutual=0;\\n                for(auto x:m[i]){//checking for mutual elements in the pair of sets\\n                    if(m[j].find(x)!=m[j].end()) mutual++;\\n                }\\n                res+=2*(m[i].size()-mutual)*(m[j].size()-mutual);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long distinctNames(vector<string>& ideas) {\\n        //unordered map and set because finding an element will be  of O(1)\\n        unordered_map<char,unordered_set<string>> m;\\n        long long res=0;\\n        //creating the map with 1st letter as key and the rest will be in the set \\n        for (auto idea:ideas) m[idea[0]].insert(idea.substr(1));\\n        for(char i=\\'a\\';i<\\'z\\';i++){ //this loop will run from a to y \\n            for(char j=i+1;j<=\\'z\\';j++){\\n                int mutual=0;\\n                for(auto x:m[i]){//checking for mutual elements in the pair of sets\\n                    if(m[j].find(x)!=m[j].end()) mutual++;\\n                }\\n                res+=2*(m[i].size()-mutual)*(m[j].size()-mutual);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163618,
                "title": "python3-523-ms-faster-than-98-91-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/46a7c854-9285-409d-a09b-190e0882962c_1675934282.9071867.png)\\n```\\ndef distinctNames(self, ideas: List[str]) -> int:\\n        dic = defaultdict(set)\\n        ans = 0\\n        for i in ideas:\\n            dic[i[0]].add(i[1:])\\n        for i in dic.keys():\\n            for j in dic.keys():\\n                if i>=j:\\n                    continue\\n                same = len(dic[i] & dic[j])\\n                ans+= (2 * (len(dic[i])-same) * (len(dic[j])-same))\\n        return ans\\n```\\nThe code implements a solution to the problem of finding the number of distinct valid names for a company. Here\\'s a step-by-step description of the code:\\n\\n1. The code starts by initializing an empty dictionary dic and a variable ans that will store the final answer. The dictionary will be used to store the first letter of each name as the key and the rest of the name as a set of values.\\n1. In the next step, the code iterates through the ideas list and adds each name to the dictionary. The first letter of the name is used as the key, and the rest of the name is added as a value to the set associated with that key.\\n1. The code then iterates over the keys of the dictionary and for each pair of keys i and j (where i >= j), the code calculates the number of common elements in the sets associated with keys i and j. The code calculates the number of distinct valid names as 2 * (len(dic[i]) - same) * (len(dic[j]) - same), where same is the number of common elements in the sets associated with keys i and j. This result is added to the ans variable.\\n1. Finally, the code returns the value of the ans variable, which represents the total number of distinct valid names for the company.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\ndef distinctNames(self, ideas: List[str]) -> int:\\n        dic = defaultdict(set)\\n        ans = 0\\n        for i in ideas:\\n            dic[i[0]].add(i[1:])\\n        for i in dic.keys():\\n            for j in dic.keys():\\n                if i>=j:\\n                    continue\\n                same = len(dic[i] & dic[j])\\n                ans+= (2 * (len(dic[i])-same) * (len(dic[j])-same))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3163428,
                "title": "two-solutions-using-trie-and-map-highly-commented",
                "content": "# Complexity\\n- Time complexity:\\nO(26*(maxlength)*n)\\n\\n- Space complexity:\\nO((maxlen)*n)\\n\\n# Code Using Map (87/89 Test Case passed TLE)\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>&ideas) \\n    {\\n        unordered_map<string,bool>exists;\\n        vector<vector<int>>indexesatchar(26,vector<int>(0));\\n        for(int i=0;i<ideas.size();i++)\\n        {\\n            exists[ideas[i]]=true;\\n            indexesatchar[ideas[i][0]-\\'a\\'].push_back(i);\\n        }\\n        vector<vector<int>>replace(26,vector<int>(0));\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            for(char x=\\'a\\';x<=\\'z\\';x++)\\n            {\\n                int notexist=0;\\n                for(auto j:indexesatchar[ch-\\'a\\'])\\n                {\\n                    ideas[j][0]=x;\\n                    if(!exists[ideas[j]])\\n                    {\\n                        notexist++;\\n                    }\\n                }\\n                replace[ch-\\'a\\'].push_back(notexist);\\n            }\\n        }\\n        long long ans=0;\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            for(char x=ch;x<=\\'z\\';x++)\\n            {\\n                ans+=replace[ch-\\'a\\'][x-\\'a\\']*replace[x-\\'a\\'][ch-\\'a\\'];\\n            }\\n        }\\n        ans*=2;\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code Using Trie (AC)\\n```\\nclass Solution {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* child[26];//node pointing to other 26 possible nodes...if they dont exist then null\\n        bool flag=false;//for knowing if the node is the end of a possible word or not\\n        bool Inserted=false;//to avoid duplicates in ans...if the word already inserted\\n        string str;//keeping record of string that has made its way to here\\n        bool containChar(char character)\\n        {\\n            return (child[character-\\'a\\']!=NULL);//to see if the node contains the character as next node\\n        }\\n        void putNode(char nxtchar,TrieNode* node)\\n        {\\n            child[nxtchar-\\'a\\']=node;//if next character doesnt exist in trie the to insert\\n        }\\n        TrieNode* getNode(char character)\\n        {\\n            return child[character-\\'a\\'];//maybe traverse the trie further if we get our way in dfs\\n        }\\n        void setEnd()\\n        {\\n            flag=true;//sets end tag to node denoting it being end of one word\\n        }\\n        bool isEnd()\\n        {\\n            return flag;//to know if its the end or not\\n        }\\n        bool didInsert()\\n        {\\n            return Inserted;//self explanatory\\n        }\\n        void setdidInsert()\\n        {\\n            Inserted=true;//      \"\\n        }\\n    };\\n    TrieNode* root=new TrieNode();//publicly define root of our Trie\\n    void insertWord(string word)//insert words from vector given into our Trie\\n    {\\n        TrieNode* node=root;\\n        int i;\\n        for(i=0;i<word.size();i++)\\n        {\\n            if(node->containChar(word[i])==false)\\n            {\\n                node->putNode(word[i],new TrieNode());//if not present then insert\\n            }\\n            node=node->getNode(word[i]);//traverse further in trie (now that the character is inserted if it didnt exist before)\\n        }\\n        node->setEnd();//set end to final node after traversal of word\\n        node->str=word;//assign str\\n    }\\n    bool stringpresence(string &word)//to find string presence (similiar to insert word, just here we are checking the presence and incrementing the string pointer)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->containChar(word[i])==false)\\n            {\\n                return false;\\n            }\\n            node=node->getNode(word[i]);\\n        }\\n        return node->isEnd();//it could be that the string is prefix of some existing one....so to make sure, we check if it\\'s terminal or not\\n    }\\n    long long distinctNames(vector<string>&ideas) \\n    {\\n        vector<vector<int>>indexesatchar(26,vector<int>(0));\\n        for(int i=0;i<ideas.size();i++)\\n        {\\n            insertWord(ideas[i]);//inserting word\\n            indexesatchar[ideas[i][0]-\\'a\\'].push_back(i);//indexes with first char as \\'a\\' or \\'b\\' or other respective character is appended with the index in ideas the word is present at\\n        }\\n        vector<vector<int>>replace(26,vector<int>(0));\\n        //replace all the first characters of indexesatchar of the sets of strings starting with \\'a\\'/\\'b\\'/\\'c\\'....\\'z\\' with other alphabets in \\'a\\' to \\'z\\' and check their existence and incrementing count if doesn\\'t existand build adjacency matrix\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            for(char x=\\'a\\';x<=\\'z\\';x++)\\n            {\\n                int notexist=0;\\n                for(auto j:indexesatchar[ch-\\'a\\'])\\n                {\\n                    ideas[j][0]=x;\\n                    if(!stringpresence(ideas[j]))\\n                    {\\n                        notexist++;\\n                    }\\n                }\\n                replace[ch-\\'a\\'].push_back(notexist);\\n            }\\n        }\\n        //now we have adjacency matrix (vector<vector<int>>) where the ith row denotes that \"if we replace the (char)(i+97) of the strings having it as first character with the character (char)(j+97) (denoted by the jth column) then how many strings won\\'t exist in \"ideas\"(the guven vector of strings)....which means that we can choose them with the set of strings which don\\'t exist when their first character of (char)(j+97) is replaced by (char)(i+97) (denoted by count at row j and column i)...so we multiply them and add in our final ans.\\n        long long ans=0;\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            for(char x=ch;x<=\\'z\\';x++)\\n            {\\n                ans+=replace[ch-\\'a\\'][x-\\'a\\']*replace[x-\\'a\\'][ch-\\'a\\'];\\n            }\\n        }\\n        ans*=2;//the valid pairs are also valid when words are interchanged\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>&ideas) \\n    {\\n        unordered_map<string,bool>exists;\\n        vector<vector<int>>indexesatchar(26,vector<int>(0));\\n        for(int i=0;i<ideas.size();i++)\\n        {\\n            exists[ideas[i]]=true;\\n            indexesatchar[ideas[i][0]-\\'a\\'].push_back(i);\\n        }\\n        vector<vector<int>>replace(26,vector<int>(0));\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            for(char x=\\'a\\';x<=\\'z\\';x++)\\n            {\\n                int notexist=0;\\n                for(auto j:indexesatchar[ch-\\'a\\'])\\n                {\\n                    ideas[j][0]=x;\\n                    if(!exists[ideas[j]])\\n                    {\\n                        notexist++;\\n                    }\\n                }\\n                replace[ch-\\'a\\'].push_back(notexist);\\n            }\\n        }\\n        long long ans=0;\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            for(char x=ch;x<=\\'z\\';x++)\\n            {\\n                ans+=replace[ch-\\'a\\'][x-\\'a\\']*replace[x-\\'a\\'][ch-\\'a\\'];\\n            }\\n        }\\n        ans*=2;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    struct TrieNode\\n    {\\n        TrieNode* child[26];//node pointing to other 26 possible nodes...if they dont exist then null\\n        bool flag=false;//for knowing if the node is the end of a possible word or not\\n        bool Inserted=false;//to avoid duplicates in ans...if the word already inserted\\n        string str;//keeping record of string that has made its way to here\\n        bool containChar(char character)\\n        {\\n            return (child[character-\\'a\\']!=NULL);//to see if the node contains the character as next node\\n        }\\n        void putNode(char nxtchar,TrieNode* node)\\n        {\\n            child[nxtchar-\\'a\\']=node;//if next character doesnt exist in trie the to insert\\n        }\\n        TrieNode* getNode(char character)\\n        {\\n            return child[character-\\'a\\'];//maybe traverse the trie further if we get our way in dfs\\n        }\\n        void setEnd()\\n        {\\n            flag=true;//sets end tag to node denoting it being end of one word\\n        }\\n        bool isEnd()\\n        {\\n            return flag;//to know if its the end or not\\n        }\\n        bool didInsert()\\n        {\\n            return Inserted;//self explanatory\\n        }\\n        void setdidInsert()\\n        {\\n            Inserted=true;//      \"\\n        }\\n    };\\n    TrieNode* root=new TrieNode();//publicly define root of our Trie\\n    void insertWord(string word)//insert words from vector given into our Trie\\n    {\\n        TrieNode* node=root;\\n        int i;\\n        for(i=0;i<word.size();i++)\\n        {\\n            if(node->containChar(word[i])==false)\\n            {\\n                node->putNode(word[i],new TrieNode());//if not present then insert\\n            }\\n            node=node->getNode(word[i]);//traverse further in trie (now that the character is inserted if it didnt exist before)\\n        }\\n        node->setEnd();//set end to final node after traversal of word\\n        node->str=word;//assign str\\n    }\\n    bool stringpresence(string &word)//to find string presence (similiar to insert word, just here we are checking the presence and incrementing the string pointer)\\n    {\\n        TrieNode* node=root;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            if(node->containChar(word[i])==false)\\n            {\\n                return false;\\n            }\\n            node=node->getNode(word[i]);\\n        }\\n        return node->isEnd();//it could be that the string is prefix of some existing one....so to make sure, we check if it\\'s terminal or not\\n    }\\n    long long distinctNames(vector<string>&ideas) \\n    {\\n        vector<vector<int>>indexesatchar(26,vector<int>(0));\\n        for(int i=0;i<ideas.size();i++)\\n        {\\n            insertWord(ideas[i]);//inserting word\\n            indexesatchar[ideas[i][0]-\\'a\\'].push_back(i);//indexes with first char as \\'a\\' or \\'b\\' or other respective character is appended with the index in ideas the word is present at\\n        }\\n        vector<vector<int>>replace(26,vector<int>(0));\\n        //replace all the first characters of indexesatchar of the sets of strings starting with \\'a\\'/\\'b\\'/\\'c\\'....\\'z\\' with other alphabets in \\'a\\' to \\'z\\' and check their existence and incrementing count if doesn\\'t existand build adjacency matrix\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            for(char x=\\'a\\';x<=\\'z\\';x++)\\n            {\\n                int notexist=0;\\n                for(auto j:indexesatchar[ch-\\'a\\'])\\n                {\\n                    ideas[j][0]=x;\\n                    if(!stringpresence(ideas[j]))\\n                    {\\n                        notexist++;\\n                    }\\n                }\\n                replace[ch-\\'a\\'].push_back(notexist);\\n            }\\n        }\\n        //now we have adjacency matrix (vector<vector<int>>) where the ith row denotes that \"if we replace the (char)(i+97) of the strings having it as first character with the character (char)(j+97) (denoted by the jth column) then how many strings won\\'t exist in \"ideas\"(the guven vector of strings)....which means that we can choose them with the set of strings which don\\'t exist when their first character of (char)(j+97) is replaced by (char)(i+97) (denoted by count at row j and column i)...so we multiply them and add in our final ans.\\n        long long ans=0;\\n        for(char ch=\\'a\\';ch<=\\'z\\';ch++)\\n        {\\n            for(char x=ch;x<=\\'z\\';x++)\\n            {\\n                ans+=replace[ch-\\'a\\'][x-\\'a\\']*replace[x-\\'a\\'][ch-\\'a\\'];\\n            }\\n        }\\n        ans*=2;//the valid pairs are also valid when words are interchanged\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163351,
                "title": "two-approaches-with-easy-to-understand-code",
                "content": "# Code approach 1 [Brute Force]\\n```\\nclass Solution {\\npublic:\\n//app 1: gives tle\\n    long long distinctNames(vector<string>& s) {\\n        int n=s.size();\\n        unordered_set<string> st;\\n\\n        for(string &w: s) st.insert(w);\\n        long long ans=0;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                string w1=s[i];\\n                string w2=s[j];\\n                //cout<<j<<\" \"<<w2<<endl;\\n                //check condtn\\n                if(w1[0] != w2[0]){\\n                    swap(w1[0],w2[0]);\\n                    //cout<<w1<<\" \"<<w2<<endl;\\n                    if(st.find(w1) == st.end() &&\\n                       st.find(w2) == st.end()){\\n                           ans += 2;\\n                       }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n# Code approach 2 [Accepted]\\n```\\nclass Solution {\\npublic:\\n//app 2: O(n*m)\\n    long long distinctNames(vector<string>& s) {\\n        int n=s.size();\\n\\n        //make an array of set\\n        unordered_set<string> st[26];\\n\\n       //group words by initials [a to z]\\n        for(string &w: s){\\n            st[w[0] - \\'a\\'].insert(w.substr(1));\\n        }\\n\\n        long long ans=0;\\n        for(int i=0; i<26; i++){\\n            for(int j=i+1; j<26; j++){\\n                int mutual=0;\\n                //find mutual words \\n                for(auto &word: st[i]){\\n                     if(st[j].count(word)) mutual++;\\n                }\\n                \\n// Valid names are only from distinct suffixes in both groups.\\n // Since we can swap a with b and swap b with a to create two valid names, multiple answer by 2.\\n                long long combn = (st[i].size()-mutual)*(st[j].size()-mutual);\\n                ans += 2*combn;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n![Upvote 2.png](https://assets.leetcode.com/users/images/f7669487-b8eb-4436-9fb7-10205792c5ba_1675928233.555479.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//app 1: gives tle\\n    long long distinctNames(vector<string>& s) {\\n        int n=s.size();\\n        unordered_set<string> st;\\n\\n        for(string &w: s) st.insert(w);\\n        long long ans=0;\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                string w1=s[i];\\n                string w2=s[j];\\n                //cout<<j<<\" \"<<w2<<endl;\\n                //check condtn\\n                if(w1[0] != w2[0]){\\n                    swap(w1[0],w2[0]);\\n                    //cout<<w1<<\" \"<<w2<<endl;\\n                    if(st.find(w1) == st.end() &&\\n                       st.find(w2) == st.end()){\\n                           ans += 2;\\n                       }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n//app 2: O(n*m)\\n    long long distinctNames(vector<string>& s) {\\n        int n=s.size();\\n\\n        //make an array of set\\n        unordered_set<string> st[26];\\n\\n       //group words by initials [a to z]\\n        for(string &w: s){\\n            st[w[0] - \\'a\\'].insert(w.substr(1));\\n        }\\n\\n        long long ans=0;\\n        for(int i=0; i<26; i++){\\n            for(int j=i+1; j<26; j++){\\n                int mutual=0;\\n                //find mutual words \\n                for(auto &word: st[i]){\\n                     if(st[j].count(word)) mutual++;\\n                }\\n                \\n// Valid names are only from distinct suffixes in both groups.\\n // Since we can swap a with b and swap b with a to create two valid names, multiple answer by 2.\\n                long long combn = (st[i].size()-mutual)*(st[j].size()-mutual);\\n                ans += 2*combn;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3163067,
                "title": "c-o-n-hashmap",
                "content": "# Intuition\\nFor every idea in ideas, we need to find out no. of other ideas, which can be combined with it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAny current idea will accept other idea, if we take other idea\\'s starting character and replace it into the starting character of current idea and that doesn\\'t exist in the original array.\\n\\nSo for a match, both, current idea and the other idea, will have to accept each other.\\n\\nAlgo:\\n\\nFirst we store all the elements in a map.\\n\\nThen for each element we check its starting character and characters it accepts(ie. starting characters of other ideas which it can combine with).\\n\\nThen in the third iteration for each idea, we fetch the count of elements, which accept the current element and start with character which the current element accepts.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        int n = ideas.size();\\n\\n        unordered_map<string,int> m;\\n        for(string idea:ideas){\\n            m[idea]++;\\n        }\\n\\n        vector<vector<int>> starts_accepts(26,vector<int>(26));\\n        for(int i=0;i<n;i++){\\n            string str = ideas[i];\\n            int starts = ideas[i][0]-\\'a\\';\\n\\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                str[0] = c;\\n                if(m.find(str)==m.end()){\\n                    int accepts = str[0]-\\'a\\';\\n                    starts_accepts[starts][accepts]++;\\n                }\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            string str = ideas[i];\\n            int starts = ideas[i][0]-\\'a\\';\\n\\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                str[0] = c;\\n                if(m.find(str)==m.end()){\\n                    int accepts = str[0]-\\'a\\';\\n                    ans = ans+starts_accepts[accepts][starts];\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        int n = ideas.size();\\n\\n        unordered_map<string,int> m;\\n        for(string idea:ideas){\\n            m[idea]++;\\n        }\\n\\n        vector<vector<int>> starts_accepts(26,vector<int>(26));\\n        for(int i=0;i<n;i++){\\n            string str = ideas[i];\\n            int starts = ideas[i][0]-\\'a\\';\\n\\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                str[0] = c;\\n                if(m.find(str)==m.end()){\\n                    int accepts = str[0]-\\'a\\';\\n                    starts_accepts[starts][accepts]++;\\n                }\\n            }\\n        }\\n\\n        long long ans = 0;\\n        for(int i=0;i<n;i++){\\n            string str = ideas[i];\\n            int starts = ideas[i][0]-\\'a\\';\\n\\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                str[0] = c;\\n                if(m.find(str)==m.end()){\\n                    int accepts = str[0]-\\'a\\';\\n                    ans = ans+starts_accepts[accepts][starts];\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162559,
                "title": "c-hashmap-faster-easy-to-understand",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N * Constant)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        int n = ideas.size();\\n        \\n        unordered_set<string> s;\\n        \\n        // insert all ideas into set\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            s.insert(ideas[i]);\\n        }\\n        \\n        vector<vector<int>> dp(26, vector<int> (26, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            string idea = ideas[i];\\n            \\n            char old_char = idea[0];\\n            \\n            // try out all possible replacement\\n            \\n            for(char new_char = \\'a\\'; new_char <= \\'z\\'; new_char++)\\n            {\\n                idea[0] = new_char;\\n                \\n                if(s.count(idea) == 0)  // if not found in set\\n                {\\n                    dp[old_char - \\'a\\'][new_char - \\'a\\']++;\\n                }\\n            }\\n        }\\n        \\n        // calculate ans\\n        \\n        long long ans = 0;\\n        \\n        for(int i = 0; i < 26; i++)\\n        {\\n            for(int j = 0; j < 26; j++)\\n            {\\n                ans += (long long) dp[i][j] * (long long) dp[j][i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        int n = ideas.size();\\n        \\n        unordered_set<string> s;\\n        \\n        // insert all ideas into set\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            s.insert(ideas[i]);\\n        }\\n        \\n        vector<vector<int>> dp(26, vector<int> (26, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            string idea = ideas[i];\\n            \\n            char old_char = idea[0];\\n            \\n            // try out all possible replacement\\n            \\n            for(char new_char = \\'a\\'; new_char <= \\'z\\'; new_char++)\\n            {\\n                idea[0] = new_char;\\n                \\n                if(s.count(idea) == 0)  // if not found in set\\n                {\\n                    dp[old_char - \\'a\\'][new_char - \\'a\\']++;\\n                }\\n            }\\n        }\\n        \\n        // calculate ans\\n        \\n        long long ans = 0;\\n        \\n        for(int i = 0; i < 26; i++)\\n        {\\n            for(int j = 0; j < 26; j++)\\n            {\\n                ans += (long long) dp[i][j] * (long long) dp[j][i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160237,
                "title": "rust-intersection-of-sets",
                "content": "Adapted from https://leetcode.com/problems/naming-a-company/discuss/2141038/Python-3-Explanation-with-pictures\\n```rust\\n\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let mut sets =  vec![HashSet::new(); 26];\\n        \\n        for idea in ideas.iter(){\\n            let bytes = idea.as_bytes();\\n            sets[(bytes[0] - b\\'a\\') as usize].insert(&idea[1..]);\\n        }\\n        \\n        let mut res = 0;\\n        for i in 0..sets.len() - 1{\\n            for j in (i+1)..sets.len(){\\n                let (a, b) = (&sets[i], &sets[j]);\\n                \\n                let duplicates = a.intersection(b).collect::<HashSet<_>>().len();\\n                res += 2_i64 * ((a.len() - duplicates) * (b.len() - duplicates)) as i64;\\n            }   \\n        }\\n        \\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Ordered Set"
                ],
                "code": "```rust\\n\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let mut sets =  vec![HashSet::new(); 26];\\n        \\n        for idea in ideas.iter(){\\n            let bytes = idea.as_bytes();\\n            sets[(bytes[0] - b\\'a\\') as usize].insert(&idea[1..]);\\n        }\\n        \\n        let mut res = 0;\\n        for i in 0..sets.len() - 1{\\n            for j in (i+1)..sets.len(){\\n                let (a, b) = (&sets[i], &sets[j]);\\n                \\n                let duplicates = a.intersection(b).collect::<HashSet<_>>().len();\\n                res += 2_i64 * ((a.len() - duplicates) * (b.len() - duplicates)) as i64;\\n            }   \\n        }\\n        \\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3165677,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nlong long distinctNames(vector<string>& ideas) {\\n  map<int ,unordered_set<string> > mp;\\n  long long ans =0;\\n  for(auto it: ideas){\\n    mp[it[0]-\\'a\\'].insert(it.substr(1));\\n  }\\n//******************************************\\n\\nfor(auto it: mp){\\n  auto it1=mp.find(it.first);\\n  it1++;\\n  while (it1!= mp.end()){\\n    long long vl1=0,vl2=0;\\n\\n    for(auto v1: it.second){\\n      if(it1->second.find(v1)== it1->second.end())\\n      vl1++;      \\n    }\\n    for(auto v1: it1->second){\\n      if(it.second.find(v1)== it.second.end())\\n      vl2++;      \\n    }\\n  ans += (vl1*vl2);\\n  it1++;\\n  }   \\n}\\nans *=2;\\nreturn ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nlong long distinctNames(vector<string>& ideas) {\\n  map<int ,unordered_set<string> > mp;\\n  long long ans =0;\\n  for(auto it: ideas){\\n    mp[it[0]-\\'a\\'].insert(it.substr(1));\\n  }\\n//******************************************\\n\\nfor(auto it: mp){\\n  auto it1=mp.find(it.first);\\n  it1++;\\n  while (it1!= mp.end()){\\n    long long vl1=0,vl2=0;\\n\\n    for(auto v1: it.second){\\n      if(it1->second.find(v1)== it1->second.end())\\n      vl1++;      \\n    }\\n    for(auto v1: it1->second){\\n      if(it.second.find(v1)== it.second.end())\\n      vl2++;      \\n    }\\n  ans += (vl1*vl2);\\n  it1++;\\n  }   \\n}\\nans *=2;\\nreturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165236,
                "title": "python3-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- make array of size 26*26.\\n- i will represent first incident alphabet of ideas.\\n- j will be our replacement for i alphabet.\\n- value of $$match[i][j]$$ will decide that how many times replacing current idea\\'s incident with another word\\'s incident is correct.\\n- at end we want answer for match[i][j] and match[j][i], because it represents if we can **replace c with b** and **creates one new word, then viseversa is also correct.**\\n- return answer\\n\\n# Complexity\\n- Time complexity: $$O(N*26+26*26)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N+1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        answer = 0\\n        ideasSet = {i for i in ideas}\\n        match = [[0 for _ in range(26)] for __ in range(26)]\\n        for i in ideas:\\n            for j in range(ord(\\'a\\'), ord(\\'z\\')+1):\\n                newIdea = chr(j)+i[1:]\\n                if newIdea not in ideasSet:\\n                    match[ord(i[0]) - ord(\\'a\\')][j - ord(\\'a\\')] += 1\\n        for i in range(26):\\n            for j in range(26):\\n                answer += match[i][j]*match[j][i]\\n        return answer\\n```\\n# Please like this solution and comment any suggestion :-)",
                "solutionTags": [
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        answer = 0\\n        ideasSet = {i for i in ideas}\\n        match = [[0 for _ in range(26)] for __ in range(26)]\\n        for i in ideas:\\n            for j in range(ord(\\'a\\'), ord(\\'z\\')+1):\\n                newIdea = chr(j)+i[1:]\\n                if newIdea not in ideasSet:\\n                    match[ord(i[0]) - ord(\\'a\\')][j - ord(\\'a\\')] += 1\\n        for i in range(26):\\n            for j in range(26):\\n                answer += match[i][j]*match[j][i]\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165218,
                "title": "super-easy-concise-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<char , unordered_set<string>>mp;\\n        for(auto &s : ideas)\\n            mp[s[0]].insert(s.substr(1 , s.size() - 1));\\n        long long ans = 0 ;\\n        for(auto&[key , st]:mp)\\n        {\\n            \\n            for(auto&[key2 , st2]:mp)\\n            {\\n                \\n                int commonCounter = 0;\\n                if(key == key2)\\n                    continue;\\n                for(auto &s :st)\\n                {\\n                    if(st2.find(s) != st2.end())\\n                        commonCounter+=1;\\n                }       \\n                ans+= (st.size() - commonCounter) *  (st2.size() - commonCounter);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<char , unordered_set<string>>mp;\\n        for(auto &s : ideas)\\n            mp[s[0]].insert(s.substr(1 , s.size() - 1));\\n        long long ans = 0 ;\\n        for(auto&[key , st]:mp)\\n        {\\n            \\n            for(auto&[key2 , st2]:mp)\\n            {\\n                \\n                int commonCounter = 0;\\n                if(key == key2)\\n                    continue;\\n                for(auto &s :st)\\n                {\\n                    if(st2.find(s) != st2.end())\\n                        commonCounter+=1;\\n                }       \\n                ans+= (st.size() - commonCounter) *  (st2.size() - commonCounter);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164785,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n         long long disName = 0;\\n        vector<unordered_set<string>> arr(26);\\n        for (string s : ideas) \\n            arr[s[0] - \\'a\\'].insert(s.substr(1));\\n        \\n        for (int i = 0; i < 25; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                unordered_set<string> set;\\n                set.insert(arr[i].begin(), arr[i].end());\\n                set.insert(arr[j].begin(), arr[j].end());\\n                disName += (arr[i].size() - set.size()) * (arr[j].size() - set.size());\\n            }\\n        }\\n        return disName * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n         long long disName = 0;\\n        vector<unordered_set<string>> arr(26);\\n        for (string s : ideas) \\n            arr[s[0] - \\'a\\'].insert(s.substr(1));\\n        \\n        for (int i = 0; i < 25; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                unordered_set<string> set;\\n                set.insert(arr[i].begin(), arr[i].end());\\n                set.insert(arr[j].begin(), arr[j].end());\\n                disName += (arr[i].size() - set.size()) * (arr[j].size() - set.size());\\n            }\\n        }\\n        return disName * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163109,
                "title": "javascript-solution-beat-s-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach for the code is to find the number of distinct names in the given array \"ideas\". It works as follows:\\n\\nInitialize an array \"sets\" of 26 sets, each representing the unique names starting with a different letter (a-z).\\n\\nFor each idea in the \"ideas\" array, the first letter is used to index into the \"sets\" array, and the rest of the name is added to the corresponding set.\\n\\nInitialize a two-dimensional array \"same\" to store the count of names that are common between each set.\\n\\nFor each set in the \"sets\" array, compare it with the other sets to find the common names, and increment the count in the \"same\" array for the corresponding indices.\\n\\nInitialize a variable \"res\" to store the result.\\n\\nFor each set in the \"sets\" array, calculate the number of distinct names as the product of the size of each set minus the count of common names, and add it to the \"res\" variable.\\n\\nReturn the \"res\" variable as the final result.\\n\\n# Code\\n```\\n/**\\n * @param {string[]} ideas\\n * @return {number}\\n */\\nvar distinctNames = function(ideas) {\\n    let sets = [];\\n    for (let i = 0; i < 26; i++) {\\n        sets[i] = new Set();\\n    }\\n    for (let s of ideas) {\\n        sets[s.charCodeAt(0) - 97].add(s.substring(1));\\n    }\\n    let same = [];\\n    for (let i = 0; i < 26; i++) {\\n        same[i] = Array(26).fill(0);\\n    }\\n    for (let i = 0; i < 26; i++) {\\n        for (let s of sets[i]) {\\n            for (let j = i + 1; j < 26; j++) {\\n                if (sets[j].has(s)) {\\n                    same[i][j]++;\\n                }\\n            }\\n        }\\n    }\\n    let res = 0;\\n    for (let i = 0; i < 26; i++) {\\n        for (let j = i + 1; j < 26; j++) {\\n            res += (sets[i].size - same[i][j]) * (sets[j].size - same[i][j]) * 2;\\n        }\\n    }\\n    return res;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} ideas\\n * @return {number}\\n */\\nvar distinctNames = function(ideas) {\\n    let sets = [];\\n    for (let i = 0; i < 26; i++) {\\n        sets[i] = new Set();\\n    }\\n    for (let s of ideas) {\\n        sets[s.charCodeAt(0) - 97].add(s.substring(1));\\n    }\\n    let same = [];\\n    for (let i = 0; i < 26; i++) {\\n        same[i] = Array(26).fill(0);\\n    }\\n    for (let i = 0; i < 26; i++) {\\n        for (let s of sets[i]) {\\n            for (let j = i + 1; j < 26; j++) {\\n                if (sets[j].has(s)) {\\n                    same[i][j]++;\\n                }\\n            }\\n        }\\n    }\\n    let res = 0;\\n    for (let i = 0; i < 26; i++) {\\n        for (let j = i + 1; j < 26; j++) {\\n            res += (sets[i].size - same[i][j]) * (sets[j].size - same[i][j]) * 2;\\n        }\\n    }\\n    return res;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162272,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public long DistinctNames(string[] ideas) \\n    {\\n        HashSet<string>[] initialGroup = new HashSet<string>[26];\\n        for (int i = 0; i < 26; ++i)\\n        {\\n            initialGroup[i] = new HashSet<String>();\\n        }\\n        foreach (string idea in ideas) \\n        {\\n            initialGroup[idea[0] - \\'a\\'].Add(idea.Substring(1));\\n        }\\n        \\n        long answer = 0;\\n        for (int i = 0; i < 25; ++i) \\n        {\\n            for (int j = i + 1; j < 26; ++j) \\n            {\\n                long numOfMutual = 0;\\n                foreach (string ideaA in initialGroup[i]) \\n                {\\n                    if (initialGroup[j].Contains(ideaA)) \\n                    {\\n                        numOfMutual++;\\n                    }\\n                }\\n                answer += 2 * (initialGroup[i].Count - numOfMutual) * (initialGroup[j].Count - numOfMutual);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public long DistinctNames(string[] ideas) \\n    {\\n        HashSet<string>[] initialGroup = new HashSet<string>[26];\\n        for (int i = 0; i < 26; ++i)\\n        {\\n            initialGroup[i] = new HashSet<String>();\\n        }\\n        foreach (string idea in ideas) \\n        {\\n            initialGroup[idea[0] - \\'a\\'].Add(idea.Substring(1));\\n        }\\n        \\n        long answer = 0;\\n        for (int i = 0; i < 25; ++i) \\n        {\\n            for (int j = i + 1; j < 26; ++j) \\n            {\\n                long numOfMutual = 0;\\n                foreach (string ideaA in initialGroup[i]) \\n                {\\n                    if (initialGroup[j].Contains(ideaA)) \\n                    {\\n                        numOfMutual++;\\n                    }\\n                }\\n                answer += 2 * (initialGroup[i].Count - numOfMutual) * (initialGroup[j].Count - numOfMutual);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162243,
                "title": "daily-leetcoding-challenge-february-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/naming-a-company/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/naming-a-company/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2143296,
                "title": "python-100-explained",
                "content": "This is the first time, I have gotten 100% with python. \\n\\nThe idea is that two ideas having the same first letter or the same suffix cannot be used to create a name for the company.\\nSo we group the ideas together if they have the same suffix or the same first letter. \\n\\nIf you group them together on the bases of the first letter, there will be only 26 groups, for each alphabet in the english language. \\nBut if you group them by the suffixes then there can be a lot of groups, which results in a TLE.\\n\\nNow the number of company names for the pair A and B are:\\n**(**(#ideas in A) - (#common ideas in A&B) **)** **\\\\*** **(** (#ideas in B) - (#common ideas in A&B)**) * 2**\\n\\n\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        mp = defaultdict(set)\\n        for i in ideas:\\n            mp[i[0]].add(i[1:])\\n            \\n        arr = list(mp.keys())\\n        ans, n = 0, len(arr)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                common = len(mp[arr[i]].intersection(mp[arr[j]]))\\n                ans += (len(mp[arr[i]])-common)*(len(mp[arr[j]])-common)*2\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        mp = defaultdict(set)\\n        for i in ideas:\\n            mp[i[0]].add(i[1:])\\n            \\n        arr = list(mp.keys())\\n        ans, n = 0, len(arr)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                common = len(mp[arr[i]].intersection(mp[arr[j]]))\\n                ans += (len(mp[arr[i]])-common)*(len(mp[arr[j]])-common)*2\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141979,
                "title": "100-faster-easy-understanding-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        int n=ideas.size();\\n        vector<unordered_map<string,int> > v(26);\\n        for(int i=0;i<n;i++)\\n        {\\n            int ch=ideas[i][0]-\\'a\\';\\n            string str=ideas[i].substr(1,ideas[i].length()-1);\\n            v[ch][str]++;\\n        }\\n        long long int ans=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            long long int cur1=v[i].size();\\n            for(int j=i+1;j<26;j++)\\n            {\\n                long long int cur2=v[j].size();\\n                long long int temp=cur1;\\n                for(auto it=v[j].begin();it!=v[j].end();it++)\\n                {\\n                    if(v[i].find(it->first)!=v[i].end())\\n                    {\\n                        temp--;\\n                        cur2--;\\n                    }\\n                }\\n                ans+=(temp*cur2);\\n            }\\n        }\\n        return ans*2;\\n        \\n        \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        int n=ideas.size();\\n        vector<unordered_map<string,int> > v(26);\\n        for(int i=0;i<n;i++)\\n        {\\n            int ch=ideas[i][0]-\\'a\\';\\n            string str=ideas[i].substr(1,ideas[i].length()-1);\\n            v[ch][str]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2141115,
                "title": "java-count-pairs",
                "content": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String>[] map = new HashSet[26];\\n        for(int i = 0; i < 26; i++){\\n            map[i] = new HashSet<>();\\n        }\\n        for(String idea : ideas){\\n            char c = idea.charAt(0);\\n            map[c-\\'a\\'].add(idea.substring(1)); \\n        }\\n        \\n        long res = 0;\\n        for(int i = 0; i < 25; i++){\\n            for(int j = i+1; j < 26; j++){\\n                HashSet<String> set1 = map[i];\\n                HashSet<String> set2 = map[j];\\n                int nomore = 0;\\n                for(String s : set1){\\n                    if(set2.contains(s)){\\n                        nomore++;\\n                        \\n                    }\\n                }\\n                res += (set1.size() -nomore) * (set2.size()-nomore)*2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String>[] map = new HashSet[26];\\n        for(int i = 0; i < 26; i++){\\n            map[i] = new HashSet<>();\\n        }\\n        for(String idea : ideas){\\n            char c = idea.charAt(0);\\n            map[c-\\'a\\'].add(idea.substring(1)); \\n        }\\n        \\n        long res = 0;\\n        for(int i = 0; i < 25; i++){\\n            for(int j = i+1; j < 26; j++){\\n                HashSet<String> set1 = map[i];\\n                HashSet<String> set2 = map[j];\\n                int nomore = 0;\\n                for(String s : set1){\\n                    if(set2.contains(s)){\\n                        nomore++;\\n                        \\n                    }\\n                }\\n                res += (set1.size() -nomore) * (set2.size()-nomore)*2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140970,
                "title": "c-count-all-26-26-possible-pairs",
                "content": "A bit of explanation\\nso we need pairs of words which are after swapping their first character, not present in the original list. \\nI precalculated the thing that if we swap letter let say \\'a\\' to \\'c\\' then what are the number of such words starting with \\'a\\' which after swapping  with \\'c\\' doesn\\'t exist in original list.\\nlet call this sum v[a][c]  \\nnow v[c][a]  will denote that how many words are there with c which on swapping with a , are not present in list.\\nso we can use v[a][c]  and v[c][a] to form pairs \\ntotal possible pairs = v[a][c] * v[c][a]\\n\\n\\n```\\nlong long distinctNames(vector<string>& ideas) {\\n        long long res = 0;\\n        vector<vector<long long>> v(26,vector<long long>(26,0));\\n        unordered_map<int,unordered_set<string>> mp;\\n\\n        for(auto &idea : ideas)\\n        {\\n            mp[idea[0]-\\'a\\'].insert(idea);\\n        }\\n        \\n\\t\\t//v[i][j] denotes that how many words that doesn\\'t exist in the \\n\\t\\t// original set if we replace  their first char i with j\\n\\t\\t//e.g. v[c][d] = size{\"doffee\"} = 1;\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(mp.find(i) == mp.end() || i == j) continue;\\n                for(auto &e : mp[i])\\n                {\\n                    string p = e;\\n                    p[0] = \\'a\\'+j;\\n                    if(mp[j].count(p)) continue;\\n                    v[i][j]++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(i!=j)\\n                res += (v[i][j]*v[j][i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long distinctNames(vector<string>& ideas) {\\n        long long res = 0;\\n        vector<vector<long long>> v(26,vector<long long>(26,0));\\n        unordered_map<int,unordered_set<string>> mp;\\n\\n        for(auto &idea : ideas)\\n        {\\n            mp[idea[0]-\\'a\\'].insert(idea);\\n        }\\n        \\n\\t\\t//v[i][j] denotes that how many words that doesn\\'t exist in the \\n\\t\\t// original set if we replace  their first char i with j\\n\\t\\t//e.g. v[c][d] = size{\"doffee\"} = 1;\\n\\t\\t\\n\\t\\t\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(mp.find(i) == mp.end() || i == j) continue;\\n                for(auto &e : mp[i])\\n                {\\n                    string p = e;\\n                    p[0] = \\'a\\'+j;\\n                    if(mp[j].count(p)) continue;\\n                    v[i][j]++;\\n                }\\n            }\\n        }\\n        \\n\\t\\t\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                if(i!=j)\\n                res += (v[i][j]*v[j][i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202612,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> initialGroup[26];\\n        for(auto x : ideas) initialGroup[x[0] - \\'a\\'].insert(x.substr(1));\\n        long long answer = 0;\\n        for (int i = 0; i < 25; ++i) {\\n            for (int j = i + 1; j < 26; ++j) {\\n                int numOfMutual = 0;\\n                for (auto x: initialGroup[i]) {\\n                    if (initialGroup[j].count(x)) {\\n                        numOfMutual++;\\n                    }\\n                }\\n                answer += 2LL * (initialGroup[i].size() - numOfMutual) * (initialGroup[j].size() - numOfMutual);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> initialGroup[26];\\n        for(auto x : ideas) initialGroup[x[0] - \\'a\\'].insert(x.substr(1));\\n        long long answer = 0;\\n        for (int i = 0; i < 25; ++i) {\\n            for (int j = i + 1; j < 26; ++j) {\\n                int numOfMutual = 0;\\n                for (auto x: initialGroup[i]) {\\n                    if (initialGroup[j].count(x)) {\\n                        numOfMutual++;\\n                    }\\n                }\\n                answer += 2LL * (initialGroup[i].size() - numOfMutual) * (initialGroup[j].size() - numOfMutual);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164992,
                "title": "naming-a-company-c-begineer-s-approach-set-intersection-86-faster-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int findIntersection(unordered_set<string> &s1,unordered_set<string> &s2){\\n        int total = 0;\\n        for(auto i:s1){\\n            if(s2.find(i)!=s2.end()) total++;\\n        }\\n        return total;\\n    }\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        int n = ideas.size();\\n        long long ans = 0;\\n\\n        vector<unordered_set<string>> mp(26); // unordered because here ordering doesn\\'t matter O(1)\\n        for(auto i:ideas){\\n            mp[i[0]-\\'a\\'].insert(i.substr(1));\\n        }\\n\\n        for(int i=0;i<25;i++){\\n            if(mp[i].size()!=0){\\n                for(int j=i+1;j<26;j++){\\n                    if(mp[j].size()!=0){\\n                        int comm = findIntersection(mp[i],mp[j]); // common elements\\n                        ans+=2*(mp[i].size()-comm)*(mp[j].size()-comm);\\n                    }\\n                }   \\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int findIntersection(unordered_set<string> &s1,unordered_set<string> &s2){\\n        int total = 0;\\n        for(auto i:s1){\\n            if(s2.find(i)!=s2.end()) total++;\\n        }\\n        return total;\\n    }\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        int n = ideas.size();\\n        long long ans = 0;\\n\\n        vector<unordered_set<string>> mp(26); // unordered because here ordering doesn\\'t matter O(1)\\n        for(auto i:ideas){\\n            mp[i[0]-\\'a\\'].insert(i.substr(1));\\n        }\\n\\n        for(int i=0;i<25;i++){\\n            if(mp[i].size()!=0){\\n                for(int j=i+1;j<26;j++){\\n                    if(mp[j].size()!=0){\\n                        int comm = findIntersection(mp[i],mp[j]); // common elements\\n                        ans+=2*(mp[i].size()-comm)*(mp[j].size()-comm);\\n                    }\\n                }   \\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164105,
                "title": "swift-easy-to-understand-solution-with-hashmap",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func distinctNames(_ ideas: [String]) -> Int {\\n        // first char : rest suffixes\\n        var wordMap = [Character: Set<String>]()\\n        for w in ideas {\\n            var word = Array(w)\\n            wordMap[word[0], default: []].insert(String(word[1..<word.count]))\\n        }\\n        var res = 0\\n        for char1 in wordMap.keys {\\n            for char2 in wordMap.keys {\\n                if char1 == char2 { continue }\\n                var intersect = 0\\n                for w in wordMap[char1]! {\\n                    if wordMap[char2]!.contains(w) { intersect += 1 }\\n                }\\n                var distinct1 = wordMap[char1]!.count - intersect\\n                var distinct2 = wordMap[char2]!.count - intersect\\n                res += distinct1 * distinct2\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distinctNames(_ ideas: [String]) -> Int {\\n        // first char : rest suffixes\\n        var wordMap = [Character: Set<String>]()\\n        for w in ideas {\\n            var word = Array(w)\\n            wordMap[word[0], default: []].insert(String(word[1..<word.count]))\\n        }\\n        var res = 0\\n        for char1 in wordMap.keys {\\n            for char2 in wordMap.keys {\\n                if char1 == char2 { continue }\\n                var intersect = 0\\n                for w in wordMap[char1]! {\\n                    if wordMap[char2]!.contains(w) { intersect += 1 }\\n                }\\n                var distinct1 = wordMap[char1]!.count - intersect\\n                var distinct2 = wordMap[char2]!.count - intersect\\n                res += distinct1 * distinct2\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163478,
                "title": "simple-solution-c",
                "content": "1. First iterate through the ideas and store in unordered_map (easy access).\\n2. create vector of 26x26 or 2-d array\\n3. now go over each element of ideas. for each element extract the suffix. Now the prefix (first character can be anything from a to z)\\n4. There are some constraints to step3. First if this new character index is same as previous character index then there is actually no new word forming, just continue.\\n5. now after adding all alphabets (except prefixIndex char) to suffix, check if it is present in map or not. If it is present then it means it is one of the idea that shares same suffix. hence just continue.\\n6. now t[prefixIndex][j] += 1 indicates that prefixIndex character can be replaced by jth character. \\n7. now iterate through the 2-d array and check for positions (i,j) which are greater than zero.\\n8. now here is the biggest catch. WHY ADD \"(t[i][j]*t[j][i])\"?\\n9. t[i][j] indicates that j can replace i. t[j][i] indicates that i can replace j. if both can replace each other then it means both i and j were present as prefix in ideas array. \\n10. lets say we have \"abc\", \"mxy\" then (t[a][m]>0 && t[m][a]>0) , (t[a][c]>0 but t[c][a]==0). hence overall we will get some +ve value in t[a][m] case and 0 in t[a][c] case. \\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        int n = ideas.size();\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for (int i=0; i<n; i++){\\n            mp[ideas[i]]++;\\n        }\\n        \\n        vector<vector<int>> t(26, vector<int>(26,0));\\n        \\n        for (int i=0; i<n; i++){\\n            string word = ideas[i];\\n            char prefix = word[0];\\n            string suffix = word.substr(1);\\n            int prefixIndex = (prefix-\\'a\\');\\n            \\n            for (int j=0; j<26; j++){\\n                if (j==prefixIndex) continue;\\n                char newChar = (\\'a\\'+j);\\n                string newWord = newChar + suffix;\\n                \\n                if (mp.find(newWord) != mp.end()) continue;\\n                \\n                t[prefixIndex][j] += 1;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for (int i=0; i<26; i++){\\n            for (int j=0; j<26; j++){\\n                if (i==j) continue;\\n                if (t[i][j]>0){\\n                    ans += (t[i][j]*t[j][i]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        int n = ideas.size();\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for (int i=0; i<n; i++){\\n            mp[ideas[i]]++;\\n        }\\n        \\n        vector<vector<int>> t(26, vector<int>(26,0));\\n        \\n        for (int i=0; i<n; i++){\\n            string word = ideas[i];\\n            char prefix = word[0];\\n            string suffix = word.substr(1);\\n            int prefixIndex = (prefix-\\'a\\');\\n            \\n            for (int j=0; j<26; j++){\\n                if (j==prefixIndex) continue;\\n                char newChar = (\\'a\\'+j);\\n                string newWord = newChar + suffix;\\n                \\n                if (mp.find(newWord) != mp.end()) continue;\\n                \\n                t[prefixIndex][j] += 1;\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for (int i=0; i<26; i++){\\n            for (int j=0; j<26; j++){\\n                if (i==j) continue;\\n                if (t[i][j]>0){\\n                    ans += (t[i][j]*t[j][i]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163477,
                "title": "c-trie-easy-to-understand-faster-than-90",
                "content": "In this i am pushing each string in reverse order in the trie \\nand then checking last char of string from a to z whether the string is present or not \\nif that is not present that i can consider that string to be replaced by a particular charater from a to z\\nand will store the count \\nthen just run a loop and calculate the final res\\nrefer code you will understand better\\ntime complexity O(n*maxlength(s)) total character in all string \\n\\n```\\nstruct Node{\\n    Node * link[26];\\n    int flag=false;\\n    bool findval(char ch)\\n    {\\n        return link[ch-\\'a\\']!=NULL;\\n    }\\n    void insertval(char ch,Node * node)\\n    {\\n        link[ch-\\'a\\']=node;\\n    }\\n    Node * nextval(char ch)\\n    {\\n        return link[ch-\\'a\\'];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int val[26][26];\\n    Node * root;\\n    void insertstring(string& s )\\n    {\\n        Node * node=root;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(node->findval(s[i])==false)\\n            {\\n                node->insertval(s[i],new Node());\\n            }\\n            node=node->nextval(s[i]);\\n        }\\n        node->flag=true;   \\n    }\\n    \\n    void checkstring(string &s)\\n    {\\n        Node * node=root;\\n        int flag=true;\\n        for(int i=s.size()-1;i>0;i--)\\n        { \\n            node=node->nextval(s[i]);\\n        }\\n        char ch=s[0];\\n        char cc=\\'a\\';\\n        for(int i=0;i<26;i++)\\n        {\\n            if(node->findval(cc)==false)\\n            {\\n                val[ch-\\'a\\'][cc-\\'a\\']++;\\n            }\\n            else\\n            {\\n                Node * t=node->nextval(cc);\\n                if(t->flag==false)\\n                {\\n                    val[ch-\\'a\\'][cc-\\'a\\']++;\\n                }\\n            }\\n            cc++;\\n        }\\n        \\n    }\\n    \\n     \\n        long long distinctNames(vector<string>& t) {\\n        vector<string >v[26];\\n       root= new Node();\\n        for(auto i:t)\\n            insertstring(i);\\n        for(auto i:t)\\n            checkstring(i);\\n            \\n            \\n            long long res=0;\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=i+1;j<26;j++)\\n            {\\n                res+=2*(val[i][j]*val[j][i]);\\n                \\n            }\\n        }\\n        return res;\\n        \\n        \\n        \\n    }\\n};\\n```\\nCONSIDER UPVOTE IF YOU LIKE IT",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node * link[26];\\n    int flag=false;\\n    bool findval(char ch)\\n    {\\n        return link[ch-\\'a\\']!=NULL;\\n    }\\n    void insertval(char ch,Node * node)\\n    {\\n        link[ch-\\'a\\']=node;\\n    }\\n    Node * nextval(char ch)\\n    {\\n        return link[ch-\\'a\\'];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int val[26][26];\\n    Node * root;\\n    void insertstring(string& s )\\n    {\\n        Node * node=root;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            if(node->findval(s[i])==false)\\n            {\\n                node->insertval(s[i],new Node());\\n            }\\n            node=node->nextval(s[i]);\\n        }\\n        node->flag=true;   \\n    }\\n    \\n    void checkstring(string &s)\\n    {\\n        Node * node=root;\\n        int flag=true;\\n        for(int i=s.size()-1;i>0;i--)\\n        { \\n            node=node->nextval(s[i]);\\n        }\\n        char ch=s[0];\\n        char cc=\\'a\\';\\n        for(int i=0;i<26;i++)\\n        {\\n            if(node->findval(cc)==false)\\n            {\\n                val[ch-\\'a\\'][cc-\\'a\\']++;\\n            }\\n            else\\n            {\\n                Node * t=node->nextval(cc);\\n                if(t->flag==false)\\n                {\\n                    val[ch-\\'a\\'][cc-\\'a\\']++;\\n                }\\n            }\\n            cc++;\\n        }\\n        \\n    }\\n    \\n     \\n        long long distinctNames(vector<string>& t) {\\n        vector<string >v[26];\\n       root= new Node();\\n        for(auto i:t)\\n            insertstring(i);\\n        for(auto i:t)\\n            checkstring(i);\\n            \\n            \\n            long long res=0;\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=i+1;j<26;j++)\\n            {\\n                res+=2*(val[i][j]*val[j][i]);\\n                \\n            }\\n        }\\n        return res;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163405,
                "title": "kotlin-intersect-suffix-buckets",
                "content": "#### Join me on Telegram\\nhttps://t.me/leetcode_daily_unstoppable/113\\n#### Intuition\\nIf we group ideas by the suffixes and consider only the unique elements, the result will be the intersection of the sizes of the groups. (To deduce this you must sit and draw, or have a big brain, or just use a hint)\\n\\n#### Approach\\nGroup and multiply. Don\\'t forget to remove repeating elements in each two groups.\\n#### Complexity\\n- Time complexity:\\n$$O(26^2n)$$\\n- Space complexity:\\n$$O(n)$$\\n#### Code\\n```\\nclass Solution {\\n    fun distinctNames(ideas: Array<String>): Long {\\n        // c -> offee\\n        // d -> onuts\\n        // t -> ime, offee\\n        val prefToSuf = Array(27) { hashSetOf<String>() }\\n        for (idea in ideas)\\n            prefToSuf[idea[0].toInt() - \\'a\\'.toInt()].add(idea.substring(1, idea.length))\\n        var count = 0L\\n        for (i in 0..26) \\n            for (j in i + 1..26) \\n                count += prefToSuf[i].count { !prefToSuf[j].contains(it) } * prefToSuf[j].count { ! prefToSuf[i].contains(it) }\\n        return count * 2L\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    fun distinctNames(ideas: Array<String>): Long {\\n        // c -> offee\\n        // d -> onuts\\n        // t -> ime, offee\\n        val prefToSuf = Array(27) { hashSetOf<String>() }\\n        for (idea in ideas)\\n            prefToSuf[idea[0].toInt() - \\'a\\'.toInt()].add(idea.substring(1, idea.length))\\n        var count = 0L\\n        for (i in 0..26) \\n            for (j in i + 1..26) \\n                count += prefToSuf[i].count { !prefToSuf[j].contains(it) } * prefToSuf[j].count { ! prefToSuf[i].contains(it) }\\n        return count * 2L\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163255,
                "title": "beats-95-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        Set<String>[] sets = new Set[26];\\n        for (int i = 0; i < 26; i++) {\\n            sets[i] = new HashSet();\\n        }\\n        for (String s : ideas) {\\n            sets[s.charAt(0) - \\'a\\'].add(s.substring(1));\\n        }\\n        int[][] same = new int[26][26];\\n        for (int i = 0; i < 26; i++) {\\n            for (String s : sets[i]) {\\n                for (int j = i + 1; j < 26; j++) {\\n                    if (sets[j].contains(s)) {\\n                        same[i][j]++;\\n                    }\\n                }\\n            }\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                res += (sets[i].size() - same[i][j]) * (sets[j].size() - same[i][j]) * 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        Set<String>[] sets = new Set[26];\\n        for (int i = 0; i < 26; i++) {\\n            sets[i] = new HashSet();\\n        }\\n        for (String s : ideas) {\\n            sets[s.charAt(0) - \\'a\\'].add(s.substring(1));\\n        }\\n        int[][] same = new int[26][26];\\n        for (int i = 0; i < 26; i++) {\\n            for (String s : sets[i]) {\\n                for (int j = i + 1; j < 26; j++) {\\n                    if (sets[j].contains(s)) {\\n                        same[i][j]++;\\n                    }\\n                }\\n            }\\n        }\\n        long res = 0;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                res += (sets[i].size() - same[i][j]) * (sets[j].size() - same[i][j]) * 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163235,
                "title": "python3-96-98-t-m-beats-only-10-lines-optimization-simple-explain-attach-a-tle-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/f2e96c6c-855c-4313-b6eb-39d0cff49eac_1675925230.1417468.png)\\n\\n# Approach\\nCreate Hash table with \\nkey: > prefix_word , in other words words[0]\\nvalue: > suffux_word , in other words words[1:]\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\nCreate table time , need traverse ideas\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\nThe Max table size is O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        hashmap = defaultdict(set)\\n        for name in set(ideas):\\n            hashmap[name[0]].add(name[1:])\\n        ans=0\\n        for index_1 , (pre_a,suf_a) in enumerate(hashmap.items()):\\n            for index_2 , (pre_b,suf_b) in enumerate(hashmap.items()):        # name_a name_b is same name_b name_a  \\n                if index_2>index_1:                                           # so you dont need calculate it double times\\n                    both_have = len(suf_a.intersection(suf_b))                # count the suffix_words that appear in both groups\\n                    ans += (len(suf_a)-both_have) * (len(suf_b)-both_have)    \\n        return 2*ans\\n\\n```\\n# Old Code (TLE with pairs of words)\\nWhy TLE ?\\nGiven the size of the input array ideas as n, we need to try O(n ^ 2) pairs of words.(n <=5 * 10_4) This approach is likely to exceed the time limit, implying that we should look for a better approach.\\n\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        def check_naming(name_list,ht):\\n            name_a,name_b = name_list[0],name_list[1]\\n            if name_a[0] == name_b[0]:\\n                return 0\\n            if name_b[1:] in ht[name_a[0]] or name_a[1:] in ht[name_b[0]]:\\n                return 0\\n            return 2\\n        n = len(ideas)\\n        hashmap = defaultdict(list)\\n        for name in ideas:\\n            hashmap[name[0]].append(name[1:])\\n        cur_list,ans=[],0\\n        for index_a in range(n):\\n            cur_list.append(ideas.pop(0))\\n            for index_b in range(index_a+1,n):\\n                cur_list.append(ideas.pop(0))\\n                ans += check_naming(cur_list,hashmap)\\n                ideas.append(cur_list.pop())\\n            cur_list.pop()\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        hashmap = defaultdict(set)\\n        for name in set(ideas):\\n            hashmap[name[0]].add(name[1:])\\n        ans=0\\n        for index_1 , (pre_a,suf_a) in enumerate(hashmap.items()):\\n            for index_2 , (pre_b,suf_b) in enumerate(hashmap.items()):        # name_a name_b is same name_b name_a  \\n                if index_2>index_1:                                           # so you dont need calculate it double times\\n                    both_have = len(suf_a.intersection(suf_b))                # count the suffix_words that appear in both groups\\n                    ans += (len(suf_a)-both_have) * (len(suf_b)-both_have)    \\n        return 2*ans\\n\\n```\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        def check_naming(name_list,ht):\\n            name_a,name_b = name_list[0],name_list[1]\\n            if name_a[0] == name_b[0]:\\n                return 0\\n            if name_b[1:] in ht[name_a[0]] or name_a[1:] in ht[name_b[0]]:\\n                return 0\\n            return 2\\n        n = len(ideas)\\n        hashmap = defaultdict(list)\\n        for name in ideas:\\n            hashmap[name[0]].append(name[1:])\\n        cur_list,ans=[],0\\n        for index_a in range(n):\\n            cur_list.append(ideas.pop(0))\\n            for index_b in range(index_a+1,n):\\n                cur_list.append(ideas.pop(0))\\n                ans += check_naming(cur_list,hashmap)\\n                ideas.append(cur_list.pop())\\n            cur_list.pop()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163222,
                "title": "swift-fastest-630ms-7-sloc",
                "content": "**Fast, 7 SLOC (accepted answer)**\\n```\\nclass Solution {\\n    func distinctNames(_ ideas: [String]) -> Int {\\n        let hashmap = Dictionary(grouping: ideas){$0.first!}.mapValues {Set($0.map{Array($0)[1...].hashValue})} \\n        \\n        return hashmap.reduce(into: 0) { result, i in\\n            result += hashmap.filter { j in j.key > i.key }.reduce(into: 0) { innerResult, j in\\n                let common = i.value.reduce(0) { common, str in  common + (j.value.contains(str) ? 1 : 0) }\\n                innerResult += (i.value.count - common) * (j.value.count - common) * 2\\n            }\\n        }        \\n    }\\n}\\n```\\n\\n---\\n\\n**Notes on the construction of `hashmap`**\\n\\n**Step 1: Create the Dictionary.**\\nResult is `[Int: [String]]`, where keys are initial letter as a Character (\"a\"...\"z\") and values are strings from `ideas` grouped to those keys.\\n\\n```\\n\\t let hashmap1 = Dictionary(grouping: ideas, by {idea in idea.first!})\\n```\\n```\\n// example hashmap1:\\nideas = [\"abc\", \"abd\", \"bcd\", \"def\"]\\n\\t\\nhashmap1 becomes [Character(\"a\"): [\"abc\", \"abd\"], Character(\"b\"):[\"bcd\"], Character(\"c\"):[\"def\"]]\\n```\\n\\n**Step 2: Fix the values in the hashmap.**\\nThe hashmap values have two things to change (plus a third, for optimization). First, they are `Array(String)` and we\\'d like them to be `Set(String)`. Second, each string still contains the initial character, so we need to remove the initial character.\\n\\n```\\n\\tlet hashmap2 = hashmap1.mapValues { arrayOfStrings in \\n\\t\\t\\tSet(\\n\\t\\t\\t\\tarrayOfStrings.map{ string in \\n\\t\\t\\t\\t\\t\\tArray(string)[1...]\\n\\t\\t\\t\\t}\\n\\t\\t\\t)\\n\\t} \\n```\\n\\n```\\n// example hashmap2 \\nhashmap1 = [Character(\"a\"): [\"abc\", \"abd\"], Character(\"b\"):[\"bcd\"], Character(\"c\"):[\"def\"]]\\n\\nhashmap2 becomes [Character(\"a\"): Set([\"bc\", \"bd\"]), Character(\"b\"):Set([\"cd\"]), Character(\"c\"):Set([\"def\"])]\\n```\\n\\n**Step 2A: Optimization: Replace the strings in each set with their `hashValue`**\\nBy using hash value instead of `String`, we shave 10-20% off of the result time.\\n```\\n\\tlet hashmap2 = hashmap1.mapValues { arrayOfStrings in \\n\\t\\t\\tSet(\\n\\t\\t\\t\\tarrayOfStrings.map{ string in \\n\\t\\t\\t\\t\\t\\tArray(string)[1...].hashValue // add `.hashValue`\\n\\t\\t\\t\\t}\\n\\t\\t\\t)\\n\\t} \\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distinctNames(_ ideas: [String]) -> Int {\\n        let hashmap = Dictionary(grouping: ideas){$0.first!}.mapValues {Set($0.map{Array($0)[1...].hashValue})} \\n        \\n        return hashmap.reduce(into: 0) { result, i in\\n            result += hashmap.filter { j in j.key > i.key }.reduce(into: 0) { innerResult, j in\\n                let common = i.value.reduce(0) { common, str in  common + (j.value.contains(str) ? 1 : 0) }\\n                innerResult += (i.value.count - common) * (j.value.count - common) * 2\\n            }\\n        }        \\n    }\\n}\\n```\n```\\n\\t let hashmap1 = Dictionary(grouping: ideas, by {idea in idea.first!})\\n```\n```\\n// example hashmap1:\\nideas = [\"abc\", \"abd\", \"bcd\", \"def\"]\\n\\t\\nhashmap1 becomes [Character(\"a\"): [\"abc\", \"abd\"], Character(\"b\"):[\"bcd\"], Character(\"c\"):[\"def\"]]\\n```\n```\\n\\tlet hashmap2 = hashmap1.mapValues { arrayOfStrings in \\n\\t\\t\\tSet(\\n\\t\\t\\t\\tarrayOfStrings.map{ string in \\n\\t\\t\\t\\t\\t\\tArray(string)[1...]\\n\\t\\t\\t\\t}\\n\\t\\t\\t)\\n\\t} \\n```\n```\\n// example hashmap2 \\nhashmap1 = [Character(\"a\"): [\"abc\", \"abd\"], Character(\"b\"):[\"bcd\"], Character(\"c\"):[\"def\"]]\\n\\nhashmap2 becomes [Character(\"a\"): Set([\"bc\", \"bd\"]), Character(\"b\"):Set([\"cd\"]), Character(\"c\"):Set([\"def\"])]\\n```\n```\\n\\tlet hashmap2 = hashmap1.mapValues { arrayOfStrings in \\n\\t\\t\\tSet(\\n\\t\\t\\t\\tarrayOfStrings.map{ string in \\n\\t\\t\\t\\t\\t\\tArray(string)[1...].hashValue // add `.hashValue`\\n\\t\\t\\t\\t}\\n\\t\\t\\t)\\n\\t} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163196,
                "title": "rust-dp-solution",
                "content": "\\n```\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let mut set = std::collections::HashSet::new();\\n\\n        ideas.iter().for_each(|idea| { set.insert(idea); });\\n\\n        // f[i][j] means the number of first char of idea\\n        // replaced by char c that is not in ideas\\n        let mut f = vec![vec![0; 26]; 26];\\n        let mut res: i64 = 0;\\n\\n        ideas.iter().for_each(|idea| {\\n            let i = idea.chars().nth(0).unwrap() as usize - \\'a\\' as usize;\\n\\n            for j in 0..26 {\\n                let c = char::from((\\'a\\' as usize + j) as u8);\\n                let swap = c.to_string() + &idea[1..].to_string();\\n\\n                if !set.contains(&swap) {\\n                    f[i][j] += 1;\\n                    \\n                    // count the number not contains swap, which is f[j][i]\\n                    res += f[j][i];\\n                }\\n            }\\n        });\\n\\n        2 * res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let mut set = std::collections::HashSet::new();\\n\\n        ideas.iter().for_each(|idea| { set.insert(idea); });\\n\\n        // f[i][j] means the number of first char of idea\\n        // replaced by char c that is not in ideas\\n        let mut f = vec![vec![0; 26]; 26];\\n        let mut res: i64 = 0;\\n\\n        ideas.iter().for_each(|idea| {\\n            let i = idea.chars().nth(0).unwrap() as usize - \\'a\\' as usize;\\n\\n            for j in 0..26 {\\n                let c = char::from((\\'a\\' as usize + j) as u8);\\n                let swap = c.to_string() + &idea[1..].to_string();\\n\\n                if !set.contains(&swap) {\\n                    f[i][j] += 1;\\n                    \\n                    // count the number not contains swap, which is f[j][i]\\n                    res += f[j][i];\\n                }\\n            }\\n        });\\n\\n        2 * res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163070,
                "title": "python-optimized-solution-explained-in-detail",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**For Detailed Explaination Read this Blog:**\\nhttps://www.python-techs.com/2023/02/naming-company.html\\n\\n**Solution:**\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        # Create 26 empty sets to store words starting with each letter\\n        groups = [set() for i in range(26)]\\n        \\n        for idea in ideas:\\n            \\n            # Add each word to its respective set based on its first letter\\n            groups[ord(idea[0]) - ord(\\'a\\')].add(idea[1:])\\n\\n        answer = 0\\n        \\n        # Iterate through all 26 sets\\n        for i in range(25):\\n            for j in range(i+1, 26):\\n                \\n                # Calculate the number of mutual ideas (ideas with same suffix)\\n                mutuals = len(groups[i] & groups[j])\\n                \\n                # For each group, the number of unique combinations of two words from different groups is\\n                # equal to the product of the number of words in each group minus the number of mutual words\\n                answer += 2 * (len(groups[i]) - mutuals) * (len(groups[j]) - mutuals)\\n        \\n        return answer\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        # Create 26 empty sets to store words starting with each letter\\n        groups = [set() for i in range(26)]\\n        \\n        for idea in ideas:\\n            \\n            # Add each word to its respective set based on its first letter\\n            groups[ord(idea[0]) - ord(\\'a\\')].add(idea[1:])\\n\\n        answer = 0\\n        \\n        # Iterate through all 26 sets\\n        for i in range(25):\\n            for j in range(i+1, 26):\\n                \\n                # Calculate the number of mutual ideas (ideas with same suffix)\\n                mutuals = len(groups[i] & groups[j])\\n                \\n                # For each group, the number of unique combinations of two words from different groups is\\n                # equal to the product of the number of words in each group minus the number of mutual words\\n                answer += 2 * (len(groups[i]) - mutuals) * (len(groups[j]) - mutuals)\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163068,
                "title": "bucket-beyond-100",
                "content": "# Intuition\\nUse buckets\\n\\n# Approach\\nPut each suffix to target bucket, and you have 26 buckets at most.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        use std::collections::HashMap;\\n        use std::collections::HashSet;\\n\\n        // init buckets\\n        let mut buckets = HashMap::new();\\n        for idea in ideas {\\n            let c = idea[..1].to_string();\\n            let w = idea[1..].to_string();\\n            let mut bucket = buckets.entry(c).or_insert(HashSet::new());\\n            bucket.insert(w);\\n        }\\n\\n        let keys: Vec<&String> = buckets.keys().collect();\\n        let mut cnt = 0;\\n\\n        for i in 0..keys.len() - 1 {\\n            for j in i + 1..keys.len() {\\n                let bucket1 = buckets.get(keys[i]).unwrap();\\n                let bucket2 = buckets.get(keys[j]).unwrap();\\n                let lhs: Vec<&String> = bucket1.difference(bucket2).collect();\\n                let rhs: Vec<&String> = bucket2.difference(bucket1).collect();\\n                cnt += lhs.len() * rhs.len() * 2;\\n            }\\n        }\\n\\n        cnt as i64\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        use std::collections::HashMap;\\n        use std::collections::HashSet;\\n\\n        // init buckets\\n        let mut buckets = HashMap::new();\\n        for idea in ideas {\\n            let c = idea[..1].to_string();\\n            let w = idea[1..].to_string();\\n            let mut bucket = buckets.entry(c).or_insert(HashSet::new());\\n            bucket.insert(w);\\n        }\\n\\n        let keys: Vec<&String> = buckets.keys().collect();\\n        let mut cnt = 0;\\n\\n        for i in 0..keys.len() - 1 {\\n            for j in i + 1..keys.len() {\\n                let bucket1 = buckets.get(keys[i]).unwrap();\\n                let bucket2 = buckets.get(keys[j]).unwrap();\\n                let lhs: Vec<&String> = bucket1.difference(bucket2).collect();\\n                let rhs: Vec<&String> = bucket2.difference(bucket1).collect();\\n                cnt += lhs.len() * rhs.len() * 2;\\n            }\\n        }\\n\\n        cnt as i64\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163058,
                "title": "simple-java-100-easy-comments-readable-beginners-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n       public long distinctNames(String[] ideas) {\\n       List<String> arr[] = new ArrayList[26];               // create array of ArrayList\\n       long disName = 0;                                     // Instead ArrayList, HashSet can be used\\n       for(int i = 0; i < 26; i++)                           // assign new ArrayList to each index\\n           arr[i] = new ArrayList<>();\\n\\n       for(String s : ideas)\\n           arr[s.charAt(0) - \\'a\\'].add(s.substring(1));       // store each string A/C to its 1st char\\n\\n       for(int i = 0; i < 25; i++) {\\n           for(int j = i + 1; j < 26; j++) {\\n               Set<String> set = new HashSet<>();            // store all strings of arr[i] & arr[j]\\n\\n               set.addAll(arr[i]);\\n               set.addAll(arr[j]);\\n               disName += (arr[i].size() - set.size()) * (arr[j].size() - set.size());     // no. of pairs possible\\n           }\\n       }\\n\\n       return disName * 2;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       public long distinctNames(String[] ideas) {\\n       List<String> arr[] = new ArrayList[26];               // create array of ArrayList\\n       long disName = 0;                                     // Instead ArrayList, HashSet can be used\\n       for(int i = 0; i < 26; i++)                           // assign new ArrayList to each index\\n           arr[i] = new ArrayList<>();\\n\\n       for(String s : ideas)\\n           arr[s.charAt(0) - \\'a\\'].add(s.substring(1));       // store each string A/C to its 1st char\\n\\n       for(int i = 0; i < 25; i++) {\\n           for(int j = i + 1; j < 26; j++) {\\n               Set<String> set = new HashSet<>();            // store all strings of arr[i] & arr[j]\\n\\n               set.addAll(arr[i]);\\n               set.addAll(arr[j]);\\n               disName += (arr[i].size() - set.size()) * (arr[j].size() - set.size());     // no. of pairs possible\\n           }\\n       }\\n\\n       return disName * 2;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163034,
                "title": "c-hashset-solution-with-explanation",
                "content": "# Approach\\n1. Create a hashset for each letter of the alphabet\\n2. For each idea, add it to the hashset of the first letter\\n3. For each pair of hashsets, count the number of mutual ideas\\n4. Add the number of non-mutual ideas to the answer\\n5. Return the answer\\n\\n# Speed And Memory.\\n![image.png](https://assets.leetcode.com/users/images/f7d8d98b-38b0-4a8b-9496-6da9ac942795_1675922074.2704825.png)\\n\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public long DistinctNames(string[] ideas) \\n    {\\n        var groups = new HashSet<string>[26];\\n        for (int i = 0; i < 26; i++)\\n        {\\n            groups[i] = new HashSet<string>();\\n        }\\n\\n        foreach (var idea in ideas)\\n        {\\n            groups[idea[0] - \\'a\\'].Add(idea.Substring(1));\\n        }\\n\\n        long answer = 0;\\n        for (int i = 0; i < 25; i++)\\n        {\\n            for (int j = i + 1; j < 26; j++)\\n            {\\n                int mutuals = 0;\\n                foreach (var ideaA in groups[i])\\n                {\\n                    if (groups[j].Contains(ideaA))\\n                    {\\n                        mutuals++;\\n                    }\\n                }\\n\\n                answer += 2 * (groups[i].Count - mutuals) * (groups[j].Count - mutuals);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```\\n# Like \\u2B06\\uFE0F | Share \\uD83C\\uDFAF | Favourite \\u2B50",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long DistinctNames(string[] ideas) \\n    {\\n        var groups = new HashSet<string>[26];\\n        for (int i = 0; i < 26; i++)\\n        {\\n            groups[i] = new HashSet<string>();\\n        }\\n\\n        foreach (var idea in ideas)\\n        {\\n            groups[idea[0] - \\'a\\'].Add(idea.Substring(1));\\n        }\\n\\n        long answer = 0;\\n        for (int i = 0; i < 25; i++)\\n        {\\n            for (int j = i + 1; j < 26; j++)\\n            {\\n                int mutuals = 0;\\n                foreach (var ideaA in groups[i])\\n                {\\n                    if (groups[j].Contains(ideaA))\\n                    {\\n                        mutuals++;\\n                    }\\n                }\\n\\n                answer += 2 * (groups[i].Count - mutuals) * (groups[j].Count - mutuals);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162944,
                "title": "naming-company-using-hashmap-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBeing in brute force we will take two loops and create a function that swaps the first characters and checks whether they are equal or not.... but we are getting TLE:...Hence this cannot be good approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we will create a dictionary with the first character as the dictionary key and value takes the list of words that are starting with the same character...\\n\\n        wordmap=collections.defaultdict(set)\\n        Ouput...:- defaultdict(<class \\'set\\'>, {})\\n\\nWe will create a map for the starting character to the suffix of the string.....\\n\\nAfter creating we will try to find the valid strings that can be used as the name for the company..\\n\\n    We wil find the intersecting words and finally we will update result..\\n\\nFor Further details Walk through the code....\\n\\n \\n\\n# Code\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        hashmap=collections.defaultdict(set)\\n        for char in ideas:\\n            hashmap[char[0]].add(char[1:])\\n        #Creating the map for the character to the suffix....\\n        res=0\\n        for char1 in hashmap:\\n            for char2 in hashmap:\\n                if char1==char2:\\n                    continue\\n                intersect=0\\n                for words in hashmap[char1]:\\n                    if words in hashmap[char2]:\\n                        intersect+=1\\n                #finding the suffix which are equals cause we cannot use \\n#them as the name for the company....\\n                distinct1=len(hashmap[char1])-intersect\\n                distinct2=len(hashmap[char2])-intersect\\n                #find the distinct names and then add into the result..\\n                res=res+distinct1*distinct2\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        hashmap=collections.defaultdict(set)\\n        for char in ideas:\\n            hashmap[char[0]].add(char[1:])\\n        #Creating the map for the character to the suffix....\\n        res=0\\n        for char1 in hashmap:\\n            for char2 in hashmap:\\n                if char1==char2:\\n                    continue\\n                intersect=0\\n                for words in hashmap[char1]:\\n                    if words in hashmap[char2]:\\n                        intersect+=1\\n                #finding the suffix which are equals cause we cannot use \\n#them as the name for the company....\\n                distinct1=len(hashmap[char1])-intersect\\n                distinct2=len(hashmap[char2])-intersect\\n                #find the distinct names and then add into the result..\\n                res=res+distinct1*distinct2\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162872,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force : Check for every pair of words that will be O(n^2)\\nOptimised : Group the words on the basis of first character of every word\\nAfter grouping iteration will be O(group * group) that can be considered and O(26*26) as per constraint\\n\\n# Code\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        //grouping the words of ideas array on the basis of first character\\n        Map<Character, Set<String>> map = new HashMap<>();\\n        //As we crerating group on the basis of first character, I can store all the words in the grop without first character\\n        //to handle the same suffix scenario\\n        for(String idea : ideas){\\n            char c = idea.charAt(0);\\n            if(!map.containsKey(c))\\n                map.put(c, new HashSet<>());\\n            map.get(c).add(idea.substring(1,idea.length()));\\n        }\\n        // System.out.println(map);\\n        long result = 0;\\n\\n        //now for every group check the suffixes of group 1 with iterative group2 if common suffixes maintain a count of it\\n        //non common suffixes can concatinate and make valid words\\n\\n        for(Map.Entry<Character, Set<String>> key1 : map.entrySet()){\\n            Set<String> group1 = key1.getValue();\\n            for(Map.Entry<Character, Set<String>> key2 : map.entrySet()){\\n                if(key1 == key2)\\n                    continue;\\n                int commonSuffixes = 0;\\n                Set<String> group2 = key2.getValue();\\n                for(String suffix : group1){\\n                    if(group2.contains(suffix))\\n                        commonSuffixes++;\\n                }\\n\\n                int validSuffixes1 = group1.size() - commonSuffixes;\\n                int validSuffixes2 = group2.size() - commonSuffixes;\\n\\n                result += (validSuffixes1 * validSuffixes2);\\n            }\\n        }   \\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        //grouping the words of ideas array on the basis of first character\\n        Map<Character, Set<String>> map = new HashMap<>();\\n        //As we crerating group on the basis of first character, I can store all the words in the grop without first character\\n        //to handle the same suffix scenario\\n        for(String idea : ideas){\\n            char c = idea.charAt(0);\\n            if(!map.containsKey(c))\\n                map.put(c, new HashSet<>());\\n            map.get(c).add(idea.substring(1,idea.length()));\\n        }\\n        // System.out.println(map);\\n        long result = 0;\\n\\n        //now for every group check the suffixes of group 1 with iterative group2 if common suffixes maintain a count of it\\n        //non common suffixes can concatinate and make valid words\\n\\n        for(Map.Entry<Character, Set<String>> key1 : map.entrySet()){\\n            Set<String> group1 = key1.getValue();\\n            for(Map.Entry<Character, Set<String>> key2 : map.entrySet()){\\n                if(key1 == key2)\\n                    continue;\\n                int commonSuffixes = 0;\\n                Set<String> group2 = key2.getValue();\\n                for(String suffix : group1){\\n                    if(group2.contains(suffix))\\n                        commonSuffixes++;\\n                }\\n\\n                int validSuffixes1 = group1.size() - commonSuffixes;\\n                int validSuffixes2 = group2.size() - commonSuffixes;\\n\\n                result += (validSuffixes1 * validSuffixes2);\\n            }\\n        }   \\n\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162680,
                "title": "java-c-100-solution-using-hashing-naming-a-company",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String>[] initialGroup = new HashSet[26];\\n        for (int i = 0; i < 26; ++i) {\\n            initialGroup[i] = new HashSet<>();\\n        }\\n        for (String idea : ideas) {\\n            initialGroup[idea.charAt(0) - \\'a\\'].add(idea.substring(1));\\n        }\\n\\n        long answer = 0,mutuals=0;\\n        for (int i = 0; i < 25; ++i) {\\n            for (int j = i + 1; j < 26; ++j) {\\n                mutuals = 0;\\n                for (String idea : initialGroup[i]) {\\n                    if (initialGroup[j].contains(idea))\\n                        ++mutuals;\\n                }\\n                answer += 2 * (initialGroup[i].size() - mutuals) * (initialGroup[j].size() - mutuals);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> initialGroup[26];\\n        for(auto& str: ideas)\\n            initialGroup[str[0]-\\'a\\'].insert(str.substr(1));\\n\\n        int mutuals;\\n        long long ans=0;\\n        for(int i=0;i<25;++i)\\n        {\\n            for(int j=i+1;j<26;++j)\\n            {\\n                mutuals=0;\\n                for(auto& idea: initialGroup[i])\\n                {\\n                    if(initialGroup[j].count(idea))\\n                        ++mutuals;\\n                }\\n\\n                ans += 2LL * (initialGroup[i].size()-mutuals) * (initialGroup[j].size() - mutuals); \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```Java []\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String>[] initialGroup = new HashSet[26];\\n        for (int i = 0; i < 26; ++i) {\\n            initialGroup[i] = new HashSet<>();\\n        }\\n        for (String idea : ideas) {\\n            initialGroup[idea.charAt(0) - \\'a\\'].add(idea.substring(1));\\n        }\\n\\n        long answer = 0,mutuals=0;\\n        for (int i = 0; i < 25; ++i) {\\n            for (int j = i + 1; j < 26; ++j) {\\n                mutuals = 0;\\n                for (String idea : initialGroup[i]) {\\n                    if (initialGroup[j].contains(idea))\\n                        ++mutuals;\\n                }\\n                answer += 2 * (initialGroup[i].size() - mutuals) * (initialGroup[j].size() - mutuals);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> initialGroup[26];\\n        for(auto& str: ideas)\\n            initialGroup[str[0]-\\'a\\'].insert(str.substr(1));\\n\\n        int mutuals;\\n        long long ans=0;\\n        for(int i=0;i<25;++i)\\n        {\\n            for(int j=i+1;j<26;++j)\\n            {\\n                mutuals=0;\\n                for(auto& idea: initialGroup[i])\\n                {\\n                    if(initialGroup[j].count(idea))\\n                        ++mutuals;\\n                }\\n\\n                ans += 2LL * (initialGroup[i].size()-mutuals) * (initialGroup[j].size() - mutuals); \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162540,
                "title": "python-easy-to-understand-mathing-it-chaotic-pretty-fast",
                "content": "# Intuition\\nI brute-forced it at first, but it didn\\'t work because time limit exceed.\\nSo I tried to do some analysis and math it: what is faster than lists? Dictionaries!\\nThere are two important elements to this problem: the first character of a word and the rest.\\nTherefore, I wonder if it\\'s better to classify all the words by their first letters or the other letters.\\nSince there are only 26 charaters in the English letters, it\\'s faster if we go with first letters like an actual dictionary.\\n\\nUsing the given example, ```[\"coffee\",\"donuts\",\"time\",\"toffee\"] ```, we see that if we add them to a dictionary by the first character, we get:\\n```\\n\"c\":[\"offee\"]\\n\"d\":[\"onuts\"]\\n\"t\":[\"ime\", \"offee\"]\\n```\\nNow it\\'s just a problem of combinations!\\n\\nWe just need to calculate the different combinations between two letters!\\nWe see that ```\"offee\"``` appears for both ```\"c\"``` and ```\"t\"```, we know that when we swap ```\"toffee\"``` and ```\"coffee\"```, they will generate the same words that are already in idea, so when we calculate the combinations between two letters we just ignore them. \\nWhat does that mean? The interesections between words that have the same word[1:] should be ignored.\\n\\nFrom this we know that the values of the dictionary would be better stored as sets than lists, because sets have a built in intersection method and sets are cooler(they are faster) anyways.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet letter `l1` and letter `l2` be two of the keys of a dictionary book, `word` be partial words like `\"offee\"` of `\"coffee\"`, and `common` be the intersection of sets of `l1` and `l2`:\\nThe formula now is:  `combinations = (len(l1)-len(common))*(len(l2)-len(common))`\\n\\n# Complexity\\n- Time complexity:`O(n^2)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n\\n# Code\\n```\\nfrom itertools import combinations\\n\\nclass Solution(object):\\n    def distinctNames(self, ideas):\\n        \"\"\"\\n        :type ideas: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n        count, book, lengths = 0, {}, {}\\n\\n        for word in ideas:\\n            if word[0] not in book: book[word[0]] = set()\\n            book[word[0]].add(word[1:])\\n\\n        for letter in book.keys():\\n            lengths[letter] = len(book[letter])\\n\\n        letters = book.keys()\\n        for i in range(len(letters)-1):\\n            l1 = letters[i]\\n            for j in range(i+1, len(letters)):\\n                l2 = letters[j]\\n                common = len(book[l1].intersection(book[l2]))\\n                count+= (lengths[l1]-common)*(lengths[l2]-common)\\n\\n        return count*2\\n```\\nO and times 2 at the end because ab is different from ba ciao~",
                "solutionTags": [
                    "Python"
                ],
                "code": "```[\"coffee\",\"donuts\",\"time\",\"toffee\"] ```\n```\\n\"c\":[\"offee\"]\\n\"d\":[\"onuts\"]\\n\"t\":[\"ime\", \"offee\"]\\n```\n```\"offee\"```\n```\"c\"```\n```\"t\"```\n```\"toffee\"```\n```\"coffee\"```\n```\\nfrom itertools import combinations\\n\\nclass Solution(object):\\n    def distinctNames(self, ideas):\\n        \"\"\"\\n        :type ideas: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n        count, book, lengths = 0, {}, {}\\n\\n        for word in ideas:\\n            if word[0] not in book: book[word[0]] = set()\\n            book[word[0]].add(word[1:])\\n\\n        for letter in book.keys():\\n            lengths[letter] = len(book[letter])\\n\\n        letters = book.keys()\\n        for i in range(len(letters)-1):\\n            l1 = letters[i]\\n            for j in range(i+1, len(letters)):\\n                l2 = letters[j]\\n                common = len(book[l1].intersection(book[l2]))\\n                count+= (lengths[l1]-common)*(lengths[l2]-common)\\n\\n        return count*2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162518,
                "title": "easy-c-solution-using-hashing",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Creating an vector as map its datatype which contains all lowercase alpha size i.e 26.\\n2. inserting at first letter position of string the remaining string.\\n3. Now for each character i.e a-z we are comparing all and inserting pairs map in 1 map.\\n4. then adding up the 2 times of difference of both initial to later achieved size of new map.\\n5. returning the ans.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long ans = 0;\\n        int n=ideas.size();\\n        vector<unordered_map<string,int>> x(26);\\n        for (int i=0;i<n;i++){\\n            x[ideas[i][0]-\\'a\\'][ideas[i].substr(1)]=1;\\n        }\\n        for (int i=0;i<25;i++) {\\n            for (int j=i+1;j<26;j++) {\\n                unordered_map<string,int> y;\\n                y = x[i];\\n                y.insert(x[j].begin(),x[j].end());\\n                ans+=2*(y.size()-x[i].size())*(y.size()-x[j].size());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long ans = 0;\\n        int n=ideas.size();\\n        vector<unordered_map<string,int>> x(26);\\n        for (int i=0;i<n;i++){\\n            x[ideas[i][0]-\\'a\\'][ideas[i].substr(1)]=1;\\n        }\\n        for (int i=0;i<25;i++) {\\n            for (int j=i+1;j<26;j++) {\\n                unordered_map<string,int> y;\\n                y = x[i];\\n                y.insert(x[j].begin(),x[j].end());\\n                ans+=2*(y.size()-x[i].size())*(y.size()-x[j].size());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162423,
                "title": "clean-swift-solution",
                "content": "# Complexity\\n- Time complexity: O(n * m)\\n\\n- Space complexity: O(n * m)\\n\\n# Code\\n```\\nclass Solution {\\n    func distinctNames(_ ideas: [String]) -> Int {\\n        var suffixesByFirstLetter: [Character: Set<String>] = [:]\\n        for idea in ideas {\\n            var chars = Array(idea)\\n            let firstChar = chars[0]\\n            let suffix = String(chars[1..<chars.count])\\n            suffixesByFirstLetter[firstChar, default: []].insert(suffix)\\n        }\\n\\n        var answer = 0\\n\\n        var keys = Array(suffixesByFirstLetter.keys)\\n        var n = keys.count\\n        for i in 0..<n {\\n            for j in (i + 1)..<n {\\n                let suffixes1 = suffixesByFirstLetter[keys[i]]!\\n                let suffixes2 = suffixesByFirstLetter[keys[j]]!\\n                let uniqueSuffixes1 = suffixes1.subtracting(suffixes2).count\\n                let uniqueSuffixes2 = suffixes2.subtracting(suffixes1).count\\n\\n                answer += 2 * uniqueSuffixes1 * uniqueSuffixes2\\n            }\\n        }\\n\\n        return answer\\n    }\\n}\\n```\\n---\\n\\nIf my LeetCode solution was helpful, kindly upvote it to support my contributions and aid others in their coding journey! \\uD83D\\uDE0A\\uD83D\\uDC4D",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distinctNames(_ ideas: [String]) -> Int {\\n        var suffixesByFirstLetter: [Character: Set<String>] = [:]\\n        for idea in ideas {\\n            var chars = Array(idea)\\n            let firstChar = chars[0]\\n            let suffix = String(chars[1..<chars.count])\\n            suffixesByFirstLetter[firstChar, default: []].insert(suffix)\\n        }\\n\\n        var answer = 0\\n\\n        var keys = Array(suffixesByFirstLetter.keys)\\n        var n = keys.count\\n        for i in 0..<n {\\n            for j in (i + 1)..<n {\\n                let suffixes1 = suffixesByFirstLetter[keys[i]]!\\n                let suffixes2 = suffixesByFirstLetter[keys[j]]!\\n                let uniqueSuffixes1 = suffixes1.subtracting(suffixes2).count\\n                let uniqueSuffixes2 = suffixes2.subtracting(suffixes1).count\\n\\n                answer += 2 * uniqueSuffixes1 * uniqueSuffixes2\\n            }\\n        }\\n\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744285,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> count[26];\\n        for (auto& s: ideas)\\n            count[s[0] - \\'a\\'].insert(s.substr(1));\\n        long long res = 0;\\n        for(int i = 0; i < 26; ++i)\\n            for(int j = i + 1; j < 26; ++j) {   \\n                long long c1 = 0L, c2 = 0L;\\n                for (auto& c: count[i])\\n                    if (!count[j].count(c)) c1++;\\n                for (auto& c: count[j])\\n                    if (!count[i].count(c)) c2++;\\n                res += c1 * c2;\\n            }\\n        return res * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> count[26];\\n        for (auto& s: ideas)\\n            count[s[0] - \\'a\\'].insert(s.substr(1));\\n        long long res = 0;\\n        for(int i = 0; i < 26; ++i)\\n            for(int j = i + 1; j < 26; ++j) {   \\n                long long c1 = 0L, c2 = 0L;\\n                for (auto& c: count[i])\\n                    if (!count[j].count(c)) c1++;\\n                for (auto& c: count[j])\\n                    if (!count[i].count(c)) c2++;\\n                res += c1 * c2;\\n            }\\n        return res * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182239,
                "title": "c-o-61-n-time-and-o-10-n-space-bit-masking-group-by-suffixes",
                "content": "I was surprised to see that there are ony few bitmasking related solutions(maybe using bitmasks to improve runtime in these kinds of problems are not very popular) in the dicuss section, hence I\\'m posting mine.\\n\\n**Solution Idea**:\\n1. we have 2 hashmaps, one for storing `suffix -> mask` and another for storing `suffix -> group` where, `suffix` is the substring `ai[1..n - 1]` for any string `ai` in ideas, group is a set of strings having the same `suffix`, and `mask` represents the bitmask of characters present as starting letters in any string of a group.\\n2. we have another matrix 26 x 26 matrix `cnt`, where at any point of time `cnt[x][y]` represents the number of strings which we have seen so far having `x` as a starting letter and doesn\\'t have any string with `y` as a starting letter in its `group`   \\n3. traverse the strings group by group at a time and for each string in any group count the total number of strings in the previous groups it can pair with, this can be found by adding `cnt[x][y]` to answer where x can be any character which is not in current group\\'s bitmask and y is the `ai[0]`(starting letter of current string)\\n4. update the `cnt` matrix by again traversing the current group. For each character `x` which is not present in the current group\\'s bitmask do, `cnt[y][x]++` where `y` is the starting letter of the current string `ai`. By doing this we are saying that \"ok, we have a string with staring letter `x` which can be grouped with any string with `y` as a starting letter in the future.\\n5. return `2 * ans` because if we can make a pair (ai, aj), we can also make a pair (aj, ai)\\n\\n**Code:**\\n```\\n\\tlong long distinctNames(vector<string>& ideas) {\\n      unordered_map<string, int> masks;\\n      unordered_map<string, vector<string>> groups;\\n      \\n      for (auto &ai: ideas) {\\n        string suff = ai.substr(1);\\n        groups[suff].push_back(ai);\\n        masks[suff] |= 1 << (ai[0] - \\'a\\');\\n      }\\n      \\n      long long ans = 0;\\n      int cnt[26][26] = {};\\n      for (auto &[suff, group]: groups) {\\n        int curr_mask = masks[suff];\\n        for (auto &ai: group) {\\n          for (int i = 0; i < 26; i++) {\\n            if (curr_mask & (1 << i)) continue;\\n            ans += cnt[i][ai[0] - \\'a\\'];\\n          }\\n        }\\n        \\n        for (auto &ai: group) {\\n          for (int i = 0; i < 26; i++) {\\n            if (curr_mask & (1 << i)) continue;\\n            cnt[ai[0] - \\'a\\'][i]++;\\n          }\\n        }\\n      }\\n      \\n      return 2 * ans;\\n    }\\n```\\n\\n**Complexity Analysis**:\\n*Time Complexity*: \\n\\nThe preprocessing step takes `O(9*N)` time (because we are iterating over all strings and for each string we\\'re processing the `suffix[1..n - 1]` of that string which can have length of at most 9.\\n```\\nfor (auto &ai: ideas) {\\n\\tstring suff = ai.substr(1);\\n\\tgroups[suff].push_back(ai);\\n\\tmasks[suff] |= 1 << (ai[0] - \\'a\\');\\n}\\n```\\n\\nThen we\\'re traversing each group, that\\'s `O(N)`\\n```\\nfor (auto &[suff, group]: groups) {\\n\\t...\\n}\\n```\\n\\nand in each group, we\\'re doing 3 things\\n\\nfirst, we\\'re getting the current mask using the suffix of the group, that\\'s `O(L = 9)`, where L is the maximum length of the suffix\\n```\\nfor (auto &[suff, group]: groups) {\\n\\tint curr_mask = masks[suff];\\n\\t...\\n}\\n```\\n\\nnext, for each string in the current group, we have a loop that runs 26 times and inside that we\\'ve a bitwise operation, that\\'s `O(26)` (note that I\\'m considering the cost of the bitwise operation as `O(1)` here, although some people will argue it\\'s `O(log2(26))`. For more details on this topic refer [Time complexity of bitwise operators in C++](https://leetcode.com/discuss/general-discussion/375033/bitwise-operators-complexity/338350))\\n```\\nfor (auto &[suff, group]: groups) {\\n\\t...\\n\\tfor (auto &ai: group) {\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif (curr_mask & (1 << i)) continue;\\n\\t\\t\\tans += cnt[i][ai[0] - \\'a\\'];\\n  }\\n}\\n```\\n\\nthen at last we have a loop that runs 26 times for each string in the current group and update the `cnt` matrix, that\\'s `O(26)` again\\n```\\nfor (auto &[suff, group]: groups) {\\n\\t...\\n\\tfor (auto &ai: group) {\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif (curr_mask & (1 << i)) continue;\\n\\t\\t\\tcnt[ai[0] - \\'a\\'][i]++;\\n\\t\\t}\\n\\t}\\n}\\n```\\nsumming up, we have `O(9 * N + N * (9 + 26 + 26))` = `O(9 * N + 61 * N)`\\nwhich is `O(61 * N)`\\n\\n*Space Complexity*: \\nwe are using 2 hashmaps and one can have upto `n` strings with each string having a maximum length of 10. Hence, the space complexity would be `O(10 * N)`\\n\\nThis solution actually has a good runtime but it could be improved a bit by some more preprocessing and removing redundant code\\n![image](https://assets.leetcode.com/users/images/ef324b4f-8265-46ef-813a-5df0a0803cc6_1655886008.4441223.png) \\n\\nEDIT: I have made a [video](https://youtu.be/Agq8fyvvFy0) in which I have explained my thought process and how I arrive at this solution. In case you\\'re interested in a detailed solution explanation with the techniques I have used, check it out!\\n\\nThanks for reading",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\n\\tlong long distinctNames(vector<string>& ideas) {\\n      unordered_map<string, int> masks;\\n      unordered_map<string, vector<string>> groups;\\n      \\n      for (auto &ai: ideas) {\\n        string suff = ai.substr(1);\\n        groups[suff].push_back(ai);\\n        masks[suff] |= 1 << (ai[0] - \\'a\\');\\n      }\\n      \\n      long long ans = 0;\\n      int cnt[26][26] = {};\\n      for (auto &[suff, group]: groups) {\\n        int curr_mask = masks[suff];\\n        for (auto &ai: group) {\\n          for (int i = 0; i < 26; i++) {\\n            if (curr_mask & (1 << i)) continue;\\n            ans += cnt[i][ai[0] - \\'a\\'];\\n          }\\n        }\\n        \\n        for (auto &ai: group) {\\n          for (int i = 0; i < 26; i++) {\\n            if (curr_mask & (1 << i)) continue;\\n            cnt[ai[0] - \\'a\\'][i]++;\\n          }\\n        }\\n      }\\n      \\n      return 2 * ans;\\n    }\\n```\n```\\nfor (auto &ai: ideas) {\\n\\tstring suff = ai.substr(1);\\n\\tgroups[suff].push_back(ai);\\n\\tmasks[suff] |= 1 << (ai[0] - \\'a\\');\\n}\\n```\n```\\nfor (auto &[suff, group]: groups) {\\n\\t...\\n}\\n```\n```\\nfor (auto &[suff, group]: groups) {\\n\\tint curr_mask = masks[suff];\\n\\t...\\n}\\n```\n```\\nfor (auto &[suff, group]: groups) {\\n\\t...\\n\\tfor (auto &ai: group) {\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif (curr_mask & (1 << i)) continue;\\n\\t\\t\\tans += cnt[i][ai[0] - \\'a\\'];\\n  }\\n}\\n```\n```\\nfor (auto &[suff, group]: groups) {\\n\\t...\\n\\tfor (auto &ai: group) {\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tif (curr_mask & (1 << i)) continue;\\n\\t\\t\\tcnt[ai[0] - \\'a\\'][i]++;\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2159593,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Unordered Set***\\n\\n* ***Time Complexity : O(N * 26)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        int n = ideas.size();\\n        \\n        unordered_set<string> s;\\n        \\n        // insert all ideas into set\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            s.insert(ideas[i]);\\n        }\\n        \\n        vector<vector<int>> dp(26, vector<int> (26, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            string idea = ideas[i];\\n            \\n            char old_char = idea[0];\\n            \\n            // try out all possible replacement\\n            \\n            for(char new_char = \\'a\\'; new_char <= \\'z\\'; new_char++)\\n            {\\n                idea[0] = new_char;\\n                \\n                if(s.count(idea) == 0)  // if not found in set\\n                {\\n                    dp[old_char - \\'a\\'][new_char - \\'a\\']++;\\n                }\\n            }\\n        }\\n        \\n        // calculate ans\\n        \\n        long long ans = 0;\\n        \\n        for(int i = 0; i < 26; i++)\\n        {\\n            for(int j = 0; j < 26; j++)\\n            {\\n                ans += (long long) dp[i][j] * (long long) dp[j][i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        int n = ideas.size();\\n        \\n        unordered_set<string> s;\\n        \\n        // insert all ideas into set\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            s.insert(ideas[i]);\\n        }\\n        \\n        vector<vector<int>> dp(26, vector<int> (26, 0));\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            string idea = ideas[i];\\n            \\n            char old_char = idea[0];\\n            \\n            // try out all possible replacement\\n            \\n            for(char new_char = \\'a\\'; new_char <= \\'z\\'; new_char++)\\n            {\\n                idea[0] = new_char;\\n                \\n                if(s.count(idea) == 0)  // if not found in set\\n                {\\n                    dp[old_char - \\'a\\'][new_char - \\'a\\']++;\\n                }\\n            }\\n        }\\n        \\n        // calculate ans\\n        \\n        long long ans = 0;\\n        \\n        for(int i = 0; i < 26; i++)\\n        {\\n            for(int j = 0; j < 26; j++)\\n            {\\n                ans += (long long) dp[i][j] * (long long) dp[j][i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2145119,
                "title": "c-faster-than-100-simple-brute-force-easy-to-understand",
                "content": "Lets say the given array is : [coffee,cat,corn,toffee,time,tick]\\nsolution procedure : \\n1) create a map as follows : \\n  c : offee, at,orn\\n\\t  for strings coffee,cat and corn respectively\\n t : offee,ime,ick\\n\\t for strings toffee,time and tick respectively\\n2) check similar strings in map of \\'c\\' and \\'t\\' i.e. \"offee\" in this case.\\n\\tcount of similars (i) = 1\\n\\thence, count of unique combinations =>\\n\\t\\t(size of map \\'c\\' - i) * (size of map \\'t\\' - i)\\n3) since \"tat cime\" and \"cime tat\" both are valid names, thus you can multiply 2 at the beginning i.e \\n\\tcount of unique combinations =>\\n\\t  (size of map \\'c\\' - i) * (size of map \\'t\\' -i) * 2 \\n\\t\\t\\t\\t\\t\\t\\t  or\\n\\tyou can use a nested loop in which both combinations are automatically taken care of.\\n\\t\\nPS : Kindly upvote if you found this post helpful\\n\\n```\\nclass Solution {\\npublic:\\n    int intersect(unordered_set<string> &one,unordered_set<string> &two){\\n        int i=0;\\n        for(auto x : one){\\n            i+=two.count(x);\\n        }\\n        return i;\\n    }\\n    long long distinctNames(vector<string>& list) {\\n        vector<unordered_set<string> > one(26);\\n        for(auto x : list){\\n                one[x[0]-\\'a\\'].insert(x.substr(1));\\n        }\\n        long long int ans=0;\\n        for(int i=0;i<one.size();i++){\\n            for(int j=0;j<one.size();j++){\\n                if(i==j) continue;\\n                int io=intersect(one[i],one[j]);\\n                io=(one[i].size()-io)*(one[j].size()-io);\\n                ans+=io;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int intersect(unordered_set<string> &one,unordered_set<string> &two){\\n        int i=0;\\n        for(auto x : one){\\n            i+=two.count(x);\\n        }\\n        return i;\\n    }\\n    long long distinctNames(vector<string>& list) {\\n        vector<unordered_set<string> > one(26);\\n        for(auto x : list){\\n                one[x[0]-\\'a\\'].insert(x.substr(1));\\n        }\\n        long long int ans=0;\\n        for(int i=0;i<one.size();i++){\\n            for(int j=0;j<one.size();j++){\\n                if(i==j) continue;\\n                int io=intersect(one[i],one[j]);\\n                io=(one[i].size()-io)*(one[j].size()-io);\\n                ans+=io;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142406,
                "title": "trie-o-n-solution-without-hashing",
                "content": "The main idea is to store ideas reversally to Trie. Then, we can know if there is another idea having the same content except the first character. (check if there is a sibling for this node that is also a start of some ideas)\\n\\nFirst, we have to figure out `dp[c1][c2]`, which means the no. of ideas starting at `c1` that can convert to `c2`.\\n\\nIn the beginning, every idea starting at any character can convert to any other character, i.e. `dp[c][any] = num_of_ideas_starting_at[c]`\\n\\nLater, for every idea, if this idea starting at character `c1` has another string with the same content except it starts at `c2`, then `dp[c1][c2] -= 1` because we cannot convert this idea to `c2`.\\n\\nFinally, for every idea starting at character `c1`, check what character `c2` is possbile to convert. If possible, there should be `dp[c2][c1]` of ideas for this idea to use.\\n\\nTime, Space: O(n)\\n```\\nclass TrieNode {\\npublic:\\n\\tarray<TrieNode*,26> children;\\n\\tbool is_start = false;\\n};\\nTrieNode* root;\\nlong long distinctNames(vector<string>& ideas) {\\n\\tint n = ideas.size();\\n\\tlong long ans = 0;\\n\\t// starts[c] := no. of ideas starting at character c\\n\\tvector<int> starts(26);\\n\\t// dp[c1][c2] := no. of ideas starting at character c1 that can swap to c2\\n\\tvector<vector<int>> dp(26, vector<int>(26));\\n\\troot = new TrieNode();\\n\\tfor (string idea : ideas) {\\n\\t\\tint len = idea.size();\\n\\t\\tTrieNode* cur = root;\\n\\t\\tfor (int i = len-1; i >= 0; --i) {\\n\\t\\t\\tint c = idea[i] - \\'a\\';\\n\\t\\t\\tif (!cur->children[c]) cur->children[c] = new TrieNode();\\n\\t\\t\\tcur = cur->children[c];\\n\\t\\t}\\n\\t\\tstarts[idea[0]-\\'a\\']++;\\n\\t\\tcur->is_start = true;\\n\\t}\\n\\t// 1) In the beginning, every idea starting at any character can convert to any other character.\\n\\tfor (int c1 = 0; c1 < 26; ++c1) {\\n\\t\\tfor (int c2 = 0; c2 < 26; ++c2) {\\n\\t\\t\\tdp[c1][c2] = starts[c1];\\n\\t\\t}\\n\\t}\\n\\t// 2) Check which idea cannot convert to which character, then make dp[c1][c2] -= 1\\n\\tfor (string idea : ideas) {\\n\\t\\tint len = idea.size();\\n\\t\\tTrieNode* cur = root;\\n\\t\\tfor (int i = len-1; i >= 1; --i) {\\n\\t\\t\\tint c = idea[i] - \\'a\\';\\n\\t\\t\\tcur = cur->children[c];\\n\\t\\t}\\n\\t\\tfor (int c1 = idea[0]-\\'a\\', c2 = 0; c2 < 26; ++c2) {\\n\\t\\t\\tif (cur->children[c2] && cur->children[c2]->is_start)\\n\\t\\t\\t\\tdp[c1][c2]--;\\n\\t\\t}\\n\\t}\\n\\t// 3) For every idea starting at character c1, check what character c2 we can convert and append to the answer.\\n\\tfor (string idea : ideas) {\\n\\t\\tint len = idea.size();\\n\\t\\tTrieNode* cur = root;\\n\\t\\tfor (int i = len-1; i >= 1; --i) {\\n\\t\\t\\tint c = idea[i] - \\'a\\';\\n\\t\\t\\tcur = cur->children[c];\\n\\t\\t}\\n\\t\\tfor (int c1 = idea[0]-\\'a\\', c2 = 0; c2 < 26; ++c2) {\\n\\t\\t\\tif (!cur->children[c2] || !cur->children[c2]->is_start)\\n\\t\\t\\t\\tans += dp[c2][c1];\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass TrieNode {\\npublic:\\n\\tarray<TrieNode*,26> children;\\n\\tbool is_start = false;\\n};\\nTrieNode* root;\\nlong long distinctNames(vector<string>& ideas) {\\n\\tint n = ideas.size();\\n\\tlong long ans = 0;\\n\\t// starts[c] := no. of ideas starting at character c\\n\\tvector<int> starts(26);\\n\\t// dp[c1][c2] := no. of ideas starting at character c1 that can swap to c2\\n\\tvector<vector<int>> dp(26, vector<int>(26));\\n\\troot = new TrieNode();\\n\\tfor (string idea : ideas) {\\n\\t\\tint len = idea.size();\\n\\t\\tTrieNode* cur = root;\\n\\t\\tfor (int i = len-1; i >= 0; --i) {\\n\\t\\t\\tint c = idea[i] - \\'a\\';\\n\\t\\t\\tif (!cur->children[c]) cur->children[c] = new TrieNode();\\n\\t\\t\\tcur = cur->children[c];\\n\\t\\t}\\n\\t\\tstarts[idea[0]-\\'a\\']++;\\n\\t\\tcur->is_start = true;\\n\\t}\\n\\t// 1) In the beginning, every idea starting at any character can convert to any other character.\\n\\tfor (int c1 = 0; c1 < 26; ++c1) {\\n\\t\\tfor (int c2 = 0; c2 < 26; ++c2) {\\n\\t\\t\\tdp[c1][c2] = starts[c1];\\n\\t\\t}\\n\\t}\\n\\t// 2) Check which idea cannot convert to which character, then make dp[c1][c2] -= 1\\n\\tfor (string idea : ideas) {\\n\\t\\tint len = idea.size();\\n\\t\\tTrieNode* cur = root;\\n\\t\\tfor (int i = len-1; i >= 1; --i) {\\n\\t\\t\\tint c = idea[i] - \\'a\\';\\n\\t\\t\\tcur = cur->children[c];\\n\\t\\t}\\n\\t\\tfor (int c1 = idea[0]-\\'a\\', c2 = 0; c2 < 26; ++c2) {\\n\\t\\t\\tif (cur->children[c2] && cur->children[c2]->is_start)\\n\\t\\t\\t\\tdp[c1][c2]--;\\n\\t\\t}\\n\\t}\\n\\t// 3) For every idea starting at character c1, check what character c2 we can convert and append to the answer.\\n\\tfor (string idea : ideas) {\\n\\t\\tint len = idea.size();\\n\\t\\tTrieNode* cur = root;\\n\\t\\tfor (int i = len-1; i >= 1; --i) {\\n\\t\\t\\tint c = idea[i] - \\'a\\';\\n\\t\\t\\tcur = cur->children[c];\\n\\t\\t}\\n\\t\\tfor (int c1 = idea[0]-\\'a\\', c2 = 0; c2 < 26; ++c2) {\\n\\t\\t\\tif (!cur->children[c2] || !cur->children[c2]->is_start)\\n\\t\\t\\t\\tans += dp[c2][c1];\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141531,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string, int>m;\\n        for (string& id : ideas)\\n            m[id.substr(1)] |= (1 << (id[0] - \\'a\\'));\\n        vector<vector<int>>dp(26, vector<int>(26));\\n        for (auto& it : m)\\n            for (int i = 0; i < 26; i++)\\n                for (int j = 0; j < 26; j++)\\n                    if ((it.second & (1 << i)) && !(it.second & (1 << j))) dp[i][j]++;\\n        long long res = 0;\\n        for (int i = 0; i < 26; i++)\\n            for (int j = 0; j < 26; j++)\\n                res += dp[i][j] * (long long)dp[j][i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string, int>m;\\n        for (string& id : ideas)\\n            m[id.substr(1)] |= (1 << (id[0] - \\'a\\'));\\n        vector<vector<int>>dp(26, vector<int>(26));\\n        for (auto& it : m)\\n            for (int i = 0; i < 26; i++)\\n                for (int j = 0; j < 26; j++)\\n                    if ((it.second & (1 << i)) && !(it.second & (1 << j))) dp[i][j]++;\\n        long long res = 0;\\n        for (int i = 0; i < 26; i++)\\n            for (int j = 0; j < 26; j++)\\n                res += dp[i][j] * (long long)dp[j][i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141202,
                "title": "python3-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e59b5d5832483707a595ae92b9aa1fb456986009) for solutions of weekly 297\\n\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        seen = set(ideas)\\n        freq = Counter()\\n        letters = {x[0] for x in ideas}\\n        for idea in ideas: \\n            for ch in letters: \\n                if ch + idea[1:] not in seen: freq[idea[0], ch] += 1 \\n        ans = 0 \\n        for idea in ideas: \\n            for ch in letters: \\n                if ch + idea[1:] not in seen: ans += freq[ch, idea[0]]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        seen = set(ideas)\\n        freq = Counter()\\n        letters = {x[0] for x in ideas}\\n        for idea in ideas: \\n            for ch in letters: \\n                if ch + idea[1:] not in seen: freq[idea[0], ch] += 1 \\n        ans = 0 \\n        for idea in ideas: \\n            for ch in letters: \\n                if ch + idea[1:] not in seen: ans += freq[ch, idea[0]]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141022,
                "title": "c-detailed-with-comments",
                "content": "For any doubts, feel free to ask in comments.\\nUPVote if you liked.\\n\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long ans = 0;\\n        // Will map, first characrter to strings.\\n        unordered_map <char, vector<string>> mp;\\n        // All the unique first chars. (26 max possible).\\n        unordered_set <char> uni;\\n        // To check fast if the string is present in initial ideas when we change first char\\n        // of any string.\\n        unordered_set <string> ss;\\n        for (auto s : ideas) {\\n          mp[s[0]].push_back(s);\\n          ss.insert(s);\\n          uni.insert(s[0]);\\n        }\\n        /*\\n          To check if any two strings after swapping there first char, makes a good company name or NOT.\\n          We can see while swapping chars, we swapped every unique char with this string\\'s first char\\n          And then we just incremented the cnt[s[0]][ch] means s[0] when swapped with ch, ch + s.substr(1) is Not present in intial ideas\\n          We do this for all the strings.\\n          At last we have to multiply all pairs of (i, j) with (j, i) (Convince youself)\\n        */\\n        vector <vector<long long>> cnt(26, vector(26, 0LL));\\n        for (auto s : ideas) {\\n          for (auto ch : uni) {\\n            // Changing first char of s with ch.\\n            string ns = \"\";\\n            ns.push_back(ch);\\n            ns += s.substr(1);\\n            if (!ss.count(ns)) {\\n              cnt[s[0] - \\'a\\'][ch - \\'a\\']++;\\n            }\\n          }\\n        }\\n        for (int i = 0; i < 26; ++i) {\\n          for (int j = 0; j < 26; ++j) {\\n            ans += cnt[i][j] * cnt[j][i];\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long ans = 0;\\n        // Will map, first characrter to strings.\\n        unordered_map <char, vector<string>> mp;\\n        // All the unique first chars. (26 max possible).\\n        unordered_set <char> uni;\\n        // To check fast if the string is present in initial ideas when we change first char\\n        // of any string.\\n        unordered_set <string> ss;\\n        for (auto s : ideas) {\\n          mp[s[0]].push_back(s);\\n          ss.insert(s);\\n          uni.insert(s[0]);\\n        }\\n        /*\\n          To check if any two strings after swapping there first char, makes a good company name or NOT.\\n          We can see while swapping chars, we swapped every unique char with this string\\'s first char\\n          And then we just incremented the cnt[s[0]][ch] means s[0] when swapped with ch, ch + s.substr(1) is Not present in intial ideas\\n          We do this for all the strings.\\n          At last we have to multiply all pairs of (i, j) with (j, i) (Convince youself)\\n        */\\n        vector <vector<long long>> cnt(26, vector(26, 0LL));\\n        for (auto s : ideas) {\\n          for (auto ch : uni) {\\n            // Changing first char of s with ch.\\n            string ns = \"\";\\n            ns.push_back(ch);\\n            ns += s.substr(1);\\n            if (!ss.count(ns)) {\\n              cnt[s[0] - \\'a\\'][ch - \\'a\\']++;\\n            }\\n          }\\n        }\\n        for (int i = 0; i < 26; ++i) {\\n          for (int j = 0; j < 26; ++j) {\\n            ans += cnt[i][j] * cnt[j][i];\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140968,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        \\n        HashMap<Character, Set<String>> map=new HashMap<>();\\n        \\n        for(String idea: ideas)\\n        {\\n            Set<String> temp=map.getOrDefault(idea.charAt(0), new HashSet<>());\\n            temp.add(idea.substring(1));\\n            map.put(idea.charAt(0), temp);\\n        }\\n        long ans=0;\\n        for(char key: map.keySet())\\n        {\\n            Set<String> ls=map.get(key);\\n            for(char key1: map.keySet())\\n            {\\n                if(key==key1) continue;\\n                \\n                Set<String> ls1=map.get(key1);\\n                Set<String> inter=getIn(ls, ls1);\\n                \\n                Set<String> diff=getDiff(ls, inter);\\n                Set<String> diff1=getDiff(ls1, inter);\\n                \\n                ans+=((long)diff.size()*diff1.size());\\n                \\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    \\n    public Set<String> getIn(Set<String> s1, Set<String> s2)\\n    {\\n        Set<String> s=new HashSet<>();\\n        for(String c: s2)\\n            if(s1.contains(c))\\n                s.add(c);\\n        return s;\\n    }\\n    public Set<String> getDiff(Set<String> s1, Set<String> s2)\\n    {\\n        Set<String> s=new HashSet<>();\\n        for(String c: s1)\\n            if(!s2.contains(c))\\n                s.add(c);\\n        return s;\\n    }\\n    \\n}\\n```\\n\\nTime Complexity: O(26 * 26 * n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        \\n        HashMap<Character, Set<String>> map=new HashMap<>();\\n        \\n        for(String idea: ideas)\\n        {\\n            Set<String> temp=map.getOrDefault(idea.charAt(0), new HashSet<>());\\n            temp.add(idea.substring(1));\\n            map.put(idea.charAt(0), temp);\\n        }\\n        long ans=0;\\n        for(char key: map.keySet())\\n        {\\n            Set<String> ls=map.get(key);\\n            for(char key1: map.keySet())\\n            {\\n                if(key==key1) continue;\\n                \\n                Set<String> ls1=map.get(key1);\\n                Set<String> inter=getIn(ls, ls1);\\n                \\n                Set<String> diff=getDiff(ls, inter);\\n                Set<String> diff1=getDiff(ls1, inter);\\n                \\n                ans+=((long)diff.size()*diff1.size());\\n                \\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    \\n    public Set<String> getIn(Set<String> s1, Set<String> s2)\\n    {\\n        Set<String> s=new HashSet<>();\\n        for(String c: s2)\\n            if(s1.contains(c))\\n                s.add(c);\\n        return s;\\n    }\\n    public Set<String> getDiff(Set<String> s1, Set<String> s2)\\n    {\\n        Set<String> s=new HashSet<>();\\n        for(String c: s1)\\n            if(!s2.contains(c))\\n                s.add(c);\\n        return s;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006981,
                "title": "dp-based-solution-with-hashmap-ds",
                "content": "# Intuition\\n- Here for the O(N^2) solution check for each pair whether on swapping their characters 2 valid strings can be formed \\n- But this will give TLE as constraints are strict for N^2 solution\\nSo We need to check for each word\\'s first character with all the 26 characters\\n- If a valid string is formed increase the count by the number of times that appear character appears as the first character in all the strings\\n- But this approach is faulted as we need to have pairs which are both not faulted since the above does not check whether the 2nd string formed would be faulted or not\\n\\n- We can make some minor changes here to make this solution work\\n- So create a dp array of size 26* 26 which denotes that number of  valid strings for (i,j) -> ith character replaced with the jth character and a valid string is formed\\nSimilary for (j , i) -> it will denote the jth character replaced with the ith character and a valid string is formed\\n\\n- For a valid pair we need to check both (i,j) and (j,i)\\n- If dp[i][j] or dp[j][i] == 0 then the pair is not valid so we should not count that pair\\n- Else add dp[i][j] * dp[j][i] to the count variable\\n\\n\\n# Complexity\\n- Time complexity: O(26*N)\\n- Space complexity: O(26*26)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        set<string> words(ideas.begin(),ideas.end());\\n\\n        int dp[26][26];\\n        memset(dp,0,sizeof(dp));\\n\\n        for(auto word:ideas){\\n            char ch1 = word[0];\\n            for(int i=0;i<26;i++){\\n                char ch2 = i + \\'a\\'; \\n                if(ch1 == ch2)    continue;\\n                word[0] = ch2;\\n                if(words.find(word) == words.end()){\\n                   dp[ch1-\\'a\\'][ch2-\\'a\\']++;\\n                }\\n            }\\n            word[0] = ch1;\\n        }\\n\\n        long long int count = 0;\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                count += dp[i][j] * dp[j][i];   // this will automatiacally discard invalid string pairs\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n# PLEASE UPVOTE!!!",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        set<string> words(ideas.begin(),ideas.end());\\n\\n        int dp[26][26];\\n        memset(dp,0,sizeof(dp));\\n\\n        for(auto word:ideas){\\n            char ch1 = word[0];\\n            for(int i=0;i<26;i++){\\n                char ch2 = i + \\'a\\'; \\n                if(ch1 == ch2)    continue;\\n                word[0] = ch2;\\n                if(words.find(word) == words.end()){\\n                   dp[ch1-\\'a\\'][ch2-\\'a\\']++;\\n                }\\n            }\\n            word[0] = ch1;\\n        }\\n\\n        long long int count = 0;\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                count += dp[i][j] * dp[j][i];   // this will automatiacally discard invalid string pairs\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668949,
                "title": "c-set-clean",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long result = 0;\\n        // Group by first letter and it\\'s suffix\\n        vector<unordered_set<string>> count(26);\\n\\n        for (auto& idea : ideas) {\\n            count[idea[0] - \\'a\\'].insert(idea.substr(1));\\n        }\\n\\n        // permutations = unique items in set1 * unique items in set2 * 2\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                long unique1 = 0, unique2 = 0;\\n                \\n                for (auto& suffix : count[i]) {\\n                    if (count[j].find(suffix) == count[j].end())\\n                        unique1++;\\n                }\\n\\n                for (auto& suffix : count[j]) {\\n                    if (count[i].find(suffix) == count[i].end())\\n                        unique2++;\\n                }\\n\\n                result += unique1 * unique2 * 2;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long result = 0;\\n        // Group by first letter and it\\'s suffix\\n        vector<unordered_set<string>> count(26);\\n\\n        for (auto& idea : ideas) {\\n            count[idea[0] - \\'a\\'].insert(idea.substr(1));\\n        }\\n\\n        // permutations = unique items in set1 * unique items in set2 * 2\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                long unique1 = 0, unique2 = 0;\\n                \\n                for (auto& suffix : count[i]) {\\n                    if (count[j].find(suffix) == count[j].end())\\n                        unique1++;\\n                }\\n\\n                for (auto& suffix : count[j]) {\\n                    if (count[i].find(suffix) == count[i].end())\\n                        unique2++;\\n                }\\n\\n                result += unique1 * unique2 * 2;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169572,
                "title": "hard-challenge-c-simple-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMapping first character and remaining string. N^2 loop for further task.\\n# Approach\\nMap the first char each string to remaining string. If any two starting characters have a common remaining substring then that pair will not give any output.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n\\n# Please Upvote the solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        map<char,unordered_set<string>> m;\\n        long long ans=0;\\n        for(auto it:ideas){\\n            m[it[0]].insert(it.substr(1,it.size()-1));\\n        }\\n        for(auto it=m.begin();it!=m.end();it++){\\n            for(auto it2=next(it,1);it2!=m.end();it2++){\\n                unordered_set<string> s;\\n                s.insert((it->second).begin(),(it->second).end());\\n                s.insert((it2->second).begin(),(it2->second).end());\\n                ans+=(s.size()-(it->second).size())*(s.size()-(it2->second).size());\\n            }\\n        }\\n\\n        return ans*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        map<char,unordered_set<string>> m;\\n        long long ans=0;\\n        for(auto it:ideas){\\n            m[it[0]].insert(it.substr(1,it.size()-1));\\n        }\\n        for(auto it=m.begin();it!=m.end();it++){\\n            for(auto it2=next(it,1);it2!=m.end();it2++){\\n                unordered_set<string> s;\\n                s.insert((it->second).begin(),(it->second).end());\\n                s.insert((it2->second).begin(),(it2->second).end());\\n                ans+=(s.size()-(it->second).size())*(s.size()-(it2->second).size());\\n            }\\n        }\\n\\n        return ans*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168677,
                "title": "python-clean-simple-pre-processing-solution-beats-83-87",
                "content": "\\n# *Complexity*\\n- *Time complexity: $$O(n*m)$$*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. *We group words in $$ideas$$ by their initials, it takes $$O(m)$$ time to hash a string of length $$m$$, thus it takes $$O(n*m)$$ time to hash and store $$n$$ strings.*\\n2. *We need to try every pair of initials, there are $$26*25/2=325$$ pairs of initials. For each pair of groups, we need to find the number of mutual suffixes by iterating one of the groups which takes up to $$O(n*m)$$\\n- *Space complexity:$$O(n*m)$$*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. *We store the suffixes of all words in an array of sets, it takes $$O(n*m)$$*\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        pre_processed = [set() for _ in range(26)]\\n        for idea in ideas:\\n            pre_processed[ord(idea[0]) - ord(\\'a\\')].add(idea[1:])\\n        \\n        ans = 0\\n        for i in range(25):\\n            for j in range(i+1,26):\\n                num_of_mutual = len(pre_processed[i].intersection(pre_processed[j]))\\n                ans += 2*(len(pre_processed[i])- num_of_mutual) * (len(pre_processed[j]) - num_of_mutual)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        pre_processed = [set() for _ in range(26)]\\n        for idea in ideas:\\n            pre_processed[ord(idea[0]) - ord(\\'a\\')].add(idea[1:])\\n        \\n        ans = 0\\n        for i in range(25):\\n            for j in range(i+1,26):\\n                num_of_mutual = len(pre_processed[i].intersection(pre_processed[j]))\\n                ans += 2*(len(pre_processed[i])- num_of_mutual) * (len(pre_processed[j]) - num_of_mutual)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167953,
                "title": "easy-solution-java",
                "content": "\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        \\nSet<String> s = new HashSet<>();\\n        for(String word:ideas){\\n            s.add(word);\\n        }\\n        \\n        int[][] dic = new int[26][26];\\n        for(int i=0;i<ideas.length;i++){\\n            String word = ideas[i].substring(1);\\n            \\n            char fc = ideas[i].charAt(0);\\n            \\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                String temp = c+word;\\n                if(!s.contains(temp)){\\n                    dic[fc-\\'a\\'][c-\\'a\\']+=1;\\n                }\\n            }\\n        }\\n        \\n        long ans = 0;\\n        for(int i=0;i<26;i++){\\n            for(int j =0;j<26;j++){\\n                if(dic[i][j]>0){\\n                    ans+=dic[i][j]*dic[j][i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        \\nSet<String> s = new HashSet<>();\\n        for(String word:ideas){\\n            s.add(word);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3165552,
                "title": "c-dictionary-and-2d-array-short-runtime-beats-100",
                "content": "# Intuition\\n- There are too many words in `ideas` for trying every pair-wise combination\\n- Two words \"prefixAsuffixA\" and \"prefixBsuffixB\" may be combined if \\n\"prefixBsuffixA\" and \"prefixAsuffixB\" do not exist in `ideas`. To count the cases where the two new words are not in `ideas`, we should count, for each suffix, which combinations of two prefixes exist. \\n# Approach\\nWe first start by categorising the `ideas` words by their suffixes (the word except for its first letter). To do that, we can use a Dictionary for the mapping of `suffix` to `List of prefix characters`. As all words in `ideas` are unique, each first letter can only be once in each suffix category.\\n\\nThen, we can count for each letter in each of these suffix categories with what other letters they are in a category. For that, we define the two-dimensional array `cc`, with `cc[x, y]` being the number of prefix characters `x` in categories also containing prefix character `y`. \\nThe diagonal elements equal to the total occurences of the respective characters, as each character is in a suffic category with itself. This matrix is also symmetric to its diagonal, as `y` being in a category with `x` results from `x` being in a category with `y`.\\n\\nTo calculate the number of combinations, we can separately regard every combination of two prefixes (there are $$26*26 = 676$$ such combinations). The combination $$x, y$$ will result in $$(\\\\text{number of words starting with x not in a suffix categroy with y})*(\\\\text{number of words starting with y not in a suffix categroy with x})$$ valid company names. \\nWe can conveniently compute:\\n $$\\\\text{number of words starting with x not in a suffix categroy with y} = \\\\text{number of words starting with x} - \\\\text{number of words starting with x in a suffix categroy with y}  = \\\\text{cc[x,x]} -\\\\text{cc[x,y]}$$\\nand vice versa. \\nThe result equals the sum of all these products.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*x +x^2)$$ with $$n =$$`ideas.Length` and $$x$$ being the number of letter in the alphabet\\n\\n- Space complexity:\\n$$O(n +x^2)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long DistinctNames(string[] ideas) {\\n\\n        var suffixCategories = new Dictionary<string, List<char>>();\\n        for (int i = 0; i < ideas.Length; i++)\\n        {\\n            string suffix = ideas[i].Substring(1);\\n            if (!suffixCategories.ContainsKey(suffix))\\n                suffixCategories.Add(suffix, new List<char>());\\n            suffixCategories[suffix].Add(ideas[i][0]);\\n        }\\n\\n        // cc[x, y] = number of words starting with \"x\" that are in suffix categoires containing \"y\"\\n        int[,] cc = new int[26, 26];\\n        foreach(var v in suffixCategories.Values)\\n            foreach(char c in v)\\n                foreach(char d in v)\\n                    cc[c - \\'a\\', d - \\'a\\']++;\\n        \\n        long result = 0;\\n        for(int i = 0; i < 26; i++)\\n            for (int j = 0; j < 26; j++)\\n                result += (cc[i, i] - cc[i, j]) * (cc[j, j] - cc[i, j]);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long DistinctNames(string[] ideas) {\\n\\n        var suffixCategories = new Dictionary<string, List<char>>();\\n        for (int i = 0; i < ideas.Length; i++)\\n        {\\n            string suffix = ideas[i].Substring(1);\\n            if (!suffixCategories.ContainsKey(suffix))\\n                suffixCategories.Add(suffix, new List<char>());\\n            suffixCategories[suffix].Add(ideas[i][0]);\\n        }\\n\\n        // cc[x, y] = number of words starting with \"x\" that are in suffix categoires containing \"y\"\\n        int[,] cc = new int[26, 26];\\n        foreach(var v in suffixCategories.Values)\\n            foreach(char c in v)\\n                foreach(char d in v)\\n                    cc[c - \\'a\\', d - \\'a\\']++;\\n        \\n        long result = 0;\\n        for(int i = 0; i < 26; i++)\\n            for (int j = 0; j < 26; j++)\\n                result += (cc[i, i] - cc[i, j]) * (cc[j, j] - cc[i, j]);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165548,
                "title": "python-short-and-clean-functional-programming",
                "content": "# Approach\\n1. Split each `idea` into first letter prefix and rest letters suffix.\\n    Ex: `batman -> b _ atman`.\\n\\n2. Group `idea` suffixes with same prefixes together.\\n\\n3. For every pair of groups, say `ga` and `gb`:\\n    1. We can join each suffix in `ga` with each suffix in `gb`, except if they are the same suffix.\\n    2. Hence remove the common suffixes and count the number of pairs.\\n    3. Common suffixes, say `gab = ga \\u2229 gb`\\n    4. Pair counts = `(|ga| - |gab|) * (|gb| * |gab|)`\\n\\n4. Sum all the counts and return.\\n\\n5. Note:\\n    Since intersection of groups is symmetric, we can optimize by only considering one of the two ordering.\\n    We can also use hash of suffix instead of the entire string.\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is length of ideas` and `m is average length of an idea`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def distinctNames(self, ideas: list[str]) -> int:\\n        groups = defaultdict(set)\\n        for idea in ideas: groups[idea[0]].add(hash(idea[1:]))\\n        \\n        return sum(\\n            (len(ga) - len(gab)) * (len(gb) - len(gab))\\n            for ga, gb in combinations_with_replacement(groups.values(), 2)\\n            for gab in (ga & gb,)\\n        ) * 2\\n\\n\\n```\\n\\nSame as above. Imperative version:\\n```python\\nclass Solution:\\n    def distinctNames(self, ideas: list[str]) -> int:\\n        groups = defaultdict(set)\\n        for idea in ideas: groups[idea[0]].add(hash(idea[1:]))\\n        \\n        values = tuple(groups.values())\\n        n = len(values)\\n        count = 0\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                ga, gb = values[i], values[j]\\n                gab = ga & gb\\n                count += (len(ga) - len(gab)) * (len(gb) - len(gab))\\n\\n        return count * 2\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Enumeration"
                ],
                "code": "```python\\nclass Solution:\\n    def distinctNames(self, ideas: list[str]) -> int:\\n        groups = defaultdict(set)\\n        for idea in ideas: groups[idea[0]].add(hash(idea[1:]))\\n        \\n        return sum(\\n            (len(ga) - len(gab)) * (len(gb) - len(gab))\\n            for ga, gb in combinations_with_replacement(groups.values(), 2)\\n            for gab in (ga & gb,)\\n        ) * 2\\n\\n\\n```\n```python\\nclass Solution:\\n    def distinctNames(self, ideas: list[str]) -> int:\\n        groups = defaultdict(set)\\n        for idea in ideas: groups[idea[0]].add(hash(idea[1:]))\\n        \\n        values = tuple(groups.values())\\n        n = len(values)\\n        count = 0\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                ga, gb = values[i], values[j]\\n                gab = ga & gb\\n                count += (len(ga) - len(gab)) * (len(gb) - len(gab))\\n\\n        return count * 2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165439,
                "title": "o-n-o-n-python-solution-explained",
                "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, we are giving an array of strings `ideas`, we want to return `valid distinct names for companies`\\n\\nThe restrictions are as follows:\\n1) If both of the new names are not found in the original ideas, then the name ideaA ideaB (the concatenation of ideaA and ideaB, separated by a space) is a valid company name.\\n\\n2) Otherwise, it is not a valid name.\\n\\n### Explanation\\nWe can use `Hashset` to help us validate distinct names. If we want to know the number of distinct company names formed by ideas array, we only need to pay attention to the first character of our two words as that will be our key to help us group suffixes together.\\n\\nFor each set of grouped suffixes based on the first character, we will now look at their suffixes to see if any other group have the same suffix, If so, we will subtract it to make our grouped suffix to be distinct\\n\\n#### Example: \\n\\n```\\nc -> [at, offee] -> 2 - 1(offee) = 1 distinct suffix\\n\\nd -> [onuts] -> 1 distinct suffix\\n \\nt -> [ime, offee] -> 2 - 1 (offee) =  1 distinct suffix\\n```\\n\\n#### Algorithm steps:\\n\\n1) Group ideas based on the first letter\\n\\n2) When comparing two words, if same words appears in both set(), then the word must not be a valid name\\n\\n3) Remove the same words then calculate how many unique suffix are in the list\\n\\n4) To make a valid name with two words: \\n\\n     - Multiply the first suffix\\n     \\n     - Multiply the second suffix * 2\\n     \\nWe are multiplying by `2` is because once we found a distinct suffix, we can use the suffix to also create another pair of words. \\n\\n **Example**: **``coffee, donuts` -> `doffee conuts`,  `conuts doffee``**\\n     \\n### Code\\t \\n\\t \\n```\\n def distinctNames(self, ideas: List[str]) -> int:\\n        \\n        nameMap = collections.defaultdict(set)\\n        result = 0\\n\\n        for word in ideas: \\n            # first char as keys -  nameMap[word[0]]\\n            # suffixes as values - word[1:]\\n            nameMap[word[0]].add(word[1:])\\n            \\n        keys = list(nameMap.keys())\\n        n = len(keys)\\n        \\n        # traverse through first char\\n        for char1 in range(n):\\n    \\n            for char2 in range(char1 + 1, n):\\n                key1, key2 = keys[char1], keys[char2]\\n                \\n                value1, value2 = nameMap[key1], nameMap[key2]\\n      \\n                duplicated_suffixes = len(value1 & value2)\\n                \\n                if key1 == key2: continue\\n                \\n                result += (len(value1) - duplicated_suffixes) * (len(value2) - duplicated_suffixes) * 2\\n\\n        return result\\n```\\n\\n#### Time complexity: O(n)\\n#### Space complexity:  O(n)\\n\\n***Upvote if this tenno\\'s discussion helped you in some type of way***\\n \\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nc -> [at, offee] -> 2 - 1(offee) = 1 distinct suffix\\n\\nd -> [onuts] -> 1 distinct suffix\\n \\nt -> [ime, offee] -> 2 - 1 (offee) =  1 distinct suffix\\n```\n```\\n def distinctNames(self, ideas: List[str]) -> int:\\n        \\n        nameMap = collections.defaultdict(set)\\n        result = 0\\n\\n        for word in ideas: \\n            # first char as keys -  nameMap[word[0]]\\n            # suffixes as values - word[1:]\\n            nameMap[word[0]].add(word[1:])\\n            \\n        keys = list(nameMap.keys())\\n        n = len(keys)\\n        \\n        # traverse through first char\\n        for char1 in range(n):\\n    \\n            for char2 in range(char1 + 1, n):\\n                key1, key2 = keys[char1], keys[char2]\\n                \\n                value1, value2 = nameMap[key1], nameMap[key2]\\n      \\n                duplicated_suffixes = len(value1 & value2)\\n                \\n                if key1 == key2: continue\\n                \\n                result += (len(value1) - duplicated_suffixes) * (len(value2) - duplicated_suffixes) * 2\\n\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3165243,
                "title": "a-simple-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} ideas\\n * @return {number}\\n */\\nvar distinctNames = function(ideas) {\\n      const suf = Array.from({length: 26}, () => new Set());\\n\\n  for (const A of ideas)\\n    suf[A.charCodeAt(0)-97].add(A.slice(1))\\n\\n  let pairs = 0;\\n\\n  for (let i = 0; i < 25; i++) {\\n    for (let j = i+1; j < 26; j++) {\\n      let mutual = 0;\\n      for (const B of suf[i])\\n        if (suf[j].has(B))\\n          mutual++\\n\\n      pairs += (suf[i].size - mutual) * (suf[j].size - mutual)\\n    }\\n  }\\n      \\n  return pairs * 2\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} ideas\\n * @return {number}\\n */\\nvar distinctNames = function(ideas) {\\n      const suf = Array.from({length: 26}, () => new Set());\\n\\n  for (const A of ideas)\\n    suf[A.charCodeAt(0)-97].add(A.slice(1))\\n\\n  let pairs = 0;\\n\\n  for (let i = 0; i < 25; i++) {\\n    for (let j = i+1; j < 26; j++) {\\n      let mutual = 0;\\n      for (const B of suf[i])\\n        if (suf[j].has(B))\\n          mutual++\\n\\n      pairs += (suf[i].size - mutual) * (suf[j].size - mutual)\\n    }\\n  }\\n      \\n  return pairs * 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164959,
                "title": "swift-676-ms-run-time-beats-100-with-comments",
                "content": "# Code\\n```\\nclass Solution {\\n    func distinctNames(_ ideas: [String]) -> Int {\\n        // Group idea by their initials.\\n        var initialGroup = Array(repeating: Set<String>(), count: 26)\\n        for idea in ideas {\\n            let index = idea.first!.unicodeScalars.first!.value - Unicode.Scalar(\"a\").value\\n            initialGroup[Int(index)].insert(String(idea.dropFirst()))\\n        }\\n        \\n        // Calculate number of valid names from every pair of groups.\\n        var answer: Int = 0\\n        for i in 0..<25 {\\n            for j in i+1..<26 {\\n                // Get the number of mutual suffixes.\\n                var numOfMutual = 0\\n                for ideaA in initialGroup[i] {\\n                    if initialGroup[j].contains(ideaA) {\\n                        numOfMutual += 1\\n                    }\\n                }\\n                \\n                // Valid names are only from distinct suffixes in both groups.\\n                // Since we can swap a with b and swap b with a to create two valid names, multiple answer by 2.\\n                answer += 2 * (initialGroup[i].count - numOfMutual) * (initialGroup[j].count - numOfMutual)\\n            }\\n        }\\n        \\n        return answer\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distinctNames(_ ideas: [String]) -> Int {\\n        // Group idea by their initials.\\n        var initialGroup = Array(repeating: Set<String>(), count: 26)\\n        for idea in ideas {\\n            let index = idea.first!.unicodeScalars.first!.value - Unicode.Scalar(\"a\").value\\n            initialGroup[Int(index)].insert(String(idea.dropFirst()))\\n        }\\n        \\n        // Calculate number of valid names from every pair of groups.\\n        var answer: Int = 0\\n        for i in 0..<25 {\\n            for j in i+1..<26 {\\n                // Get the number of mutual suffixes.\\n                var numOfMutual = 0\\n                for ideaA in initialGroup[i] {\\n                    if initialGroup[j].contains(ideaA) {\\n                        numOfMutual += 1\\n                    }\\n                }\\n                \\n                // Valid names are only from distinct suffixes in both groups.\\n                // Since we can swap a with b and swap b with a to create two valid names, multiple answer by 2.\\n                answer += 2 * (initialGroup[i].count - numOfMutual) * (initialGroup[j].count - numOfMutual)\\n            }\\n        }\\n        \\n        return answer\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164423,
                "title": "frst-rust-solution",
                "content": "# Complexity\\nlet n = `len(ideas)` and m = `average(len(ideas[i]))`\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let (mut ans, n) = (0, ideas.len());\\n        let mut dict = vec![HashSet::new(); 26];\\n        for word in ideas.iter() {\\n            dict[word.chars().next().unwrap() as usize - 97].insert(&word[1..]);\\n        }\\n\\n        for i in 0..26 {\\n            for j in (i + 1)..26 {\\n                let mut mutual_count = 0;\\n                for word in dict[i].iter() {\\n                    if dict[j].contains(word) {\\n                        mutual_count += 1;\\n                    }\\n                }\\n\\n                ans += 2 * (dict[i].len() - mutual_count) * (dict[j].len() - mutual_count)\\n            }\\n        }\\n        ans as i64\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let (mut ans, n) = (0, ideas.len());\\n        let mut dict = vec![HashSet::new(); 26];\\n        for word in ideas.iter() {\\n            dict[word.chars().next().unwrap() as usize - 97].insert(&word[1..]);\\n        }\\n\\n        for i in 0..26 {\\n            for j in (i + 1)..26 {\\n                let mut mutual_count = 0;\\n                for word in dict[i].iter() {\\n                    if dict[j].contains(word) {\\n                        mutual_count += 1;\\n                    }\\n                }\\n\\n                ans += 2 * (dict[i].len() - mutual_count) * (dict[j].len() - mutual_count)\\n            }\\n        }\\n        ans as i64\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164404,
                "title": "c-easy-and-clean-code-o-nlogn-solution",
                "content": "# Intuition\\nDP[ i ][ j ] shows hows many strings in ideas starting from char i + \\'a\\' can also start from char j + \\'a\\' without contradicting the condition.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string, bool> mp;\\n        vector<bool> store(26, 0);\\n\\n        for(auto s : ideas){\\n            mp[s] = true;\\n            store[s[0] - \\'a\\'] = 1;\\n        }\\n\\n        vector<vector<int>> DP(26, vector<int>(26, 0));\\n\\n        for(auto &s : ideas){\\n            char ch = s[0];\\n\\n            for(int i=0; i<26; i++){\\n                if(store[i] == 0) continue;\\n                if(i+\\'a\\' == ch) continue;\\n\\n                char c = i + \\'a\\';\\n                s[0] = c;\\n                if(mp.find(s) == mp.end()) DP[ch-\\'a\\'][c-\\'a\\']++;\\n            }\\n        }\\n\\n        long long ans = 0;\\n\\n        for(int i=0; i<26; i++){\\n            for(int j=0; j<26; j++){\\n                if(DP[i][j] == 0) continue;        \\n        \\n                ans = ans + (DP[i][j] * DP[j][i] * 2);\\n                DP[i][j] = 0;\\n                DP[j][i] = 0;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string, bool> mp;\\n        vector<bool> store(26, 0);\\n\\n        for(auto s : ideas){\\n            mp[s] = true;\\n            store[s[0] - \\'a\\'] = 1;\\n        }\\n\\n        vector<vector<int>> DP(26, vector<int>(26, 0));\\n\\n        for(auto &s : ideas){\\n            char ch = s[0];\\n\\n            for(int i=0; i<26; i++){\\n                if(store[i] == 0) continue;\\n                if(i+\\'a\\' == ch) continue;\\n\\n                char c = i + \\'a\\';\\n                s[0] = c;\\n                if(mp.find(s) == mp.end()) DP[ch-\\'a\\'][c-\\'a\\']++;\\n            }\\n        }\\n\\n        long long ans = 0;\\n\\n        for(int i=0; i<26; i++){\\n            for(int j=0; j<26; j++){\\n                if(DP[i][j] == 0) continue;        \\n        \\n                ans = ans + (DP[i][j] * DP[j][i] * 2);\\n                DP[i][j] = 0;\\n                DP[j][i] = 0;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164363,
                "title": "c-using-unordered-set-nice-n-clean-code",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long disName = 0;\\n        vector<unordered_set<string>> arr(26);\\n        for (string s : ideas) \\n            arr[s[0] - \\'a\\'].insert(s.substr(1));\\n        \\n        for (int i = 0; i < 25; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                unordered_set<string> set;\\n                set.insert(arr[i].begin(), arr[i].end());\\n                set.insert(arr[j].begin(), arr[j].end());\\n                disName += (arr[i].size() - set.size()) * (arr[j].size() - set.size());\\n            }\\n        }\\n        return disName * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long disName = 0;\\n        vector<unordered_set<string>> arr(26);\\n        for (string s : ideas) \\n            arr[s[0] - \\'a\\'].insert(s.substr(1));\\n        \\n        for (int i = 0; i < 25; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                unordered_set<string> set;\\n                set.insert(arr[i].begin(), arr[i].end());\\n                set.insert(arr[j].begin(), arr[j].end());\\n                disName += (arr[i].size() - set.size()) * (arr[j].size() - set.size());\\n            }\\n        }\\n        return disName * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164332,
                "title": "python-simple-five-line-pythonic-solution-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We are going to count the number of valid combinations of words in a list.\\n- A combination of words is valid if we can swap their initials and both the new words are not found in the list.\\n- If both words have the **same** initial, then swapping initials will have no change, and both the new words will be in the list. Hence, no combination of two words with the same initial is valid.\\n- But what about if two words have **different** initials?\\n- If two words have different initials, then they are not a valid combination if one of the new words created by swapping initials exists in the list.\\n- We can reframe this by thinking in terms of sets of words with the same initial. For any two initials, a combination that includes a word with an ending in both of these sets would be invalid.\\n- What if we could check each combination of initial letters and just count the word endings that exist for only one of the initials, but not both?\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Write a function `distinctPairs`, which counts the number of combinations (with replacement) of elements in either set but not the other.\\n- Create the dictionary `sameInitial`, which maps initial letters to a set of possible word endings.\\n- For each word in `ideas`, add the word\\'s ending to the set corresponding to the word\\'s initial.\\n- The expression `permutations(sameInitial.values(), 2)` generates all the possible ordered pairs of sets*. We then apply `distinctPairs()` to count the number of distinct pairs for each combination, and use `sum()` to add them all together. \\n\\n**Note: Some pairs from `permutations` will contain the same set twice. We don\\'t need to worry about this because `distinctPairs(a, b) == 0` if `a == b`.*\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\cdot m )$$\\n  - For each of the $n$ words of the input, we hash and store $m-1$ characters for word length $m$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n \\\\cdot m)$$\\n  - `sameInitial` contains 26 sets, together containing a total of $n$ word-endings, with length $m-1$ for word length $m$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        distinctPairs = lambda set1, set2: len(set1 - set2) * len(set2 - set1)\\n        sameInitial = defaultdict(set)\\n        for idea in ideas:\\n            sameInitial[idea[0]].add(idea[1:])\\n        return sum(distinctPairs(a, b) for a, b in permutations(sameInitial.values(), 2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        distinctPairs = lambda set1, set2: len(set1 - set2) * len(set2 - set1)\\n        sameInitial = defaultdict(set)\\n        for idea in ideas:\\n            sameInitial[idea[0]].add(idea[1:])\\n        return sum(distinctPairs(a, b) for a, b in permutations(sameInitial.values(), 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164188,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long count=0;\\n        vector<unordered_set<string>>arr(26);\\n        for(string i:ideas)\\n        arr[i[0]-\\'a\\'].insert(i.substr(1));\\n        for(int i=0; i<25;i++){\\n            for(int j=i+1;j<26;j++){\\n                unordered_set<string>set;\\n                set.insert(arr[i].begin(),arr[i].end());\\n                set.insert(arr[j].begin(),arr[j].end());\\n                count+=(arr[i].size()-set.size())*(arr[j].size()-set.size());\\n            }\\n        }\\n        return count*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long count=0;\\n        vector<unordered_set<string>>arr(26);\\n        for(string i:ideas)\\n        arr[i[0]-\\'a\\'].insert(i.substr(1));\\n        for(int i=0; i<25;i++){\\n            for(int j=i+1;j<26;j++){\\n                unordered_set<string>set;\\n                set.insert(arr[i].begin(),arr[i].end());\\n                set.insert(arr[j].begin(),arr[j].end());\\n                count+=(arr[i].size()-set.size())*(arr[j].size()-set.size());\\n            }\\n        }\\n        return count*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164185,
                "title": "dict-of-set-take-intersection-and-remove-the-common",
                "content": "```\\nclass Solution:\\n    def distinctNames(self, ids: List[str]) -> int:\\n        mp = defaultdict(set)\\n        for i in ids:\\n            mp[i[0]].add(i[1:])\\n        \\n        \\n        res = 0\\n        for a, seta in mp.items():\\n            # print(a)\\n            for b, setb in mp.items():\\n                # print(b)\\n                if a>=b:\\n                    continue\\n                same = len(seta & setb)\\n                res+=((len(seta)-same)*(len(setb)-same))\\n        \\n        return res*2\\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ids: List[str]) -> int:\\n        mp = defaultdict(set)\\n        for i in ids:\\n            mp[i[0]].add(i[1:])\\n        \\n        \\n        res = 0\\n        for a, seta in mp.items():\\n            # print(a)\\n            for b, setb in mp.items():\\n                # print(b)\\n                if a>=b:\\n                    continue\\n                same = len(seta & setb)\\n                res+=((len(seta)-same)*(len(setb)-same))\\n        \\n        return res*2\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163856,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncan I eliminate some cases so that we don\\'t have to search for all combinations???\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe main idea is to eliminate some comparisions.\\n\\nWe can make an array of set of size 26 where we can store strings according to theri first characte.\\n\\nIf two strings start with the same character then, swapping their first characters doesn\\'t makes sense.\\n\\nAlso if the strings have first character different and remaining characters same doesn\\'t makes sense.\\nEx: coffee and toffee ----> toffee and coffee\\nIf we change the first characters then it again makes the same word.\\n\\nAlso if we find a pair that follows the conditions then the reverse of the pair also satisfies the conditions.\\nEx: cash and pet  ----> pash cet\\n    pet and cash  ----> cet pash\\n\\n\\nSo, if we are able to find one such pair then we will multiply it with \\'2\\'.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> s[26];\\n\\n        for(auto it: ideas){\\n            s[it[0]-\\'a\\'].insert(it.substr(1));\\n        }\\n\\n        long long ans=0;\\n        for(int i=0; i<25; i++){\\n            for(int j=i+1; j<26; j++){\\n                int mutual=0;\\n                for(auto it: s[i]){\\n                    if(s[j].count(it)){\\n                        mutual++;\\n                    }\\n                }\\n                ans+=2LL*(s[i].size()-mutual)*(s[j].size()-mutual);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> s[26];\\n\\n        for(auto it: ideas){\\n            s[it[0]-\\'a\\'].insert(it.substr(1));\\n        }\\n\\n        long long ans=0;\\n        for(int i=0; i<25; i++){\\n            for(int j=i+1; j<26; j++){\\n                int mutual=0;\\n                for(auto it: s[i]){\\n                    if(s[j].count(it)){\\n                        mutual++;\\n                    }\\n                }\\n                ans+=2LL*(s[i].size()-mutual)*(s[j].size()-mutual);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163823,
                "title": "go-solution-beats-100",
                "content": "\\n# Code\\n```\\nfunc distinctNames(ideas []string) int64 {\\n    dct := make(map[string]map[string]bool)\\n    ans := 0\\n\\n    for _, idea := range ideas {\\n        if _, ok := dct[idea[:1]]; !ok {\\n            dct[idea[:1]] = make(map[string]bool)\\n        }\\n        dct[idea[:1]][idea[1:]] = true\\n    }\\n\\n    keys := make([]string, 0, len(dct))\\n    for k := range dct {\\n        keys = append(keys, k)\\n    }\\n    sort.Strings(keys)\\n\\n    for i, init1 := range keys {\\n        for _, init2 := range keys[i+1:] {\\n            suff1, suff2 := dct[init1], dct[init2]\\n            c := 0\\n            for suff := range suff1 {\\n                if _, ok := suff2[suff]; ok {\\n                    c++\\n                }\\n            }\\n            ans += (len(suff1) - c) * (len(suff2) - c)\\n        }\\n    }\\n\\n    return int64(ans * 2)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distinctNames(ideas []string) int64 {\\n    dct := make(map[string]map[string]bool)\\n    ans := 0\\n\\n    for _, idea := range ideas {\\n        if _, ok := dct[idea[:1]]; !ok {\\n            dct[idea[:1]] = make(map[string]bool)\\n        }\\n        dct[idea[:1]][idea[1:]] = true\\n    }\\n\\n    keys := make([]string, 0, len(dct))\\n    for k := range dct {\\n        keys = append(keys, k)\\n    }\\n    sort.Strings(keys)\\n\\n    for i, init1 := range keys {\\n        for _, init2 := range keys[i+1:] {\\n            suff1, suff2 := dct[init1], dct[init2]\\n            c := 0\\n            for suff := range suff1 {\\n                if _, ok := suff2[suff]; ok {\\n                    c++\\n                }\\n            }\\n            ans += (len(suff1) - c) * (len(suff2) - c)\\n        }\\n    }\\n\\n    return int64(ans * 2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163803,
                "title": "c-solution-hash-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        vector<unordered_map<string,int>>dp(26);\\n        for(auto x:ideas){\\n            int ind=x[0]-\\'a\\';\\n            string st=x.substr(1,x.size()-1);\\n            dp[ind][st]++;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<26;i++){\\n            for(int j=i+1;j<26;j++){\\n                long long c=0;\\n                for(auto x:dp[i]){\\n                    if(dp[j].find(x.first)!=dp[j].end()) c++;\\n                }\\n                ans+=((dp[i].size()-c)*(dp[j].size()-c))*2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        vector<unordered_map<string,int>>dp(26);\\n        for(auto x:ideas){\\n            int ind=x[0]-\\'a\\';\\n            string st=x.substr(1,x.size()-1);\\n            dp[ind][st]++;\\n        }\\n        long long ans=0;\\n        for(int i=0;i<26;i++){\\n            for(int j=i+1;j<26;j++){\\n                long long c=0;\\n                for(auto x:dp[i]){\\n                    if(dp[j].find(x.first)!=dp[j].end()) c++;\\n                }\\n                ans+=((dp[i].size()-c)*(dp[j].size()-c))*2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163742,
                "title": "bit-manipulation-c-fast-than-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> mtail;\\n        vector<vector<string>> mhead(26);\\n        for(auto &s:ideas){\\n            int index = s[0]-\\'a\\';\\n            string st = s.substr(1);\\n            mhead[index].push_back(st);\\n            if(mtail.count(st)) mtail[st] |= (1<<index);\\n            else mtail.insert({st,1<<index});\\n        }\\n        long long ans = 0;\\n        for(int i = 0; i < 26; i++){\\n            int dup[26]{};\\n            for(auto &s:mhead[i]){\\n                int temp = mtail[s];\\n                for(int j = i+1; j<26;j++){\\n                    if(temp&(1<<j)) dup[j]++;\\n                }\\n            }\\n            int nsize = mhead[i].size();\\n            for(int j = i+1; j < 26;j++){\\n                int ndup = dup[j];\\n                int val = (nsize - ndup)*(mhead[j].size()-ndup);\\n                ans += (nsize - ndup)*(mhead[j].size()-ndup);\\n            }\\n        }\\n        return ans<<1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> mtail;\\n        vector<vector<string>> mhead(26);\\n        for(auto &s:ideas){\\n            int index = s[0]-\\'a\\';\\n            string st = s.substr(1);\\n            mhead[index].push_back(st);\\n            if(mtail.count(st)) mtail[st] |= (1<<index);\\n            else mtail.insert({st,1<<index});\\n        }\\n        long long ans = 0;\\n        for(int i = 0; i < 26; i++){\\n            int dup[26]{};\\n            for(auto &s:mhead[i]){\\n                int temp = mtail[s];\\n                for(int j = i+1; j<26;j++){\\n                    if(temp&(1<<j)) dup[j]++;\\n                }\\n            }\\n            int nsize = mhead[i].size();\\n            for(int j = i+1; j < 26;j++){\\n                int ndup = dup[j];\\n                int val = (nsize - ndup)*(mhead[j].size()-ndup);\\n                ans += (nsize - ndup)*(mhead[j].size()-ndup);\\n            }\\n        }\\n        return ans<<1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163741,
                "title": "using-unordered-list-of-sets-to-find-common-suffix-and-remove-them-from-answer",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n      using ll=long long;\\n      ll  res=0;\\n        unordered_set<string>s[26];\\n        for(int i=0;i<ideas.size();i++)\\n        {\\n            string k=ideas[i];\\n            s[k[0]-\\'a\\'].insert(k.substr(1));\\n        }\\n        for(int i=0;i<25;i++)\\n        {\\n            for(int j=i+1;j<26;j++)\\n            {\\n                 long long ans=0;\\n                for(auto x:s[i])\\n                {\\n                    if(s[j].count(x))\\n                    {\\n                        ans++;\\n                    }\\n                }\\n                res+=2*((s[i].size()-ans)*(s[j].size()-ans));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n      using ll=long long;\\n      ll  res=0;\\n        unordered_set<string>s[26];\\n        for(int i=0;i<ideas.size();i++)\\n        {\\n            string k=ideas[i];\\n            s[k[0]-\\'a\\'].insert(k.substr(1));\\n        }\\n        for(int i=0;i<25;i++)\\n        {\\n            for(int j=i+1;j<26;j++)\\n            {\\n                 long long ans=0;\\n                for(auto x:s[i])\\n                {\\n                    if(s[j].count(x))\\n                    {\\n                        ans++;\\n                    }\\n                }\\n                res+=2*((s[i].size()-ans)*(s[j].size()-ans));\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163676,
                "title": "go-beats-100-runtime-100-memory",
                "content": "# Code\\n```\\nfunc distinctNames(ideas []string) int64 {\\n\\tvar ans int64\\n\\tvar words [26]map[string]bool\\n\\tfor i := range words {\\n\\t\\twords[i] = make(map[string]bool)\\n\\t}\\n\\n\\tfor _, idea := range ideas {\\n\\t\\tbi := []byte(idea)\\n\\t\\twords[int(bi[0]-\\'a\\')][string(bi[1:])] = true\\n\\t}\\n\\n\\tfor i := 0; i < 25; i++ {\\n\\t\\tfor j := i + 1; j < 26; j++ {\\n\\t\\t\\tvar mut int\\n\\t\\t\\tfor suf := range words[i] {\\n\\t\\t\\t\\tif words[j][suf] {\\n\\t\\t\\t\\t\\tmut++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans += 2 * int64(len(words[i])-mut) * int64(len(words[j])-mut)\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc distinctNames(ideas []string) int64 {\\n\\tvar ans int64\\n\\tvar words [26]map[string]bool\\n\\tfor i := range words {\\n\\t\\twords[i] = make(map[string]bool)\\n\\t}\\n\\n\\tfor _, idea := range ideas {\\n\\t\\tbi := []byte(idea)\\n\\t\\twords[int(bi[0]-\\'a\\')][string(bi[1:])] = true\\n\\t}\\n\\n\\tfor i := 0; i < 25; i++ {\\n\\t\\tfor j := i + 1; j < 26; j++ {\\n\\t\\t\\tvar mut int\\n\\t\\t\\tfor suf := range words[i] {\\n\\t\\t\\t\\tif words[j][suf] {\\n\\t\\t\\t\\t\\tmut++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans += 2 * int64(len(words[i])-mut) * int64(len(words[j])-mut)\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163537,
                "title": "python-11-lines-faster-than-98",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nTODO\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctNames(self, xs: List[str]) -> int:\\n        idx = defaultdict(lambda: len(idx))\\n        grp = defaultdict(set)\\n        for x in xs:\\n            grp[x[0]].add(idx[x[1:]])\\n        n = 0\\n        for a, b in combinations(grp.values(), 2):\\n            d = len(a&b)\\n            n += (len(a)-d) * (len(b)-d)\\n        return n * 2\\n```\\nOr just:\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        S = [set() for _ in range(26)]\\n        for x in ideas:\\n            S[ord(x[0])-97].add(x[1:])\\n        n = 0\\n        for x, y in combinations(S, 2):\\n            a = len(x&y)\\n            n += (len(x)-a) * (len(y)-a)\\n        return n * 2\\n```\\n^ Same speed, less memory.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, xs: List[str]) -> int:\\n        idx = defaultdict(lambda: len(idx))\\n        grp = defaultdict(set)\\n        for x in xs:\\n            grp[x[0]].add(idx[x[1:]])\\n        n = 0\\n        for a, b in combinations(grp.values(), 2):\\n            d = len(a&b)\\n            n += (len(a)-d) * (len(b)-d)\\n        return n * 2\\n```\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        S = [set() for _ in range(26)]\\n        for x in ideas:\\n            S[ord(x[0])-97].add(x[1:])\\n        n = 0\\n        for x, y in combinations(S, 2):\\n            a = len(x&y)\\n            n += (len(x)-a) * (len(y)-a)\\n        return n * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163522,
                "title": "java-using-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        long res=0;\\n        ArrayList<Set<String>> l=new ArrayList<Set<String>>();\\n        for(int i=0;i<26;i++)l.add(new HashSet());\\n        for(String str:ideas){\\n            l.get(str.charAt(0)-\\'a\\').add(str.substring(1));\\n        }\\n        for(int i=0;i<25;i++)\\n        {\\n            for(int j=i+1;j<26;j++)\\n            {\\n                int useless=0;\\n                for(String str:l.get(i)){\\n                    if(l.get(j).contains(str))useless++;\\n                }\\n\\n                res+=2*((l.get(i).size()-useless)*(l.get(j).size()-useless));\\n            }\\n        }\\n       // System.out.println(l);\\n        return res;\\n    }\\n}\\n/*\\nc-offee\\nd-onuts\\nt-ime,offee\\n*/\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        long res=0;\\n        ArrayList<Set<String>> l=new ArrayList<Set<String>>();\\n        for(int i=0;i<26;i++)l.add(new HashSet());\\n        for(String str:ideas){\\n            l.get(str.charAt(0)-\\'a\\').add(str.substring(1));\\n        }\\n        for(int i=0;i<25;i++)\\n        {\\n            for(int j=i+1;j<26;j++)\\n            {\\n                int useless=0;\\n                for(String str:l.get(i)){\\n                    if(l.get(j).contains(str))useless++;\\n                }\\n\\n                res+=2*((l.get(i).size()-useless)*(l.get(j).size()-useless));\\n            }\\n        }\\n       // System.out.println(l);\\n        return res;\\n    }\\n}\\n/*\\nc-offee\\nd-onuts\\nt-ime,offee\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163450,
                "title": "java-simple-code-easy-to-understand-short-and-fast-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        List<String>[] arr = new ArrayList[26];\\n        long result = 0;\\n        for(int i = 0; i < 26; i++) arr[i] = new ArrayList<>();\\n        for(int i = ideas.length - 1; i >= 0; i--){\\n            arr[ideas[i].charAt(0) - \\'a\\'].add(ideas[i].substring(1));\\n        }\\n        for(int i = 0; i < 25; i++){\\n            for(int j = i + 1; j < 26; j++){\\n                Set<String> set = new HashSet<>();\\n                set.addAll(arr[i]);\\n                set.addAll(arr[j]);\\n                result += (arr[i].size() - set.size()) * (arr[j].size() - set.size());\\n            }\\n        }\\n        return result * 2;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        List<String>[] arr = new ArrayList[26];\\n        long result = 0;\\n        for(int i = 0; i < 26; i++) arr[i] = new ArrayList<>();\\n        for(int i = ideas.length - 1; i >= 0; i--){\\n            arr[ideas[i].charAt(0) - \\'a\\'].add(ideas[i].substring(1));\\n        }\\n        for(int i = 0; i < 25; i++){\\n            for(int j = i + 1; j < 26; j++){\\n                Set<String> set = new HashSet<>();\\n                set.addAll(arr[i]);\\n                set.addAll(arr[j]);\\n                result += (arr[i].size() - set.size()) * (arr[j].size() - set.size());\\n            }\\n        }\\n        return result * 2;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163446,
                "title": "c-2d-vector-o-n-solution",
                "content": "Hello Everyone\\n\\n**C++ Code**\\n\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string>s1;\\n        for(auto itr: ideas){\\n            s1.insert(itr);\\n        }\\n        vector<vector<int>>safeRec(26, vector<int>(26, 0));\\n        for(auto itr: ideas){\\n            int i = (int)itr[0] - 97;\\n            string t = itr;\\n            for(int j=0;j<26;j++){\\n                t[0] = (char)(97+j);\\n                if(s1.find(t) == s1.end()){\\n                    safeRec[i][j]++;\\n                }\\n            }\\n        }\\n        \\n        long long int res = 0;\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                res += safeRec[i][j] * safeRec[j][i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string>s1;\\n        for(auto itr: ideas){\\n            s1.insert(itr);\\n        }\\n        vector<vector<int>>safeRec(26, vector<int>(26, 0));\\n        for(auto itr: ideas){\\n            int i = (int)itr[0] - 97;\\n            string t = itr;\\n            for(int j=0;j<26;j++){\\n                t[0] = (char)(97+j);\\n                if(s1.find(t) == s1.end()){\\n                    safeRec[i][j]++;\\n                }\\n            }\\n        }\\n        \\n        long long int res = 0;\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++){\\n                res += safeRec[i][j] * safeRec[j][i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163392,
                "title": "java-93ms-fast-array-a-z-of-hashset-s",
                "content": "\\nThe code below works by grouping all passed words by their first character, where each letter-group contains the words\\' strings without their first letter (i.e. the \"suffix\" of the word which is the string from the second letter to the end of the word).  The groups are implemented by an array of 26 HashSets, where the HashSets contain the suffixes of their group\\'s words.  The total number of combinations of valid company names will be the sum the valid combinations from all possible pairs of groups.  If n is the number of suffix strings in common between two groups, then the number of valid company names that can be formed with any pair of groups, will be the size of the first group minus n, times the size of the second group minus n.\\n\\nAfter the words are grouped into the 26 HashSets, if some letters are not used as a first letter in any word, that letter-group\\'s HashSet will be empty, so we squeeze out all empty HashSets.  Two later sections of code will compare all possible pairs of HashSets, which could result in 26\\\\*26 comparisons to get the total number of valid company names.  By squeezing out empty group\\'s HashSets the number of group HashSet comparisons can be reduced.  For example, if only 5 different letters are used as first letters of the passed words, then only 5\\\\*5 HashSet comparisons will be needed.  We can further reduce the number of group comparisons by only comparing the groups in one direction.  For example, given groups A and B, the number of company names formed by the pair of groups A,B will be the same number as reversing the direction to B,A, so we only count one direction of comparison, then multiply by 2.  Also, don\\'t compare any group with itself, because there will be no valid company names.\\n\\nThe code then uses a 2-D array to calculate the number of suffixes in common between all possible group HashSet pairs, i.e. the number of suffixes in the intersection of the pair of HashSets.  After the number of all HashSet pair\\'s common (intersecting) suffixes have been calculated, then the number of valid company name combinations for each pair of groups is calculated and summed.\\n\\nThis code ran as fast as 93ms in August 2023.\\n\\nIf useful, then please upvote.\\n\\n### --- Commented Code ---\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        // Add all words (from second character on) into an array of HashSet\\'s, \\n        // indexed by the first letter of the words.  One HashSet for each \\n        // possible first letter of the words.  Group the words by the first \\n        // letter of the words, and each group contains the suffix of the \\n        // words (i.e. each group contains the words\\' strings from the second \\n        // letter of the word until the end of the word).\\n        HashSet<String>[] sets = new HashSet[26];\\n        for (int i = 0; i < 26; i++)  sets[i] = new HashSet();\\n        for (String s : ideas)  sets[s.charAt(0) - \\'a\\'].add(s.substring(1));\\n\\n        // Remove HashSet\\'s that don\\'t have any words in them.\\n        int inn = 0;\\n        while (inn < 26 && sets[inn].size() != 0)  inn++;   // Find first empty HashSet, if any.\\n        int used = inn;\\n        while (inn < 26) {          // Loop to remove empty HashSet\\'s.\\n            if (sets[inn].size() != 0) \\n                sets[used++] = sets[inn];\\n            inn++;\\n        }\\n        if (used <= 1)  return 0;   // If only one non-empty HashSet, then no valid company names.\\n        \\n        // Find the number of words in the intersection of all possible pair \\n        // combinations from the Array of HashSets.\\n        int[][] intersectionSizes = new int[used][used];\\n        for (int i = used - 2; i >= 0; i--) {       // Loop through first HashSet\\'s of the pairs.\\n            int[] intersectRow = intersectionSizes[i];\\n            for (String suffix : sets[i])           // Loop to test first HashSet strings for intersection.\\n                for (int j = used - 1; j > i; j--)  // Loop through second HashSet\\'s of the pairs. \\n                    if (sets[j].contains(suffix))   // If string in both HashSets of pair\\n                        intersectRow[j]++;\\n        }\\n\\n        // Add up the combinations from all possible pairs of HashSet\\'s, without including the \\n        // intersection suffix strings between the pair of HashSet\\'s.\\n        long count = 0;\\n        for (int i = used - 2; i >= 0; i--) {       // Loop through first HashSet\\'s of the pairs.\\n            int iSize = sets[i].size();\\n            for (int j = used - 1; j > i; j--)      // Loop through second HashSet\\'s of the pairs. \\n                count += (iSize - intersectionSizes[i][j]) * (sets[j].size() - intersectionSizes[i][j]);\\n        }                                           // Add number of company names from pair of HashSet\\'s.\\n        \\n        // Return the count of valid company names.  The \"*2\" is because each \\n        // pair of valid company names can swap the order of the words and \\n        // still be a valid company name.\\n        return count * 2;\\n    }\\n}\\n```\\n### --- Clean Code ---\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String>[] sets = new HashSet[26];\\n        for (int i = 0; i < 26; i++)  sets[i] = new HashSet();\\n        for (String s : ideas)  sets[s.charAt(0) - \\'a\\'].add(s.substring(1));\\n\\n        int inn = 0;\\n        while (inn < 26 && sets[inn].size() != 0)  inn++;\\n        int used = inn;\\n        while (inn < 26) {\\n            if (sets[inn].size() != 0) \\n                sets[used++] = sets[inn];\\n            inn++;\\n        }\\n        if (used <= 1)  return 0;\\n        \\n        int[][] intersectionSizes = new int[used][used];\\n        for (int i = used - 2; i >= 0; i--) {\\n            int[] intersectRow = intersectionSizes[i];\\n            for (String suffix : sets[i])\\n                for (int j = used - 1; j > i; j--)\\n                    if (sets[j].contains(suffix))\\n                        intersectRow[j]++;\\n        }\\n\\n        long count = 0;\\n        for (int i = used - 2; i >= 0; i--) {\\n            int iSize = sets[i].size();\\n            for (int j = used - 1; j > i; j--) \\n                count += (iSize - intersectionSizes[i][j]) * (sets[j].size() - intersectionSizes[i][j]);\\n        }\\n\\n        return count * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        // Add all words (from second character on) into an array of HashSet\\'s, \\n        // indexed by the first letter of the words.  One HashSet for each \\n        // possible first letter of the words.  Group the words by the first \\n        // letter of the words, and each group contains the suffix of the \\n        // words (i.e. each group contains the words\\' strings from the second \\n        // letter of the word until the end of the word).\\n        HashSet<String>[] sets = new HashSet[26];\\n        for (int i = 0; i < 26; i++)  sets[i] = new HashSet();\\n        for (String s : ideas)  sets[s.charAt(0) - \\'a\\'].add(s.substring(1));\\n\\n        // Remove HashSet\\'s that don\\'t have any words in them.\\n        int inn = 0;\\n        while (inn < 26 && sets[inn].size() != 0)  inn++;   // Find first empty HashSet, if any.\\n        int used = inn;\\n        while (inn < 26) {          // Loop to remove empty HashSet\\'s.\\n            if (sets[inn].size() != 0) \\n                sets[used++] = sets[inn];\\n            inn++;\\n        }\\n        if (used <= 1)  return 0;   // If only one non-empty HashSet, then no valid company names.\\n        \\n        // Find the number of words in the intersection of all possible pair \\n        // combinations from the Array of HashSets.\\n        int[][] intersectionSizes = new int[used][used];\\n        for (int i = used - 2; i >= 0; i--) {       // Loop through first HashSet\\'s of the pairs.\\n            int[] intersectRow = intersectionSizes[i];\\n            for (String suffix : sets[i])           // Loop to test first HashSet strings for intersection.\\n                for (int j = used - 1; j > i; j--)  // Loop through second HashSet\\'s of the pairs. \\n                    if (sets[j].contains(suffix))   // If string in both HashSets of pair\\n                        intersectRow[j]++;\\n        }\\n\\n        // Add up the combinations from all possible pairs of HashSet\\'s, without including the \\n        // intersection suffix strings between the pair of HashSet\\'s.\\n        long count = 0;\\n        for (int i = used - 2; i >= 0; i--) {       // Loop through first HashSet\\'s of the pairs.\\n            int iSize = sets[i].size();\\n            for (int j = used - 1; j > i; j--)      // Loop through second HashSet\\'s of the pairs. \\n                count += (iSize - intersectionSizes[i][j]) * (sets[j].size() - intersectionSizes[i][j]);\\n        }                                           // Add number of company names from pair of HashSet\\'s.\\n        \\n        // Return the count of valid company names.  The \"*2\" is because each \\n        // pair of valid company names can swap the order of the words and \\n        // still be a valid company name.\\n        return count * 2;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String>[] sets = new HashSet[26];\\n        for (int i = 0; i < 26; i++)  sets[i] = new HashSet();\\n        for (String s : ideas)  sets[s.charAt(0) - \\'a\\'].add(s.substring(1));\\n\\n        int inn = 0;\\n        while (inn < 26 && sets[inn].size() != 0)  inn++;\\n        int used = inn;\\n        while (inn < 26) {\\n            if (sets[inn].size() != 0) \\n                sets[used++] = sets[inn];\\n            inn++;\\n        }\\n        if (used <= 1)  return 0;\\n        \\n        int[][] intersectionSizes = new int[used][used];\\n        for (int i = used - 2; i >= 0; i--) {\\n            int[] intersectRow = intersectionSizes[i];\\n            for (String suffix : sets[i])\\n                for (int j = used - 1; j > i; j--)\\n                    if (sets[j].contains(suffix))\\n                        intersectRow[j]++;\\n        }\\n\\n        long count = 0;\\n        for (int i = used - 2; i >= 0; i--) {\\n            int iSize = sets[i].size();\\n            for (int j = used - 1; j > i; j--) \\n                count += (iSize - intersectionSizes[i][j]) * (sets[j].size() - intersectionSizes[i][j]);\\n        }\\n\\n        return count * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163365,
                "title": "ruby-bit-manipulation",
                "content": "# Code\\n```ruby\\ndef distinct_names(ideas)\\n  h = Hash.new(0)\\n  ideas.each { |idea| h[idea[1..]] |= 1 << idea[0].ord - ?a.ord }\\n  heads = Array.new(26) { [0] * 26 }\\n  2 * ideas.sum { |idea|\\n    head = idea[0].ord - ?a.ord\\n    existing = h[idea[1..]]\\n    26.times.sum {\\n      if existing[_1] > 0\\n        0\\n      else\\n        heads[head][_1] += 1\\n        heads[_1][head]\\n      end\\n    }\\n  }\\nend\\n```\\n\\n# Time complexity\\n\\n$$\\\\mathcal{O}(n)$$\\n\\n# Space complexity\\n\\n$$\\\\mathcal{O}(n)$$",
                "solutionTags": [
                    "Ruby",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```ruby\\ndef distinct_names(ideas)\\n  h = Hash.new(0)\\n  ideas.each { |idea| h[idea[1..]] |= 1 << idea[0].ord - ?a.ord }\\n  heads = Array.new(26) { [0] * 26 }\\n  2 * ideas.sum { |idea|\\n    head = idea[0].ord - ?a.ord\\n    existing = h[idea[1..]]\\n    26.times.sum {\\n      if existing[_1] > 0\\n        0\\n      else\\n        heads[head][_1] += 1\\n        heads[_1][head]\\n      end\\n    }\\n  }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3163289,
                "title": "think-dp",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> st;\\n        int n = ideas.size();\\n        for(string i: ideas) \\n            st.insert(i);\\n        vector<vector<int>> dp(26, vector<int>(26));\\n        for(int i = 0; i < n; i++) {\\n            string t = ideas[i];\\n            for(int j = 0; j < 26; j++) {\\n                t[0] = (char)(\\'a\\' + j);\\n                if(st.find(t) == st.end()) dp[ideas[i][0] - \\'a\\'][j]++;\\n            }\\n        }\\n        long long res = 0;\\n        for(int i = 0; i < 26; i++)\\n            for(int j = 0; j < 26; j++) \\n                res += dp[i][j] * dp[j][i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> st;\\n        int n = ideas.size();\\n        for(string i: ideas) \\n            st.insert(i);\\n        vector<vector<int>> dp(26, vector<int>(26));\\n        for(int i = 0; i < n; i++) {\\n            string t = ideas[i];\\n            for(int j = 0; j < 26; j++) {\\n                t[0] = (char)(\\'a\\' + j);\\n                if(st.find(t) == st.end()) dp[ideas[i][0] - \\'a\\'][j]++;\\n            }\\n        }\\n        long long res = 0;\\n        for(int i = 0; i < 26; i++)\\n            for(int j = 0; j < 26; j++) \\n                res += dp[i][j] * dp[j][i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163204,
                "title": "c-map-of-ideas-suffixes",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<char, unordered_set<string>> words;\\n        for(auto& word: ideas)\\n            words[word[0]].insert(word.substr(1));\\n        \\n        long long count = 0L, common;\\n        for(auto& [letter1, suffixes1]: words) {\\n            for(auto& [letter2, suffixes2]: words) {\\n                common = 0L;\\n                for(auto& suffix: suffixes1)\\n                    if(suffixes2.count(suffix) != 0)\\n                        common++;\\n\\n                count += (suffixes1.size() - common) * (suffixes2.size() - common);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<char, unordered_set<string>> words;\\n        for(auto& word: ideas)\\n            words[word[0]].insert(word.substr(1));\\n        \\n        long long count = 0L, common;\\n        for(auto& [letter1, suffixes1]: words) {\\n            for(auto& [letter2, suffixes2]: words) {\\n                common = 0L;\\n                for(auto& suffix: suffixes1)\\n                    if(suffixes2.count(suffix) != 0)\\n                        common++;\\n\\n                count += (suffixes1.size() - common) * (suffixes2.size() - common);\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163171,
                "title": "java-brute-force-and-optimised-solution",
                "content": "\\n\\n# Code\\n```\\n\\n// Approach 1 :- Brute force Getting TLE\\n\\n// class Solution {\\n//     public long distinctNames(String[] ideas) {\\n//         HashSet<Pair> set = new HashSet<>();\\n//         int n = ideas.length;\\n//         HashMap<String,Integer> map = new HashMap<>();\\n//         for(int i=0;i<n;i++){\\n//             map.put(ideas[i],map.getOrDefault(ideas[i],0)+1);\\n//         }\\n//         for(int i=0;i<n;i++){\\n//             for(int j=0;j<n;j++){\\n//                 if(i != j){\\n//                     String tempA = ideas[i];\\n//                     String tempB = ideas[j];\\n//                     StringBuilder ideaA = new StringBuilder(ideas[i]);\\n//                     StringBuilder ideaB = new StringBuilder(ideas[j]);\\n//                     ideaA.setCharAt(0,tempB.charAt(0));\\n//                     ideaB.setCharAt(0,tempA.charAt(0));\\n//                     if(!map.containsKey(ideaA.toString()) && !map.containsKey(ideaB.toString())){\\n//                         Pair pair = new Pair (ideaA.toString(), ideaB.toString());\\n//                         set.add(pair);\\n//                     }\\n//                 }\\n//             }\\n//         }\\n//         long ans = (long)set.size();\\n//         return ans;\\n//     }\\n// }\\n// class Pair{\\n//     String ideaA;\\n//     String ideaB;\\n//     public Pair(String ideaA, String ideaB){\\n//         this.ideaA = ideaA;\\n//         this.ideaB = ideaB;\\n//     }\\n// }\\n\\n\\n\\n// Approach 2 :- Optimised Solution\\n\\nclass Solution {\\n       public long distinctNames(String[] ideas) {\\n       List<String> list[] = new ArrayList[26];\\n       long possiblePair = 0;\\n       for(int i = 0; i < 26; i++)\\n           list[i] = new ArrayList<>();\\n       for(String s : ideas)\\n           list[s.charAt(0) - \\'a\\'].add(s.substring(1));\\n       for(int i = 0; i < 25; i++) {\\n           for(int j = i + 1; j < 26; j++) {\\n               Set<String> set = new HashSet<>();\\n               set.addAll(list[i]);\\n               set.addAll(list[j]);\\n               possiblePair += (list[i].size() - set.size()) * (list[j].size() - set.size());\\n           }\\n       }\\n       return possiblePair * 2;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n// Approach 1 :- Brute force Getting TLE\\n\\n// class Solution {\\n//     public long distinctNames(String[] ideas) {\\n//         HashSet<Pair> set = new HashSet<>();\\n//         int n = ideas.length;\\n//         HashMap<String,Integer> map = new HashMap<>();\\n//         for(int i=0;i<n;i++){\\n//             map.put(ideas[i],map.getOrDefault(ideas[i],0)+1);\\n//         }\\n//         for(int i=0;i<n;i++){\\n//             for(int j=0;j<n;j++){\\n//                 if(i != j){\\n//                     String tempA = ideas[i];\\n//                     String tempB = ideas[j];\\n//                     StringBuilder ideaA = new StringBuilder(ideas[i]);\\n//                     StringBuilder ideaB = new StringBuilder(ideas[j]);\\n//                     ideaA.setCharAt(0,tempB.charAt(0));\\n//                     ideaB.setCharAt(0,tempA.charAt(0));\\n//                     if(!map.containsKey(ideaA.toString()) && !map.containsKey(ideaB.toString())){\\n//                         Pair pair = new Pair (ideaA.toString(), ideaB.toString());\\n//                         set.add(pair);\\n//                     }\\n//                 }\\n//             }\\n//         }\\n//         long ans = (long)set.size();\\n//         return ans;\\n//     }\\n// }\\n// class Pair{\\n//     String ideaA;\\n//     String ideaB;\\n//     public Pair(String ideaA, String ideaB){\\n//         this.ideaA = ideaA;\\n//         this.ideaB = ideaB;\\n//     }\\n// }\\n\\n\\n\\n// Approach 2 :- Optimised Solution\\n\\nclass Solution {\\n       public long distinctNames(String[] ideas) {\\n       List<String> list[] = new ArrayList[26];\\n       long possiblePair = 0;\\n       for(int i = 0; i < 26; i++)\\n           list[i] = new ArrayList<>();\\n       for(String s : ideas)\\n           list[s.charAt(0) - \\'a\\'].add(s.substring(1));\\n       for(int i = 0; i < 25; i++) {\\n           for(int j = i + 1; j < 26; j++) {\\n               Set<String> set = new HashSet<>();\\n               set.addAll(list[i]);\\n               set.addAll(list[j]);\\n               possiblePair += (list[i].size() - set.size()) * (list[j].size() - set.size());\\n           }\\n       }\\n       return possiblePair * 2;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163129,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string>s(ideas.begin(),ideas.end());\\n        int n=ideas.size();\\n        long long c=0;\\n        vector<vector<long long>>v(26,vector<long long>(26,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            string s1=ideas[i];\\n            int k=s1[0]-\\'a\\';\\n            for(int i=0;i<26;i++)\\n            {\\n                s1[0]=char(i+\\'a\\');\\n                if(!s.count(s1)) v[k][i]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {   cout<<v[i][j]<<\"|\";\\n                if(i!=j)\\n                {\\n                    c+=(v[i][j]*v[j][i]);\\n                }\\n            }\\n            cout<<endl;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string>s(ideas.begin(),ideas.end());\\n        int n=ideas.size();\\n        long long c=0;\\n        vector<vector<long long>>v(26,vector<long long>(26,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            string s1=ideas[i];\\n            int k=s1[0]-\\'a\\';\\n            for(int i=0;i<26;i++)\\n            {\\n                s1[0]=char(i+\\'a\\');\\n                if(!s.count(s1)) v[k][i]++;\\n            }\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {   cout<<v[i][j]<<\"|\";\\n                if(i!=j)\\n                {\\n                    c+=(v[i][j]*v[j][i]);\\n                }\\n            }\\n            cout<<endl;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3163091,
                "title": "easy-hashing-solution-space-optimsation-c",
                "content": "```\\nT.C: O(26*N)\\nS.C:O(26*N)\\n\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& v) {\\n        int n=v.size();\\n        unordered_set<string> us;\\n        for(auto s:v) us.insert(s);\\n        vector<vector<int>> A(n,vector<int>(26,0));\\n        vector<vector<int>> B(26,vector<int>(26,0));\\n        for(int i=0;i<n;i++){\\n            int k=(v[i][0]-\\'a\\');\\n            for(int j=0;j<26;j++){\\n                char temp=v[i][0];\\n                v[i][0]=(\\'a\\'+j);\\n                if(us.find(v[i])==us.end()){\\n                    A[i][j]=1;\\n                    B[k][j]+=1;\\n                }\\n                v[i][0]=temp;\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<26;j++){\\n                if(A[i][j]==1){\\n                    int k=(v[i][0]-\\'a\\');\\n                    ans+=(B[j][k]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Space Optimization\\nT.C: O(26*N)\\nS.C: O(26*26)\\n\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& v) {\\n        int n=v.size();\\n        unordered_set<string> us;\\n        for(auto s:v) us.insert(s);\\n        vector<vector<int>> B(26,vector<int>(26,0));\\n        for(int i=0;i<n;i++){\\n            int k=(v[i][0]-\\'a\\');\\n            for(int j=0;j<26;j++){\\n                char temp=v[i][0];\\n                v[i][0]=(\\'a\\'+j);\\n                if(us.find(v[i])==us.end()){\\n                    B[k][j]+=1;\\n                }\\n                v[i][0]=temp;\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<26;j++){\\n                char temp=v[i][0];\\n                v[i][0]=(\\'a\\'+j);\\n                if(us.find(v[i])==us.end()){\\n                    int k=(temp-\\'a\\');\\n                    ans+=(B[j][k]);\\n                }\\n                v[i][0]=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nT.C: O(26*N)\\nS.C:O(26*N)\\n\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& v) {\\n        int n=v.size();\\n        unordered_set<string> us;\\n        for(auto s:v) us.insert(s);\\n        vector<vector<int>> A(n,vector<int>(26,0));\\n        vector<vector<int>> B(26,vector<int>(26,0));\\n        for(int i=0;i<n;i++){\\n            int k=(v[i][0]-\\'a\\');\\n            for(int j=0;j<26;j++){\\n                char temp=v[i][0];\\n                v[i][0]=(\\'a\\'+j);\\n                if(us.find(v[i])==us.end()){\\n                    A[i][j]=1;\\n                    B[k][j]+=1;\\n                }\\n                v[i][0]=temp;\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<26;j++){\\n                if(A[i][j]==1){\\n                    int k=(v[i][0]-\\'a\\');\\n                    ans+=(B[j][k]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Space Optimization\\nT.C: O(26*N)\\nS.C: O(26*26)\\n\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& v) {\\n        int n=v.size();\\n        unordered_set<string> us;\\n        for(auto s:v) us.insert(s);\\n        vector<vector<int>> B(26,vector<int>(26,0));\\n        for(int i=0;i<n;i++){\\n            int k=(v[i][0]-\\'a\\');\\n            for(int j=0;j<26;j++){\\n                char temp=v[i][0];\\n                v[i][0]=(\\'a\\'+j);\\n                if(us.find(v[i])==us.end()){\\n                    B[k][j]+=1;\\n                }\\n                v[i][0]=temp;\\n            }\\n        }\\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<26;j++){\\n                char temp=v[i][0];\\n                v[i][0]=(\\'a\\'+j);\\n                if(us.find(v[i])==us.end()){\\n                    int k=(temp-\\'a\\');\\n                    ans+=(B[j][k]);\\n                }\\n                v[i][0]=temp;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163045,
                "title": "java-easy-understanding",
                "content": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        //group all with the prefix,now length of the prefix will be 26 alphabets\\n        \\n        Map<Integer,HashSet<String>> group = new HashMap<>();\\n        \\n        for(String idea : ideas){\\n            int firstChar = idea.charAt(0) - \\'a\\';\\n            if(!group.containsKey(firstChar)){\\n                group.put(firstChar,new HashSet<>());\\n            }\\n            group.get(firstChar).add(idea.substring(1));\\n        }\\n        \\n        //if suffix is same then we have to ignore them \\n        // like 2nd example lack,back\\n        // l-->(ack) and b-->(ack)\\n        //if both are same the ignore\\n        long answer = 0;\\n        for(int a = 0 ; a < 25 ; a++){\\n            for(int b = a+1 ; b < 26 ; b++){\\n                int len = 0;\\n                if(group.get(a)!= null && group.get(b)!= null){\\n                    for(String word : group.get(a)){\\n                        if(group.get(b).contains(word)){\\n                            len++;\\n                        }\\n                    }\\n                    \\n                    int calc = 2 * ((group.get(a).size() - len) * (group.get(b).size() - len));\\n                    answer+=calc;\\n                }\\n                \\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        //group all with the prefix,now length of the prefix will be 26 alphabets\\n        \\n        Map<Integer,HashSet<String>> group = new HashMap<>();\\n        \\n        for(String idea : ideas){\\n            int firstChar = idea.charAt(0) - \\'a\\';\\n            if(!group.containsKey(firstChar)){\\n                group.put(firstChar,new HashSet<>());\\n            }\\n            group.get(firstChar).add(idea.substring(1));\\n        }\\n        \\n        //if suffix is same then we have to ignore them \\n        // like 2nd example lack,back\\n        // l-->(ack) and b-->(ack)\\n        //if both are same the ignore\\n        long answer = 0;\\n        for(int a = 0 ; a < 25 ; a++){\\n            for(int b = a+1 ; b < 26 ; b++){\\n                int len = 0;\\n                if(group.get(a)!= null && group.get(b)!= null){\\n                    for(String word : group.get(a)){\\n                        if(group.get(b).contains(word)){\\n                            len++;\\n                        }\\n                    }\\n                    \\n                    int calc = 2 * ((group.get(a).size() - len) * (group.get(b).size() - len));\\n                    answer+=calc;\\n                }\\n                \\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162945,
                "title": "javascript-7-lines-hashing-time-o-n-100-space-o-n-100",
                "content": "# Approach\\n1. Create an object `dict` that maps each letter to a set of all suffixes of words in `idea` that start with it, and initialize a variable `res` to `0`.\\n2. Compare each letter\\'s set to all following sets in `dict`. For sets `A` and `B`:\\n    1. Store the number of mutual suffixes from both sets in a variable `mut`.\\n    2. Add `2 * ( dict[A].size - mut ) * ( dict[B].size - mut )` to `res`.\\n3. Return `res`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nconst distinctNames = ideas => {\\n    let d = {}, r = 0\\n    ideas.forEach( i => d[i[0]] = ( d[i[0]] || new Set() ).add(i.substring(1)) )\\n    for ( let a = 0, c = Object.keys(d); a < c.length; a++ )\\n        for ( let b = a+1, m; b < c.length; b++ )\\n            m = [...d[c[a]]].reduce( ( s, w ) => s+d[c[b]].has(w), 0 ),\\n            r += 2*(d[c[a]].size-m)*(d[c[b]].size-m)\\n    return r\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nconst distinctNames = ideas => {\\n    let d = {}, r = 0\\n    ideas.forEach( i => d[i[0]] = ( d[i[0]] || new Set() ).add(i.substring(1)) )\\n    for ( let a = 0, c = Object.keys(d); a < c.length; a++ )\\n        for ( let b = a+1, m; b < c.length; b++ )\\n            m = [...d[c[a]]].reduce( ( s, w ) => s+d[c[b]].has(w), 0 ),\\n            r += 2*(d[c[a]].size-m)*(d[c[b]].size-m)\\n    return r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162892,
                "title": "c-solution-with-explanation",
                "content": "\\n\\n# Approach\\nThe approach of this solution is to use a hash table to preprocess the input array \"ideas\", and then use two nested loops to generate all possible combinations of two distinct letters from the alphabet.\\nFor each combination of two letters, the solution generates two sets \"temp1\" and \"temp2\" to store the substrings that start with the two letters, and finds the number of duplicates between the two sets.\\nThe solution then adds the product of the size of each set minus the number of duplicates to the final answer, and multiplies the final answer by 2 because swapping the first letters of two ideas generates two distinct names.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- The time complexity of this solution is O(26 * N), where N is the total number of strings in the input array \"ideas\".\\nThe outer loop runs 26 times, once for each letter in the alphabet, and the inner loop runs N times to iterate through the \"ideas\" array.\\nThe hash table \"mp\" takes O(N) time to construct, and finding duplicates in the two sets \"temp1\" and \"temp2\" takes O(N) time, so the overall time complexity is O(26 * N + N).\\n\\n- The space complexity of this solution is O(N), as the hash table \"mp\" requires O(N) space to store all the substrings of the \"ideas\" array. The two sets \"temp1\" and \"temp2\" require O(N) space as well.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        // A hash table to store all substrings of the ideas array\\n        // The key is the first letter of each substring\\n        // The value is a set of substrings starting with the same letter\\n        unordered_map<int, unordered_set<string>> firstLetterToSubstrings;\\n        for (string idea : ideas) {\\n            int firstLetter = idea[0] - \\'a\\';\\n            string substring = idea.substr(1);\\n            firstLetterToSubstrings[firstLetter].insert(substring);\\n        }\\n\\n        // The final answer, initialized to 0\\n        long long ans = 0;\\n\\n        // Loop through all 26 letters in the alphabet\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                // Get the sets of substrings starting with letter i and j\\n                unordered_set<string> substringsStartingWithI = firstLetterToSubstrings[i];\\n                unordered_set<string> substringsStartingWithJ = firstLetterToSubstrings[j];\\n                int duplicate = 0;\\n\\n                // Find the number of duplicates between the two sets\\n                for (string substring : substringsStartingWithI) {\\n                    if (substringsStartingWithJ.count(substring) > 0) duplicate++;\\n                }\\n\\n                // Add the product of the size of each set minus the number of duplicates to the final answer\\n                ans += (substringsStartingWithI.size() - duplicate) * (substringsStartingWithJ.size() - duplicate);\\n            }\\n        }\\n\\n        // Multiply the final answer by 2 because swapping the first letters of two ideas generates two distinct names\\n        return ans * 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        // A hash table to store all substrings of the ideas array\\n        // The key is the first letter of each substring\\n        // The value is a set of substrings starting with the same letter\\n        unordered_map<int, unordered_set<string>> firstLetterToSubstrings;\\n        for (string idea : ideas) {\\n            int firstLetter = idea[0] - \\'a\\';\\n            string substring = idea.substr(1);\\n            firstLetterToSubstrings[firstLetter].insert(substring);\\n        }\\n\\n        // The final answer, initialized to 0\\n        long long ans = 0;\\n\\n        // Loop through all 26 letters in the alphabet\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                // Get the sets of substrings starting with letter i and j\\n                unordered_set<string> substringsStartingWithI = firstLetterToSubstrings[i];\\n                unordered_set<string> substringsStartingWithJ = firstLetterToSubstrings[j];\\n                int duplicate = 0;\\n\\n                // Find the number of duplicates between the two sets\\n                for (string substring : substringsStartingWithI) {\\n                    if (substringsStartingWithJ.count(substring) > 0) duplicate++;\\n                }\\n\\n                // Add the product of the size of each set minus the number of duplicates to the final answer\\n                ans += (substringsStartingWithI.size() - duplicate) * (substringsStartingWithJ.size() - duplicate);\\n            }\\n        }\\n\\n        // Multiply the final answer by 2 because swapping the first letters of two ideas generates two distinct names\\n        return ans * 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162835,
                "title": "python3-dictionary-solution-96-74",
                "content": "# Idea\\nConstruct a dictionary `d` with keys the alphabats `x` where the values are set of strings `s` such that `x+s` is in `ideas`. One can then derive the result by computing pairwise intersections.\\n\\n# Code\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        d = defaultdict(set)\\n        for idea in ideas:\\n            d[idea[0]].add(idea[1:])\\n        result = 0\\n        for (x, y) in combinations(d, 2):\\n            temp = len(d[x] & d[y])\\n            result += (len(d[x]) - temp) * (len(d[y]) - temp)\\n        return result * 2\\n```\\n\\n##### Example\\nSay we have `[\\'ab\\',\\'ac\\',\\'bc\\',\\'bd\\']`, then `d={\\'a\\':{\\'b\\',\\'c\\'},\\'b\\':{\\'c\\',\\'d\\'}}`. The only available swap is between `\\'ab\\',\\'bd\\'`, so this should output `2`. The formula for computing this can be seen in the code above.\\n\\n##### Note on implementation in Python\\n`collections.defaultdict` is pretty handy to avoid getting KeyErrors and specify how to initialize a dictionary key value, while `itertools.combinations` is also convenient when we want to iterate over pairs of elements in an iterable.",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        d = defaultdict(set)\\n        for idea in ideas:\\n            d[idea[0]].add(idea[1:])\\n        result = 0\\n        for (x, y) in combinations(d, 2):\\n            temp = len(d[x] & d[y])\\n            result += (len(d[x]) - temp) * (len(d[y]) - temp)\\n        return result * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162770,
                "title": "simple-js-solution",
                "content": "# Code\\n\\n```js\\n/**\\n * @param {string[]} ideas\\n * @return {number}\\n */\\nvar distinctNames = function (ideas) {\\n  let map = {};\\n  // storing data as key value pair\\n  // key is char & value is suffix that is without 1st letter\\n  for (const idea of ideas) {\\n    let char = idea[0];\\n    if (!map[char]) map[char] = new Set();\\n    map[char].add(idea.slice(1));\\n  }\\n  let result = 0;\\n  // looping over map  just like nested for loop every 1 char with rest all char\\n\\n  for (let char1 in map) {\\n    for (let char2 in map) {\\n      // if char are same means we cannot add them to result\\n      if (char1 === char2) {\\n        continue;\\n      }\\n      // Here we have to find different suffix\\n      // because if suffix are same we have a same word in gives ideas & hence we cannot increment count\\n      // idea is to get intersect that is get common suffix count & sub it from set of all suffix\\n      //\\n      let intersect = 0;\\n      for (let w of map[char1]) {\\n        if (map[char2].has(w)) {\\n          intersect++;\\n        }\\n      }\\n      let d1 = map[char1].size - intersect;\\n      let d2 = map[char2].size - intersect;\\n      result = result + d1 * d2;\\n    }\\n  }\\n  return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string[]} ideas\\n * @return {number}\\n */\\nvar distinctNames = function (ideas) {\\n  let map = {};\\n  // storing data as key value pair\\n  // key is char & value is suffix that is without 1st letter\\n  for (const idea of ideas) {\\n    let char = idea[0];\\n    if (!map[char]) map[char] = new Set();\\n    map[char].add(idea.slice(1));\\n  }\\n  let result = 0;\\n  // looping over map  just like nested for loop every 1 char with rest all char\\n\\n  for (let char1 in map) {\\n    for (let char2 in map) {\\n      // if char are same means we cannot add them to result\\n      if (char1 === char2) {\\n        continue;\\n      }\\n      // Here we have to find different suffix\\n      // because if suffix are same we have a same word in gives ideas & hence we cannot increment count\\n      // idea is to get intersect that is get common suffix count & sub it from set of all suffix\\n      //\\n      let intersect = 0;\\n      for (let w of map[char1]) {\\n        if (map[char2].has(w)) {\\n          intersect++;\\n        }\\n      }\\n      let d1 = map[char1].size - intersect;\\n      let d2 = map[char2].size - intersect;\\n      result = result + d1 * d2;\\n    }\\n  }\\n  return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162731,
                "title": "c-easy-explainable-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    long long distinctNames(vector<string>& ideas) \\n    {\\n        unordered_map<string , bool> mp;\\n        for(int i = 0; i < ideas.size(); i++)\\n        {\\n            mp[ideas[i]] = true;\\n        }\\n        \\n        vector<vector<long long>> distint(26 , vector<long long> (26,0));\\n        for(int i = 0 ;i < ideas.size(); i++)\\n        {\\n            string afterremovefirstchar = ideas[i].substr(1);\\n            int in = ideas[i][0]-\\'a\\';\\n            for(int j = 0; j < 26; j++) // to check after adding char a to z and check that char is present in map or not.\\n            {\\n                char y = (j+\\'a\\'); \\n                string afterconcatenation = y+afterremovefirstchar;\\n                if(mp.count(afterconcatenation) == 0) // it means the distint word in a string then \\n                {\\n                    distint[in][j] += 1;\\n                }\\n            }\\n        }\\n        \\n        long long count = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            for(int j = 0; j < 26; j++)\\n            {\\n                if(distint[i][j] > 0)\\n                {\\n                    count += distint[i][j]*distint[j][i];\\n                }\\n                    \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long distinctNames(vector<string>& ideas) \\n    {\\n        unordered_map<string , bool> mp;\\n        for(int i = 0; i < ideas.size(); i++)\\n        {\\n            mp[ideas[i]] = true;\\n        }\\n        \\n        vector<vector<long long>> distint(26 , vector<long long> (26,0));\\n        for(int i = 0 ;i < ideas.size(); i++)\\n        {\\n            string afterremovefirstchar = ideas[i].substr(1);\\n            int in = ideas[i][0]-\\'a\\';\\n            for(int j = 0; j < 26; j++) // to check after adding char a to z and check that char is present in map or not.\\n            {\\n                char y = (j+\\'a\\'); \\n                string afterconcatenation = y+afterremovefirstchar;\\n                if(mp.count(afterconcatenation) == 0) // it means the distint word in a string then \\n                {\\n                    distint[in][j] += 1;\\n                }\\n            }\\n        }\\n        \\n        long long count = 0;\\n        for(int i = 0; i < 26; i++)\\n        {\\n            for(int j = 0; j < 26; j++)\\n            {\\n                if(distint[i][j] > 0)\\n                {\\n                    count += distint[i][j]*distint[j][i];\\n                }\\n                    \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162690,
                "title": "easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         HashSet<Integer>[] count = new HashSet[26];\\n        for (int i = 0; i < 26; ++i)\\n            count[i] = new HashSet<>();\\n        for (String s : ideas)\\n            count[s.charAt(0) - \\'a\\'].add(s.substring(1).hashCode());\\n        long res = 0;\\n        for (int i = 0; i < 26; ++i)\\n            for (int j = i + 1; j < 26; ++j) {\\n                long c1 = 0, c2 = 0;\\n                for (int c : count[i])\\n                    if (!count[j].contains(c)) c1++;\\n                for (int c : count[j])\\n                    if (!count[i].contains(c)) c2++;\\n                res += c1 * c2;\\n            }\\n        return res * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         HashSet<Integer>[] count = new HashSet[26];\\n        for (int i = 0; i < 26; ++i)\\n            count[i] = new HashSet<>();\\n        for (String s : ideas)\\n            count[s.charAt(0) - \\'a\\'].add(s.substring(1).hashCode());\\n        long res = 0;\\n        for (int i = 0; i < 26; ++i)\\n            for (int j = i + 1; j < 26; ++j) {\\n                long c1 = 0, c2 = 0;\\n                for (int c : count[i])\\n                    if (!count[j].contains(c)) c1++;\\n                for (int c : count[j])\\n                    if (!count[i].contains(c)) c2++;\\n                res += c1 * c2;\\n            }\\n        return res * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162682,
                "title": "naming-a-company-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> sets=new HashSet<>();\\n\\t\\tint[][] dp=new int[26][26];\\n\\t\\tint n=ideas.length;\\n\\t\\tlong count=0;\\n\\n\\t\\tfor(String idea:ideas)\\n\\t\\t\\tsets.add(idea);\\n\\n\\t\\tfor(String idea:ideas)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<26;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString s=(char)(j+\\'a\\')+idea.substring(1);\\n\\n\\t\\t\\t\\tif(!sets.contains(s))\\n\\t\\t\\t\\t\\tdp[idea.charAt(0)-\\'a\\'][j]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0;i<26;i++)\\n\\t\\t\\tfor(int j=0;j<26;j++)\\n\\t\\t\\t\\tcount+=dp[i][j]*dp[j][i];\\n\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> sets=new HashSet<>();\\n\\t\\tint[][] dp=new int[26][26];\\n\\t\\tint n=ideas.length;\\n\\t\\tlong count=0;\\n\\n\\t\\tfor(String idea:ideas)\\n\\t\\t\\tsets.add(idea);\\n\\n\\t\\tfor(String idea:ideas)\\n\\t\\t{\\n\\t\\t\\tfor(int j=0;j<26;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tString s=(char)(j+\\'a\\')+idea.substring(1);\\n\\n\\t\\t\\t\\tif(!sets.contains(s))\\n\\t\\t\\t\\t\\tdp[idea.charAt(0)-\\'a\\'][j]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0;i<26;i++)\\n\\t\\t\\tfor(int j=0;j<26;j++)\\n\\t\\t\\t\\tcount+=dp[i][j]*dp[j][i];\\n\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162677,
                "title": "accepted-very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long count=0;\\n        vector<unordered_set<string>>arr(26);\\n        for(string i:ideas)\\n        arr[i[0]-\\'a\\'].insert(i.substr(1));\\n        for(int i=0; i<25;i++){\\n            for(int j=i+1;j<26;j++){\\n                unordered_set<string>set;\\n                set.insert(arr[i].begin(),arr[i].end());\\n                set.insert(arr[j].begin(),arr[j].end());\\n                count+=(arr[i].size()-set.size())*(arr[j].size()-set.size());\\n            }\\n        }\\n        return count*2;\\n    }\\n};\\n```\\n![upvote 3.png](https://assets.leetcode.com/users/images/7a3f2baa-1d51-462d-a71a-57e9edff5e49_1675915493.2997746.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        long long count=0;\\n        vector<unordered_set<string>>arr(26);\\n        for(string i:ideas)\\n        arr[i[0]-\\'a\\'].insert(i.substr(1));\\n        for(int i=0; i<25;i++){\\n            for(int j=i+1;j<26;j++){\\n                unordered_set<string>set;\\n                set.insert(arr[i].begin(),arr[i].end());\\n                set.insert(arr[j].begin(),arr[j].end());\\n                count+=(arr[i].size()-set.size())*(arr[j].size()-set.size());\\n            }\\n        }\\n        return count*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162661,
                "title": "python-suffix-count-hashtable-beats-90-time-complexity",
                "content": "# Code\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        cnt = 0\\n        suffixes = [set() for _ in range(26)]\\n        for idea in ideas:\\n            suffixes[ord(idea[0]) - ord(\\'a\\')].add(idea[1:])\\n        for i in range(25):\\n            for j in range(i+1, 26):\\n                ans = len(suffixes[i] & suffixes[j])\\n                cnt += 2 * (len(suffixes[i]) - ans) * (len(suffixes[j]) - ans) \\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        cnt = 0\\n        suffixes = [set() for _ in range(26)]\\n        for idea in ideas:\\n            suffixes[ord(idea[0]) - ord(\\'a\\')].add(idea[1:])\\n        for i in range(25):\\n            for j in range(i+1, 26):\\n                ans = len(suffixes[i] & suffixes[j])\\n                cnt += 2 * (len(suffixes[i]) - ans) * (len(suffixes[j]) - ans) \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162605,
                "title": "kotlin-easy-understanding-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun distinctNames(ideas: Array<String>): Long {\\n        var num = 0L\\n        val ideasMap = ideas.groupBy ({ it[0] },{it.removeRange(0 until 1) }).values.toList()\\n        for(i in ideasMap.indices){\\n            for(j in i+1 until ideasMap.size){\\n                val intersectTwoList = ideasMap[i].intersect(ideasMap[j].toSet()).size\\n                num += (2 * (ideasMap[i].size-intersectTwoList ) * ((ideasMap[j].size)-intersectTwoList))\\n            }\\n        }\\n        return num\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    fun distinctNames(ideas: Array<String>): Long {\\n        var num = 0L\\n        val ideasMap = ideas.groupBy ({ it[0] },{it.removeRange(0 until 1) }).values.toList()\\n        for(i in ideasMap.indices){\\n            for(j in i+1 until ideasMap.size){\\n                val intersectTwoList = ideasMap[i].intersect(ideasMap[j].toSet()).size\\n                num += (2 * (ideasMap[i].size-intersectTwoList ) * ((ideasMap[j].size)-intersectTwoList))\\n            }\\n        }\\n        return num\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162556,
                "title": "simple-easy-explanation-of-the-approach-and-thought-process-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought time toffee can\\'t pair up, because on first letter interchanging \\nno new word is formed.\\nI thought coffee toffee can\\'t pair up, because on first letter interchanging coffee already exists in the ideas.\\nFirstly I submitted the solution by BF and got TLE, but atleast I thought I got the question right.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhy not we can make a vector(we know 26 alphabets only) or map of sets, so that we can store cnt unique postfix with same starting letter.\\nNow first problem gone, toffee time will come in same set, and we will not count them in answer. \\nwe will take map first and second , first and third and so on, can be 26^2 at max, ((n^2)combinations) and see if the postfix are not same we can join them as coffee toffee postfix are same, so we can\\'t join them. \\nDoubling up as time dime and dime time both are valid. \\n\\n# Complexity\\n- Time complexity: 0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        vector<unordered_set<string>> count(26);\\n        for(auto& idea : ideas){\\n            count[idea[0] - \\'a\\'].insert(idea.substr(1));\\n        }\\n        long ret = 0;\\n        for(int i = 0; i < 26; i ++){\\n            for(int j = i + 1; j < 26; j ++){\\n                long c1 = 0, c2 = 0;\\n                for(auto& p : count[i]){\\n                    if(count[j].find(p) == count[j].end()){\\n                        c1 ++;\\n                    }\\n                }\\n                for(auto& p : count[j]){\\n                    if(count[i].find(p) == count[i].end()){\\n                        c2 ++;\\n                    }\\n                }\\n                ret += c1 * c2 * 2;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        vector<unordered_set<string>> count(26);\\n        for(auto& idea : ideas){\\n            count[idea[0] - \\'a\\'].insert(idea.substr(1));\\n        }\\n        long ret = 0;\\n        for(int i = 0; i < 26; i ++){\\n            for(int j = i + 1; j < 26; j ++){\\n                long c1 = 0, c2 = 0;\\n                for(auto& p : count[i]){\\n                    if(count[j].find(p) == count[j].end()){\\n                        c1 ++;\\n                    }\\n                }\\n                for(auto& p : count[j]){\\n                    if(count[i].find(p) == count[i].end()){\\n                        c2 ++;\\n                    }\\n                }\\n                ret += c1 * c2 * 2;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162485,
                "title": "python-begineer-friendly-well-explained",
                "content": "# Intitution\\nElement with same first letter cannot form valid combination as replecing them create the same name again.\\nTherefore, there is no relation between element with same first letter. So, we will divide them into different set with same first letter.\\nThen we will compare every set and and check the common element because common element also leads to same invalid sequence **if we have \"cat\",\"car\" and \"rat\" so replacing c with r in \"cat\" and \"rat\"will make the same letters again and even if we replace \"car\" and \"rat\" thet will also creat \"cat\" that is invalid**. So we will simply dont count them in result .\\ntake intersection and dont count them while calculating the combination.\\n# Code\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        d={}\\n        #creating a dictionary with first letter as key\\n        for i in ideas:\\n            if ord(i[0]) in d:\\n                d[ord(i[0])].add(i[1:])\\n            else:\\n                d[ord(i[0])]={i[1:]}\\n        r=0  \\n        #comparing every set with each other      \\n        for i in range(97,123):\\n            if i not in d:\\n                continue\\n            for j in range(i+1,123):\\n                if j not in d:\\n                    continue\\n                # we dont need common element because that will lead to invalid sequence\\n                a=len(d[i].intersection(d[j]))\\n                #removing common element and add total combinations it to result \\n                r+=((len(d[i])-a)*(len(d[j])-a))*2           \\n        return r        \\n```\\n **UPVOTE IF YOU FIND THIS HELPFUL AND DO COMMENT IF YOU GET CONFUSED SOMEWHERE**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        d={}\\n        #creating a dictionary with first letter as key\\n        for i in ideas:\\n            if ord(i[0]) in d:\\n                d[ord(i[0])].add(i[1:])\\n            else:\\n                d[ord(i[0])]={i[1:]}\\n        r=0  \\n        #comparing every set with each other      \\n        for i in range(97,123):\\n            if i not in d:\\n                continue\\n            for j in range(i+1,123):\\n                if j not in d:\\n                    continue\\n                # we dont need common element because that will lead to invalid sequence\\n                a=len(d[i].intersection(d[j]))\\n                #removing common element and add total combinations it to result \\n                r+=((len(d[i])-a)*(len(d[j])-a))*2           \\n        return r        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162372,
                "title": "hash-beating-95-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe length of ideas is at 10^4 level, which means we cannot just loop twice, as the limit is at 10^6 level. \\nGiven we need to find the unoverlapped rest of strings other than the initial, we can use hash - to keep the length of substrings per initial and get the length of substring intersection of two initials, and finally get the result\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse hash, i.e. set to keep the unique substrings per initial and loop it twice (at most 26 * 26 loops).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where n is the length of ideas. The count of loops is at most 26 * 26. Per loop we take intersection of two sets, whose complexity is O(min(len1, len2)) where len1 and len2 are the lengths of the two sets. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) where n is the length of ideas. A list to keep sets and the sets contains all elements in ideas. \\n\\n# Code\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        ls = [set() for _ in range(26)]\\n        for idea in ideas: \\n            init = idea[0]\\n            rest = idea[1:]\\n            ls[ord(init) - 97].add(rest)\\n        res = 0\\n        for i in range(25): \\n            st1 = ls[i]\\n            len1 = len(st1)\\n            if not len1: \\n                continue\\n            for j in range(i + 1, 26): \\n                st2 = ls[j]\\n                len2 = len(st2)\\n                if not len2: \\n                    continue\\n                len_int = len(st1.intersection(st2))\\n                res += 2 * (len1 - len_int) * (len2 - len_int)\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        ls = [set() for _ in range(26)]\\n        for idea in ideas: \\n            init = idea[0]\\n            rest = idea[1:]\\n            ls[ord(init) - 97].add(rest)\\n        res = 0\\n        for i in range(25): \\n            st1 = ls[i]\\n            len1 = len(st1)\\n            if not len1: \\n                continue\\n            for j in range(i + 1, 26): \\n                st2 = ls[j]\\n                len2 = len(st2)\\n                if not len2: \\n                    continue\\n                len_int = len(st1.intersection(st2))\\n                res += 2 * (len1 - len_int) * (len2 - len_int)\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162332,
                "title": "lil-bit-easy-approach",
                "content": "** UPVOTE IF U FOUND IT HELPFUL :-)**\\n\\n# Code\\n```\\n   long long distinctNames(vector<string>& ideas) {\\n       long long ans=0;\\n       int len=ideas.size();\\n       int  cnt[26][26]={0};\\n       unordered_set<string> Set;\\n       for(int j=0;j<len;j++)\\n       {\\n\\n           Set.insert(ideas[j]);\\n       }\\n       for(int j=0;j<len;j++){\\n           string s= ideas[j];\\n           int st=s[0] -\\'a\\';\\n           \\n           for(int i=0;i<26;i++)\\n           {\\n              s[0]=i+\\'a\\';\\n             if (Set.find(s)==Set.end())\\n             {\\n                   cnt[st][i]++;  \\n                   ans+=cnt[i][st];\\n               }\\n           }\\n       }\\n     \\n       return ans*2;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n   long long distinctNames(vector<string>& ideas) {\\n       long long ans=0;\\n       int len=ideas.size();\\n       int  cnt[26][26]={0};\\n       unordered_set<string> Set;\\n       for(int j=0;j<len;j++)\\n       {\\n\\n           Set.insert(ideas[j]);\\n       }\\n       for(int j=0;j<len;j++){\\n           string s= ideas[j];\\n           int st=s[0] -\\'a\\';\\n           \\n           for(int i=0;i<26;i++)\\n           {\\n              s[0]=i+\\'a\\';\\n             if (Set.find(s)==Set.end())\\n             {\\n                   cnt[st][i]++;  \\n                   ans+=cnt[i][st];\\n               }\\n           }\\n       }\\n     \\n       return ans*2;\\n   }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3157288,
                "title": "rust-solution-using-hashset",
                "content": "# Code\\n### Without HashMap\\n```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let mut groups: Vec<HashSet<String>> = vec![HashSet::new(); 26];\\n        let mut pairs: i64 = 0;\\n\\n        ideas.into_iter().for_each(|idea| {\\n            groups[(idea.as_bytes()[0] - b\\'a\\') as usize].insert(idea[1..].to_string());\\n        });\\n\\n        for i in 0..25 {\\n            for j in (i + 1)..26 {\\n                let dup = groups[i].iter().filter(|&s| groups[j].contains(s)).count();\\n                pairs += 2 * ((groups[i].len() - dup) * (groups[j].len() - dup)) as i64;\\n            }\\n        }\\n        pairs\\n    }\\n}\\n```\\n\\n### With HashMap\\n\\n```\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let mut groups: HashMap<&str, HashSet<&str>> = HashMap::new();\\n\\n        ideas.iter().for_each(|idea| {\\n            groups.entry(&idea[..1])\\n                .or_insert(HashSet::new()).insert(&idea[1..]);\\n        });\\n\\n        let mut keys: Vec<&str> = groups.keys().map(|&key| key).collect();\\n        let mut pairs: i64 = 0;\\n\\n        for &k1 in keys.iter() {\\n            groups.iter().for_each(|(&k2, v2)| {\\n                let mut dup = 0;\\n                for sfx in groups[k1].iter() {\\n                    if v2.contains(sfx) {\\n                        dup += 1;\\n                    }\\n                }\\n                pairs += 2 * (groups[k1].len() as i64 - dup) * (v2.len() as i64 - dup);\\n            });\\n            groups.remove(k1);\\n        }\\n        pairs\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let mut groups: Vec<HashSet<String>> = vec![HashSet::new(); 26];\\n        let mut pairs: i64 = 0;\\n\\n        ideas.into_iter().for_each(|idea| {\\n            groups[(idea.as_bytes()[0] - b\\'a\\') as usize].insert(idea[1..].to_string());\\n        });\\n\\n        for i in 0..25 {\\n            for j in (i + 1)..26 {\\n                let dup = groups[i].iter().filter(|&s| groups[j].contains(s)).count();\\n                pairs += 2 * ((groups[i].len() - dup) * (groups[j].len() - dup)) as i64;\\n            }\\n        }\\n        pairs\\n    }\\n}\\n```\n```\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let mut groups: HashMap<&str, HashSet<&str>> = HashMap::new();\\n\\n        ideas.iter().for_each(|idea| {\\n            groups.entry(&idea[..1])\\n                .or_insert(HashSet::new()).insert(&idea[1..]);\\n        });\\n\\n        let mut keys: Vec<&str> = groups.keys().map(|&key| key).collect();\\n        let mut pairs: i64 = 0;\\n\\n        for &k1 in keys.iter() {\\n            groups.iter().for_each(|(&k2, v2)| {\\n                let mut dup = 0;\\n                for sfx in groups[k1].iter() {\\n                    if v2.contains(sfx) {\\n                        dup += 1;\\n                    }\\n                }\\n                pairs += 2 * (groups[k1].len() as i64 - dup) * (v2.len() as i64 - dup);\\n            });\\n            groups.remove(k1);\\n        }\\n        pairs\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2785635,
                "title": "swift-solution",
                "content": "## Code \\n\\n```\\nclass Solution {\\n    func distinctNames(_ ideas: [String]) -> Int {\\n        var set = Set<String>()\\n        for i in 0..<ideas.count {\\n            set.insert(ideas[i])\\n        }\\n        var mapArr = [[Int]](repeating: [Int](repeating: 0, count: 26), count: 26)\\n        var map = [Character: [String]]()\\n        for i in 0..<ideas.count {\\n            if map[ideas[i].first!] == nil {\\n                map[ideas[i].first!] = [String]()\\n            }\\n            map[ideas[i].first!]?.append(ideas[i])\\n        }\\n        for i in 0..<26 {\\n            for j in 0..<26 {\\n                for idea in map[Character(UnicodeScalar(i + 97)!)] ?? [String]() {\\n                    if Character(UnicodeScalar(i + 97)!) != Character(UnicodeScalar(j + 97)!) {\\n                        let s = String(UnicodeScalar(j + 97)!) + idea[idea.index(idea.startIndex, offsetBy: 1)...]\\n                        if !set.contains(s) { mapArr[i][j] += 1 }\\n                    }\\n                }\\n            }\\n        }\\n        var ans = 0\\n        for i in 0..<26 {\\n            for j in 0..<26 {\\n                ans += mapArr[i][j] * mapArr[j][i]\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```\\n\\n<HR>\\n\\n## Explanation\\n\\n1. We will store all distinct names in a set.\\n2. We will store all names with the same first letter in a map.\\n3. We will create a 2-d array, where the first index represents the first letter and the second index represents the second letter.\\n4. We will iterate through the 2-d array and for each first letter, we will iterate through the second letter.\\n5. For each second letter, we will iterate through all names with the same first letter and we will create a new name by replacing the first letter with the second letter.\\n6. If the newly created name is not in the set, we will increment the value in the 2-d array at the corresponding indices.\\n7. Once we have the 2-d array, we will iterate through it again and for each first letter, we will iterate through the second letter.\\n8. We will multiply the values at the corresponding indices and add that to the answer.\\n9. We will return the answer.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func distinctNames(_ ideas: [String]) -> Int {\\n        var set = Set<String>()\\n        for i in 0..<ideas.count {\\n            set.insert(ideas[i])\\n        }\\n        var mapArr = [[Int]](repeating: [Int](repeating: 0, count: 26), count: 26)\\n        var map = [Character: [String]]()\\n        for i in 0..<ideas.count {\\n            if map[ideas[i].first!] == nil {\\n                map[ideas[i].first!] = [String]()\\n            }\\n            map[ideas[i].first!]?.append(ideas[i])\\n        }\\n        for i in 0..<26 {\\n            for j in 0..<26 {\\n                for idea in map[Character(UnicodeScalar(i + 97)!)] ?? [String]() {\\n                    if Character(UnicodeScalar(i + 97)!) != Character(UnicodeScalar(j + 97)!) {\\n                        let s = String(UnicodeScalar(j + 97)!) + idea[idea.index(idea.startIndex, offsetBy: 1)...]\\n                        if !set.contains(s) { mapArr[i][j] += 1 }\\n                    }\\n                }\\n            }\\n        }\\n        var ans = 0\\n        for i in 0..<26 {\\n            for j in 0..<26 {\\n                ans += mapArr[i][j] * mapArr[j][i]\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614877,
                "title": "golang-easy-to-understand-solution",
                "content": "Result is OK but got ```Time Limit Exceeded``` error when submitted\\n\\n```\\nfunc distinctNames(ideas []string) int64 {\\n\\tvar result int64\\n\\n\\tfor _, ideaA := range ideas {\\n\\t\\tfor _, ideaB := range ideas {\\n\\t\\t\\tif ideaA == ideaB {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tnStr1, nStr2 := swapFirstLetter(ideaA, ideaB)\\n\\t\\t\\tif stringInSlice(nStr1, ideas) == false && stringInSlice(nStr2, ideas) == false {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc swapFirstLetter(str1 string, str2 string) (nstr1 string, nstr2 string) {\\n\\tfcStr1, str1 := trimLeftCharAndReturnFc(str1)\\n\\tfcStr2, str2 := trimLeftCharAndReturnFc(str2)\\n\\n\\treturn fcStr2 + str1, fcStr1 + str2\\n}\\n\\nfunc trimLeftCharAndReturnFc(s string) (fcStr string, newStr string) {\\n\\tfcStr = string(s[0])\\n\\n\\tif len(s) > 1 {\\n\\t\\treturn fcStr, s[1:]\\n\\t}\\n\\n\\treturn fcStr, \"\"\\n}\\n\\nfunc stringInSlice(a string, list []string) bool {\\n\\tfor _, b := range list {\\n\\t\\tif b == a {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```Time Limit Exceeded```\n```\\nfunc distinctNames(ideas []string) int64 {\\n\\tvar result int64\\n\\n\\tfor _, ideaA := range ideas {\\n\\t\\tfor _, ideaB := range ideas {\\n\\t\\t\\tif ideaA == ideaB {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tnStr1, nStr2 := swapFirstLetter(ideaA, ideaB)\\n\\t\\t\\tif stringInSlice(nStr1, ideas) == false && stringInSlice(nStr2, ideas) == false {\\n\\t\\t\\t\\tresult++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n\\nfunc swapFirstLetter(str1 string, str2 string) (nstr1 string, nstr2 string) {\\n\\tfcStr1, str1 := trimLeftCharAndReturnFc(str1)\\n\\tfcStr2, str2 := trimLeftCharAndReturnFc(str2)\\n\\n\\treturn fcStr2 + str1, fcStr1 + str2\\n}\\n\\nfunc trimLeftCharAndReturnFc(s string) (fcStr string, newStr string) {\\n\\tfcStr = string(s[0])\\n\\n\\tif len(s) > 1 {\\n\\t\\treturn fcStr, s[1:]\\n\\t}\\n\\n\\treturn fcStr, \"\"\\n}\\n\\nfunc stringInSlice(a string, list []string) bool {\\n\\tfor _, b := range list {\\n\\t\\tif b == a {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2190043,
                "title": "cpp-java-hashset-unordered-set",
                "content": "Cpp Code:\\n```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        // HashSet, String manipulation; TC: O(26*26*n); SC: O(26*n)\\n        long long ans=0, cnt;\\n        vector<unordered_set<string>> v(26);\\n        for(string &s: ideas) {\\n            v[s[0]-\\'a\\'].insert(s.substr(1));\\n        }\\n        for(int i=0; i<26; i++) {\\n            for(int j=i+1; j<26; j++) {\\n                cnt=0;\\n                for(string str: v[j]) {\\n                    if(v[i].find(str)!=v[i].end()) cnt++;\\n                }\\n                ans+=(v[i].size()-cnt)*(v[j].size()-cnt)*2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nJava Code:\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        // HashSet + String Manipulation; TC: O(26*26*n); SC: O(26*n) \\n        HashSet<String> [] arr = new HashSet[26];\\n        for(int i=0; i<26; i++) {\\n            arr[i] = new HashSet<>();\\n        }\\n        for(String s: ideas) {\\n            arr[s.charAt(0)-\\'a\\'].add(s.substring(1));\\n        }\\n        long ans=0, cnt;\\n        for(int i=0; i<26; i++) {\\n            for(int j=i+1; j<26; j++) {\\n                cnt=0;\\n                for(String str: arr[j]) {\\n                    if(arr[i].contains(str)) cnt++;\\n                }\\n                ans+=2*(arr[i].size()-cnt)*(arr[j].size()-cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        // HashSet, String manipulation; TC: O(26*26*n); SC: O(26*n)\\n        long long ans=0, cnt;\\n        vector<unordered_set<string>> v(26);\\n        for(string &s: ideas) {\\n            v[s[0]-\\'a\\'].insert(s.substr(1));\\n        }\\n        for(int i=0; i<26; i++) {\\n            for(int j=i+1; j<26; j++) {\\n                cnt=0;\\n                for(string str: v[j]) {\\n                    if(v[i].find(str)!=v[i].end()) cnt++;\\n                }\\n                ans+=(v[i].size()-cnt)*(v[j].size()-cnt)*2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        // HashSet + String Manipulation; TC: O(26*26*n); SC: O(26*n) \\n        HashSet<String> [] arr = new HashSet[26];\\n        for(int i=0; i<26; i++) {\\n            arr[i] = new HashSet<>();\\n        }\\n        for(String s: ideas) {\\n            arr[s.charAt(0)-\\'a\\'].add(s.substring(1));\\n        }\\n        long ans=0, cnt;\\n        for(int i=0; i<26; i++) {\\n            for(int j=i+1; j<26; j++) {\\n                cnt=0;\\n                for(String str: arr[j]) {\\n                    if(arr[i].contains(str)) cnt++;\\n                }\\n                ans+=2*(arr[i].size()-cnt)*(arr[j].size()-cnt);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181857,
                "title": "c-2-methods",
                "content": "**First methods - common PREFIX & intersection groups with different prefixes**\\nRuntime: 473 ms, faster than 97.78% of C++ online submissions for Naming a Company.\\nMemory Usage: 83.3 MB, less than 71.80% of C++ online submissions for Naming a Company.\\n```\\nclass Solution {\\npublic:\\n  long long distinctNames(vector<string>& ideas) { \\n    vector<unordered_set<string>> table(26);\\n\\n    for(auto &i : ideas){\\n      int id = i[0]-\\'a\\';\\n      i[0] = \\'*\\';\\n      table[id].insert(i);\\n    }\\n    \\n    long ans = 0;\\n    \\n    for(int i = 0; i != 26; i++)\\n      if(!table[i].empty())\\n        for(int j = i+1; j != 26; j++)\\n          if(!table[j].empty()){\\n            int inter = 0;\\n            for(auto &x: table[j])\\n              if(table[i].count(x)) inter++;\\n          \\n            ans += (table[i].size() - inter) * (table[j].size() - inter);\\n          }\\n    \\n    return ans*2;\\n  }\\n};\\n```\\n\\n**Second methods - common SUFFIX & intersection groups with different suffixes**\\n![image](https://assets.leetcode.com/users/images/1c518c58-c209-4b44-9b5c-277c7d271dbc_1655880857.3236783.png)\\n**Conclusion : second methods are good but numbers of prefixes is alwais constant and equal 26 : numbers of suffixes isnt constant and for worst case we will have time n^2. But I was intersted how far second method will reach.**\\n```\\nclass Solution {\\npublic:\\n  long long distinctNames(vector<string>& ideas) { \\n    unordered_map<string, unsigned int> table;\\n\\n    for(auto &i : ideas){\\n      int mask = 1<<(i[0]-\\'a\\');\\n      i[0] = \\'*\\';\\n      table[i] |= mask;\\n    }\\n\\n    long ans = 0;\\n\\n    while(table.size() > 1){\\n      string s1 = table.begin()->first;\\n      unsigned int m1 = table.begin()->second;\\n      table.erase(s1);\\n      for(auto &[s2 , m2] : table){\\n          int inter = m1 & m2;\\n          ans += CountOnes5(m1^inter)*CountOnes5(m2^inter);\\n        }\\n    }\\n    return ans*2;\\n  }\\n\\n  inline int CountOnes5 (unsigned int n ) {\\n    n -= (n>>1) & 0x55555555;\\n    n = ((n>>2) & 0x33333333 ) + (n & 0x33333333);\\n    n = ((((n>>4) + n) & 0x0F0F0F0F) * 0x01010101) >> 24;\\n    return n;\\n  } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long distinctNames(vector<string>& ideas) { \\n    vector<unordered_set<string>> table(26);\\n\\n    for(auto &i : ideas){\\n      int id = i[0]-\\'a\\';\\n      i[0] = \\'*\\';\\n      table[id].insert(i);\\n    }\\n    \\n    long ans = 0;\\n    \\n    for(int i = 0; i != 26; i++)\\n      if(!table[i].empty())\\n        for(int j = i+1; j != 26; j++)\\n          if(!table[j].empty()){\\n            int inter = 0;\\n            for(auto &x: table[j])\\n              if(table[i].count(x)) inter++;\\n          \\n            ans += (table[i].size() - inter) * (table[j].size() - inter);\\n          }\\n    \\n    return ans*2;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  long long distinctNames(vector<string>& ideas) { \\n    unordered_map<string, unsigned int> table;\\n\\n    for(auto &i : ideas){\\n      int mask = 1<<(i[0]-\\'a\\');\\n      i[0] = \\'*\\';\\n      table[i] |= mask;\\n    }\\n\\n    long ans = 0;\\n\\n    while(table.size() > 1){\\n      string s1 = table.begin()->first;\\n      unsigned int m1 = table.begin()->second;\\n      table.erase(s1);\\n      for(auto &[s2 , m2] : table){\\n          int inter = m1 & m2;\\n          ans += CountOnes5(m1^inter)*CountOnes5(m2^inter);\\n        }\\n    }\\n    return ans*2;\\n  }\\n\\n  inline int CountOnes5 (unsigned int n ) {\\n    n -= (n>>1) & 0x55555555;\\n    n = ((n>>2) & 0x33333333 ) + (n & 0x33333333);\\n    n = ((((n>>4) + n) & 0x0F0F0F0F) * 0x01010101) >> 24;\\n    return n;\\n  } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166842,
                "title": "simple-cpp-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> st;\\n        for(auto it:ideas)\\n        {\\n            st.insert(it);\\n        }\\n        vector<vector<long long>> dict(26,vector<long long>(26,0));\\n        for(auto ele:ideas)\\n        {\\n            char ch=ele[0];\\n            for(char j=\\'a\\';j<=\\'z\\';j++)\\n            {\\n                ele[0]=j;\\n                if(st.find(ele) == st.end())\\n                {\\n                    dict[ch-\\'a\\'][j-\\'a\\']+=1;\\n                }\\n            }\\n        }\\n        long long count=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                count += dict[i][j]*dict[j][i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_set<string> st;\\n        for(auto it:ideas)\\n        {\\n            st.insert(it);\\n        }\\n        vector<vector<long long>> dict(26,vector<long long>(26,0));\\n        for(auto ele:ideas)\\n        {\\n            char ch=ele[0];\\n            for(char j=\\'a\\';j<=\\'z\\';j++)\\n            {\\n                ele[0]=j;\\n                if(st.find(ele) == st.end())\\n                {\\n                    dict[ch-\\'a\\'][j-\\'a\\']+=1;\\n                }\\n            }\\n        }\\n        long long count=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            for(int j=0;j<26;j++)\\n            {\\n                count += dict[i][j]*dict[j][i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165685,
                "title": "golang",
                "content": "```\\nfunc distinctNames(ideas []string) int64 {\\n    dict := make(map[byte]map[string]bool)\\n    for _, s := range ideas {\\n        if _, ok := dict[s[0]]; !ok {\\n            dict[s[0]] = make(map[string]bool)\\n        }\\n        dict[s[0]][s[1:]] = true\\n    }\\n    \\n    res := 0\\n    for a := byte(\\'a\\'); a <= \\'z\\'; a++ {\\n        for b := byte(\\'a\\'); b <= \\'z\\'; b++ {\\n            cnt := 0\\n            for k := range dict[b] {\\n                if !dict[a][k] {\\n                    cnt++\\n                } \\n            }\\n            \\n            for s := range dict[a] {\\n                if !dict[b][s] {\\n                    res += cnt\\n                }\\n            } \\n        }\\n    }\\n    return int64(res)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc distinctNames(ideas []string) int64 {\\n    dict := make(map[byte]map[string]bool)\\n    for _, s := range ideas {\\n        if _, ok := dict[s[0]]; !ok {\\n            dict[s[0]] = make(map[string]bool)\\n        }\\n        dict[s[0]][s[1:]] = true\\n    }\\n    \\n    res := 0\\n    for a := byte(\\'a\\'); a <= \\'z\\'; a++ {\\n        for b := byte(\\'a\\'); b <= \\'z\\'; b++ {\\n            cnt := 0\\n            for k := range dict[b] {\\n                if !dict[a][k] {\\n                    cnt++\\n                } \\n            }\\n            \\n            for s := range dict[a] {\\n                if !dict[b][s] {\\n                    res += cnt\\n                }\\n            } \\n        }\\n    }\\n    return int64(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2158887,
                "title": "java-easy-explainable-solution-list-hashset",
                "content": "```\\n/**\\n * eg. [\"coffee\",\"donuts\",\"time\",\"toffee\"]\\n * array of list created, now store according to first char and also removing first char\\n *\\n * arr[2] = { offee }\\n * arr[3] = { onuts }\\n * arr[19] = { ime, offee }\\n *\\n * now apply the HashSet part operation\\n * set.addAll(arr[i]);\\n * set.addAll(arr[j]);\\n * disName += 2 * (arr[i].size() - set.size()) * (arr[j].size() - set.size());\\n */\\n```\\n**Code:**\\n```\\n    public long distinctNames(String[] ideas) {\\n        List<String> arr[] = new ArrayList[26];               // create array of ArrayList\\n        long disName = 0;                                     // Instead ArrayList, HashSet can be used\\n        for(int i = 0; i < 26; i++)                           // assign new ArrayList to each index\\n            arr[i] = new ArrayList<>();\\n\\n        for(String s : ideas)\\n            arr[s.charAt(0) - \\'a\\'].add(s.substring(1));       // store each string A/C to its 1st char\\n\\n        for(int i = 0; i < 25; i++) {\\n            for(int j = i + 1; j < 26; j++) {\\n                Set<String> set = new HashSet<>();            // store all strings of arr[i] & arr[j]\\n\\n                set.addAll(arr[i]);\\n                set.addAll(arr[j]);\\n                disName += (arr[i].size() - set.size()) * (arr[j].size() - set.size());     // no. of pairs possible\\n            }\\n        }\\n\\n        return disName * 2;\\n    }\\n```\\n*Comment down, If you have any doubt.*\\n**Upvote^, If you liked it!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * eg. [\"coffee\",\"donuts\",\"time\",\"toffee\"]\\n * array of list created, now store according to first char and also removing first char\\n *\\n * arr[2] = { offee }\\n * arr[3] = { onuts }\\n * arr[19] = { ime, offee }\\n *\\n * now apply the HashSet part operation\\n * set.addAll(arr[i]);\\n * set.addAll(arr[j]);\\n * disName += 2 * (arr[i].size() - set.size()) * (arr[j].size() - set.size());\\n */\\n```\n```\\n    public long distinctNames(String[] ideas) {\\n        List<String> arr[] = new ArrayList[26];               // create array of ArrayList\\n        long disName = 0;                                     // Instead ArrayList, HashSet can be used\\n        for(int i = 0; i < 26; i++)                           // assign new ArrayList to each index\\n            arr[i] = new ArrayList<>();\\n\\n        for(String s : ideas)\\n            arr[s.charAt(0) - \\'a\\'].add(s.substring(1));       // store each string A/C to its 1st char\\n\\n        for(int i = 0; i < 25; i++) {\\n            for(int j = i + 1; j < 26; j++) {\\n                Set<String> set = new HashSet<>();            // store all strings of arr[i] & arr[j]\\n\\n                set.addAll(arr[i]);\\n                set.addAll(arr[j]);\\n                disName += (arr[i].size() - set.size()) * (arr[j].size() - set.size());     // no. of pairs possible\\n            }\\n        }\\n\\n        return disName * 2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150804,
                "title": "clean-c-hashmap-faster-than-83-brute-force-commented",
                "content": "![image](https://assets.leetcode.com/users/images/b5c4b00f-e239-42cb-8c71-5893de846e8a_1655201037.4433916.png)\\n\\n**Input :** `[\"cat\",\"cake\",\"rat\",\"make\",\"roll\",\"can\",\"ran\"]`\\n**Output :** 8\\n\\nEliminate common elements from any **2 sets** (suppose `a` and `b`) and make pairs from \\nremaining elements same as cartesian product of two sets.\\n**valid pairs** = `ans += (a.size()-common)*(b.size()-common)`\\n\\n  c --> <ins>at</ins>, <ins>an</ins>, ake\\n  r --> <ins>at</ins>, oll, <ins>an</ins>\\n m --> <ins>ake</ins>\\n \\n----\\n**Time complexity :** `O(26*26*N)`\\n**Space complexity :** `O(26*N)` \\n\\n----\\n```\\nclass Solution {\\npublic:\\n   \\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        int n=ideas.size();\\n        long long ans=0;;\\n        unordered_map<char,unordered_set<string>>mp;\\n        \\n        for(int i=0;i<n;i++){\\n            if(ideas[i].size()!=1)\\n                mp[ideas[i][0]].insert(ideas[i].substr(1)); // t --> offee, ime, c --> offee, d --> onuts\\n            else                                            // pair of ideas from the same group is invalid.\\n                mp[ideas[i][0]].insert(ideas[0]);\\n        }\\n        \\n        // pairs of ideas from different groups\\n        for(auto i = mp.begin(); i!=mp.end();i++) // --> O(26)\\n        {\\n            auto k = i;\\n            k++;\\n            for(auto j = k;j!=mp.end();j++){\\n                \\n                // two sets (i->second and j->second)\\n                int common=0;\\n                for(auto &s1 : i->second){\\n                    if(j->second.count(s1) > 0){\\n                        common++;\\n                    }\\n                }\\n                // valid pairs\\n                ans += (i->second.size()-common)*(j->second.size()-common);\\n\\n            }\\n        }\\n        return ans*2;        // final answer multiplied by 2 because we can use single valid pair 2 times for \\n\\t\\t                     // the naming of company.\\n    }\\n};\\n```\\n*if you like my efforts and this post, please don\\'t forget to hit the **upvote** ! : )*\\n*Happy coding*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        int n=ideas.size();\\n        long long ans=0;;\\n        unordered_map<char,unordered_set<string>>mp;\\n        \\n        for(int i=0;i<n;i++){\\n            if(ideas[i].size()!=1)\\n                mp[ideas[i][0]].insert(ideas[i].substr(1)); // t --> offee, ime, c --> offee, d --> onuts\\n            else                                            // pair of ideas from the same group is invalid.\\n                mp[ideas[i][0]].insert(ideas[0]);\\n        }\\n        \\n        // pairs of ideas from different groups\\n        for(auto i = mp.begin(); i!=mp.end();i++) // --> O(26)\\n        {\\n            auto k = i;\\n            k++;\\n            for(auto j = k;j!=mp.end();j++){\\n                \\n                // two sets (i->second and j->second)\\n                int common=0;\\n                for(auto &s1 : i->second){\\n                    if(j->second.count(s1) > 0){\\n                        common++;\\n                    }\\n                }\\n                // valid pairs\\n                ans += (i->second.size()-common)*(j->second.size()-common);\\n\\n            }\\n        }\\n        return ans*2;        // final answer multiplied by 2 because we can use single valid pair 2 times for \\n\\t\\t                     // the naming of company.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150337,
                "title": "very-easy-java-soln",
                "content": "```\\n    public long distinctNames(String[] idea) {\\n    \\n        //  instead of ArrayList, hashset can also be used;         \\n        \\n        ArrayList<String> a[]= new ArrayList[26];\\n        long res =0;\\n        for(int i=0;i<26;i++) a[i] = new ArrayList<>();\\n        \\n        for(String s : idea)\\n        { \\n           a[s.charAt(0)-\\'a\\'].add(s.substring(1,s.length()));     \\n        }\\n        \\n        \\n        for(int i=0;i<25;i++)\\n        {\\n            for(int j=i+1;j<26;j++)\\n            {\\n                HashSet<String> hs = new HashSet<>();\\n                hs.addAll(a[i]);\\n                hs.addAll(a[j]);\\n\\n                res += 2 * (a[i].size() - hs.size()) * (a[j].size() - hs.size());\\n            }\\n        }\\n\\t\\treturn res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long distinctNames(String[] idea) {\\n    \\n        //  instead of ArrayList, hashset can also be used;         \\n        \\n        ArrayList<String> a[]= new ArrayList[26];\\n        long res =0;\\n        for(int i=0;i<26;i++) a[i] = new ArrayList<>();\\n        \\n        for(String s : idea)\\n        { \\n           a[s.charAt(0)-\\'a\\'].add(s.substring(1,s.length()));     \\n        }\\n        \\n        \\n        for(int i=0;i<25;i++)\\n        {\\n            for(int j=i+1;j<26;j++)\\n            {\\n                HashSet<String> hs = new HashSet<>();\\n                hs.addAll(a[i]);\\n                hs.addAll(a[j]);\\n\\n                res += 2 * (a[i].size() - hs.size()) * (a[j].size() - hs.size());\\n            }\\n        }\\n\\t\\treturn res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2149833,
                "title": "c-solution-using-hashmap-easy-to-understand",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<char, unordered_set<string>> mp;\\n        ll ans=0;\\n        for(auto &s: ideas) mp[s[0]].insert(s.substr(1,s.size()-1));\\n        for(auto i=mp.begin(), k=mp.begin(); i!=mp.end(); ++i) {\\n            ++k;\\n            auto j=k;\\n            for(; j!=mp.end(); ++j) {\\n                ll common=0;\\n                auto& a=i->second;\\n                auto& b=j->second;\\n                for(auto& i: a) {\\n                    if(b.count(i)) common++;\\n                }\\n                ans+=(a.size()-common)*(b.size()-common)*2;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote(); // thanks:)\\n}\\n*/\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<char, unordered_set<string>> mp;\\n        ll ans=0;\\n        for(auto &s: ideas) mp[s[0]].insert(s.substr(1,s.size()-1));\\n        for(auto i=mp.begin(), k=mp.begin(); i!=mp.end(); ++i) {\\n            ++k;\\n            auto j=k;\\n            for(; j!=mp.end(); ++j) {\\n                ll common=0;\\n                auto& a=i->second;\\n                auto& b=j->second;\\n                for(auto& i: a) {\\n                    if(b.count(i)) common++;\\n                }\\n                ans+=(a.size()-common)*(b.size()-common)*2;\\n            }\\n        }\\n     return ans;\\n    }\\n};\\n/**\\nif(find helpful) {\\ndo upvote(); // thanks:)\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148290,
                "title": "javascript-with-set-faster-than-100-394ms",
                "content": "Explanation with pictures here:\\n https://leetcode.com/problems/naming-a-company/discuss/2141038/Python-3-Explanation-with-pictures\\n\\n```\\nlet distinctNames = ideas => {\\n    // fill up with an empty set for each position of the alphabet\\n    let abc = new Array(26).fill(0).map(s => new Set());\\n    for (let idea of ideas) {\\n        // add each suffix to each initial\\n        let pos = idea[0].charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n        abc[pos].add(idea.slice(1));\\n    }\\n    \\n    let result = 0;\\n    for (let idx = 0; idx < abc.length; idx++) {\\n        for (let j = idx + 1; j < abc.length; j++) {\\n            let count = 0;\\n            // count the suffix shared by the two sets\\n            for (let sfx of abc[idx]) {\\n                count += abc[j].has(sfx) ? 1 : 0;\\n            }\\n            \\n            // 2 * unique in A * unique in B\\n            result += 2 * (abc[idx].size - count) * (abc[j].size - count);\\n        }\\n    }\\n    \\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "Explanation with pictures here:\\n https://leetcode.com/problems/naming-a-company/discuss/2141038/Python-3-Explanation-with-pictures\\n\\n```\\nlet distinctNames = ideas => {\\n    // fill up with an empty set for each position of the alphabet\\n    let abc = new Array(26).fill(0).map(s => new Set());\\n    for (let idea of ideas) {\\n        // add each suffix to each initial\\n        let pos = idea[0].charCodeAt(0) - \\'a\\'.charCodeAt(0);\\n        abc[pos].add(idea.slice(1));\\n    }\\n    \\n    let result = 0;\\n    for (let idx = 0; idx < abc.length; idx++) {\\n        for (let j = idx + 1; j < abc.length; j++) {\\n            let count = 0;\\n            // count the suffix shared by the two sets\\n            for (let sfx of abc[idx]) {\\n                count += abc[j].has(sfx) ? 1 : 0;\\n            }\\n            \\n            // 2 * unique in A * unique in B\\n            result += 2 * (abc[idx].size - count) * (abc[j].size - count);\\n        }\\n    }\\n    \\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2144713,
                "title": "javascript-2d-array-w-first-letter-pointing-to-sets-350ms",
                "content": "Thought process:\\n- Since each combo needs 2 different first letters, we can split up ideas into a 2d array by first letter\\n- When considering 2 words in separate lists, we can count a name as valid IFF neither tail (word minus the first letter) exists in the other\\'s list\\n- Meaning the combo count which results from any two lists, is the unique tails from list 1 multiplied by the unique tails from list 2\\n- Instead of checking both lists explicitly for unique values, we can just count the common words, and unique will be (total list size - common)\\n- Need to remember that each combo can be reversed, so multiply output by 2\\n\\n```\\nconst acode = \\'a\\'.charCodeAt()\\nconst distinctNames = ideas => {\\n    \\n    const ideaTails = Array.from(\\n        {length: 26}, \\n        () => new Set()\\n    )\\n    ideas.forEach( idea => \\n      ideaTails[ idea[0].charCodeAt() - acode ]\\n        .add( idea.slice(1) ) \\n     )\\n    \\n    let tot = 0\\n    for ( let i = 0; i < 26; i++ ) {\\n        for ( let j = i+1; j < 26; j++ ) {\\n            let common = 0\\n            \\n            ideaTails[i].forEach( tail => \\n                ideaTails[j].has( tail ) \\n                && common++ \\n            )\\n\\n            tot +=\\n                ( ideaTails[i].size - common )\\n                * ( ideaTails[j].size - common )\\n        }\\n    }\\n\\n    return tot * 2\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Ordered Set"
                ],
                "code": "```\\nconst acode = \\'a\\'.charCodeAt()\\nconst distinctNames = ideas => {\\n    \\n    const ideaTails = Array.from(\\n        {length: 26}, \\n        () => new Set()\\n    )\\n    ideas.forEach( idea => \\n      ideaTails[ idea[0].charCodeAt() - acode ]\\n        .add( idea.slice(1) ) \\n     )\\n    \\n    let tot = 0\\n    for ( let i = 0; i < 26; i++ ) {\\n        for ( let j = i+1; j < 26; j++ ) {\\n            let common = 0\\n            \\n            ideaTails[i].forEach( tail => \\n                ideaTails[j].has( tail ) \\n                && common++ \\n            )\\n\\n            tot +=\\n                ( ideaTails[i].size - common )\\n                * ( ideaTails[j].size - common )\\n        }\\n    }\\n\\n    return tot * 2\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2143933,
                "title": "go-golang-count-ideas-by-keeping-track-of-suffixes-and-prefix-letters",
                "content": "```\\nfunc distinctNames(ideas []string) (result int64) {\\n    suffix:=map[string][26]bool{} // keeps a map of suffix to prefix letter\\n    count:=[26]int{} // keeps a count of each letter frequency in first letter of each idea\\n    same:=[26][26]int{} //keeps a count of shared prefixes\\n    val:=0\\n    s:=\"\"\\n    for _,idea:=range ideas{\\n        s=string(idea[1:])\\n        val=int(idea[0]-\\'a\\')\\n        count[val]++\\n        if _,ok:=suffix[s];!ok{\\n            suffix[s]=[26]bool{}\\n        }\\n        chars:=suffix[s]\\n        chars[val]=true\\n        suffix[s]=chars\\n    }\\n    for _,chars:=range suffix{\\n        for i:=range chars{\\n            if !chars[i]{ continue }\\n            for j:=i+1;j<26;j++{\\n                if !chars[j]{ continue }\\n                same[i][j]++\\n            }\\n        }\\n    }\\n    for i:=range count{\\n        if (count[i] == 0) {continue}\\n        for j:=i+1;j<26;j++{\\n            if (count[j] == 0) {continue}\\n            val = (count[i] - same[i][j]) * (count[j] - same[i][j]);\\n            result += int64(val)\\n        }\\n    }\\n    return result*2 // to identify symmetrical solutions under j,i conditions\\n}",
                "solutionTags": [
                    "Go",
                    "Counting"
                ],
                "code": "```\\nfunc distinctNames(ideas []string) (result int64) {\\n    suffix:=map[string][26]bool{} // keeps a map of suffix to prefix letter\\n    count:=[26]int{} // keeps a count of each letter frequency in first letter of each idea\\n    same:=[26][26]int{} //keeps a count of shared prefixes\\n    val:=0\\n    s:=\"\"\\n    for _,idea:=range ideas{\\n        s=string(idea[1:])\\n        val=int(idea[0]-\\'a\\')\\n        count[val]++\\n        if _,ok:=suffix[s];!ok{\\n            suffix[s]=[26]bool{}\\n        }\\n        chars:=suffix[s]\\n        chars[val]=true\\n        suffix[s]=chars\\n    }\\n    for _,chars:=range suffix{\\n        for i:=range chars{\\n            if !chars[i]{ continue }\\n            for j:=i+1;j<26;j++{\\n                if !chars[j]{ continue }\\n                same[i][j]++\\n            }\\n        }\\n    }\\n    for i:=range count{\\n        if (count[i] == 0) {continue}\\n        for j:=i+1;j<26;j++{\\n            if (count[j] == 0) {continue}\\n            val = (count[i] - same[i][j]) * (count[j] - same[i][j]);\\n            result += int64(val)\\n        }\\n    }\\n    return result*2 // to identify symmetrical solutions under j,i conditions\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2143338,
                "title": "rust-group-by-first-char",
                "content": "```\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let mut map: HashMap<u8, HashSet<&str>> = HashMap::new();\\n        \\n        for idea in ideas.iter() {\\n            let first_char = idea.as_bytes()[0];\\n            map.entry(first_char).or_insert(HashSet::new()).insert(&idea[1..]);\\n        }\\n        \\n        let mut res = 0;\\n        for i in b\\'a\\'..=b\\'z\\' {\\n            for j in i+1..=b\\'z\\' {\\n                if !map.contains_key(&i) || !map.contains_key(&j) {\\n                    continue;\\n                }\\n                let mut set_a = map.get(&i).unwrap();\\n                let mut set_b = map.get(&j).unwrap();\\n                \\n                res += 2 * (set_a - set_b).len() * (set_b - set_a).len();\\n            }\\n        }\\n        \\n        res as i64\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::{HashMap, HashSet};\\n\\nimpl Solution {\\n    pub fn distinct_names(ideas: Vec<String>) -> i64 {\\n        let mut map: HashMap<u8, HashSet<&str>> = HashMap::new();\\n        \\n        for idea in ideas.iter() {\\n            let first_char = idea.as_bytes()[0];\\n            map.entry(first_char).or_insert(HashSet::new()).insert(&idea[1..]);\\n        }\\n        \\n        let mut res = 0;\\n        for i in b\\'a\\'..=b\\'z\\' {\\n            for j in i+1..=b\\'z\\' {\\n                if !map.contains_key(&i) || !map.contains_key(&j) {\\n                    continue;\\n                }\\n                let mut set_a = map.get(&i).unwrap();\\n                let mut set_b = map.get(&j).unwrap();\\n                \\n                res += 2 * (set_a - set_b).len() * (set_b - set_a).len();\\n            }\\n        }\\n        \\n        res as i64\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2142944,
                "title": "c-store-the-count-intuition",
                "content": "**INTUITION**\\n\\nAny word starting with letter `i` which can change it\\'s first letter to `j`, can be paired with all the words starting with letter `j` which can change their first letter to `i`\\n\\nHere, `cnt[i][j] = number of words starting with letter \\'i\\' that can change their first letter to \\'j\\' `\\n\\n**CODE**\\n\\n```\\nlong long distinctNames(vector<string>& ideas) {\\n\\tunordered_set<string> s(ideas.begin(), ideas.end());\\n\\tvector<vector<long long>> cnt(26, vector<long long>(26, 0LL));\\n\\n\\tfor(auto &x : ideas) {\\n\\t\\tstring curr = x;\\n\\t\\tfor(int j = 0; j<26; j++) {\\n\\t\\t\\tcurr[0] = \\'a\\' + j;\\n\\t\\t\\tif(!s.count(curr)) cnt[x[0]-\\'a\\'][j]++;\\n\\t\\t}\\n\\t}\\n\\n\\tlong long res = 0LL;\\n\\tfor(auto &x : ideas) {\\n\\t\\tstring curr = x;\\n\\t\\tfor(int i = 0; i<26; i++) {\\n\\t\\t\\tcurr[0] = \\'a\\' + i;\\n\\t\\t\\t// If current word can change it\\'s letter to \\'j\\' we can pair it with all the words than can change their first letters to x[0]-\\'a\\'\\n\\t\\t\\tif(!s.count(curr)) res += cnt[i][x[0]-\\'a\\'];\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```\\n\\n**TIME COMPLEXITY**\\n\\nWe only run a loop over all the words twice, followed by a loop of 26 characters which can be ignored. So the final complexity of this solution is `O(n)`.\\n\\n**Please Upvote if you like the solution!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long distinctNames(vector<string>& ideas) {\\n\\tunordered_set<string> s(ideas.begin(), ideas.end());\\n\\tvector<vector<long long>> cnt(26, vector<long long>(26, 0LL));\\n\\n\\tfor(auto &x : ideas) {\\n\\t\\tstring curr = x;\\n\\t\\tfor(int j = 0; j<26; j++) {\\n\\t\\t\\tcurr[0] = \\'a\\' + j;\\n\\t\\t\\tif(!s.count(curr)) cnt[x[0]-\\'a\\'][j]++;\\n\\t\\t}\\n\\t}\\n\\n\\tlong long res = 0LL;\\n\\tfor(auto &x : ideas) {\\n\\t\\tstring curr = x;\\n\\t\\tfor(int i = 0; i<26; i++) {\\n\\t\\t\\tcurr[0] = \\'a\\' + i;\\n\\t\\t\\t// If current word can change it\\'s letter to \\'j\\' we can pair it with all the words than can change their first letters to x[0]-\\'a\\'\\n\\t\\t\\tif(!s.count(curr)) res += cnt[i][x[0]-\\'a\\'];\\n\\t\\t}\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141938,
                "title": "easy-o-26-n-solution-with-explanation-c",
                "content": "v is to check if a string exists or not, mp stores all the string starting with all 26 characters.\\n```\\nlong long distinctNames(vector<string>& id) {\\n        map<char,vector<string>>mp;\\n        unordered_map<string,int>v;\\n        for(auto s:id){\\n            mp[s[0]].push_back(s);\\n            v[s]++;\\n        }\\n        long long l=0;\\n        for(auto s:id){\\n            string t=s;\\n            for(char c=\\'a\\';c<=\\'z\\';c++){  // changing first char \\n                t[0]=c;\\n                if(!v.count(t)){  // this changed string should not already exist\\n                    for(auto p:mp[c]){     // finding string with which we can change the first char\\n                        string k=p;\\n                        k[0]=s[0];    \\n                        if(!v.count(k))l++;     // after swapping first char the resulting string should not be present.\\n                    }\\n                }\\n            }\\n        }\\n        return l;\\n    }\\n```\\nThis will result in TLE as time complexity in worst case can be O(26* N * N).\\nto optimize this we case make a DP table to store value and then evaluate final answer independently. \\nThis will reduce the time complexity to O(26*N+26 * 26);\\n\\n```\\n long long distinctNames(vector<string>& id) {\\n        map<char,vector<string>>mp;\\n        unordered_map<string,int>v;\\n        for(auto s:id){\\n            mp[s[0]].push_back(s);\\n            v[s]++;\\n        }\\n        long long l=0;\\n        vector<vector<int>>dp(26,vector<int>(26,0));\\n        for(auto s:id){\\n            string t=s;\\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                t[0]=c;\\n                if(!v.count(t)){\\n                    dp[s[0]-\\'a\\'][c-\\'a\\']++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++)l+=dp[i][j]*dp[j][i];\\n        }\\n        return l;\\n    }\\n```\\n\\nthis optimization is inspired by this post.\\nhttps://leetcode.com/problems/naming-a-company/discuss/2140967/Count-Pairs",
                "solutionTags": [],
                "code": "```\\nlong long distinctNames(vector<string>& id) {\\n        map<char,vector<string>>mp;\\n        unordered_map<string,int>v;\\n        for(auto s:id){\\n            mp[s[0]].push_back(s);\\n            v[s]++;\\n        }\\n        long long l=0;\\n        for(auto s:id){\\n            string t=s;\\n            for(char c=\\'a\\';c<=\\'z\\';c++){  // changing first char \\n                t[0]=c;\\n                if(!v.count(t)){  // this changed string should not already exist\\n                    for(auto p:mp[c]){     // finding string with which we can change the first char\\n                        string k=p;\\n                        k[0]=s[0];    \\n                        if(!v.count(k))l++;     // after swapping first char the resulting string should not be present.\\n                    }\\n                }\\n            }\\n        }\\n        return l;\\n    }\\n```\n```\\n long long distinctNames(vector<string>& id) {\\n        map<char,vector<string>>mp;\\n        unordered_map<string,int>v;\\n        for(auto s:id){\\n            mp[s[0]].push_back(s);\\n            v[s]++;\\n        }\\n        long long l=0;\\n        vector<vector<int>>dp(26,vector<int>(26,0));\\n        for(auto s:id){\\n            string t=s;\\n            for(char c=\\'a\\';c<=\\'z\\';c++){\\n                t[0]=c;\\n                if(!v.count(t)){\\n                    dp[s[0]-\\'a\\'][c-\\'a\\']++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            for(int j=0;j<26;j++)l+=dp[i][j]*dp[j][i];\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141685,
                "title": "javascript-faster-than-100-00",
                "content": "```\\nvar distinctNames = function (ideas) {\\n  let map = new Map(), result = 0, keys = [];\\n  for (let idea of ideas) {\\n    let firstCharIndex = idea.charCodeAt(0) - \"a\".charCodeAt(0);\\n    map.set(firstCharIndex, (map.get(firstCharIndex) || (keys.push(firstCharIndex) && new Set())).add(idea.substr(1)));\\n  }\\n  for (let i = 0; i < keys.length; i++) {\\n    for (let j = i + 1; j < keys.length; j++) {\\n      let setA = map.get(keys[i]);\\n      let setB = map.get(keys[j]);\\n      const common = new Set(\\n        [...setA].filter(element => setB.has(element))\\n      );\\n      result += (setA.size - common.size) * (setB.size - common.size);\\n    }\\n  }\\n  return 2 * result; //order is imp, \"doffee conuts\" and \"conuts doffee\" are different\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distinctNames = function (ideas) {\\n  let map = new Map(), result = 0, keys = [];\\n  for (let idea of ideas) {\\n    let firstCharIndex = idea.charCodeAt(0) - \"a\".charCodeAt(0);\\n    map.set(firstCharIndex, (map.get(firstCharIndex) || (keys.push(firstCharIndex) && new Set())).add(idea.substr(1)));\\n  }\\n  for (let i = 0; i < keys.length; i++) {\\n    for (let j = i + 1; j < keys.length; j++) {\\n      let setA = map.get(keys[i]);\\n      let setB = map.get(keys[j]);\\n      const common = new Set(\\n        [...setA].filter(element => setB.has(element))\\n      );\\n      result += (setA.size - common.size) * (setB.size - common.size);\\n    }\\n  }\\n  return 2 * result; //order is imp, \"doffee conuts\" and \"conuts doffee\" are different\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141391,
                "title": "python-time-o-n-space-o-n-2d-dict-similiar-to-2d-array",
                "content": "\\n```python\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        ideas = set(ideas)\\n        initials = set()\\n        for name in ideas:\\n            initials.add(name[0])\\n\\n        swapableCount = {c: {c: 0 for c in initials} for c in initials}\\n        for name in ideas:\\n            for initial in initials:\\n                if initial + name[1:] not in ideas:\\n                    swapableCount[name[0]][initial] += 1\\n\\n        count = 0\\n        for c1 in initials:\\n            for c2 in initials:\\n                count += swapableCount[c1][c2]*swapableCount[c2][c1]\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        ideas = set(ideas)\\n        initials = set()\\n        for name in ideas:\\n            initials.add(name[0])\\n\\n        swapableCount = {c: {c: 0 for c in initials} for c in initials}\\n        for name in ideas:\\n            for initial in initials:\\n                if initial + name[1:] not in ideas:\\n                    swapableCount[name[0]][initial] += 1\\n\\n        count = 0\\n        for c1 in initials:\\n            for c2 in initials:\\n                count += swapableCount[c1][c2]*swapableCount[c2][c1]\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141362,
                "title": "java-count-the-replacements",
                "content": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        int[] firstLetters = new int[26];\\n        Set<String> wordSet = new HashSet<>();\\n        for (var idea : ideas) {\\n            wordSet.add(idea);\\n            firstLetters[idea.charAt(0) - \\'a\\']++;\\n        }\\n        \\n        long[][] replace = new long[26][26];\\n        \\n        for (var word : wordSet) {\\n            int c = word.charAt(0) - \\'a\\';\\n            for (int i = 0; i < 26; ++i) {\\n                if (c != i && firstLetters[i] > 0) {\\n                    String newWord = (char)(i + \\'a\\') + word.substring(1);\\n                    if (!wordSet.contains(newWord)) {\\n                        // from char c to char i\\n                        replace[c][i]++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long sum = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            for (int j = i + 1; j < 26; ++j) {\\n                sum += replace[i][j] * replace[j][i];\\n            }\\n        }\\n        \\n        return sum * 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        int[] firstLetters = new int[26];\\n        Set<String> wordSet = new HashSet<>();\\n        for (var idea : ideas) {\\n            wordSet.add(idea);\\n            firstLetters[idea.charAt(0) - \\'a\\']++;\\n        }\\n        \\n        long[][] replace = new long[26][26];\\n        \\n        for (var word : wordSet) {\\n            int c = word.charAt(0) - \\'a\\';\\n            for (int i = 0; i < 26; ++i) {\\n                if (c != i && firstLetters[i] > 0) {\\n                    String newWord = (char)(i + \\'a\\') + word.substring(1);\\n                    if (!wordSet.contains(newWord)) {\\n                        // from char c to char i\\n                        replace[c][i]++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long sum = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            for (int j = i + 1; j < 26; ++j) {\\n                sum += replace[i][j] * replace[j][i];\\n            }\\n        }\\n        \\n        return sum * 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141111,
                "title": "just-count-how-many-pairs",
                "content": "`a[i][j]`: can the `i^th` idea be replaced by a initial character `j`.\\n\\t`b[i][j]`: how many ideas have an initial character `i` and can be replaced by another character `j` \\n\\t\\nRuns in `O(n)` but cost over 2ms. There should be some optimization.\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        int n = ideas.length;\\n        boolean[][] a = new  boolean[n][26];\\n        int[][] b = new int[26][26];\\n        Set<String> set = new HashSet<>();\\n        for (String idea : ideas) {\\n            set.add(idea);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (!set.contains((char)(\\'a\\' + j) + ideas[i].substring(1))) {\\n                    a[i][j] = true;\\n                    b[ideas[i].charAt(0) - \\'a\\'][j] += 1;\\n                }\\n            }\\n        }\\n        /*\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                System.out.print(b[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }*/\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (a[i][j]) {\\n                    res += b[j][ideas[i].charAt(0) - \\'a\\'];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        int n = ideas.length;\\n        boolean[][] a = new  boolean[n][26];\\n        int[][] b = new int[26][26];\\n        Set<String> set = new HashSet<>();\\n        for (String idea : ideas) {\\n            set.add(idea);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (!set.contains((char)(\\'a\\' + j) + ideas[i].substring(1))) {\\n                    a[i][j] = true;\\n                    b[ideas[i].charAt(0) - \\'a\\'][j] += 1;\\n                }\\n            }\\n        }\\n        /*\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                System.out.print(b[i][j] + \" \");\\n            }\\n            System.out.println();\\n        }*/\\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 26; j++) {\\n                if (a[i][j]) {\\n                    res += b[j][ideas[i].charAt(0) - \\'a\\'];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141104,
                "title": "give-take-o-n-one-pass",
                "content": "For each idea we need to count the # of ideas that can take its first letter and give letters that wouldn\\'t form one that is already in `ideas` with the rest. In the reverse role, the idea always gives its first letter and can only take letters that wouldn\\'t form one that is already in `ideas` with the rest. In one-pass solution, each pair only gets counted once so we have to multiply by 2.\\n\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        s = set(ideas)\\n        d = {(give, take): 0 for give in string.ascii_lowercase for take in string.ascii_lowercase}\\n        ans = 0\\n        for idea in ideas:\\n            take = idea[0]\\n            for give in string.ascii_lowercase:\\n                if give + idea[1:] not in s:\\n                    ans += d[give, take] * 2\\n                    d[take, give] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        s = set(ideas)\\n        d = {(give, take): 0 for give in string.ascii_lowercase for take in string.ascii_lowercase}\\n        ans = 0\\n        for idea in ideas:\\n            take = idea[0]\\n            for give in string.ascii_lowercase:\\n                if give + idea[1:] not in s:\\n                    ans += d[give, take] * 2\\n                    d[take, give] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141052,
                "title": "python-o-n-proprocessing-solution",
                "content": "exchanging prefix is equivalent to exchanging suffix\\nsuffix cannot be exchagned if different initials share the same suffix\\n\\npreprocess:\\ninitial - dictionary, key: initial letter, value: set of distinct suffix of names\\nideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]\\ninitial = {\\'c\\': {\\'offee\\'}, \\'d\\': {\\'onuts\\'}, \\'t\\': {\\'offee\\', \\'ime\\'}}\\na, b are the initial letters of name pairs\\nnumber of names generated with initial a and b = len(initial[a] - initial[b]) * len(initial[b] - initial[a])\\n\\n```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        initial = defaultdict(lambda: set()) \\n        chars = [chr(ord(\\'a\\') + c) for c in range(26)]\\n        for s in ideas:\\n            initial[s[0]].add(s[1:]) \\n        res = 0\\n        for i in range(26):\\n            for j in range(i + 1, 26):\\n                a, b = chars[i], chars[j] \\n                res += len(initial[a] - initial[b]) * len(initial[b] - initial[a])\\n        return res * 2\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        initial = defaultdict(lambda: set()) \\n        chars = [chr(ord(\\'a\\') + c) for c in range(26)]\\n        for s in ideas:\\n            initial[s[0]].add(s[1:]) \\n        res = 0\\n        for i in range(26):\\n            for j in range(i + 1, 26):\\n                a, b = chars[i], chars[j] \\n                res += len(initial[a] - initial[b]) * len(initial[b] - initial[a])\\n        return res * 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141030,
                "title": "c-o-n-hash-map",
                "content": "```C++\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string, unordered_set<int>> notSwapWith;\\n        for(auto& i : ideas) {\\n            notSwapWith[i.substr(1)].insert(i[0]);\\n        }\\n\\n        long long res = 0;\\n        long long dp[26][26] = {};\\n\\n        for(auto& i : ideas) {\\n            string suf = i.substr(1);\\n            auto& us = notSwapWith[suf];\\n            for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                if(us.count(c)) continue;\\n                dp[c-\\'a\\'][i[0] - \\'a\\']++;\\n            }\\n        }\\n\\n        for(auto& i : ideas) {\\n            string suf = i.substr(1);\\n            auto& us = notSwapWith[suf];\\n            for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                if(us.count(c)) continue;\\n                res += dp[i[0]-\\'a\\'][c-\\'a\\'];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string, unordered_set<int>> notSwapWith;\\n        for(auto& i : ideas) {\\n            notSwapWith[i.substr(1)].insert(i[0]);\\n        }\\n\\n        long long res = 0;\\n        long long dp[26][26] = {};\\n\\n        for(auto& i : ideas) {\\n            string suf = i.substr(1);\\n            auto& us = notSwapWith[suf];\\n            for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                if(us.count(c)) continue;\\n                dp[c-\\'a\\'][i[0] - \\'a\\']++;\\n            }\\n        }\\n\\n        for(auto& i : ideas) {\\n            string suf = i.substr(1);\\n            auto& us = notSwapWith[suf];\\n            for(char c = \\'a\\'; c <= \\'z\\'; c++) {\\n                if(us.count(c)) continue;\\n                res += dp[i[0]-\\'a\\'][c-\\'a\\'];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141009,
                "title": "compress-and-then-count-c-o-n",
                "content": "Complexity is O(n * 26) = O(n)\\n\\n// replace[i][j] = how many strings in starts_with[i] that after replacing first character with j does not belong to all\\n```c++\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        vector<unordered_map<string, int>> starts_with(26);\\n        unordered_set<string> all;\\n        for (string& idea: ideas) {\\n            starts_with[idea[0] - \\'a\\'][idea] += 1;\\n            all.insert(idea);\\n        }\\n        \\n\\t\\t// replace[i][j] = how many strings in starts_with[i] that after replacing first character with j does not belong to all\\n        vector<vector<ll>> replace(26, vector<ll>(26, 0));\\n        for (int i = 0; i < 26; i++) {   \\n            for (auto [s, f1]: starts_with[i]) {\\n                string a = s;\\n                for (int j = 0; j < 26; j++) {\\n                    a[0] = \\'a\\' + j;\\n                    if (i != j && all.find(a) == all.end()) {\\n                        replace[i][j] += f1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                ans += replace[i][j] * replace[j][i] * 2;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long distinctNames(vector<string>& ideas) {\\n        vector<unordered_map<string, int>> starts_with(26);\\n        unordered_set<string> all;\\n        for (string& idea: ideas) {\\n            starts_with[idea[0] - \\'a\\'][idea] += 1;\\n            all.insert(idea);\\n        }\\n        \\n\\t\\t// replace[i][j] = how many strings in starts_with[i] that after replacing first character with j does not belong to all\\n        vector<vector<ll>> replace(26, vector<ll>(26, 0));\\n        for (int i = 0; i < 26; i++) {   \\n            for (auto [s, f1]: starts_with[i]) {\\n                string a = s;\\n                for (int j = 0; j < 26; j++) {\\n                    a[0] = \\'a\\' + j;\\n                    if (i != j && all.find(a) == all.end()) {\\n                        replace[i][j] += f1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        for (int i = 0; i < 26; i++) {\\n            for (int j = i + 1; j < 26; j++) {\\n                ans += replace[i][j] * replace[j][i] * 2;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140974,
                "title": "simple-efficient-solution",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef vector<ll> vi;\\n    typedef pair<ll, ll> pi;\\n#define endl \\'\\\\n\\'\\n    static const ll mod = 1e9;\\npublic:\\n    long long distinctNames(vector<string>& v) {\\n        ll sz = v.size();\\n        unordered_set<string>ust(v.begin(), v.end());\\n        vector<vi>pre(26, vi(26, 0));\\n        for (string& s : v) {\\n            char first = s.front();\\n            for (char ch = \\'a\\';ch <= \\'z\\';++ch) {\\n                s.front() = ch;\\n                if (ust.find(s) == ust.end())\\n                    ++pre[first - \\'a\\'][ch - \\'a\\'];\\n            }\\n            s.front() = first;\\n        }\\n        ll res = 0;\\n        for (string& s : v) {\\n            char first = s.front();\\n            for (char ch = \\'a\\';ch <= \\'z\\';++ch) {\\n                s.front() = ch;\\n                if (ust.find(s) == ust.end())\\n                    res += (pre[ch - \\'a\\'][first - \\'a\\']);\\n            }\\n            s.front() = first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef long double ld;\\n    typedef vector<ll> vi;\\n    typedef pair<ll, ll> pi;\\n#define endl \\'\\\\n\\'\\n    static const ll mod = 1e9;\\npublic:\\n    long long distinctNames(vector<string>& v) {\\n        ll sz = v.size();\\n        unordered_set<string>ust(v.begin(), v.end());\\n        vector<vi>pre(26, vi(26, 0));\\n        for (string& s : v) {\\n            char first = s.front();\\n            for (char ch = \\'a\\';ch <= \\'z\\';++ch) {\\n                s.front() = ch;\\n                if (ust.find(s) == ust.end())\\n                    ++pre[first - \\'a\\'][ch - \\'a\\'];\\n            }\\n            s.front() = first;\\n        }\\n        ll res = 0;\\n        for (string& s : v) {\\n            char first = s.front();\\n            for (char ch = \\'a\\';ch <= \\'z\\';++ch) {\\n                s.front() = ch;\\n                if (ust.find(s) == ust.end())\\n                    res += (pre[ch - \\'a\\'][first - \\'a\\']);\\n            }\\n            s.front() = first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2140961,
                "title": "python-3-clean-defaultdict-set",
                "content": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        ideas = set(ideas)\\n        d = defaultdict(set)\\n\\t\\t# first letter as key\\n        for word in ideas:\\n            d[word[0]].add(word[1:])\\n        ans = 0\\n        for fl in d:\\n            for sl in d:\\n                if fl != sl:\\n\\t\\t\\t\\t\\t# do set difference so only new words will be counted\\n                    ans += len(d[fl]-d[sl]) * len(d[sl]-d[fl])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        ideas = set(ideas)\\n        d = defaultdict(set)\\n\\t\\t# first letter as key\\n        for word in ideas:\\n            d[word[0]].add(word[1:])\\n        ans = 0\\n        for fl in d:\\n            for sl in d:\\n                if fl != sl:\\n\\t\\t\\t\\t\\t# do set difference so only new words will be counted\\n                    ans += len(d[fl]-d[sl]) * len(d[sl]-d[fl])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083657,
                "title": "c-with-proper-explanation-comments-using-hashmap-set-prefix-suffix-map",
                "content": "# Intuition\\nThe idea is to split the string idea into two parts - one is the first letter i.e. idea[0] and idea.substr(1) (means the rest of the string).\\nWe know, that we cannot make pairs of string on the basis of -\\n1. If first letter of both the strings are same\\n2. If first letter is not same BUT there exists a suffix of corresponding first letter of first string as a suffix of second string. (I know this is quite complicated to understand). For example ideas = [\"coffee\", \"toffee\", \"tonuts\"]; So we cannot pair \"coffee\" and \"tonuts\" even if their first letter is different, this is because suffix of \"coffee\" as a first letter \\'a\\' is present as a suffix of \"toffee\" as a first letter \\'t\\'.\\n\\nSo while making pairs of two different first characters we have to make sure that common suffixes of both the letters SHOULD NOT BE INCLUDED.\\n\\n# Approach\\nThe best Data structure to do the same is to use HashMap (unordered_map) of type <char, set<string>> where the key will be first letter of string and value is a set of string which has all the suffixes of those strings whose first letter is the corresponding key.\\n\\nAfter doing so, we make pairs of characters using two nested for loops and check (may be using a function) that how many pairing are possible. This is done by finding number of common suffixes between two sets and multiplying the remaining numbers of suffixes.\\n\\n# Complexity\\n- Time complexity:\\nO(26x26xnlogn)\\n26*26 -> Two nested for loops for characters.\\nnlogn -> for searching common elements in set and finding number of pairs.\\n\\n- Space complexity:\\nO(n) -> We are storing a unordered map of strings only with no repeatitions.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/* this function calculates the number of valid pairs between two sets\\nby calculating common elements and multiplying rest of them. */\\n    long long solveForTwoSets(set<string> &s1, set<string> &s2) {\\n        int c=0;\\n        for(auto &x:s1){\\n            if(s2.find(x)!=s2.end()) {\\n                c++;\\n            }\\n        }\\n        long long x = (long long)(s1.size()-c);\\n        long long y = (long long)(s2.size()-c);\\n        return x*y;\\n    }\\n\\n    long long distinctNames(vector<string>& ideas) {\\n// creating unordered_map with key as first letter and suffix as value\\n        unordered_map<char, set<string>> m;\\n        for(int i=0;i<ideas.size();i++){\\n            m[ideas[i][0]].insert(ideas[i].substr(1));\\n        }\\n\\n// for each character pair find the valid pairing (ignoring same chars)\\n        long long ans = 0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            for(char j=\\'a\\';j<=\\'z\\';j++){\\n                if(i == j) continue;\\n                ans += solveForTwoSets(m[i], m[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/* this function calculates the number of valid pairs between two sets\\nby calculating common elements and multiplying rest of them. */\\n    long long solveForTwoSets(set<string> &s1, set<string> &s2) {\\n        int c=0;\\n        for(auto &x:s1){\\n            if(s2.find(x)!=s2.end()) {\\n                c++;\\n            }\\n        }\\n        long long x = (long long)(s1.size()-c);\\n        long long y = (long long)(s2.size()-c);\\n        return x*y;\\n    }\\n\\n    long long distinctNames(vector<string>& ideas) {\\n// creating unordered_map with key as first letter and suffix as value\\n        unordered_map<char, set<string>> m;\\n        for(int i=0;i<ideas.size();i++){\\n            m[ideas[i][0]].insert(ideas[i].substr(1));\\n        }\\n\\n// for each character pair find the valid pairing (ignoring same chars)\\n        long long ans = 0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            for(char j=\\'a\\';j<=\\'z\\';j++){\\n                if(i == j) continue;\\n                ans += solveForTwoSets(m[i], m[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054863,
                "title": "c-solution-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    public long DistinctNames(string[] ideas) {\\n        HashSet<string>[] arr = new HashSet<string>[26];\\n        for(int i = 0;i < ideas.Length;i++){\\n            int idx = ideas[i][0] - \\'a\\';\\n            if(arr[idx] == null) arr[idx] = new HashSet<string>();\\n            arr[idx].Add(ideas[i].Substring(1));\\n        }\\n        long res = 0;\\n        for(int i = 0;i < 25;i++){\\n            if(arr[i] == null) continue;\\n            for(int j = i + 1;j < 26;j++){\\n                // find intersect between two hashset\\n                // intersect between two sets is part of smallest one\\n                if(arr[j] == null) continue;\\n                HashSet<string> smallest = arr[i], largest = arr[j];\\n                if(smallest.Count > largest.Count)\\n                    (smallest,largest) = (largest,smallest);\\n                int intersect = 0;\\n                foreach(var w in smallest)\\n                    if(largest.Contains(w)) intersect++;\\n                res+= 2 * (smallest.Count - intersect) * (largest.Count - intersect);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public long DistinctNames(string[] ideas) {\\n        HashSet<string>[] arr = new HashSet<string>[26];\\n        for(int i = 0;i < ideas.Length;i++){\\n            int idx = ideas[i][0] - \\'a\\';\\n            if(arr[idx] == null) arr[idx] = new HashSet<string>();\\n            arr[idx].Add(ideas[i].Substring(1));\\n        }\\n        long res = 0;\\n        for(int i = 0;i < 25;i++){\\n            if(arr[i] == null) continue;\\n            for(int j = i + 1;j < 26;j++){\\n                // find intersect between two hashset\\n                // intersect between two sets is part of smallest one\\n                if(arr[j] == null) continue;\\n                HashSet<string> smallest = arr[i], largest = arr[j];\\n                if(smallest.Count > largest.Count)\\n                    (smallest,largest) = (largest,smallest);\\n                int intersect = 0;\\n                foreach(var w in smallest)\\n                    if(largest.Contains(w)) intersect++;\\n                res+= 2 * (smallest.Count - intersect) * (largest.Count - intersect);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905181,
                "title": "simple-java-solution-using-hashmap-and-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->The goal of this problem is to count the number of distinct pairs of words that start with different characters in a given array of ideas. To achieve this, the code first groups the words based on their starting characters and then calculates the distinct pairs using the grouped information.\\n\\n# Approach\\n1. Word Grouping:\\nThe code starts by creating a HashMap<Character, HashSet<String>> named map. This hashmap will be used to group words by their starting characters. For each idea in the input array, the code extracts the first character and adds the remaining part of the word to the corresponding HashSet in the map.\\n\\n2. Calculating Distinct Pairs:\\n- After grouping the words by starting characters, the code proceeds to calculate the distinct pairs of words that start with different characters.\\n- The outer loop iterates through each character c1 in the map.\\n- The inner loop iterates through each character c2 in the map.\\n- If c1 is equal to c2, the code continues to the next iteration to avoid counting pairs with the same starting character.\\n- For each pair of characters (c1 and c2), the code calculates the number of words that are common between the sets of words associated with c1 and c2. This is done by comparing the words in the HashSet of c1 with the HashSet of c2.\\n- The code then calculates the number of distinct words for each character. This is done by subtracting the count of common words from the total number of words for that character.\\n- The number of distinct pairs of words that start with different characters is calculated by multiplying the counts of distinct words for c1 and c2.\\n- The result of each pair calculation is added to the res variable.\\n\\n3. Final Result:\\nAfter iterating through all possible character pairs, the code returns the total count of distinct pairs stored in the res variable.\\n\\n# Example:\\n\\nSuppose ideas contains the following array: [\"apple\", \"banana\", \"berry\", \"cherry\"].\\n\\nThe map will be:\\n```\\n\\'a\\': {\"pple\"}\\n\\'b\\': {\"anana\", \"erry\"}\\n\\'c\\': {\"herry\"}\\n```\\nFor each character pair, the code calculates the distinct pairs:\\n```\\n(\\'a\\', \\'b\\'): Distinct pairs = 1 * 2 = 2\\n(\\'a\\', \\'c\\'): Distinct pairs = 1 * 1 = 1\\n(\\'b\\', \\'a\\'): Distinct pairs = 1 * 1 = 1\\n(\\'b\\', \\'c\\'): Distinct pairs = 1 * 1 = 1\\n(\\'c\\', \\'a\\'): Distinct pairs = 1 * 1 = 1\\n(\\'c\\', \\'b\\'): Distinct pairs = 1 * 1 = 1\\n```\\nThe final result is 2 + 1 + 1 + 1 + 1 + 1 = 7.\\n\\nTherefore, the output of the code for this example would be 7.\\n\\nThe code efficiently groups the words and calculates the number of distinct pairs using the approach outlined above.\\n\\n# Complexity\\n- Time complexity: $$O(N + 26^2 * M)$$\\nwhere N is the total number of characters in all the ideas and M is the average number of words for a character in the map.\\nWord Grouping:\\n\\nIterating through each idea in the ideas array takes O(N), where N is the total number of characters in all the ideas.\\nAdding words to the HashMap takes O(1) on average, assuming an evenly distributed hash function and good resizing policy.\\n\\nCalculating Distinct Pairs:\\n\\nThe outer loop iterates through each character in the map. Since there are 26 characters (\\'a\\' to \\'z\\'), this loop has a constant time complexity of O(26).\\nThe inner loop also iterates through each character in the map. Again, the maximum number of iterations is O(26).\\nThe nested loop that compares words in the HashSet of c1 with the HashSet of c2 runs in O(M), where M is the average number of words for a character in the map.\\nFinal Result:\\n\\nAfter the nested loops, the code returns the result in constant time.\\n\\n- Space complexity: $$ O(N)$$\\n\\nWord Grouping:\\n\\nThe space used for the map hashmap is proportional to the number of distinct characters. In the worst case, this can be O(26), which simplifies to O(1).\\n\\nCalculating Distinct Pairs:\\n\\nThe space used by the sets for each character in the map is proportional to the number of words for that character. In the worst case, this can be O(N), where N is the total number of characters in all the ideas.\\n\\nOther Variables:\\n\\nThe res variable, additional loop counters, and temporary variables used for calculations consume a constant amount of space.\\nOverall, the space complexity of the code is O(1) for the map and O(N) for the sets, which simplifies to O(N) since the space used by the map is constant in relation to the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashMap<Character, HashSet<String>> map = new HashMap<>();\\n        for (String word : ideas) {\\n            char c = word.charAt(0);\\n            if (!map.containsKey(c)) {\\n                map.put(c, new HashSet<String>());\\n            }\\n            map.get(c).add(word.substring(1));\\n        }\\n        long res = 0;\\n        for (char c1 : map.keySet()) {\\n            for (char c2 : map.keySet()) {\\n                if (c1 == c2) {\\n                    continue;\\n                }\\n                long same = 0;\\n                for (String sub1 : map.get(c1)) {\\n                    if (map.get(c2).contains(sub1)) {\\n                        same++;\\n                    }\\n                }\\n                long distinct1 = map.get(c1).size() - same;\\n                long distinct2 = map.get(c2).size() - same;\\n                res += distinct1 * distinct2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\'a\\': {\"pple\"}\\n\\'b\\': {\"anana\", \"erry\"}\\n\\'c\\': {\"herry\"}\\n```\n```\\n(\\'a\\', \\'b\\'): Distinct pairs = 1 * 2 = 2\\n(\\'a\\', \\'c\\'): Distinct pairs = 1 * 1 = 1\\n(\\'b\\', \\'a\\'): Distinct pairs = 1 * 1 = 1\\n(\\'b\\', \\'c\\'): Distinct pairs = 1 * 1 = 1\\n(\\'c\\', \\'a\\'): Distinct pairs = 1 * 1 = 1\\n(\\'c\\', \\'b\\'): Distinct pairs = 1 * 1 = 1\\n```\n```\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashMap<Character, HashSet<String>> map = new HashMap<>();\\n        for (String word : ideas) {\\n            char c = word.charAt(0);\\n            if (!map.containsKey(c)) {\\n                map.put(c, new HashSet<String>());\\n            }\\n            map.get(c).add(word.substring(1));\\n        }\\n        long res = 0;\\n        for (char c1 : map.keySet()) {\\n            for (char c2 : map.keySet()) {\\n                if (c1 == c2) {\\n                    continue;\\n                }\\n                long same = 0;\\n                for (String sub1 : map.get(c1)) {\\n                    if (map.get(c2).contains(sub1)) {\\n                        same++;\\n                    }\\n                }\\n                long distinct1 = map.get(c1).size() - same;\\n                long distinct2 = map.get(c2).size() - same;\\n                res += distinct1 * distinct2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1793683,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793703,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793898,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793800,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793682,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1794247,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793720,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793770,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1794415,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1794655,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793683,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793703,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793898,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793800,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793682,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1794247,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793720,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793770,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1794415,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1794655,
                "content": [
                    {
                        "username": "ptk_trindade",
                        "content": "Me: \"This problem is easy, why is being considered `hard`\"?\nLC: \"Time limit exceeded\"\nAlso me: \"Oh, now I understand why\""
                    },
                    {
                        "username": "davejay1999",
                        "content": "exactly"
                    },
                    {
                        "username": "Sahul_Raj",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "TLE be like : Wake Up To Reality, Nothing Ever Goes As Planned In This Accursed World......."
                    },
                    {
                        "username": "santanusen",
                        "content": "February is starting to get hotter!"
                    },
                    {
                        "username": "arajshow",
                        "content": "This is Programmer\\'s life"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "TLE : \"My sweet summer child\""
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "Le TLE : Hold my beer !!"
                    },
                    {
                        "username": "spes6608",
                        "content": "damn  it\\'s actually me in 30 minutes ago :cry"
                    },
                    {
                        "username": "AlecLC",
                        "content": "Me: wow, I'm really smart!\nMe, 10 seconds later:  dammit"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/1.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/2.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/3.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/4.png)\n![x](https://leetcode.com/problems/naming-a-company/solutions/3081799/Figures/2306/5.png)"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Super!, thanks"
                    },
                    {
                        "username": "mhdsuhail172",
                        "content": "Amazing explanation !"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "PRO solution"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Thanks, this helped"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This is how I am gonna name my startup"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "[@jga111](/jga111)  Yhank Tou!"
                    },
                    {
                        "username": "jga111",
                        "content": "Oice Nne!"
                    },
                    {
                        "username": "Vaibhav_69",
                        "content": "Leetcode rule: If the question seems easy, just make sure it goes TLE one way or another"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Finally, break from sliding window...."
                    },
                    {
                        "username": "Movsar",
                        "content": "**ideas = [\"coffee\",\"donuts\",\"time\",\"toffee\"]**\n\n```\n{\n  c: {\"offee\"},\n  d: {\"onuts\"},\n  t: {\"ime\", \"offee\"}\n}\n```\n\nIf first letters and suffixes are the same for 2 words, we cant make valid name. Example: `time and toffee (first letters)` OR `coffee and toffee (suffix)`"
                    },
                    {
                        "username": "ZapTap",
                        "content": "[@Ariel6Du](/Ariel6Du) You can pick the pair of first letters, count stems from the first letter that aren\\'t also in the second, then vice versa."
                    },
                    {
                        "username": "Ariel6Du",
                        "content": "time and coffee is an invalid combination. How do you deal with this situation?"
                    },
                    {
                        "username": "ritiksharma8427",
                        "content": "This was pro tip :<"
                    },
                    {
                        "username": "rock1207",
                        "content": "[@Vinaygoswami321](/Vinaygoswami321) arr[i].substr(1);"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "how to select the suffix for comparing them"
                    },
                    {
                        "username": "kanishk--",
                        "content": "You just solved the whole question."
                    },
                    {
                        "username": "DexterHines",
                        "content": "What a weird question lmao"
                    },
                    {
                        "username": "rickybalboa",
                        "content": "Can be rephrased as simply a list of tuples of arbitrary elements"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Fr lmao"
                    },
                    {
                        "username": "naresh-khatri",
                        "content": "When TLE slaps hard :("
                    },
                    {
                        "username": "morningstar1",
                        "content": "I too also tried the obviously naive brute-force solution first. Honestly though, I feel like it\\'s a good practice to always attempt that solution first anyway, in many (tho not all) situations irl, it\\'s probably adequate."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "him_Sarma619",
                        "content": "TLE : Ok so yeah, where were we?"
                    },
                    {
                        "username": "sathvikraj",
                        "content": "people at 74th test case\\n\"ARREY EPPURAAAA\""
                    }
                ]
            },
            {
                "id": 1793717,
                "content": [
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "No."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@billy_homeless](/billy_homeless) Nes"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "Yes."
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "My mind: \"Reads this question: It seems easy then why rated hard\"\\nMy heart: \"Don\\'t trust them, it gonna hurt\"\\nLC: TLE\\naaaaaaaaaaa"
                    },
                    {
                        "username": "maltarouti",
                        "content": "CeetLode"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "Time Limit Exceeded -  89 / 89 test case passed\nwhat am i supposed to do ??"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "Write a more efficient solution?"
                    },
                    {
                        "username": "KhacLong",
                        "content": "i think this problem need many skills and experiences about set to solve, it took me 2 hours but i was failed to solve it"
                    },
                    {
                        "username": "radhika_8",
                        "content": "can anyone explain me this \\nHashSet<String>[] initialGroup = new HashSet[26];\\nis it an set or array?"
                    },
                    {
                        "username": "radhika_8",
                        "content": "[@kbbhatt61](/kbbhatt61) thanks;)\\n"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "HashSet is a class so, this statement of yours has just declared an object of that class. It\\'s neither an array nor a set.\\n\\nMore specifically, what you\\'ve done is called raw type declaration. It will not have any hashset methods. It\\'s still used just for the compatibility (backwards) with older versions of java which don\\'t have generics feature.\\n\\nYou must use generic type using diamond operator <> to enable functionalities of hashset including add, remove, etc.\\n\\nBtw, thanks for this comment. I didn\\'t know this concept. I researched it myself before replying. :)"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "50000, so many ideas, they must be clever!"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "Weird leetcode BUG\\nDoes anyone also faced same issue when trying bit masking solution...??\\n\\nProblem-Accepted for same testcase in console but getting TLE after submission.\\n\\n\\nTC=\\n[\"j\",\"t\",\"fmucd\",\"liantvj\",\"sgizj\",\"qjkqmnefo\",\"g\",\"zaa\",\"epw\",\"fz\",\"ycad\",\"oocqnz\",\"bwowse\",\"bcnealx\",\"imlwxoxzml\",\"crmahpv\",\"vh\",\"qfwyd\",\"dycxopdrzb\",\"hvbje\",\"f\",\"qwowse\",\"lnwgxmqdc\",\"k\",\"fmffskrv\",\"bmlwxoxzml\",\"iffrcpdsu\",\"xpqodjcvri\",\"cmsyrkrrm\",\"unb\",\"ln\",\"hmffskrv\",\"bihbm\",\"fv\",\"eqwg\",\"p\",\"vnpooqdpe\",\"okja\",\"lmffskrv\",\"r\",\"pnwgxmqdc\",\"gpyamphhda\",\"azklwrs\",\"ejwuuqz\",\"rmxhrnzz\",\"gggwj\",\"qh\",\"siantvj\",\"pcad\",\"y\",\"nteqr\",\"mi\",\"ri\",\"jqwg\",\"fnpooqdpe\",\"ukqhjnk\",\"tyaastc\",\"xmsyrkrrm\",\"l\",\"ypmpilxnl\",\"lzf\",\"nkja\",\"xiantvj\",\"fvbje\",\"ooltwf\",\"fycxopdrzb\",\"gi\",\"bmffskrv\",\"bnihnwsx\",\"epci\",\"awowse\",\"tokjknsyk\",\"owan\",\"vz\",\"qd\",\"ng\",\"goebwzhefq\",\"xafrsm\",\"sjyfskc\",\"bfr\",\"nwan\",\"mjkj\",\"ujlr\",\"mrmahpv\"]\\n\\n\\nsame for other test cases>40 out of 80\\nMy solution-\\nhttps://leetcode.com/problems/naming-a-company/submissions/894707979/\\n\\n\\n"
                    },
                    {
                        "username": "shivam-singh",
                        "content": "Passed all test cases 89/89.\\nStill getting TLE, Why? "
                    },
                    {
                        "username": "suckpf98690",
                        "content": "Is it possible to use pure C code without TLE?"
                    },
                    {
                        "username": "6fitzy",
                        "content": "I\\'m not sure that it is. I haven\\'t gotten past TLE either"
                    }
                ]
            },
            {
                "id": 1794477,
                "content": [
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "No."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@billy_homeless](/billy_homeless) Nes"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "Yes."
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "My mind: \"Reads this question: It seems easy then why rated hard\"\\nMy heart: \"Don\\'t trust them, it gonna hurt\"\\nLC: TLE\\naaaaaaaaaaa"
                    },
                    {
                        "username": "maltarouti",
                        "content": "CeetLode"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "Time Limit Exceeded -  89 / 89 test case passed\nwhat am i supposed to do ??"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "Write a more efficient solution?"
                    },
                    {
                        "username": "KhacLong",
                        "content": "i think this problem need many skills and experiences about set to solve, it took me 2 hours but i was failed to solve it"
                    },
                    {
                        "username": "radhika_8",
                        "content": "can anyone explain me this \\nHashSet<String>[] initialGroup = new HashSet[26];\\nis it an set or array?"
                    },
                    {
                        "username": "radhika_8",
                        "content": "[@kbbhatt61](/kbbhatt61) thanks;)\\n"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "HashSet is a class so, this statement of yours has just declared an object of that class. It\\'s neither an array nor a set.\\n\\nMore specifically, what you\\'ve done is called raw type declaration. It will not have any hashset methods. It\\'s still used just for the compatibility (backwards) with older versions of java which don\\'t have generics feature.\\n\\nYou must use generic type using diamond operator <> to enable functionalities of hashset including add, remove, etc.\\n\\nBtw, thanks for this comment. I didn\\'t know this concept. I researched it myself before replying. :)"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "50000, so many ideas, they must be clever!"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "Weird leetcode BUG\\nDoes anyone also faced same issue when trying bit masking solution...??\\n\\nProblem-Accepted for same testcase in console but getting TLE after submission.\\n\\n\\nTC=\\n[\"j\",\"t\",\"fmucd\",\"liantvj\",\"sgizj\",\"qjkqmnefo\",\"g\",\"zaa\",\"epw\",\"fz\",\"ycad\",\"oocqnz\",\"bwowse\",\"bcnealx\",\"imlwxoxzml\",\"crmahpv\",\"vh\",\"qfwyd\",\"dycxopdrzb\",\"hvbje\",\"f\",\"qwowse\",\"lnwgxmqdc\",\"k\",\"fmffskrv\",\"bmlwxoxzml\",\"iffrcpdsu\",\"xpqodjcvri\",\"cmsyrkrrm\",\"unb\",\"ln\",\"hmffskrv\",\"bihbm\",\"fv\",\"eqwg\",\"p\",\"vnpooqdpe\",\"okja\",\"lmffskrv\",\"r\",\"pnwgxmqdc\",\"gpyamphhda\",\"azklwrs\",\"ejwuuqz\",\"rmxhrnzz\",\"gggwj\",\"qh\",\"siantvj\",\"pcad\",\"y\",\"nteqr\",\"mi\",\"ri\",\"jqwg\",\"fnpooqdpe\",\"ukqhjnk\",\"tyaastc\",\"xmsyrkrrm\",\"l\",\"ypmpilxnl\",\"lzf\",\"nkja\",\"xiantvj\",\"fvbje\",\"ooltwf\",\"fycxopdrzb\",\"gi\",\"bmffskrv\",\"bnihnwsx\",\"epci\",\"awowse\",\"tokjknsyk\",\"owan\",\"vz\",\"qd\",\"ng\",\"goebwzhefq\",\"xafrsm\",\"sjyfskc\",\"bfr\",\"nwan\",\"mjkj\",\"ujlr\",\"mrmahpv\"]\\n\\n\\nsame for other test cases>40 out of 80\\nMy solution-\\nhttps://leetcode.com/problems/naming-a-company/submissions/894707979/\\n\\n\\n"
                    },
                    {
                        "username": "shivam-singh",
                        "content": "Passed all test cases 89/89.\\nStill getting TLE, Why? "
                    },
                    {
                        "username": "suckpf98690",
                        "content": "Is it possible to use pure C code without TLE?"
                    },
                    {
                        "username": "6fitzy",
                        "content": "I\\'m not sure that it is. I haven\\'t gotten past TLE either"
                    }
                ]
            },
            {
                "id": 1794905,
                "content": [
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "No."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@billy_homeless](/billy_homeless) Nes"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "Yes."
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "My mind: \"Reads this question: It seems easy then why rated hard\"\\nMy heart: \"Don\\'t trust them, it gonna hurt\"\\nLC: TLE\\naaaaaaaaaaa"
                    },
                    {
                        "username": "maltarouti",
                        "content": "CeetLode"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "Time Limit Exceeded -  89 / 89 test case passed\nwhat am i supposed to do ??"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "Write a more efficient solution?"
                    },
                    {
                        "username": "KhacLong",
                        "content": "i think this problem need many skills and experiences about set to solve, it took me 2 hours but i was failed to solve it"
                    },
                    {
                        "username": "radhika_8",
                        "content": "can anyone explain me this \\nHashSet<String>[] initialGroup = new HashSet[26];\\nis it an set or array?"
                    },
                    {
                        "username": "radhika_8",
                        "content": "[@kbbhatt61](/kbbhatt61) thanks;)\\n"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "HashSet is a class so, this statement of yours has just declared an object of that class. It\\'s neither an array nor a set.\\n\\nMore specifically, what you\\'ve done is called raw type declaration. It will not have any hashset methods. It\\'s still used just for the compatibility (backwards) with older versions of java which don\\'t have generics feature.\\n\\nYou must use generic type using diamond operator <> to enable functionalities of hashset including add, remove, etc.\\n\\nBtw, thanks for this comment. I didn\\'t know this concept. I researched it myself before replying. :)"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "50000, so many ideas, they must be clever!"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "Weird leetcode BUG\\nDoes anyone also faced same issue when trying bit masking solution...??\\n\\nProblem-Accepted for same testcase in console but getting TLE after submission.\\n\\n\\nTC=\\n[\"j\",\"t\",\"fmucd\",\"liantvj\",\"sgizj\",\"qjkqmnefo\",\"g\",\"zaa\",\"epw\",\"fz\",\"ycad\",\"oocqnz\",\"bwowse\",\"bcnealx\",\"imlwxoxzml\",\"crmahpv\",\"vh\",\"qfwyd\",\"dycxopdrzb\",\"hvbje\",\"f\",\"qwowse\",\"lnwgxmqdc\",\"k\",\"fmffskrv\",\"bmlwxoxzml\",\"iffrcpdsu\",\"xpqodjcvri\",\"cmsyrkrrm\",\"unb\",\"ln\",\"hmffskrv\",\"bihbm\",\"fv\",\"eqwg\",\"p\",\"vnpooqdpe\",\"okja\",\"lmffskrv\",\"r\",\"pnwgxmqdc\",\"gpyamphhda\",\"azklwrs\",\"ejwuuqz\",\"rmxhrnzz\",\"gggwj\",\"qh\",\"siantvj\",\"pcad\",\"y\",\"nteqr\",\"mi\",\"ri\",\"jqwg\",\"fnpooqdpe\",\"ukqhjnk\",\"tyaastc\",\"xmsyrkrrm\",\"l\",\"ypmpilxnl\",\"lzf\",\"nkja\",\"xiantvj\",\"fvbje\",\"ooltwf\",\"fycxopdrzb\",\"gi\",\"bmffskrv\",\"bnihnwsx\",\"epci\",\"awowse\",\"tokjknsyk\",\"owan\",\"vz\",\"qd\",\"ng\",\"goebwzhefq\",\"xafrsm\",\"sjyfskc\",\"bfr\",\"nwan\",\"mjkj\",\"ujlr\",\"mrmahpv\"]\\n\\n\\nsame for other test cases>40 out of 80\\nMy solution-\\nhttps://leetcode.com/problems/naming-a-company/submissions/894707979/\\n\\n\\n"
                    },
                    {
                        "username": "shivam-singh",
                        "content": "Passed all test cases 89/89.\\nStill getting TLE, Why? "
                    },
                    {
                        "username": "suckpf98690",
                        "content": "Is it possible to use pure C code without TLE?"
                    },
                    {
                        "username": "6fitzy",
                        "content": "I\\'m not sure that it is. I haven\\'t gotten past TLE either"
                    }
                ]
            },
            {
                "id": 1794503,
                "content": [
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "No."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@billy_homeless](/billy_homeless) Nes"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "Yes."
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "My mind: \"Reads this question: It seems easy then why rated hard\"\\nMy heart: \"Don\\'t trust them, it gonna hurt\"\\nLC: TLE\\naaaaaaaaaaa"
                    },
                    {
                        "username": "maltarouti",
                        "content": "CeetLode"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "Time Limit Exceeded -  89 / 89 test case passed\nwhat am i supposed to do ??"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "Write a more efficient solution?"
                    },
                    {
                        "username": "KhacLong",
                        "content": "i think this problem need many skills and experiences about set to solve, it took me 2 hours but i was failed to solve it"
                    },
                    {
                        "username": "radhika_8",
                        "content": "can anyone explain me this \\nHashSet<String>[] initialGroup = new HashSet[26];\\nis it an set or array?"
                    },
                    {
                        "username": "radhika_8",
                        "content": "[@kbbhatt61](/kbbhatt61) thanks;)\\n"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "HashSet is a class so, this statement of yours has just declared an object of that class. It\\'s neither an array nor a set.\\n\\nMore specifically, what you\\'ve done is called raw type declaration. It will not have any hashset methods. It\\'s still used just for the compatibility (backwards) with older versions of java which don\\'t have generics feature.\\n\\nYou must use generic type using diamond operator <> to enable functionalities of hashset including add, remove, etc.\\n\\nBtw, thanks for this comment. I didn\\'t know this concept. I researched it myself before replying. :)"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "50000, so many ideas, they must be clever!"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "Weird leetcode BUG\\nDoes anyone also faced same issue when trying bit masking solution...??\\n\\nProblem-Accepted for same testcase in console but getting TLE after submission.\\n\\n\\nTC=\\n[\"j\",\"t\",\"fmucd\",\"liantvj\",\"sgizj\",\"qjkqmnefo\",\"g\",\"zaa\",\"epw\",\"fz\",\"ycad\",\"oocqnz\",\"bwowse\",\"bcnealx\",\"imlwxoxzml\",\"crmahpv\",\"vh\",\"qfwyd\",\"dycxopdrzb\",\"hvbje\",\"f\",\"qwowse\",\"lnwgxmqdc\",\"k\",\"fmffskrv\",\"bmlwxoxzml\",\"iffrcpdsu\",\"xpqodjcvri\",\"cmsyrkrrm\",\"unb\",\"ln\",\"hmffskrv\",\"bihbm\",\"fv\",\"eqwg\",\"p\",\"vnpooqdpe\",\"okja\",\"lmffskrv\",\"r\",\"pnwgxmqdc\",\"gpyamphhda\",\"azklwrs\",\"ejwuuqz\",\"rmxhrnzz\",\"gggwj\",\"qh\",\"siantvj\",\"pcad\",\"y\",\"nteqr\",\"mi\",\"ri\",\"jqwg\",\"fnpooqdpe\",\"ukqhjnk\",\"tyaastc\",\"xmsyrkrrm\",\"l\",\"ypmpilxnl\",\"lzf\",\"nkja\",\"xiantvj\",\"fvbje\",\"ooltwf\",\"fycxopdrzb\",\"gi\",\"bmffskrv\",\"bnihnwsx\",\"epci\",\"awowse\",\"tokjknsyk\",\"owan\",\"vz\",\"qd\",\"ng\",\"goebwzhefq\",\"xafrsm\",\"sjyfskc\",\"bfr\",\"nwan\",\"mjkj\",\"ujlr\",\"mrmahpv\"]\\n\\n\\nsame for other test cases>40 out of 80\\nMy solution-\\nhttps://leetcode.com/problems/naming-a-company/submissions/894707979/\\n\\n\\n"
                    },
                    {
                        "username": "shivam-singh",
                        "content": "Passed all test cases 89/89.\\nStill getting TLE, Why? "
                    },
                    {
                        "username": "suckpf98690",
                        "content": "Is it possible to use pure C code without TLE?"
                    },
                    {
                        "username": "6fitzy",
                        "content": "I\\'m not sure that it is. I haven\\'t gotten past TLE either"
                    }
                ]
            },
            {
                "id": 1794417,
                "content": [
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "No."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@billy_homeless](/billy_homeless) Nes"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "Yes."
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "My mind: \"Reads this question: It seems easy then why rated hard\"\\nMy heart: \"Don\\'t trust them, it gonna hurt\"\\nLC: TLE\\naaaaaaaaaaa"
                    },
                    {
                        "username": "maltarouti",
                        "content": "CeetLode"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "Time Limit Exceeded -  89 / 89 test case passed\nwhat am i supposed to do ??"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "Write a more efficient solution?"
                    },
                    {
                        "username": "KhacLong",
                        "content": "i think this problem need many skills and experiences about set to solve, it took me 2 hours but i was failed to solve it"
                    },
                    {
                        "username": "radhika_8",
                        "content": "can anyone explain me this \\nHashSet<String>[] initialGroup = new HashSet[26];\\nis it an set or array?"
                    },
                    {
                        "username": "radhika_8",
                        "content": "[@kbbhatt61](/kbbhatt61) thanks;)\\n"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "HashSet is a class so, this statement of yours has just declared an object of that class. It\\'s neither an array nor a set.\\n\\nMore specifically, what you\\'ve done is called raw type declaration. It will not have any hashset methods. It\\'s still used just for the compatibility (backwards) with older versions of java which don\\'t have generics feature.\\n\\nYou must use generic type using diamond operator <> to enable functionalities of hashset including add, remove, etc.\\n\\nBtw, thanks for this comment. I didn\\'t know this concept. I researched it myself before replying. :)"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "50000, so many ideas, they must be clever!"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "Weird leetcode BUG\\nDoes anyone also faced same issue when trying bit masking solution...??\\n\\nProblem-Accepted for same testcase in console but getting TLE after submission.\\n\\n\\nTC=\\n[\"j\",\"t\",\"fmucd\",\"liantvj\",\"sgizj\",\"qjkqmnefo\",\"g\",\"zaa\",\"epw\",\"fz\",\"ycad\",\"oocqnz\",\"bwowse\",\"bcnealx\",\"imlwxoxzml\",\"crmahpv\",\"vh\",\"qfwyd\",\"dycxopdrzb\",\"hvbje\",\"f\",\"qwowse\",\"lnwgxmqdc\",\"k\",\"fmffskrv\",\"bmlwxoxzml\",\"iffrcpdsu\",\"xpqodjcvri\",\"cmsyrkrrm\",\"unb\",\"ln\",\"hmffskrv\",\"bihbm\",\"fv\",\"eqwg\",\"p\",\"vnpooqdpe\",\"okja\",\"lmffskrv\",\"r\",\"pnwgxmqdc\",\"gpyamphhda\",\"azklwrs\",\"ejwuuqz\",\"rmxhrnzz\",\"gggwj\",\"qh\",\"siantvj\",\"pcad\",\"y\",\"nteqr\",\"mi\",\"ri\",\"jqwg\",\"fnpooqdpe\",\"ukqhjnk\",\"tyaastc\",\"xmsyrkrrm\",\"l\",\"ypmpilxnl\",\"lzf\",\"nkja\",\"xiantvj\",\"fvbje\",\"ooltwf\",\"fycxopdrzb\",\"gi\",\"bmffskrv\",\"bnihnwsx\",\"epci\",\"awowse\",\"tokjknsyk\",\"owan\",\"vz\",\"qd\",\"ng\",\"goebwzhefq\",\"xafrsm\",\"sjyfskc\",\"bfr\",\"nwan\",\"mjkj\",\"ujlr\",\"mrmahpv\"]\\n\\n\\nsame for other test cases>40 out of 80\\nMy solution-\\nhttps://leetcode.com/problems/naming-a-company/submissions/894707979/\\n\\n\\n"
                    },
                    {
                        "username": "shivam-singh",
                        "content": "Passed all test cases 89/89.\\nStill getting TLE, Why? "
                    },
                    {
                        "username": "suckpf98690",
                        "content": "Is it possible to use pure C code without TLE?"
                    },
                    {
                        "username": "6fitzy",
                        "content": "I\\'m not sure that it is. I haven\\'t gotten past TLE either"
                    }
                ]
            },
            {
                "id": 1794179,
                "content": [
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "No."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@billy_homeless](/billy_homeless) Nes"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "Yes."
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "My mind: \"Reads this question: It seems easy then why rated hard\"\\nMy heart: \"Don\\'t trust them, it gonna hurt\"\\nLC: TLE\\naaaaaaaaaaa"
                    },
                    {
                        "username": "maltarouti",
                        "content": "CeetLode"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "Time Limit Exceeded -  89 / 89 test case passed\nwhat am i supposed to do ??"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "Write a more efficient solution?"
                    },
                    {
                        "username": "KhacLong",
                        "content": "i think this problem need many skills and experiences about set to solve, it took me 2 hours but i was failed to solve it"
                    },
                    {
                        "username": "radhika_8",
                        "content": "can anyone explain me this \\nHashSet<String>[] initialGroup = new HashSet[26];\\nis it an set or array?"
                    },
                    {
                        "username": "radhika_8",
                        "content": "[@kbbhatt61](/kbbhatt61) thanks;)\\n"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "HashSet is a class so, this statement of yours has just declared an object of that class. It\\'s neither an array nor a set.\\n\\nMore specifically, what you\\'ve done is called raw type declaration. It will not have any hashset methods. It\\'s still used just for the compatibility (backwards) with older versions of java which don\\'t have generics feature.\\n\\nYou must use generic type using diamond operator <> to enable functionalities of hashset including add, remove, etc.\\n\\nBtw, thanks for this comment. I didn\\'t know this concept. I researched it myself before replying. :)"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "50000, so many ideas, they must be clever!"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "Weird leetcode BUG\\nDoes anyone also faced same issue when trying bit masking solution...??\\n\\nProblem-Accepted for same testcase in console but getting TLE after submission.\\n\\n\\nTC=\\n[\"j\",\"t\",\"fmucd\",\"liantvj\",\"sgizj\",\"qjkqmnefo\",\"g\",\"zaa\",\"epw\",\"fz\",\"ycad\",\"oocqnz\",\"bwowse\",\"bcnealx\",\"imlwxoxzml\",\"crmahpv\",\"vh\",\"qfwyd\",\"dycxopdrzb\",\"hvbje\",\"f\",\"qwowse\",\"lnwgxmqdc\",\"k\",\"fmffskrv\",\"bmlwxoxzml\",\"iffrcpdsu\",\"xpqodjcvri\",\"cmsyrkrrm\",\"unb\",\"ln\",\"hmffskrv\",\"bihbm\",\"fv\",\"eqwg\",\"p\",\"vnpooqdpe\",\"okja\",\"lmffskrv\",\"r\",\"pnwgxmqdc\",\"gpyamphhda\",\"azklwrs\",\"ejwuuqz\",\"rmxhrnzz\",\"gggwj\",\"qh\",\"siantvj\",\"pcad\",\"y\",\"nteqr\",\"mi\",\"ri\",\"jqwg\",\"fnpooqdpe\",\"ukqhjnk\",\"tyaastc\",\"xmsyrkrrm\",\"l\",\"ypmpilxnl\",\"lzf\",\"nkja\",\"xiantvj\",\"fvbje\",\"ooltwf\",\"fycxopdrzb\",\"gi\",\"bmffskrv\",\"bnihnwsx\",\"epci\",\"awowse\",\"tokjknsyk\",\"owan\",\"vz\",\"qd\",\"ng\",\"goebwzhefq\",\"xafrsm\",\"sjyfskc\",\"bfr\",\"nwan\",\"mjkj\",\"ujlr\",\"mrmahpv\"]\\n\\n\\nsame for other test cases>40 out of 80\\nMy solution-\\nhttps://leetcode.com/problems/naming-a-company/submissions/894707979/\\n\\n\\n"
                    },
                    {
                        "username": "shivam-singh",
                        "content": "Passed all test cases 89/89.\\nStill getting TLE, Why? "
                    },
                    {
                        "username": "suckpf98690",
                        "content": "Is it possible to use pure C code without TLE?"
                    },
                    {
                        "username": "6fitzy",
                        "content": "I\\'m not sure that it is. I haven\\'t gotten past TLE either"
                    }
                ]
            },
            {
                "id": 1793877,
                "content": [
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "No."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@billy_homeless](/billy_homeless) Nes"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "Yes."
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "My mind: \"Reads this question: It seems easy then why rated hard\"\\nMy heart: \"Don\\'t trust them, it gonna hurt\"\\nLC: TLE\\naaaaaaaaaaa"
                    },
                    {
                        "username": "maltarouti",
                        "content": "CeetLode"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "Time Limit Exceeded -  89 / 89 test case passed\nwhat am i supposed to do ??"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "Write a more efficient solution?"
                    },
                    {
                        "username": "KhacLong",
                        "content": "i think this problem need many skills and experiences about set to solve, it took me 2 hours but i was failed to solve it"
                    },
                    {
                        "username": "radhika_8",
                        "content": "can anyone explain me this \\nHashSet<String>[] initialGroup = new HashSet[26];\\nis it an set or array?"
                    },
                    {
                        "username": "radhika_8",
                        "content": "[@kbbhatt61](/kbbhatt61) thanks;)\\n"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "HashSet is a class so, this statement of yours has just declared an object of that class. It\\'s neither an array nor a set.\\n\\nMore specifically, what you\\'ve done is called raw type declaration. It will not have any hashset methods. It\\'s still used just for the compatibility (backwards) with older versions of java which don\\'t have generics feature.\\n\\nYou must use generic type using diamond operator <> to enable functionalities of hashset including add, remove, etc.\\n\\nBtw, thanks for this comment. I didn\\'t know this concept. I researched it myself before replying. :)"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "50000, so many ideas, they must be clever!"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "Weird leetcode BUG\\nDoes anyone also faced same issue when trying bit masking solution...??\\n\\nProblem-Accepted for same testcase in console but getting TLE after submission.\\n\\n\\nTC=\\n[\"j\",\"t\",\"fmucd\",\"liantvj\",\"sgizj\",\"qjkqmnefo\",\"g\",\"zaa\",\"epw\",\"fz\",\"ycad\",\"oocqnz\",\"bwowse\",\"bcnealx\",\"imlwxoxzml\",\"crmahpv\",\"vh\",\"qfwyd\",\"dycxopdrzb\",\"hvbje\",\"f\",\"qwowse\",\"lnwgxmqdc\",\"k\",\"fmffskrv\",\"bmlwxoxzml\",\"iffrcpdsu\",\"xpqodjcvri\",\"cmsyrkrrm\",\"unb\",\"ln\",\"hmffskrv\",\"bihbm\",\"fv\",\"eqwg\",\"p\",\"vnpooqdpe\",\"okja\",\"lmffskrv\",\"r\",\"pnwgxmqdc\",\"gpyamphhda\",\"azklwrs\",\"ejwuuqz\",\"rmxhrnzz\",\"gggwj\",\"qh\",\"siantvj\",\"pcad\",\"y\",\"nteqr\",\"mi\",\"ri\",\"jqwg\",\"fnpooqdpe\",\"ukqhjnk\",\"tyaastc\",\"xmsyrkrrm\",\"l\",\"ypmpilxnl\",\"lzf\",\"nkja\",\"xiantvj\",\"fvbje\",\"ooltwf\",\"fycxopdrzb\",\"gi\",\"bmffskrv\",\"bnihnwsx\",\"epci\",\"awowse\",\"tokjknsyk\",\"owan\",\"vz\",\"qd\",\"ng\",\"goebwzhefq\",\"xafrsm\",\"sjyfskc\",\"bfr\",\"nwan\",\"mjkj\",\"ujlr\",\"mrmahpv\"]\\n\\n\\nsame for other test cases>40 out of 80\\nMy solution-\\nhttps://leetcode.com/problems/naming-a-company/submissions/894707979/\\n\\n\\n"
                    },
                    {
                        "username": "shivam-singh",
                        "content": "Passed all test cases 89/89.\\nStill getting TLE, Why? "
                    },
                    {
                        "username": "suckpf98690",
                        "content": "Is it possible to use pure C code without TLE?"
                    },
                    {
                        "username": "6fitzy",
                        "content": "I\\'m not sure that it is. I haven\\'t gotten past TLE either"
                    }
                ]
            },
            {
                "id": 1794395,
                "content": [
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "No."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@billy_homeless](/billy_homeless) Nes"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "Yes."
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "My mind: \"Reads this question: It seems easy then why rated hard\"\\nMy heart: \"Don\\'t trust them, it gonna hurt\"\\nLC: TLE\\naaaaaaaaaaa"
                    },
                    {
                        "username": "maltarouti",
                        "content": "CeetLode"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "Time Limit Exceeded -  89 / 89 test case passed\nwhat am i supposed to do ??"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "Write a more efficient solution?"
                    },
                    {
                        "username": "KhacLong",
                        "content": "i think this problem need many skills and experiences about set to solve, it took me 2 hours but i was failed to solve it"
                    },
                    {
                        "username": "radhika_8",
                        "content": "can anyone explain me this \\nHashSet<String>[] initialGroup = new HashSet[26];\\nis it an set or array?"
                    },
                    {
                        "username": "radhika_8",
                        "content": "[@kbbhatt61](/kbbhatt61) thanks;)\\n"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "HashSet is a class so, this statement of yours has just declared an object of that class. It\\'s neither an array nor a set.\\n\\nMore specifically, what you\\'ve done is called raw type declaration. It will not have any hashset methods. It\\'s still used just for the compatibility (backwards) with older versions of java which don\\'t have generics feature.\\n\\nYou must use generic type using diamond operator <> to enable functionalities of hashset including add, remove, etc.\\n\\nBtw, thanks for this comment. I didn\\'t know this concept. I researched it myself before replying. :)"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "50000, so many ideas, they must be clever!"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "Weird leetcode BUG\\nDoes anyone also faced same issue when trying bit masking solution...??\\n\\nProblem-Accepted for same testcase in console but getting TLE after submission.\\n\\n\\nTC=\\n[\"j\",\"t\",\"fmucd\",\"liantvj\",\"sgizj\",\"qjkqmnefo\",\"g\",\"zaa\",\"epw\",\"fz\",\"ycad\",\"oocqnz\",\"bwowse\",\"bcnealx\",\"imlwxoxzml\",\"crmahpv\",\"vh\",\"qfwyd\",\"dycxopdrzb\",\"hvbje\",\"f\",\"qwowse\",\"lnwgxmqdc\",\"k\",\"fmffskrv\",\"bmlwxoxzml\",\"iffrcpdsu\",\"xpqodjcvri\",\"cmsyrkrrm\",\"unb\",\"ln\",\"hmffskrv\",\"bihbm\",\"fv\",\"eqwg\",\"p\",\"vnpooqdpe\",\"okja\",\"lmffskrv\",\"r\",\"pnwgxmqdc\",\"gpyamphhda\",\"azklwrs\",\"ejwuuqz\",\"rmxhrnzz\",\"gggwj\",\"qh\",\"siantvj\",\"pcad\",\"y\",\"nteqr\",\"mi\",\"ri\",\"jqwg\",\"fnpooqdpe\",\"ukqhjnk\",\"tyaastc\",\"xmsyrkrrm\",\"l\",\"ypmpilxnl\",\"lzf\",\"nkja\",\"xiantvj\",\"fvbje\",\"ooltwf\",\"fycxopdrzb\",\"gi\",\"bmffskrv\",\"bnihnwsx\",\"epci\",\"awowse\",\"tokjknsyk\",\"owan\",\"vz\",\"qd\",\"ng\",\"goebwzhefq\",\"xafrsm\",\"sjyfskc\",\"bfr\",\"nwan\",\"mjkj\",\"ujlr\",\"mrmahpv\"]\\n\\n\\nsame for other test cases>40 out of 80\\nMy solution-\\nhttps://leetcode.com/problems/naming-a-company/submissions/894707979/\\n\\n\\n"
                    },
                    {
                        "username": "shivam-singh",
                        "content": "Passed all test cases 89/89.\\nStill getting TLE, Why? "
                    },
                    {
                        "username": "suckpf98690",
                        "content": "Is it possible to use pure C code without TLE?"
                    },
                    {
                        "username": "6fitzy",
                        "content": "I\\'m not sure that it is. I haven\\'t gotten past TLE either"
                    }
                ]
            },
            {
                "id": 1794318,
                "content": [
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "No."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@billy_homeless](/billy_homeless) Nes"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "Yes."
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "My mind: \"Reads this question: It seems easy then why rated hard\"\\nMy heart: \"Don\\'t trust them, it gonna hurt\"\\nLC: TLE\\naaaaaaaaaaa"
                    },
                    {
                        "username": "maltarouti",
                        "content": "CeetLode"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "Time Limit Exceeded -  89 / 89 test case passed\nwhat am i supposed to do ??"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "Write a more efficient solution?"
                    },
                    {
                        "username": "KhacLong",
                        "content": "i think this problem need many skills and experiences about set to solve, it took me 2 hours but i was failed to solve it"
                    },
                    {
                        "username": "radhika_8",
                        "content": "can anyone explain me this \\nHashSet<String>[] initialGroup = new HashSet[26];\\nis it an set or array?"
                    },
                    {
                        "username": "radhika_8",
                        "content": "[@kbbhatt61](/kbbhatt61) thanks;)\\n"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "HashSet is a class so, this statement of yours has just declared an object of that class. It\\'s neither an array nor a set.\\n\\nMore specifically, what you\\'ve done is called raw type declaration. It will not have any hashset methods. It\\'s still used just for the compatibility (backwards) with older versions of java which don\\'t have generics feature.\\n\\nYou must use generic type using diamond operator <> to enable functionalities of hashset including add, remove, etc.\\n\\nBtw, thanks for this comment. I didn\\'t know this concept. I researched it myself before replying. :)"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "50000, so many ideas, they must be clever!"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "Weird leetcode BUG\\nDoes anyone also faced same issue when trying bit masking solution...??\\n\\nProblem-Accepted for same testcase in console but getting TLE after submission.\\n\\n\\nTC=\\n[\"j\",\"t\",\"fmucd\",\"liantvj\",\"sgizj\",\"qjkqmnefo\",\"g\",\"zaa\",\"epw\",\"fz\",\"ycad\",\"oocqnz\",\"bwowse\",\"bcnealx\",\"imlwxoxzml\",\"crmahpv\",\"vh\",\"qfwyd\",\"dycxopdrzb\",\"hvbje\",\"f\",\"qwowse\",\"lnwgxmqdc\",\"k\",\"fmffskrv\",\"bmlwxoxzml\",\"iffrcpdsu\",\"xpqodjcvri\",\"cmsyrkrrm\",\"unb\",\"ln\",\"hmffskrv\",\"bihbm\",\"fv\",\"eqwg\",\"p\",\"vnpooqdpe\",\"okja\",\"lmffskrv\",\"r\",\"pnwgxmqdc\",\"gpyamphhda\",\"azklwrs\",\"ejwuuqz\",\"rmxhrnzz\",\"gggwj\",\"qh\",\"siantvj\",\"pcad\",\"y\",\"nteqr\",\"mi\",\"ri\",\"jqwg\",\"fnpooqdpe\",\"ukqhjnk\",\"tyaastc\",\"xmsyrkrrm\",\"l\",\"ypmpilxnl\",\"lzf\",\"nkja\",\"xiantvj\",\"fvbje\",\"ooltwf\",\"fycxopdrzb\",\"gi\",\"bmffskrv\",\"bnihnwsx\",\"epci\",\"awowse\",\"tokjknsyk\",\"owan\",\"vz\",\"qd\",\"ng\",\"goebwzhefq\",\"xafrsm\",\"sjyfskc\",\"bfr\",\"nwan\",\"mjkj\",\"ujlr\",\"mrmahpv\"]\\n\\n\\nsame for other test cases>40 out of 80\\nMy solution-\\nhttps://leetcode.com/problems/naming-a-company/submissions/894707979/\\n\\n\\n"
                    },
                    {
                        "username": "shivam-singh",
                        "content": "Passed all test cases 89/89.\\nStill getting TLE, Why? "
                    },
                    {
                        "username": "suckpf98690",
                        "content": "Is it possible to use pure C code without TLE?"
                    },
                    {
                        "username": "6fitzy",
                        "content": "I\\'m not sure that it is. I haven\\'t gotten past TLE either"
                    }
                ]
            },
            {
                "id": 1794227,
                "content": [
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "No."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@billy_homeless](/billy_homeless) Nes"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "Yes."
                    },
                    {
                        "username": "SHIVAM_1357",
                        "content": "My mind: \"Reads this question: It seems easy then why rated hard\"\\nMy heart: \"Don\\'t trust them, it gonna hurt\"\\nLC: TLE\\naaaaaaaaaaa"
                    },
                    {
                        "username": "maltarouti",
                        "content": "CeetLode"
                    },
                    {
                        "username": "ankurgoswami718",
                        "content": "Time Limit Exceeded -  89 / 89 test case passed\nwhat am i supposed to do ??"
                    },
                    {
                        "username": "Shadow_Guo",
                        "content": "Write a more efficient solution?"
                    },
                    {
                        "username": "KhacLong",
                        "content": "i think this problem need many skills and experiences about set to solve, it took me 2 hours but i was failed to solve it"
                    },
                    {
                        "username": "radhika_8",
                        "content": "can anyone explain me this \\nHashSet<String>[] initialGroup = new HashSet[26];\\nis it an set or array?"
                    },
                    {
                        "username": "radhika_8",
                        "content": "[@kbbhatt61](/kbbhatt61) thanks;)\\n"
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "HashSet is a class so, this statement of yours has just declared an object of that class. It\\'s neither an array nor a set.\\n\\nMore specifically, what you\\'ve done is called raw type declaration. It will not have any hashset methods. It\\'s still used just for the compatibility (backwards) with older versions of java which don\\'t have generics feature.\\n\\nYou must use generic type using diamond operator <> to enable functionalities of hashset including add, remove, etc.\\n\\nBtw, thanks for this comment. I didn\\'t know this concept. I researched it myself before replying. :)"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "50000, so many ideas, they must be clever!"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "Weird leetcode BUG\\nDoes anyone also faced same issue when trying bit masking solution...??\\n\\nProblem-Accepted for same testcase in console but getting TLE after submission.\\n\\n\\nTC=\\n[\"j\",\"t\",\"fmucd\",\"liantvj\",\"sgizj\",\"qjkqmnefo\",\"g\",\"zaa\",\"epw\",\"fz\",\"ycad\",\"oocqnz\",\"bwowse\",\"bcnealx\",\"imlwxoxzml\",\"crmahpv\",\"vh\",\"qfwyd\",\"dycxopdrzb\",\"hvbje\",\"f\",\"qwowse\",\"lnwgxmqdc\",\"k\",\"fmffskrv\",\"bmlwxoxzml\",\"iffrcpdsu\",\"xpqodjcvri\",\"cmsyrkrrm\",\"unb\",\"ln\",\"hmffskrv\",\"bihbm\",\"fv\",\"eqwg\",\"p\",\"vnpooqdpe\",\"okja\",\"lmffskrv\",\"r\",\"pnwgxmqdc\",\"gpyamphhda\",\"azklwrs\",\"ejwuuqz\",\"rmxhrnzz\",\"gggwj\",\"qh\",\"siantvj\",\"pcad\",\"y\",\"nteqr\",\"mi\",\"ri\",\"jqwg\",\"fnpooqdpe\",\"ukqhjnk\",\"tyaastc\",\"xmsyrkrrm\",\"l\",\"ypmpilxnl\",\"lzf\",\"nkja\",\"xiantvj\",\"fvbje\",\"ooltwf\",\"fycxopdrzb\",\"gi\",\"bmffskrv\",\"bnihnwsx\",\"epci\",\"awowse\",\"tokjknsyk\",\"owan\",\"vz\",\"qd\",\"ng\",\"goebwzhefq\",\"xafrsm\",\"sjyfskc\",\"bfr\",\"nwan\",\"mjkj\",\"ujlr\",\"mrmahpv\"]\\n\\n\\nsame for other test cases>40 out of 80\\nMy solution-\\nhttps://leetcode.com/problems/naming-a-company/submissions/894707979/\\n\\n\\n"
                    },
                    {
                        "username": "shivam-singh",
                        "content": "Passed all test cases 89/89.\\nStill getting TLE, Why? "
                    },
                    {
                        "username": "suckpf98690",
                        "content": "Is it possible to use pure C code without TLE?"
                    },
                    {
                        "username": "6fitzy",
                        "content": "I\\'m not sure that it is. I haven\\'t gotten past TLE either"
                    }
                ]
            },
            {
                "id": 1793902,
                "content": [
                    {
                        "username": "asdfghjklll123",
                        "content": "`itertools` makes a TLE lmao"
                    },
                    {
                        "username": "gflanary",
                        "content": "Definitely feels like it\\'s on the easier side of hard problems. Just go in expecting to need to think about a way around TLE, and it becomes pretty obvious what the solution will be."
                    },
                    {
                        "username": "It_is_me_Mario",
                        "content": "It would be much clear if the problem\\'s description said:\\nSwap the first letter of ideaA and the first letter of ideaB with each other.\\nI spent 20 minutes figuring out why [coffes, donute] (selected the first two letters) is not a valid case."
                    },
                    {
                        "username": "heraAijaz",
                        "content": "They didn\\'t because that\\'s not how real world problems come across. And what\\'s point in solving otherwise?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "It\\'s clearly stated in the question:\\n\\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\\n\\nSwap the *first letters* of ideaA and ideaB with each other."
                    },
                    {
                        "username": "Rawl",
                        "content": "Any intuitive reason why grouping them using the suffix instead of the first character doesn\\'t work ?"
                    },
                    {
                        "username": "__ro",
                        "content": "Can anyone explain why this code is throwing \"memory limit exceeded\" ?\\n`from itertools import combinations\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        score = 0\\n        for each in list(combinations(range(len(ideas)),2)):\\n            if ideas[each[0]][0] != ideas[each[1]][0]:\\n                if ideas[each[0]][0] + ideas[each[1]][1:] in ideas:\\n                    continue\\n                if   ideas[each[1]][0] + ideas[each[0]][1:] not in ideas:\\n                    score += 2\\n        return score`"
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "Holy god why the heck did i pick this problem when I was just doing a random array routine.... Reading the question I just said why such a basic problem in hard!!.. Nd now its ruining my sleep"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "In the description to this problem, leetcode added a `bit manipulation` tag. \\nPlease if anyone has an idea on how to solve this using that, leave a hint."
                    },
                    {
                        "username": "escoville",
                        "content": "I come here for interview practice, and this problem isn\\'t worth the effort.  The problem hides the real difficulty:  solving the hidden test cases within an arbitrary time frame.  It\\'s way too ambiguous for a whiteboard interview, and even if you were given the test case in a take-home test, the time it takes to run would vary too much from machine to machine.  Sure, it\\'s interesting, but it feels like I just wasted my time trying to solve a problem I\\'ll never encounter."
                    },
                    {
                        "username": "slashtab",
                        "content": "Has anyone done it using Bit Manipulation? please share link for solution, or direct me in right direction?!"
                    },
                    {
                        "username": "nikmarko",
                        "content": "Is there any submission for C that is accepted? My best result is 85/89 testcases passed so far, with TLE."
                    }
                ]
            },
            {
                "id": 1793842,
                "content": [
                    {
                        "username": "asdfghjklll123",
                        "content": "`itertools` makes a TLE lmao"
                    },
                    {
                        "username": "gflanary",
                        "content": "Definitely feels like it\\'s on the easier side of hard problems. Just go in expecting to need to think about a way around TLE, and it becomes pretty obvious what the solution will be."
                    },
                    {
                        "username": "It_is_me_Mario",
                        "content": "It would be much clear if the problem\\'s description said:\\nSwap the first letter of ideaA and the first letter of ideaB with each other.\\nI spent 20 minutes figuring out why [coffes, donute] (selected the first two letters) is not a valid case."
                    },
                    {
                        "username": "heraAijaz",
                        "content": "They didn\\'t because that\\'s not how real world problems come across. And what\\'s point in solving otherwise?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "It\\'s clearly stated in the question:\\n\\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\\n\\nSwap the *first letters* of ideaA and ideaB with each other."
                    },
                    {
                        "username": "Rawl",
                        "content": "Any intuitive reason why grouping them using the suffix instead of the first character doesn\\'t work ?"
                    },
                    {
                        "username": "__ro",
                        "content": "Can anyone explain why this code is throwing \"memory limit exceeded\" ?\\n`from itertools import combinations\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        score = 0\\n        for each in list(combinations(range(len(ideas)),2)):\\n            if ideas[each[0]][0] != ideas[each[1]][0]:\\n                if ideas[each[0]][0] + ideas[each[1]][1:] in ideas:\\n                    continue\\n                if   ideas[each[1]][0] + ideas[each[0]][1:] not in ideas:\\n                    score += 2\\n        return score`"
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "Holy god why the heck did i pick this problem when I was just doing a random array routine.... Reading the question I just said why such a basic problem in hard!!.. Nd now its ruining my sleep"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "In the description to this problem, leetcode added a `bit manipulation` tag. \\nPlease if anyone has an idea on how to solve this using that, leave a hint."
                    },
                    {
                        "username": "escoville",
                        "content": "I come here for interview practice, and this problem isn\\'t worth the effort.  The problem hides the real difficulty:  solving the hidden test cases within an arbitrary time frame.  It\\'s way too ambiguous for a whiteboard interview, and even if you were given the test case in a take-home test, the time it takes to run would vary too much from machine to machine.  Sure, it\\'s interesting, but it feels like I just wasted my time trying to solve a problem I\\'ll never encounter."
                    },
                    {
                        "username": "slashtab",
                        "content": "Has anyone done it using Bit Manipulation? please share link for solution, or direct me in right direction?!"
                    },
                    {
                        "username": "nikmarko",
                        "content": "Is there any submission for C that is accepted? My best result is 85/89 testcases passed so far, with TLE."
                    }
                ]
            },
            {
                "id": 1793747,
                "content": [
                    {
                        "username": "asdfghjklll123",
                        "content": "`itertools` makes a TLE lmao"
                    },
                    {
                        "username": "gflanary",
                        "content": "Definitely feels like it\\'s on the easier side of hard problems. Just go in expecting to need to think about a way around TLE, and it becomes pretty obvious what the solution will be."
                    },
                    {
                        "username": "It_is_me_Mario",
                        "content": "It would be much clear if the problem\\'s description said:\\nSwap the first letter of ideaA and the first letter of ideaB with each other.\\nI spent 20 minutes figuring out why [coffes, donute] (selected the first two letters) is not a valid case."
                    },
                    {
                        "username": "heraAijaz",
                        "content": "They didn\\'t because that\\'s not how real world problems come across. And what\\'s point in solving otherwise?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "It\\'s clearly stated in the question:\\n\\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\\n\\nSwap the *first letters* of ideaA and ideaB with each other."
                    },
                    {
                        "username": "Rawl",
                        "content": "Any intuitive reason why grouping them using the suffix instead of the first character doesn\\'t work ?"
                    },
                    {
                        "username": "__ro",
                        "content": "Can anyone explain why this code is throwing \"memory limit exceeded\" ?\\n`from itertools import combinations\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        score = 0\\n        for each in list(combinations(range(len(ideas)),2)):\\n            if ideas[each[0]][0] != ideas[each[1]][0]:\\n                if ideas[each[0]][0] + ideas[each[1]][1:] in ideas:\\n                    continue\\n                if   ideas[each[1]][0] + ideas[each[0]][1:] not in ideas:\\n                    score += 2\\n        return score`"
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "Holy god why the heck did i pick this problem when I was just doing a random array routine.... Reading the question I just said why such a basic problem in hard!!.. Nd now its ruining my sleep"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "In the description to this problem, leetcode added a `bit manipulation` tag. \\nPlease if anyone has an idea on how to solve this using that, leave a hint."
                    },
                    {
                        "username": "escoville",
                        "content": "I come here for interview practice, and this problem isn\\'t worth the effort.  The problem hides the real difficulty:  solving the hidden test cases within an arbitrary time frame.  It\\'s way too ambiguous for a whiteboard interview, and even if you were given the test case in a take-home test, the time it takes to run would vary too much from machine to machine.  Sure, it\\'s interesting, but it feels like I just wasted my time trying to solve a problem I\\'ll never encounter."
                    },
                    {
                        "username": "slashtab",
                        "content": "Has anyone done it using Bit Manipulation? please share link for solution, or direct me in right direction?!"
                    },
                    {
                        "username": "nikmarko",
                        "content": "Is there any submission for C that is accepted? My best result is 85/89 testcases passed so far, with TLE."
                    }
                ]
            },
            {
                "id": 1986923,
                "content": [
                    {
                        "username": "asdfghjklll123",
                        "content": "`itertools` makes a TLE lmao"
                    },
                    {
                        "username": "gflanary",
                        "content": "Definitely feels like it\\'s on the easier side of hard problems. Just go in expecting to need to think about a way around TLE, and it becomes pretty obvious what the solution will be."
                    },
                    {
                        "username": "It_is_me_Mario",
                        "content": "It would be much clear if the problem\\'s description said:\\nSwap the first letter of ideaA and the first letter of ideaB with each other.\\nI spent 20 minutes figuring out why [coffes, donute] (selected the first two letters) is not a valid case."
                    },
                    {
                        "username": "heraAijaz",
                        "content": "They didn\\'t because that\\'s not how real world problems come across. And what\\'s point in solving otherwise?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "It\\'s clearly stated in the question:\\n\\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\\n\\nSwap the *first letters* of ideaA and ideaB with each other."
                    },
                    {
                        "username": "Rawl",
                        "content": "Any intuitive reason why grouping them using the suffix instead of the first character doesn\\'t work ?"
                    },
                    {
                        "username": "__ro",
                        "content": "Can anyone explain why this code is throwing \"memory limit exceeded\" ?\\n`from itertools import combinations\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        score = 0\\n        for each in list(combinations(range(len(ideas)),2)):\\n            if ideas[each[0]][0] != ideas[each[1]][0]:\\n                if ideas[each[0]][0] + ideas[each[1]][1:] in ideas:\\n                    continue\\n                if   ideas[each[1]][0] + ideas[each[0]][1:] not in ideas:\\n                    score += 2\\n        return score`"
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "Holy god why the heck did i pick this problem when I was just doing a random array routine.... Reading the question I just said why such a basic problem in hard!!.. Nd now its ruining my sleep"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "In the description to this problem, leetcode added a `bit manipulation` tag. \\nPlease if anyone has an idea on how to solve this using that, leave a hint."
                    },
                    {
                        "username": "escoville",
                        "content": "I come here for interview practice, and this problem isn\\'t worth the effort.  The problem hides the real difficulty:  solving the hidden test cases within an arbitrary time frame.  It\\'s way too ambiguous for a whiteboard interview, and even if you were given the test case in a take-home test, the time it takes to run would vary too much from machine to machine.  Sure, it\\'s interesting, but it feels like I just wasted my time trying to solve a problem I\\'ll never encounter."
                    },
                    {
                        "username": "slashtab",
                        "content": "Has anyone done it using Bit Manipulation? please share link for solution, or direct me in right direction?!"
                    },
                    {
                        "username": "nikmarko",
                        "content": "Is there any submission for C that is accepted? My best result is 85/89 testcases passed so far, with TLE."
                    }
                ]
            },
            {
                "id": 1964927,
                "content": [
                    {
                        "username": "asdfghjklll123",
                        "content": "`itertools` makes a TLE lmao"
                    },
                    {
                        "username": "gflanary",
                        "content": "Definitely feels like it\\'s on the easier side of hard problems. Just go in expecting to need to think about a way around TLE, and it becomes pretty obvious what the solution will be."
                    },
                    {
                        "username": "It_is_me_Mario",
                        "content": "It would be much clear if the problem\\'s description said:\\nSwap the first letter of ideaA and the first letter of ideaB with each other.\\nI spent 20 minutes figuring out why [coffes, donute] (selected the first two letters) is not a valid case."
                    },
                    {
                        "username": "heraAijaz",
                        "content": "They didn\\'t because that\\'s not how real world problems come across. And what\\'s point in solving otherwise?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "It\\'s clearly stated in the question:\\n\\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\\n\\nSwap the *first letters* of ideaA and ideaB with each other."
                    },
                    {
                        "username": "Rawl",
                        "content": "Any intuitive reason why grouping them using the suffix instead of the first character doesn\\'t work ?"
                    },
                    {
                        "username": "__ro",
                        "content": "Can anyone explain why this code is throwing \"memory limit exceeded\" ?\\n`from itertools import combinations\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        score = 0\\n        for each in list(combinations(range(len(ideas)),2)):\\n            if ideas[each[0]][0] != ideas[each[1]][0]:\\n                if ideas[each[0]][0] + ideas[each[1]][1:] in ideas:\\n                    continue\\n                if   ideas[each[1]][0] + ideas[each[0]][1:] not in ideas:\\n                    score += 2\\n        return score`"
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "Holy god why the heck did i pick this problem when I was just doing a random array routine.... Reading the question I just said why such a basic problem in hard!!.. Nd now its ruining my sleep"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "In the description to this problem, leetcode added a `bit manipulation` tag. \\nPlease if anyone has an idea on how to solve this using that, leave a hint."
                    },
                    {
                        "username": "escoville",
                        "content": "I come here for interview practice, and this problem isn\\'t worth the effort.  The problem hides the real difficulty:  solving the hidden test cases within an arbitrary time frame.  It\\'s way too ambiguous for a whiteboard interview, and even if you were given the test case in a take-home test, the time it takes to run would vary too much from machine to machine.  Sure, it\\'s interesting, but it feels like I just wasted my time trying to solve a problem I\\'ll never encounter."
                    },
                    {
                        "username": "slashtab",
                        "content": "Has anyone done it using Bit Manipulation? please share link for solution, or direct me in right direction?!"
                    },
                    {
                        "username": "nikmarko",
                        "content": "Is there any submission for C that is accepted? My best result is 85/89 testcases passed so far, with TLE."
                    }
                ]
            },
            {
                "id": 1952034,
                "content": [
                    {
                        "username": "asdfghjklll123",
                        "content": "`itertools` makes a TLE lmao"
                    },
                    {
                        "username": "gflanary",
                        "content": "Definitely feels like it\\'s on the easier side of hard problems. Just go in expecting to need to think about a way around TLE, and it becomes pretty obvious what the solution will be."
                    },
                    {
                        "username": "It_is_me_Mario",
                        "content": "It would be much clear if the problem\\'s description said:\\nSwap the first letter of ideaA and the first letter of ideaB with each other.\\nI spent 20 minutes figuring out why [coffes, donute] (selected the first two letters) is not a valid case."
                    },
                    {
                        "username": "heraAijaz",
                        "content": "They didn\\'t because that\\'s not how real world problems come across. And what\\'s point in solving otherwise?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "It\\'s clearly stated in the question:\\n\\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\\n\\nSwap the *first letters* of ideaA and ideaB with each other."
                    },
                    {
                        "username": "Rawl",
                        "content": "Any intuitive reason why grouping them using the suffix instead of the first character doesn\\'t work ?"
                    },
                    {
                        "username": "__ro",
                        "content": "Can anyone explain why this code is throwing \"memory limit exceeded\" ?\\n`from itertools import combinations\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        score = 0\\n        for each in list(combinations(range(len(ideas)),2)):\\n            if ideas[each[0]][0] != ideas[each[1]][0]:\\n                if ideas[each[0]][0] + ideas[each[1]][1:] in ideas:\\n                    continue\\n                if   ideas[each[1]][0] + ideas[each[0]][1:] not in ideas:\\n                    score += 2\\n        return score`"
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "Holy god why the heck did i pick this problem when I was just doing a random array routine.... Reading the question I just said why such a basic problem in hard!!.. Nd now its ruining my sleep"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "In the description to this problem, leetcode added a `bit manipulation` tag. \\nPlease if anyone has an idea on how to solve this using that, leave a hint."
                    },
                    {
                        "username": "escoville",
                        "content": "I come here for interview practice, and this problem isn\\'t worth the effort.  The problem hides the real difficulty:  solving the hidden test cases within an arbitrary time frame.  It\\'s way too ambiguous for a whiteboard interview, and even if you were given the test case in a take-home test, the time it takes to run would vary too much from machine to machine.  Sure, it\\'s interesting, but it feels like I just wasted my time trying to solve a problem I\\'ll never encounter."
                    },
                    {
                        "username": "slashtab",
                        "content": "Has anyone done it using Bit Manipulation? please share link for solution, or direct me in right direction?!"
                    },
                    {
                        "username": "nikmarko",
                        "content": "Is there any submission for C that is accepted? My best result is 85/89 testcases passed so far, with TLE."
                    }
                ]
            },
            {
                "id": 1803730,
                "content": [
                    {
                        "username": "asdfghjklll123",
                        "content": "`itertools` makes a TLE lmao"
                    },
                    {
                        "username": "gflanary",
                        "content": "Definitely feels like it\\'s on the easier side of hard problems. Just go in expecting to need to think about a way around TLE, and it becomes pretty obvious what the solution will be."
                    },
                    {
                        "username": "It_is_me_Mario",
                        "content": "It would be much clear if the problem\\'s description said:\\nSwap the first letter of ideaA and the first letter of ideaB with each other.\\nI spent 20 minutes figuring out why [coffes, donute] (selected the first two letters) is not a valid case."
                    },
                    {
                        "username": "heraAijaz",
                        "content": "They didn\\'t because that\\'s not how real world problems come across. And what\\'s point in solving otherwise?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "It\\'s clearly stated in the question:\\n\\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\\n\\nSwap the *first letters* of ideaA and ideaB with each other."
                    },
                    {
                        "username": "Rawl",
                        "content": "Any intuitive reason why grouping them using the suffix instead of the first character doesn\\'t work ?"
                    },
                    {
                        "username": "__ro",
                        "content": "Can anyone explain why this code is throwing \"memory limit exceeded\" ?\\n`from itertools import combinations\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        score = 0\\n        for each in list(combinations(range(len(ideas)),2)):\\n            if ideas[each[0]][0] != ideas[each[1]][0]:\\n                if ideas[each[0]][0] + ideas[each[1]][1:] in ideas:\\n                    continue\\n                if   ideas[each[1]][0] + ideas[each[0]][1:] not in ideas:\\n                    score += 2\\n        return score`"
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "Holy god why the heck did i pick this problem when I was just doing a random array routine.... Reading the question I just said why such a basic problem in hard!!.. Nd now its ruining my sleep"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "In the description to this problem, leetcode added a `bit manipulation` tag. \\nPlease if anyone has an idea on how to solve this using that, leave a hint."
                    },
                    {
                        "username": "escoville",
                        "content": "I come here for interview practice, and this problem isn\\'t worth the effort.  The problem hides the real difficulty:  solving the hidden test cases within an arbitrary time frame.  It\\'s way too ambiguous for a whiteboard interview, and even if you were given the test case in a take-home test, the time it takes to run would vary too much from machine to machine.  Sure, it\\'s interesting, but it feels like I just wasted my time trying to solve a problem I\\'ll never encounter."
                    },
                    {
                        "username": "slashtab",
                        "content": "Has anyone done it using Bit Manipulation? please share link for solution, or direct me in right direction?!"
                    },
                    {
                        "username": "nikmarko",
                        "content": "Is there any submission for C that is accepted? My best result is 85/89 testcases passed so far, with TLE."
                    }
                ]
            },
            {
                "id": 1794922,
                "content": [
                    {
                        "username": "asdfghjklll123",
                        "content": "`itertools` makes a TLE lmao"
                    },
                    {
                        "username": "gflanary",
                        "content": "Definitely feels like it\\'s on the easier side of hard problems. Just go in expecting to need to think about a way around TLE, and it becomes pretty obvious what the solution will be."
                    },
                    {
                        "username": "It_is_me_Mario",
                        "content": "It would be much clear if the problem\\'s description said:\\nSwap the first letter of ideaA and the first letter of ideaB with each other.\\nI spent 20 minutes figuring out why [coffes, donute] (selected the first two letters) is not a valid case."
                    },
                    {
                        "username": "heraAijaz",
                        "content": "They didn\\'t because that\\'s not how real world problems come across. And what\\'s point in solving otherwise?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "It\\'s clearly stated in the question:\\n\\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\\n\\nSwap the *first letters* of ideaA and ideaB with each other."
                    },
                    {
                        "username": "Rawl",
                        "content": "Any intuitive reason why grouping them using the suffix instead of the first character doesn\\'t work ?"
                    },
                    {
                        "username": "__ro",
                        "content": "Can anyone explain why this code is throwing \"memory limit exceeded\" ?\\n`from itertools import combinations\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        score = 0\\n        for each in list(combinations(range(len(ideas)),2)):\\n            if ideas[each[0]][0] != ideas[each[1]][0]:\\n                if ideas[each[0]][0] + ideas[each[1]][1:] in ideas:\\n                    continue\\n                if   ideas[each[1]][0] + ideas[each[0]][1:] not in ideas:\\n                    score += 2\\n        return score`"
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "Holy god why the heck did i pick this problem when I was just doing a random array routine.... Reading the question I just said why such a basic problem in hard!!.. Nd now its ruining my sleep"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "In the description to this problem, leetcode added a `bit manipulation` tag. \\nPlease if anyone has an idea on how to solve this using that, leave a hint."
                    },
                    {
                        "username": "escoville",
                        "content": "I come here for interview practice, and this problem isn\\'t worth the effort.  The problem hides the real difficulty:  solving the hidden test cases within an arbitrary time frame.  It\\'s way too ambiguous for a whiteboard interview, and even if you were given the test case in a take-home test, the time it takes to run would vary too much from machine to machine.  Sure, it\\'s interesting, but it feels like I just wasted my time trying to solve a problem I\\'ll never encounter."
                    },
                    {
                        "username": "slashtab",
                        "content": "Has anyone done it using Bit Manipulation? please share link for solution, or direct me in right direction?!"
                    },
                    {
                        "username": "nikmarko",
                        "content": "Is there any submission for C that is accepted? My best result is 85/89 testcases passed so far, with TLE."
                    }
                ]
            },
            {
                "id": 1794912,
                "content": [
                    {
                        "username": "asdfghjklll123",
                        "content": "`itertools` makes a TLE lmao"
                    },
                    {
                        "username": "gflanary",
                        "content": "Definitely feels like it\\'s on the easier side of hard problems. Just go in expecting to need to think about a way around TLE, and it becomes pretty obvious what the solution will be."
                    },
                    {
                        "username": "It_is_me_Mario",
                        "content": "It would be much clear if the problem\\'s description said:\\nSwap the first letter of ideaA and the first letter of ideaB with each other.\\nI spent 20 minutes figuring out why [coffes, donute] (selected the first two letters) is not a valid case."
                    },
                    {
                        "username": "heraAijaz",
                        "content": "They didn\\'t because that\\'s not how real world problems come across. And what\\'s point in solving otherwise?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "It\\'s clearly stated in the question:\\n\\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\\n\\nSwap the *first letters* of ideaA and ideaB with each other."
                    },
                    {
                        "username": "Rawl",
                        "content": "Any intuitive reason why grouping them using the suffix instead of the first character doesn\\'t work ?"
                    },
                    {
                        "username": "__ro",
                        "content": "Can anyone explain why this code is throwing \"memory limit exceeded\" ?\\n`from itertools import combinations\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        score = 0\\n        for each in list(combinations(range(len(ideas)),2)):\\n            if ideas[each[0]][0] != ideas[each[1]][0]:\\n                if ideas[each[0]][0] + ideas[each[1]][1:] in ideas:\\n                    continue\\n                if   ideas[each[1]][0] + ideas[each[0]][1:] not in ideas:\\n                    score += 2\\n        return score`"
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "Holy god why the heck did i pick this problem when I was just doing a random array routine.... Reading the question I just said why such a basic problem in hard!!.. Nd now its ruining my sleep"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "In the description to this problem, leetcode added a `bit manipulation` tag. \\nPlease if anyone has an idea on how to solve this using that, leave a hint."
                    },
                    {
                        "username": "escoville",
                        "content": "I come here for interview practice, and this problem isn\\'t worth the effort.  The problem hides the real difficulty:  solving the hidden test cases within an arbitrary time frame.  It\\'s way too ambiguous for a whiteboard interview, and even if you were given the test case in a take-home test, the time it takes to run would vary too much from machine to machine.  Sure, it\\'s interesting, but it feels like I just wasted my time trying to solve a problem I\\'ll never encounter."
                    },
                    {
                        "username": "slashtab",
                        "content": "Has anyone done it using Bit Manipulation? please share link for solution, or direct me in right direction?!"
                    },
                    {
                        "username": "nikmarko",
                        "content": "Is there any submission for C that is accepted? My best result is 85/89 testcases passed so far, with TLE."
                    }
                ]
            },
            {
                "id": 1794903,
                "content": [
                    {
                        "username": "asdfghjklll123",
                        "content": "`itertools` makes a TLE lmao"
                    },
                    {
                        "username": "gflanary",
                        "content": "Definitely feels like it\\'s on the easier side of hard problems. Just go in expecting to need to think about a way around TLE, and it becomes pretty obvious what the solution will be."
                    },
                    {
                        "username": "It_is_me_Mario",
                        "content": "It would be much clear if the problem\\'s description said:\\nSwap the first letter of ideaA and the first letter of ideaB with each other.\\nI spent 20 minutes figuring out why [coffes, donute] (selected the first two letters) is not a valid case."
                    },
                    {
                        "username": "heraAijaz",
                        "content": "They didn\\'t because that\\'s not how real world problems come across. And what\\'s point in solving otherwise?"
                    },
                    {
                        "username": "breathermachine",
                        "content": "It\\'s clearly stated in the question:\\n\\nChoose 2 distinct names from ideas, call them ideaA and ideaB.\\n\\nSwap the *first letters* of ideaA and ideaB with each other."
                    },
                    {
                        "username": "Rawl",
                        "content": "Any intuitive reason why grouping them using the suffix instead of the first character doesn\\'t work ?"
                    },
                    {
                        "username": "__ro",
                        "content": "Can anyone explain why this code is throwing \"memory limit exceeded\" ?\\n`from itertools import combinations\\nclass Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        score = 0\\n        for each in list(combinations(range(len(ideas)),2)):\\n            if ideas[each[0]][0] != ideas[each[1]][0]:\\n                if ideas[each[0]][0] + ideas[each[1]][1:] in ideas:\\n                    continue\\n                if   ideas[each[1]][0] + ideas[each[0]][1:] not in ideas:\\n                    score += 2\\n        return score`"
                    },
                    {
                        "username": "bhavya_vermaa",
                        "content": "Holy god why the heck did i pick this problem when I was just doing a random array routine.... Reading the question I just said why such a basic problem in hard!!.. Nd now its ruining my sleep"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "In the description to this problem, leetcode added a `bit manipulation` tag. \\nPlease if anyone has an idea on how to solve this using that, leave a hint."
                    },
                    {
                        "username": "escoville",
                        "content": "I come here for interview practice, and this problem isn\\'t worth the effort.  The problem hides the real difficulty:  solving the hidden test cases within an arbitrary time frame.  It\\'s way too ambiguous for a whiteboard interview, and even if you were given the test case in a take-home test, the time it takes to run would vary too much from machine to machine.  Sure, it\\'s interesting, but it feels like I just wasted my time trying to solve a problem I\\'ll never encounter."
                    },
                    {
                        "username": "slashtab",
                        "content": "Has anyone done it using Bit Manipulation? please share link for solution, or direct me in right direction?!"
                    },
                    {
                        "username": "nikmarko",
                        "content": "Is there any submission for C that is accepted? My best result is 85/89 testcases passed so far, with TLE."
                    }
                ]
            },
            {
                "id": 1794876,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Weird question T_T"
                    },
                    {
                        "username": "huanpipt",
                        "content": "I follow the hint and group ideas by suffix, which leads to TLE. After struggling one hour, I changed to group by prefix. Pass!"
                    },
                    {
                        "username": "yashuagroya",
                        "content": "Why is there a time limit\\ntime limit is the only thing difficult to solve"
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "I have a major headache after solving this .... but the satisfaction is worth it !!"
                    },
                    {
                        "username": "ashleymavericks",
                        "content": "Me: Why is it a Hard problem, why, why ???\nLC : TLE\nMe: Ohh, that's why :facepalm:"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Looking at constraints, O(n^2) might give a TLE!\\n\\nI came up with O(26*N) soln. Many tips in discussion is about suffix matching. Could not find some with prefix counting. So, adding my idea here:\\n\\nTip:\\n- In a array of strings\\n- Store what all starting characters can the IdeaA accept as a pair and IdeaB accept as a pair in a dict of dicts.\\n- Now, we know what all characters ideaA can accept. But we also need to know what all characters can IdeaB accept. So, design a structure similar to this:\\n\\nInput: A = [\"hogs\", \"dairy\", \"pairy\"]\\nHM1 = {\"hogs\": {p, d}, \"dairy\": {h}, \"pairy\": {h}}\\nHM2 = {d: {h: 1}, h: {d: 1, p: 1}, p: {h: 1}}\\n\\nHM2 gives information about how many characters can a string be replaced with.\\nFor eg: \\n- In case of strings starting with d, they can only be coupled with a string starting with letter h\\n- In case of strings starting with h, they can be coupled with 1 string starting with d, p.\\n- In case of strings starting with p, they can only be coupled with 1 string starting with h\\n\\nHope this helps!\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "O(n*m) solution passes 89/89 testcases and gets TLE? Mine was not as elegant as the official solution, but that seems like a little much."
                    },
                    {
                        "username": "paraskumar_12",
                        "content": "Me: \"This problem is easy\"\\nle TLE:  Hold my cup."
                    },
                    {
                        "username": "niteshsingh29",
                        "content": "Hi guyz, is it accepting O(n^2) ??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Nope ;)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The given hints are inaccurate. They suggest grouping by suffix, which gives me TLE. Then I tried to group by prefix, and that passed the tests.\\nThe Official Solution is also done by prefix-grouping, why is the hint misleading:("
                    }
                ]
            },
            {
                "id": 1794847,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Weird question T_T"
                    },
                    {
                        "username": "huanpipt",
                        "content": "I follow the hint and group ideas by suffix, which leads to TLE. After struggling one hour, I changed to group by prefix. Pass!"
                    },
                    {
                        "username": "yashuagroya",
                        "content": "Why is there a time limit\\ntime limit is the only thing difficult to solve"
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "I have a major headache after solving this .... but the satisfaction is worth it !!"
                    },
                    {
                        "username": "ashleymavericks",
                        "content": "Me: Why is it a Hard problem, why, why ???\nLC : TLE\nMe: Ohh, that's why :facepalm:"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Looking at constraints, O(n^2) might give a TLE!\\n\\nI came up with O(26*N) soln. Many tips in discussion is about suffix matching. Could not find some with prefix counting. So, adding my idea here:\\n\\nTip:\\n- In a array of strings\\n- Store what all starting characters can the IdeaA accept as a pair and IdeaB accept as a pair in a dict of dicts.\\n- Now, we know what all characters ideaA can accept. But we also need to know what all characters can IdeaB accept. So, design a structure similar to this:\\n\\nInput: A = [\"hogs\", \"dairy\", \"pairy\"]\\nHM1 = {\"hogs\": {p, d}, \"dairy\": {h}, \"pairy\": {h}}\\nHM2 = {d: {h: 1}, h: {d: 1, p: 1}, p: {h: 1}}\\n\\nHM2 gives information about how many characters can a string be replaced with.\\nFor eg: \\n- In case of strings starting with d, they can only be coupled with a string starting with letter h\\n- In case of strings starting with h, they can be coupled with 1 string starting with d, p.\\n- In case of strings starting with p, they can only be coupled with 1 string starting with h\\n\\nHope this helps!\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "O(n*m) solution passes 89/89 testcases and gets TLE? Mine was not as elegant as the official solution, but that seems like a little much."
                    },
                    {
                        "username": "paraskumar_12",
                        "content": "Me: \"This problem is easy\"\\nle TLE:  Hold my cup."
                    },
                    {
                        "username": "niteshsingh29",
                        "content": "Hi guyz, is it accepting O(n^2) ??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Nope ;)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The given hints are inaccurate. They suggest grouping by suffix, which gives me TLE. Then I tried to group by prefix, and that passed the tests.\\nThe Official Solution is also done by prefix-grouping, why is the hint misleading:("
                    }
                ]
            },
            {
                "id": 1794842,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Weird question T_T"
                    },
                    {
                        "username": "huanpipt",
                        "content": "I follow the hint and group ideas by suffix, which leads to TLE. After struggling one hour, I changed to group by prefix. Pass!"
                    },
                    {
                        "username": "yashuagroya",
                        "content": "Why is there a time limit\\ntime limit is the only thing difficult to solve"
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "I have a major headache after solving this .... but the satisfaction is worth it !!"
                    },
                    {
                        "username": "ashleymavericks",
                        "content": "Me: Why is it a Hard problem, why, why ???\nLC : TLE\nMe: Ohh, that's why :facepalm:"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Looking at constraints, O(n^2) might give a TLE!\\n\\nI came up with O(26*N) soln. Many tips in discussion is about suffix matching. Could not find some with prefix counting. So, adding my idea here:\\n\\nTip:\\n- In a array of strings\\n- Store what all starting characters can the IdeaA accept as a pair and IdeaB accept as a pair in a dict of dicts.\\n- Now, we know what all characters ideaA can accept. But we also need to know what all characters can IdeaB accept. So, design a structure similar to this:\\n\\nInput: A = [\"hogs\", \"dairy\", \"pairy\"]\\nHM1 = {\"hogs\": {p, d}, \"dairy\": {h}, \"pairy\": {h}}\\nHM2 = {d: {h: 1}, h: {d: 1, p: 1}, p: {h: 1}}\\n\\nHM2 gives information about how many characters can a string be replaced with.\\nFor eg: \\n- In case of strings starting with d, they can only be coupled with a string starting with letter h\\n- In case of strings starting with h, they can be coupled with 1 string starting with d, p.\\n- In case of strings starting with p, they can only be coupled with 1 string starting with h\\n\\nHope this helps!\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "O(n*m) solution passes 89/89 testcases and gets TLE? Mine was not as elegant as the official solution, but that seems like a little much."
                    },
                    {
                        "username": "paraskumar_12",
                        "content": "Me: \"This problem is easy\"\\nle TLE:  Hold my cup."
                    },
                    {
                        "username": "niteshsingh29",
                        "content": "Hi guyz, is it accepting O(n^2) ??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Nope ;)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The given hints are inaccurate. They suggest grouping by suffix, which gives me TLE. Then I tried to group by prefix, and that passed the tests.\\nThe Official Solution is also done by prefix-grouping, why is the hint misleading:("
                    }
                ]
            },
            {
                "id": 1794838,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Weird question T_T"
                    },
                    {
                        "username": "huanpipt",
                        "content": "I follow the hint and group ideas by suffix, which leads to TLE. After struggling one hour, I changed to group by prefix. Pass!"
                    },
                    {
                        "username": "yashuagroya",
                        "content": "Why is there a time limit\\ntime limit is the only thing difficult to solve"
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "I have a major headache after solving this .... but the satisfaction is worth it !!"
                    },
                    {
                        "username": "ashleymavericks",
                        "content": "Me: Why is it a Hard problem, why, why ???\nLC : TLE\nMe: Ohh, that's why :facepalm:"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Looking at constraints, O(n^2) might give a TLE!\\n\\nI came up with O(26*N) soln. Many tips in discussion is about suffix matching. Could not find some with prefix counting. So, adding my idea here:\\n\\nTip:\\n- In a array of strings\\n- Store what all starting characters can the IdeaA accept as a pair and IdeaB accept as a pair in a dict of dicts.\\n- Now, we know what all characters ideaA can accept. But we also need to know what all characters can IdeaB accept. So, design a structure similar to this:\\n\\nInput: A = [\"hogs\", \"dairy\", \"pairy\"]\\nHM1 = {\"hogs\": {p, d}, \"dairy\": {h}, \"pairy\": {h}}\\nHM2 = {d: {h: 1}, h: {d: 1, p: 1}, p: {h: 1}}\\n\\nHM2 gives information about how many characters can a string be replaced with.\\nFor eg: \\n- In case of strings starting with d, they can only be coupled with a string starting with letter h\\n- In case of strings starting with h, they can be coupled with 1 string starting with d, p.\\n- In case of strings starting with p, they can only be coupled with 1 string starting with h\\n\\nHope this helps!\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "O(n*m) solution passes 89/89 testcases and gets TLE? Mine was not as elegant as the official solution, but that seems like a little much."
                    },
                    {
                        "username": "paraskumar_12",
                        "content": "Me: \"This problem is easy\"\\nle TLE:  Hold my cup."
                    },
                    {
                        "username": "niteshsingh29",
                        "content": "Hi guyz, is it accepting O(n^2) ??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Nope ;)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The given hints are inaccurate. They suggest grouping by suffix, which gives me TLE. Then I tried to group by prefix, and that passed the tests.\\nThe Official Solution is also done by prefix-grouping, why is the hint misleading:("
                    }
                ]
            },
            {
                "id": 1794777,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Weird question T_T"
                    },
                    {
                        "username": "huanpipt",
                        "content": "I follow the hint and group ideas by suffix, which leads to TLE. After struggling one hour, I changed to group by prefix. Pass!"
                    },
                    {
                        "username": "yashuagroya",
                        "content": "Why is there a time limit\\ntime limit is the only thing difficult to solve"
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "I have a major headache after solving this .... but the satisfaction is worth it !!"
                    },
                    {
                        "username": "ashleymavericks",
                        "content": "Me: Why is it a Hard problem, why, why ???\nLC : TLE\nMe: Ohh, that's why :facepalm:"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Looking at constraints, O(n^2) might give a TLE!\\n\\nI came up with O(26*N) soln. Many tips in discussion is about suffix matching. Could not find some with prefix counting. So, adding my idea here:\\n\\nTip:\\n- In a array of strings\\n- Store what all starting characters can the IdeaA accept as a pair and IdeaB accept as a pair in a dict of dicts.\\n- Now, we know what all characters ideaA can accept. But we also need to know what all characters can IdeaB accept. So, design a structure similar to this:\\n\\nInput: A = [\"hogs\", \"dairy\", \"pairy\"]\\nHM1 = {\"hogs\": {p, d}, \"dairy\": {h}, \"pairy\": {h}}\\nHM2 = {d: {h: 1}, h: {d: 1, p: 1}, p: {h: 1}}\\n\\nHM2 gives information about how many characters can a string be replaced with.\\nFor eg: \\n- In case of strings starting with d, they can only be coupled with a string starting with letter h\\n- In case of strings starting with h, they can be coupled with 1 string starting with d, p.\\n- In case of strings starting with p, they can only be coupled with 1 string starting with h\\n\\nHope this helps!\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "O(n*m) solution passes 89/89 testcases and gets TLE? Mine was not as elegant as the official solution, but that seems like a little much."
                    },
                    {
                        "username": "paraskumar_12",
                        "content": "Me: \"This problem is easy\"\\nle TLE:  Hold my cup."
                    },
                    {
                        "username": "niteshsingh29",
                        "content": "Hi guyz, is it accepting O(n^2) ??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Nope ;)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The given hints are inaccurate. They suggest grouping by suffix, which gives me TLE. Then I tried to group by prefix, and that passed the tests.\\nThe Official Solution is also done by prefix-grouping, why is the hint misleading:("
                    }
                ]
            },
            {
                "id": 1794775,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Weird question T_T"
                    },
                    {
                        "username": "huanpipt",
                        "content": "I follow the hint and group ideas by suffix, which leads to TLE. After struggling one hour, I changed to group by prefix. Pass!"
                    },
                    {
                        "username": "yashuagroya",
                        "content": "Why is there a time limit\\ntime limit is the only thing difficult to solve"
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "I have a major headache after solving this .... but the satisfaction is worth it !!"
                    },
                    {
                        "username": "ashleymavericks",
                        "content": "Me: Why is it a Hard problem, why, why ???\nLC : TLE\nMe: Ohh, that's why :facepalm:"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Looking at constraints, O(n^2) might give a TLE!\\n\\nI came up with O(26*N) soln. Many tips in discussion is about suffix matching. Could not find some with prefix counting. So, adding my idea here:\\n\\nTip:\\n- In a array of strings\\n- Store what all starting characters can the IdeaA accept as a pair and IdeaB accept as a pair in a dict of dicts.\\n- Now, we know what all characters ideaA can accept. But we also need to know what all characters can IdeaB accept. So, design a structure similar to this:\\n\\nInput: A = [\"hogs\", \"dairy\", \"pairy\"]\\nHM1 = {\"hogs\": {p, d}, \"dairy\": {h}, \"pairy\": {h}}\\nHM2 = {d: {h: 1}, h: {d: 1, p: 1}, p: {h: 1}}\\n\\nHM2 gives information about how many characters can a string be replaced with.\\nFor eg: \\n- In case of strings starting with d, they can only be coupled with a string starting with letter h\\n- In case of strings starting with h, they can be coupled with 1 string starting with d, p.\\n- In case of strings starting with p, they can only be coupled with 1 string starting with h\\n\\nHope this helps!\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "O(n*m) solution passes 89/89 testcases and gets TLE? Mine was not as elegant as the official solution, but that seems like a little much."
                    },
                    {
                        "username": "paraskumar_12",
                        "content": "Me: \"This problem is easy\"\\nle TLE:  Hold my cup."
                    },
                    {
                        "username": "niteshsingh29",
                        "content": "Hi guyz, is it accepting O(n^2) ??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Nope ;)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The given hints are inaccurate. They suggest grouping by suffix, which gives me TLE. Then I tried to group by prefix, and that passed the tests.\\nThe Official Solution is also done by prefix-grouping, why is the hint misleading:("
                    }
                ]
            },
            {
                "id": 1794680,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Weird question T_T"
                    },
                    {
                        "username": "huanpipt",
                        "content": "I follow the hint and group ideas by suffix, which leads to TLE. After struggling one hour, I changed to group by prefix. Pass!"
                    },
                    {
                        "username": "yashuagroya",
                        "content": "Why is there a time limit\\ntime limit is the only thing difficult to solve"
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "I have a major headache after solving this .... but the satisfaction is worth it !!"
                    },
                    {
                        "username": "ashleymavericks",
                        "content": "Me: Why is it a Hard problem, why, why ???\nLC : TLE\nMe: Ohh, that's why :facepalm:"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Looking at constraints, O(n^2) might give a TLE!\\n\\nI came up with O(26*N) soln. Many tips in discussion is about suffix matching. Could not find some with prefix counting. So, adding my idea here:\\n\\nTip:\\n- In a array of strings\\n- Store what all starting characters can the IdeaA accept as a pair and IdeaB accept as a pair in a dict of dicts.\\n- Now, we know what all characters ideaA can accept. But we also need to know what all characters can IdeaB accept. So, design a structure similar to this:\\n\\nInput: A = [\"hogs\", \"dairy\", \"pairy\"]\\nHM1 = {\"hogs\": {p, d}, \"dairy\": {h}, \"pairy\": {h}}\\nHM2 = {d: {h: 1}, h: {d: 1, p: 1}, p: {h: 1}}\\n\\nHM2 gives information about how many characters can a string be replaced with.\\nFor eg: \\n- In case of strings starting with d, they can only be coupled with a string starting with letter h\\n- In case of strings starting with h, they can be coupled with 1 string starting with d, p.\\n- In case of strings starting with p, they can only be coupled with 1 string starting with h\\n\\nHope this helps!\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "O(n*m) solution passes 89/89 testcases and gets TLE? Mine was not as elegant as the official solution, but that seems like a little much."
                    },
                    {
                        "username": "paraskumar_12",
                        "content": "Me: \"This problem is easy\"\\nle TLE:  Hold my cup."
                    },
                    {
                        "username": "niteshsingh29",
                        "content": "Hi guyz, is it accepting O(n^2) ??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Nope ;)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The given hints are inaccurate. They suggest grouping by suffix, which gives me TLE. Then I tried to group by prefix, and that passed the tests.\\nThe Official Solution is also done by prefix-grouping, why is the hint misleading:("
                    }
                ]
            },
            {
                "id": 1794664,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Weird question T_T"
                    },
                    {
                        "username": "huanpipt",
                        "content": "I follow the hint and group ideas by suffix, which leads to TLE. After struggling one hour, I changed to group by prefix. Pass!"
                    },
                    {
                        "username": "yashuagroya",
                        "content": "Why is there a time limit\\ntime limit is the only thing difficult to solve"
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "I have a major headache after solving this .... but the satisfaction is worth it !!"
                    },
                    {
                        "username": "ashleymavericks",
                        "content": "Me: Why is it a Hard problem, why, why ???\nLC : TLE\nMe: Ohh, that's why :facepalm:"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Looking at constraints, O(n^2) might give a TLE!\\n\\nI came up with O(26*N) soln. Many tips in discussion is about suffix matching. Could not find some with prefix counting. So, adding my idea here:\\n\\nTip:\\n- In a array of strings\\n- Store what all starting characters can the IdeaA accept as a pair and IdeaB accept as a pair in a dict of dicts.\\n- Now, we know what all characters ideaA can accept. But we also need to know what all characters can IdeaB accept. So, design a structure similar to this:\\n\\nInput: A = [\"hogs\", \"dairy\", \"pairy\"]\\nHM1 = {\"hogs\": {p, d}, \"dairy\": {h}, \"pairy\": {h}}\\nHM2 = {d: {h: 1}, h: {d: 1, p: 1}, p: {h: 1}}\\n\\nHM2 gives information about how many characters can a string be replaced with.\\nFor eg: \\n- In case of strings starting with d, they can only be coupled with a string starting with letter h\\n- In case of strings starting with h, they can be coupled with 1 string starting with d, p.\\n- In case of strings starting with p, they can only be coupled with 1 string starting with h\\n\\nHope this helps!\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "O(n*m) solution passes 89/89 testcases and gets TLE? Mine was not as elegant as the official solution, but that seems like a little much."
                    },
                    {
                        "username": "paraskumar_12",
                        "content": "Me: \"This problem is easy\"\\nle TLE:  Hold my cup."
                    },
                    {
                        "username": "niteshsingh29",
                        "content": "Hi guyz, is it accepting O(n^2) ??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Nope ;)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The given hints are inaccurate. They suggest grouping by suffix, which gives me TLE. Then I tried to group by prefix, and that passed the tests.\\nThe Official Solution is also done by prefix-grouping, why is the hint misleading:("
                    }
                ]
            },
            {
                "id": 1794663,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Weird question T_T"
                    },
                    {
                        "username": "huanpipt",
                        "content": "I follow the hint and group ideas by suffix, which leads to TLE. After struggling one hour, I changed to group by prefix. Pass!"
                    },
                    {
                        "username": "yashuagroya",
                        "content": "Why is there a time limit\\ntime limit is the only thing difficult to solve"
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "I have a major headache after solving this .... but the satisfaction is worth it !!"
                    },
                    {
                        "username": "ashleymavericks",
                        "content": "Me: Why is it a Hard problem, why, why ???\nLC : TLE\nMe: Ohh, that's why :facepalm:"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Looking at constraints, O(n^2) might give a TLE!\\n\\nI came up with O(26*N) soln. Many tips in discussion is about suffix matching. Could not find some with prefix counting. So, adding my idea here:\\n\\nTip:\\n- In a array of strings\\n- Store what all starting characters can the IdeaA accept as a pair and IdeaB accept as a pair in a dict of dicts.\\n- Now, we know what all characters ideaA can accept. But we also need to know what all characters can IdeaB accept. So, design a structure similar to this:\\n\\nInput: A = [\"hogs\", \"dairy\", \"pairy\"]\\nHM1 = {\"hogs\": {p, d}, \"dairy\": {h}, \"pairy\": {h}}\\nHM2 = {d: {h: 1}, h: {d: 1, p: 1}, p: {h: 1}}\\n\\nHM2 gives information about how many characters can a string be replaced with.\\nFor eg: \\n- In case of strings starting with d, they can only be coupled with a string starting with letter h\\n- In case of strings starting with h, they can be coupled with 1 string starting with d, p.\\n- In case of strings starting with p, they can only be coupled with 1 string starting with h\\n\\nHope this helps!\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "O(n*m) solution passes 89/89 testcases and gets TLE? Mine was not as elegant as the official solution, but that seems like a little much."
                    },
                    {
                        "username": "paraskumar_12",
                        "content": "Me: \"This problem is easy\"\\nle TLE:  Hold my cup."
                    },
                    {
                        "username": "niteshsingh29",
                        "content": "Hi guyz, is it accepting O(n^2) ??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Nope ;)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The given hints are inaccurate. They suggest grouping by suffix, which gives me TLE. Then I tried to group by prefix, and that passed the tests.\\nThe Official Solution is also done by prefix-grouping, why is the hint misleading:("
                    }
                ]
            },
            {
                "id": 1794638,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "Weird question T_T"
                    },
                    {
                        "username": "huanpipt",
                        "content": "I follow the hint and group ideas by suffix, which leads to TLE. After struggling one hour, I changed to group by prefix. Pass!"
                    },
                    {
                        "username": "yashuagroya",
                        "content": "Why is there a time limit\\ntime limit is the only thing difficult to solve"
                    },
                    {
                        "username": "garv_luthra_19",
                        "content": "I have a major headache after solving this .... but the satisfaction is worth it !!"
                    },
                    {
                        "username": "ashleymavericks",
                        "content": "Me: Why is it a Hard problem, why, why ???\nLC : TLE\nMe: Ohh, that's why :facepalm:"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Looking at constraints, O(n^2) might give a TLE!\\n\\nI came up with O(26*N) soln. Many tips in discussion is about suffix matching. Could not find some with prefix counting. So, adding my idea here:\\n\\nTip:\\n- In a array of strings\\n- Store what all starting characters can the IdeaA accept as a pair and IdeaB accept as a pair in a dict of dicts.\\n- Now, we know what all characters ideaA can accept. But we also need to know what all characters can IdeaB accept. So, design a structure similar to this:\\n\\nInput: A = [\"hogs\", \"dairy\", \"pairy\"]\\nHM1 = {\"hogs\": {p, d}, \"dairy\": {h}, \"pairy\": {h}}\\nHM2 = {d: {h: 1}, h: {d: 1, p: 1}, p: {h: 1}}\\n\\nHM2 gives information about how many characters can a string be replaced with.\\nFor eg: \\n- In case of strings starting with d, they can only be coupled with a string starting with letter h\\n- In case of strings starting with h, they can be coupled with 1 string starting with d, p.\\n- In case of strings starting with p, they can only be coupled with 1 string starting with h\\n\\nHope this helps!\\n"
                    },
                    {
                        "username": "AMerrill",
                        "content": "O(n*m) solution passes 89/89 testcases and gets TLE? Mine was not as elegant as the official solution, but that seems like a little much."
                    },
                    {
                        "username": "paraskumar_12",
                        "content": "Me: \"This problem is easy\"\\nle TLE:  Hold my cup."
                    },
                    {
                        "username": "niteshsingh29",
                        "content": "Hi guyz, is it accepting O(n^2) ??"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Nope ;)"
                    },
                    {
                        "username": "xeniawann",
                        "content": "The given hints are inaccurate. They suggest grouping by suffix, which gives me TLE. Then I tried to group by prefix, and that passed the tests.\\nThe Official Solution is also done by prefix-grouping, why is the hint misleading:("
                    }
                ]
            },
            {
                "id": 1794583,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This question is a headache for me, tried searching for some tips in the discuss but was still confuse "
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@rajan_jasani9](/rajan_jasani9) It seems like no amount of optimization will really work. Either you get the intended solution or you don\\'t. Mine was O(n*m), passed all testcases and got TLE."
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Agreed, Optimization is really frustrating stuck on testcase 78"
                    },
                    {
                        "username": "FeedNet",
                        "content": "Can anyone explain why my code is undershooting the answer for some testcases? Not sure if I'm missing a specific case:\nThanks in advance for any help (I know this is naive solution, just not sure why it's getting W/A).\n```class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        final = set()\n        ideaMap = {x:0 for x in ideas}\n        for index,name1 in enumerate(ideas):\n            for j in range(index+1,n):\n                name2 = ideas[j]\n                new1 = name2[0] + name1[1:]\n                new2 = name1[0] + name2[1:]\n                #print(new1,new2)\n                if new1 not in ideaMap and new2 not in ideaMap:\n                    combine1 = new1+new2\n                    combine2 = new2+new1\n                    final.add(combine1)\n                    final.add(combine2)\n        #print(final)\n        return len(final)```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "#One of simple approach\n``` dictionary []\n\nideas = [\"co\",\"de\",\"ce\",\"da\",\"ti\",\"to\"], \nmap all of the first letter of given words (followed by the suffixes):\ndic['c']={o,e}\ndic['d']={e,a}\ndic['t']={i,o}\n\nThen, just verify the difference of each defined suffix set, for example: \ndic['c']={'o','e'}\ndic['d']={'e','a'}\n\nWe have {'o'}, {'a'} are the difference of both checked sets\nans+= len{'o'} * len{'a'} *2\n'2' stands for a switch order.\n\ndic['d']={e,a}\ndic['t']={i,o}\nans+= len{e,a}* len{i,o} *2\n\nand so on...\n\nTry to run dry test on:\nideas =[\"c\",\"t\",\"to\"], then go for submit. \n```\nGood luck."
                    },
                    {
                        "username": "shivamguptacoder",
                        "content": "I thought of Using a TRIE data structure for this question ."
                    },
                    {
                        "username": "stefann01",
                        "content": "And whats the conclusion?"
                    },
                    {
                        "username": "madhes23",
                        "content": "# HINT\\nJust compare all the pairs, but that would lead to TLE.\\n1. But, does all of those n*n comparisons required? \\n2. Can we eliminate some of the comparisons? \\n3. Is there a way to select the valid pair of strings?\\n\\n**How to find the useless comparison?**\\n(mat, cat) and (cat, cable) : in these two which one is use less comparison?\\n\\n_Big jump in idea, not easy to get it_\\nIf you group strings by their first character, would it any insight on invalid pair of strings? \\nHow to find the invalid pair strings? \\n\\n\\n**Spoilers below**\\nInvalid -> not satisfy the given condition after swapping -> either one of the string is present in the either of the selected group"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "can someone tell me the exact code of brute force approach?"
                    },
                    {
                        "username": "Maninder_4",
                        "content": " long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> m;\\n        for(auto i:ideas){\\n            m[i]++;\\n        }\\n        long long ans =0;\\n        for(int i = 0;i<ideas.size();i++){\\n            for(int j = 0;j<ideas.size();j++){\\n                if(j == i){\\n                    continue;\\n                }\\n                string s1 = ideas[i];\\n                string s2 = ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(m.find(s1) == m.end() && m.find(s2)==m.end()){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Hashbaer",
                        "content": "I\\'m not sure but I guess you need O(n) time Complexity "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Being happy that you solved a hard question?\\n*TIME LIMIT EXCEEDED* guess who\\'s back?"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Everyone :Discussing TLE\nMe  without realization :  `Name1[0], Name2[0] = Name2[0], Name[1]`  \nWhy am i getting error :( \n\nIf you know, you know\n\n"
                    },
                    {
                        "username": "Jaswanth_bammidi",
                        "content": "i have written the complete code and executed in 5 minutes.sudden if has showed me time limit exceeded aadhi dhaa surprise."
                    },
                    {
                        "username": "sanskarshrm",
                        "content": "lol same with me\\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1794572,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This question is a headache for me, tried searching for some tips in the discuss but was still confuse "
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@rajan_jasani9](/rajan_jasani9) It seems like no amount of optimization will really work. Either you get the intended solution or you don\\'t. Mine was O(n*m), passed all testcases and got TLE."
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Agreed, Optimization is really frustrating stuck on testcase 78"
                    },
                    {
                        "username": "FeedNet",
                        "content": "Can anyone explain why my code is undershooting the answer for some testcases? Not sure if I'm missing a specific case:\nThanks in advance for any help (I know this is naive solution, just not sure why it's getting W/A).\n```class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        final = set()\n        ideaMap = {x:0 for x in ideas}\n        for index,name1 in enumerate(ideas):\n            for j in range(index+1,n):\n                name2 = ideas[j]\n                new1 = name2[0] + name1[1:]\n                new2 = name1[0] + name2[1:]\n                #print(new1,new2)\n                if new1 not in ideaMap and new2 not in ideaMap:\n                    combine1 = new1+new2\n                    combine2 = new2+new1\n                    final.add(combine1)\n                    final.add(combine2)\n        #print(final)\n        return len(final)```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "#One of simple approach\n``` dictionary []\n\nideas = [\"co\",\"de\",\"ce\",\"da\",\"ti\",\"to\"], \nmap all of the first letter of given words (followed by the suffixes):\ndic['c']={o,e}\ndic['d']={e,a}\ndic['t']={i,o}\n\nThen, just verify the difference of each defined suffix set, for example: \ndic['c']={'o','e'}\ndic['d']={'e','a'}\n\nWe have {'o'}, {'a'} are the difference of both checked sets\nans+= len{'o'} * len{'a'} *2\n'2' stands for a switch order.\n\ndic['d']={e,a}\ndic['t']={i,o}\nans+= len{e,a}* len{i,o} *2\n\nand so on...\n\nTry to run dry test on:\nideas =[\"c\",\"t\",\"to\"], then go for submit. \n```\nGood luck."
                    },
                    {
                        "username": "shivamguptacoder",
                        "content": "I thought of Using a TRIE data structure for this question ."
                    },
                    {
                        "username": "stefann01",
                        "content": "And whats the conclusion?"
                    },
                    {
                        "username": "madhes23",
                        "content": "# HINT\\nJust compare all the pairs, but that would lead to TLE.\\n1. But, does all of those n*n comparisons required? \\n2. Can we eliminate some of the comparisons? \\n3. Is there a way to select the valid pair of strings?\\n\\n**How to find the useless comparison?**\\n(mat, cat) and (cat, cable) : in these two which one is use less comparison?\\n\\n_Big jump in idea, not easy to get it_\\nIf you group strings by their first character, would it any insight on invalid pair of strings? \\nHow to find the invalid pair strings? \\n\\n\\n**Spoilers below**\\nInvalid -> not satisfy the given condition after swapping -> either one of the string is present in the either of the selected group"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "can someone tell me the exact code of brute force approach?"
                    },
                    {
                        "username": "Maninder_4",
                        "content": " long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> m;\\n        for(auto i:ideas){\\n            m[i]++;\\n        }\\n        long long ans =0;\\n        for(int i = 0;i<ideas.size();i++){\\n            for(int j = 0;j<ideas.size();j++){\\n                if(j == i){\\n                    continue;\\n                }\\n                string s1 = ideas[i];\\n                string s2 = ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(m.find(s1) == m.end() && m.find(s2)==m.end()){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Hashbaer",
                        "content": "I\\'m not sure but I guess you need O(n) time Complexity "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Being happy that you solved a hard question?\\n*TIME LIMIT EXCEEDED* guess who\\'s back?"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Everyone :Discussing TLE\nMe  without realization :  `Name1[0], Name2[0] = Name2[0], Name[1]`  \nWhy am i getting error :( \n\nIf you know, you know\n\n"
                    },
                    {
                        "username": "Jaswanth_bammidi",
                        "content": "i have written the complete code and executed in 5 minutes.sudden if has showed me time limit exceeded aadhi dhaa surprise."
                    },
                    {
                        "username": "sanskarshrm",
                        "content": "lol same with me\\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1794532,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This question is a headache for me, tried searching for some tips in the discuss but was still confuse "
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@rajan_jasani9](/rajan_jasani9) It seems like no amount of optimization will really work. Either you get the intended solution or you don\\'t. Mine was O(n*m), passed all testcases and got TLE."
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Agreed, Optimization is really frustrating stuck on testcase 78"
                    },
                    {
                        "username": "FeedNet",
                        "content": "Can anyone explain why my code is undershooting the answer for some testcases? Not sure if I'm missing a specific case:\nThanks in advance for any help (I know this is naive solution, just not sure why it's getting W/A).\n```class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        final = set()\n        ideaMap = {x:0 for x in ideas}\n        for index,name1 in enumerate(ideas):\n            for j in range(index+1,n):\n                name2 = ideas[j]\n                new1 = name2[0] + name1[1:]\n                new2 = name1[0] + name2[1:]\n                #print(new1,new2)\n                if new1 not in ideaMap and new2 not in ideaMap:\n                    combine1 = new1+new2\n                    combine2 = new2+new1\n                    final.add(combine1)\n                    final.add(combine2)\n        #print(final)\n        return len(final)```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "#One of simple approach\n``` dictionary []\n\nideas = [\"co\",\"de\",\"ce\",\"da\",\"ti\",\"to\"], \nmap all of the first letter of given words (followed by the suffixes):\ndic['c']={o,e}\ndic['d']={e,a}\ndic['t']={i,o}\n\nThen, just verify the difference of each defined suffix set, for example: \ndic['c']={'o','e'}\ndic['d']={'e','a'}\n\nWe have {'o'}, {'a'} are the difference of both checked sets\nans+= len{'o'} * len{'a'} *2\n'2' stands for a switch order.\n\ndic['d']={e,a}\ndic['t']={i,o}\nans+= len{e,a}* len{i,o} *2\n\nand so on...\n\nTry to run dry test on:\nideas =[\"c\",\"t\",\"to\"], then go for submit. \n```\nGood luck."
                    },
                    {
                        "username": "shivamguptacoder",
                        "content": "I thought of Using a TRIE data structure for this question ."
                    },
                    {
                        "username": "stefann01",
                        "content": "And whats the conclusion?"
                    },
                    {
                        "username": "madhes23",
                        "content": "# HINT\\nJust compare all the pairs, but that would lead to TLE.\\n1. But, does all of those n*n comparisons required? \\n2. Can we eliminate some of the comparisons? \\n3. Is there a way to select the valid pair of strings?\\n\\n**How to find the useless comparison?**\\n(mat, cat) and (cat, cable) : in these two which one is use less comparison?\\n\\n_Big jump in idea, not easy to get it_\\nIf you group strings by their first character, would it any insight on invalid pair of strings? \\nHow to find the invalid pair strings? \\n\\n\\n**Spoilers below**\\nInvalid -> not satisfy the given condition after swapping -> either one of the string is present in the either of the selected group"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "can someone tell me the exact code of brute force approach?"
                    },
                    {
                        "username": "Maninder_4",
                        "content": " long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> m;\\n        for(auto i:ideas){\\n            m[i]++;\\n        }\\n        long long ans =0;\\n        for(int i = 0;i<ideas.size();i++){\\n            for(int j = 0;j<ideas.size();j++){\\n                if(j == i){\\n                    continue;\\n                }\\n                string s1 = ideas[i];\\n                string s2 = ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(m.find(s1) == m.end() && m.find(s2)==m.end()){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Hashbaer",
                        "content": "I\\'m not sure but I guess you need O(n) time Complexity "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Being happy that you solved a hard question?\\n*TIME LIMIT EXCEEDED* guess who\\'s back?"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Everyone :Discussing TLE\nMe  without realization :  `Name1[0], Name2[0] = Name2[0], Name[1]`  \nWhy am i getting error :( \n\nIf you know, you know\n\n"
                    },
                    {
                        "username": "Jaswanth_bammidi",
                        "content": "i have written the complete code and executed in 5 minutes.sudden if has showed me time limit exceeded aadhi dhaa surprise."
                    },
                    {
                        "username": "sanskarshrm",
                        "content": "lol same with me\\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1794528,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This question is a headache for me, tried searching for some tips in the discuss but was still confuse "
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@rajan_jasani9](/rajan_jasani9) It seems like no amount of optimization will really work. Either you get the intended solution or you don\\'t. Mine was O(n*m), passed all testcases and got TLE."
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Agreed, Optimization is really frustrating stuck on testcase 78"
                    },
                    {
                        "username": "FeedNet",
                        "content": "Can anyone explain why my code is undershooting the answer for some testcases? Not sure if I'm missing a specific case:\nThanks in advance for any help (I know this is naive solution, just not sure why it's getting W/A).\n```class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        final = set()\n        ideaMap = {x:0 for x in ideas}\n        for index,name1 in enumerate(ideas):\n            for j in range(index+1,n):\n                name2 = ideas[j]\n                new1 = name2[0] + name1[1:]\n                new2 = name1[0] + name2[1:]\n                #print(new1,new2)\n                if new1 not in ideaMap and new2 not in ideaMap:\n                    combine1 = new1+new2\n                    combine2 = new2+new1\n                    final.add(combine1)\n                    final.add(combine2)\n        #print(final)\n        return len(final)```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "#One of simple approach\n``` dictionary []\n\nideas = [\"co\",\"de\",\"ce\",\"da\",\"ti\",\"to\"], \nmap all of the first letter of given words (followed by the suffixes):\ndic['c']={o,e}\ndic['d']={e,a}\ndic['t']={i,o}\n\nThen, just verify the difference of each defined suffix set, for example: \ndic['c']={'o','e'}\ndic['d']={'e','a'}\n\nWe have {'o'}, {'a'} are the difference of both checked sets\nans+= len{'o'} * len{'a'} *2\n'2' stands for a switch order.\n\ndic['d']={e,a}\ndic['t']={i,o}\nans+= len{e,a}* len{i,o} *2\n\nand so on...\n\nTry to run dry test on:\nideas =[\"c\",\"t\",\"to\"], then go for submit. \n```\nGood luck."
                    },
                    {
                        "username": "shivamguptacoder",
                        "content": "I thought of Using a TRIE data structure for this question ."
                    },
                    {
                        "username": "stefann01",
                        "content": "And whats the conclusion?"
                    },
                    {
                        "username": "madhes23",
                        "content": "# HINT\\nJust compare all the pairs, but that would lead to TLE.\\n1. But, does all of those n*n comparisons required? \\n2. Can we eliminate some of the comparisons? \\n3. Is there a way to select the valid pair of strings?\\n\\n**How to find the useless comparison?**\\n(mat, cat) and (cat, cable) : in these two which one is use less comparison?\\n\\n_Big jump in idea, not easy to get it_\\nIf you group strings by their first character, would it any insight on invalid pair of strings? \\nHow to find the invalid pair strings? \\n\\n\\n**Spoilers below**\\nInvalid -> not satisfy the given condition after swapping -> either one of the string is present in the either of the selected group"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "can someone tell me the exact code of brute force approach?"
                    },
                    {
                        "username": "Maninder_4",
                        "content": " long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> m;\\n        for(auto i:ideas){\\n            m[i]++;\\n        }\\n        long long ans =0;\\n        for(int i = 0;i<ideas.size();i++){\\n            for(int j = 0;j<ideas.size();j++){\\n                if(j == i){\\n                    continue;\\n                }\\n                string s1 = ideas[i];\\n                string s2 = ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(m.find(s1) == m.end() && m.find(s2)==m.end()){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Hashbaer",
                        "content": "I\\'m not sure but I guess you need O(n) time Complexity "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Being happy that you solved a hard question?\\n*TIME LIMIT EXCEEDED* guess who\\'s back?"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Everyone :Discussing TLE\nMe  without realization :  `Name1[0], Name2[0] = Name2[0], Name[1]`  \nWhy am i getting error :( \n\nIf you know, you know\n\n"
                    },
                    {
                        "username": "Jaswanth_bammidi",
                        "content": "i have written the complete code and executed in 5 minutes.sudden if has showed me time limit exceeded aadhi dhaa surprise."
                    },
                    {
                        "username": "sanskarshrm",
                        "content": "lol same with me\\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1794521,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This question is a headache for me, tried searching for some tips in the discuss but was still confuse "
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@rajan_jasani9](/rajan_jasani9) It seems like no amount of optimization will really work. Either you get the intended solution or you don\\'t. Mine was O(n*m), passed all testcases and got TLE."
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Agreed, Optimization is really frustrating stuck on testcase 78"
                    },
                    {
                        "username": "FeedNet",
                        "content": "Can anyone explain why my code is undershooting the answer for some testcases? Not sure if I'm missing a specific case:\nThanks in advance for any help (I know this is naive solution, just not sure why it's getting W/A).\n```class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        final = set()\n        ideaMap = {x:0 for x in ideas}\n        for index,name1 in enumerate(ideas):\n            for j in range(index+1,n):\n                name2 = ideas[j]\n                new1 = name2[0] + name1[1:]\n                new2 = name1[0] + name2[1:]\n                #print(new1,new2)\n                if new1 not in ideaMap and new2 not in ideaMap:\n                    combine1 = new1+new2\n                    combine2 = new2+new1\n                    final.add(combine1)\n                    final.add(combine2)\n        #print(final)\n        return len(final)```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "#One of simple approach\n``` dictionary []\n\nideas = [\"co\",\"de\",\"ce\",\"da\",\"ti\",\"to\"], \nmap all of the first letter of given words (followed by the suffixes):\ndic['c']={o,e}\ndic['d']={e,a}\ndic['t']={i,o}\n\nThen, just verify the difference of each defined suffix set, for example: \ndic['c']={'o','e'}\ndic['d']={'e','a'}\n\nWe have {'o'}, {'a'} are the difference of both checked sets\nans+= len{'o'} * len{'a'} *2\n'2' stands for a switch order.\n\ndic['d']={e,a}\ndic['t']={i,o}\nans+= len{e,a}* len{i,o} *2\n\nand so on...\n\nTry to run dry test on:\nideas =[\"c\",\"t\",\"to\"], then go for submit. \n```\nGood luck."
                    },
                    {
                        "username": "shivamguptacoder",
                        "content": "I thought of Using a TRIE data structure for this question ."
                    },
                    {
                        "username": "stefann01",
                        "content": "And whats the conclusion?"
                    },
                    {
                        "username": "madhes23",
                        "content": "# HINT\\nJust compare all the pairs, but that would lead to TLE.\\n1. But, does all of those n*n comparisons required? \\n2. Can we eliminate some of the comparisons? \\n3. Is there a way to select the valid pair of strings?\\n\\n**How to find the useless comparison?**\\n(mat, cat) and (cat, cable) : in these two which one is use less comparison?\\n\\n_Big jump in idea, not easy to get it_\\nIf you group strings by their first character, would it any insight on invalid pair of strings? \\nHow to find the invalid pair strings? \\n\\n\\n**Spoilers below**\\nInvalid -> not satisfy the given condition after swapping -> either one of the string is present in the either of the selected group"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "can someone tell me the exact code of brute force approach?"
                    },
                    {
                        "username": "Maninder_4",
                        "content": " long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> m;\\n        for(auto i:ideas){\\n            m[i]++;\\n        }\\n        long long ans =0;\\n        for(int i = 0;i<ideas.size();i++){\\n            for(int j = 0;j<ideas.size();j++){\\n                if(j == i){\\n                    continue;\\n                }\\n                string s1 = ideas[i];\\n                string s2 = ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(m.find(s1) == m.end() && m.find(s2)==m.end()){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Hashbaer",
                        "content": "I\\'m not sure but I guess you need O(n) time Complexity "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Being happy that you solved a hard question?\\n*TIME LIMIT EXCEEDED* guess who\\'s back?"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Everyone :Discussing TLE\nMe  without realization :  `Name1[0], Name2[0] = Name2[0], Name[1]`  \nWhy am i getting error :( \n\nIf you know, you know\n\n"
                    },
                    {
                        "username": "Jaswanth_bammidi",
                        "content": "i have written the complete code and executed in 5 minutes.sudden if has showed me time limit exceeded aadhi dhaa surprise."
                    },
                    {
                        "username": "sanskarshrm",
                        "content": "lol same with me\\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1794516,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This question is a headache for me, tried searching for some tips in the discuss but was still confuse "
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@rajan_jasani9](/rajan_jasani9) It seems like no amount of optimization will really work. Either you get the intended solution or you don\\'t. Mine was O(n*m), passed all testcases and got TLE."
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Agreed, Optimization is really frustrating stuck on testcase 78"
                    },
                    {
                        "username": "FeedNet",
                        "content": "Can anyone explain why my code is undershooting the answer for some testcases? Not sure if I'm missing a specific case:\nThanks in advance for any help (I know this is naive solution, just not sure why it's getting W/A).\n```class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        final = set()\n        ideaMap = {x:0 for x in ideas}\n        for index,name1 in enumerate(ideas):\n            for j in range(index+1,n):\n                name2 = ideas[j]\n                new1 = name2[0] + name1[1:]\n                new2 = name1[0] + name2[1:]\n                #print(new1,new2)\n                if new1 not in ideaMap and new2 not in ideaMap:\n                    combine1 = new1+new2\n                    combine2 = new2+new1\n                    final.add(combine1)\n                    final.add(combine2)\n        #print(final)\n        return len(final)```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "#One of simple approach\n``` dictionary []\n\nideas = [\"co\",\"de\",\"ce\",\"da\",\"ti\",\"to\"], \nmap all of the first letter of given words (followed by the suffixes):\ndic['c']={o,e}\ndic['d']={e,a}\ndic['t']={i,o}\n\nThen, just verify the difference of each defined suffix set, for example: \ndic['c']={'o','e'}\ndic['d']={'e','a'}\n\nWe have {'o'}, {'a'} are the difference of both checked sets\nans+= len{'o'} * len{'a'} *2\n'2' stands for a switch order.\n\ndic['d']={e,a}\ndic['t']={i,o}\nans+= len{e,a}* len{i,o} *2\n\nand so on...\n\nTry to run dry test on:\nideas =[\"c\",\"t\",\"to\"], then go for submit. \n```\nGood luck."
                    },
                    {
                        "username": "shivamguptacoder",
                        "content": "I thought of Using a TRIE data structure for this question ."
                    },
                    {
                        "username": "stefann01",
                        "content": "And whats the conclusion?"
                    },
                    {
                        "username": "madhes23",
                        "content": "# HINT\\nJust compare all the pairs, but that would lead to TLE.\\n1. But, does all of those n*n comparisons required? \\n2. Can we eliminate some of the comparisons? \\n3. Is there a way to select the valid pair of strings?\\n\\n**How to find the useless comparison?**\\n(mat, cat) and (cat, cable) : in these two which one is use less comparison?\\n\\n_Big jump in idea, not easy to get it_\\nIf you group strings by their first character, would it any insight on invalid pair of strings? \\nHow to find the invalid pair strings? \\n\\n\\n**Spoilers below**\\nInvalid -> not satisfy the given condition after swapping -> either one of the string is present in the either of the selected group"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "can someone tell me the exact code of brute force approach?"
                    },
                    {
                        "username": "Maninder_4",
                        "content": " long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> m;\\n        for(auto i:ideas){\\n            m[i]++;\\n        }\\n        long long ans =0;\\n        for(int i = 0;i<ideas.size();i++){\\n            for(int j = 0;j<ideas.size();j++){\\n                if(j == i){\\n                    continue;\\n                }\\n                string s1 = ideas[i];\\n                string s2 = ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(m.find(s1) == m.end() && m.find(s2)==m.end()){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Hashbaer",
                        "content": "I\\'m not sure but I guess you need O(n) time Complexity "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Being happy that you solved a hard question?\\n*TIME LIMIT EXCEEDED* guess who\\'s back?"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Everyone :Discussing TLE\nMe  without realization :  `Name1[0], Name2[0] = Name2[0], Name[1]`  \nWhy am i getting error :( \n\nIf you know, you know\n\n"
                    },
                    {
                        "username": "Jaswanth_bammidi",
                        "content": "i have written the complete code and executed in 5 minutes.sudden if has showed me time limit exceeded aadhi dhaa surprise."
                    },
                    {
                        "username": "sanskarshrm",
                        "content": "lol same with me\\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1794496,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This question is a headache for me, tried searching for some tips in the discuss but was still confuse "
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@rajan_jasani9](/rajan_jasani9) It seems like no amount of optimization will really work. Either you get the intended solution or you don\\'t. Mine was O(n*m), passed all testcases and got TLE."
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Agreed, Optimization is really frustrating stuck on testcase 78"
                    },
                    {
                        "username": "FeedNet",
                        "content": "Can anyone explain why my code is undershooting the answer for some testcases? Not sure if I'm missing a specific case:\nThanks in advance for any help (I know this is naive solution, just not sure why it's getting W/A).\n```class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        final = set()\n        ideaMap = {x:0 for x in ideas}\n        for index,name1 in enumerate(ideas):\n            for j in range(index+1,n):\n                name2 = ideas[j]\n                new1 = name2[0] + name1[1:]\n                new2 = name1[0] + name2[1:]\n                #print(new1,new2)\n                if new1 not in ideaMap and new2 not in ideaMap:\n                    combine1 = new1+new2\n                    combine2 = new2+new1\n                    final.add(combine1)\n                    final.add(combine2)\n        #print(final)\n        return len(final)```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "#One of simple approach\n``` dictionary []\n\nideas = [\"co\",\"de\",\"ce\",\"da\",\"ti\",\"to\"], \nmap all of the first letter of given words (followed by the suffixes):\ndic['c']={o,e}\ndic['d']={e,a}\ndic['t']={i,o}\n\nThen, just verify the difference of each defined suffix set, for example: \ndic['c']={'o','e'}\ndic['d']={'e','a'}\n\nWe have {'o'}, {'a'} are the difference of both checked sets\nans+= len{'o'} * len{'a'} *2\n'2' stands for a switch order.\n\ndic['d']={e,a}\ndic['t']={i,o}\nans+= len{e,a}* len{i,o} *2\n\nand so on...\n\nTry to run dry test on:\nideas =[\"c\",\"t\",\"to\"], then go for submit. \n```\nGood luck."
                    },
                    {
                        "username": "shivamguptacoder",
                        "content": "I thought of Using a TRIE data structure for this question ."
                    },
                    {
                        "username": "stefann01",
                        "content": "And whats the conclusion?"
                    },
                    {
                        "username": "madhes23",
                        "content": "# HINT\\nJust compare all the pairs, but that would lead to TLE.\\n1. But, does all of those n*n comparisons required? \\n2. Can we eliminate some of the comparisons? \\n3. Is there a way to select the valid pair of strings?\\n\\n**How to find the useless comparison?**\\n(mat, cat) and (cat, cable) : in these two which one is use less comparison?\\n\\n_Big jump in idea, not easy to get it_\\nIf you group strings by their first character, would it any insight on invalid pair of strings? \\nHow to find the invalid pair strings? \\n\\n\\n**Spoilers below**\\nInvalid -> not satisfy the given condition after swapping -> either one of the string is present in the either of the selected group"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "can someone tell me the exact code of brute force approach?"
                    },
                    {
                        "username": "Maninder_4",
                        "content": " long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> m;\\n        for(auto i:ideas){\\n            m[i]++;\\n        }\\n        long long ans =0;\\n        for(int i = 0;i<ideas.size();i++){\\n            for(int j = 0;j<ideas.size();j++){\\n                if(j == i){\\n                    continue;\\n                }\\n                string s1 = ideas[i];\\n                string s2 = ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(m.find(s1) == m.end() && m.find(s2)==m.end()){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Hashbaer",
                        "content": "I\\'m not sure but I guess you need O(n) time Complexity "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Being happy that you solved a hard question?\\n*TIME LIMIT EXCEEDED* guess who\\'s back?"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Everyone :Discussing TLE\nMe  without realization :  `Name1[0], Name2[0] = Name2[0], Name[1]`  \nWhy am i getting error :( \n\nIf you know, you know\n\n"
                    },
                    {
                        "username": "Jaswanth_bammidi",
                        "content": "i have written the complete code and executed in 5 minutes.sudden if has showed me time limit exceeded aadhi dhaa surprise."
                    },
                    {
                        "username": "sanskarshrm",
                        "content": "lol same with me\\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1794491,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This question is a headache for me, tried searching for some tips in the discuss but was still confuse "
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@rajan_jasani9](/rajan_jasani9) It seems like no amount of optimization will really work. Either you get the intended solution or you don\\'t. Mine was O(n*m), passed all testcases and got TLE."
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Agreed, Optimization is really frustrating stuck on testcase 78"
                    },
                    {
                        "username": "FeedNet",
                        "content": "Can anyone explain why my code is undershooting the answer for some testcases? Not sure if I'm missing a specific case:\nThanks in advance for any help (I know this is naive solution, just not sure why it's getting W/A).\n```class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        final = set()\n        ideaMap = {x:0 for x in ideas}\n        for index,name1 in enumerate(ideas):\n            for j in range(index+1,n):\n                name2 = ideas[j]\n                new1 = name2[0] + name1[1:]\n                new2 = name1[0] + name2[1:]\n                #print(new1,new2)\n                if new1 not in ideaMap and new2 not in ideaMap:\n                    combine1 = new1+new2\n                    combine2 = new2+new1\n                    final.add(combine1)\n                    final.add(combine2)\n        #print(final)\n        return len(final)```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "#One of simple approach\n``` dictionary []\n\nideas = [\"co\",\"de\",\"ce\",\"da\",\"ti\",\"to\"], \nmap all of the first letter of given words (followed by the suffixes):\ndic['c']={o,e}\ndic['d']={e,a}\ndic['t']={i,o}\n\nThen, just verify the difference of each defined suffix set, for example: \ndic['c']={'o','e'}\ndic['d']={'e','a'}\n\nWe have {'o'}, {'a'} are the difference of both checked sets\nans+= len{'o'} * len{'a'} *2\n'2' stands for a switch order.\n\ndic['d']={e,a}\ndic['t']={i,o}\nans+= len{e,a}* len{i,o} *2\n\nand so on...\n\nTry to run dry test on:\nideas =[\"c\",\"t\",\"to\"], then go for submit. \n```\nGood luck."
                    },
                    {
                        "username": "shivamguptacoder",
                        "content": "I thought of Using a TRIE data structure for this question ."
                    },
                    {
                        "username": "stefann01",
                        "content": "And whats the conclusion?"
                    },
                    {
                        "username": "madhes23",
                        "content": "# HINT\\nJust compare all the pairs, but that would lead to TLE.\\n1. But, does all of those n*n comparisons required? \\n2. Can we eliminate some of the comparisons? \\n3. Is there a way to select the valid pair of strings?\\n\\n**How to find the useless comparison?**\\n(mat, cat) and (cat, cable) : in these two which one is use less comparison?\\n\\n_Big jump in idea, not easy to get it_\\nIf you group strings by their first character, would it any insight on invalid pair of strings? \\nHow to find the invalid pair strings? \\n\\n\\n**Spoilers below**\\nInvalid -> not satisfy the given condition after swapping -> either one of the string is present in the either of the selected group"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "can someone tell me the exact code of brute force approach?"
                    },
                    {
                        "username": "Maninder_4",
                        "content": " long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> m;\\n        for(auto i:ideas){\\n            m[i]++;\\n        }\\n        long long ans =0;\\n        for(int i = 0;i<ideas.size();i++){\\n            for(int j = 0;j<ideas.size();j++){\\n                if(j == i){\\n                    continue;\\n                }\\n                string s1 = ideas[i];\\n                string s2 = ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(m.find(s1) == m.end() && m.find(s2)==m.end()){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Hashbaer",
                        "content": "I\\'m not sure but I guess you need O(n) time Complexity "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Being happy that you solved a hard question?\\n*TIME LIMIT EXCEEDED* guess who\\'s back?"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Everyone :Discussing TLE\nMe  without realization :  `Name1[0], Name2[0] = Name2[0], Name[1]`  \nWhy am i getting error :( \n\nIf you know, you know\n\n"
                    },
                    {
                        "username": "Jaswanth_bammidi",
                        "content": "i have written the complete code and executed in 5 minutes.sudden if has showed me time limit exceeded aadhi dhaa surprise."
                    },
                    {
                        "username": "sanskarshrm",
                        "content": "lol same with me\\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1794482,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This question is a headache for me, tried searching for some tips in the discuss but was still confuse "
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@rajan_jasani9](/rajan_jasani9) It seems like no amount of optimization will really work. Either you get the intended solution or you don\\'t. Mine was O(n*m), passed all testcases and got TLE."
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Agreed, Optimization is really frustrating stuck on testcase 78"
                    },
                    {
                        "username": "FeedNet",
                        "content": "Can anyone explain why my code is undershooting the answer for some testcases? Not sure if I'm missing a specific case:\nThanks in advance for any help (I know this is naive solution, just not sure why it's getting W/A).\n```class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        final = set()\n        ideaMap = {x:0 for x in ideas}\n        for index,name1 in enumerate(ideas):\n            for j in range(index+1,n):\n                name2 = ideas[j]\n                new1 = name2[0] + name1[1:]\n                new2 = name1[0] + name2[1:]\n                #print(new1,new2)\n                if new1 not in ideaMap and new2 not in ideaMap:\n                    combine1 = new1+new2\n                    combine2 = new2+new1\n                    final.add(combine1)\n                    final.add(combine2)\n        #print(final)\n        return len(final)```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "#One of simple approach\n``` dictionary []\n\nideas = [\"co\",\"de\",\"ce\",\"da\",\"ti\",\"to\"], \nmap all of the first letter of given words (followed by the suffixes):\ndic['c']={o,e}\ndic['d']={e,a}\ndic['t']={i,o}\n\nThen, just verify the difference of each defined suffix set, for example: \ndic['c']={'o','e'}\ndic['d']={'e','a'}\n\nWe have {'o'}, {'a'} are the difference of both checked sets\nans+= len{'o'} * len{'a'} *2\n'2' stands for a switch order.\n\ndic['d']={e,a}\ndic['t']={i,o}\nans+= len{e,a}* len{i,o} *2\n\nand so on...\n\nTry to run dry test on:\nideas =[\"c\",\"t\",\"to\"], then go for submit. \n```\nGood luck."
                    },
                    {
                        "username": "shivamguptacoder",
                        "content": "I thought of Using a TRIE data structure for this question ."
                    },
                    {
                        "username": "stefann01",
                        "content": "And whats the conclusion?"
                    },
                    {
                        "username": "madhes23",
                        "content": "# HINT\\nJust compare all the pairs, but that would lead to TLE.\\n1. But, does all of those n*n comparisons required? \\n2. Can we eliminate some of the comparisons? \\n3. Is there a way to select the valid pair of strings?\\n\\n**How to find the useless comparison?**\\n(mat, cat) and (cat, cable) : in these two which one is use less comparison?\\n\\n_Big jump in idea, not easy to get it_\\nIf you group strings by their first character, would it any insight on invalid pair of strings? \\nHow to find the invalid pair strings? \\n\\n\\n**Spoilers below**\\nInvalid -> not satisfy the given condition after swapping -> either one of the string is present in the either of the selected group"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "can someone tell me the exact code of brute force approach?"
                    },
                    {
                        "username": "Maninder_4",
                        "content": " long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> m;\\n        for(auto i:ideas){\\n            m[i]++;\\n        }\\n        long long ans =0;\\n        for(int i = 0;i<ideas.size();i++){\\n            for(int j = 0;j<ideas.size();j++){\\n                if(j == i){\\n                    continue;\\n                }\\n                string s1 = ideas[i];\\n                string s2 = ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(m.find(s1) == m.end() && m.find(s2)==m.end()){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Hashbaer",
                        "content": "I\\'m not sure but I guess you need O(n) time Complexity "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Being happy that you solved a hard question?\\n*TIME LIMIT EXCEEDED* guess who\\'s back?"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Everyone :Discussing TLE\nMe  without realization :  `Name1[0], Name2[0] = Name2[0], Name[1]`  \nWhy am i getting error :( \n\nIf you know, you know\n\n"
                    },
                    {
                        "username": "Jaswanth_bammidi",
                        "content": "i have written the complete code and executed in 5 minutes.sudden if has showed me time limit exceeded aadhi dhaa surprise."
                    },
                    {
                        "username": "sanskarshrm",
                        "content": "lol same with me\\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1794409,
                "content": [
                    {
                        "username": "Vinaygoswami321",
                        "content": "This question is a headache for me, tried searching for some tips in the discuss but was still confuse "
                    },
                    {
                        "username": "AMerrill",
                        "content": "[@rajan_jasani9](/rajan_jasani9) It seems like no amount of optimization will really work. Either you get the intended solution or you don\\'t. Mine was O(n*m), passed all testcases and got TLE."
                    },
                    {
                        "username": "rajan_jasani9",
                        "content": "Agreed, Optimization is really frustrating stuck on testcase 78"
                    },
                    {
                        "username": "FeedNet",
                        "content": "Can anyone explain why my code is undershooting the answer for some testcases? Not sure if I'm missing a specific case:\nThanks in advance for any help (I know this is naive solution, just not sure why it's getting W/A).\n```class Solution:\n    def distinctNames(self, ideas: List[str]) -> int:\n        n = len(ideas)\n        final = set()\n        ideaMap = {x:0 for x in ideas}\n        for index,name1 in enumerate(ideas):\n            for j in range(index+1,n):\n                name2 = ideas[j]\n                new1 = name2[0] + name1[1:]\n                new2 = name1[0] + name2[1:]\n                #print(new1,new2)\n                if new1 not in ideaMap and new2 not in ideaMap:\n                    combine1 = new1+new2\n                    combine2 = new2+new1\n                    final.add(combine1)\n                    final.add(combine2)\n        #print(final)\n        return len(final)```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "#One of simple approach\n``` dictionary []\n\nideas = [\"co\",\"de\",\"ce\",\"da\",\"ti\",\"to\"], \nmap all of the first letter of given words (followed by the suffixes):\ndic['c']={o,e}\ndic['d']={e,a}\ndic['t']={i,o}\n\nThen, just verify the difference of each defined suffix set, for example: \ndic['c']={'o','e'}\ndic['d']={'e','a'}\n\nWe have {'o'}, {'a'} are the difference of both checked sets\nans+= len{'o'} * len{'a'} *2\n'2' stands for a switch order.\n\ndic['d']={e,a}\ndic['t']={i,o}\nans+= len{e,a}* len{i,o} *2\n\nand so on...\n\nTry to run dry test on:\nideas =[\"c\",\"t\",\"to\"], then go for submit. \n```\nGood luck."
                    },
                    {
                        "username": "shivamguptacoder",
                        "content": "I thought of Using a TRIE data structure for this question ."
                    },
                    {
                        "username": "stefann01",
                        "content": "And whats the conclusion?"
                    },
                    {
                        "username": "madhes23",
                        "content": "# HINT\\nJust compare all the pairs, but that would lead to TLE.\\n1. But, does all of those n*n comparisons required? \\n2. Can we eliminate some of the comparisons? \\n3. Is there a way to select the valid pair of strings?\\n\\n**How to find the useless comparison?**\\n(mat, cat) and (cat, cable) : in these two which one is use less comparison?\\n\\n_Big jump in idea, not easy to get it_\\nIf you group strings by their first character, would it any insight on invalid pair of strings? \\nHow to find the invalid pair strings? \\n\\n\\n**Spoilers below**\\nInvalid -> not satisfy the given condition after swapping -> either one of the string is present in the either of the selected group"
                    },
                    {
                        "username": "sheelaggarwal028",
                        "content": "can someone tell me the exact code of brute force approach?"
                    },
                    {
                        "username": "Maninder_4",
                        "content": " long long distinctNames(vector<string>& ideas) {\\n        unordered_map<string,int> m;\\n        for(auto i:ideas){\\n            m[i]++;\\n        }\\n        long long ans =0;\\n        for(int i = 0;i<ideas.size();i++){\\n            for(int j = 0;j<ideas.size();j++){\\n                if(j == i){\\n                    continue;\\n                }\\n                string s1 = ideas[i];\\n                string s2 = ideas[j];\\n                swap(s1[0],s2[0]);\\n                if(m.find(s1) == m.end() && m.find(s2)==m.end()){\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Hashbaer",
                        "content": "I\\'m not sure but I guess you need O(n) time Complexity "
                    },
                    {
                        "username": "chawlaeekshit65",
                        "content": "Being happy that you solved a hard question?\\n*TIME LIMIT EXCEEDED* guess who\\'s back?"
                    },
                    {
                        "username": "SomeOnE-_-",
                        "content": "Everyone :Discussing TLE\nMe  without realization :  `Name1[0], Name2[0] = Name2[0], Name[1]`  \nWhy am i getting error :( \n\nIf you know, you know\n\n"
                    },
                    {
                        "username": "Jaswanth_bammidi",
                        "content": "i have written the complete code and executed in 5 minutes.sudden if has showed me time limit exceeded aadhi dhaa surprise."
                    },
                    {
                        "username": "sanskarshrm",
                        "content": "lol same with me\\uD83E\\uDD72"
                    }
                ]
            },
            {
                "id": 1794404,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "TLE at 74/89 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "\"TiMe LiMiT eXcEeDeD\""
                    },
                    {
                        "username": "krishnasaich",
                        "content": "Consider grouping of strings with same initial letter and multiplication after exclusion of common substrings.\\nKeep in mind that each combination forms 2 different titles"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Can someone tell me whats wrong \\n `\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        map<string, int> m;\\n\\n        long long count = 0;\\n        \\n        int n = ideas.size();\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            m[ideas[i]]++;\\n        }\\n        \\n        for(int i = 0; i<n-1; i++)\\n        {\\n            string ideaA = ideas[i];\\n\\n            for(int j = i+1; j<n; j++)\\n            {\\n                \\n                string ideaB = ideas[j];\\n                \\n                swap(ideaA[0], ideaB[0]);\\n                \\n                if(m.find(ideaA) == m.end()  and m.find(ideaB) == m.end() )\\n                {\\n                    cout<<ideaA<<\" and \"<<ideaB<< \" are not present\"<<endl;\\n                    count += 2;\\n                }\\n    \\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n};`\\n\\nIts not considering for i = 1 and j = 3;. Don\\'t know why.\\n\\nOutput : 4 (for 1st test case)\\nstdout : doffee and conuts are not present\\ntonuts and dime are not present"
                    },
                    {
                        "username": "user3510p",
                        "content": "i also faced same problem what u have done for this can u tell me"
                    },
                    {
                        "username": "singlaanubhav088",
                        "content": "swap the characters again after if statement -> swap(ideaA[0], ideaB[0]);"
                    },
                    {
                        "username": "YashSudhirraoHaramkar",
                        "content": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> hs=new HashSet<>();\\n        int ans=0;\\n        for(int i=0;i<ideas.length;i++){\\n            hs.add(ideas[i]);\\n        }\\n        for(int i=0;i<ideas.length-1;i++){\\n            String st1=ideas[i];\\n            char ch=st1.charAt(0);\\n            for(int j=i+1;j<ideas.length;j++){\\n                String st2=ideas[j];\\n                char ch1=st2.charAt(0);\\n               st1= st1.replace(st1.charAt(0),ch);\\n               st2= st2.replace(st2.charAt(0),ch1);\\n               if(!hs.contains(st1)){\\n                   ans++;\\n               }\\n                if(!hs.contains(st2)){\\n                   ans++;\\n               }\\n            }\\n        }\\n   return ans; }\\n}\\nwhat is wrong with this solution can anyone help?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Why Trie is not working here? It\\'s giving TLE at 74/89. I\\'m getting frustrated now. Or am i doing silly mistakes somewhere!!"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "still getting tle , i followed official solution\\nplease tell me if there is any mistake in my code (c)\\nlong long distinctNames(char ** ideas, int ideasSize){\\n    long long rtn = 0;\\n    char *c[26][ideasSize];\\n    int la[26] = {0};\\n\\n    for (long long i = 0; i < ideasSize; i++){\\n        int a = ideas[i][0] - \\'a\\'; \\n        // char *ptr;\\n        // ptr = ideas[i];\\n        // ptr++;\\n        // strcpy(c[a][la[a]], ptr);\\n        c[a][la[a]] = ++ideas[i];\\n        la[a]++;\\n    }\\n    for (int i = 0; i < 25; i++){\\n        if (la[i] == 0) continue;\\n        for (int j = i + 1, m; j < 26; j++){\\n            if (la[j] == 0) continue;\\n            m = 0;\\n            for (int k = 0; k < la[i]; k++){\\n                for (int l = 0; l < la[j]; l++)\\n                    if (strcmp(c[i][k], c[j][l]) == 0) m++; \\n            }\\n            rtn += (2* (la[i] - m) * (la[j] - m));\\n            //printf(\"%d %d %lld\\\\n\",i, j, rtn);\\n        }\\n    }\\n    // printf(\"\\\\n\");\\n    // for (int i = 0; i < 26; i++){\\n    //     for (int j = 0;j < la[i] ;j++)\\n    //         printf(\"%s\\\\n\", c[i][j]);\\n    // }\\n    return rtn;\\n}"
                    },
                    {
                        "username": "yash_visavadia",
                        "content": "Whatever seems easy but it isn\\'t."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "i can\\'t understand how to solve this problem.Please give me some hint."
                    }
                ]
            },
            {
                "id": 1794386,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "TLE at 74/89 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "\"TiMe LiMiT eXcEeDeD\""
                    },
                    {
                        "username": "krishnasaich",
                        "content": "Consider grouping of strings with same initial letter and multiplication after exclusion of common substrings.\\nKeep in mind that each combination forms 2 different titles"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Can someone tell me whats wrong \\n `\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        map<string, int> m;\\n\\n        long long count = 0;\\n        \\n        int n = ideas.size();\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            m[ideas[i]]++;\\n        }\\n        \\n        for(int i = 0; i<n-1; i++)\\n        {\\n            string ideaA = ideas[i];\\n\\n            for(int j = i+1; j<n; j++)\\n            {\\n                \\n                string ideaB = ideas[j];\\n                \\n                swap(ideaA[0], ideaB[0]);\\n                \\n                if(m.find(ideaA) == m.end()  and m.find(ideaB) == m.end() )\\n                {\\n                    cout<<ideaA<<\" and \"<<ideaB<< \" are not present\"<<endl;\\n                    count += 2;\\n                }\\n    \\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n};`\\n\\nIts not considering for i = 1 and j = 3;. Don\\'t know why.\\n\\nOutput : 4 (for 1st test case)\\nstdout : doffee and conuts are not present\\ntonuts and dime are not present"
                    },
                    {
                        "username": "user3510p",
                        "content": "i also faced same problem what u have done for this can u tell me"
                    },
                    {
                        "username": "singlaanubhav088",
                        "content": "swap the characters again after if statement -> swap(ideaA[0], ideaB[0]);"
                    },
                    {
                        "username": "YashSudhirraoHaramkar",
                        "content": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> hs=new HashSet<>();\\n        int ans=0;\\n        for(int i=0;i<ideas.length;i++){\\n            hs.add(ideas[i]);\\n        }\\n        for(int i=0;i<ideas.length-1;i++){\\n            String st1=ideas[i];\\n            char ch=st1.charAt(0);\\n            for(int j=i+1;j<ideas.length;j++){\\n                String st2=ideas[j];\\n                char ch1=st2.charAt(0);\\n               st1= st1.replace(st1.charAt(0),ch);\\n               st2= st2.replace(st2.charAt(0),ch1);\\n               if(!hs.contains(st1)){\\n                   ans++;\\n               }\\n                if(!hs.contains(st2)){\\n                   ans++;\\n               }\\n            }\\n        }\\n   return ans; }\\n}\\nwhat is wrong with this solution can anyone help?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Why Trie is not working here? It\\'s giving TLE at 74/89. I\\'m getting frustrated now. Or am i doing silly mistakes somewhere!!"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "still getting tle , i followed official solution\\nplease tell me if there is any mistake in my code (c)\\nlong long distinctNames(char ** ideas, int ideasSize){\\n    long long rtn = 0;\\n    char *c[26][ideasSize];\\n    int la[26] = {0};\\n\\n    for (long long i = 0; i < ideasSize; i++){\\n        int a = ideas[i][0] - \\'a\\'; \\n        // char *ptr;\\n        // ptr = ideas[i];\\n        // ptr++;\\n        // strcpy(c[a][la[a]], ptr);\\n        c[a][la[a]] = ++ideas[i];\\n        la[a]++;\\n    }\\n    for (int i = 0; i < 25; i++){\\n        if (la[i] == 0) continue;\\n        for (int j = i + 1, m; j < 26; j++){\\n            if (la[j] == 0) continue;\\n            m = 0;\\n            for (int k = 0; k < la[i]; k++){\\n                for (int l = 0; l < la[j]; l++)\\n                    if (strcmp(c[i][k], c[j][l]) == 0) m++; \\n            }\\n            rtn += (2* (la[i] - m) * (la[j] - m));\\n            //printf(\"%d %d %lld\\\\n\",i, j, rtn);\\n        }\\n    }\\n    // printf(\"\\\\n\");\\n    // for (int i = 0; i < 26; i++){\\n    //     for (int j = 0;j < la[i] ;j++)\\n    //         printf(\"%s\\\\n\", c[i][j]);\\n    // }\\n    return rtn;\\n}"
                    },
                    {
                        "username": "yash_visavadia",
                        "content": "Whatever seems easy but it isn\\'t."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "i can\\'t understand how to solve this problem.Please give me some hint."
                    }
                ]
            },
            {
                "id": 1794380,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "TLE at 74/89 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "\"TiMe LiMiT eXcEeDeD\""
                    },
                    {
                        "username": "krishnasaich",
                        "content": "Consider grouping of strings with same initial letter and multiplication after exclusion of common substrings.\\nKeep in mind that each combination forms 2 different titles"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Can someone tell me whats wrong \\n `\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        map<string, int> m;\\n\\n        long long count = 0;\\n        \\n        int n = ideas.size();\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            m[ideas[i]]++;\\n        }\\n        \\n        for(int i = 0; i<n-1; i++)\\n        {\\n            string ideaA = ideas[i];\\n\\n            for(int j = i+1; j<n; j++)\\n            {\\n                \\n                string ideaB = ideas[j];\\n                \\n                swap(ideaA[0], ideaB[0]);\\n                \\n                if(m.find(ideaA) == m.end()  and m.find(ideaB) == m.end() )\\n                {\\n                    cout<<ideaA<<\" and \"<<ideaB<< \" are not present\"<<endl;\\n                    count += 2;\\n                }\\n    \\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n};`\\n\\nIts not considering for i = 1 and j = 3;. Don\\'t know why.\\n\\nOutput : 4 (for 1st test case)\\nstdout : doffee and conuts are not present\\ntonuts and dime are not present"
                    },
                    {
                        "username": "user3510p",
                        "content": "i also faced same problem what u have done for this can u tell me"
                    },
                    {
                        "username": "singlaanubhav088",
                        "content": "swap the characters again after if statement -> swap(ideaA[0], ideaB[0]);"
                    },
                    {
                        "username": "YashSudhirraoHaramkar",
                        "content": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> hs=new HashSet<>();\\n        int ans=0;\\n        for(int i=0;i<ideas.length;i++){\\n            hs.add(ideas[i]);\\n        }\\n        for(int i=0;i<ideas.length-1;i++){\\n            String st1=ideas[i];\\n            char ch=st1.charAt(0);\\n            for(int j=i+1;j<ideas.length;j++){\\n                String st2=ideas[j];\\n                char ch1=st2.charAt(0);\\n               st1= st1.replace(st1.charAt(0),ch);\\n               st2= st2.replace(st2.charAt(0),ch1);\\n               if(!hs.contains(st1)){\\n                   ans++;\\n               }\\n                if(!hs.contains(st2)){\\n                   ans++;\\n               }\\n            }\\n        }\\n   return ans; }\\n}\\nwhat is wrong with this solution can anyone help?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Why Trie is not working here? It\\'s giving TLE at 74/89. I\\'m getting frustrated now. Or am i doing silly mistakes somewhere!!"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "still getting tle , i followed official solution\\nplease tell me if there is any mistake in my code (c)\\nlong long distinctNames(char ** ideas, int ideasSize){\\n    long long rtn = 0;\\n    char *c[26][ideasSize];\\n    int la[26] = {0};\\n\\n    for (long long i = 0; i < ideasSize; i++){\\n        int a = ideas[i][0] - \\'a\\'; \\n        // char *ptr;\\n        // ptr = ideas[i];\\n        // ptr++;\\n        // strcpy(c[a][la[a]], ptr);\\n        c[a][la[a]] = ++ideas[i];\\n        la[a]++;\\n    }\\n    for (int i = 0; i < 25; i++){\\n        if (la[i] == 0) continue;\\n        for (int j = i + 1, m; j < 26; j++){\\n            if (la[j] == 0) continue;\\n            m = 0;\\n            for (int k = 0; k < la[i]; k++){\\n                for (int l = 0; l < la[j]; l++)\\n                    if (strcmp(c[i][k], c[j][l]) == 0) m++; \\n            }\\n            rtn += (2* (la[i] - m) * (la[j] - m));\\n            //printf(\"%d %d %lld\\\\n\",i, j, rtn);\\n        }\\n    }\\n    // printf(\"\\\\n\");\\n    // for (int i = 0; i < 26; i++){\\n    //     for (int j = 0;j < la[i] ;j++)\\n    //         printf(\"%s\\\\n\", c[i][j]);\\n    // }\\n    return rtn;\\n}"
                    },
                    {
                        "username": "yash_visavadia",
                        "content": "Whatever seems easy but it isn\\'t."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "i can\\'t understand how to solve this problem.Please give me some hint."
                    }
                ]
            },
            {
                "id": 1794367,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "TLE at 74/89 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "\"TiMe LiMiT eXcEeDeD\""
                    },
                    {
                        "username": "krishnasaich",
                        "content": "Consider grouping of strings with same initial letter and multiplication after exclusion of common substrings.\\nKeep in mind that each combination forms 2 different titles"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Can someone tell me whats wrong \\n `\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        map<string, int> m;\\n\\n        long long count = 0;\\n        \\n        int n = ideas.size();\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            m[ideas[i]]++;\\n        }\\n        \\n        for(int i = 0; i<n-1; i++)\\n        {\\n            string ideaA = ideas[i];\\n\\n            for(int j = i+1; j<n; j++)\\n            {\\n                \\n                string ideaB = ideas[j];\\n                \\n                swap(ideaA[0], ideaB[0]);\\n                \\n                if(m.find(ideaA) == m.end()  and m.find(ideaB) == m.end() )\\n                {\\n                    cout<<ideaA<<\" and \"<<ideaB<< \" are not present\"<<endl;\\n                    count += 2;\\n                }\\n    \\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n};`\\n\\nIts not considering for i = 1 and j = 3;. Don\\'t know why.\\n\\nOutput : 4 (for 1st test case)\\nstdout : doffee and conuts are not present\\ntonuts and dime are not present"
                    },
                    {
                        "username": "user3510p",
                        "content": "i also faced same problem what u have done for this can u tell me"
                    },
                    {
                        "username": "singlaanubhav088",
                        "content": "swap the characters again after if statement -> swap(ideaA[0], ideaB[0]);"
                    },
                    {
                        "username": "YashSudhirraoHaramkar",
                        "content": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> hs=new HashSet<>();\\n        int ans=0;\\n        for(int i=0;i<ideas.length;i++){\\n            hs.add(ideas[i]);\\n        }\\n        for(int i=0;i<ideas.length-1;i++){\\n            String st1=ideas[i];\\n            char ch=st1.charAt(0);\\n            for(int j=i+1;j<ideas.length;j++){\\n                String st2=ideas[j];\\n                char ch1=st2.charAt(0);\\n               st1= st1.replace(st1.charAt(0),ch);\\n               st2= st2.replace(st2.charAt(0),ch1);\\n               if(!hs.contains(st1)){\\n                   ans++;\\n               }\\n                if(!hs.contains(st2)){\\n                   ans++;\\n               }\\n            }\\n        }\\n   return ans; }\\n}\\nwhat is wrong with this solution can anyone help?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Why Trie is not working here? It\\'s giving TLE at 74/89. I\\'m getting frustrated now. Or am i doing silly mistakes somewhere!!"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "still getting tle , i followed official solution\\nplease tell me if there is any mistake in my code (c)\\nlong long distinctNames(char ** ideas, int ideasSize){\\n    long long rtn = 0;\\n    char *c[26][ideasSize];\\n    int la[26] = {0};\\n\\n    for (long long i = 0; i < ideasSize; i++){\\n        int a = ideas[i][0] - \\'a\\'; \\n        // char *ptr;\\n        // ptr = ideas[i];\\n        // ptr++;\\n        // strcpy(c[a][la[a]], ptr);\\n        c[a][la[a]] = ++ideas[i];\\n        la[a]++;\\n    }\\n    for (int i = 0; i < 25; i++){\\n        if (la[i] == 0) continue;\\n        for (int j = i + 1, m; j < 26; j++){\\n            if (la[j] == 0) continue;\\n            m = 0;\\n            for (int k = 0; k < la[i]; k++){\\n                for (int l = 0; l < la[j]; l++)\\n                    if (strcmp(c[i][k], c[j][l]) == 0) m++; \\n            }\\n            rtn += (2* (la[i] - m) * (la[j] - m));\\n            //printf(\"%d %d %lld\\\\n\",i, j, rtn);\\n        }\\n    }\\n    // printf(\"\\\\n\");\\n    // for (int i = 0; i < 26; i++){\\n    //     for (int j = 0;j < la[i] ;j++)\\n    //         printf(\"%s\\\\n\", c[i][j]);\\n    // }\\n    return rtn;\\n}"
                    },
                    {
                        "username": "yash_visavadia",
                        "content": "Whatever seems easy but it isn\\'t."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "i can\\'t understand how to solve this problem.Please give me some hint."
                    }
                ]
            },
            {
                "id": 1794363,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "TLE at 74/89 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "\"TiMe LiMiT eXcEeDeD\""
                    },
                    {
                        "username": "krishnasaich",
                        "content": "Consider grouping of strings with same initial letter and multiplication after exclusion of common substrings.\\nKeep in mind that each combination forms 2 different titles"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Can someone tell me whats wrong \\n `\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        map<string, int> m;\\n\\n        long long count = 0;\\n        \\n        int n = ideas.size();\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            m[ideas[i]]++;\\n        }\\n        \\n        for(int i = 0; i<n-1; i++)\\n        {\\n            string ideaA = ideas[i];\\n\\n            for(int j = i+1; j<n; j++)\\n            {\\n                \\n                string ideaB = ideas[j];\\n                \\n                swap(ideaA[0], ideaB[0]);\\n                \\n                if(m.find(ideaA) == m.end()  and m.find(ideaB) == m.end() )\\n                {\\n                    cout<<ideaA<<\" and \"<<ideaB<< \" are not present\"<<endl;\\n                    count += 2;\\n                }\\n    \\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n};`\\n\\nIts not considering for i = 1 and j = 3;. Don\\'t know why.\\n\\nOutput : 4 (for 1st test case)\\nstdout : doffee and conuts are not present\\ntonuts and dime are not present"
                    },
                    {
                        "username": "user3510p",
                        "content": "i also faced same problem what u have done for this can u tell me"
                    },
                    {
                        "username": "singlaanubhav088",
                        "content": "swap the characters again after if statement -> swap(ideaA[0], ideaB[0]);"
                    },
                    {
                        "username": "YashSudhirraoHaramkar",
                        "content": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> hs=new HashSet<>();\\n        int ans=0;\\n        for(int i=0;i<ideas.length;i++){\\n            hs.add(ideas[i]);\\n        }\\n        for(int i=0;i<ideas.length-1;i++){\\n            String st1=ideas[i];\\n            char ch=st1.charAt(0);\\n            for(int j=i+1;j<ideas.length;j++){\\n                String st2=ideas[j];\\n                char ch1=st2.charAt(0);\\n               st1= st1.replace(st1.charAt(0),ch);\\n               st2= st2.replace(st2.charAt(0),ch1);\\n               if(!hs.contains(st1)){\\n                   ans++;\\n               }\\n                if(!hs.contains(st2)){\\n                   ans++;\\n               }\\n            }\\n        }\\n   return ans; }\\n}\\nwhat is wrong with this solution can anyone help?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Why Trie is not working here? It\\'s giving TLE at 74/89. I\\'m getting frustrated now. Or am i doing silly mistakes somewhere!!"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "still getting tle , i followed official solution\\nplease tell me if there is any mistake in my code (c)\\nlong long distinctNames(char ** ideas, int ideasSize){\\n    long long rtn = 0;\\n    char *c[26][ideasSize];\\n    int la[26] = {0};\\n\\n    for (long long i = 0; i < ideasSize; i++){\\n        int a = ideas[i][0] - \\'a\\'; \\n        // char *ptr;\\n        // ptr = ideas[i];\\n        // ptr++;\\n        // strcpy(c[a][la[a]], ptr);\\n        c[a][la[a]] = ++ideas[i];\\n        la[a]++;\\n    }\\n    for (int i = 0; i < 25; i++){\\n        if (la[i] == 0) continue;\\n        for (int j = i + 1, m; j < 26; j++){\\n            if (la[j] == 0) continue;\\n            m = 0;\\n            for (int k = 0; k < la[i]; k++){\\n                for (int l = 0; l < la[j]; l++)\\n                    if (strcmp(c[i][k], c[j][l]) == 0) m++; \\n            }\\n            rtn += (2* (la[i] - m) * (la[j] - m));\\n            //printf(\"%d %d %lld\\\\n\",i, j, rtn);\\n        }\\n    }\\n    // printf(\"\\\\n\");\\n    // for (int i = 0; i < 26; i++){\\n    //     for (int j = 0;j < la[i] ;j++)\\n    //         printf(\"%s\\\\n\", c[i][j]);\\n    // }\\n    return rtn;\\n}"
                    },
                    {
                        "username": "yash_visavadia",
                        "content": "Whatever seems easy but it isn\\'t."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "i can\\'t understand how to solve this problem.Please give me some hint."
                    }
                ]
            },
            {
                "id": 1794358,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "TLE at 74/89 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "\"TiMe LiMiT eXcEeDeD\""
                    },
                    {
                        "username": "krishnasaich",
                        "content": "Consider grouping of strings with same initial letter and multiplication after exclusion of common substrings.\\nKeep in mind that each combination forms 2 different titles"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Can someone tell me whats wrong \\n `\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        map<string, int> m;\\n\\n        long long count = 0;\\n        \\n        int n = ideas.size();\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            m[ideas[i]]++;\\n        }\\n        \\n        for(int i = 0; i<n-1; i++)\\n        {\\n            string ideaA = ideas[i];\\n\\n            for(int j = i+1; j<n; j++)\\n            {\\n                \\n                string ideaB = ideas[j];\\n                \\n                swap(ideaA[0], ideaB[0]);\\n                \\n                if(m.find(ideaA) == m.end()  and m.find(ideaB) == m.end() )\\n                {\\n                    cout<<ideaA<<\" and \"<<ideaB<< \" are not present\"<<endl;\\n                    count += 2;\\n                }\\n    \\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n};`\\n\\nIts not considering for i = 1 and j = 3;. Don\\'t know why.\\n\\nOutput : 4 (for 1st test case)\\nstdout : doffee and conuts are not present\\ntonuts and dime are not present"
                    },
                    {
                        "username": "user3510p",
                        "content": "i also faced same problem what u have done for this can u tell me"
                    },
                    {
                        "username": "singlaanubhav088",
                        "content": "swap the characters again after if statement -> swap(ideaA[0], ideaB[0]);"
                    },
                    {
                        "username": "YashSudhirraoHaramkar",
                        "content": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> hs=new HashSet<>();\\n        int ans=0;\\n        for(int i=0;i<ideas.length;i++){\\n            hs.add(ideas[i]);\\n        }\\n        for(int i=0;i<ideas.length-1;i++){\\n            String st1=ideas[i];\\n            char ch=st1.charAt(0);\\n            for(int j=i+1;j<ideas.length;j++){\\n                String st2=ideas[j];\\n                char ch1=st2.charAt(0);\\n               st1= st1.replace(st1.charAt(0),ch);\\n               st2= st2.replace(st2.charAt(0),ch1);\\n               if(!hs.contains(st1)){\\n                   ans++;\\n               }\\n                if(!hs.contains(st2)){\\n                   ans++;\\n               }\\n            }\\n        }\\n   return ans; }\\n}\\nwhat is wrong with this solution can anyone help?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Why Trie is not working here? It\\'s giving TLE at 74/89. I\\'m getting frustrated now. Or am i doing silly mistakes somewhere!!"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "still getting tle , i followed official solution\\nplease tell me if there is any mistake in my code (c)\\nlong long distinctNames(char ** ideas, int ideasSize){\\n    long long rtn = 0;\\n    char *c[26][ideasSize];\\n    int la[26] = {0};\\n\\n    for (long long i = 0; i < ideasSize; i++){\\n        int a = ideas[i][0] - \\'a\\'; \\n        // char *ptr;\\n        // ptr = ideas[i];\\n        // ptr++;\\n        // strcpy(c[a][la[a]], ptr);\\n        c[a][la[a]] = ++ideas[i];\\n        la[a]++;\\n    }\\n    for (int i = 0; i < 25; i++){\\n        if (la[i] == 0) continue;\\n        for (int j = i + 1, m; j < 26; j++){\\n            if (la[j] == 0) continue;\\n            m = 0;\\n            for (int k = 0; k < la[i]; k++){\\n                for (int l = 0; l < la[j]; l++)\\n                    if (strcmp(c[i][k], c[j][l]) == 0) m++; \\n            }\\n            rtn += (2* (la[i] - m) * (la[j] - m));\\n            //printf(\"%d %d %lld\\\\n\",i, j, rtn);\\n        }\\n    }\\n    // printf(\"\\\\n\");\\n    // for (int i = 0; i < 26; i++){\\n    //     for (int j = 0;j < la[i] ;j++)\\n    //         printf(\"%s\\\\n\", c[i][j]);\\n    // }\\n    return rtn;\\n}"
                    },
                    {
                        "username": "yash_visavadia",
                        "content": "Whatever seems easy but it isn\\'t."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "i can\\'t understand how to solve this problem.Please give me some hint."
                    }
                ]
            },
            {
                "id": 1794352,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "TLE at 74/89 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "\"TiMe LiMiT eXcEeDeD\""
                    },
                    {
                        "username": "krishnasaich",
                        "content": "Consider grouping of strings with same initial letter and multiplication after exclusion of common substrings.\\nKeep in mind that each combination forms 2 different titles"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Can someone tell me whats wrong \\n `\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        map<string, int> m;\\n\\n        long long count = 0;\\n        \\n        int n = ideas.size();\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            m[ideas[i]]++;\\n        }\\n        \\n        for(int i = 0; i<n-1; i++)\\n        {\\n            string ideaA = ideas[i];\\n\\n            for(int j = i+1; j<n; j++)\\n            {\\n                \\n                string ideaB = ideas[j];\\n                \\n                swap(ideaA[0], ideaB[0]);\\n                \\n                if(m.find(ideaA) == m.end()  and m.find(ideaB) == m.end() )\\n                {\\n                    cout<<ideaA<<\" and \"<<ideaB<< \" are not present\"<<endl;\\n                    count += 2;\\n                }\\n    \\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n};`\\n\\nIts not considering for i = 1 and j = 3;. Don\\'t know why.\\n\\nOutput : 4 (for 1st test case)\\nstdout : doffee and conuts are not present\\ntonuts and dime are not present"
                    },
                    {
                        "username": "user3510p",
                        "content": "i also faced same problem what u have done for this can u tell me"
                    },
                    {
                        "username": "singlaanubhav088",
                        "content": "swap the characters again after if statement -> swap(ideaA[0], ideaB[0]);"
                    },
                    {
                        "username": "YashSudhirraoHaramkar",
                        "content": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> hs=new HashSet<>();\\n        int ans=0;\\n        for(int i=0;i<ideas.length;i++){\\n            hs.add(ideas[i]);\\n        }\\n        for(int i=0;i<ideas.length-1;i++){\\n            String st1=ideas[i];\\n            char ch=st1.charAt(0);\\n            for(int j=i+1;j<ideas.length;j++){\\n                String st2=ideas[j];\\n                char ch1=st2.charAt(0);\\n               st1= st1.replace(st1.charAt(0),ch);\\n               st2= st2.replace(st2.charAt(0),ch1);\\n               if(!hs.contains(st1)){\\n                   ans++;\\n               }\\n                if(!hs.contains(st2)){\\n                   ans++;\\n               }\\n            }\\n        }\\n   return ans; }\\n}\\nwhat is wrong with this solution can anyone help?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Why Trie is not working here? It\\'s giving TLE at 74/89. I\\'m getting frustrated now. Or am i doing silly mistakes somewhere!!"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "still getting tle , i followed official solution\\nplease tell me if there is any mistake in my code (c)\\nlong long distinctNames(char ** ideas, int ideasSize){\\n    long long rtn = 0;\\n    char *c[26][ideasSize];\\n    int la[26] = {0};\\n\\n    for (long long i = 0; i < ideasSize; i++){\\n        int a = ideas[i][0] - \\'a\\'; \\n        // char *ptr;\\n        // ptr = ideas[i];\\n        // ptr++;\\n        // strcpy(c[a][la[a]], ptr);\\n        c[a][la[a]] = ++ideas[i];\\n        la[a]++;\\n    }\\n    for (int i = 0; i < 25; i++){\\n        if (la[i] == 0) continue;\\n        for (int j = i + 1, m; j < 26; j++){\\n            if (la[j] == 0) continue;\\n            m = 0;\\n            for (int k = 0; k < la[i]; k++){\\n                for (int l = 0; l < la[j]; l++)\\n                    if (strcmp(c[i][k], c[j][l]) == 0) m++; \\n            }\\n            rtn += (2* (la[i] - m) * (la[j] - m));\\n            //printf(\"%d %d %lld\\\\n\",i, j, rtn);\\n        }\\n    }\\n    // printf(\"\\\\n\");\\n    // for (int i = 0; i < 26; i++){\\n    //     for (int j = 0;j < la[i] ;j++)\\n    //         printf(\"%s\\\\n\", c[i][j]);\\n    // }\\n    return rtn;\\n}"
                    },
                    {
                        "username": "yash_visavadia",
                        "content": "Whatever seems easy but it isn\\'t."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "i can\\'t understand how to solve this problem.Please give me some hint."
                    }
                ]
            },
            {
                "id": 1794334,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "TLE at 74/89 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "\"TiMe LiMiT eXcEeDeD\""
                    },
                    {
                        "username": "krishnasaich",
                        "content": "Consider grouping of strings with same initial letter and multiplication after exclusion of common substrings.\\nKeep in mind that each combination forms 2 different titles"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Can someone tell me whats wrong \\n `\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        map<string, int> m;\\n\\n        long long count = 0;\\n        \\n        int n = ideas.size();\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            m[ideas[i]]++;\\n        }\\n        \\n        for(int i = 0; i<n-1; i++)\\n        {\\n            string ideaA = ideas[i];\\n\\n            for(int j = i+1; j<n; j++)\\n            {\\n                \\n                string ideaB = ideas[j];\\n                \\n                swap(ideaA[0], ideaB[0]);\\n                \\n                if(m.find(ideaA) == m.end()  and m.find(ideaB) == m.end() )\\n                {\\n                    cout<<ideaA<<\" and \"<<ideaB<< \" are not present\"<<endl;\\n                    count += 2;\\n                }\\n    \\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n};`\\n\\nIts not considering for i = 1 and j = 3;. Don\\'t know why.\\n\\nOutput : 4 (for 1st test case)\\nstdout : doffee and conuts are not present\\ntonuts and dime are not present"
                    },
                    {
                        "username": "user3510p",
                        "content": "i also faced same problem what u have done for this can u tell me"
                    },
                    {
                        "username": "singlaanubhav088",
                        "content": "swap the characters again after if statement -> swap(ideaA[0], ideaB[0]);"
                    },
                    {
                        "username": "YashSudhirraoHaramkar",
                        "content": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> hs=new HashSet<>();\\n        int ans=0;\\n        for(int i=0;i<ideas.length;i++){\\n            hs.add(ideas[i]);\\n        }\\n        for(int i=0;i<ideas.length-1;i++){\\n            String st1=ideas[i];\\n            char ch=st1.charAt(0);\\n            for(int j=i+1;j<ideas.length;j++){\\n                String st2=ideas[j];\\n                char ch1=st2.charAt(0);\\n               st1= st1.replace(st1.charAt(0),ch);\\n               st2= st2.replace(st2.charAt(0),ch1);\\n               if(!hs.contains(st1)){\\n                   ans++;\\n               }\\n                if(!hs.contains(st2)){\\n                   ans++;\\n               }\\n            }\\n        }\\n   return ans; }\\n}\\nwhat is wrong with this solution can anyone help?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Why Trie is not working here? It\\'s giving TLE at 74/89. I\\'m getting frustrated now. Or am i doing silly mistakes somewhere!!"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "still getting tle , i followed official solution\\nplease tell me if there is any mistake in my code (c)\\nlong long distinctNames(char ** ideas, int ideasSize){\\n    long long rtn = 0;\\n    char *c[26][ideasSize];\\n    int la[26] = {0};\\n\\n    for (long long i = 0; i < ideasSize; i++){\\n        int a = ideas[i][0] - \\'a\\'; \\n        // char *ptr;\\n        // ptr = ideas[i];\\n        // ptr++;\\n        // strcpy(c[a][la[a]], ptr);\\n        c[a][la[a]] = ++ideas[i];\\n        la[a]++;\\n    }\\n    for (int i = 0; i < 25; i++){\\n        if (la[i] == 0) continue;\\n        for (int j = i + 1, m; j < 26; j++){\\n            if (la[j] == 0) continue;\\n            m = 0;\\n            for (int k = 0; k < la[i]; k++){\\n                for (int l = 0; l < la[j]; l++)\\n                    if (strcmp(c[i][k], c[j][l]) == 0) m++; \\n            }\\n            rtn += (2* (la[i] - m) * (la[j] - m));\\n            //printf(\"%d %d %lld\\\\n\",i, j, rtn);\\n        }\\n    }\\n    // printf(\"\\\\n\");\\n    // for (int i = 0; i < 26; i++){\\n    //     for (int j = 0;j < la[i] ;j++)\\n    //         printf(\"%s\\\\n\", c[i][j]);\\n    // }\\n    return rtn;\\n}"
                    },
                    {
                        "username": "yash_visavadia",
                        "content": "Whatever seems easy but it isn\\'t."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "i can\\'t understand how to solve this problem.Please give me some hint."
                    }
                ]
            },
            {
                "id": 1794333,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "TLE at 74/89 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "\"TiMe LiMiT eXcEeDeD\""
                    },
                    {
                        "username": "krishnasaich",
                        "content": "Consider grouping of strings with same initial letter and multiplication after exclusion of common substrings.\\nKeep in mind that each combination forms 2 different titles"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Can someone tell me whats wrong \\n `\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        map<string, int> m;\\n\\n        long long count = 0;\\n        \\n        int n = ideas.size();\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            m[ideas[i]]++;\\n        }\\n        \\n        for(int i = 0; i<n-1; i++)\\n        {\\n            string ideaA = ideas[i];\\n\\n            for(int j = i+1; j<n; j++)\\n            {\\n                \\n                string ideaB = ideas[j];\\n                \\n                swap(ideaA[0], ideaB[0]);\\n                \\n                if(m.find(ideaA) == m.end()  and m.find(ideaB) == m.end() )\\n                {\\n                    cout<<ideaA<<\" and \"<<ideaB<< \" are not present\"<<endl;\\n                    count += 2;\\n                }\\n    \\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n};`\\n\\nIts not considering for i = 1 and j = 3;. Don\\'t know why.\\n\\nOutput : 4 (for 1st test case)\\nstdout : doffee and conuts are not present\\ntonuts and dime are not present"
                    },
                    {
                        "username": "user3510p",
                        "content": "i also faced same problem what u have done for this can u tell me"
                    },
                    {
                        "username": "singlaanubhav088",
                        "content": "swap the characters again after if statement -> swap(ideaA[0], ideaB[0]);"
                    },
                    {
                        "username": "YashSudhirraoHaramkar",
                        "content": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> hs=new HashSet<>();\\n        int ans=0;\\n        for(int i=0;i<ideas.length;i++){\\n            hs.add(ideas[i]);\\n        }\\n        for(int i=0;i<ideas.length-1;i++){\\n            String st1=ideas[i];\\n            char ch=st1.charAt(0);\\n            for(int j=i+1;j<ideas.length;j++){\\n                String st2=ideas[j];\\n                char ch1=st2.charAt(0);\\n               st1= st1.replace(st1.charAt(0),ch);\\n               st2= st2.replace(st2.charAt(0),ch1);\\n               if(!hs.contains(st1)){\\n                   ans++;\\n               }\\n                if(!hs.contains(st2)){\\n                   ans++;\\n               }\\n            }\\n        }\\n   return ans; }\\n}\\nwhat is wrong with this solution can anyone help?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Why Trie is not working here? It\\'s giving TLE at 74/89. I\\'m getting frustrated now. Or am i doing silly mistakes somewhere!!"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "still getting tle , i followed official solution\\nplease tell me if there is any mistake in my code (c)\\nlong long distinctNames(char ** ideas, int ideasSize){\\n    long long rtn = 0;\\n    char *c[26][ideasSize];\\n    int la[26] = {0};\\n\\n    for (long long i = 0; i < ideasSize; i++){\\n        int a = ideas[i][0] - \\'a\\'; \\n        // char *ptr;\\n        // ptr = ideas[i];\\n        // ptr++;\\n        // strcpy(c[a][la[a]], ptr);\\n        c[a][la[a]] = ++ideas[i];\\n        la[a]++;\\n    }\\n    for (int i = 0; i < 25; i++){\\n        if (la[i] == 0) continue;\\n        for (int j = i + 1, m; j < 26; j++){\\n            if (la[j] == 0) continue;\\n            m = 0;\\n            for (int k = 0; k < la[i]; k++){\\n                for (int l = 0; l < la[j]; l++)\\n                    if (strcmp(c[i][k], c[j][l]) == 0) m++; \\n            }\\n            rtn += (2* (la[i] - m) * (la[j] - m));\\n            //printf(\"%d %d %lld\\\\n\",i, j, rtn);\\n        }\\n    }\\n    // printf(\"\\\\n\");\\n    // for (int i = 0; i < 26; i++){\\n    //     for (int j = 0;j < la[i] ;j++)\\n    //         printf(\"%s\\\\n\", c[i][j]);\\n    // }\\n    return rtn;\\n}"
                    },
                    {
                        "username": "yash_visavadia",
                        "content": "Whatever seems easy but it isn\\'t."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "i can\\'t understand how to solve this problem.Please give me some hint."
                    }
                ]
            },
            {
                "id": 1794332,
                "content": [
                    {
                        "username": "arghyadas",
                        "content": "TLE at 74/89 \\uD83E\\uDD72"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "\"TiMe LiMiT eXcEeDeD\""
                    },
                    {
                        "username": "krishnasaich",
                        "content": "Consider grouping of strings with same initial letter and multiplication after exclusion of common substrings.\\nKeep in mind that each combination forms 2 different titles"
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Can someone tell me whats wrong \\n `\\nclass Solution {\\npublic:\\n\\n    long long distinctNames(vector<string>& ideas) {\\n        \\n        map<string, int> m;\\n\\n        long long count = 0;\\n        \\n        int n = ideas.size();\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            m[ideas[i]]++;\\n        }\\n        \\n        for(int i = 0; i<n-1; i++)\\n        {\\n            string ideaA = ideas[i];\\n\\n            for(int j = i+1; j<n; j++)\\n            {\\n                \\n                string ideaB = ideas[j];\\n                \\n                swap(ideaA[0], ideaB[0]);\\n                \\n                if(m.find(ideaA) == m.end()  and m.find(ideaB) == m.end() )\\n                {\\n                    cout<<ideaA<<\" and \"<<ideaB<< \" are not present\"<<endl;\\n                    count += 2;\\n                }\\n    \\n            }\\n\\n        }\\n\\n        return count;\\n        \\n    }\\n};`\\n\\nIts not considering for i = 1 and j = 3;. Don\\'t know why.\\n\\nOutput : 4 (for 1st test case)\\nstdout : doffee and conuts are not present\\ntonuts and dime are not present"
                    },
                    {
                        "username": "user3510p",
                        "content": "i also faced same problem what u have done for this can u tell me"
                    },
                    {
                        "username": "singlaanubhav088",
                        "content": "swap the characters again after if statement -> swap(ideaA[0], ideaB[0]);"
                    },
                    {
                        "username": "YashSudhirraoHaramkar",
                        "content": "class Solution {\\n    public long distinctNames(String[] ideas) {\\n        HashSet<String> hs=new HashSet<>();\\n        int ans=0;\\n        for(int i=0;i<ideas.length;i++){\\n            hs.add(ideas[i]);\\n        }\\n        for(int i=0;i<ideas.length-1;i++){\\n            String st1=ideas[i];\\n            char ch=st1.charAt(0);\\n            for(int j=i+1;j<ideas.length;j++){\\n                String st2=ideas[j];\\n                char ch1=st2.charAt(0);\\n               st1= st1.replace(st1.charAt(0),ch);\\n               st2= st2.replace(st2.charAt(0),ch1);\\n               if(!hs.contains(st1)){\\n                   ans++;\\n               }\\n                if(!hs.contains(st2)){\\n                   ans++;\\n               }\\n            }\\n        }\\n   return ans; }\\n}\\nwhat is wrong with this solution can anyone help?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "when you came up with all you know all you have , and leetcode gives you TLE \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02\\n\\nmind be like : pehle bata deta bisi, itne der iske liye thodi lagaya tha ki TLE de"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Why Trie is not working here? It\\'s giving TLE at 74/89. I\\'m getting frustrated now. Or am i doing silly mistakes somewhere!!"
                    },
                    {
                        "username": "mohitjakhar",
                        "content": "still getting tle , i followed official solution\\nplease tell me if there is any mistake in my code (c)\\nlong long distinctNames(char ** ideas, int ideasSize){\\n    long long rtn = 0;\\n    char *c[26][ideasSize];\\n    int la[26] = {0};\\n\\n    for (long long i = 0; i < ideasSize; i++){\\n        int a = ideas[i][0] - \\'a\\'; \\n        // char *ptr;\\n        // ptr = ideas[i];\\n        // ptr++;\\n        // strcpy(c[a][la[a]], ptr);\\n        c[a][la[a]] = ++ideas[i];\\n        la[a]++;\\n    }\\n    for (int i = 0; i < 25; i++){\\n        if (la[i] == 0) continue;\\n        for (int j = i + 1, m; j < 26; j++){\\n            if (la[j] == 0) continue;\\n            m = 0;\\n            for (int k = 0; k < la[i]; k++){\\n                for (int l = 0; l < la[j]; l++)\\n                    if (strcmp(c[i][k], c[j][l]) == 0) m++; \\n            }\\n            rtn += (2* (la[i] - m) * (la[j] - m));\\n            //printf(\"%d %d %lld\\\\n\",i, j, rtn);\\n        }\\n    }\\n    // printf(\"\\\\n\");\\n    // for (int i = 0; i < 26; i++){\\n    //     for (int j = 0;j < la[i] ;j++)\\n    //         printf(\"%s\\\\n\", c[i][j]);\\n    // }\\n    return rtn;\\n}"
                    },
                    {
                        "username": "yash_visavadia",
                        "content": "Whatever seems easy but it isn\\'t."
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "i can\\'t understand how to solve this problem.Please give me some hint."
                    }
                ]
            },
            {
                "id": 1794307,
                "content": [
                    {
                        "username": "nishtha_1412",
                        "content": "Can somebody help me with this solution , like why is it failing.\\n\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         int count = 0;\\n        HashSet<String> set = new HashSet<>();\\n        for (int i = 0; i < ideas.length; i++) {\\n            for (int j = i + 1; j < ideas.length; j++) {\\n                String ideaA = ideas[i];\\n                String ideaB = ideas[j];\\n                char[] ideaAChars = ideaA.toCharArray();\\n                char[] ideaBChars = ideaB.toCharArray();\\n                char temp = ideaAChars[0];\\n                ideaAChars[0] = ideaBChars[0];\\n                ideaBChars[0] = temp;\\n                String newIdeaA = new String(ideaAChars);\\n                String newIdeaB = new String(ideaBChars);\\n                if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {\\n                    count++;\\n                    set.add(newIdeaA + \" \" + newIdeaB);\\n                }\\n            }\\n        }\\n        if(count==1)\\n        return count-1;\\n        else\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Hdrnjd",
                        "content": "I knew it\\'s a TLE from the beginning "
                    },
                    {
                        "username": "Sai_Kumar_Reddy77777",
                        "content": "class Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        #we just created an default dictionary in the form of sets, so that duplicate values are deleted from the sets\\n        d=defaultdict(set)\\n        for i in ideas:\\n            #we just intialized the default dictionary with the first character as a key and the remaining characters of the string as the value\\n            d[i[0]].add(i[1:])\\n        #here we are adding the key values to the array \\n        arr=list(d.keys())\\n        sum,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                a,b=arr[i],arr[j]\\n                #counting the name suggestions\\n                sum+=len(d[a]-d[b])*len(d[b]-d[a])*2\\n        return sum\\n         "
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Imagine buying coffee from soffee chop"
                    },
                    {
                        "username": "racemus",
                        "content": "Can anyone explain why expected output for `[\"phhrrjjcm\",\"zjfkpps\",\"pm\",\"fnpduelfe\",\"mxtvjnq\"]` is `18`?"
                    },
                    {
                        "username": "racemus",
                        "content": "[@kropochev](/kropochev) Thanks"
                    },
                    {
                        "username": "kropochev",
                        "content": "Possibly as shown below, but I\\'m not sure.\\n    phhrrjjcm zjfkpps 2\\n    phhrrjjcm pm ----\\n    phhrrjjcm fnpduelfe 4\\n    phhrrjjcm mxtvjnq 6\\n    zjfkpps pm 8\\n    zjfkpps fnpduelfe 10\\n    zjfkpps mxtvjnq 12\\n    pm fnpduelfe 14\\n    pm mxtvjnq 16\\n    fnpduelfe mxtvjnq 18"
                    },
                    {
                        "username": "kropochev",
                        "content": "Input: ideas = [\"r\",\"lycdkjdnoy\",\"wzlu\",\"wxkyjgwc\",\"qtaqnbi\",\"m\",\"x\",\"jhvdzr\",\"rquzz\"]\\nOutput: 62\\nExpected: 58\\n\\nGot the following list of ideas. But 4 fewer ideas are expected, tell me which ideas are not correct.\\n\\n    r lycdkjdnoy 2\\n    r wzlu 4\\n    r wxkyjgwc 6\\n    r qtaqnbi 8\\n    r m ----\\n    r x ----\\n    r jhvdzr 10\\n    r rquzz ----\\n    lycdkjdnoy wzlu 12\\n    lycdkjdnoy wxkyjgwc 14\\n    lycdkjdnoy qtaqnbi 16\\n    lycdkjdnoy m 18\\n    lycdkjdnoy x 20\\n    lycdkjdnoy jhvdzr 22\\n    lycdkjdnoy rquzz 24\\n    wzlu wxkyjgwc ----\\n    wzlu qtaqnbi 26\\n    wzlu m 28\\n    wzlu x 30\\n    wzlu jhvdzr 32\\n    wzlu rquzz 34\\n    wxkyjgwc qtaqnbi 36\\n    wxkyjgwc m 38\\n    wxkyjgwc x 40\\n    wxkyjgwc jhvdzr 42\\n    wxkyjgwc rquzz 44\\n    qtaqnbi m 46\\n    qtaqnbi x 48\\n    qtaqnbi jhvdzr 50\\n    qtaqnbi rquzz 52\\n    m x ----\\n    m jhvdzr 54\\n    m rquzz 56\\n    x jhvdzr 58\\n    x rquzz 60\\n    jhvdzr rquzz 62"
                    },
                    {
                        "username": "kropochev",
                        "content": "[@Dark_Fang](/Dark_Fang) thanks for the tip"
                    },
                    {
                        "username": "Dark_Fang",
                        "content": "56 - [x, rquzz] and 60 - [m, rquzz]\\nIn both the swaps, you will get \"r\" which is already present in ideas."
                    },
                    {
                        "username": "autf",
                        "content": "I expected a tag of `Set`, but there was no (longer?) one.\\nThere is `Ordered Set` and `Hash Table`, but I don\\'t think they are as precise as `Set`."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "Do not use map instead use unordered_map\\n\\nmap will give you TLE (-_-)  "
                    },
                    {
                        "username": "rainajain_123",
                        "content": "Can we solve this without grouping?"
                    },
                    {
                        "username": "anau99",
                        "content": "The week of hashtable ?"
                    }
                ]
            },
            {
                "id": 1794191,
                "content": [
                    {
                        "username": "nishtha_1412",
                        "content": "Can somebody help me with this solution , like why is it failing.\\n\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         int count = 0;\\n        HashSet<String> set = new HashSet<>();\\n        for (int i = 0; i < ideas.length; i++) {\\n            for (int j = i + 1; j < ideas.length; j++) {\\n                String ideaA = ideas[i];\\n                String ideaB = ideas[j];\\n                char[] ideaAChars = ideaA.toCharArray();\\n                char[] ideaBChars = ideaB.toCharArray();\\n                char temp = ideaAChars[0];\\n                ideaAChars[0] = ideaBChars[0];\\n                ideaBChars[0] = temp;\\n                String newIdeaA = new String(ideaAChars);\\n                String newIdeaB = new String(ideaBChars);\\n                if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {\\n                    count++;\\n                    set.add(newIdeaA + \" \" + newIdeaB);\\n                }\\n            }\\n        }\\n        if(count==1)\\n        return count-1;\\n        else\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Hdrnjd",
                        "content": "I knew it\\'s a TLE from the beginning "
                    },
                    {
                        "username": "Sai_Kumar_Reddy77777",
                        "content": "class Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        #we just created an default dictionary in the form of sets, so that duplicate values are deleted from the sets\\n        d=defaultdict(set)\\n        for i in ideas:\\n            #we just intialized the default dictionary with the first character as a key and the remaining characters of the string as the value\\n            d[i[0]].add(i[1:])\\n        #here we are adding the key values to the array \\n        arr=list(d.keys())\\n        sum,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                a,b=arr[i],arr[j]\\n                #counting the name suggestions\\n                sum+=len(d[a]-d[b])*len(d[b]-d[a])*2\\n        return sum\\n         "
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Imagine buying coffee from soffee chop"
                    },
                    {
                        "username": "racemus",
                        "content": "Can anyone explain why expected output for `[\"phhrrjjcm\",\"zjfkpps\",\"pm\",\"fnpduelfe\",\"mxtvjnq\"]` is `18`?"
                    },
                    {
                        "username": "racemus",
                        "content": "[@kropochev](/kropochev) Thanks"
                    },
                    {
                        "username": "kropochev",
                        "content": "Possibly as shown below, but I\\'m not sure.\\n    phhrrjjcm zjfkpps 2\\n    phhrrjjcm pm ----\\n    phhrrjjcm fnpduelfe 4\\n    phhrrjjcm mxtvjnq 6\\n    zjfkpps pm 8\\n    zjfkpps fnpduelfe 10\\n    zjfkpps mxtvjnq 12\\n    pm fnpduelfe 14\\n    pm mxtvjnq 16\\n    fnpduelfe mxtvjnq 18"
                    },
                    {
                        "username": "kropochev",
                        "content": "Input: ideas = [\"r\",\"lycdkjdnoy\",\"wzlu\",\"wxkyjgwc\",\"qtaqnbi\",\"m\",\"x\",\"jhvdzr\",\"rquzz\"]\\nOutput: 62\\nExpected: 58\\n\\nGot the following list of ideas. But 4 fewer ideas are expected, tell me which ideas are not correct.\\n\\n    r lycdkjdnoy 2\\n    r wzlu 4\\n    r wxkyjgwc 6\\n    r qtaqnbi 8\\n    r m ----\\n    r x ----\\n    r jhvdzr 10\\n    r rquzz ----\\n    lycdkjdnoy wzlu 12\\n    lycdkjdnoy wxkyjgwc 14\\n    lycdkjdnoy qtaqnbi 16\\n    lycdkjdnoy m 18\\n    lycdkjdnoy x 20\\n    lycdkjdnoy jhvdzr 22\\n    lycdkjdnoy rquzz 24\\n    wzlu wxkyjgwc ----\\n    wzlu qtaqnbi 26\\n    wzlu m 28\\n    wzlu x 30\\n    wzlu jhvdzr 32\\n    wzlu rquzz 34\\n    wxkyjgwc qtaqnbi 36\\n    wxkyjgwc m 38\\n    wxkyjgwc x 40\\n    wxkyjgwc jhvdzr 42\\n    wxkyjgwc rquzz 44\\n    qtaqnbi m 46\\n    qtaqnbi x 48\\n    qtaqnbi jhvdzr 50\\n    qtaqnbi rquzz 52\\n    m x ----\\n    m jhvdzr 54\\n    m rquzz 56\\n    x jhvdzr 58\\n    x rquzz 60\\n    jhvdzr rquzz 62"
                    },
                    {
                        "username": "kropochev",
                        "content": "[@Dark_Fang](/Dark_Fang) thanks for the tip"
                    },
                    {
                        "username": "Dark_Fang",
                        "content": "56 - [x, rquzz] and 60 - [m, rquzz]\\nIn both the swaps, you will get \"r\" which is already present in ideas."
                    },
                    {
                        "username": "autf",
                        "content": "I expected a tag of `Set`, but there was no (longer?) one.\\nThere is `Ordered Set` and `Hash Table`, but I don\\'t think they are as precise as `Set`."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "Do not use map instead use unordered_map\\n\\nmap will give you TLE (-_-)  "
                    },
                    {
                        "username": "rainajain_123",
                        "content": "Can we solve this without grouping?"
                    },
                    {
                        "username": "anau99",
                        "content": "The week of hashtable ?"
                    }
                ]
            },
            {
                "id": 1794184,
                "content": [
                    {
                        "username": "nishtha_1412",
                        "content": "Can somebody help me with this solution , like why is it failing.\\n\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         int count = 0;\\n        HashSet<String> set = new HashSet<>();\\n        for (int i = 0; i < ideas.length; i++) {\\n            for (int j = i + 1; j < ideas.length; j++) {\\n                String ideaA = ideas[i];\\n                String ideaB = ideas[j];\\n                char[] ideaAChars = ideaA.toCharArray();\\n                char[] ideaBChars = ideaB.toCharArray();\\n                char temp = ideaAChars[0];\\n                ideaAChars[0] = ideaBChars[0];\\n                ideaBChars[0] = temp;\\n                String newIdeaA = new String(ideaAChars);\\n                String newIdeaB = new String(ideaBChars);\\n                if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {\\n                    count++;\\n                    set.add(newIdeaA + \" \" + newIdeaB);\\n                }\\n            }\\n        }\\n        if(count==1)\\n        return count-1;\\n        else\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Hdrnjd",
                        "content": "I knew it\\'s a TLE from the beginning "
                    },
                    {
                        "username": "Sai_Kumar_Reddy77777",
                        "content": "class Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        #we just created an default dictionary in the form of sets, so that duplicate values are deleted from the sets\\n        d=defaultdict(set)\\n        for i in ideas:\\n            #we just intialized the default dictionary with the first character as a key and the remaining characters of the string as the value\\n            d[i[0]].add(i[1:])\\n        #here we are adding the key values to the array \\n        arr=list(d.keys())\\n        sum,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                a,b=arr[i],arr[j]\\n                #counting the name suggestions\\n                sum+=len(d[a]-d[b])*len(d[b]-d[a])*2\\n        return sum\\n         "
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Imagine buying coffee from soffee chop"
                    },
                    {
                        "username": "racemus",
                        "content": "Can anyone explain why expected output for `[\"phhrrjjcm\",\"zjfkpps\",\"pm\",\"fnpduelfe\",\"mxtvjnq\"]` is `18`?"
                    },
                    {
                        "username": "racemus",
                        "content": "[@kropochev](/kropochev) Thanks"
                    },
                    {
                        "username": "kropochev",
                        "content": "Possibly as shown below, but I\\'m not sure.\\n    phhrrjjcm zjfkpps 2\\n    phhrrjjcm pm ----\\n    phhrrjjcm fnpduelfe 4\\n    phhrrjjcm mxtvjnq 6\\n    zjfkpps pm 8\\n    zjfkpps fnpduelfe 10\\n    zjfkpps mxtvjnq 12\\n    pm fnpduelfe 14\\n    pm mxtvjnq 16\\n    fnpduelfe mxtvjnq 18"
                    },
                    {
                        "username": "kropochev",
                        "content": "Input: ideas = [\"r\",\"lycdkjdnoy\",\"wzlu\",\"wxkyjgwc\",\"qtaqnbi\",\"m\",\"x\",\"jhvdzr\",\"rquzz\"]\\nOutput: 62\\nExpected: 58\\n\\nGot the following list of ideas. But 4 fewer ideas are expected, tell me which ideas are not correct.\\n\\n    r lycdkjdnoy 2\\n    r wzlu 4\\n    r wxkyjgwc 6\\n    r qtaqnbi 8\\n    r m ----\\n    r x ----\\n    r jhvdzr 10\\n    r rquzz ----\\n    lycdkjdnoy wzlu 12\\n    lycdkjdnoy wxkyjgwc 14\\n    lycdkjdnoy qtaqnbi 16\\n    lycdkjdnoy m 18\\n    lycdkjdnoy x 20\\n    lycdkjdnoy jhvdzr 22\\n    lycdkjdnoy rquzz 24\\n    wzlu wxkyjgwc ----\\n    wzlu qtaqnbi 26\\n    wzlu m 28\\n    wzlu x 30\\n    wzlu jhvdzr 32\\n    wzlu rquzz 34\\n    wxkyjgwc qtaqnbi 36\\n    wxkyjgwc m 38\\n    wxkyjgwc x 40\\n    wxkyjgwc jhvdzr 42\\n    wxkyjgwc rquzz 44\\n    qtaqnbi m 46\\n    qtaqnbi x 48\\n    qtaqnbi jhvdzr 50\\n    qtaqnbi rquzz 52\\n    m x ----\\n    m jhvdzr 54\\n    m rquzz 56\\n    x jhvdzr 58\\n    x rquzz 60\\n    jhvdzr rquzz 62"
                    },
                    {
                        "username": "kropochev",
                        "content": "[@Dark_Fang](/Dark_Fang) thanks for the tip"
                    },
                    {
                        "username": "Dark_Fang",
                        "content": "56 - [x, rquzz] and 60 - [m, rquzz]\\nIn both the swaps, you will get \"r\" which is already present in ideas."
                    },
                    {
                        "username": "autf",
                        "content": "I expected a tag of `Set`, but there was no (longer?) one.\\nThere is `Ordered Set` and `Hash Table`, but I don\\'t think they are as precise as `Set`."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "Do not use map instead use unordered_map\\n\\nmap will give you TLE (-_-)  "
                    },
                    {
                        "username": "rainajain_123",
                        "content": "Can we solve this without grouping?"
                    },
                    {
                        "username": "anau99",
                        "content": "The week of hashtable ?"
                    }
                ]
            },
            {
                "id": 1794162,
                "content": [
                    {
                        "username": "nishtha_1412",
                        "content": "Can somebody help me with this solution , like why is it failing.\\n\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         int count = 0;\\n        HashSet<String> set = new HashSet<>();\\n        for (int i = 0; i < ideas.length; i++) {\\n            for (int j = i + 1; j < ideas.length; j++) {\\n                String ideaA = ideas[i];\\n                String ideaB = ideas[j];\\n                char[] ideaAChars = ideaA.toCharArray();\\n                char[] ideaBChars = ideaB.toCharArray();\\n                char temp = ideaAChars[0];\\n                ideaAChars[0] = ideaBChars[0];\\n                ideaBChars[0] = temp;\\n                String newIdeaA = new String(ideaAChars);\\n                String newIdeaB = new String(ideaBChars);\\n                if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {\\n                    count++;\\n                    set.add(newIdeaA + \" \" + newIdeaB);\\n                }\\n            }\\n        }\\n        if(count==1)\\n        return count-1;\\n        else\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Hdrnjd",
                        "content": "I knew it\\'s a TLE from the beginning "
                    },
                    {
                        "username": "Sai_Kumar_Reddy77777",
                        "content": "class Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        #we just created an default dictionary in the form of sets, so that duplicate values are deleted from the sets\\n        d=defaultdict(set)\\n        for i in ideas:\\n            #we just intialized the default dictionary with the first character as a key and the remaining characters of the string as the value\\n            d[i[0]].add(i[1:])\\n        #here we are adding the key values to the array \\n        arr=list(d.keys())\\n        sum,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                a,b=arr[i],arr[j]\\n                #counting the name suggestions\\n                sum+=len(d[a]-d[b])*len(d[b]-d[a])*2\\n        return sum\\n         "
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Imagine buying coffee from soffee chop"
                    },
                    {
                        "username": "racemus",
                        "content": "Can anyone explain why expected output for `[\"phhrrjjcm\",\"zjfkpps\",\"pm\",\"fnpduelfe\",\"mxtvjnq\"]` is `18`?"
                    },
                    {
                        "username": "racemus",
                        "content": "[@kropochev](/kropochev) Thanks"
                    },
                    {
                        "username": "kropochev",
                        "content": "Possibly as shown below, but I\\'m not sure.\\n    phhrrjjcm zjfkpps 2\\n    phhrrjjcm pm ----\\n    phhrrjjcm fnpduelfe 4\\n    phhrrjjcm mxtvjnq 6\\n    zjfkpps pm 8\\n    zjfkpps fnpduelfe 10\\n    zjfkpps mxtvjnq 12\\n    pm fnpduelfe 14\\n    pm mxtvjnq 16\\n    fnpduelfe mxtvjnq 18"
                    },
                    {
                        "username": "kropochev",
                        "content": "Input: ideas = [\"r\",\"lycdkjdnoy\",\"wzlu\",\"wxkyjgwc\",\"qtaqnbi\",\"m\",\"x\",\"jhvdzr\",\"rquzz\"]\\nOutput: 62\\nExpected: 58\\n\\nGot the following list of ideas. But 4 fewer ideas are expected, tell me which ideas are not correct.\\n\\n    r lycdkjdnoy 2\\n    r wzlu 4\\n    r wxkyjgwc 6\\n    r qtaqnbi 8\\n    r m ----\\n    r x ----\\n    r jhvdzr 10\\n    r rquzz ----\\n    lycdkjdnoy wzlu 12\\n    lycdkjdnoy wxkyjgwc 14\\n    lycdkjdnoy qtaqnbi 16\\n    lycdkjdnoy m 18\\n    lycdkjdnoy x 20\\n    lycdkjdnoy jhvdzr 22\\n    lycdkjdnoy rquzz 24\\n    wzlu wxkyjgwc ----\\n    wzlu qtaqnbi 26\\n    wzlu m 28\\n    wzlu x 30\\n    wzlu jhvdzr 32\\n    wzlu rquzz 34\\n    wxkyjgwc qtaqnbi 36\\n    wxkyjgwc m 38\\n    wxkyjgwc x 40\\n    wxkyjgwc jhvdzr 42\\n    wxkyjgwc rquzz 44\\n    qtaqnbi m 46\\n    qtaqnbi x 48\\n    qtaqnbi jhvdzr 50\\n    qtaqnbi rquzz 52\\n    m x ----\\n    m jhvdzr 54\\n    m rquzz 56\\n    x jhvdzr 58\\n    x rquzz 60\\n    jhvdzr rquzz 62"
                    },
                    {
                        "username": "kropochev",
                        "content": "[@Dark_Fang](/Dark_Fang) thanks for the tip"
                    },
                    {
                        "username": "Dark_Fang",
                        "content": "56 - [x, rquzz] and 60 - [m, rquzz]\\nIn both the swaps, you will get \"r\" which is already present in ideas."
                    },
                    {
                        "username": "autf",
                        "content": "I expected a tag of `Set`, but there was no (longer?) one.\\nThere is `Ordered Set` and `Hash Table`, but I don\\'t think they are as precise as `Set`."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "Do not use map instead use unordered_map\\n\\nmap will give you TLE (-_-)  "
                    },
                    {
                        "username": "rainajain_123",
                        "content": "Can we solve this without grouping?"
                    },
                    {
                        "username": "anau99",
                        "content": "The week of hashtable ?"
                    }
                ]
            },
            {
                "id": 1794155,
                "content": [
                    {
                        "username": "nishtha_1412",
                        "content": "Can somebody help me with this solution , like why is it failing.\\n\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         int count = 0;\\n        HashSet<String> set = new HashSet<>();\\n        for (int i = 0; i < ideas.length; i++) {\\n            for (int j = i + 1; j < ideas.length; j++) {\\n                String ideaA = ideas[i];\\n                String ideaB = ideas[j];\\n                char[] ideaAChars = ideaA.toCharArray();\\n                char[] ideaBChars = ideaB.toCharArray();\\n                char temp = ideaAChars[0];\\n                ideaAChars[0] = ideaBChars[0];\\n                ideaBChars[0] = temp;\\n                String newIdeaA = new String(ideaAChars);\\n                String newIdeaB = new String(ideaBChars);\\n                if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {\\n                    count++;\\n                    set.add(newIdeaA + \" \" + newIdeaB);\\n                }\\n            }\\n        }\\n        if(count==1)\\n        return count-1;\\n        else\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Hdrnjd",
                        "content": "I knew it\\'s a TLE from the beginning "
                    },
                    {
                        "username": "Sai_Kumar_Reddy77777",
                        "content": "class Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        #we just created an default dictionary in the form of sets, so that duplicate values are deleted from the sets\\n        d=defaultdict(set)\\n        for i in ideas:\\n            #we just intialized the default dictionary with the first character as a key and the remaining characters of the string as the value\\n            d[i[0]].add(i[1:])\\n        #here we are adding the key values to the array \\n        arr=list(d.keys())\\n        sum,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                a,b=arr[i],arr[j]\\n                #counting the name suggestions\\n                sum+=len(d[a]-d[b])*len(d[b]-d[a])*2\\n        return sum\\n         "
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Imagine buying coffee from soffee chop"
                    },
                    {
                        "username": "racemus",
                        "content": "Can anyone explain why expected output for `[\"phhrrjjcm\",\"zjfkpps\",\"pm\",\"fnpduelfe\",\"mxtvjnq\"]` is `18`?"
                    },
                    {
                        "username": "racemus",
                        "content": "[@kropochev](/kropochev) Thanks"
                    },
                    {
                        "username": "kropochev",
                        "content": "Possibly as shown below, but I\\'m not sure.\\n    phhrrjjcm zjfkpps 2\\n    phhrrjjcm pm ----\\n    phhrrjjcm fnpduelfe 4\\n    phhrrjjcm mxtvjnq 6\\n    zjfkpps pm 8\\n    zjfkpps fnpduelfe 10\\n    zjfkpps mxtvjnq 12\\n    pm fnpduelfe 14\\n    pm mxtvjnq 16\\n    fnpduelfe mxtvjnq 18"
                    },
                    {
                        "username": "kropochev",
                        "content": "Input: ideas = [\"r\",\"lycdkjdnoy\",\"wzlu\",\"wxkyjgwc\",\"qtaqnbi\",\"m\",\"x\",\"jhvdzr\",\"rquzz\"]\\nOutput: 62\\nExpected: 58\\n\\nGot the following list of ideas. But 4 fewer ideas are expected, tell me which ideas are not correct.\\n\\n    r lycdkjdnoy 2\\n    r wzlu 4\\n    r wxkyjgwc 6\\n    r qtaqnbi 8\\n    r m ----\\n    r x ----\\n    r jhvdzr 10\\n    r rquzz ----\\n    lycdkjdnoy wzlu 12\\n    lycdkjdnoy wxkyjgwc 14\\n    lycdkjdnoy qtaqnbi 16\\n    lycdkjdnoy m 18\\n    lycdkjdnoy x 20\\n    lycdkjdnoy jhvdzr 22\\n    lycdkjdnoy rquzz 24\\n    wzlu wxkyjgwc ----\\n    wzlu qtaqnbi 26\\n    wzlu m 28\\n    wzlu x 30\\n    wzlu jhvdzr 32\\n    wzlu rquzz 34\\n    wxkyjgwc qtaqnbi 36\\n    wxkyjgwc m 38\\n    wxkyjgwc x 40\\n    wxkyjgwc jhvdzr 42\\n    wxkyjgwc rquzz 44\\n    qtaqnbi m 46\\n    qtaqnbi x 48\\n    qtaqnbi jhvdzr 50\\n    qtaqnbi rquzz 52\\n    m x ----\\n    m jhvdzr 54\\n    m rquzz 56\\n    x jhvdzr 58\\n    x rquzz 60\\n    jhvdzr rquzz 62"
                    },
                    {
                        "username": "kropochev",
                        "content": "[@Dark_Fang](/Dark_Fang) thanks for the tip"
                    },
                    {
                        "username": "Dark_Fang",
                        "content": "56 - [x, rquzz] and 60 - [m, rquzz]\\nIn both the swaps, you will get \"r\" which is already present in ideas."
                    },
                    {
                        "username": "autf",
                        "content": "I expected a tag of `Set`, but there was no (longer?) one.\\nThere is `Ordered Set` and `Hash Table`, but I don\\'t think they are as precise as `Set`."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "Do not use map instead use unordered_map\\n\\nmap will give you TLE (-_-)  "
                    },
                    {
                        "username": "rainajain_123",
                        "content": "Can we solve this without grouping?"
                    },
                    {
                        "username": "anau99",
                        "content": "The week of hashtable ?"
                    }
                ]
            },
            {
                "id": 1794147,
                "content": [
                    {
                        "username": "nishtha_1412",
                        "content": "Can somebody help me with this solution , like why is it failing.\\n\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         int count = 0;\\n        HashSet<String> set = new HashSet<>();\\n        for (int i = 0; i < ideas.length; i++) {\\n            for (int j = i + 1; j < ideas.length; j++) {\\n                String ideaA = ideas[i];\\n                String ideaB = ideas[j];\\n                char[] ideaAChars = ideaA.toCharArray();\\n                char[] ideaBChars = ideaB.toCharArray();\\n                char temp = ideaAChars[0];\\n                ideaAChars[0] = ideaBChars[0];\\n                ideaBChars[0] = temp;\\n                String newIdeaA = new String(ideaAChars);\\n                String newIdeaB = new String(ideaBChars);\\n                if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {\\n                    count++;\\n                    set.add(newIdeaA + \" \" + newIdeaB);\\n                }\\n            }\\n        }\\n        if(count==1)\\n        return count-1;\\n        else\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Hdrnjd",
                        "content": "I knew it\\'s a TLE from the beginning "
                    },
                    {
                        "username": "Sai_Kumar_Reddy77777",
                        "content": "class Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        #we just created an default dictionary in the form of sets, so that duplicate values are deleted from the sets\\n        d=defaultdict(set)\\n        for i in ideas:\\n            #we just intialized the default dictionary with the first character as a key and the remaining characters of the string as the value\\n            d[i[0]].add(i[1:])\\n        #here we are adding the key values to the array \\n        arr=list(d.keys())\\n        sum,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                a,b=arr[i],arr[j]\\n                #counting the name suggestions\\n                sum+=len(d[a]-d[b])*len(d[b]-d[a])*2\\n        return sum\\n         "
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Imagine buying coffee from soffee chop"
                    },
                    {
                        "username": "racemus",
                        "content": "Can anyone explain why expected output for `[\"phhrrjjcm\",\"zjfkpps\",\"pm\",\"fnpduelfe\",\"mxtvjnq\"]` is `18`?"
                    },
                    {
                        "username": "racemus",
                        "content": "[@kropochev](/kropochev) Thanks"
                    },
                    {
                        "username": "kropochev",
                        "content": "Possibly as shown below, but I\\'m not sure.\\n    phhrrjjcm zjfkpps 2\\n    phhrrjjcm pm ----\\n    phhrrjjcm fnpduelfe 4\\n    phhrrjjcm mxtvjnq 6\\n    zjfkpps pm 8\\n    zjfkpps fnpduelfe 10\\n    zjfkpps mxtvjnq 12\\n    pm fnpduelfe 14\\n    pm mxtvjnq 16\\n    fnpduelfe mxtvjnq 18"
                    },
                    {
                        "username": "kropochev",
                        "content": "Input: ideas = [\"r\",\"lycdkjdnoy\",\"wzlu\",\"wxkyjgwc\",\"qtaqnbi\",\"m\",\"x\",\"jhvdzr\",\"rquzz\"]\\nOutput: 62\\nExpected: 58\\n\\nGot the following list of ideas. But 4 fewer ideas are expected, tell me which ideas are not correct.\\n\\n    r lycdkjdnoy 2\\n    r wzlu 4\\n    r wxkyjgwc 6\\n    r qtaqnbi 8\\n    r m ----\\n    r x ----\\n    r jhvdzr 10\\n    r rquzz ----\\n    lycdkjdnoy wzlu 12\\n    lycdkjdnoy wxkyjgwc 14\\n    lycdkjdnoy qtaqnbi 16\\n    lycdkjdnoy m 18\\n    lycdkjdnoy x 20\\n    lycdkjdnoy jhvdzr 22\\n    lycdkjdnoy rquzz 24\\n    wzlu wxkyjgwc ----\\n    wzlu qtaqnbi 26\\n    wzlu m 28\\n    wzlu x 30\\n    wzlu jhvdzr 32\\n    wzlu rquzz 34\\n    wxkyjgwc qtaqnbi 36\\n    wxkyjgwc m 38\\n    wxkyjgwc x 40\\n    wxkyjgwc jhvdzr 42\\n    wxkyjgwc rquzz 44\\n    qtaqnbi m 46\\n    qtaqnbi x 48\\n    qtaqnbi jhvdzr 50\\n    qtaqnbi rquzz 52\\n    m x ----\\n    m jhvdzr 54\\n    m rquzz 56\\n    x jhvdzr 58\\n    x rquzz 60\\n    jhvdzr rquzz 62"
                    },
                    {
                        "username": "kropochev",
                        "content": "[@Dark_Fang](/Dark_Fang) thanks for the tip"
                    },
                    {
                        "username": "Dark_Fang",
                        "content": "56 - [x, rquzz] and 60 - [m, rquzz]\\nIn both the swaps, you will get \"r\" which is already present in ideas."
                    },
                    {
                        "username": "autf",
                        "content": "I expected a tag of `Set`, but there was no (longer?) one.\\nThere is `Ordered Set` and `Hash Table`, but I don\\'t think they are as precise as `Set`."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "Do not use map instead use unordered_map\\n\\nmap will give you TLE (-_-)  "
                    },
                    {
                        "username": "rainajain_123",
                        "content": "Can we solve this without grouping?"
                    },
                    {
                        "username": "anau99",
                        "content": "The week of hashtable ?"
                    }
                ]
            },
            {
                "id": 1794145,
                "content": [
                    {
                        "username": "nishtha_1412",
                        "content": "Can somebody help me with this solution , like why is it failing.\\n\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         int count = 0;\\n        HashSet<String> set = new HashSet<>();\\n        for (int i = 0; i < ideas.length; i++) {\\n            for (int j = i + 1; j < ideas.length; j++) {\\n                String ideaA = ideas[i];\\n                String ideaB = ideas[j];\\n                char[] ideaAChars = ideaA.toCharArray();\\n                char[] ideaBChars = ideaB.toCharArray();\\n                char temp = ideaAChars[0];\\n                ideaAChars[0] = ideaBChars[0];\\n                ideaBChars[0] = temp;\\n                String newIdeaA = new String(ideaAChars);\\n                String newIdeaB = new String(ideaBChars);\\n                if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {\\n                    count++;\\n                    set.add(newIdeaA + \" \" + newIdeaB);\\n                }\\n            }\\n        }\\n        if(count==1)\\n        return count-1;\\n        else\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Hdrnjd",
                        "content": "I knew it\\'s a TLE from the beginning "
                    },
                    {
                        "username": "Sai_Kumar_Reddy77777",
                        "content": "class Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        #we just created an default dictionary in the form of sets, so that duplicate values are deleted from the sets\\n        d=defaultdict(set)\\n        for i in ideas:\\n            #we just intialized the default dictionary with the first character as a key and the remaining characters of the string as the value\\n            d[i[0]].add(i[1:])\\n        #here we are adding the key values to the array \\n        arr=list(d.keys())\\n        sum,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                a,b=arr[i],arr[j]\\n                #counting the name suggestions\\n                sum+=len(d[a]-d[b])*len(d[b]-d[a])*2\\n        return sum\\n         "
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Imagine buying coffee from soffee chop"
                    },
                    {
                        "username": "racemus",
                        "content": "Can anyone explain why expected output for `[\"phhrrjjcm\",\"zjfkpps\",\"pm\",\"fnpduelfe\",\"mxtvjnq\"]` is `18`?"
                    },
                    {
                        "username": "racemus",
                        "content": "[@kropochev](/kropochev) Thanks"
                    },
                    {
                        "username": "kropochev",
                        "content": "Possibly as shown below, but I\\'m not sure.\\n    phhrrjjcm zjfkpps 2\\n    phhrrjjcm pm ----\\n    phhrrjjcm fnpduelfe 4\\n    phhrrjjcm mxtvjnq 6\\n    zjfkpps pm 8\\n    zjfkpps fnpduelfe 10\\n    zjfkpps mxtvjnq 12\\n    pm fnpduelfe 14\\n    pm mxtvjnq 16\\n    fnpduelfe mxtvjnq 18"
                    },
                    {
                        "username": "kropochev",
                        "content": "Input: ideas = [\"r\",\"lycdkjdnoy\",\"wzlu\",\"wxkyjgwc\",\"qtaqnbi\",\"m\",\"x\",\"jhvdzr\",\"rquzz\"]\\nOutput: 62\\nExpected: 58\\n\\nGot the following list of ideas. But 4 fewer ideas are expected, tell me which ideas are not correct.\\n\\n    r lycdkjdnoy 2\\n    r wzlu 4\\n    r wxkyjgwc 6\\n    r qtaqnbi 8\\n    r m ----\\n    r x ----\\n    r jhvdzr 10\\n    r rquzz ----\\n    lycdkjdnoy wzlu 12\\n    lycdkjdnoy wxkyjgwc 14\\n    lycdkjdnoy qtaqnbi 16\\n    lycdkjdnoy m 18\\n    lycdkjdnoy x 20\\n    lycdkjdnoy jhvdzr 22\\n    lycdkjdnoy rquzz 24\\n    wzlu wxkyjgwc ----\\n    wzlu qtaqnbi 26\\n    wzlu m 28\\n    wzlu x 30\\n    wzlu jhvdzr 32\\n    wzlu rquzz 34\\n    wxkyjgwc qtaqnbi 36\\n    wxkyjgwc m 38\\n    wxkyjgwc x 40\\n    wxkyjgwc jhvdzr 42\\n    wxkyjgwc rquzz 44\\n    qtaqnbi m 46\\n    qtaqnbi x 48\\n    qtaqnbi jhvdzr 50\\n    qtaqnbi rquzz 52\\n    m x ----\\n    m jhvdzr 54\\n    m rquzz 56\\n    x jhvdzr 58\\n    x rquzz 60\\n    jhvdzr rquzz 62"
                    },
                    {
                        "username": "kropochev",
                        "content": "[@Dark_Fang](/Dark_Fang) thanks for the tip"
                    },
                    {
                        "username": "Dark_Fang",
                        "content": "56 - [x, rquzz] and 60 - [m, rquzz]\\nIn both the swaps, you will get \"r\" which is already present in ideas."
                    },
                    {
                        "username": "autf",
                        "content": "I expected a tag of `Set`, but there was no (longer?) one.\\nThere is `Ordered Set` and `Hash Table`, but I don\\'t think they are as precise as `Set`."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "Do not use map instead use unordered_map\\n\\nmap will give you TLE (-_-)  "
                    },
                    {
                        "username": "rainajain_123",
                        "content": "Can we solve this without grouping?"
                    },
                    {
                        "username": "anau99",
                        "content": "The week of hashtable ?"
                    }
                ]
            },
            {
                "id": 1794126,
                "content": [
                    {
                        "username": "nishtha_1412",
                        "content": "Can somebody help me with this solution , like why is it failing.\\n\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         int count = 0;\\n        HashSet<String> set = new HashSet<>();\\n        for (int i = 0; i < ideas.length; i++) {\\n            for (int j = i + 1; j < ideas.length; j++) {\\n                String ideaA = ideas[i];\\n                String ideaB = ideas[j];\\n                char[] ideaAChars = ideaA.toCharArray();\\n                char[] ideaBChars = ideaB.toCharArray();\\n                char temp = ideaAChars[0];\\n                ideaAChars[0] = ideaBChars[0];\\n                ideaBChars[0] = temp;\\n                String newIdeaA = new String(ideaAChars);\\n                String newIdeaB = new String(ideaBChars);\\n                if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {\\n                    count++;\\n                    set.add(newIdeaA + \" \" + newIdeaB);\\n                }\\n            }\\n        }\\n        if(count==1)\\n        return count-1;\\n        else\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Hdrnjd",
                        "content": "I knew it\\'s a TLE from the beginning "
                    },
                    {
                        "username": "Sai_Kumar_Reddy77777",
                        "content": "class Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        #we just created an default dictionary in the form of sets, so that duplicate values are deleted from the sets\\n        d=defaultdict(set)\\n        for i in ideas:\\n            #we just intialized the default dictionary with the first character as a key and the remaining characters of the string as the value\\n            d[i[0]].add(i[1:])\\n        #here we are adding the key values to the array \\n        arr=list(d.keys())\\n        sum,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                a,b=arr[i],arr[j]\\n                #counting the name suggestions\\n                sum+=len(d[a]-d[b])*len(d[b]-d[a])*2\\n        return sum\\n         "
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Imagine buying coffee from soffee chop"
                    },
                    {
                        "username": "racemus",
                        "content": "Can anyone explain why expected output for `[\"phhrrjjcm\",\"zjfkpps\",\"pm\",\"fnpduelfe\",\"mxtvjnq\"]` is `18`?"
                    },
                    {
                        "username": "racemus",
                        "content": "[@kropochev](/kropochev) Thanks"
                    },
                    {
                        "username": "kropochev",
                        "content": "Possibly as shown below, but I\\'m not sure.\\n    phhrrjjcm zjfkpps 2\\n    phhrrjjcm pm ----\\n    phhrrjjcm fnpduelfe 4\\n    phhrrjjcm mxtvjnq 6\\n    zjfkpps pm 8\\n    zjfkpps fnpduelfe 10\\n    zjfkpps mxtvjnq 12\\n    pm fnpduelfe 14\\n    pm mxtvjnq 16\\n    fnpduelfe mxtvjnq 18"
                    },
                    {
                        "username": "kropochev",
                        "content": "Input: ideas = [\"r\",\"lycdkjdnoy\",\"wzlu\",\"wxkyjgwc\",\"qtaqnbi\",\"m\",\"x\",\"jhvdzr\",\"rquzz\"]\\nOutput: 62\\nExpected: 58\\n\\nGot the following list of ideas. But 4 fewer ideas are expected, tell me which ideas are not correct.\\n\\n    r lycdkjdnoy 2\\n    r wzlu 4\\n    r wxkyjgwc 6\\n    r qtaqnbi 8\\n    r m ----\\n    r x ----\\n    r jhvdzr 10\\n    r rquzz ----\\n    lycdkjdnoy wzlu 12\\n    lycdkjdnoy wxkyjgwc 14\\n    lycdkjdnoy qtaqnbi 16\\n    lycdkjdnoy m 18\\n    lycdkjdnoy x 20\\n    lycdkjdnoy jhvdzr 22\\n    lycdkjdnoy rquzz 24\\n    wzlu wxkyjgwc ----\\n    wzlu qtaqnbi 26\\n    wzlu m 28\\n    wzlu x 30\\n    wzlu jhvdzr 32\\n    wzlu rquzz 34\\n    wxkyjgwc qtaqnbi 36\\n    wxkyjgwc m 38\\n    wxkyjgwc x 40\\n    wxkyjgwc jhvdzr 42\\n    wxkyjgwc rquzz 44\\n    qtaqnbi m 46\\n    qtaqnbi x 48\\n    qtaqnbi jhvdzr 50\\n    qtaqnbi rquzz 52\\n    m x ----\\n    m jhvdzr 54\\n    m rquzz 56\\n    x jhvdzr 58\\n    x rquzz 60\\n    jhvdzr rquzz 62"
                    },
                    {
                        "username": "kropochev",
                        "content": "[@Dark_Fang](/Dark_Fang) thanks for the tip"
                    },
                    {
                        "username": "Dark_Fang",
                        "content": "56 - [x, rquzz] and 60 - [m, rquzz]\\nIn both the swaps, you will get \"r\" which is already present in ideas."
                    },
                    {
                        "username": "autf",
                        "content": "I expected a tag of `Set`, but there was no (longer?) one.\\nThere is `Ordered Set` and `Hash Table`, but I don\\'t think they are as precise as `Set`."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "Do not use map instead use unordered_map\\n\\nmap will give you TLE (-_-)  "
                    },
                    {
                        "username": "rainajain_123",
                        "content": "Can we solve this without grouping?"
                    },
                    {
                        "username": "anau99",
                        "content": "The week of hashtable ?"
                    }
                ]
            },
            {
                "id": 1794079,
                "content": [
                    {
                        "username": "nishtha_1412",
                        "content": "Can somebody help me with this solution , like why is it failing.\\n\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         int count = 0;\\n        HashSet<String> set = new HashSet<>();\\n        for (int i = 0; i < ideas.length; i++) {\\n            for (int j = i + 1; j < ideas.length; j++) {\\n                String ideaA = ideas[i];\\n                String ideaB = ideas[j];\\n                char[] ideaAChars = ideaA.toCharArray();\\n                char[] ideaBChars = ideaB.toCharArray();\\n                char temp = ideaAChars[0];\\n                ideaAChars[0] = ideaBChars[0];\\n                ideaBChars[0] = temp;\\n                String newIdeaA = new String(ideaAChars);\\n                String newIdeaB = new String(ideaBChars);\\n                if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {\\n                    count++;\\n                    set.add(newIdeaA + \" \" + newIdeaB);\\n                }\\n            }\\n        }\\n        if(count==1)\\n        return count-1;\\n        else\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Hdrnjd",
                        "content": "I knew it\\'s a TLE from the beginning "
                    },
                    {
                        "username": "Sai_Kumar_Reddy77777",
                        "content": "class Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        #we just created an default dictionary in the form of sets, so that duplicate values are deleted from the sets\\n        d=defaultdict(set)\\n        for i in ideas:\\n            #we just intialized the default dictionary with the first character as a key and the remaining characters of the string as the value\\n            d[i[0]].add(i[1:])\\n        #here we are adding the key values to the array \\n        arr=list(d.keys())\\n        sum,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                a,b=arr[i],arr[j]\\n                #counting the name suggestions\\n                sum+=len(d[a]-d[b])*len(d[b]-d[a])*2\\n        return sum\\n         "
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Imagine buying coffee from soffee chop"
                    },
                    {
                        "username": "racemus",
                        "content": "Can anyone explain why expected output for `[\"phhrrjjcm\",\"zjfkpps\",\"pm\",\"fnpduelfe\",\"mxtvjnq\"]` is `18`?"
                    },
                    {
                        "username": "racemus",
                        "content": "[@kropochev](/kropochev) Thanks"
                    },
                    {
                        "username": "kropochev",
                        "content": "Possibly as shown below, but I\\'m not sure.\\n    phhrrjjcm zjfkpps 2\\n    phhrrjjcm pm ----\\n    phhrrjjcm fnpduelfe 4\\n    phhrrjjcm mxtvjnq 6\\n    zjfkpps pm 8\\n    zjfkpps fnpduelfe 10\\n    zjfkpps mxtvjnq 12\\n    pm fnpduelfe 14\\n    pm mxtvjnq 16\\n    fnpduelfe mxtvjnq 18"
                    },
                    {
                        "username": "kropochev",
                        "content": "Input: ideas = [\"r\",\"lycdkjdnoy\",\"wzlu\",\"wxkyjgwc\",\"qtaqnbi\",\"m\",\"x\",\"jhvdzr\",\"rquzz\"]\\nOutput: 62\\nExpected: 58\\n\\nGot the following list of ideas. But 4 fewer ideas are expected, tell me which ideas are not correct.\\n\\n    r lycdkjdnoy 2\\n    r wzlu 4\\n    r wxkyjgwc 6\\n    r qtaqnbi 8\\n    r m ----\\n    r x ----\\n    r jhvdzr 10\\n    r rquzz ----\\n    lycdkjdnoy wzlu 12\\n    lycdkjdnoy wxkyjgwc 14\\n    lycdkjdnoy qtaqnbi 16\\n    lycdkjdnoy m 18\\n    lycdkjdnoy x 20\\n    lycdkjdnoy jhvdzr 22\\n    lycdkjdnoy rquzz 24\\n    wzlu wxkyjgwc ----\\n    wzlu qtaqnbi 26\\n    wzlu m 28\\n    wzlu x 30\\n    wzlu jhvdzr 32\\n    wzlu rquzz 34\\n    wxkyjgwc qtaqnbi 36\\n    wxkyjgwc m 38\\n    wxkyjgwc x 40\\n    wxkyjgwc jhvdzr 42\\n    wxkyjgwc rquzz 44\\n    qtaqnbi m 46\\n    qtaqnbi x 48\\n    qtaqnbi jhvdzr 50\\n    qtaqnbi rquzz 52\\n    m x ----\\n    m jhvdzr 54\\n    m rquzz 56\\n    x jhvdzr 58\\n    x rquzz 60\\n    jhvdzr rquzz 62"
                    },
                    {
                        "username": "kropochev",
                        "content": "[@Dark_Fang](/Dark_Fang) thanks for the tip"
                    },
                    {
                        "username": "Dark_Fang",
                        "content": "56 - [x, rquzz] and 60 - [m, rquzz]\\nIn both the swaps, you will get \"r\" which is already present in ideas."
                    },
                    {
                        "username": "autf",
                        "content": "I expected a tag of `Set`, but there was no (longer?) one.\\nThere is `Ordered Set` and `Hash Table`, but I don\\'t think they are as precise as `Set`."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "Do not use map instead use unordered_map\\n\\nmap will give you TLE (-_-)  "
                    },
                    {
                        "username": "rainajain_123",
                        "content": "Can we solve this without grouping?"
                    },
                    {
                        "username": "anau99",
                        "content": "The week of hashtable ?"
                    }
                ]
            },
            {
                "id": 1794073,
                "content": [
                    {
                        "username": "nishtha_1412",
                        "content": "Can somebody help me with this solution , like why is it failing.\\n\\nclass Solution {\\n    public long distinctNames(String[] ideas) {\\n         int count = 0;\\n        HashSet<String> set = new HashSet<>();\\n        for (int i = 0; i < ideas.length; i++) {\\n            for (int j = i + 1; j < ideas.length; j++) {\\n                String ideaA = ideas[i];\\n                String ideaB = ideas[j];\\n                char[] ideaAChars = ideaA.toCharArray();\\n                char[] ideaBChars = ideaB.toCharArray();\\n                char temp = ideaAChars[0];\\n                ideaAChars[0] = ideaBChars[0];\\n                ideaBChars[0] = temp;\\n                String newIdeaA = new String(ideaAChars);\\n                String newIdeaB = new String(ideaBChars);\\n                if (!set.contains(newIdeaA) && !set.contains(newIdeaB)) {\\n                    count++;\\n                    set.add(newIdeaA + \" \" + newIdeaB);\\n                }\\n            }\\n        }\\n        if(count==1)\\n        return count-1;\\n        else\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "Hdrnjd",
                        "content": "I knew it\\'s a TLE from the beginning "
                    },
                    {
                        "username": "Sai_Kumar_Reddy77777",
                        "content": "class Solution:\\n    def distinctNames(self, ideas: List[str]) -> int:\\n        #we just created an default dictionary in the form of sets, so that duplicate values are deleted from the sets\\n        d=defaultdict(set)\\n        for i in ideas:\\n            #we just intialized the default dictionary with the first character as a key and the remaining characters of the string as the value\\n            d[i[0]].add(i[1:])\\n        #here we are adding the key values to the array \\n        arr=list(d.keys())\\n        sum,n=0,len(arr)\\n        for i in range(n):\\n            for j in range(i+1,n):\\n                a,b=arr[i],arr[j]\\n                #counting the name suggestions\\n                sum+=len(d[a]-d[b])*len(d[b]-d[a])*2\\n        return sum\\n         "
                    },
                    {
                        "username": "yatharth-kumar",
                        "content": "Imagine buying coffee from soffee chop"
                    },
                    {
                        "username": "racemus",
                        "content": "Can anyone explain why expected output for `[\"phhrrjjcm\",\"zjfkpps\",\"pm\",\"fnpduelfe\",\"mxtvjnq\"]` is `18`?"
                    },
                    {
                        "username": "racemus",
                        "content": "[@kropochev](/kropochev) Thanks"
                    },
                    {
                        "username": "kropochev",
                        "content": "Possibly as shown below, but I\\'m not sure.\\n    phhrrjjcm zjfkpps 2\\n    phhrrjjcm pm ----\\n    phhrrjjcm fnpduelfe 4\\n    phhrrjjcm mxtvjnq 6\\n    zjfkpps pm 8\\n    zjfkpps fnpduelfe 10\\n    zjfkpps mxtvjnq 12\\n    pm fnpduelfe 14\\n    pm mxtvjnq 16\\n    fnpduelfe mxtvjnq 18"
                    },
                    {
                        "username": "kropochev",
                        "content": "Input: ideas = [\"r\",\"lycdkjdnoy\",\"wzlu\",\"wxkyjgwc\",\"qtaqnbi\",\"m\",\"x\",\"jhvdzr\",\"rquzz\"]\\nOutput: 62\\nExpected: 58\\n\\nGot the following list of ideas. But 4 fewer ideas are expected, tell me which ideas are not correct.\\n\\n    r lycdkjdnoy 2\\n    r wzlu 4\\n    r wxkyjgwc 6\\n    r qtaqnbi 8\\n    r m ----\\n    r x ----\\n    r jhvdzr 10\\n    r rquzz ----\\n    lycdkjdnoy wzlu 12\\n    lycdkjdnoy wxkyjgwc 14\\n    lycdkjdnoy qtaqnbi 16\\n    lycdkjdnoy m 18\\n    lycdkjdnoy x 20\\n    lycdkjdnoy jhvdzr 22\\n    lycdkjdnoy rquzz 24\\n    wzlu wxkyjgwc ----\\n    wzlu qtaqnbi 26\\n    wzlu m 28\\n    wzlu x 30\\n    wzlu jhvdzr 32\\n    wzlu rquzz 34\\n    wxkyjgwc qtaqnbi 36\\n    wxkyjgwc m 38\\n    wxkyjgwc x 40\\n    wxkyjgwc jhvdzr 42\\n    wxkyjgwc rquzz 44\\n    qtaqnbi m 46\\n    qtaqnbi x 48\\n    qtaqnbi jhvdzr 50\\n    qtaqnbi rquzz 52\\n    m x ----\\n    m jhvdzr 54\\n    m rquzz 56\\n    x jhvdzr 58\\n    x rquzz 60\\n    jhvdzr rquzz 62"
                    },
                    {
                        "username": "kropochev",
                        "content": "[@Dark_Fang](/Dark_Fang) thanks for the tip"
                    },
                    {
                        "username": "Dark_Fang",
                        "content": "56 - [x, rquzz] and 60 - [m, rquzz]\\nIn both the swaps, you will get \"r\" which is already present in ideas."
                    },
                    {
                        "username": "autf",
                        "content": "I expected a tag of `Set`, but there was no (longer?) one.\\nThere is `Ordered Set` and `Hash Table`, but I don\\'t think they are as precise as `Set`."
                    },
                    {
                        "username": "CHIIKUU",
                        "content": "Do not use map instead use unordered_map\\n\\nmap will give you TLE (-_-)  "
                    },
                    {
                        "username": "rainajain_123",
                        "content": "Can we solve this without grouping?"
                    },
                    {
                        "username": "anau99",
                        "content": "The week of hashtable ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum XOR After Operations ",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. In one operation, select <strong>any</strong> non-negative integer <code>x</code> and an index <code>i</code>, then <strong>update</strong> <code>nums[i]</code> to be equal to <code>nums[i] AND (nums[i] XOR x)</code>.</p>\n\n<p>Note that <code>AND</code> is the bitwise AND operation and <code>XOR</code> is the bitwise XOR operation.</p>\n\n<p>Return <em>the <strong>maximum</strong> possible bitwise XOR of all elements of </em><code>nums</code><em> after applying the operation <strong>any number</strong> of times</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,4,6]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Apply the operation with x = 4 and i = 3, num[3] = 6 AND (6 XOR 4) = 6 AND 2 = 2.\nNow, nums = [3, 2, 4, 2] and the bitwise XOR of all the elements = 3 XOR 2 XOR 4 XOR 2 = 7.\nIt can be shown that 7 is the maximum possible bitwise XOR.\nNote that other operations may be used to achieve a bitwise XOR of 7.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,9,2]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> Apply the operation zero times.\nThe bitwise XOR of all the elements = 1 XOR 2 XOR 3 XOR 9 XOR 2 = 11.\nIt can be shown that 11 is the maximum possible bitwise XOR.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2195929,
                "title": "java-c-python-1-line-solution-or-of-all-elements",
                "content": "# **Explanation**\\nThe maximum possible result is `res = A[0] || A[1] || A[2] ... ` and it\\'s realisiable.\\n\\n# **Prove**\\nNow we approve it\\'s realisiable.\\nAssume result is `best = XOR(A[i])` and `best < res` above.\\nThere is at least one bit difference between `best` and `res`, assume it\\'s `x = 1 << k`.\\n\\nWe can find at least a `A[i]` that `A[i] & x = x`.\\n\\nwe apply `x` on `A[i]`, `A[i]` is updated to `A[i] & (A[i] ^ x) = A[i] ^ x`.\\nWe had `best = XOR(A[i])` as said above,\\nnow we have `best2 = XOR(A[i]) ^ x`,\\nso we get a better `best2 > best`, where we prove by contradiction.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int maximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        for (int a : nums)\\n            res |= a;\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int maximumXOR(vector<int>& nums) {\\n        return reduce(nums.begin(), nums.end(), 0, bit_or());\\n    }\\n```\\n**Python**\\n```py\\n    def maximumXOR(self, nums):\\n        return reduce(ior, nums)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }\\n```\n```cpp\\n    int maximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        for (int a : nums)\\n            res |= a;\\n        return res;\\n    }\\n```\n```cpp\\n    int maximumXOR(vector<int>& nums) {\\n        return reduce(nums.begin(), nums.end(), 0, bit_or());\\n    }\\n```\n```py\\n    def maximumXOR(self, nums):\\n        return reduce(ior, nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2196294,
                "title": "thought-process-explained-basic-intuition-to-optimise",
                "content": "So during the contest, Initialy I thought about using tries(a most famous based on xor) but here doesn\\'t make sense. So let\\'s understand the problem first :\\n\\nSo what we\\'re going to do in each step :\\n1. pick any i-th element let\\'s say y\\n2. pick any x\\n3. make x^y\\n4. and put (x&y) at i-th position \\n\\nSo let\\'s know more about & :\\n* x&y will never add extra set bit in the result. Suppose x has n bit than after doing & operation on x you can\\'t get n+1 bits ***but we can reduct the set bit from n to any number [0...n]***\\n* Ok! So what\\'s the use of above things in this question :\\n\\n**Since you\\'re main aim to get maximum xor of elements**\\n\\nSo suppose after doing xor [3,2,4,6] we\\'re getting 1\\n\\n3 => 0 0 1 1\\n2 => 0 0 1 0\\n4 => 0 1 0 0\\n6 => 0 1 1 0\\n---------\\nxor => 0 0 1 1\\n---------\\nok so what thinks are reducing the xor? i.e. number of bit\\'s position which comes even times from all elements?\\nRight? So what if I reduce that bit and make it unset using &(yeah we\\'re now using & to reduce that bit) so that it\\'ll contribute in the result.\\n\\nSo finally :\\n* find the frequency of all set bit from array :\\n* if bit\\'s frequency is 0 than you can\\'t do any things because that bit\\'s are absent and there is not way to add using &.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> bits(32,0);\\n        for(int &i:nums) {\\n            for(int j=31;j>=0;j--) {\\n                if((i>>j)&1) {\\n                    bits[j]++;\\n                }\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0;i<32;i++) {\\n            if(bits[i]) {\\n                res = res | 1<<i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut after contest and reading some discuss I found that I am just including all set bits no matter it comes even times and odd times, I am including. How?\\nI know if frequency comes even times than we can reduce it by & and make it odd so that it\\'ll be consider into xor.\\nSo let\\'s refactor the code.\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        for(int &i:nums) res |= i;\\n        return res;\\n    }\\n};\\n```\\n***Please upvote if you it help you.***\\n***Thanks for reading.***\\n***Happy Coding!***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> bits(32,0);\\n        for(int &i:nums) {\\n            for(int j=31;j>=0;j--) {\\n                if((i>>j)&1) {\\n                    bits[j]++;\\n                }\\n            }\\n        }\\n        int res = 0;\\n        for(int i=0;i<32;i++) {\\n            if(bits[i]) {\\n                res = res | 1<<i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        for(int &i:nums) res |= i;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196006,
                "title": "simplest-o-n-solution-with-explanation",
                "content": "`nums[i] AND (nums[i] XOR x)` where *x is ANY integer*, basically means you can decrease that element into any number but can\\'t increase it.\\n*Reread the above statement. That\\'s the key to solving the problem!*\\n* AND operation can only allow a 1 to be 0 but not a 0 to become 1.\\n* XOR of elements is maximised by getting distinct combination of a 0 and 1.\\n* So bascially in the answer you get a 0 where all numbers in array have the bit place values 0, as there is no way to make it into a 1 .\\n* Rest can be made into a 1, as atleast one number in the array has a bit place value 1.\\n* And obviously you can check if atleast one of the element has a place value 1 by doing a cumulative OR.\\n\\nSketch out the given TCs in binary bits and do a dry run, I bet you will understand this completely! \\nComment if you have any doubts.\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res=0;\\n        for(int i=0; i<nums.length; i++) res |= nums[i];\\n        return res;\\n    }\\n}\\n```\\nDo upvote if this helps and what was your approach?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res=0;\\n        for(int i=0; i<nums.length; i++) res |= nums[i];\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195885,
                "title": "3-lines-of-code-with-explanation-c",
                "content": "`nums[i] & (nums[i]^x)` cannot be more than `nums[i]` because we are taking **AND.**\\nSo this implies that for any number we can set the bits `OFF`  ***(only the bits which are already `ON` (1))*** .\\n**BUT** we cannot set any bit` ON `if it were `OFF `already .\\n\\nTherefore , we can say that we will set bits ON and OFF for all numbers in such a way that `XOR` of all the numbers is equal to `OR` of all numbers. Because if a bit is not on in any of the numbers ,there is no way we can get it on in our ans.\\n\\n```\\nint y = 0;\\nfor(int x :nums)y = y|x;\\nreturn y;\\n```",
                "solutionTags": [],
                "code": "```\\nint y = 0;\\nfor(int x :nums)y = y|x;\\nreturn y;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195825,
                "title": "one-liner",
                "content": "An operation can remove a bit, but cannot add one.\\n    \\nSo, the maximum result would contain bits from all elements in the input array.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(or_, nums)\\n```\\n\\n**C++**\\n```cpp\\nint maximumXOR(vector<int>& nums) {\\n    return accumulate(begin(nums), end(nums), 0, bit_or<int>());\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(or_, nums)\\n```\n```cpp\\nint maximumXOR(vector<int>& nums) {\\n    return accumulate(begin(nums), end(nums), 0, bit_or<int>());\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217648,
                "title": "explained-c-python-java",
                "content": "**UPVOTE IF HELPFuul**\\n\\nEvery once in a while try using paper-pen. -> useful for finding pattern, cant just think about these.\\n\\nUpon converting to binary, there will be a pattern.\\nResult is **OR of all elements** .\\n\\n**OBSERvATION=>** ```nums[i] AND (nums[i] XOR x)```  \\nWith this operation, we can modify each element and adjust it to provide max XOR.\\n\\nBut with **AND** operation applied to ```nums[i]``` , it can be positively said that none of bits of nums[i] can be converted from **0** to **1**. \\nBut the converse could be done, Bit can be changed from 1 -> 0.\\n\\nHence if all **i**th bits for all nums are```0```, XOR for that bit will also be zero.  ```[ 0 XOR 0 = 1 ]```\\nBut if atleast single bit at **i**th position is ```1```, we can have a combination of other bits to give ```XOR =1``` for that bit\\n\\n\\n```\\nnums = [ 3, 2, 4, 6 ]                   nums = [ 9, 64, 25, 19 ]\\n\\n3   -> 0 | 1 | 1                        9   -> 0 | 0 | 0 | 1 | 0 | 0 | 1\\n2   -> 0 | 1 | 0                        64  -> 1 | 0 | 0 | 0 | 0 | 0 | 0\\n4   -> 1 | 0 | 0                        25  -> 0 | 0 | 1 | 1 | 0 | 0 | 1\\n6   -> 1 | 1 | 0                        19  -> 0 | 0 | 1 | 0 | 0 | 1 | 1\\n       ----------                              -------------------------\\nres -> 1 | 1 | 1                        res -> 1 | 0 | 1 | 1 | 0 | 1 | 1\\nres = 7                                 res = 91\\n\\n\\nnums = [ 1, 2, 3, 9, 2 ]\\n\\n1   -> 0 | 0 | 0 | 1\\n2   -> 0 | 0 | 1 | 0\\n3   -> 0 | 0 | 1 | 1\\n9   -> 1 | 0 | 0 | 1\\n2   -> 0 | 0 | 1 | 0\\n       -------------\\nres -> 1 | 0 | 1 | 1\\nres = 11\\n```\\n\\nA few Dry runs to show the result is **OR** operation applied on the array.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            res |= nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n**PYTHON**\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        res=0\\n        for i in nums:\\n            res |= i\\n        return res\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int i=0; i<nums.length; i++){\\n            res |= nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/a3c40fd5-21ac-4ad0-9fb1-491bead205ae_1656579946.7431452.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```nums[i] AND (nums[i] XOR x)```\n```nums[i]```\n```0```\n```[ 0 XOR 0 = 1 ]```\n```1```\n```XOR =1```\n```\\nnums = [ 3, 2, 4, 6 ]                   nums = [ 9, 64, 25, 19 ]\\n\\n3   -> 0 | 1 | 1                        9   -> 0 | 0 | 0 | 1 | 0 | 0 | 1\\n2   -> 0 | 1 | 0                        64  -> 1 | 0 | 0 | 0 | 0 | 0 | 0\\n4   -> 1 | 0 | 0                        25  -> 0 | 0 | 1 | 1 | 0 | 0 | 1\\n6   -> 1 | 1 | 0                        19  -> 0 | 0 | 1 | 0 | 0 | 1 | 1\\n       ----------                              -------------------------\\nres -> 1 | 1 | 1                        res -> 1 | 0 | 1 | 1 | 0 | 1 | 1\\nres = 7                                 res = 91\\n\\n\\nnums = [ 1, 2, 3, 9, 2 ]\\n\\n1   -> 0 | 0 | 0 | 1\\n2   -> 0 | 0 | 1 | 0\\n3   -> 0 | 0 | 1 | 1\\n9   -> 1 | 0 | 0 | 1\\n2   -> 0 | 0 | 1 | 0\\n       -------------\\nres -> 1 | 0 | 1 | 1\\nres = 11\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        for (int i=0; i<nums.size() ; i++){\\n            res |= nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        res=0\\n        for i in nums:\\n            res |= i\\n        return res\\n```\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int i=0; i<nums.length; i++){\\n            res |= nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196041,
                "title": "c-bit-manipulation-time-o-nlogn-explaination-added",
                "content": "**Concept- If we XOR odd number of ones then we\\nget 1 and if we XOR even number of ones then\\nwe will get 0.**\\n**1^1^1^.....^1(odd number of times)=1\\n1^1^1^.....^1(even number of times)=0**\\n**Steps-**\\n* Each number has bits when we convert it into\\nbinary. Eg. 4 has 3 bits which are 100.\\nSo First we will find the maximum number of bits\\nfrom numbers present in nums.\\n* Count zeroes and ones at each bit position.\\n* If bits are the number of bits then we iterate at each bit\\nposition and check if it ones are odd at this \\nposition, if it is then we will store one \\nand if it is not then is ones are not zero then\\nwe can get 1 as we can convert a 1 to 0 not 0\\nto 1 because of AND opertion.\\n* Calculate the answer.\\n\\n\\n**Better Understaing**\\n**Eg.\\nnums:[3,2,4,6]\\nWRITING BITS FOR EACH NUMBER-**\\n**3-011\\n2-010\\n4-100\\n6-110**\\n\\nTHERE ARE 3 BITS LETS WRITE THE NUMBER OF ONES AND ZEROES FOR EACH POSITION.\\nOnes-[2,3,1]\\nZeroes-[2,1,3]\\nAt index 2, there are 1 ones which is odd so we can get one at this bit position. Similarly for \\nindex 1, ones are odd, but for index 0 ones are even which is 2. In what condition we can get \\none at this bits position? We have to make a 1 to 0 or a zero to 1 to convert ones to odd.\\nIf we convert a 0 to 1 it will not work because when we AND with the same number it will \\nagain yield a zero at this position. So we will convert a 1 to 0 so make ones odd. It is only \\npossible when count of ones are not zero.\\nI hope you got it!!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int num=nums[n-1]; //maximum number of bits will be present in the largest number\\n        int bits=0; //counting the bits for the maximum  number of bits among all the numbers\\n        while(num>0){\\n            num=num>>1;\\n            bits++;\\n        }\\n        vector<int> ones(bits,0), zeroes(bits,0); //ones will store number of ones at this bit position in every number\\n        for(int i=0;i<n;i++){\\n            num=nums[i];\\n            int idx=0;\\n            while(num>0){\\n                int bit=num&1;//checking current bit is 1 or 0\\n                if(bit){\\n                    ones[idx]++;\\n                }else{\\n                    zeroes[idx]++;\\n                }\\n                num=num>>1;\\n                idx++;\\n            }\\n            \\n            \\n            //if idx is less then maximum number of bits then increasing the zeroes for those position\\n            while(idx<bits){\\n                zeroes[idx]++;\\n                idx++;\\n            }\\n        }\\n        \\n        \\n        //If number of ones is odd then we can get 1 bit at this position or if one is even then count of ones at this position must not be zero otherwise this position we will put 0\\n        vector<int> v;\\n        for(int i=0;i<bits;i++){\\n            if(ones[i]%2!=0){\\n                v.push_back(1);\\n            }else if(ones[i]>0){\\n                v.push_back(1);\\n            }else{\\n                v.push_back(0);\\n            }\\n        }\\n        \\n        //Calculating the final answer\\n        int res=0;\\n        for(int i=0;i<bits;i++){\\n            res=res+pow(2,i)*v[i];\\n        }\\n\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int num=nums[n-1]; //maximum number of bits will be present in the largest number\\n        int bits=0; //counting the bits for the maximum  number of bits among all the numbers\\n        while(num>0){\\n            num=num>>1;\\n            bits++;\\n        }\\n        vector<int> ones(bits,0), zeroes(bits,0); //ones will store number of ones at this bit position in every number\\n        for(int i=0;i<n;i++){\\n            num=nums[i];\\n            int idx=0;\\n            while(num>0){\\n                int bit=num&1;//checking current bit is 1 or 0\\n                if(bit){\\n                    ones[idx]++;\\n                }else{\\n                    zeroes[idx]++;\\n                }\\n                num=num>>1;\\n                idx++;\\n            }\\n            \\n            \\n            //if idx is less then maximum number of bits then increasing the zeroes for those position\\n            while(idx<bits){\\n                zeroes[idx]++;\\n                idx++;\\n            }\\n        }\\n        \\n        \\n        //If number of ones is odd then we can get 1 bit at this position or if one is even then count of ones at this position must not be zero otherwise this position we will put 0\\n        vector<int> v;\\n        for(int i=0;i<bits;i++){\\n            if(ones[i]%2!=0){\\n                v.push_back(1);\\n            }else if(ones[i]>0){\\n                v.push_back(1);\\n            }else{\\n                v.push_back(0);\\n            }\\n        }\\n        \\n        //Calculating the final answer\\n        int res=0;\\n        for(int i=0;i<bits;i++){\\n            res=res+pow(2,i)*v[i];\\n        }\\n\\n        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196106,
                "title": "java-python-3-bit-manipulations-w-brief-explanation-and-analysis",
                "content": "**Key observation: `nums[i] & (nums[i] ^ x) <= nums[i]`**. Therefoe, we can only set off the `1` bits of each number if necessary, in order to make greatest of the xor all numbers after operations.\\n\\nSince 2<sup>27</sup> > 10<sup>8</sup>, we can traverse the left-most `28` bits to count how many `1`\\'s on each bits.\\n1. Count each set bit (`1` bit) on the `0th`, `1st`, `2nd`, ..., `27th` bit; if greater than `0`, we can make it odd so that the xor of all elements on that bit will be `1`;\\n2. For each bit, add it (use `|=`) to the result.\\n\\n```java\\n    public int maximumXOR(int[] nums) {\\n        int[] cnt = new int[28];\\n        int maxXor = 0;\\n        for (int i = 0; i < 28; ++i) {\\n            for (int num : nums) {\\n                if (((num >> i) & 1) != 0) {\\n                    ++cnt[i];\\n                }\\n            }\\n            if (cnt[i] > 0) {\\n                maxXor |= 1 << i; \\n            }\\n        }\\n        return maxXor;\\n    }\\n```\\n\\n```python\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        cnt = [0] * 28\\n        maxXor = 0            \\n        for i in range(28):\\n            for num in nums:\\n                if (num & (1 << i)) > 0:\\n                    cnt[i] += 1\\n            if cnt[i] > 0:        \\n                maxXor |= (1 << i)\\n        return maxXor\\n```\\n\\n-----\\n\\nBased from the above explanation, as long as there are at least `1` set bit on a certain bit (say `ith` bit) , we can set that bit (`ith` bit) `1`. Therefore, that is bitwise or `|` operation. Therefore, we can simplify the above codes as follows:\\n\\n```java\\n    public int maximumXOR(int[] nums) {\\n        return IntStream.of(nums).reduce(0, (a, b) -> a | b);\\n    }\\n```\\n```python\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return functools.reduce(operator.ior, nums, 0)\\n```\\n\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = nums.length`.",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```java\\n    public int maximumXOR(int[] nums) {\\n        int[] cnt = new int[28];\\n        int maxXor = 0;\\n        for (int i = 0; i < 28; ++i) {\\n            for (int num : nums) {\\n                if (((num >> i) & 1) != 0) {\\n                    ++cnt[i];\\n                }\\n            }\\n            if (cnt[i] > 0) {\\n                maxXor |= 1 << i; \\n            }\\n        }\\n        return maxXor;\\n    }\\n```\n```python\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        cnt = [0] * 28\\n        maxXor = 0            \\n        for i in range(28):\\n            for num in nums:\\n                if (num & (1 << i)) > 0:\\n                    cnt[i] += 1\\n            if cnt[i] > 0:        \\n                maxXor |= (1 << i)\\n        return maxXor\\n```\n```java\\n    public int maximumXOR(int[] nums) {\\n        return IntStream.of(nums).reduce(0, (a, b) -> a | b);\\n    }\\n```\n```python\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return functools.reduce(operator.ior, nums, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2195861,
                "title": "c-simple-or-operation",
                "content": "```\\nlet take some example\\nsuppose arr = {1,2,3,9}\\nnow we will find have bit of all these\\n1 -> 0001\\n2 -> 0010\\n3 -> 0011\\n9 -> 1001\\nnow to get maximum answer we should have as many as 1 bits possible in \\nanswer so for that we need to use OR operation, \\nso that we get maximum of 1 bits in every place of answer\\n\\n1011 as answer which is equal to 11.\\n```\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maximumXOR(vector<int>& nums) {\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor(auto x:nums) res|=x;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "```\\nlet take some example\\nsuppose arr = {1,2,3,9}\\nnow we will find have bit of all these\\n1 -> 0001\\n2 -> 0010\\n3 -> 0011\\n9 -> 1001\\nnow to get maximum answer we should have as many as 1 bits possible in \\nanswer so for that we need to use OR operation, \\nso that we get maximum of 1 bits in every place of answer\\n\\n1011 as answer which is equal to 11.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2373604,
                "title": "c-beginner-friendly-explanation",
                "content": "**Approach:**\\n\\n* ```nums[i] AND (nums[i] XOR x)```\\n* with the above operation we can modify any nums[i] right\\n* as we are taking ```AND```, we can say that none of the bits of nums[i] can be converted from 0 to 1 \\n* on the other hand, we can convert a bit from 1 to 0\\n\\t* as we can choose x such that nums[i]^x = 0 at that ith bit then its & with nums[i] will result in 0\\n\\t* 1&0 = 0\\n* now to maximize the final answer we want as many 1 as possible in the final value\\n* So, if there exist atleast a single bit at ith position whose value is 1, we can have a combination of other bits to give XOR =1 for that bit\\n\\t* how?\\n\\t\\t* we can make all the other elements ith bit = 0 then the xor of all the elements at this ith bit will be\\n\\t\\t* 1^0^0...^0 = 1\\n* So, in conclusion if the ith bit of any element is 1 then the ith bit of our final answer will be 1 too and if all the elements has their ith bit =0 then the ith bit of our answer will be 0\\n* you can clearly guess from the above statement that we just want the OR of all the elements\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int maximumXOR(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n            ans |= nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```nums[i] AND (nums[i] XOR x)```\n```AND```\n```\\nclass Solution\\n{\\npublic:\\n    int maximumXOR(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int ans = 0;\\n        for (int i = 0; i < n; i++)\\n            ans |= nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366537,
                "title": "python3-1-line-bit-operations-w-explanation-t-m-88-87",
                "content": "Points to consider:\\n\\n*  The problem calls for choosing an integer x, selecting an element n of the list, applying the compound operator op(n,x) = (x&n)^n,  and taking the bit-intersection of the modified set. Because of the associative and commutative properties of the XOR operator, it does not matter which n we choose in nums. \\n\\n*   Below is the truth table for op(num,x)\\n![image](https://assets.leetcode.com/users/images/3d54169a-85a0-466e-829c-08d2ff436128_1659383847.6181347.png)\\n    The end result is that the op leaves num\\'s bit unchanged unless x and num are both 1, in which case that bit of num becomes 0. It follows that by choosing x wisely, we can erase any bits in any of the elements of nums. \\n\\n*  For example:\\n              _ _ _ _ _ _ _ _ _ 3 =  0x4 + 1x2 + 1x1  = 011 (base2)\\n\\t\\t\\t  _ _ _ _ _ _ _ _ _ 2 =  0x4 + 1x2 + 0x1  = 010 (base2)\\n\\t\\t\\t  _ _ _ _ _ _ _ _ _ 4 =  1x4 + 0x2 + 0x1  = 100 (base2)\\n              _ _ _ _ _ _ _ _ _ 6 =  1x4 + 1x2 + 0x1  = 110 (base2)\\n\\t\\t\\t  \\n_ _ _ _ _ _ XOR (3,2,4,6)\\t=  0x4 + 1x2 + 1x1 = 011 (base2) = 3\\n\\nIn the base 2 representation of the XOR, the 4s digit is 0 because the bit-XOR of the 4s digits in nums,\\nXOR(0,0,1,1) = 0 because there\\'s an even number of 1s. And:\\n  2s digits:  XOR(1,1,0,1)  => 2s digit of XOR(nums) = 1 because #of 1s is odd\\n   1s digits:  XOR(1,0,0,0)  => 1s digit of XOR(nums) = 1 because #of 1s is odd\\n   \\n*    After applying Op(4,6) = 2 to nums[3]:\\n              _ _ _ _ _ _ _ _ _ 3 =  0x4 + 1x2 + 1x1  = 011 (base2)\\n\\t\\t\\t  _ _ _ _ _ _ _ _ _ 2 =  0x4 + 1x2 + 0x1  = 010 (base2)\\n\\t\\t\\t  _ _ _ _ _ _ _ _ _ 4 =  1x4 + 0x2 + 0x1  = 100 (base2)\\n              _ _ _ _ _ _ _ _ _ 2 =  0x4 + 1x2 + 0x1  = 110 (base2)\\n\\t\\t\\t  \\n_ _ _ _ _  XOR (3,2,4,2)\\t=  1x4 + 1x2 + 1x1 = 111 (base2) = 7\\n\\n*  The bottom line: choosing  a value of x that will reduce columns with even 1s by one will maximize the value of XOR(nums). The only columns that cannot be changed are those with no 1s initially. Thus we can solve the problem by determining OR(nums).\\n\\nThree short solutions:\\n \\n ```\\n class Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(lambda x,y: x|y, nums)\\n\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(or_, nums)\\n\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        \\n        ans = 0\\n        for n in nums:\\n            ans |= n      \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Points to consider:\\n\\n*  The problem calls for choosing an integer x, selecting an element n of the list, applying the compound operator op(n,x) = (x&n)^n,  and taking the bit-intersection of the modified set. Because of the associative and commutative properties of the XOR operator, it does not matter which n we choose in nums. \\n\\n*   Below is the truth table for op(num,x)\\n![image](https://assets.leetcode.com/users/images/3d54169a-85a0-466e-829c-08d2ff436128_1659383847.6181347.png)\\n    The end result is that the op leaves num\\'s bit unchanged unless x and num are both 1, in which case that bit of num becomes 0. It follows that by choosing x wisely, we can erase any bits in any of the elements of nums. \\n\\n*  For example:\\n              _ _ _ _ _ _ _ _ _ 3 =  0x4 + 1x2 + 1x1  = 011 (base2)\\n\\t\\t\\t  _ _ _ _ _ _ _ _ _ 2 =  0x4 + 1x2 + 0x1  = 010 (base2)\\n\\t\\t\\t  _ _ _ _ _ _ _ _ _ 4 =  1x4 + 0x2 + 0x1  = 100 (base2)\\n              _ _ _ _ _ _ _ _ _ 6 =  1x4 + 1x2 + 0x1  = 110 (base2)\\n\\t\\t\\t  \\n_ _ _ _ _ _ XOR (3,2,4,6)\\t=  0x4 + 1x2 + 1x1 = 011 (base2) = 3\\n\\nIn the base 2 representation of the XOR, the 4s digit is 0 because the bit-XOR of the 4s digits in nums,\\nXOR(0,0,1,1) = 0 because there\\'s an even number of 1s. And:\\n  2s digits:  XOR(1,1,0,1)  => 2s digit of XOR(nums) = 1 because #of 1s is odd\\n   1s digits:  XOR(1,0,0,0)  => 1s digit of XOR(nums) = 1 because #of 1s is odd\\n   \\n*    After applying Op(4,6) = 2 to nums[3]:\\n              _ _ _ _ _ _ _ _ _ 3 =  0x4 + 1x2 + 1x1  = 011 (base2)\\n\\t\\t\\t  _ _ _ _ _ _ _ _ _ 2 =  0x4 + 1x2 + 0x1  = 010 (base2)\\n\\t\\t\\t  _ _ _ _ _ _ _ _ _ 4 =  1x4 + 0x2 + 0x1  = 100 (base2)\\n              _ _ _ _ _ _ _ _ _ 2 =  0x4 + 1x2 + 0x1  = 110 (base2)\\n\\t\\t\\t  \\n_ _ _ _ _  XOR (3,2,4,2)\\t=  1x4 + 1x2 + 1x1 = 111 (base2) = 7\\n\\n*  The bottom line: choosing  a value of x that will reduce columns with even 1s by one will maximize the value of XOR(nums). The only columns that cannot be changed are those with no 1s initially. Thus we can solve the problem by determining OR(nums).\\n\\nThree short solutions:\\n \\n ```\\n class Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(lambda x,y: x|y, nums)\\n\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(or_, nums)\\n\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        \\n        ans = 0\\n        for n in nums:\\n            ans |= n      \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2198937,
                "title": "c-simple-solution-o-n-solution-easy-to-understand-with-comments-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans=0;\\n        // for every bit check the cnt of the times 1 appears in the array. If the cnt is great than 1, then we can consider that bit in our ans.\\n        // this is becuase the given op can unset any bit of the number in nums[i].\\n        //so if the cntOne is odd we dont have to change that bit in any of the nums[i] because the xor of odd number of one is 1.\\n        // but if the cntOne if even we must unset any one nums[i] bit in the array and consider that bit in our answer.\\n        // So it can be conculded that even if a single 1 occurs in that position in any nums[i], we can consider that bit in our ans.\\n        for(int i=31;i>=0;i--) {\\n            int cntOne = 0;\\n            for(int j=0;j<n;j++) {\\n                cntOne += ((nums[j]>>i)&1);\\n            }\\n            if(cntOne == 0)\\n                continue;\\n            ans += (1<<i);\\n        }\\n        return ans;\\n    }\\n};  \\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans=0;\\n        // for every bit check the cnt of the times 1 appears in the array. If the cnt is great than 1, then we can consider that bit in our ans.\\n        // this is becuase the given op can unset any bit of the number in nums[i].\\n        //so if the cntOne is odd we dont have to change that bit in any of the nums[i] because the xor of odd number of one is 1.\\n        // but if the cntOne if even we must unset any one nums[i] bit in the array and consider that bit in our answer.\\n        // So it can be conculded that even if a single 1 occurs in that position in any nums[i], we can consider that bit in our ans.\\n        for(int i=31;i>=0;i--) {\\n            int cntOne = 0;\\n            for(int j=0;j<n;j++) {\\n                cntOne += ((nums[j]>>i)&1);\\n            }\\n            if(cntOne == 0)\\n                continue;\\n            ans += (1<<i);\\n        }\\n        return ans;\\n    }\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196119,
                "title": "c-only-bit-count",
                "content": "**Approach:**\\n1. Count number of bits in each positions\\n2. Now if the position bit count is zero then we can\\'t take this bit otherwise we can take this bit in mask.\\n\\nNow return the number \\n\\n**Time:** `O(N), N = Length of nums`\\n**Space:** `O(32) ~ O(1)`\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> bits(32, 0);\\n        int mask = 0;\\n        for(auto &num : nums){\\n            for(int i = 0; i < 31; i++){\\n                if(num & (1 << i)) bits[i]++;\\n            }\\n        }\\n        for(int i = 0; i < 31; i++){\\n            if(bits[i] == 0) continue;            \\n            else{\\n                mask |= (1 << i);\\n            }\\n        }\\n        return mask;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> bits(32, 0);\\n        int mask = 0;\\n        for(auto &num : nums){\\n            for(int i = 0; i < 31; i++){\\n                if(num & (1 << i)) bits[i]++;\\n            }\\n        }\\n        for(int i = 0; i < 31; i++){\\n            if(bits[i] == 0) continue;            \\n            else{\\n                mask |= (1 << i);\\n            }\\n        }\\n        return mask;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656605,
                "title": "100-beats-or-all-elements-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;;\\n        for(auto &i: nums){\\n            ans |= i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;;\\n        for(auto &i: nums){\\n            ans |= i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351413,
                "title": "100-faster-3line-bitwise-or-all-elements-c-short-sweet-code",
                "content": "````\\nint maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto &i: nums)ans |= i;\\n        return ans;\\n    }\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "````\\nint maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto &i: nums)ans |= i;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2411587,
                "title": "explained-with-comments-beginner-friendly-c-o-n-time-o-1-space",
                "content": "**Explanation**\\nFor each bit position (0 to 31), we count the number of 1 bits for all elements in the nums array.\\nWe store this in bitCounts.\\n\\nNow, if we take the XOR of the entire array. In the XOR output, the bits at the positions for which the bit count is even will be 0 and for which the bit count is odd will be 1.\\n\\nIf we could somehow perform the operation to change the even bit counts into odd ones, we would get the maximum XOR output.\\n\\nWe can do that.\\nFor a number, we can perform the operation such that a 1 bit becomes 0.\\n**Note: we can select any non-negative integer x, i.e. x does not have to be from within the array.**\\n\\nSo we can make any 1 bit 0, but we can\\'t make a 0 bit 1.\\nWe cannot set a 0 bit to 1 using the operation as we are taking the bitwise AND with nums[i].\\n\\nWe can always select such an x that we can change any 1 bit to 0.\\n\\nHence, for every bit position in the bit count which has a non-zero value, we can have that bit to be 1 in the answer. For the positions for which the bit count is 0, those bits in the answer will be 0.\\n\\n\\n**Method 1.1: finding the bit counts for every bit position and then computing the answer**\\nCheck Method 1.2 for O(1) Space.\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> bitCounts(32, 0);\\n        \\n        for (int& num : nums) {\\n            for (int i = 0; i < 32; i++) {\\n                // Increment bitCounts[i] if the (i)th bit of nums is 1\\n                bitCounts[i] += (num >> i) & 1;\\n            }\\n        }\\n        \\n        // Compute the answer from the bit counts as given in the explanation.\\n        int ans = 0;\\n        for (int i = 0; i < 32; i++) {\\n            if (bitCounts[i] > 0) {\\n                ans += pow(2, i); // you could probably do some bit manipulation here instead of \\n                                  // using pow, but that\\'s when I got the inspiration for \\n                                  // Method 1.2\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Method 1.2: just take the bitwise OR of all numbers to get the answer**\\nIn the answer, we want all bits with non-zero bit counts to be 1 and the remaining bits to be 0. We can compute this answer by taking the bitwise OR of all the elements in the array.\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        for (int& num : nums) {\\n            ans |= num;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nThank you for reading.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> bitCounts(32, 0);\\n        \\n        for (int& num : nums) {\\n            for (int i = 0; i < 32; i++) {\\n                // Increment bitCounts[i] if the (i)th bit of nums is 1\\n                bitCounts[i] += (num >> i) & 1;\\n            }\\n        }\\n        \\n        // Compute the answer from the bit counts as given in the explanation.\\n        int ans = 0;\\n        for (int i = 0; i < 32; i++) {\\n            if (bitCounts[i] > 0) {\\n                ans += pow(2, i); // you could probably do some bit manipulation here instead of \\n                                  // using pow, but that\\'s when I got the inspiration for \\n                                  // Method 1.2\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        for (int& num : nums) {\\n            ans |= num;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348583,
                "title": "one-liner",
                "content": "# **C++**\\n```\\nint maximumXOR(vector<int>& nums) {\\n    return accumulate(begin(nums), end(nums), 0, bit_or<int>());     //O(n)\\n}\\n```\\n```\\nclass Solution {\\npublic:      \\n    int maximumXOR(vector<int>& nums) {\\n        int max_XOR=nums[0];\\n        for(int i=1;i<nums.size();i++){                         //O(n) \\n            max_XOR|=nums[i];\\n        }\\n        return max_XOR;\\n    }\\n};\\n```\\n# **UPVOTE   \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nint maximumXOR(vector<int>& nums) {\\n    return accumulate(begin(nums), end(nums), 0, bit_or<int>());     //O(n)\\n}\\n```\n```\\nclass Solution {\\npublic:      \\n    int maximumXOR(vector<int>& nums) {\\n        int max_XOR=nums[0];\\n        for(int i=1;i<nums.size();i++){                         //O(n) \\n            max_XOR|=nums[i];\\n        }\\n        return max_XOR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196170,
                "title": "o-n-easy-explanation-why",
                "content": "**Solution : Maximize XOR**\\nInitially, the question seems to be very brainstorming but when you closely look at the table below, you can actually find the solution like anybody:\\n\\n![image](https://assets.leetcode.com/users/images/896b6e8b-afcb-4308-870b-10690f15f4ff_1656173293.3394425.png)\\n\\n**The Real Trick:**\\nSo, we know that we need to maximize the XOR of all elements of the array.\\nIn order to do so, we must try to include as many as odd 1\\u2019s possible in the sequence at every place.\\nIncase there are even 1\\'s at any position they can be made odd. (by making that position 0 of any one number, see the table.) \\nBut incase there are no 1s at a position it can\\'t be generated. \\nTo check if any position contains 1 or not, OR is the answer.\\n\\n**Java Version:**\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.length; i++){\\n            ans=ans|nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**CPP Version :**\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto it:nums){\\n            ans|=it;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python Version:**\\n```\\ndef maximumXOR(self, nums):\\n        return reduce(ior, nums)\\n```\\n*Hope you liked it!*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.length; i++){\\n            ans=ans|nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto it:nums){\\n            ans|=it;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\ndef maximumXOR(self, nums):\\n        return reduce(ior, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196123,
                "title": "python-atk-agl-int",
                "content": "At the first glance, I really don\\'t know what number should we choose at any step for `nums[i] AND (nums[i] XOR x)`.\\nHowever, recalling the theorem of XOR, if we wanna get the largest outcome by XOR-ing the array of numbers, we need odd number of 1\\'s in each bit.\\n\\nThen, how about this `nums[i] AND (nums[i] XOR x)`? If you look at it closer, you realise that no matter how you XOR on the right side, you are gonna keep 1\\'s with the left side, which is your original number. Hence, this is kinda a 1-bit deletion operation for you. You can definitely delete any 1-bit for `nums[i]` since you can choose any number.\\n\\nTherefore, what you are gonna do is just to count the 1s at each bit and construct the final binary string before turning it into decimal.\\n\\nNote: you can only delete 1s at any bit for each number but you are not allowed to add 1s to the `nums[i]` since `nums[i] AND xxx` forced you to keep whatever 1s you have\\n\\nUpvote if you find it useful\\n\\nPS: my first article\\n\\nTC: O(32N) = O(N) where N is the number of `nums[i]`\\nSC: O(32) = O(1)\\n\\nedited: should not include frequency count into title, frequency count is just to see if there is at least one 1s at a certain bit.\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        nums = list(map(lambda x: format(x, \\'032b\\'), nums))\\n        freqs = [0]*32\\n        for num in nums:\\n            for i, bit in enumerate(num):\\n                if bit == \\'1\\':\\n                    freqs[i] += 1\\n        \\n        s = \\'\\'\\n        for cnt in freqs:\\n            if cnt > 0:\\n                s += \\'1\\'\\n            else:\\n                s += \\'0\\'\\n        return int(s, 2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        nums = list(map(lambda x: format(x, \\'032b\\'), nums))\\n        freqs = [0]*32\\n        for num in nums:\\n            for i, bit in enumerate(num):\\n                if bit == \\'1\\':\\n                    freqs[i] += 1\\n        \\n        s = \\'\\'\\n        for cnt in freqs:\\n            if cnt > 0:\\n                s += \\'1\\'\\n            else:\\n                s += \\'0\\'\\n        return int(s, 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195849,
                "title": "c-or-of-all-elements",
                "content": "**Observation:-**\\n1.For any nums[i] you can\\'t get more set bits then it already has because of the \"and\" operation in condition.\\n2.So wherever you see ```ith``` bit on set the ith bit of answer on because you can add this bit to final answer.\\n\\n    \\n```    \\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0,sz=nums.size();\\n        for(int i=0;i<sz;i++)\\n        ans|=nums[i];\\n        return ans;\\n        \\n    }\\n};\\n```\\nDo **Upvote** if it helps :)",
                "solutionTags": [],
                "code": "```ith```\n```    \\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0,sz=nums.size();\\n        for(int i=0;i<sz;i++)\\n        ans|=nums[i];\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195815,
                "title": "c-o-n-31-time-o-1-space",
                "content": "```\\nint maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<31;i++){\\n            int mask=(1<<i);\\n            bool f=0;\\n            for(auto& j:nums){\\n                if((mask&j)!=0){f=1;break;}        // break if a bit is 1 in any nums\\n            }\\n            if(f==1) ans|=mask;              \\n        }\\n        return ans;\\n  }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<31;i++){\\n            int mask=(1<<i);\\n            bool f=0;\\n            for(auto& j:nums){\\n                if((mask&j)!=0){f=1;break;}        // break if a bit is 1 in any nums\\n            }\\n            if(f==1) ans|=mask;              \\n        }\\n        return ans;\\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 2195811,
                "title": "c-3-lines-bitwise-or-of-all-elements",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = nums[0];\\n        for(int i = 1; i < nums.size(); ++i) ans |= nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = nums[0];\\n        for(int i = 1; i < nums.size(); ++i) ans |= nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838216,
                "title": "simple-solution-3-lines-runtime-100-beats-memory-100-beats-with-explanation",
                "content": "# Approach\\n\\nThe goal is to find the maximum possible bitwise XOR of all elements in the `nums` array after applying the given operation any number of times. To achieve this, we can use the properties of the bitwise XOR operation.\\n\\n**Logic:**\\n1. Initialize a variable `res` to 0. This variable will store the final result, which is the maximum possible bitwise XOR of all elements in the `nums` array.\\n2. Loop through each element `a` in the `nums` array.\\n3. For each element `a`, perform a bitwise OR operation with the current value of `res` and store the result back in `res`. This effectively combines all the elements in the `nums` array using bitwise OR.\\n4. After the loop, `res` will contain the result of combining all elements in the `nums` array using bitwise OR, which is equivalent to the maximum bitwise XOR possible for all elements in the `nums` array.\\n\\n**Explanation:**\\nThe given solution uses a simple logic to find the maximum possible bitwise XOR of all elements in the `nums` array without explicitly using XOR operators.\\n\\nFor each element in the `nums` array, it performs a bitwise OR operation with the current value of `res`. This operation combines the binary representation of the current element with the binary representation of the accumulated result so far (`res`). The OR operation sets the bits in the result to 1 if either of the corresponding bits in the operands is 1.\\n\\nBy doing this for all elements in the `nums` array, the `res` variable will eventually contain the maximum possible bitwise XOR of all elements.\\n\\nIt\\'s important to note that this solution does not perform the actual XOR operation between the elements in the array. Instead, it leverages the properties of bitwise OR to find the maximum possible XOR efficiently.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443098,
                "title": "maximum-xor-after-operations-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto it:nums)\\n        {\\n            ans |= it;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/84af7d8f-4c78-498b-9b6b-695287ca35be_1682612904.0626614.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto it:nums)\\n        {\\n            ans |= it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337964,
                "title": "python-one-line-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem relies on a few key observations made in sequence, which lend themselves to a very elegant solution.\\n\\nObservation 1: Since x is arbitrary, we can make (nums[i] XOR x) anything we like. For a given target number T = (nums[i] XOR x), we can construct x bit by bit. If the jth bit of T is 1, then the jth bit of x differs from the jth bit of nums[i]. If the jth bit of T is 0, then the jth bit of x is the same as the jth bit of nums[i].\\n\\nObservation 2: We can set nums[i] to anything using the bits ALREADY in nums[i]. We want to set nums[i] equal to nums[i] AND (nums[i] XOR x). We already know T = (nums[i] XOR x) is arbitrary. We can turn off any bits in nums[i] by making those bits in T zero, but we cannot produce any new bits, since they must be ANDed by zeros in nums[i].\\n\\nObservation 3: We can obtain any bit present in any of the nums[i] in our final XOR. All we need to do is leave one instance of each bit present in some nums[i], and turn off all other copies of that bit. Then when we XOR all of that bit together, we\\'ll get 1 XOR 0 XOR 0... which is just 1. Note we can\\'t produce any bit outside of the nums[i] since XORing zeros can only produce zero. \\n\\nObservation 4: Taking all the bits present in nums boils down to taking the bitwise OR of all the numbers. This operation will turn on a bit if at least one of the nums[i] has this bit set to 1.\\n\\n# Implementation\\n<!-- Describe your approach to solving the problem. -->\\nWe can write a simple for loop that maintains a solution variable starting at zero, and ORs every nums[i] with it. This will work, but we can express the same idea a little cleaner with functools.reduce()\\n\\nReduce takes in a function which maps 2 values down to 1 value, and applies it to our list. It will reduce the first 2 list values into 1 value, then reduce that and the next list value to 1 value, continuing to absorb the whole list. \\n\\nOur reducing funtion is simply the bitwise OR, as we want to OR the first 2 elements, then OR that with the next element, then OR that with the next element, and so on. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x | y, nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(lambda x, y: x | y, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180196,
                "title": "c-short-simple-solution-o-n-time-complexity",
                "content": "**Simple check the bit is set or not in nums[i]**\\n**OR is the best option to maximize the ans set bits will be set for ans**\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums)\\n    {\\n        int ans = 0;\\n        for(auto it : nums)\\n        {\\n            ans |=it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums)\\n    {\\n        int ans = 0;\\n        for(auto it : nums)\\n        {\\n            ans |=it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976171,
                "title": "bitmanipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    Bit Manipulation.\\n    Here we have A & (A ^ B), now if A = 9 (ie 1 0 0 1), now A & (A ^ B) can not be more than 9, because we are anding A ^ B with A, so here we know that iff the bit is 1 it can be 0, but we can not make 0 to 1.\\n    therefore we need to just bitwise OR each number (it there is 1 at that bit in any number than we can get that 1 in ans, however iff there is 0 at that bit in all numbers than it will be 0).\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    So just bitwise OR all the numbers. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int ans=0;\\n        for(int num: nums) ans |= num;\\n        return  ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int ans=0;\\n        for(int num: nums) ans |= num;\\n        return  ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763074,
                "title": "c-well-commented-brute-force-approach-bitmasks-clean-solution",
                "content": "```\\n/*  Intution -> \\n    If we write the binary representation of the nums, we can observe that \\n    if we manage to find atleast one setbit at that position across nums, \\n\\tthen we can simply take its contribution bcoz on changing a number \\n\\tby the given AND operation, we won\\'t end up with a setbit.\\n\\t( 0&0=1  1&1=1  0&1=1   1&0=1).\\n\\t\\n\\tSummary -> \\n\\tSo, at a particular position, if you find a setbit, just take its contribution\\n*/\\nint maximumXOR(vector<int>& nums) {\\n        // Border case -> [0] (as log function won\\'t work for it) \\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n\\t\\t\\n        // Taking out the max. bits to which we need to check\\n        int x = *max_element(nums.begin(),nums.end());\\n        int bits = log(x)/log(2) + 1;\\n        int j = 0, ans = 0;\\n        \\n        while(bits--) {\\n            int c = 0;\\n            for(auto i:nums) {\\n\\t\\t\\t//If that particular bit is found to be set, then take its contribution\\n                if(i&(1<<j)) {\\n                    c = 1; \\n                    ans += (pow(2,j));\\n                    break;\\n                }\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n/*  Intution -> \\n    If we write the binary representation of the nums, we can observe that \\n    if we manage to find atleast one setbit at that position across nums, \\n\\tthen we can simply take its contribution bcoz on changing a number \\n\\tby the given AND operation, we won\\'t end up with a setbit.\\n\\t( 0&0=1  1&1=1  0&1=1   1&0=1).\\n\\t\\n\\tSummary -> \\n\\tSo, at a particular position, if you find a setbit, just take its contribution\\n*/\\nint maximumXOR(vector<int>& nums) {\\n        // Border case -> [0] (as log function won\\'t work for it) \\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n\\t\\t\\n        // Taking out the max. bits to which we need to check\\n        int x = *max_element(nums.begin(),nums.end());\\n        int bits = log(x)/log(2) + 1;\\n        int j = 0, ans = 0;\\n        \\n        while(bits--) {\\n            int c = 0;\\n            for(auto i:nums) {\\n\\t\\t\\t//If that particular bit is found to be set, then take its contribution\\n                if(i&(1<<j)) {\\n                    c = 1; \\n                    ans += (pow(2,j));\\n                    break;\\n                }\\n            }\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2731827,
                "title": "two-approaches-easy-short-best-code-in-c",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n\\n***1st Approach:-***\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int xoR=0;\\n        for(auto it:nums)\\n            xoR |= it;\\n        return xoR;\\n    }\\n};\\n```\\n***2nd Approach:-***\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int size=nums.size(),xoR=0;\\n        for(auto it:nums)\\n            xoR^=it;\\n        for(int i=0;i<32;i++){\\n            if((xoR & 1<<i))\\n                continue;\\n            for(int j=0;j<size;j++){\\n                if((nums[j] & 1<<i)){\\n                    xoR^=1<<i;\\n                    break;\\n                }\\n            }\\n        }\\n        return xoR;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int xoR=0;\\n        for(auto it:nums)\\n            xoR |= it;\\n        return xoR;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int size=nums.size(),xoR=0;\\n        for(auto it:nums)\\n            xoR^=it;\\n        for(int i=0;i<32;i++){\\n            if((xoR & 1<<i))\\n                continue;\\n            for(int j=0;j<size;j++){\\n                if((nums[j] & 1<<i)){\\n                    xoR^=1<<i;\\n                    break;\\n                }\\n            }\\n        }\\n        return xoR;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548509,
                "title": "70-beats-easy-simple-c-time-o-1-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> v(32,0);\\n        int j = 0;\\n        for(auto &i: nums){\\n            j = 0;\\n            while(i){\\n                v[j] += i&1;\\n                i = i >> 1;\\n                j++;\\n            }\\n        }\\n        int ans = 0;\\n        for(j = 0; j < 32; j++){\\n            if(v[j]) ans += (1<<j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> v(32,0);\\n        int j = 0;\\n        for(auto &i: nums){\\n            j = 0;\\n            while(i){\\n                v[j] += i&1;\\n                i = i >> 1;\\n                j++;\\n            }\\n        }\\n        int ans = 0;\\n        for(j = 0; j < 32; j++){\\n            if(v[j]) ans += (1<<j);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201399,
                "title": "2-solutions-or-and-bit-shifting-python",
                "content": "# Intuition\\nWe have to use AND (&) after some XOR (^) operation.\\n\\nApplying `&` will not be able to toggle bits set to 0 into 1.\\n\\nApplying XOR `^` we are able to flip the bits.\\n\\nThe idea is to flip all the bits we can to 1,  by doing this we will be able to maximize the result. \\n\\nFor example if we are able to flip all the bits to 1\\n1111 ^ 0000 => 1111.\\n\\n\\n# First solution\\nApply cumulative `OR (|)` to turn all the possible bits on.\\n\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        res = 0\\n        for v in nums: res |= v\\n        return res\\n```\\n\\n# Second solution\\nSave an array that represents the bits.\\n\\nIterate over nums and put bits[i] to 1 if it is active in current num.\\n\\nDo this for all numbers, and then return the number that is represented by the bits.\\n\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n\\t\\t# 32 bit integer\\n        bits = [0] * 32\\n        \\n        # Try to maximize all bits to 1\\n        for n in nums:\\n            for i in range(31, -1, -1):\\n                bits[i] = max(bits[i], n>>i&1)\\n            \\n        res = 0\\n        for i, v in enumerate(bits):\\n            # Accumulate result by shifting left to retrieve the open bit value\\n            res += v<<i\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        res = 0\\n        for v in nums: res |= v\\n        return res\\n```\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n\\t\\t# 32 bit integer\\n        bits = [0] * 32\\n        \\n        # Try to maximize all bits to 1\\n        for n in nums:\\n            for i in range(31, -1, -1):\\n                bits[i] = max(bits[i], n>>i&1)\\n            \\n        res = 0\\n        for i, v in enumerate(bits):\\n            # Accumulate result by shifting left to retrieve the open bit value\\n            res += v<<i\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199992,
                "title": "c-o-32-n-code-with-detailed-explanation",
                "content": "Observe that **a&(a^x) = (a&a)^(a&x) = a^(a&x)**\\nObserve that **(a&x)** will be set only on those bits which is already 1.\\nie. if a has a binary representation of \\n\\na = 100011\\nthen a&x can be 100001, 100010, 100011, 000011, 000010, 000001, 000000.\\n\\nNow the XOR of this A&X will make those bits off which is present in (a&x), \\nthus we can set X accordingly and set any bit of A as off.\\n\\nNow for maximum XOR of array, we need to look bitwise at each position and check if there is atleast one number which has this bit on, if yes, then we can make this bit on in the answer(by switching off all bits in rest of array at this position) else we can\\'t.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        for(int i=0;i<32;i++){\\n            for(int j=0;j<n;j++){\\n                int x = (nums[j]>>i);\\n                if(x%2) {num += (1<<i); break;}\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n        for(int i=0;i<32;i++){\\n            for(int j=0;j<n;j++){\\n                int x = (nums[j]>>i);\\n                if(x%2) {num += (1<<i); break;}\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197066,
                "title": "java-simple-explanation-o-31-n",
                "content": "if we consider ```ith``` bit of numbers then we can notice that \\n* if the number of set bits are odd then ```XOR``` of that position will be ```1```.\\n* if the number of set bits are even then ```XOR``` of that position will be ```0```.\\n\\nwe know that taking ```and``` of a number with any other number can never increase the given number.\\ni.e. ```result``` of  ```x & y``` will always be ```<= x```  no matter what the value of ```y``` is.\\n\\n* if we want to maximize our ```result``` then we want to have maximum number of set bits possible in our answer.\\n* now, if the number of set bits at a position is ```odd``` which is what we want then we set the corresponding bit to ```1``` in the answer.\\n* if the corresponding number of set bits is ```even``` then we want to flip one bit of any number to make the count of set bits ```odd``` at that position.\\n\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n\\t    int answer = 0;\\n        for (int i = 0; i < 31; i++) {\\n            int bits = 0;\\n            int mask = (1 << i);\\n            for (int n : nums) {\\n                if ((mask & n) > 0) {\\n                    bits++;\\n                }\\n            }\\n            if (bits > 0) {\\n\\t\\t\\t    //  we could flip any ith bit in any nuber and make the xor 1\\n\\t\\t\\t\\t//  but we can not set an odd bit \\n                answer |= (1 << i);\\n            }\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "```ith```\n```XOR```\n```1```\n```XOR```\n```0```\n```and```\n```result```\n```x & y```\n```<= x```\n```y```\n```result```\n```odd```\n```1```\n```even```\n```odd```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196574,
                "title": "c-clean-and-concise-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        long long k=0;\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            k= (1<<i);\\n            for(auto &it : nums)\\n            {\\n                if(it&k)\\n                {\\n                    ans+=(1<<i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        long long k=0;\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n        {\\n            k= (1<<i);\\n            for(auto &it : nums)\\n            {\\n                if(it&k)\\n                {\\n                    ans+=(1<<i);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196573,
                "title": "python-o-n-explanation-for-people-struggling-with-bitwise",
                "content": "**Things to notice**\\n\\n**AND Operator**\\n\\nBasically *i AND j* is used to find the bits set in both *i* and *j*.\\nFor example.\\n\\nBitwise AND of 1001010, 1001100 is\\n1001010\\n1001100\\n*=*\\n1001000\\n\\nSo we can realise that \\n* no new bit can be set by the AND operator.\\n* AND of any number with 0 is 0.\\n* To unset ith bit of a number, use AND operator of number with all bits set except ith.\\n\\n**XOR operator**\\n*i XOR j* sets the uncommon bits between *i* and *j*, while unsetting the common ones.\\nFor example.\\n\\nBitwise XOR of 1001010, 1001100 is\\n1001010\\n1001100\\n*=*\\n0110111\\n\\nSo we can realise that\\n* We can realistically create any number with XOR operator of *i* and j, if we specifically pick j.\\n* Explanation of above point, to create 7 *(1001)* from 3 *(11)*, we can XOR it with  10 *(1010)*.\\n* XOR of any number with itself, is 0.\\n\\n**Intuition**\\n\\nIf we look at `nums[i] AND (nums[i] XOR x)` and combine it with points mentioned above.\\n* If we can select any non-negative integer x. `(nums[i] XOR x)` basically can become any number we want.\\n* We will denote this new number as **y**.\\n* `nums[i] AND y` can never exceed minimum(nums[i],y), and no new bit can be set which aren\\'t already set in nums[i].\\n* So no matter what operations we perform. If kth bit is unset in all nums[i] in nums, it can never be set.\\n* To find maximum XOR, it will be best to keep kth bit set only in odd amount of numbers, as even numbers will unset the kth bit.\\n* We can perform specific operations, such that kth bit is set in at most 1 nums[i], for all k, after all the operations.\\n* Maximum answer will only be the one with most bits set.\\n\\n**Solution**\\n\\nWe need to find all the k, for which the kth bit is set in any of the numbers. We can then assume that these bits are set in only at most 1 nums[i] each, at the end of all operations. We do not necesarrily need to find the exact nums at the end as we learnt above that it is possible to unset any bit in any nums[i] due to `nums[i] AND (nums[i] XOR x)`.\\n\\nAs maximum integer is 10^8. There are 27 bits at most.\\n\\nIterate over each nums[i], and check if kth bit is set for k in range(1,27).\\nKeep another array to maintain if kth bit is set in at least 1 of nums[i] or not.\\n\\nThe final answer will simply be to convert the new formed array into int.\\n\\nExample.\\n\\nnums = [3,2,4,6]\\n3 = 0011\\n2 = 0010\\n4 = 0100\\n6 = 0110\\n\\nsetbits = [1110] (leftmost bit means 1st bit and so on.)\\nSo final answer = 1x1 + 2x1 + 4x1 + 8x0. = 7.\\nOne possible nums array (after operations) for the same can be [1,0,0,6]\\n1 = 3 & ( 3 ^ 2 )\\n0 = 2 & ( 2 ^ 2 )\\n0 = 4 & ( 4 ^ 4 )\\n6 = 6 & ( 6 ^ 1 )\\n\\nNow XOR of 1^0^0^6 = 7.\\n\\nMy python accepted code.\\n\\n```\\ndef maximumXOR(self, nums: List[int]) -> int:\\n    nset=set() # To maintain the bits that are still unset.\\n    yes=[0]*28 # To check if kth bit is set or not.\\n    for i in range(28):\\n        nset.add(i) #initially all of the 28 bits are unset.\\n\\n    for i in nums:\\n        x=[] #Maintain all bits that were previously unset but were set in this number.\\n        for k in nset:\\n            if i & (1 << (k)):\\n                yes[k]=1 #set the kth\\n                x.append(k)\\n        #Now remove all the newly set bits from nset(not set yet).\\n        for k in x:\\n            nset.remove(k)\\n    #Now just convert the yes array into a number.\\n    x=0\\n    c=1\\n    for i in yes:\\n        if i:\\n            x+=c\\n        c=c<<1 \\n    return x\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maximumXOR(self, nums: List[int]) -> int:\\n    nset=set() # To maintain the bits that are still unset.\\n    yes=[0]*28 # To check if kth bit is set or not.\\n    for i in range(28):\\n        nset.add(i) #initially all of the 28 bits are unset.\\n\\n    for i in nums:\\n        x=[] #Maintain all bits that were previously unset but were set in this number.\\n        for k in nset:\\n            if i & (1 << (k)):\\n                yes[k]=1 #set the kth\\n                x.append(k)\\n        #Now remove all the newly set bits from nset(not set yet).\\n        for k in x:\\n            nset.remove(k)\\n    #Now just convert the yes array into a number.\\n    x=0\\n    c=1\\n    for i in yes:\\n        if i:\\n            x+=c\\n        c=c<<1 \\n    return x\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2196206,
                "title": "javascript-greedy-two-solutions-or-of-all-86ms-check-ith-bit-204ms",
                "content": "key point: make each i\\'th bit only has one 1\\'s\\n```\\nconst maximumXOR = (a) => {\\n    let res = 0;\\n    for (const x of a) res |= x;\\n    return res;\\n};\\n```\\nSolution 2: check each bit if it has one, has, add the mask value to res\\n204ms\\n```\\nconst bit = 27; // cover 10 ^ 8\\nconst checkIthBit = (x, i) => x & (1 << i);\\n\\nconst maximumXOR = (a) => {\\n    let res = 0;\\n    for (let i = 0; i < bit; i++) {\\n        let hasOne = 0;\\n        for (const x of a) {\\n            if (checkIthBit(x, i)) hasOne++;\\n        }\\n        if (hasOne) res += 1 << i; // add mask 1 << i\\n    }\\n    return res;\\n};\\n```\\nSolution 3: same as Solution 2, but using binary string instead\\n543ms\\n```\\nconst fillLeading = (len, s) => \\'0\\'.repeat(len - s.length) + s;\\n\\nconst maximumXOR = (a) => {\\n    let len = 0, res = 0;\\n    a = a.map(x => {\\n        let s = x.toString(2);\\n        len = Math.max(len, s.length);\\n        return s;\\n    }).map(s => fillLeading(len, s));\\n    for (let i = len - 1, bit = 0; ~i; i--, bit++) { // traverse binary string low(right) -> high(left)\\n        let hasOne = false;\\n        for (const s of a) {\\n            if (s[i] == \\'1\\') hasOne = true;\\n        }\\n        if (hasOne) res += 1 << bit;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst maximumXOR = (a) => {\\n    let res = 0;\\n    for (const x of a) res |= x;\\n    return res;\\n};\\n```\n```\\nconst bit = 27; // cover 10 ^ 8\\nconst checkIthBit = (x, i) => x & (1 << i);\\n\\nconst maximumXOR = (a) => {\\n    let res = 0;\\n    for (let i = 0; i < bit; i++) {\\n        let hasOne = 0;\\n        for (const x of a) {\\n            if (checkIthBit(x, i)) hasOne++;\\n        }\\n        if (hasOne) res += 1 << i; // add mask 1 << i\\n    }\\n    return res;\\n};\\n```\n```\\nconst fillLeading = (len, s) => \\'0\\'.repeat(len - s.length) + s;\\n\\nconst maximumXOR = (a) => {\\n    let len = 0, res = 0;\\n    a = a.map(x => {\\n        let s = x.toString(2);\\n        len = Math.max(len, s.length);\\n        return s;\\n    }).map(s => fillLeading(len, s));\\n    for (let i = len - 1, bit = 0; ~i; i--, bit++) { // traverse binary string low(right) -> high(left)\\n        let hasOne = false;\\n        for (const s of a) {\\n            if (s[i] == \\'1\\') hasOne = true;\\n        }\\n        if (hasOne) res += 1 << bit;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195892,
                "title": "c-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& v) {\\n        vector<bool> cnt(31);\\n        for(int x:v){\\n            int i=0;\\n            for(int i=0;x;i++){\\n                if(x&1)cnt[i]=true;\\n                x>>=1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<31;i++){\\n            if(cnt[i])\\n                ans+=(1<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& v) {\\n        vector<bool> cnt(31);\\n        for(int x:v){\\n            int i=0;\\n            for(int i=0;x;i++){\\n                if(x&1)cnt[i]=true;\\n                x>>=1;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<31;i++){\\n            if(cnt[i])\\n                ans+=(1<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195890,
                "title": "python3-solution-o-n",
                "content": "```Time``` : ```O(n)```\\n```Space``` : ```O(1)```\\n\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        res = 0\\n        for i in nums:\\n            res |= i\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Time```\n```O(n)```\n```Space```\n```O(1)```\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        res = 0\\n        for i in nums:\\n            res |= i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195826,
                "title": "o-1-solution-with-simple-approach-c-explained",
                "content": "1. We can make change 1 to 0 but can\\'t change 0 to 1 in num[i]\\n      2. ( n&(n^x) ) => ith bit of n is 0 zero then it will be zero always ans & operation is final operation\\n=> **so count for every bit if at least 1 set bit is there then take it into answer;**\\n```\\nint maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=0; i<32; i++){\\n            int tmp = (1<<i);\\n            int flag=0;\\n            for(auto x : nums){\\n                if((x&tmp)){\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag)ans += tmp;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=0; i<32; i++){\\n            int tmp = (1<<i);\\n            int flag=0;\\n            for(auto x : nums){\\n                if((x&tmp)){\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag)ans += tmp;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195814,
                "title": "c-easy-solution-12-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int x_or = 0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            for(auto x:nums)\\n            {\\n                if(((x>>i)&1)==1)// If 1 bit is present then all the other ith bits can be disabled using the above given operation and this bit can be taken in our answer to make our answer maximum.\\n                {\\n                    x_or|= (1<<i);\\n                    break;\\n                }\\n            }\\n        }\\n        return x_or;\\n    }\\n    // UPVOTE if you like\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int x_or = 0;\\n        for(int i=31;i>=0;i--)\\n        {\\n            for(auto x:nums)\\n            {\\n                if(((x>>i)&1)==1)// If 1 bit is present then all the other ith bits can be disabled using the above given operation and this bit can be taken in our answer to make our answer maximum.\\n                {\\n                    x_or|= (1<<i);\\n                    break;\\n                }\\n            }\\n        }\\n        return x_or;\\n    }\\n    // UPVOTE if you like\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089343,
                "title": "python-or-all-elements",
                "content": "```python\\n\"\"\"\\nFirst of all it\\'s easy taks, if we look create table of binary \\nrepresentation of nums, it will be clear that anser is OR sum.\\n\\nFor example [1,2,3,9,2]\\n\\n1 - 0001\\n2 - 0010\\n3 - 0011\\n9 - 1001\\n2 - 0010\\n\\nUsing `nums[i] AND (nums[i] XOR x)` we actually can zero any i th bit.\\n\\nSo it\\'s clear that if i th bit is 0 everywhere, we cannot convert it\\nto 1, if any i th bit is 1 anywhere, we can conver rest of it to zero.\\n\\nSo our result will be sum of OR.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        r = 0\\n        for n in nums:\\n            r |= n\\n        return r\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\"\"\"\\nFirst of all it\\'s easy taks, if we look create table of binary \\nrepresentation of nums, it will be clear that anser is OR sum.\\n\\nFor example [1,2,3,9,2]\\n\\n1 - 0001\\n2 - 0010\\n3 - 0011\\n9 - 1001\\n2 - 0010\\n\\nUsing `nums[i] AND (nums[i] XOR x)` we actually can zero any i th bit.\\n\\nSo it\\'s clear that if i th bit is 0 everywhere, we cannot convert it\\nto 1, if any i th bit is 1 anywhere, we can conver rest of it to zero.\\n\\nSo our result will be sum of OR.\\n\\nTC: O(N)\\nSC: O(1)\\n\"\"\"\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        r = 0\\n        for n in nums:\\n            r |= n\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684096,
                "title": "easy-solution-c-3-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n      int n=0;\\n      for(int i=0;i<nums.size();i++)\\n      {\\n          n=n|nums[i];\\n      }\\n      return n;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n      int n=0;\\n      for(int i=0;i<nums.size();i++)\\n      {\\n          n=n|nums[i];\\n      }\\n      return n;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351572,
                "title": "since-we-can-t-make-one-by-ourselves-doing-or-between-them-will-give-the-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        for(auto i : nums)\\n            res|=i;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        for(auto i : nums)\\n            res|=i;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347331,
                "title": "c-simple-implementation-using-bitwise-or",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto x:nums){\\n            ans= ans | x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto x:nums){\\n            ans= ans | x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029925,
                "title": "java-100-o-n",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nXOR means check all the bits and make or operations so if we apply this for all the array member we can reach the maximum value\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ \\n# Code\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579516,
                "title": "c-explained-o-n-3-lines-code-bit-manipulation",
                "content": "__Algorithm__\\n\\n\\n- Here we need to find the maximum xor of an array and we can replace a number a by  a & ( a ^ x) where x is a non negative number \\n-  What does a & ( a ^ x) mean ? Suppose you have 2 numbers in array 1 and 3\\n```                  \\n                           1 -> 0 0 0 1\\n\\t\\t\\t\\t\\t\\t   3 -> 0 0 1 1\\n```\\n- Now the xor operation is a odd ones detector and xor of 1 and 3 is 2 as at 0 th bit there are 2 1\\'s so looking at a & ( a ^ x) carefully we understand it can be used to make a bit which is 1 in binary representation 0 __but not 0 to 1__\\n- Now we see that the max number will have 1 is 0th bit if any number in array will have 1 in its 0 th bit as if there are other numbers with 1 in 0th bit at there sum is even we can make it odd by using the a & ( a ^ x)  operation\\n- So answer will be just or of all numbers it ith bit is 1 if any number in array has a ith bit 1\\n\\n__Code__\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans =0 ;\\n        for(auto a : nums) ans |= a;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```                  \\n                           1 -> 0 0 0 1\\n\\t\\t\\t\\t\\t\\t   3 -> 0 0 1 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans =0 ;\\n        for(auto a : nums) ans |= a;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508813,
                "title": "python3-very-easy",
                "content": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        s=[nums[0]]\\n        for i in range(len(nums)):\\n            s.append(s[-1]|nums[i])\\n        return max(s)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        s=[nums[0]]\\n        for i in range(len(nums)):\\n            s.append(s[-1]|nums[i])\\n        return max(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492318,
                "title": "python-one-liner-with-explanation",
                "content": "The operation\\nnums[i] = nums[i] & (nums[i] ^ x)\\neffectively turns off any bit 1 in nums[i].\\nIt cannot turn on 1, so we can only remove any 1 bits that are already in the array.\\nThis way we can always create a combination of odd 1 in any position as long as there is 1 at that position at any number.\\nThus, just bundle all numbers with 1 in their position with | (or) and done.\\n\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(operator.or_, nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(operator.or_, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356019,
                "title": "c-code-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) \\n    {\\n        \\n        int ans = 0;\\n            \\n        for(auto it: nums)\\n        {\\n            ans = ans | it;    \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) \\n    {\\n        \\n        int ans = 0;\\n            \\n        for(auto it: nums)\\n        {\\n            ans = ans | it;    \\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272244,
                "title": "bitwise-or",
                "content": "```\\nint maximumXOR(vector<int>& n)\\n{\\n\\treturn accumulate(begin(n), end(n), 0, bit_or{});\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumXOR(vector<int>& n)\\n{\\n\\treturn accumulate(begin(n), end(n), 0, bit_or{});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2268174,
                "title": "java-easy-explanation",
                "content": "num[i] = nums[i]&(nums[i]^x)\\nnums[i] = nums[i]&nums[i]^(nums[i] & x )\\nnums[i] = nums[i]^(nums[i]&x)\\n\\nHere nums[i]&x = only common bit between x and nums[i] will be there other will be gone.\\nFor example => 1001&(0101) = 0001\\n\\n* We conclude that any set bit can be can 0, using this operation\\n* We will calculate bit count at every position upto 32 bits, and if it is 0, then we can\\'t do anything, but if it is odd we will leave it\\n* but it is Even, this operation to remove 1 set bit to make it Odd, so that this set bit at this position can contribute of our Ans.\\n\\n0011\\n0010\\n0011\\n0010\\n1001\\n-----\\n1 2 3 4 \\nHere at 2nd postion set bit count is zero, so we can\\'t do anything, \\nbut at 3rd position set bit count in even, so we can make it Odd using operation, \\n***That is the use of this operation to remove a set bit. \\n```*\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n         // N\\n        // 3 = 11\\n        // 4 = 100\\n        // 6 = 110\\n        int n = nums.length;\\n        int[][] arr = new int[n][32];\\n        \\n        for(int i = 0; i < n; i++){\\n            int ele = nums[i];\\n            for(int j = 0; j < 32; j++){\\n                if(((ele >> j)&1) == 1){\\n                    arr[i][j] = 1;\\n                }else{\\n                    arr[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        long ans = 0;\\n        for(int i = 0; i < 32; i++){\\n            int cnt = 0;\\n            for(int j = 0; j < n; j++){\\n                if(arr[j][i] == 1) cnt++;\\n            }\\n            if(cnt == 0) continue;\\n            \\n            ans += (1 << i);\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```*\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n         // N\\n        // 3 = 11\\n        // 4 = 100\\n        // 6 = 110\\n        int n = nums.length;\\n        int[][] arr = new int[n][32];\\n        \\n        for(int i = 0; i < n; i++){\\n            int ele = nums[i];\\n            for(int j = 0; j < 32; j++){\\n                if(((ele >> j)&1) == 1){\\n                    arr[i][j] = 1;\\n                }else{\\n                    arr[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        long ans = 0;\\n        for(int i = 0; i < 32; i++){\\n            int cnt = 0;\\n            for(int j = 0; j < n; j++){\\n                if(arr[j][i] == 1) cnt++;\\n            }\\n            if(cnt == 0) continue;\\n            \\n            ans += (1 << i);\\n        }\\n        \\n        return (int)ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210066,
                "title": "java-o-n-easy-simple-and-straight-forward-solution",
                "content": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int max = 0;\\n        for(int num: nums)\\n            max = max | num;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int max = 0;\\n        for(int num: nums)\\n            max = max | num;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208288,
                "title": "c-detailed-explanation-easy-approach",
                "content": "\\uD83D\\uDCCD**Kindly Upvote, It is FREE from your side**\\n\\n\\uD83D\\uDD25Approach:-\\n* Whenever we are doing nums[i] = nums[i] & (nums[i] ^ x). Please note that the And operation will produce the result 0 if any bit of the number is zero.\\n* It can produce 1/0 depending on the result of nums[i]^x. Because XOR operator can produce 1/0 depending on the x.\\n* Whenever we XOR all the numbers at the end. If at any bit we have a minimum of one 1 from all the numbers It means that bit can be converted to 1.\\n* Refer to YouTube for more detailed explanation.\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        int isSet = 0;\\n        \\n        for(int i = 31; i>=0; i--){\\n            isSet = 0;\\n            for(auto &x: nums){\\n                if(x&(1<<i)){\\n                    isSet = 1;\\n                    break;\\n                }\\n            }\\n            if(isSet){\\n                ans = ans | (1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        int isSet = 0;\\n        \\n        for(int i = 31; i>=0; i--){\\n            isSet = 0;\\n            for(auto &x: nums){\\n                if(x&(1<<i)){\\n                    isSet = 1;\\n                    break;\\n                }\\n            }\\n            if(isSet){\\n                ans = ans | (1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205698,
                "title": "didn-t-expect-it-as-medium-2-liner-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums){\\n     int xorr = 0;\\n        for(auto it : nums) xorr |= it;\\n        return xorr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums){\\n     int xorr = 0;\\n        for(auto it : nums) xorr |= it;\\n        return xorr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201089,
                "title": "c-easy-simple-approach-beginners-friendly",
                "content": "```\\nint maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n            ans=ans|nums[i];\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n            ans=ans|nums[i];\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2200608,
                "title": "i-can-t-believe-it-work",
                "content": "## My idea \\n\\nI thought it would take little bit extra time to solve the third problem of the weekly contest.\\n\\nBut I was wrong.\\n\\nI missed the opportunity of passing another problem in the contest yesterday during contest.\\n\\nI read the problem more carefully today.\\n\\nThe problem states that the operation is number AND (number XOR x) ,\\nwhich means you can not add extra one bit to a number but only decrease the \\nnumber of one bit for one number.\\n\\n\\nSo I know that what we need to do is to keep as much as one bit in the final number .\\n\\nSo I guess we could just using OR operation to all numbers in the array,\\nand this is the biggest number we can get.\\n\\nAnd it pass. AC  !! \\n\\nI can\\'t believe it .\\n\\nAnd you and I should check out the @lee215 for formal prove of this algorithm .\\n\\n\\n## My code \\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        for(int num: nums) {\\n            res = res | num;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res = 0;\\n        for(int num: nums) {\\n            res = res | num;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199901,
                "title": "go-golang-explanation-o-n",
                "content": "```\\nfunc maximumXOR(nums []int) (ans int) { \\n    /*\\n    So suppose after doing xor [3,2,4,6] we\\'re getting 3\\n\\n            3 => 0 0 1 1\\n            2 => 0 0 1 0\\n            4 => 0 1 0 0\\n            6 => 0 1 1 0\\n          xor => 0 0 1 1\\n          \\n          The xor result can be maximised if either 4 became 0 or 6 became 2 using the operations described. Now the key to notice here is that we actually don\\'t need to perform the operations since we are only interested in the maximisation and not the order of operations and that leads us to realise that we can effectively chose to Bitwise OR the elements (instead of the proposed XOR) and our work is done.\\n    */\\n    for _,num:=range nums{\\n        ans |=num\\n    }\\n    return\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumXOR(nums []int) (ans int) { \\n    /*\\n    So suppose after doing xor [3,2,4,6] we\\'re getting 3\\n\\n            3 => 0 0 1 1\\n            2 => 0 0 1 0\\n            4 => 0 1 0 0\\n            6 => 0 1 1 0\\n          xor => 0 0 1 1\\n          \\n          The xor result can be maximised if either 4 became 0 or 6 became 2 using the operations described. Now the key to notice here is that we actually don\\'t need to perform the operations since we are only interested in the maximisation and not the order of operations and that leads us to realise that we can effectively chose to Bitwise OR the elements (instead of the proposed XOR) and our work is done.\\n    */\\n    for _,num:=range nums{\\n        ans |=num\\n    }\\n    return\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2198804,
                "title": "maximum-xor-after-operations",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<bool>v(32,0);\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<32;j++)\\n                if(nums[i]&(1<<j))v[j]=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n            if(v[i])ans+=pow(2,i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<bool>v(32,0);\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=0;j<32;j++)\\n                if(nums[i]&(1<<j))v[j]=1;\\n        }\\n        int ans=0;\\n        for(int i=0;i<32;i++)\\n            if(v[i])ans+=pow(2,i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197334,
                "title": "trie-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    class Node{\\n        public:\\n        int x;\\n        Node* left,*right;\\n        Node(){\\n            left=NULL;\\n            right=NULL;\\n        }\\n        Node(int y){\\n            x=y;\\n            left=NULL;\\n            right=NULL;\\n        }\\n    };\\n    class Trie{\\n        public:\\n        Node* root;\\n        Trie(){\\n          root=new Node() ; \\n        }\\n        void insert(int x){\\n            Node* temp=root;\\n            for(int i=30;i>=0;i--){\\n                if((x>>i)&1){\\n                   if(temp->right)temp=temp->right;\\n                   else{\\n                       temp->right=new Node();\\n                       temp=temp->right;\\n                   }\\n                }\\n                else{\\n                    if(temp->left)temp=temp->left;\\n                    else{\\n                        temp->left=new Node();\\n                        temp=temp->left;\\n                    }\\n                }\\n            }\\n        }\\n     int search(int x){\\n            Node* temp=root;\\n            int ans=0;\\n            for(int i=30;i>=0;i--){\\n                if((x>>i)&1){\\n                    if(temp->left){\\n                        ans|=(1<<i);\\n                        temp=temp->left;\\n                    }\\n                    else temp=temp->right;\\n                }\\n                else{\\n                    if(temp->right){\\n                        ans|=(1<<i);\\n                        temp=temp->right;\\n                    }\\n                    else temp=temp->left;\\n                }\\n            }\\n         return ans;\\n        }\\n    };\\n    int maximumXOR(vector<int>& nums) {\\n       \\n        if(nums.size()==1)return nums[0];\\n         Trie obj;\\n        int ans=0;\\n        int pre=0;\\n        for(int i=0;i<nums.size();i++){\\n            int x=pre^nums[i];\\n            obj.insert(x);\\n            ans=max(ans,obj.search(x));\\n            pre^=nums[i];\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            obj.insert(nums[i]);\\n            ans=max(ans,obj.search(nums[i]));\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Trie"
                ],
                "code": "class Solution {\\npublic:\\n    class Node{\\n        public:\\n        int x;\\n        Node* left,*right;\\n        Node(){\\n            left=NULL;\\n            right=NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2197143,
                "title": "2-approaches-python-easy-understanding",
                "content": "\\tclass Solution(object):\\n\\t\\tdef maximumXOR(self, nums):\\n\\t\\t\\t#approach1\\n\\t#         lis=[0 for _ in range(32)]\\n\\t#         for i in range(32):\\n\\t#             for j in nums:\\n\\t#                 if 1<<i & j:\\n\\t#                     lis[i]=1\\n\\t#                     break\\n\\t#         s=0\\n\\t#         val=1\\n\\n\\t#         for i in range(32):\\n\\t#             if lis[i]:\\n\\t#                 s+=val\\n\\t#             val*=2\\n\\t#         return s\\n\\n\\t#approach2\\n\\t#as we know we have to find the xor of all the elements\\n\\t#so we can observe there that we are calculating the sum only(of the odd bits)\\n\\t#lets take example\\n\\t#[3,2,4,6]\\n\\t#3-0011\\n\\t#2-0010\\n\\t#4-0100\\n\\t#6-0110\\n\\t#so we have to find only odd bit sum\\n\\t#so we make the 6th 3rd bit 0 to make the odd bit at the 3rd position\\n\\t#and we know that if there exist 1 in any number at that position then we can make others 0 and take the first one to make the odd\\n\\t#so here we are taking the or (which will take only the set bits - as we know 0 or 0 means 0 and 1 for all other cases)\\n\\t\\t\\tr = 0\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tr |= num\\n\\t\\t\\treturn r\\n\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef maximumXOR(self, nums):\\n\\t\\t\\t#approach1\\n\\t#         lis=[0 for _ in range(32)]\\n\\t#         for i in range(32):\\n\\t#             for j in nums:\\n\\t#                 if 1<<i & j:\\n\\t#                     lis[i]=1\\n\\t#                     break\\n\\t#         s=0\\n\\t#         val=1\\n\\n\\t#         for i in range(32):\\n\\t#             if lis[i]:\\n\\t#                 s+=val\\n\\t#             val*=2\\n\\t#         return s\\n\\n\\t#approach2\\n\\t#as we know we have to find the xor of all the elements\\n\\t#so we can observe there that we are calculating the sum only(of the odd bits)\\n\\t#lets take example\\n\\t#[3,2,4,6]\\n\\t#3-0011\\n\\t#2-0010\\n\\t#4-0100\\n\\t#6-0110\\n\\t#so we have to find only odd bit sum\\n\\t#so we make the 6th 3rd bit 0 to make the odd bit at the 3rd position\\n\\t#and we know that if there exist 1 in any number at that position then we can make others 0 and take the first one to make the odd\\n\\t#so here we are taking the or (which will take only the set bits - as we know 0 or 0 means 0 and 1 for all other cases)\\n\\t\\t\\tr = 0\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tr |= num\\n\\t\\t\\treturn r\\n\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n",
                "codeTag": "Java"
            },
            {
                "id": 2196973,
                "title": "python-solution-o-n-time-o-1-space",
                "content": "If you haven\\'t tried \\nhttps://leetcode.com/problems/single-number/ [easy]\\nyet that is a good warm up problem to this one. My description uses similar reasoning. \\n\\nIn particular checkout the solution # 6: Sum of Set Bits \\n\\nTo arrive at the solution observe two things:\\n\\n(1) nums[0] XOR nums[1] XOR ... XOR nums[n-1] will be the number of \\n*odd* set bit sums when we sum by ith bit index. \\n(2) The way that the AND operation works with the XOR is such that you can flip any and as many or as few bits you like. e.g. `6 & (4^6)` is the same as `110 & (100^110) = 110 & 010 = 010` and this last value is 2 in base 10 representation. The key point in the problem statement is that `x` can be *any* value so we choose the value that flips the necessary bit to make this column sum to an *odd* number instead of the *even* we currently have. \\n\\nIf we do the bit position sum for all the values and then the operation in (2) for all the even sums we\\'ll be left with all odd sums where there was a set bit in *at least one of the numbers* in the ith position.\\n\\nNow we don\\'t care which num in `nums` gave us this set bit this is the same as an `OR` on each value into a set bit accumulator. This gives us:\\n```\\ndef maximumXOR(nums: List[int]) -> int:\\n    r = 0\\n    for num in nums:\\n        r |= num\\n    return r\\n```\\n\\n\\nAlso a couple more using the bit manipulation approach described here:\\nhttps://leetcode.com/problems/missing-number/ [easy]\\nhttps://leetcode.com/problems/single-number-ii/ [medium]\\n https://leetcode.com/problems/find-the-duplicate-number/ [medium]\\n",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef maximumXOR(nums: List[int]) -> int:\\n    r = 0\\n    for num in nums:\\n        r |= num\\n    return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2196966,
                "title": "c-easy-o-n-or",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res=0;\\n        for(auto i:nums){\\n            res|=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res=0;\\n        for(auto i:nums){\\n            res|=i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196926,
                "title": "video-explanation-with-intuition",
                "content": "https://www.youtube.com/watch?v=q9HXx63DZCU",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=q9HXx63DZCU",
                "codeTag": "Unknown"
            },
            {
                "id": 2196642,
                "title": "js-reduce-1-liner",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumXOR = function(nums) {\\n  return nums.reduce((acc, cur) => acc |= cur, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumXOR = function(nums) {\\n  return nums.reduce((acc, cur) => acc |= cur, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196582,
                "title": "c-simple-code-or-operation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& a)\\n    {\\n        int n=a.size();\\n        \\n        if(n==1) return a[0];\\n        \\n        int ans=a[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=ans|a[i];\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maximumXOR(vector<int>& a)\\n    {\\n        int n=a.size();\\n        \\n        if(n==1) return a[0];\\n        \\n        int ans=a[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=ans|a[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2196443,
                "title": "simple-explanation-take-or-of-all-elements",
                "content": "Explanation \\nWe can unset or set any bit in A[i] by doing A[i]^x. As we can take same or reverse of that bit in x to unset or set the bit.\\nBut in every operation, we also have to do AND with A[i] so we can\\'t set any new bit in the result of one operation.\\nBut still we can unset any bit in any A[i] with one operation.\\nNow we can take every bit as set in the final answer if its set in any of the A[i]. To do so, we can unset the corresponding bit in rest of all numbers of the array except for A[i]. By proving this we can take final answer as OR of all the number of the array.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumXOR = function(nums) {\\n    let ans=0;\\n    for(let i=0;i<nums.length;i++){\\n        ans |= nums[i];\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maximumXOR = function(nums) {\\n    let ans=0;\\n    for(let i=0;i<nums.length;i++){\\n        ans |= nums[i];\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2196169,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int orr = 0;\\n        for (auto num : nums) orr |= num;\\n        return orr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int orr = 0;\\n        for (auto num : nums) orr |= num;\\n        return orr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196139,
                "title": "intuition-explained-in-detail-observation",
                "content": "<br/>\\nThe answer is simply bitwise OR of whole array.\\n\\n**But how do we observe this ?**\\n\\nAs we can replace nums[i] with nums[i] & (nums[i] ^ x)\\nThere are only 4 possible combinations of 0s and 1s, so let\\'s see what happens in all cases if we subtitute nums[i] with the above formula\\n\\n<pre>\\nnums[i]                 = 1 1 0 0\\nx                       = 0 1 0 1\\nnums[i] ^ x             = 1 0 0 1\\nnums[i] & (nums[i] ^ x) = 1 0 0 0\\n</pre>\\n\\nAs you can see from above example by this subtitution, we can get 1 as result only if the bit in nums[i] was 1, if it\\'s 0, we cannot make it 1 in anyway\\nAs we are not concerned about value of x and just final result, we can make sure that we will make subtituions such that the xor of ith bit of all numbers is 1\\nSo, we can make all such bits 1 which is not 0 in all elements of nums[i]\\n<br/>\\n\\n**Intuitive code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int ones = 0, zeros = 0;\\n            for(int& num: nums) {\\n                if((num >> i) & 1) ones++;\\n                else zeros++;\\n            }\\n            if(zeros != nums.size()) ans |= (1 << i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Optimised code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(int num: nums) {\\n            ans |= num;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<br/>",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int ones = 0, zeros = 0;\\n            for(int& num: nums) {\\n                if((num >> i) & 1) ones++;\\n                else zeros++;\\n            }\\n            if(zeros != nums.size()) ans |= (1 << i);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(int num: nums) {\\n            ans |= num;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196137,
                "title": "6105-maximum-xor-after-operations-bitwise-or",
                "content": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int[] bits=new int[32];//usigned int\\n        for(int x:nums){\\n            for(int i=0;i<32;i++){//count 1 at each bit positon!\\n                if((1&(x>>i))==1)\\n                    bits[i]=1;\\n            }\\n        }\\n        long ans=0L;\\n        for(int i=0;i<32;i++)\\n            ans+=(bits[i]==1)?(1<<i):0;//sum of that bit position that hit 1 | max \\n        return (int)ans;\\n    }\\n}\\n//or simply do BITWISE OR of the GIVEN Elements in the Array!\\n```",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int[] bits=new int[32];//usigned int\\n        for(int x:nums){\\n            for(int i=0;i<32;i++){//count 1 at each bit positon!\\n                if((1&(x>>i))==1)\\n                    bits[i]=1;\\n            }\\n        }\\n        long ans=0L;\\n        for(int i=0;i<32;i++)\\n            ans+=(bits[i]==1)?(1<<i):0;//sum of that bit position that hit 1 | max \\n        return (int)ans;\\n    }\\n}\\n//or simply do BITWISE OR of the GIVEN Elements in the Array!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196099,
                "title": "3-line-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int num=0;\\n        for(auto it:nums)\\n            num |=it;\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int num=0;\\n        for(auto it:nums)\\n            num |=it;\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196092,
                "title": "python-one-line-solution-o-n-with-explanation",
                "content": "If we try the \"nums[i] AND (nums[i] XOR x)\" operation, we get to know that this operation can be used to unset bits of a number. If we want the max XOR, then we want 1 at each possible place (if there is atleast one set bit at this place in any number). This definition seems familiar.\\nYess !! This is nothing but OR operation. \\nUsing the given operation, we can make result as OR operation. \\n```\\nfrom functools import reduce\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(lambda a,b : a|b, nums)\\n``",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "If we try the \"nums[i] AND (nums[i] XOR x)\" operation, we get to know that this operation can be used to unset bits of a number. If we want the max XOR, then we want 1 at each possible place (if there is atleast one set bit at this place in any number). This definition seems familiar.\\nYess !! This is nothing but OR operation. \\nUsing the given operation, we can make result as OR operation. \\n```\\nfrom functools import reduce\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(lambda a,b : a|b, nums)\\n``",
                "codeTag": "Java"
            },
            {
                "id": 2195989,
                "title": "very-easy-to-understand-code-counting-bits",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int>freq(31,0);\\n        for(auto x: nums)\\n        {\\n            for(int i=0;i<31;i++)\\n            {\\n                freq[i]+=(x&(1<<i))?1:0;\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<31;i++)\\n        {\\n            ans+=(freq[i]!=0)?1<<i:0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int>freq(31,0);\\n        for(auto x: nums)\\n        {\\n            for(int i=0;i<31;i++)\\n            {\\n                freq[i]+=(x&(1<<i))?1:0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2195970,
                "title": "simple-o-n-tc-and-o-1-sc-solution",
                "content": "For any bit that is on in any number that bit will be also on in the answer. So simply find all the possible on bits\\n```\\nclass Solution {\\npublic:\\n    int binaryToDecimal(string n){\\n        string num = n;\\n        int dec_value = 0, base = 1, len = num.length();\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (num[i] == \\'1\\')\\n                dec_value += base;\\n            base = base * 2;\\n        }\\n        return dec_value;\\n    }\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> v(33, 0);\\n        for(auto num : nums){\\n            int count = 0;\\n            while(num){\\n                if(num % 2 == 1)    v[count] = 1;\\n                num /= 2;\\n                count++;\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < 30; ++i){\\n            ans = to_string(v[i]) + ans;\\n        }\\n        return binaryToDecimal(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binaryToDecimal(string n){\\n        string num = n;\\n        int dec_value = 0, base = 1, len = num.length();\\n        for (int i = len - 1; i >= 0; i--) {\\n            if (num[i] == \\'1\\')\\n                dec_value += base;\\n            base = base * 2;\\n        }\\n        return dec_value;\\n    }\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> v(33, 0);\\n        for(auto num : nums){\\n            int count = 0;\\n            while(num){\\n                if(num % 2 == 1)    v[count] = 1;\\n                num /= 2;\\n                count++;\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i = 0; i < 30; ++i){\\n            ans = to_string(v[i]) + ans;\\n        }\\n        return binaryToDecimal(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195926,
                "title": "simple-or",
                "content": "```\\n    public int MaximumXOR(int[] nums) \\n    {\\n        int result = 0;\\n        foreach (var num in nums)\\n            result |= num;\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int MaximumXOR(int[] nums) \\n    {\\n        int result = 0;\\n        foreach (var num in nums)\\n            result |= num;\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2195923,
                "title": "python3-bit-operation",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/7a67de4e975be771355e048bf8dde4cf0906e360) for solutions of biweekly 81. \\n\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(or_, nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(or_, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195845,
                "title": "easy-c-solution-o-n-with-explaination",
                "content": "**OBSERVATION** : The main observaton is that we can not set any bit of any element in nums. We can only set off.\\nSo the optimal way will be to keep a bit on in exactly one element of nums. So that when we take XOR of all elements it will be on in the final answer.\\nHere is the implementation.\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) \\n    {\\n        int n=nums.size(),i,ans=0;\\n        vector <int> cnt(30);\\n        for(i=0;i<30;i++)\\n        {\\n            for(auto x : nums)\\n            {\\n                //count number of element that has ith bit set\\n                cnt[i]+=((x>>i)&1);\\n            }\\n            //if there is atleast one element in nums which has ith bit set\\n            if(cnt[i]>0)\\n            {\\n                //set the ith bit in ans\\n                ans+=(1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) \\n    {\\n        int n=nums.size(),i,ans=0;\\n        vector <int> cnt(30);\\n        for(i=0;i<30;i++)\\n        {\\n            for(auto x : nums)\\n            {\\n                //count number of element that has ith bit set\\n                cnt[i]+=((x>>i)&1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2195819,
                "title": "o-n-32-just-check-if-can-we-find-a-number-with-ith-bit-set",
                "content": "Explaination - \\nlets say\\nxor = n1 ^ n2 ^ .........nN\\nwhen this xor can be maximum -> when it has all the bits set.\\n\\nto have ith bit set in final xor ->\\nwe need to have atleast two numbers from our number set that has opposite ith bit.\\n\\nnow consider operations, what does it means?\\nnums[i] AND (nums[i] XOR x) -> it means, we can turn off  any set bit of nums[i].\\n\\nHow this operation can help us in maximising the final xor?\\nSince, we can turn off any set bit from a number that means -> To have ith bit set in our final ans we only need to check if we have one number that has ith bit set. \\n\\n\\n```\\ndef canWeFindANumberWithIthBitSet(i):\\n            mask = 1<<i\\n            for n in nums:\\n                if n&mask:\\n                    return True\\n            return False\\n        \\n        ans = \\'\\'\\n        for i in range(32, -1, -1):\\n            ans += \\'1\\' if canWeFindANumberWithIthBitSet(i) else \\'0\\'\\n        return int(ans, base=2)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\ndef canWeFindANumberWithIthBitSet(i):\\n            mask = 1<<i\\n            for n in nums:\\n                if n&mask:\\n                    return True\\n            return False\\n        \\n        ans = \\'\\'\\n        for i in range(32, -1, -1):\\n            ans += \\'1\\' if canWeFindANumberWithIthBitSet(i) else \\'0\\'\\n        return int(ans, base=2)\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2195810,
                "title": "just-4-lines-cpp",
                "content": "```\\n  int maximumXOR(vector<int>& nums) {\\n          int temp = 0;\\n        for(auto e: nums) temp |= e;\\n        return temp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  int maximumXOR(vector<int>& nums) {\\n          int temp = 0;\\n        for(auto e: nums) temp |= e;\\n        return temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997882,
                "title": "the-best-approach-you-can-ever-have-c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto &x : nums) ans |= x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(auto &x : nums) ans |= x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953780,
                "title": "java-solution-1ms-solution-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.length; i++)\\n            ans = ans | nums[i]; \\n\\n        return ans;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.length; i++)\\n            ans = ans | nums[i]; \\n\\n        return ans;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930031,
                "title": "c-best-easy-solution-in-3-lines",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans =0;\\n        for(auto x:nums)\\n        {\\n            ans = ans|x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans =0;\\n        for(auto x:nums)\\n        {\\n            ans = ans|x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865920,
                "title": "copied-solution-but-tried-to-explain-in-a-better-way",
                "content": "# Intuition\\nWhat does a&(a^b) do?\\nIt says that whatever bit of a is different from that of b, keep it. Turn all other bits to 0.\\n\\nThose different bits will anyway produce 1 when XORed. \\n\\nThe bits that were same as that of b are now 0. These bits were either 0 or 1 in b. If they were 1, they are now 0, and will produce 1 when XORed. \\n\\nRepeating the same operation on a again with b as x shall cause no change in a.\\n\\n\\nAlso please note that bits that are 0 in both a and b will never tranform to 1 with any number of operation between a nd b.\\n\\nHence the intuition. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) \\n    {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) \\n    {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865407,
                "title": "most-efficient-and-shortest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>&n){\\n        int o=0;\\n        for(auto i:n){\\n            o|=i;\\n        }\\n        return o;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>&n){\\n        int o=0;\\n        for(auto i:n){\\n            o|=i;\\n        }\\n        return o;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850552,
                "title": "very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> track(32,0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<32;j++)\\n            if(nums[i]&(1<<j))track[j]++;\\n        }\\n        int ans = 0;\\n        for(int i=0;i<32;i++)\\n        {\\n            if(track[i])ans+=(1<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> track(32,0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<32;j++)\\n            if(nums[i]&(1<<j))track[j]++;\\n        }\\n        int ans = 0;\\n        for(int i=0;i<32;i++)\\n        {\\n            if(track[i])ans+=(1<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804411,
                "title": "xor-to-or-thought-process-cpp-beats-90",
                "content": "# Intuition\\nIn starting i was about to gave up coz it looked so hard but then i took pen paper and started doing and figured things which i was able to see.XOR type question are not about long code its about one small idea which is hard to come up by just seeing.\\nRather if we give little time and sum up everything at last anybody can submit it again 2 times where 2nd time is the quick one.\\n\\n# Approach\\nfirst i thought :\\nmake vec(32,0) vector and check total bits at every position of all element.\\nif at any position the bit is odd then no need to do anything but any posittion if it is even then xor at that position will be zero which we can make 1 by making it odd\\nfor example:-0 1 0 2\\n     which means  0 0 0 1\\n                  0 1 0 1\\n  xor of which is : 0 1 0 0 cos xor of same is zero \\nif i can make 0 0 0 0\\n              0 1 0 1\\n       then the answer will become 1 0 1 which is same if i do or of \\n  0 0 0 1\\n  0 1 0 1\\n\\n:)\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int num=0;\\n        for(auto it:nums){\\n            num=num|it;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int num=0;\\n        for(auto it:nums){\\n            num=num|it;\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762994,
                "title": "racket-apply",
                "content": "```\\n(define/contract (maximum-xor nums)\\n    (-> (listof exact-integer?) exact-integer?)\\n    (apply bitwise-ior nums))\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```\\n(define/contract (maximum-xor nums)\\n    (-> (listof exact-integer?) exact-integer?)\\n    (apply bitwise-ior nums))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721556,
                "title": "c-linq-onliner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s construct a *truth table* for the operation with `item` and arbitrary `x`:\\n\\n```\\n  item | x | item ^ x | item & (item ^ x)\\n  ---------------------------------------\\n     0 | 0 |    0     |       0\\n     0 | 1 |    1     |       0\\n     1 | 0 |    1     |       1         <- either keep 1 \\n     1 | 1 |    0     |       0         <- or remove 1\\n```\\n\\nAs we can see, with a help of operation we can remove any set bit(s)(turn `1` into `0`) within array item. So far so good, we can eliminate some bits within array\\'s items in order to have *odd* number of `1` in each index, e.g.\\n\\n```\\n before   after\\n  1101    0101 <- 3d bit  removed\\n  0111 => 0110 <- 0th bit removed\\n  1110    1100 <- 1st bit removed\\n  ----    ----\\n  0100    1111 \\n```\\n\\nSo we can guarantee that each bit set (`1`) will result in bit set (`1`) and we have efficient bitwise OR operation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA *Linq* query (`Aggregate`)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n  public int MaximumXOR(int[] nums) => nums.Aggregate((s, a) => s | a);    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n  item | x | item ^ x | item & (item ^ x)\\n  ---------------------------------------\\n     0 | 0 |    0     |       0\\n     0 | 1 |    1     |       0\\n     1 | 0 |    1     |       1         <- either keep 1 \\n     1 | 1 |    0     |       0         <- or remove 1\\n```\n```\\n before   after\\n  1101    0101 <- 3d bit  removed\\n  0111 => 0110 <- 0th bit removed\\n  1110    1100 <- 1st bit removed\\n  ----    ----\\n  0100    1111 \\n```\n```\\npublic class Solution {\\n  public int MaximumXOR(int[] nums) => nums.Aggregate((s, a) => s | a);    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718649,
                "title": "easy-simple-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int  n = nums.size();\\n        vector<int> bits(32,0);\\n        for( int i =0;i<32; i++){\\n            for( auto x : nums){\\n                if( ( x>>i)& 1){\\n                    bits[i]=1;\\n                    break;\\n                }\\n            }\\n        }\\n        // for( auto x : bits){\\n        //     cout<<x<<\" \";\\n        // }\\n\\n        int ans=0;\\n        for( int i =0; i< 32;i++){\\n            if( bits[i]==1){\\n                ans = (ans)|(1<<i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int  n = nums.size();\\n        vector<int> bits(32,0);\\n        for( int i =0;i<32; i++){\\n            for( auto x : nums){\\n                if( ( x>>i)& 1){\\n                    bits[i]=1;\\n                    break;\\n                }\\n            }\\n        }\\n        // for( auto x : bits){\\n        //     cout<<x<<\" \";\\n        // }\\n\\n        int ans=0;\\n        for( int i =0; i< 32;i++){\\n            if( bits[i]==1){\\n                ans = (ans)|(1<<i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3718382,
                "title": "bitwise-or",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOur aim is to maximize the xor of all the elements present in the array. One approach is to step by step try to increase the maximum xor output possible. By maximizing the output we mean to increase the number of 1 in as many bits as we can, prioritizing the higher significant bits. \\n\\nHowever, we can try another approach in which instead of really going deep in our computational search, we just predict what the maximum output value can possible be by simply noticing the number of 1 bits for every bit position. \\nYou will realize that all you need to do is get the bitwise \\'OR\\' of all the elements present in the array \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n8 4 2 1\\n0 0 1 1\\n0 0 1 0\\n0 1 0 0\\n0 1 1 0\\n\\n0  1  1  1\\n*/\\n\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int output = 0;\\n        for(int num : nums){\\n            output = output | num;\\n        }\\n\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n8 4 2 1\\n0 0 1 1\\n0 0 1 0\\n0 1 0 0\\n0 1 1 0\\n\\n0  1  1  1\\n*/\\n\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int output = 0;\\n        for(int num : nums){\\n            output = output | num;\\n        }\\n\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3686914,
                "title": "kotlin-lovers-single-line-its-just-a-really-messed-up-way-of-saying-we-need-or-operation",
                "content": "# Intuition\\nIf you see some of the sample input bits. You will see the output has 1 if even one of them has 1 set in it. \\n\\n# Approach\\njust keep ORing each element\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    fun maximumXOR(nums: IntArray): Int = nums.reduce{a,b -> a.or(b)}\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumXOR(nums: IntArray): Int = nums.reduce{a,b -> a.or(b)}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684705,
                "title": "c-python-solution-with-explanation",
                "content": "\\nx(x ^ y) = x(!x y + x !y) = x (!y), the max value of x (!y) = x when !y = x, so we can generate some digit to unset bit of x.\\nwe just make each bit has 1 one bit, so do bitwise or for each number, and return it.\\ntc is O(n), sc is O(1)\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for (int& n: nums) ans |= n;\\n        return ans;\\n    }\\n};\\n```\\n### python\\n```python\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        ans = 0\\n        for n in nums:\\n            ans |= n\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for (int& n: nums) ans |= n;\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        ans = 0\\n        for n in nums:\\n            ans |= n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684097,
                "title": "c-bits-manipulation-with-explanation",
                "content": "Logic is if we have any bit as 1, we keep that 1 but if we don\\'t find any 1 then it is ought to be 0.\\n\\nTherefore we do bitwise OR as 1 OR 0 = 1 and 0 OR 0 = 0.\\n\\nApproach was suppose we have n & (n ^ x), then we can\\'t get anything greater than n. Therefore, use BITWISE OR.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto it:nums){\\n            ans|=it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto it:nums){\\n            ans|=it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667339,
                "title": "bitwise-or-the-array",
                "content": "# Approach\\nFor a k-th most significant digit, if nums[i] == 1, then we could pick x equals 1 if there are even number of 1s (decrement that number by 1), if current XOR estimate is 1, then for the number we would like to modify, pick x = 0 for the k-th most significant digit.\\n\\nWhereas we could not change XOR estimate from 0 to 1 since 0 AND 0 == 0 AND 1 == 1, this leads us the intuition of bitwise OR the array.  \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        ret = 0\\n\\n        for num in nums:\\n            ret |= num\\n        \\n        return ret\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        ret = 0\\n\\n        for num in nums:\\n            ret |= num\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664377,
                "title": "short-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto it:nums){\\n            ans |= it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto it:nums){\\n            ans |= it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657871,
                "title": "solved-in-29-seconds-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n       int n=0;\\n       for(int i=0;i<nums.size();i++)\\n        n=n|nums[i];\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n       int n=0;\\n       for(int i=0;i<nums.size();i++)\\n        n=n|nums[i];\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649236,
                "title": "bit-manipulation-o-n-32-time-complexity-o-1-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i=0;i<32;i++){\\n            bool digit = 0;\\n            for(int j=0;j<n;j++){\\n                digit |= (nums[j] & (1 << i));\\n            }\\n            if(digit == 1){\\n                ans |= (1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        for(int i=0;i<32;i++){\\n            bool digit = 0;\\n            for(int j=0;j<n;j++){\\n                digit |= (nums[j] & (1 << i));\\n            }\\n            if(digit == 1){\\n                ans |= (1<<i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629830,
                "title": "c-or-of-all-element",
                "content": "Observation: Need to maximize XOR of all element. We need to ensure that there is \"1\" exactly one time (or odd number of times) in specific bit position. With n & (n ^x) operation, we can change reset any bit in n. we do not need to perform any operation to come up with an answer. \\n\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for (const auto&n :nums) ans |= n;\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for (const auto&n :nums) ans |= n;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629435,
                "title": "c-bit-simple-easy-to-under-stand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int start = nums[0];\\n        /*  with the operation give we can make any bit from 1->0 but not from 1->0 \\n so when we have for a current bit 0 for  all the \\n            no in the nums vector then that bit cannot be high in the final ans \\n            so we exclude that bit \\n\\n            we if for a current bit for all the no is we have at least 1 bit high that bit will remain high in the final ans also \\n            we for that we can simple or all the no and we will get the ans \\n\\n        \\n        \\n        \\n        \\n        \\n        */ \\n        for(int i =1;i<nums.size();i++){\\n            start |= nums[i];\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int start = nums[0];\\n        /*  with the operation give we can make any bit from 1->0 but not from 1->0 \\n so when we have for a current bit 0 for  all the \\n            no in the nums vector then that bit cannot be high in the final ans \\n            so we exclude that bit \\n\\n            we if for a current bit for all the no is we have at least 1 bit high that bit will remain high in the final ans also \\n            we for that we can simple or all the no and we will get the ans \\n\\n        \\n        \\n        \\n        \\n        \\n        */ \\n        for(int i =1;i<nums.size();i++){\\n            start |= nums[i];\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621424,
                "title": "swift-solution-easy-to-understand-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport Foundation\\n\\nclass Solution {\\n    func maximumXOR(_ nums: [Int]) -> Int {\\n        var ans = 0\\n        let numsLength = nums.count\\n        var maximumNumberOfBits = 0\\n\\n        for number in nums {\\n            ans = (ans|number)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nimport Foundation\\n\\nclass Solution {\\n    func maximumXOR(_ nums: [Int]) -> Int {\\n        var ans = 0\\n        let numsLength = nums.count\\n        var maximumNumberOfBits = 0\\n\\n        for number in nums {\\n            ans = (ans|number)\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614733,
                "title": "90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       int maximumXOR(vector<int>& nums) {\\n          \\n        return reduce(nums.begin(), nums.end(), 0, bit_or());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n       int maximumXOR(vector<int>& nums) {\\n          \\n        return reduce(nums.begin(), nums.end(), 0, bit_or());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578662,
                "title": "easy-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n       int ans = 0;\\n       for(int i = 0; i<nums.size(); i++){\\n           ans |= nums[i];\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n       int ans = 0;\\n       for(int i = 0; i<nums.size(); i++){\\n           ans |= nums[i];\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558587,
                "title": "or-of-all-digits-will-maximise-the-ans",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i:nums){\\n            ans|=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto i:nums){\\n            ans|=i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538003,
                "title": "c-with-simple-explanation",
                "content": "\\n# Approach\\n```\\nnums[i] & (nums[i] ^ x) = (nums[i] & nums[i]) ^ (nums[i] & x) \\n= nums[i] ^ (nums[i] & x);\\n```\\nWe can do this infinitly, so our xor sum can contain any additional \\n```\\n(nums[i] & x)\\n```\\nThe thing is that we can add any non-zero bit from nums[i] to xor sum by using this operation. \\nXor sum can be maximized by increasing evenly counted bits to make them odd.\\n\\nSo, the answer would contain every non-zero bit of all nums.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            ans |= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnums[i] & (nums[i] ^ x) = (nums[i] & nums[i]) ^ (nums[i] & x) \\n= nums[i] ^ (nums[i] & x);\\n```\n```\\n(nums[i] & x)\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            ans |= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516909,
                "title": "go-bit-by-bit",
                "content": "# Intuition\\n\\nThe max that we can achieve is make every bit 1. \\n\\nBy given operation suppose the ith bit of a number is 1. can it be made 0? Yes, it can be. choose a number(x) with ith bit as 0 and xor it with original number and AND the result with original number. \\nBut what if the ith bit is 0, it can\\'t be made 1. Because we are doing AND with original number.\\n\\n# Approach\\n1. Go bit by bit\\n2. start from least significant bit\\n3. check the xor of all the bits at ith position\\n4. count the number of zeroes and ones at that position\\n5. if **xor==0** at ith position, **check if you can make the ith bit 1**.\\n6. if ith bit can be made one by given operation add it to result.\\n\\nExplanation of step 5:\\n- xor at ith pos can be 0 in two cases\\n  - **ith bit of all the number is zero**\\n  - **there exist even number of elements with ith bit as 1**.\\n- If ith bit of all the numbers is zero. We can\\'t change it to 1 by the given operation.(explained in intuition section)\\n- If there exist even number of elements with ith bit as 1, we can definitely make it as 0 by the given operation(explained in intuition section). So, effectively there will be odd number of ones and hence resultant **xor will be 1** at ith position.\\n# Complexity\\n- Time complexity:**O(n)**\\n\\n- Space complexity:**O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int result = 0;\\n        for(int i=0;i<32;i++){\\n\\n            int zeroes=0,ones = 0;\\n            int x = 0;\\n            for(int n :nums){\\n                if((n&(1<<i))){\\n                    ones++;\\n                    x^=1;\\n                }\\n                else{\\n                    zeroes++;\\n                    x^=0;\\n                }\\n            }\\n            if(x==0){\\n                if(ones>0){\\n                    result+=(1<<i);\\n                }\\n            }\\n            else{\\n                result+=(1<<i);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int result = 0;\\n        for(int i=0;i<32;i++){\\n\\n            int zeroes=0,ones = 0;\\n            int x = 0;\\n            for(int n :nums){\\n                if((n&(1<<i))){\\n                    ones++;\\n                    x^=1;\\n                }\\n                else{\\n                    zeroes++;\\n                    x^=0;\\n                }\\n            }\\n            if(x==0){\\n                if(ones>0){\\n                    result+=(1<<i);\\n                }\\n            }\\n            else{\\n                result+=(1<<i);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455322,
                "title": "python3-math-one-line-approach",
                "content": "# Intuition\\nWe can pick any item ``nums[i]`` in the array and any value ``x`` and change it to:\\n```\\nnums[i] = nums[i] AND (nums[i] XOR x)\\n```\\nAND operation ensures us that we won\\'t add any 1-s to the number, and XOR operation changes those bits where 1 is set in ``x``. That means that we can remove any bits from any item in the array ``nums``.\\n\\nWe need to maximize XOR of all items in the array. In order to do so we need to unset bits in items in the way so that for any bit we only have odd number of ones (or a single 1) across all items in the array. \\nThus we will get bitwise OR of all items in the array.\\n\\n# Approach\\nCalculate and return bitwise OR of the array.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(lambda s, t: s | t, nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nnums[i] = nums[i] AND (nums[i] XOR x)\\n```\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(lambda s, t: s | t, nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3408241,
                "title": "easy-and-simple-c",
                "content": "# Intuition\\nPerform the OR operation of all the values.\\n\\n# Approach\\nPerform the OR operation.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans=ans|nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            ans=ans|nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404715,
                "title": "simple-c-solution-using-o-n-complexity",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n   \\n    As the array used is of constant size 32 hence O(1) space complexity.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int>ans(32,0);\\n        for(int i:nums){\\n            for(int j=0;j<32;++j){\\n                if(i&(1<<j)){\\n                    ans[j]=1;\\n                }\\n            }\\n        }\\n        long long answer=0;\\n        for(int i=0;i<32;++i){\\n            if(ans[i])\\n            answer+=pow(2,i);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int>ans(32,0);\\n        for(int i:nums){\\n            for(int j=0;j<32;++j){\\n                if(i&(1<<j)){\\n                    ans[j]=1;\\n                }\\n            }\\n        }\\n        long long answer=0;\\n        for(int i=0;i<32;++i){\\n            if(ans[i])\\n            answer+=pow(2,i);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391561,
                "title": "java-python-c-one-liner-bitwise-or-used-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```JAVA(One Liner-Bitwise OR)\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n    int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n        //time complexity-O(n);\\n        // space complexity-O(n);\\n    }\\n\\n}\\n\\nPython(One Liner-BitWise OR)\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n    int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n        //time complexity-O(n);\\n        // space complexity-O(n);\\n    }\\n\\n}\\n\\nC(One Liner-BitWise OR)\\nint maximumXOR(int* nums, int numsSize) {\\n    int res = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        res |= nums[i];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```JAVA(One Liner-Bitwise OR)\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n    int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n        //time complexity-O(n);\\n        // space complexity-O(n);\\n    }\\n\\n}\\n\\nPython(One Liner-BitWise OR)\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n    int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n        //time complexity-O(n);\\n        // space complexity-O(n);\\n    }\\n\\n}\\n\\nC(One Liner-BitWise OR)\\nint maximumXOR(int* nums, int numsSize) {\\n    int res = 0;\\n    for (int i = 0; i < numsSize; i++) {\\n        res |= nums[i];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378086,
                "title": "very-easy-bit-manipulation-2-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        \\n        int y=0;\\n        for(auto it:nums){\\n            y|=it;\\n        }\\n        return y;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        \\n        int y=0;\\n        for(auto it:nums){\\n            y|=it;\\n        }\\n        return y;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368510,
                "title": "only-four-line-code-easy-solution-100-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/9ceddf41-3492-4ac2-8469-58a88e896d0a_1680408711.6516178.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for (int a: nums)\\n            res |= a;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340267,
                "title": "c-simple-3-line-of-code-or-operation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(int i:nums)ans|=i;\\n        return ans;        \\n    }\\n};\\n```\\n\\n**UPVOTE IF HELPFUL!!!!!**\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(int i:nums)ans|=i;\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299404,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maximumXOR(_ nums: [Int]) -> Int {\\n        nums.reduce(0, |)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumXOR(_ nums: [Int]) -> Int {\\n        nums.reduce(0, |)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282494,
                "title": "java-easy-approach",
                "content": "# Intuition\\n\\n\\n# Approach\\nBrute force approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n            int x=0;\\n            for(int i=0;i<nums.length;i++){\\n                nums[i]=nums[i]&(nums[i]^x);\\n                x^=nums[i];\\n            }\\n            return x;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n            int x=0;\\n            for(int i=0;i<nums.length;i++){\\n                nums[i]=nums[i]&(nums[i]^x);\\n                x^=nums[i];\\n            }\\n            return x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280255,
                "title": "shortest-easiest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& v) {\\n        int k=0;\\n        vector<int>p;\\n        for(int i=0;i<v.size();i++)k|=v[i];p.push_back(k);\\n        return *max_element(p.begin(),p.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& v) {\\n        int k=0;\\n        vector<int>p;\\n        for(int i=0;i<v.size();i++)k|=v[i];p.push_back(k);\\n        return *max_element(p.begin(),p.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275304,
                "title": "simple-kotlin-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    fun maximumXOR(nums: IntArray): Int {\\n        var result = 0\\n        for (num in nums) result = result or num\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maximumXOR(nums: IntArray): Int {\\n        var result = 0\\n        for (num in nums) result = result or num\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247498,
                "title": "java-beats-100-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            res |=nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            res |=nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227270,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n         int n = nums.size();\\n        int ans = 0;\\n        for (int i = 0; i < n; i++){\\n            ans =ans| nums[i];\\n        \\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n         int n = nums.size();\\n        int ans = 0;\\n        for (int i = 0; i < n; i++){\\n            ans =ans| nums[i];\\n        \\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224234,
                "title": "1-line-java-solution-just-or-of-all-elements",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for(int i : nums)\\n            res|=i;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res = 0;\\n        for(int i : nums)\\n            res|=i;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198724,
                "title": "c-one-liner-easy-soln-with-expln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOn observing we can find with the given operation we can remove any element. So to maximise xor sum we can simply maximum ones or set bits in the array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTaking OR of all elemnets keeps track of all set bits.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n   $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ret =0; for(auto it : nums) ret |= it; return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ret =0; for(auto it : nums) ret |= it; return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171020,
                "title": "0ms-and-very-easy-explantion",
                "content": "# Intuition\\njust little observation\\n# Approach\\njust take pen and paper and you\\'ll observe we just need to find the or of all the elements\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto x:nums)\\n        ans|=x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(auto x:nums)\\n        ans|=x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170911,
                "title": "c-short-and-concise-solution-with-explanation-o-n-time-complexity",
                "content": "# Approach\\nThe approach behind the solution is that by the operation given in the question for nums[i], 1 can be converted to 0 but not 0 to 1 because AND is used. To get a maximum ans we need as much 1 as possible, and if ith bit of any element of the nums is 1 then this can be converted into a 1 .Thus we OR every element of nums.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res|=nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res|=nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167535,
                "title": "python-one-line-o-n",
                "content": "# Approach\\n* Suppose $$ n = 2^{i_0} + 2^{i_1} + ... 2^{i_m}$$ and $\\\\forall j: i_j > 0$ and $M = \\\\{i_0, i_1, ..., i_m\\\\}$\\n* For every subset $I \\\\subset \\\\{0, 1, ..., m\\\\}$ we can choose such `x` what, after operation `n = n AND (n XOR x)` $n$ becomes equal to $$ n = \\\\sum_{j \\\\in I} 2^{i_j}$$\\n  * $x = \\\\sum_{j \\\\in M \\\\setminus I} 2^{i_j}$\\n* This means that we can leave exactly one copy of each bit\\n* And the answer is `nums[0] OR nums[1] OR ... OR nums[n - 1]`\\n\\n# Complexity\\nTime complexity: $O(n)$\\nSpace complexity: $O(1)$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(ior, nums, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        return reduce(ior, nums, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154263,
                "title": "c-java-python3-easy-approach",
                "content": "# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n\\n     int maxXOR = nums[0];\\n\\n     for(int ans: nums)\\n     {\\n         maxXOR = maxXOR | ans;\\n     }\\n\\n     return maxXOR;\\n\\n    }\\n};\\n```\\n\\n# Python3 Code:\\n\\n```\\nclass Solution:\\n    def maximumXOR(self, nums):\\n        maxXOR = nums[0]\\n        for ans in nums:\\n            maxXOR = maxXOR | ans\\n        return maxXOR\\n\\n```\\n\\n# Java Code: \\n\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int maxXOR = nums[0];\\n\\n        for (int ans : nums) {\\n            maxXOR = maxXOR | ans;\\n        }\\n\\n        return maxXOR;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n\\n     int maxXOR = nums[0];\\n\\n     for(int ans: nums)\\n     {\\n         maxXOR = maxXOR | ans;\\n     }\\n\\n     return maxXOR;\\n\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maximumXOR(self, nums):\\n        maxXOR = nums[0]\\n        for ans in nums:\\n            maxXOR = maxXOR | ans\\n        return maxXOR\\n\\n```\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int maxXOR = nums[0];\\n\\n        for (int ans : nums) {\\n            maxXOR = maxXOR | ans;\\n        }\\n\\n        return maxXOR;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145193,
                "title": "3-line-code-ezyyyyyyyyyyyyyyyyyy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n      int y = 0;\\nfor(int x :nums)y = y|x;\\nreturn y;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n      int y = 0;\\nfor(int x :nums)y = y|x;\\nreturn y;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124678,
                "title": "c-beats-100",
                "content": "# Intuition\\nAs we may choose arbitrary `x`, the term `t = (nums[i] XOR x)` can result arbitrary numbers by choosing `x = (nums[i] XOR t)`. As an `AND` operation is applied to `nums[i]` and `t`, arbitrary bits can be set to 0, but a 0 bit in `nums[i]` can not be set to 1. Therefore, for each position where at least one 1 bit in `nums` exists, all but one 1 can be set to 0. Therefore, the result equals the `OR` operation applied to all elements of `nums`.\\n\\n# Approach\\nIterating over the array and applying the `OR` operator to all elements.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ additional space\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumXOR(int[] nums) {\\n        int result = 0;\\n        foreach(int i in nums)\\n            result = result | i;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumXOR(int[] nums) {\\n        int result = 0;\\n        foreach(int i in nums)\\n            result = result | i;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096489,
                "title": "c",
                "content": "```\\nint maximumXOR(int* nums, int numsSize){\\n    int ans = 0 ;\\n    for(int i = 0; i < numsSize; i++){\\n        ans |= nums[i] ;\\n    }\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maximumXOR(int* nums, int numsSize){\\n    int ans = 0 ;\\n    for(int i = 0; i < numsSize; i++){\\n        ans |= nums[i] ;\\n    }\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055554,
                "title": "java-solution-1-ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n     int result=0;\\n     for(int i=0; i<nums.length; i++){\\n         result = result | nums[i];\\n     }\\n     return result;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n     int result=0;\\n     for(int i=0; i<nums.length; i++){\\n         result = result | nums[i];\\n     }\\n     return result;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027118,
                "title": "python-3-lines-solution-with-explanation",
                "content": "# Approach\\nn = number in nums\\nx = ANY number (doesn\\'t have to be in nums)\\nFirst, let\\'s observe that the binary operation n = n & (n^x) can only transform 1 => 0 for any bit in n, never 0 => 1. That\\'s because XOR can switch any bit in n, but then doing & n switches any \"new\" 1 back to original 0.\\n\\nTherefore for every number we can select some value x in order to keep any number of \"wanted\" 1-bits, and transform the \"unwanted\" to 0. By \"wanted\" of course I mean the bits which will give us maximum result in the end. \\n\\nConclusion is that we can select the values of x in such a way that the binary represenation of the result (the XOR of all elements) will have 1-bits in a given position if ANY of the numbers in nums has 1-bit in this position.\\n\\nFor example: if every number in the series has \"0\" as the second bit from the right, the result will also have it, since we cannot turn 0 into 1 (see above).\\n\\nThe binary operation which represents our conclusion is obviously binary OR. Hence:\\nfor n in nums: res |= n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n\\n        res = 0\\n        for n in nums: res |= n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n\\n        res = 0\\n        for n in nums: res |= n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985765,
                "title": "100-fast-2-liner-very-easy-approach-java",
                "content": "- Time complexity:$$O(n)$$ \\n- Space complexity:$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum = sum | nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum = sum | nums[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976098,
                "title": "c-golang-simple-bit-manipulation",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int count = 0;\\n            for(int j = 0; j < n; j++) {\\n                if(nums[j] & (1 << i))\\n                    count++;\\n            }\\n            if(count)\\n                ans |= (1 << i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Golang\\nfunc maximumXOR(nums []int) int {\\n    var n int = len(nums)\\n    var ans int = 0\\n    for i := 0; i < 32; i++ {\\n        var count int = 0\\n        for j := 0; j < n; j++ {\\n            if nums[j] & (1 << i) != 0 {\\n                count++\\n            }\\n        }\\n        if count != 0 {\\n            ans = ans | (1 << i)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        for(int i = 0; i < 32; i++) {\\n            int count = 0;\\n            for(int j = 0; j < n; j++) {\\n                if(nums[j] & (1 << i))\\n                    count++;\\n            }\\n            if(count)\\n                ans |= (1 << i);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Golang\\nfunc maximumXOR(nums []int) int {\\n    var n int = len(nums)\\n    var ans int = 0\\n    for i := 0; i < 32; i++ {\\n        var count int = 0\\n        for j := 0; j < n; j++ {\\n            if nums[j] & (1 << i) != 0 {\\n                count++\\n            }\\n        }\\n        if count != 0 {\\n            ans = ans | (1 << i)\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956746,
                "title": "python-simple-or-operation-o-n-explained",
                "content": "Just bitwise OR for all the numbers since we only need to know the bits that are 1 in the list.\\n\\n```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        ans = 0\\n        for num in nums:\\n            ans |= num\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumXOR(self, nums: List[int]) -> int:\\n        ans = 0\\n        for num in nums:\\n            ans |= num\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920559,
                "title": "easy-to-understand-o-nlogn-tc-constant-space-o-32-clean-short-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> bit_cnt(32, 0);\\n        int pos;\\n        for(auto num : nums){\\n            pos = 0;\\n            while(num){\\n                bit_cnt[pos++] += num & 0x1;\\n                num >>= 1;\\n            }\\n        }\\n        for(int j = 0; j < nums.size(); ++j){\\n            pos = 0;\\n            while(nums[j]){\\n                if(nums[j] & 0x1){\\n                    if(!(bit_cnt[pos] & 0x1)){\\n                        bit_cnt[pos]--;\\n                    }\\n                }\\n                nums[j] >>= 1;\\n                ++pos;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < 32; ++i){\\n            if(bit_cnt[i] & 0x1){\\n                ans += (1 << i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        vector<int> bit_cnt(32, 0);\\n        int pos;\\n        for(auto num : nums){\\n            pos = 0;\\n            while(num){\\n                bit_cnt[pos++] += num & 0x1;\\n                num >>= 1;\\n            }\\n        }\\n        for(int j = 0; j < nums.size(); ++j){\\n            pos = 0;\\n            while(nums[j]){\\n                if(nums[j] & 0x1){\\n                    if(!(bit_cnt[pos] & 0x1)){\\n                        bit_cnt[pos]--;\\n                    }\\n                }\\n                nums[j] >>= 1;\\n                ++pos;\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < 32; ++i){\\n            if(bit_cnt[i] & 0x1){\\n                ans += (1 << i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917570,
                "title": "maximum-xor-after-operations",
                "content": "# Intuition:\\nIF FOR ALL ELEMENTS AT A PARTICULAR BIT IF THERE IS AT LEAST 1 SET BIT THEN IN FINAL RESULT THAT BIT WOULD BE SET OTHERWISE UNSET\\n\\n# Approach\\nCHECK COUNT OF SET BITS FOR ALL ELEMENT IN A PARTICULAR POSITION IF COUNT IS GREATER THEN ZERO THEN ST THAT POSITION BIT IN ANSWER  \\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<=31;i++){\\n            int ct(0);\\n            for(int j=0;j<nums.size();++j){\\n                if(nums[j]&(1<<i)) ct++;\\n            }\\n            if(ct) ans |= (1<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<=31;i++){\\n            int ct(0);\\n            for(int j=0;j<nums.size();++j){\\n                if(nums[j]&(1<<i)) ct++;\\n            }\\n            if(ct) ans |= (1<<i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911428,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& a) {\\n        int ans = a[0];\\n        for(auto &e : a) ans |= e;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& a) {\\n        int ans = a[0];\\n        for(auto &e : a) ans |= e;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898701,
                "title": "one-line-cpp",
                "content": "\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n       \\n        int x_or=0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            x_or=x_or|nums[i];\\n\\n        }\\n        return x_or;\\n\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n       \\n        int x_or=0;\\n\\n        for(int i=0;i<nums.size();i++){\\n            x_or=x_or|nums[i];\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2862470,
                "title": "javascript-typescript-solution",
                "content": "```\\nconst maximumXOR = function(nums) {\\n    return nums.reduce((a, b) => a |= b, 0);\\n};\\n```\\n\\n```\\nfunction maximumXOR(nums: number[]): number {\\n  return nums.reduce((a, b) => a |= b, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nconst maximumXOR = function(nums) {\\n    return nums.reduce((a, b) => a |= b, 0);\\n};\\n```\n```\\nfunction maximumXOR(nums: number[]): number {\\n  return nums.reduce((a, b) => a |= b, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2830461,
                "title": "c-using-bit-manipulation-two-approaches-in-time-o-n-space-o-n-o-1-zansar",
                "content": "# Author \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[Zanhd](https://leetcode.com/zanhd/)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& a) \\n    {\\n        int n = a.size();\\n        \\n        int bit[32];\\n        memset(&bit, 0x00, sizeof(bit));\\n\\n        for(int i = 0; i < 32; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(a[j] & (1 << i))\\n                {\\n                    bit[i]++;\\n                }\\n            }\\n        }   \\n\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans ^= a[i];\\n\\n        for(int i = 0; i < 32; i++)\\n        {\\n            if(!bit[i]) continue;\\n            ans |= (1 << i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n# Author \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[Sara](https://leetcode.com/sara_24/)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int y=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            y=y|nums[i];\\n        }\\n        return y;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& a) \\n    {\\n        int n = a.size();\\n        \\n        int bit[32];\\n        memset(&bit, 0x00, sizeof(bit));\\n\\n        for(int i = 0; i < 32; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(a[j] & (1 << i))\\n                {\\n                    bit[i]++;\\n                }\\n            }\\n        }   \\n\\n        \\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n            ans ^= a[i];\\n\\n        for(int i = 0; i < 32; i++)\\n        {\\n            if(!bit[i]) continue;\\n            ans |= (1 << i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int y=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            y=y|nums[i];\\n        }\\n        return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788471,
                "title": "or-of-all-elements-o-n-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    // nums[i] AND (nums[i] XOR x) --> this means that you have the liberty to off some of the set bits of nums[i]\\n    // hence we need to find max xor of all elements with the power to set some ON bits to OFF\\n    // So what we could do is change every ON bit to OFF that is on the same position of another ON bit in the array\\n    // and keep only one ON bit at every position possible ( out of 32 indexes ) \\n    \\n    // and that is the OR function\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i : nums)\\n            ans |= i;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // nums[i] AND (nums[i] XOR x) --> this means that you have the liberty to off some of the set bits of nums[i]\\n    // hence we need to find max xor of all elements with the power to set some ON bits to OFF\\n    // So what we could do is change every ON bit to OFF that is on the same position of another ON bit in the array\\n    // and keep only one ON bit at every position possible ( out of 32 indexes ) \\n    \\n    // and that is the OR function\\n    int maximumXOR(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i : nums)\\n            ans |= i;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779061,
                "title": "golang-solution",
                "content": "# Golang Solution\\n```\\nfunc maximumXOR(nums []int) int {\\n    res :=0\\n    for _,i := range nums{\\n        res = res | i\\n    }\\n    return res\\n}\\n```\\n\\n\\n# Rust Solution\\n```\\nimpl Solution {\\n    pub fn maximum_xor(nums: Vec<i32>) -> i32 {\\n        let mut res = 0;\\n        for i in nums.iter(){\\n            res = res | i;\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumXOR(nums []int) int {\\n    res :=0\\n    for _,i := range nums{\\n        res = res | i\\n    }\\n    return res\\n}\\n```\n```\\nimpl Solution {\\n    pub fn maximum_xor(nums: Vec<i32>) -> i32 {\\n        let mut res = 0;\\n        for i in nums.iter(){\\n            res = res | i;\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2743701,
                "title": "easy-and-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) \\n    {\\n        int ans=0;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            int cnt=0;\\n            while(nums[i])\\n            {\\n                if (nums[i]&1)\\n                {\\n                    \\n                    int mask=(1<<cnt);\\n                    ans|=mask;\\n                }\\n                cnt++;\\n                nums[i]=nums[i]>>1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) \\n    {\\n        int ans=0;\\n        for (int i=0;i<nums.size();i++)\\n        {\\n            int cnt=0;\\n            while(nums[i])\\n            {\\n                if (nums[i]&1)\\n                {\\n                    \\n                    int mask=(1<<cnt);\\n                    ans|=mask;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2735923,
                "title": "maximum-xor-after-operations-easy-understanding",
                "content": "class Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res=res|nums[i];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res=res|nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2733098,
                "title": "java-solution-o-n-log-n",
                "content": "**Approach 1:**\\n\\n```java []\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int bits[] = new int[32], res=0;\\n        for(int n:nums) {\\n            int idx = 0;\\n            while(n>0) {\\n                bits[idx] |= n%2;\\n                n /= 2;\\n                ++idx;\\n            }\\n        }\\n        for(int i=0, base=1; i<32; ++i) {\\n            res += bits[i]*base;\\n            base *= 2;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Approach 2:**\\n\\nOR of all elements\\n\\n```java []\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res=0;\\n        for(int n:nums) res |= n;\\n        return res;\\n    }\\n}\\n```\\n\\nUpvote if u have liked!",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int bits[] = new int[32], res=0;\\n        for(int n:nums) {\\n            int idx = 0;\\n            while(n>0) {\\n                bits[idx] |= n%2;\\n                n /= 2;\\n                ++idx;\\n            }\\n        }\\n        for(int i=0, base=1; i<32; ++i) {\\n            res += bits[i]*base;\\n            base *= 2;\\n        }\\n        return res;\\n    }\\n}\\n```\n```java []\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int res=0;\\n        for(int n:nums) res |= n;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717348,
                "title": "easy-explanation",
                "content": "to maximize the XOR we need more 1s on left most side but the operation a AND(a XOR  A[i]  can only turn 1 to 0 it can\\'t turn 0 to 1. \\nso, we can use OR operation for all element of array because it will give you maximum possible 1s you can get in  numbers given. \\nOR operation will give you 1 for 0 OR 1 and also give you 1 for 1 OR 1.\\n\\'\\'\\'\\n    int res = 0;\\n        for (int i=0;i<nums.size();i++)\\n            res = res| nums[i];\\n        return res;\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "to maximize the XOR we need more 1s on left most side but the operation a AND(a XOR  A[i]  can only turn 1 to 0 it can\\'t turn 0 to 1. \\nso, we can use OR operation for all element of array because it will give you maximum possible 1s you can get in  numbers given. \\nOR operation will give you 1 for 0 OR 1 and also give you 1 for 1 OR 1.\\n\\'\\'\\'\\n    int res = 0;\\n        for (int i=0;i<nums.size();i++)\\n            res = res| nums[i];\\n        return res;\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2703490,
                "title": "very-easy-solution-using-bit-manipulation-99-5-less-memory-usage",
                "content": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n                \\n        int mxInd = -1;\\n        \\n        HashSet<Integer> hs = new HashSet<>();\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            for(int j = 0; j<31; j++){\\n                if((nums[i]&(1<<j)) != 0){\\n                    mxInd = Math.max(mxInd, j);\\n                    hs.add(j);\\n                }\\n            }\\n        }\\n        \\n        String bin = \"\";\\n        \\n        for(int i = mxInd; i>-1; i--){\\n            if(hs.contains(i)){\\n                bin+=\\'1\\';\\n            }\\n            else{\\n                bin+=\\'0\\';\\n            }\\n        }\\n        //System.out.println(bin);\\n        if(bin.equals(\"\")){\\n            return 0;\\n        }\\n        return Integer.parseInt(bin, 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n                \\n        int mxInd = -1;\\n        \\n        HashSet<Integer> hs = new HashSet<>();\\n        \\n        for(int i = 0; i<nums.length; i++){\\n            for(int j = 0; j<31; j++){\\n                if((nums[i]&(1<<j)) != 0){\\n                    mxInd = Math.max(mxInd, j);\\n                    hs.add(j);\\n                }\\n            }\\n        }\\n        \\n        String bin = \"\";\\n        \\n        for(int i = mxInd; i>-1; i--){\\n            if(hs.contains(i)){\\n                bin+=\\'1\\';\\n            }\\n            else{\\n                bin+=\\'0\\';\\n            }\\n        }\\n        //System.out.println(bin);\\n        if(bin.equals(\"\")){\\n            return 0;\\n        }\\n        return Integer.parseInt(bin, 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702738,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int l = nums.length;\\n        int[] res = new int[32];\\n        int mask = 1;\\n        for(int i=0;i<32;i++)\\n        {\\n            for(int j=0;j<l;j++)\\n            {\\n                if((mask & nums[j]) > 0)\\n                {\\n                    res[i]++;\\n                }\\n            }\\n            mask <<= 1;\\n        }\\n        int ans = 0;\\n        mask = 1;\\n        for(int i=0;i<32;i++)\\n        {\\n            if(res[i] > 0)\\n            {\\n                if(res[i]%2==0)\\n                {\\n                    ans = ans|mask;\\n                }\\n            }\\n            mask <<= 1;\\n        }\\n        int r = 0;\\n        for(int i=0;i<l;i++)\\n        {\\n            r ^= nums[i];\\n        }\\n        return r^ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumXOR(int[] nums) {\\n        int l = nums.length;\\n        int[] res = new int[32];\\n        int mask = 1;\\n        for(int i=0;i<32;i++)\\n        {\\n            for(int j=0;j<l;j++)\\n            {\\n                if((mask & nums[j]) > 0)\\n                {\\n                    res[i]++;\\n                }\\n            }\\n            mask <<= 1;\\n        }\\n        int ans = 0;\\n        mask = 1;\\n        for(int i=0;i<32;i++)\\n        {\\n            if(res[i] > 0)\\n            {\\n                if(res[i]%2==0)\\n                {\\n                    ans = ans|mask;\\n                }\\n            }\\n            mask <<= 1;\\n        }\\n        int r = 0;\\n        for(int i=0;i<l;i++)\\n        {\\n            r ^= nums[i];\\n        }\\n        return r^ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689981,
                "title": "c-mediocre-solution-time-o-n-space-o-1",
                "content": "# Intuition\\nStart with an example\\n```\\nnums = [ 3, 2, 4, 6 ]\\n3 = 0011\\n2 = 0010\\n4 = 0100\\n6 = 0110\\nXOR(3, 2, 4, 6) = 0011\\n\\nwe have zero 1s at index 0 -> XOR of all bits at index 0 becomes 0\\nwe have two 1s at index 1 -> XOR of all bits at index 1 becomes 0\\nwe have three 1s at index 2 -> XOR of all bits at index 2 becomes 1\\nwe have one 1s at index 3 -> XOR of all bits at index 3 becomes 1\\n...\\nwe have Odd 1s at index i -> XOR of all bits at index i becomes 1 (good)\\nwe have Even 1s at index i -> XOR of all bits at index i becomes 0 (not good)\\n```\\n\\nThe given operation `nums[i] = nums[i] & (nums[i] ^ x)` let us to **clear any single bit of** `nums[i]` if we want to.\\n\\nTherefore, if we want to **maximize** the result of *XOR*(`nums`), we can apply a operation to **reduce an even number of 1s to an odd number of 1s** to get a **1** at that resultant bit.\\n\\nBe aware of zero 1s, zero is an even number but we are not able to reduce it to get an odd number of 1s.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSince `nums[i]` <= $$10^8$$, at most 30 bits, we can check for every bits of every `nums[i]`\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maximumXOR(vector<int>& nums) {\\n    int result = 0;\\n    for (int i = 0; i < 30; i++) {\\n      int ones = 0;\\n      for (const int& num : nums) {\\n        if (num & (1 << i))\\n          ones++;\\n      }\\n      if (ones % 2 or ones >= 2)\\n        result |= 1 << i;\\n    }\\n    return result;\\n  }\\n};\\n```\\n\\n**Alternative solution**\\n- Just take the *OR* of `nums`\\n```\\nclass Solution {\\npublic:\\n  int maximumXOR(vector<int>& nums) {\\n    int result = 0;\\n    for (const int& num : nums) {\\n      result |= num;\\n    }\\n    return result;\\n  }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n  int maximumXOR(vector<int>& nums) {\\n    return accumulate(nums.begin(), nums.end(), 0, bit_or<>());\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnums = [ 3, 2, 4, 6 ]\\n3 = 0011\\n2 = 0010\\n4 = 0100\\n6 = 0110\\nXOR(3, 2, 4, 6) = 0011\\n\\nwe have zero 1s at index 0 -> XOR of all bits at index 0 becomes 0\\nwe have two 1s at index 1 -> XOR of all bits at index 1 becomes 0\\nwe have three 1s at index 2 -> XOR of all bits at index 2 becomes 1\\nwe have one 1s at index 3 -> XOR of all bits at index 3 becomes 1\\n...\\nwe have Odd 1s at index i -> XOR of all bits at index i becomes 1 (good)\\nwe have Even 1s at index i -> XOR of all bits at index i becomes 0 (not good)\\n```\n```\\nclass Solution {\\npublic:\\n  int maximumXOR(vector<int>& nums) {\\n    int result = 0;\\n    for (int i = 0; i < 30; i++) {\\n      int ones = 0;\\n      for (const int& num : nums) {\\n        if (num & (1 << i))\\n          ones++;\\n      }\\n      if (ones % 2 or ones >= 2)\\n        result |= 1 << i;\\n    }\\n    return result;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int maximumXOR(vector<int>& nums) {\\n    int result = 0;\\n    for (const int& num : nums) {\\n      result |= num;\\n    }\\n    return result;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  int maximumXOR(vector<int>& nums) {\\n    return accumulate(nums.begin(), nums.end(), 0, bit_or<>());\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641234,
                "title": "easy-3-liner-c-solution-t-c-o-n-s-c-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n       int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n            ans=ans|nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumXOR(vector<int>& nums) {\\n       int ans=0;\\n        for(int i=0;i<nums.size();i++)\\n            ans=ans|nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632157,
                "title": "rust-fold",
                "content": "bitwise OR\\n```\\nimpl Solution {\\n    pub fn maximum_xor(nums: Vec<i32>) -> i32 {\\n        nums.into_iter()\\n            .fold(0, |acc, x| acc | x)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_xor(nums: Vec<i32>) -> i32 {\\n        nums.into_iter()\\n            .fold(0, |acc, x| acc | x)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593556,
                "title": "c-easy-one-liner-solution-bitmask",
                "content": "```\\nint maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for (auto &it :nums) ans= ans | it;\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nint maximumXOR(vector<int>& nums) {\\n        int ans=0;\\n        for (auto &it :nums) ans= ans | it;\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2588942,
                "title": "c-solution-o-n-time-o-1-space-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    static int maximumXOR(const vector<int>& nums) {\\n        int ret = 0;\\n        for (auto i : nums)\\n            ret |= i;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int maximumXOR(const vector<int>& nums) {\\n        int ret = 0;\\n        for (auto i : nums)\\n            ret |= i;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1800628,
                "content": [
                    {
                        "username": "District_12",
                        "content": "What does it mean \"In one operation,\"?\\nWhat does it mean \"select any non-negative integer x and an index i\"?\\nSelect \"any\"? random?\\nrandom only for x or random for x and i?\\nHow can we choose random i if we need to access nums[i]?\\nWhat does it mean \"after applying the operation any number of times.\"?\\nLike infinite number of times? When algo should stop?"
                    },
                    {
                        "username": "escaroda",
                        "content": "Consider this testcase:\\n`[16,10,18,0,0,24,2,72,16,82,74,0,24,26,24,90]` Answer `90`\\n\\nBut I get `127`\\n\\nLet me sort this array. It shouldn\\'t affect the final result but will be easier to understand\\n`[0, 0, 0, 2, 10, 16, 16, 18, 24, 24, 24, 26, 72, 74, 82, 90]`\\n\\nI could transform it into\\n`[0, 0, 0, 1, 2, 4, 8, 16, 0, 0, 0, 0, 32, 64, 0, 0]`\\n\\nsince `nums[i] & (nums[i] ^ x)` can give us any number between `0` and `nums[i]` **(update: this was a wrong assumption, read comments)**\\n\\nAnd it is `127` if we XOR each element.\\nWhat do I miss?\\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "phalkey89",
                        "content": "\nclass Solution\n{\n    public:\n        int maximumXOR(vector<int> &nums)\n        {\n            int ans=0;\n            for(int i=0;i<31;i++)\n            {\n                int c=0;\n                int bit=1<<i;\n                for(int a:nums)\n                {\n                    c = (a & bit)==c?0:1;\n                }\n                if(c==1)\n                  {\n                      ans = ans+ bit;\n                  }\n                  \n            }\n            return ans;\n        }\n};\n\n\nwhy this code fails when submission ?? "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "is it just me aur some one thought about solving this using this dp \\nwe just have to form a subsequence which has maximum value when we xor  its elements .As we can as many elements to 0 as we want so we just have to find those elements whose XOR is maximum"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question was so good!! Gradually building to the answer and making it one liner got me feeling like \"the feeling you get after watching a good movie , or listening to a great song\" (bliss ?). "
                    },
                    {
                        "username": "tusharsharma2020",
                        "content": "I wanna know why only bitwise or is working, why nit everyone is considering XOR ? \\n"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You just have to look at least one SET bit in  Nth bit among all given  number, if you found ,add the place value of Nth bit in answer.\\nPLACE VALUE IS :\\nIn Decimal number System place value for second bit is 10. but in binary number system place value of second bit is 2. Similarly for others bit as well."
                    },
                    {
                        "username": "vikas58616",
                        "content": "what is the negative numbers are also allowed in the array should we consider the 31st bit or not ?\\n"
                    }
                ]
            },
            {
                "id": 1576940,
                "content": [
                    {
                        "username": "District_12",
                        "content": "What does it mean \"In one operation,\"?\\nWhat does it mean \"select any non-negative integer x and an index i\"?\\nSelect \"any\"? random?\\nrandom only for x or random for x and i?\\nHow can we choose random i if we need to access nums[i]?\\nWhat does it mean \"after applying the operation any number of times.\"?\\nLike infinite number of times? When algo should stop?"
                    },
                    {
                        "username": "escaroda",
                        "content": "Consider this testcase:\\n`[16,10,18,0,0,24,2,72,16,82,74,0,24,26,24,90]` Answer `90`\\n\\nBut I get `127`\\n\\nLet me sort this array. It shouldn\\'t affect the final result but will be easier to understand\\n`[0, 0, 0, 2, 10, 16, 16, 18, 24, 24, 24, 26, 72, 74, 82, 90]`\\n\\nI could transform it into\\n`[0, 0, 0, 1, 2, 4, 8, 16, 0, 0, 0, 0, 32, 64, 0, 0]`\\n\\nsince `nums[i] & (nums[i] ^ x)` can give us any number between `0` and `nums[i]` **(update: this was a wrong assumption, read comments)**\\n\\nAnd it is `127` if we XOR each element.\\nWhat do I miss?\\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "phalkey89",
                        "content": "\nclass Solution\n{\n    public:\n        int maximumXOR(vector<int> &nums)\n        {\n            int ans=0;\n            for(int i=0;i<31;i++)\n            {\n                int c=0;\n                int bit=1<<i;\n                for(int a:nums)\n                {\n                    c = (a & bit)==c?0:1;\n                }\n                if(c==1)\n                  {\n                      ans = ans+ bit;\n                  }\n                  \n            }\n            return ans;\n        }\n};\n\n\nwhy this code fails when submission ?? "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "is it just me aur some one thought about solving this using this dp \\nwe just have to form a subsequence which has maximum value when we xor  its elements .As we can as many elements to 0 as we want so we just have to find those elements whose XOR is maximum"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question was so good!! Gradually building to the answer and making it one liner got me feeling like \"the feeling you get after watching a good movie , or listening to a great song\" (bliss ?). "
                    },
                    {
                        "username": "tusharsharma2020",
                        "content": "I wanna know why only bitwise or is working, why nit everyone is considering XOR ? \\n"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You just have to look at least one SET bit in  Nth bit among all given  number, if you found ,add the place value of Nth bit in answer.\\nPLACE VALUE IS :\\nIn Decimal number System place value for second bit is 10. but in binary number system place value of second bit is 2. Similarly for others bit as well."
                    },
                    {
                        "username": "vikas58616",
                        "content": "what is the negative numbers are also allowed in the array should we consider the 31st bit or not ?\\n"
                    }
                ]
            },
            {
                "id": 1686796,
                "content": [
                    {
                        "username": "District_12",
                        "content": "What does it mean \"In one operation,\"?\\nWhat does it mean \"select any non-negative integer x and an index i\"?\\nSelect \"any\"? random?\\nrandom only for x or random for x and i?\\nHow can we choose random i if we need to access nums[i]?\\nWhat does it mean \"after applying the operation any number of times.\"?\\nLike infinite number of times? When algo should stop?"
                    },
                    {
                        "username": "escaroda",
                        "content": "Consider this testcase:\\n`[16,10,18,0,0,24,2,72,16,82,74,0,24,26,24,90]` Answer `90`\\n\\nBut I get `127`\\n\\nLet me sort this array. It shouldn\\'t affect the final result but will be easier to understand\\n`[0, 0, 0, 2, 10, 16, 16, 18, 24, 24, 24, 26, 72, 74, 82, 90]`\\n\\nI could transform it into\\n`[0, 0, 0, 1, 2, 4, 8, 16, 0, 0, 0, 0, 32, 64, 0, 0]`\\n\\nsince `nums[i] & (nums[i] ^ x)` can give us any number between `0` and `nums[i]` **(update: this was a wrong assumption, read comments)**\\n\\nAnd it is `127` if we XOR each element.\\nWhat do I miss?\\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "phalkey89",
                        "content": "\nclass Solution\n{\n    public:\n        int maximumXOR(vector<int> &nums)\n        {\n            int ans=0;\n            for(int i=0;i<31;i++)\n            {\n                int c=0;\n                int bit=1<<i;\n                for(int a:nums)\n                {\n                    c = (a & bit)==c?0:1;\n                }\n                if(c==1)\n                  {\n                      ans = ans+ bit;\n                  }\n                  \n            }\n            return ans;\n        }\n};\n\n\nwhy this code fails when submission ?? "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "is it just me aur some one thought about solving this using this dp \\nwe just have to form a subsequence which has maximum value when we xor  its elements .As we can as many elements to 0 as we want so we just have to find those elements whose XOR is maximum"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question was so good!! Gradually building to the answer and making it one liner got me feeling like \"the feeling you get after watching a good movie , or listening to a great song\" (bliss ?). "
                    },
                    {
                        "username": "tusharsharma2020",
                        "content": "I wanna know why only bitwise or is working, why nit everyone is considering XOR ? \\n"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You just have to look at least one SET bit in  Nth bit among all given  number, if you found ,add the place value of Nth bit in answer.\\nPLACE VALUE IS :\\nIn Decimal number System place value for second bit is 10. but in binary number system place value of second bit is 2. Similarly for others bit as well."
                    },
                    {
                        "username": "vikas58616",
                        "content": "what is the negative numbers are also allowed in the array should we consider the 31st bit or not ?\\n"
                    }
                ]
            },
            {
                "id": 2003397,
                "content": [
                    {
                        "username": "District_12",
                        "content": "What does it mean \"In one operation,\"?\\nWhat does it mean \"select any non-negative integer x and an index i\"?\\nSelect \"any\"? random?\\nrandom only for x or random for x and i?\\nHow can we choose random i if we need to access nums[i]?\\nWhat does it mean \"after applying the operation any number of times.\"?\\nLike infinite number of times? When algo should stop?"
                    },
                    {
                        "username": "escaroda",
                        "content": "Consider this testcase:\\n`[16,10,18,0,0,24,2,72,16,82,74,0,24,26,24,90]` Answer `90`\\n\\nBut I get `127`\\n\\nLet me sort this array. It shouldn\\'t affect the final result but will be easier to understand\\n`[0, 0, 0, 2, 10, 16, 16, 18, 24, 24, 24, 26, 72, 74, 82, 90]`\\n\\nI could transform it into\\n`[0, 0, 0, 1, 2, 4, 8, 16, 0, 0, 0, 0, 32, 64, 0, 0]`\\n\\nsince `nums[i] & (nums[i] ^ x)` can give us any number between `0` and `nums[i]` **(update: this was a wrong assumption, read comments)**\\n\\nAnd it is `127` if we XOR each element.\\nWhat do I miss?\\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "phalkey89",
                        "content": "\nclass Solution\n{\n    public:\n        int maximumXOR(vector<int> &nums)\n        {\n            int ans=0;\n            for(int i=0;i<31;i++)\n            {\n                int c=0;\n                int bit=1<<i;\n                for(int a:nums)\n                {\n                    c = (a & bit)==c?0:1;\n                }\n                if(c==1)\n                  {\n                      ans = ans+ bit;\n                  }\n                  \n            }\n            return ans;\n        }\n};\n\n\nwhy this code fails when submission ?? "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "is it just me aur some one thought about solving this using this dp \\nwe just have to form a subsequence which has maximum value when we xor  its elements .As we can as many elements to 0 as we want so we just have to find those elements whose XOR is maximum"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question was so good!! Gradually building to the answer and making it one liner got me feeling like \"the feeling you get after watching a good movie , or listening to a great song\" (bliss ?). "
                    },
                    {
                        "username": "tusharsharma2020",
                        "content": "I wanna know why only bitwise or is working, why nit everyone is considering XOR ? \\n"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You just have to look at least one SET bit in  Nth bit among all given  number, if you found ,add the place value of Nth bit in answer.\\nPLACE VALUE IS :\\nIn Decimal number System place value for second bit is 10. but in binary number system place value of second bit is 2. Similarly for others bit as well."
                    },
                    {
                        "username": "vikas58616",
                        "content": "what is the negative numbers are also allowed in the array should we consider the 31st bit or not ?\\n"
                    }
                ]
            },
            {
                "id": 1954862,
                "content": [
                    {
                        "username": "District_12",
                        "content": "What does it mean \"In one operation,\"?\\nWhat does it mean \"select any non-negative integer x and an index i\"?\\nSelect \"any\"? random?\\nrandom only for x or random for x and i?\\nHow can we choose random i if we need to access nums[i]?\\nWhat does it mean \"after applying the operation any number of times.\"?\\nLike infinite number of times? When algo should stop?"
                    },
                    {
                        "username": "escaroda",
                        "content": "Consider this testcase:\\n`[16,10,18,0,0,24,2,72,16,82,74,0,24,26,24,90]` Answer `90`\\n\\nBut I get `127`\\n\\nLet me sort this array. It shouldn\\'t affect the final result but will be easier to understand\\n`[0, 0, 0, 2, 10, 16, 16, 18, 24, 24, 24, 26, 72, 74, 82, 90]`\\n\\nI could transform it into\\n`[0, 0, 0, 1, 2, 4, 8, 16, 0, 0, 0, 0, 32, 64, 0, 0]`\\n\\nsince `nums[i] & (nums[i] ^ x)` can give us any number between `0` and `nums[i]` **(update: this was a wrong assumption, read comments)**\\n\\nAnd it is `127` if we XOR each element.\\nWhat do I miss?\\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "phalkey89",
                        "content": "\nclass Solution\n{\n    public:\n        int maximumXOR(vector<int> &nums)\n        {\n            int ans=0;\n            for(int i=0;i<31;i++)\n            {\n                int c=0;\n                int bit=1<<i;\n                for(int a:nums)\n                {\n                    c = (a & bit)==c?0:1;\n                }\n                if(c==1)\n                  {\n                      ans = ans+ bit;\n                  }\n                  \n            }\n            return ans;\n        }\n};\n\n\nwhy this code fails when submission ?? "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "is it just me aur some one thought about solving this using this dp \\nwe just have to form a subsequence which has maximum value when we xor  its elements .As we can as many elements to 0 as we want so we just have to find those elements whose XOR is maximum"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question was so good!! Gradually building to the answer and making it one liner got me feeling like \"the feeling you get after watching a good movie , or listening to a great song\" (bliss ?). "
                    },
                    {
                        "username": "tusharsharma2020",
                        "content": "I wanna know why only bitwise or is working, why nit everyone is considering XOR ? \\n"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You just have to look at least one SET bit in  Nth bit among all given  number, if you found ,add the place value of Nth bit in answer.\\nPLACE VALUE IS :\\nIn Decimal number System place value for second bit is 10. but in binary number system place value of second bit is 2. Similarly for others bit as well."
                    },
                    {
                        "username": "vikas58616",
                        "content": "what is the negative numbers are also allowed in the array should we consider the 31st bit or not ?\\n"
                    }
                ]
            },
            {
                "id": 1842851,
                "content": [
                    {
                        "username": "District_12",
                        "content": "What does it mean \"In one operation,\"?\\nWhat does it mean \"select any non-negative integer x and an index i\"?\\nSelect \"any\"? random?\\nrandom only for x or random for x and i?\\nHow can we choose random i if we need to access nums[i]?\\nWhat does it mean \"after applying the operation any number of times.\"?\\nLike infinite number of times? When algo should stop?"
                    },
                    {
                        "username": "escaroda",
                        "content": "Consider this testcase:\\n`[16,10,18,0,0,24,2,72,16,82,74,0,24,26,24,90]` Answer `90`\\n\\nBut I get `127`\\n\\nLet me sort this array. It shouldn\\'t affect the final result but will be easier to understand\\n`[0, 0, 0, 2, 10, 16, 16, 18, 24, 24, 24, 26, 72, 74, 82, 90]`\\n\\nI could transform it into\\n`[0, 0, 0, 1, 2, 4, 8, 16, 0, 0, 0, 0, 32, 64, 0, 0]`\\n\\nsince `nums[i] & (nums[i] ^ x)` can give us any number between `0` and `nums[i]` **(update: this was a wrong assumption, read comments)**\\n\\nAnd it is `127` if we XOR each element.\\nWhat do I miss?\\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "phalkey89",
                        "content": "\nclass Solution\n{\n    public:\n        int maximumXOR(vector<int> &nums)\n        {\n            int ans=0;\n            for(int i=0;i<31;i++)\n            {\n                int c=0;\n                int bit=1<<i;\n                for(int a:nums)\n                {\n                    c = (a & bit)==c?0:1;\n                }\n                if(c==1)\n                  {\n                      ans = ans+ bit;\n                  }\n                  \n            }\n            return ans;\n        }\n};\n\n\nwhy this code fails when submission ?? "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "is it just me aur some one thought about solving this using this dp \\nwe just have to form a subsequence which has maximum value when we xor  its elements .As we can as many elements to 0 as we want so we just have to find those elements whose XOR is maximum"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question was so good!! Gradually building to the answer and making it one liner got me feeling like \"the feeling you get after watching a good movie , or listening to a great song\" (bliss ?). "
                    },
                    {
                        "username": "tusharsharma2020",
                        "content": "I wanna know why only bitwise or is working, why nit everyone is considering XOR ? \\n"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You just have to look at least one SET bit in  Nth bit among all given  number, if you found ,add the place value of Nth bit in answer.\\nPLACE VALUE IS :\\nIn Decimal number System place value for second bit is 10. but in binary number system place value of second bit is 2. Similarly for others bit as well."
                    },
                    {
                        "username": "vikas58616",
                        "content": "what is the negative numbers are also allowed in the array should we consider the 31st bit or not ?\\n"
                    }
                ]
            },
            {
                "id": 1818175,
                "content": [
                    {
                        "username": "District_12",
                        "content": "What does it mean \"In one operation,\"?\\nWhat does it mean \"select any non-negative integer x and an index i\"?\\nSelect \"any\"? random?\\nrandom only for x or random for x and i?\\nHow can we choose random i if we need to access nums[i]?\\nWhat does it mean \"after applying the operation any number of times.\"?\\nLike infinite number of times? When algo should stop?"
                    },
                    {
                        "username": "escaroda",
                        "content": "Consider this testcase:\\n`[16,10,18,0,0,24,2,72,16,82,74,0,24,26,24,90]` Answer `90`\\n\\nBut I get `127`\\n\\nLet me sort this array. It shouldn\\'t affect the final result but will be easier to understand\\n`[0, 0, 0, 2, 10, 16, 16, 18, 24, 24, 24, 26, 72, 74, 82, 90]`\\n\\nI could transform it into\\n`[0, 0, 0, 1, 2, 4, 8, 16, 0, 0, 0, 0, 32, 64, 0, 0]`\\n\\nsince `nums[i] & (nums[i] ^ x)` can give us any number between `0` and `nums[i]` **(update: this was a wrong assumption, read comments)**\\n\\nAnd it is `127` if we XOR each element.\\nWhat do I miss?\\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "phalkey89",
                        "content": "\nclass Solution\n{\n    public:\n        int maximumXOR(vector<int> &nums)\n        {\n            int ans=0;\n            for(int i=0;i<31;i++)\n            {\n                int c=0;\n                int bit=1<<i;\n                for(int a:nums)\n                {\n                    c = (a & bit)==c?0:1;\n                }\n                if(c==1)\n                  {\n                      ans = ans+ bit;\n                  }\n                  \n            }\n            return ans;\n        }\n};\n\n\nwhy this code fails when submission ?? "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "is it just me aur some one thought about solving this using this dp \\nwe just have to form a subsequence which has maximum value when we xor  its elements .As we can as many elements to 0 as we want so we just have to find those elements whose XOR is maximum"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question was so good!! Gradually building to the answer and making it one liner got me feeling like \"the feeling you get after watching a good movie , or listening to a great song\" (bliss ?). "
                    },
                    {
                        "username": "tusharsharma2020",
                        "content": "I wanna know why only bitwise or is working, why nit everyone is considering XOR ? \\n"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You just have to look at least one SET bit in  Nth bit among all given  number, if you found ,add the place value of Nth bit in answer.\\nPLACE VALUE IS :\\nIn Decimal number System place value for second bit is 10. but in binary number system place value of second bit is 2. Similarly for others bit as well."
                    },
                    {
                        "username": "vikas58616",
                        "content": "what is the negative numbers are also allowed in the array should we consider the 31st bit or not ?\\n"
                    }
                ]
            },
            {
                "id": 1722630,
                "content": [
                    {
                        "username": "District_12",
                        "content": "What does it mean \"In one operation,\"?\\nWhat does it mean \"select any non-negative integer x and an index i\"?\\nSelect \"any\"? random?\\nrandom only for x or random for x and i?\\nHow can we choose random i if we need to access nums[i]?\\nWhat does it mean \"after applying the operation any number of times.\"?\\nLike infinite number of times? When algo should stop?"
                    },
                    {
                        "username": "escaroda",
                        "content": "Consider this testcase:\\n`[16,10,18,0,0,24,2,72,16,82,74,0,24,26,24,90]` Answer `90`\\n\\nBut I get `127`\\n\\nLet me sort this array. It shouldn\\'t affect the final result but will be easier to understand\\n`[0, 0, 0, 2, 10, 16, 16, 18, 24, 24, 24, 26, 72, 74, 82, 90]`\\n\\nI could transform it into\\n`[0, 0, 0, 1, 2, 4, 8, 16, 0, 0, 0, 0, 32, 64, 0, 0]`\\n\\nsince `nums[i] & (nums[i] ^ x)` can give us any number between `0` and `nums[i]` **(update: this was a wrong assumption, read comments)**\\n\\nAnd it is `127` if we XOR each element.\\nWhat do I miss?\\n\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA5One Liner\\nhttps://leetcode.com/problems/maximum-xor-after-operations/solutions/2348583/one-liner/"
                    },
                    {
                        "username": "phalkey89",
                        "content": "\nclass Solution\n{\n    public:\n        int maximumXOR(vector<int> &nums)\n        {\n            int ans=0;\n            for(int i=0;i<31;i++)\n            {\n                int c=0;\n                int bit=1<<i;\n                for(int a:nums)\n                {\n                    c = (a & bit)==c?0:1;\n                }\n                if(c==1)\n                  {\n                      ans = ans+ bit;\n                  }\n                  \n            }\n            return ans;\n        }\n};\n\n\nwhy this code fails when submission ?? "
                    },
                    {
                        "username": "himanshupanwar123",
                        "content": "is it just me aur some one thought about solving this using this dp \\nwe just have to form a subsequence which has maximum value when we xor  its elements .As we can as many elements to 0 as we want so we just have to find those elements whose XOR is maximum"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question was so good!! Gradually building to the answer and making it one liner got me feeling like \"the feeling you get after watching a good movie , or listening to a great song\" (bliss ?). "
                    },
                    {
                        "username": "tusharsharma2020",
                        "content": "I wanna know why only bitwise or is working, why nit everyone is considering XOR ? \\n"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "You just have to look at least one SET bit in  Nth bit among all given  number, if you found ,add the place value of Nth bit in answer.\\nPLACE VALUE IS :\\nIn Decimal number System place value for second bit is 10. but in binary number system place value of second bit is 2. Similarly for others bit as well."
                    },
                    {
                        "username": "vikas58616",
                        "content": "what is the negative numbers are also allowed in the array should we consider the 31st bit or not ?\\n"
                    }
                ]
            }
        ]
    }
]