[
    {
        "title": "Maximize Sum Of Array After K Negations",
        "question_content": "Given an integer array nums and an integer k, modify the array in the following way:\n\tchoose an index i and replace nums[i] with -nums[i].\nYou should apply this process exactly k times. You may choose the same index i multiple times.\nReturn the largest possible sum of the array after modifying it in this way.\n&nbsp;\nExample 1:\nInput: nums = [4,2,3], k = 1\nOutput: 5\nExplanation: Choose index 1 and nums becomes [4,-2,3].\nExample 2:\nInput: nums = [3,-1,0,2], k = 3\nOutput: 6\nExplanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].\nExample 3:\nInput: nums = [2,-3,-1,5,-4], k = 2\nOutput: 13\nExplanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].\n&nbsp;\nConstraints:\n\t1 <= nums.length <= 104\n\t-100 <= nums[i] <= 100\n\t1 <= k <= 104",
        "solutions": [
            {
                "id": 3540706,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nlong long getSum(vector<int> negate, vector<int>positive)\\n{\\n    long long sum =0;\\n                for(int i=0;i<negate.size();i++)\\n            {\\n                sum+=negate[i];\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                sum+=positive[i];\\n            }\\n            return sum;\\n}\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n   vector<int>negate;\\n   vector<int>positive;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>=0)\\n        {\\n            positive.push_back(nums[i]);\\n        }\\n        else{\\n            negate.push_back(nums[i]);\\n        }\\n    }\\n    if(negate.size()>k)\\n    {\\n        sort(negate.begin(), negate.end());\\n        for(int i=0;i<k;i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        return getSum(negate, positive);\\n    } else {\\n        for(int i=0;i<negate.size();i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        int remainingcount = k-negate.size();\\n        if(remainingcount%2==0)\\n        {\\n            return getSum(negate, positive);\\n        } else {\\n        int mini = INT_MAX;\\n            for(int i=0;i<negate.size();i++)\\n            {\\n                mini = min(mini, negate[i]);\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                mini = min(mini, positive[i]);\\n            }\\ncout<<mini<<endl;\\ncout<<getSum(negate, positive)<<endl;\\n            return (getSum(negate, positive) - 2*mini);\\n        }\\n    }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums = sorted(nums)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] = -nums[i]\\n                k -= 1\\n        nums = sorted(nums)\\n        if k > 0 and k % 2 != 0: \\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nlong long getSum(vector<int> negate, vector<int>positive)\\n{\\n    long long sum =0;\\n                for(int i=0;i<negate.size();i++)\\n            {\\n                sum+=negate[i];\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                sum+=positive[i];\\n            }\\n            return sum;\\n}\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n   vector<int>negate;\\n   vector<int>positive;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>=0)\\n        {\\n            positive.push_back(nums[i]);\\n        }\\n        else{\\n            negate.push_back(nums[i]);\\n        }\\n    }\\n    if(negate.size()>k)\\n    {\\n        sort(negate.begin(), negate.end());\\n        for(int i=0;i<k;i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        return getSum(negate, positive);\\n    } else {\\n        for(int i=0;i<negate.size();i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        int remainingcount = k-negate.size();\\n        if(remainingcount%2==0)\\n        {\\n            return getSum(negate, positive);\\n        } else {\\n        int mini = INT_MAX;\\n            for(int i=0;i<negate.size();i++)\\n            {\\n                mini = min(mini, negate[i]);\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                mini = min(mini, positive[i]);\\n            }\\ncout<<mini<<endl;\\ncout<<getSum(negate, positive)<<endl;\\n            return (getSum(negate, positive) - 2*mini);\\n        }\\n    }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums = sorted(nums)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] = -nums[i]\\n                k -= 1\\n        nums = sorted(nums)\\n        if k > 0 and k % 2 != 0: \\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```\n```Java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 252254,
                "title": "java-c-python-sort",
                "content": "## **Explanation**\\n@codePower:\\nIn case someone needs an explanation:\\n1- sort the numbers in ascending order\\n2- flip all the negative numbers, as long as k > 0\\n3- find the sum of the new array (with flipped numbers if any) and keep track of the minimum number\\n4- Now for the return statement\\n\\n`res` is the total sum of the new array\\n`K % 2` check if the remaining `K` is odd.\\n\\nBecause if it\\'s even, it will have no effect\\n(we will flip a number and then get it back to the original)\\n\\nIf it\\'s odd,\\nflip the minimum number and remove twice its value from the result\\n(twice because we already added it as positive in our sum operation)\\n<br>\\n\\n## **Complexity**\\nTime `O(NlogN)` for sorting.\\nSpace `O(1)` extra space, in-place sort\\n\\nTime can be easily improved to `O(N)`,\\nby quick selecting the `k`th negative.\\n<br>\\n\\n**Java**\\n```java\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        for (int i = 0; K > 0 && i < A.length && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        int res = 0, min = Integer.MAX_VALUE;\\n        for (int a : A) {\\n            res += a;\\n            min = Math.min(min, a);\\n        }\\n        return res - (K % 2) * min * 2;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        for (int i = 0; K > 0 && i < A.size() && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        return accumulate(A.begin(), A.end(), 0) - (K%2) * *min_element(A.begin(), A.end()) * 2;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def largestSumAfterKNegations(self, A, K):\\n        A.sort()\\n        i = 0\\n        while i < len(A) and i < K and A[i] < 0:\\n            A[i] = -A[i]\\n            i += 1\\n        return sum(A) - (K - i) % 2 * min(A) * 2\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        for (int i = 0; K > 0 && i < A.length && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        int res = 0, min = Integer.MAX_VALUE;\\n        for (int a : A) {\\n            res += a;\\n            min = Math.min(min, a);\\n        }\\n        return res - (K % 2) * min * 2;\\n    }\\n```\n```cpp\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        for (int i = 0; K > 0 && i < A.size() && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        return accumulate(A.begin(), A.end(), 0) - (K%2) * *min_element(A.begin(), A.end()) * 2;\\n    }\\n```\n```py\\n    def largestSumAfterKNegations(self, A, K):\\n        A.sort()\\n        i = 0\\n        while i < len(A) and i < K and A[i] < 0:\\n            A[i] = -A[i]\\n            i += 1\\n        return sum(A) - (K - i) % 2 * min(A) * 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 252228,
                "title": "a-very-simple-java-solution",
                "content": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        \\n        for(int x: A) pq.add(x);\\n        while( K--  > 0) pq.add(-pq.poll());\\n  \\n        int sum  = 0;\\n        for(int i = 0; i < A.length; i++){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        \\n        for(int x: A) pq.add(x);\\n        while( K--  > 0) pq.add(-pq.poll());\\n  \\n        int sum  = 0;\\n        for(int i = 0; i < A.length; i++){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252849,
                "title": "c-java-o-n-o-1",
                "content": "Since the ```A[i]``` is limited to [-100, 100], we can use an fixed-size array ```cnt``` to count occurrences. Bucket sort (or, more precise, countint sort), in other words :)\\n\\nThen, as we process numbers ```[-100, 100]```, we flip the negative numbers by moving count from ```cnt[i + 100]``` to ```cnt[-i + 100]```. This guaranties that, if ```K > 0``` after processing all negative numbers, the first positive number will have the smallest absolute value.\\n\\nTherefore, when we encounter the first positive number, and our ```K % 2 == 1```, we negate one occurrence of that number.\\n```\\nint largestSumAfterKNegations(vector<int>& A, int K) {\\n  int cnt[201] = {}, j = -100;\\n  for (auto i : A) ++cnt[i + 100];\\n  for (auto i = -100; i <= 100 && K; ++i) {\\n    if (cnt[i + 100]) {\\n      auto k = i < 0 ? min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  return accumulate(begin(cnt), end(cnt), 0, [&](int s, int cnt) { return s + cnt * j++; });\\n}\\n```\\nJava version:\\n```\\npublic int largestSumAfterKNegations(int[] A, int K) {\\n  int[] cnt = new int[201];\\n  int res = 0;\\n  for (int i : A) ++cnt[i + 100];\\n  for (int i = -100; i <= 100 && K > 0; ++i) {\\n    if (cnt[i + 100] > 0) {\\n      int k = i < 0 ? Math.min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  for (int i = -100; i <= 100; ++i) res += i * cnt[i + 100];\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```A[i]```\n```cnt```\n```[-100, 100]```\n```cnt[i + 100]```\n```cnt[-i + 100]```\n```K > 0```\n```K % 2 == 1```\n```\\nint largestSumAfterKNegations(vector<int>& A, int K) {\\n  int cnt[201] = {}, j = -100;\\n  for (auto i : A) ++cnt[i + 100];\\n  for (auto i = -100; i <= 100 && K; ++i) {\\n    if (cnt[i + 100]) {\\n      auto k = i < 0 ? min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  return accumulate(begin(cnt), end(cnt), 0, [&](int s, int cnt) { return s + cnt * j++; });\\n}\\n```\n```\\npublic int largestSumAfterKNegations(int[] A, int K) {\\n  int[] cnt = new int[201];\\n  int res = 0;\\n  for (int i : A) ++cnt[i + 100];\\n  for (int i = -100; i <= 100 && K > 0; ++i) {\\n    if (cnt[i + 100] > 0) {\\n      int k = i < 0 ? Math.min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  for (int i = -100; i <= 100; ++i) res += i * cnt[i + 100];\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252596,
                "title": "python-straightforward-self-explanatory-concise",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696962,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while (K--) {\\n            int x = pq.top();\\n            pq.pop();\\n\\n            pq.push(-1 * x);\\n        }\\n        int res = 0;\\n        while (!pq.empty()) {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while (K--) {\\n            int x = pq.top();\\n            pq.pop();\\n\\n            pq.push(-1 * x);\\n        }\\n        int res = 0;\\n        while (!pq.empty()) {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628859,
                "title": "min-heap-o-n-k-log-n-time-o-1-space",
                "content": "Hi LeetCoders \\uD83D\\uDC4B\\nHere is my simple and clean solution to this problem with use of min-heap.\\n\\n**Code:**\\n```\\nfrom heapq import heapify, heapreplace\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        while k and nums[0] < 0:\\n            heapreplace(nums, -nums[0])\\n            k -= 1\\n        if k % 2:\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```\\n\\n**Idea explanation:**\\n* negate negative numbers as many as you can\\n* if ```k % 2 == 1``` negate the smallest element in the heap\\n\\n**Notes:**\\nAvoid using ```heappush + heappop``` because it takes ```O(2 * log (n))``` time, use ```heapreplace``` instead and pay just ```O(log (n))```. Isn\\'t that a great deal?\\n\\n**Algorithm complexity:**\\n*n = len(nums)*\\n*Time complexity: O(n + k * log (n))*\\n*Space complexity: O(1)*\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I hope you learned something and wish you an enjoyable time on LeetCode. \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heapreplace\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        while k and nums[0] < 0:\\n            heapreplace(nums, -nums[0])\\n            k -= 1\\n        if k % 2:\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```\n```k % 2 == 1```\n```heappush + heappop```\n```O(2 * log (n))```\n```heapreplace```\n```O(log (n))```",
                "codeTag": "Java"
            },
            {
                "id": 301380,
                "title": "java-simple-greedy-solution-explained-beats-100",
                "content": "The intution is - \\n1. Sort the array.\\n2. Check if first element of the array is positive.\\n\\ti. If K is even, don\\'t modify anything.\\n\\tii. Else, modify the lowest element.\\n3. Else, mark all -ve elements positive for a given K.\\n4. If K after operations is not even then, mark the lowest element -ve.\\n5. Sum up and return.\\n\\n\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        if (A[0] >= 0 && K % 2 != 0) {\\n            A[0] = - A[0];\\n        } else if (A[0] < 0 ) { //&& K % 2 == 0) {\\n            int change = 0;\\n            while (K > 0 && A[change] < 0 && change < A.length) {\\n                A[change] = - A[change++];\\n                K--;\\n            }\\n            if (K % 2 != 0) {\\n                int index = A[change] < A[change - 1] ? change : change - 1;\\n                A[index] = - A[index];\\n            }\\n        }\\n        for (int val : A) sum += val;\\n        return sum;\\n    }\\n}\\n```\\n\\nIf you liked the post please do upvote and any suggestions are most welcome.\\nPS: I see a few people posting solution with PriorityQueue, which is awesome, however, the question says \\'modify the array\\'.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        if (A[0] >= 0 && K % 2 != 0) {\\n            A[0] = - A[0];\\n        } else if (A[0] < 0 ) { //&& K % 2 == 0) {\\n            int change = 0;\\n            while (K > 0 && A[change] < 0 && change < A.length) {\\n                A[change] = - A[change++];\\n                K--;\\n            }\\n            if (K % 2 != 0) {\\n                int index = A[change] < A[change - 1] ? change : change - 1;\\n                A[index] = - A[index];\\n            }\\n        }\\n        for (int val : A) sum += val;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895079,
                "title": "c-solution-100-faster-memory-efficient",
                "content": "A pure greedy question.\\nAlgorithm\\n1. Sort the vector\\n2. Run a loop until looping variable reaches to size of vector or K.\\n\\t* If the vector element is found greater than or equal to 0, terminate the loop\\n\\t* If the vector element is found less than 0 then negate its value.\\n3. Sort the value again \\n4. Check if looping variable is less than K then calculate its difference. \\n5. If the difference is not divisible by 2 then negate A[0].\\n\\n\\nNote:\\n1. Sorting of vector in step 3 is required to arrange back the numbers to ascending order as in previous loop the negative number was made positive too.\\n2. Step 5 is checked because we can negate a number as many times possible. So we will negate the smallest number only to get maximum result.(Also twice negation of a number results to same number. So the difference is calculated and checked for its divisibility by 2.)\\n3. Sorting and step 5 are showing the greedy nature of the problem.\\n\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        int i, t=0, n=A.size();\\n        \\n        for(i=0; i < min(n, K); i++) {\\n            if(A[t]>=0) break;\\n            \\n            else {\\n                A[t]=-A[t];\\n                t++;\\n            }\\n        }\\n        \\n        sort(A.begin(), A.end());\\n        if(i<K) {\\n            if((K-i)%2) {\\n                A[0]=-A[0];\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(i=0; i<A.size(); i++) {\\n            sum += A[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        int i, t=0, n=A.size();\\n        \\n        for(i=0; i < min(n, K); i++) {\\n            if(A[t]>=0) break;\\n            \\n            else {\\n                A[t]=-A[t];\\n                t++;\\n            }\\n        }\\n        \\n        sort(A.begin(), A.end());\\n        if(i<K) {\\n            if((K-i)%2) {\\n                A[0]=-A[0];\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(i=0; i<A.size(); i++) {\\n            sum += A[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278596,
                "title": "heapq-python",
                "content": "```\\nimport heapq\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        heapq.heapify(A)\\n        while K:\\n            heapq.heapreplace(A, -A[0])\\n            K -= 1\\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        heapq.heapify(A)\\n        while K:\\n            heapq.heapreplace(A, -A[0])\\n            K -= 1\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688733,
                "title": "python-3-min-heap-few-lines-easy-to-read-solution",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, min_heap: List[int], K: int) -> int:\\n        heapify(min_heap)\\n        while K > 0:\\n            heappush(min_heap , - (heappop(min_heap)))            \\n            K -= 1\\n        return sum(min_heap)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, min_heap: List[int], K: int) -> int:\\n        heapify(min_heap)\\n        while K > 0:\\n            heappush(min_heap , - (heappop(min_heap)))            \\n            K -= 1\\n        return sum(min_heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157105,
                "title": "super-simple-c-o-nlog-n-solution-w-explanation",
                "content": "# Intuition\\nSorting is your best friend here. That way we can make as many negative values as possible become positive (maximizing the final sum).\\n\\nThe other key detail to notice is that if every element is already positive, changing the sign of any element twice reduces `k` by $$2$$ without reducing the final sum.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Sort the input\\n2. Loop through as many negatives elements as possible, `k` permitting\\n3. Lastly check if `k` is odd. If it is, then sort the array again and negate the first (a.k.a. smallest) element\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        while(i<nums.size() && nums[i]<0 && k>0)\\n        {\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        if(k%2 == 1)\\n        {\\n            sort(nums.begin(),nums.end());\\n            nums[0] *= -1;\\n        }\\n        int sum = 0;\\n        for(int n : nums)\\n        {\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        while(i<nums.size() && nums[i]<0 && k>0)\\n        {\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        if(k%2 == 1)\\n        {\\n            sort(nums.begin(),nums.end());\\n            nums[0] *= -1;\\n        }\\n        int sum = 0;\\n        for(int n : nums)\\n        {\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808062,
                "title": "easy-to-understand-apprach-without-cases",
                "content": "Basic idea is to sort the array based on their absolute value and then start taking ones having greater absolute value. If we encouter a negative element, we can use one negation to negate it and add it\\'s absolute value, otherwise we have no other option, we have to take it\\'s original value. In the last, we will check if we have some K left i.e. we have to negate more elements. Most optimal choice here is to negate the minimum absolute value element. If K is even, it will not have any effect otherwise we have to subtract it\\'s *absolute value* twice from our sum as we have taken it once before also.\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        int n = A.size();\\n        auto cmp = [](int a, int b) {\\n            return abs(a) > abs(b);\\n        };\\n        \\n        sort(A.begin(), A.end(), cmp);\\n        int sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(A[i] < 0 && K > 0) {\\n                sum += -A[i];\\n                K--;\\n            }\\n            else {\\n                sum += A[i];\\n            }\\n        }\\n        \\n        if(K&1) {\\n            sum -= 2*(abs(A[n-1]));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        int n = A.size();\\n        auto cmp = [](int a, int b) {\\n            return abs(a) > abs(b);\\n        };\\n        \\n        sort(A.begin(), A.end(), cmp);\\n        int sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(A[i] < 0 && K > 0) {\\n                sum += -A[i];\\n                K--;\\n            }\\n            else {\\n                sum += A[i];\\n            }\\n        }\\n        \\n        if(K&1) {\\n            sum -= 2*(abs(A[n-1]));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254652,
                "title": "beat-94-56-with-explain-o-nlgn",
                "content": "Sort the array first.\\n\\nThe negation rules are quite simple\\uFF1A\\n\\n1. execute negation for K times\\uFF0Cso use a for loop\\n2. after negation, if the next number (if has) is smaller, the next number is next to negation (if still in for loop). Here we use a greedy strategy. If the next number is non-negative and smaller than the current one, negation it will result in less sum loss(for example current is 4, and next is 1), if the next number is negative and smaller than the current one, negation it will result in more sum (for example current is 4 and next is -3). \\n\\nAfter that , compute the sum.\\n\\n    class Solution {\\n        public int largestSumAfterKNegations(int[] A, int K) {\\n            Arrays.sort(A);\\n            int idx = 0;\\n            for (int i = 0; i < K; ++i) {\\n                A[idx] = -A[idx];\\n                if (idx + 1 < A.length) {\\n                    if (A[idx + 1] < A[idx]) idx += 1;\\n                }\\n            }\\n            int sum = 0;\\n            for (int i = 0; i < A.length; ++i) sum += A[i];\\n            return sum;\\n        }\\n    }\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n        public int largestSumAfterKNegations(int[] A, int K) {\\n            Arrays.sort(A);\\n            int idx = 0;\\n            for (int i = 0; i < K; ++i) {\\n                A[idx] = -A[idx];\\n                if (idx + 1 < A.length) {\\n                    if (A[idx + 1] < A[idx]) idx += 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 384970,
                "title": "python-5-lines-very-easy-solution",
                "content": "```python\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K):\\n\\t\\tfor _ in range(K):\\n            target = min(A)\\n            A.remove(target)\\n            A.append(-target)\\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K):\\n\\t\\tfor _ in range(K):\\n            target = min(A)\\n            A.remove(target)\\n            A.append(-target)\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776207,
                "title": "simple-java-solution-stream-api",
                "content": "```\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n\\n        var minHeap = new PriorityQueue<Integer>(Arrays.stream(nums).boxed().toList());\\n        \\n        IntStream.range(0, k).forEach(i -> minHeap.add(-minHeap.remove()));\\n        \\n        return minHeap.stream().reduce(0, (intermediateResult, num) -> intermediateResult + num);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n\\n        var minHeap = new PriorityQueue<Integer>(Arrays.stream(nums).boxed().toList());\\n        \\n        IntStream.range(0, k).forEach(i -> minHeap.add(-minHeap.remove()));\\n        \\n        return minHeap.stream().reduce(0, (intermediateResult, num) -> intermediateResult + num);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120243,
                "title": "weeb-explains-python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/deac20d6-f25b-4f9f-9a91-4f79bcb66724_1620122556.4046779.png)\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\t\\t\\tA.sort()\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i < len(A) and K>0:\\n\\t\\t\\t\\tif A[i] < 0: # negative value\\n\\t\\t\\t\\t\\tA[i] = A[i] * -1 # update the list, change negative to positive\\n\\t\\t\\t\\t\\tK-=1\\n\\n\\t\\t\\t\\telif A[i] > 0: # positive value\\n\\t\\t\\t\\t\\tif K % 2 == 0: # let K==2(must be even value), this means -1*-1==1 so it has no effect on sum\\n\\t\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\t\\telse: return sum(A) - 2 * min(A) # let A==[1,2,3],K=1, so equation is 6-2(1)==4, same as -1+2+3=4 after taking the minimum in the list to give the largest possible sum required in the question\\n\\n\\t\\t\\t\\telse: return sum(A) # if A[i]==0,just sum cuz 0 is neutral: 1-0==1 or 1+0==1 thus no change just sum\\n\\n\\t\\t\\t\\ti+=1\\n\\n\\t\\t\\tif K > len(A): # that means we have changed all values to positive\\n\\t\\t\\t\\tA.sort() # cuz now its the opposite let A = [-4,-2,-3], K = 8, now flipping all negatives to positives, we have a new minimum which is 2\\n\\t\\t\\t\\tif K % 2 == 0: # Here onwards is basically the same thing from before\\n\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\telse: return sum(A) - 2 * min(A)\\n\\n\\t\\t\\treturn sum(A)\\n\\nAight, time for some anime recommendations\\n# try watching ***Uzaki-chan Wants to Hang Out!***\\n# Genres: Romantic comedy, Slice of life\\n# Episodes: 12\\n\\nOverall, this anime is quite fun to watch. Although i have to warn you, this anime does contain some ecchi(perverted) elements in it, but its not extreme.\\n\\nNow go take a break and watch some anime.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/deac20d6-f25b-4f9f-9a91-4f79bcb66724_1620122556.4046779.png)\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\t\\t\\tA.sort()\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i < len(A) and K>0:\\n\\t\\t\\t\\tif A[i] < 0: # negative value\\n\\t\\t\\t\\t\\tA[i] = A[i] * -1 # update the list, change negative to positive\\n\\t\\t\\t\\t\\tK-=1\\n\\n\\t\\t\\t\\telif A[i] > 0: # positive value\\n\\t\\t\\t\\t\\tif K % 2 == 0: # let K==2(must be even value), this means -1*-1==1 so it has no effect on sum\\n\\t\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\t\\telse: return sum(A) - 2 * min(A) # let A==[1,2,3],K=1, so equation is 6-2(1)==4, same as -1+2+3=4 after taking the minimum in the list to give the largest possible sum required in the question\\n\\n\\t\\t\\t\\telse: return sum(A) # if A[i]==0,just sum cuz 0 is neutral: 1-0==1 or 1+0==1 thus no change just sum\\n\\n\\t\\t\\t\\ti+=1\\n\\n\\t\\t\\tif K > len(A): # that means we have changed all values to positive\\n\\t\\t\\t\\tA.sort() # cuz now its the opposite let A = [-4,-2,-3], K = 8, now flipping all negatives to positives, we have a new minimum which is 2\\n\\t\\t\\t\\tif K % 2 == 0: # Here onwards is basically the same thing from before\\n\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\telse: return sum(A) - 2 * min(A)\\n\\n\\t\\t\\treturn sum(A)\\n\\nAight, time for some anime recommendations\\n# try watching ***Uzaki-chan Wants to Hang Out!***\\n# Genres: Romantic comedy, Slice of life\\n# Episodes: 12\\n\\nOverall, this anime is quite fun to watch. Although i have to warn you, this anime does contain some ecchi(perverted) elements in it, but its not extreme.\\n\\nNow go take a break and watch some anime.\\n",
                "codeTag": "Java"
            },
            {
                "id": 891225,
                "title": "java-easy-to-understand",
                "content": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n\\n        for(int i = 0; i < A.length && K > 0 && A[i] < 0; i++){\\n            A[i] = -A[i];\\n            K--;\\n        }\\n\\n        Arrays.sort(A);\\n        for(int a : A) sum+= a;\\n        if(K > 0 && K % 2 == 1){\\n            sum -= A[0] * 2;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n\\n        for(int i = 0; i < A.length && K > 0 && A[i] < 0; i++){\\n            A[i] = -A[i];\\n            K--;\\n        }\\n\\n        Arrays.sort(A);\\n        for(int a : A) sum+= a;\\n        if(K > 0 && K % 2 == 1){\\n            sum -= A[0] * 2;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252410,
                "title": "o-n-k-logn-using-min-heap",
                "content": "1.build a min-heap (cost O(n));\\n2.negate the root node\\'s val then heapify the heap\\nrepeat step 2  K times\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void heapify(int arr[], int n, int i) { \\n        int smallest = i;  \\n        int l = 2*i + 1; // left = 2*i + 1 \\n        int r = 2*i + 2; // right = 2*i + 2 \\n        if (l < n && arr[l] < arr[smallest]) smallest = l; \\n        if (r < n && arr[r] < arr[smallest]) smallest = r; \\n        if (smallest != i) { \\n            swap(arr[i], arr[smallest]); \\n            heapify(arr, n, smallest); \\n        } \\n    } \\n  \\n    void helper(int arr[], int n, int K) { \\n        for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);   \\n        for(int i = 0; i < K; ++i) {\\n            arr[0] = -arr[0];\\n            heapify(arr, n, 0);\\n        }\\n    } \\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        if(A.empty()) return -1;\\n        int sum = 0;\\n        helper(A.data(), A.size(), K);\\n        for(auto &e:A) sum += e;\\n        return sum;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void heapify(int arr[], int n, int i) { \\n        int smallest = i;  \\n        int l = 2*i + 1; // left = 2*i + 1 \\n        int r = 2*i + 2; // right = 2*i + 2 \\n        if (l < n && arr[l] < arr[smallest]) smallest = l; \\n        if (r < n && arr[r] < arr[smallest]) smallest = r; \\n        if (smallest != i) { \\n            swap(arr[i], arr[smallest]); \\n            heapify(arr, n, smallest); \\n        } \\n    } \\n  \\n    void helper(int arr[], int n, int K) { \\n        for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);   \\n        for(int i = 0; i < K; ++i) {\\n            arr[0] = -arr[0];\\n            heapify(arr, n, 0);\\n        }\\n    } \\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        if(A.empty()) return -1;\\n        int sum = 0;\\n        helper(A.data(), A.size(), K);\\n        for(auto &e:A) sum += e;\\n        return sum;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637579,
                "title": "python-3-min-heap-for-negative-values-with-comments-beats-80",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # if k <= n(count of negative numbers )=> need make highest negative values positive (here using heap for this)\\n        # if k > n(count of negative numbers) and k-n is odd => need make all negative numbers positive and minVal make negative\\n        heap, res, minVal = [], 0, 101\\n\\n        for n in nums:\\n            if n > 0: res += n\\n            elif n < 0: heappush(heap, n)\\n            minVal = min(minVal, abs(n))\\n\\n        # make highest negative values positive while k opertions available\\n        while heap and k > 0:\\n            res += -heappop(heap) #add negative value\\n            k -= 1\\n        # if still exists negative value, just add them to final sum\\n        if heap:\\n            res += sum(heap)\\n        # if k > 0 and it\\'s odd need make minVal negative (if 0 exists it will be smalles value)\\n        if k % 2:\\n            res = res - 2 * minVal\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # if k <= n(count of negative numbers )=> need make highest negative values positive (here using heap for this)\\n        # if k > n(count of negative numbers) and k-n is odd => need make all negative numbers positive and minVal make negative\\n        heap, res, minVal = [], 0, 101\\n\\n        for n in nums:\\n            if n > 0: res += n\\n            elif n < 0: heappush(heap, n)\\n            minVal = min(minVal, abs(n))\\n\\n        # make highest negative values positive while k opertions available\\n        while heap and k > 0:\\n            res += -heappop(heap) #add negative value\\n            k -= 1\\n        # if still exists negative value, just add them to final sum\\n        if heap:\\n            res += sum(heap)\\n        # if k > 0 and it\\'s odd need make minVal negative (if 0 exists it will be smalles value)\\n        if k % 2:\\n            res = res - 2 * minVal\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738913,
                "title": "java-ms-solution",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }\\n                else\\n                {\\n                    count+=i;\\n                }\\n            }\\n            else if(i==0)\\n            {\\n                k=0;\\n            }\\n            else\\n            {\\n                if(k%2==0)\\n                {\\n                    count+=i;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    if(prev==0)\\n                    {\\n                        count+=(-1*i);\\n                        k=0;\\n                    }\\n                    else\\n                    {\\n                        if(prev>i || Math.abs(prev)>i)\\n                        {\\n                            count+=(-1*i);\\n                        }\\n                        else\\n                        {\\n                            count+=prev;\\n                            count+=(prev + i);\\n                        }\\n                        k=0;\\n                    }\\n                }\\n            }\\n        }\\n        if(k%2!=0)\\n        {\\n            count+=(prev + prev);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }\\n                else\\n                {\\n                    count+=i;\\n                }\\n            }\\n            else if(i==0)\\n            {\\n                k=0;\\n            }\\n            else\\n            {\\n                if(k%2==0)\\n                {\\n                    count+=i;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    if(prev==0)\\n                    {\\n                        count+=(-1*i);\\n                        k=0;\\n                    }\\n                    else\\n                    {\\n                        if(prev>i || Math.abs(prev)>i)\\n                        {\\n                            count+=(-1*i);\\n                        }\\n                        else\\n                        {\\n                            count+=prev;\\n                            count+=(prev + i);\\n                        }\\n                        k=0;\\n                    }\\n                }\\n            }\\n        }\\n        if(k%2!=0)\\n        {\\n            count+=(prev + prev);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241273,
                "title": "100-faster-sol-c",
                "content": "The time complexity of this approach is O(n+n log n).\\nhope you will find it helpful.\\n```\\nint largestSumAfterKNegations(vector<int>& nums, int k) {\\n       sort(nums.begin(),nums.end());\\n        int i=0,sum=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0&& k>0)\\n            {\\n                nums[i]*=(-1);\\n                k--;\\n            }\\n            else if(nums[i]>=0)\\n                break;\\n            i++;\\n        }\\n        if(k%2!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n                nums[0]*=(-1);           \\n        }               \\n        for(auto a:nums)\\n            sum+=a;\\n        return sum; \\n    }\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint largestSumAfterKNegations(vector<int>& nums, int k) {\\n       sort(nums.begin(),nums.end());\\n        int i=0,sum=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0&& k>0)\\n            {\\n                nums[i]*=(-1);\\n                k--;\\n            }\\n            else if(nums[i]>=0)\\n                break;\\n            i++;\\n        }\\n        if(k%2!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n                nums[0]*=(-1);           \\n        }               \\n        for(auto a:nums)\\n            sum+=a;\\n        return sum; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753580,
                "title": "c-easy-heap-solution",
                "content": "```\\nBefore discussing the problem, let me tell you something, it\\'s our coding nature \\nwhen we see to find max/min sum , element we think of sorting . But what if i tell \\nyou do sorting but in a better and optimized way, sort only those elements which \\nneed to be sorted.\\n\\nOk let\\'s talk about logic to the problem, we have to negate any index element \\nk times so array elements yields max sum. So it is clear we have to always \\nnegate smallest element, so we can use \" min Heap \" which will ensure you have \\nsmallest element always on top no matter how many insertion or deletion you make.\\n```\\n```\\nclass Solution {\\npublic:\\n    int find_sum(vector<int>&v, int k){\\n        priority_queue<int,vector<int>,greater<int>>q;       // Mean Heap\\n        for(int i=0; i<v.size(); i++)\\n            q.push(v[i]);\\n        while(k){                        // Negate k times ( min element will always be on top )\\n            int res = -q.top();\\n            q.pop();\\n            q.push(res);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n        return sum;\\n    }\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = find_sum(nums,k);\\n        return sum;\\n    }\\n};\\n```\\n```\\nLet me tell you a secret, if question is based on array and you feel there is a need of sorting always think of heap solution as a possibility.\\n```\\nIf you liked my solution please upvote to motivate me. Happy Coding :)\\n",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nBefore discussing the problem, let me tell you something, it\\'s our coding nature \\nwhen we see to find max/min sum , element we think of sorting . But what if i tell \\nyou do sorting but in a better and optimized way, sort only those elements which \\nneed to be sorted.\\n\\nOk let\\'s talk about logic to the problem, we have to negate any index element \\nk times so array elements yields max sum. So it is clear we have to always \\nnegate smallest element, so we can use \" min Heap \" which will ensure you have \\nsmallest element always on top no matter how many insertion or deletion you make.\\n```\n```\\nclass Solution {\\npublic:\\n    int find_sum(vector<int>&v, int k){\\n        priority_queue<int,vector<int>,greater<int>>q;       // Mean Heap\\n        for(int i=0; i<v.size(); i++)\\n            q.push(v[i]);\\n        while(k){                        // Negate k times ( min element will always be on top )\\n            int res = -q.top();\\n            q.pop();\\n            q.push(res);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n        return sum;\\n    }\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = find_sum(nums,k);\\n        return sum;\\n    }\\n};\\n```\n```\\nLet me tell you a secret, if question is based on array and you feel there is a need of sorting always think of heap solution as a possibility.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582378,
                "title": "c-only-for-beginners-simple-and-clean-solution",
                "content": "**Please Upvote If it helped You !!!\\nHappy Coding :)**\\n```\\nint largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        \\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        while(k>0)\\n        {\\n            nums[0]= -1*nums[0];\\n            k--;\\n            sort(nums.begin(),nums.end());\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum= sum+nums[i];\\n        }\\n        return sum;\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        \\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        while(k>0)\\n        {\\n            nums[0]= -1*nums[0];\\n            k--;\\n            sort(nums.begin(),nums.end());\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum= sum+nums[i];\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385477,
                "title": "python-logic",
                "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \\n        while k > 0:\\n            nums.sort()\\n            nums[0] = nums[0] * -1\\n            k = k -1\\n        return sum(nums)\\n            \\n## \\t\\t\\t``",
                "solutionTags": [],
                "code": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \\n        while k > 0:\\n            nums.sort()\\n            nums[0] = nums[0] * -1\\n            k = k -1\\n        return sum(nums)\\n            \\n## \\t\\t\\t``",
                "codeTag": "Java"
            },
            {
                "id": 1191474,
                "title": "javascript-concise",
                "content": "```\\nvar largestSumAfterKNegations = function(A, K) {\\n    while(K > 0 ){ \\n        let v = Math.min(...A)\\n        let i = A.indexOf(v)\\n        A[i] = - A[i]\\n        K--\\n    }\\n    \\n    return A.reduce((a,c) => a+c,0)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestSumAfterKNegations = function(A, K) {\\n    while(K > 0 ){ \\n        let v = Math.min(...A)\\n        let i = A.indexOf(v)\\n        A[i] = - A[i]\\n        K--\\n    }\\n    \\n    return A.reduce((a,c) => a+c,0)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 518152,
                "title": "simple-java-solution",
                "content": "```\\npublic int largestSumAfterKNegations(int[] arr, int k) {\\n\\tArrays.sort(arr);\\n\\tint sum = 0, len = arr.length, minIndex = 0;\\n\\twhile (k > 0) {\\n\\t\\tarr[minIndex] *= -1;\\n\\t\\tk--;\\n\\t\\tif (minIndex + 1 < len && arr[minIndex] > arr[minIndex + 1]) minIndex++;\\n\\t}\\n\\tfor (int i : arr) sum += i;\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int largestSumAfterKNegations(int[] arr, int k) {\\n\\tArrays.sort(arr);\\n\\tint sum = 0, len = arr.length, minIndex = 0;\\n\\twhile (k > 0) {\\n\\t\\tarr[minIndex] *= -1;\\n\\t\\tk--;\\n\\t\\tif (minIndex + 1 < len && arr[minIndex] > arr[minIndex + 1]) minIndex++;\\n\\t}\\n\\tfor (int i : arr) sum += i;\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252520,
                "title": "java-solution-o-1-space-one-pass",
                "content": "Traverse the array, track the number of negative elements\\nIf number of negative elements is smaller than K, we can flip it to positive, otherwise, keep it as negative.\\nAfter the traversal, if we still have K - count flips to finish, it means we have flipped all negative elements, and have to touch a positive element. if K - count is even, flip any element is ok since it does not change anything. If K - count is odd, choose the smallest element which we have kept tracking in the traversal by minPositive.\\n\\n```java\\n        Arrays.sort(A);\\n        int count = 0, sum = 0, minPositive = Integer.MAX_VALUE;\\n        for (int num : A) {\\n            if (num < 0 && ++count <= K) {\\n                num = -num;\\n            }\\n            sum += num;\\n            minPositive = Math.min(minPositive, num);\\n        }\\n        if (count > K || (K - count) % 2 == 0) {\\n            return sum;\\n        } else {\\n            return sum - minPositive * 2;\\n        }\\n```",
                "solutionTags": [],
                "code": "```java\\n        Arrays.sort(A);\\n        int count = 0, sum = 0, minPositive = Integer.MAX_VALUE;\\n        for (int num : A) {\\n            if (num < 0 && ++count <= K) {\\n                num = -num;\\n            }\\n            sum += num;\\n            minPositive = Math.min(minPositive, num);\\n        }\\n        if (count > K || (K - count) % 2 == 0) {\\n            return sum;\\n        } else {\\n            return sum - minPositive * 2;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2478851,
                "title": "java-easy-priority-queue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        for(int n:nums){\\n            q.add(n);\\n        }\\n        while(k>0)\\n        {\\n            int val=q.poll();\\n            q.add(-val);\\n            k--;\\n        }\\n        int sum=0;\\n        while(!q.isEmpty())\\n        {\\n            sum+=q.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        for(int n:nums){\\n            q.add(n);\\n        }\\n        while(k>0)\\n        {\\n            int val=q.poll();\\n            q.add(-val);\\n            k--;\\n        }\\n        int sum=0;\\n        while(!q.isEmpty())\\n        {\\n            sum+=q.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431212,
                "title": "3ms-t-c-java-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        Arrays.sort(nums);\\n\\n        int sum = 0;\\n        int min = 100;\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right){\\n            min = Math.min(min, Math.abs(nums[left]));\\n            if (k == 0) {\\n                sum += nums[left];\\n                left++;\\n            }\\n            else if (nums[right] < Math.abs(nums[left])){\\n                sum += Math.abs(nums[left]);\\n                left++;\\n                k--;\\n            }\\n            else {\\n                sum += nums[right];\\n                right--;\\n            }\\n        }\\n\\n        return k % 2 == 0 ? sum : sum - 2 * min;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816680,
                "title": "fastest-3-liner-solution-with-inbuilt-functions",
                "content": "```\\nvar largestSumAfterKNegations = function(nums, k) {\\n    while(k>0){\\n        let i = nums.indexOf(Math.min(...nums)); //find the index of minimum item in array using inbuilt function\\n        nums[i]*=-1; //Toggle the minimum value to get the maximum sum\\n        k--;\\n    }\\n    return nums.reduce((acc, curr)=>acc+curr); //return the sum using reduce function\\n};\\n```\\n\\n**Please upvote if I could help**\\nOpen to Suggestions :)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestSumAfterKNegations = function(nums, k) {\\n    while(k>0){\\n        let i = nums.indexOf(Math.min(...nums)); //find the index of minimum item in array using inbuilt function\\n        nums[i]*=-1; //Toggle the minimum value to get the maximum sum\\n        k--;\\n    }\\n    return nums.reduce((acc, curr)=>acc+curr); //return the sum using reduce function\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756738,
                "title": "java-simple-explained",
                "content": "**Idea:**\\n* To maximize the sum, negate the negatives and then the smallest number\\n* Negation of negation of n gives back n. \\n* This means if k is even, then we can exhaust it on the smallest int without changing it. So ignore even value k after loop  \\n* If k is odd, only then you need to actually negate the smallest int for maximum sum\\n>**T/S:** O(n lg n)/O(1), where n = size(nums) (ignored extra space of Arrays.sort)\\n```\\npublic int largestSumAfterKNegations(int[] nums, int k) {\\n\\tArrays.sort(nums);\\n\\tvar minIndex = 0;\\n\\t\\n\\tfor (var i = 0; i < nums.length && k > 0; i++) {\\n\\t\\tif (nums[i] < 0) {\\n\\t\\t\\tnums[i] *= -1;\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\tif (nums[minIndex] > nums[i])\\n\\t\\t\\tminIndex = i;\\n\\t}\\n\\n\\tif ((k & 1) == 1)\\n\\t\\tnums[minIndex] *= -1;\\n\\t\\t\\n\\treturn Arrays.stream(nums)\\n\\t\\t\\t\\t .sum();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int largestSumAfterKNegations(int[] nums, int k) {\\n\\tArrays.sort(nums);\\n\\tvar minIndex = 0;\\n\\t\\n\\tfor (var i = 0; i < nums.length && k > 0; i++) {\\n\\t\\tif (nums[i] < 0) {\\n\\t\\t\\tnums[i] *= -1;\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\tif (nums[minIndex] > nums[i])\\n\\t\\t\\tminIndex = i;\\n\\t}\\n\\n\\tif ((k & 1) == 1)\\n\\t\\tnums[minIndex] *= -1;\\n\\t\\t\\n\\treturn Arrays.stream(nums)\\n\\t\\t\\t\\t .sum();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388659,
                "title": "c-greedy-using-priority-queue-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375639,
                "title": "1005-maximize-sum-of-array-after-k-negations",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # sort nums according to each num\\'s absolute value in descending order\\n        nums = sorted(nums, key = abs, reverse = True)\\n        \\n        # we first negate the smallest negative num (it\\'s absolute value is the largest), so it adds most to the sum of nums\\n        for i in range(len(nums)):\\n            if k > 0 and nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n        \\n        # after negating all negative numbers, if k is still not zero (we need to do more negation), we negate the smallest positive number (which is the last element in nums) k times. Only if k is odd it will be negated \\n        if k % 2 == 1:\\n            nums[-1] *= -1\\n        \\n        return sum(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # sort nums according to each num\\'s absolute value in descending order\\n        nums = sorted(nums, key = abs, reverse = True)\\n        \\n        # we first negate the smallest negative num (it\\'s absolute value is the largest), so it adds most to the sum of nums\\n        for i in range(len(nums)):\\n            if k > 0 and nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n        \\n        # after negating all negative numbers, if k is still not zero (we need to do more negation), we negate the smallest positive number (which is the last element in nums) k times. Only if k is odd it will be negated \\n        if k % 2 == 1:\\n            nums[-1] *= -1\\n        \\n        return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285244,
                "title": "java-solution-priority-queue-code-with-comments",
                "content": "```\\n// TC: O(nlogn)\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        // Create a priority queue and insert all array elements in the priority queue      TC: O(n)\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int num : nums)\\n            pq.add(num);\\n        // Do k negations by removing a minimum element k times         TC: O(log n)\\n        while(k--> 0) {\\n            int temp = pq.poll();   // Retrieve and remove min element\\n            \\n            temp *= -1;     // Modify the min element and add it back to priority queue\\n            pq.add(temp);\\n        }\\n        \\n        // Compute sum of all elements in priority queue\\n        int sum = 0;\\n        for(int num : pq)\\n            sum += num;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// TC: O(nlogn)\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        // Create a priority queue and insert all array elements in the priority queue      TC: O(n)\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int num : nums)\\n            pq.add(num);\\n        // Do k negations by removing a minimum element k times         TC: O(log n)\\n        while(k--> 0) {\\n            int temp = pq.poll();   // Retrieve and remove min element\\n            \\n            temp *= -1;     // Modify the min element and add it back to priority queue\\n            pq.add(temp);\\n        }\\n        \\n        // Compute sum of all elements in priority queue\\n        int sum = 0;\\n        for(int num : pq)\\n            sum += num;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001349,
                "title": "java-straightforward-priority-queue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int x : A) {\\n            pq.offer(x);\\n        }\\n        while (K > 0) {\\n            pq.offer(-pq.poll());\\n            K--;\\n        }\\n        return pq.stream().mapToInt(i -> i).sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int x : A) {\\n            pq.offer(x);\\n        }\\n        while (K > 0) {\\n            pq.offer(-pq.poll());\\n            K--;\\n        }\\n        return pq.stream().mapToInt(i -> i).sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875597,
                "title": "python-4-lines-heapq-o-n-klogn",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): \\n            heapq.heapreplace(A, -A[0])\\n        return sum(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): \\n            heapq.heapreplace(A, -A[0])\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515509,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(A, K) {\\n  A.sort((a, b) => a - b);\\n  for (let i = 0; i < A.length && K > 0 && A[i] < 0; i++, K--) A[i] = -A[i];\\n  if (K > 0 && K % 2 == 1) {\\n    const minI = A.reduce((min, cur, i) => (cur < A[min] ? i : min), 0);\\n    A[minI] = -A[minI];\\n  }\\n  return A.reduce((acc, cur) => acc + cur);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(A, K) {\\n  A.sort((a, b) => a - b);\\n  for (let i = 0; i < A.length && K > 0 && A[i] < 0; i++, K--) A[i] = -A[i];\\n  if (K > 0 && K % 2 == 1) {\\n    const minI = A.reduce((min, cur, i) => (cur < A[min] ? i : min), 0);\\n    A[minI] = -A[minI];\\n  }\\n  return A.reduce((acc, cur) => acc + cur);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350855,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n    \\tS, a = sum(A), sorted([i for i in A if i < 0])\\n    \\tL, b = len(a), min([i for i in A if i >= 0])\\n    \\tif L == 0: return S if K % 2 == 0 else S - 2*b\\n    \\tif K <= L or (K - L) % 2 == 0: return S - 2*sum(a[:min(K,L)])\\n    \\treturn S - 2*sum(a[:-1]) if -a[-1] < b else S - 2*sum(a) - 2*b\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n    \\tS, a = sum(A), sorted([i for i in A if i < 0])\\n    \\tL, b = len(a), min([i for i in A if i >= 0])\\n    \\tif L == 0: return S if K % 2 == 0 else S - 2*b\\n    \\tif K <= L or (K - L) % 2 == 0: return S - 2*sum(a[:min(K,L)])\\n    \\treturn S - 2*sum(a[:-1]) if -a[-1] < b else S - 2*sum(a) - 2*b\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 253429,
                "title": "java-solutions",
                "content": "**Solution 1: Linear Search Approach**\\n\\n- The idea is to replace the minimum element `A[minIndex]` in array by `-A[minIndex]` for current operation. In this way we can make `sum` of array maximum after `K` operations. \\n- One interesting case is, once minimum element becomes `0`, we don\\u2019t need to make any more changes.\\n- Here we use linear search to find minimum element. So the time complexity of the this solution is `O(K * n)`.\\n\\nTime complexity: `O(K * n)` - where `n` is the length of an input array.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        int sum = 0;\\n        \\n        while(K-- > 0)\\n        {\\n            int minIndex = findMinIndex(A);\\n\\t\\t\\t\\n\\t\\t\\tif(A[minIndex] == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n                A[minIndex] = -A[minIndex];\\n        }\\n        \\n        for(int n : A)\\n            sum += n;\\n        return sum;\\n    }\\n    \\n    private int findMinIndex(int[] A)\\n    {\\n        int minIndex = 0;\\n\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            if(A[i] <= A[minIndex])\\n                minIndex = i;\\n        }\\n        return minIndex;\\n    }\\n}\\n```\\n\\n**Solution 2: Using minHeap**\\n\\n- Here an optimized solution is implemented that uses a `PriorityQueue` to find the minimum element quickly.\\n- The time complexity to insert `n` elements in to the `PriorityQueue` takes `O(n log n)` time in the general case. An `O(n)` algorithm exists for the special case where the input is already ordered, but this is not provided in `java.util.PriorityQueue` class. Also adding and removing `K` elements from the `minHeap` of size `n` takes `O(K log n)`, so the total complexity is `O(n log n + K log n) = (n + K) * log n`.\\n\\nTime complexity: `O(n log n + K log n) = (n + K) * log n` - where `n` is the length of an input array.\\nSpace complexity: `O(n)` - space required for the `minHeap`\\n\\n```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        int sum = 0;\\n        \\n        for(int n : A)\\n            minHeap.add(n);\\n        \\n        while(K-- > 0 && minHeap.peek() != 0)\\n            minHeap.add(-minHeap.poll());\\n        \\n        while(!minHeap.isEmpty())\\n            sum += minHeap.poll();\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        int sum = 0;\\n        \\n        while(K-- > 0)\\n        {\\n            int minIndex = findMinIndex(A);\\n\\t\\t\\t\\n\\t\\t\\tif(A[minIndex] == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n                A[minIndex] = -A[minIndex];\\n        }\\n        \\n        for(int n : A)\\n            sum += n;\\n        return sum;\\n    }\\n    \\n    private int findMinIndex(int[] A)\\n    {\\n        int minIndex = 0;\\n\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            if(A[i] <= A[minIndex])\\n                minIndex = i;\\n        }\\n        return minIndex;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        int sum = 0;\\n        \\n        for(int n : A)\\n            minHeap.add(n);\\n        \\n        while(K-- > 0 && minHeap.peek() != 0)\\n            minHeap.add(-minHeap.poll());\\n        \\n        while(!minHeap.isEmpty())\\n            sum += minHeap.poll();\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545228,
                "title": "explanation-of-the-whole-idea",
                "content": "## Explanation\\n```\\nAssume nums = [8,-1,8,-3,2,-2], k = 2\\n\\nTo get the LARGEST SUM we will make positive -3 and -2 as they are the SMALLEST NEGATIVE\\nNUMBERS. This finding process would be easier if we sort first:\\n\\n               -3,-2,-1,2,8,8 \\n\\nIf k were 5, first we would turn all the negative numbers to positive numbers, right?\\nCause the Q asked us LARGEST SUM!\\n\\n               3,2,1,2,8,8 and now k = 5 - 3 = 2\\n\\nAs we can choose the same index multiple times SO AFTER TURNING NEGATIVE NUMBERS\\nTO POSITIVE NUMBERS, OBVIOUSLY WE WILL NOW PICK THE SMALLEST NUMBER TO CHANGE IT\\'S SIGN\\nTO REMAINING K TIMES TO GET THE LARGEST SUM.\\n\\nHere the smallest number now is 1 and k = 2, so -1,1 which is same as 1 cause \\n       if k is even, sign won\\'t change, but if k is odd, sign will change 100%.\\n```\\n\\n```CPP []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        for(int i=0; i<nums.size() && nums[i]<0 && k>0; i++, k--)\\n            nums[i] = -nums[i];    \\n\\n        nums[min_element(begin(nums),end(nums))-begin(nums)] *= ((k&1) == 1? -1 : 1);\\n        return accumulate(begin(nums),end(nums),0);      \\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int :\\n        nums.sort()\\n        i = 0\\n        while i<len(nums) and k>0 and nums[i]<0 :\\n            nums[i] = -nums[i]\\n            i, k = i+1, k-1\\n        nums[nums.index(min(nums))] *= -1 if k&1 else 1\\n        return sum(nums) \\n```\\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(sort)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nAssume nums = [8,-1,8,-3,2,-2], k = 2\\n\\nTo get the LARGEST SUM we will make positive -3 and -2 as they are the SMALLEST NEGATIVE\\nNUMBERS. This finding process would be easier if we sort first:\\n\\n               -3,-2,-1,2,8,8 \\n\\nIf k were 5, first we would turn all the negative numbers to positive numbers, right?\\nCause the Q asked us LARGEST SUM!\\n\\n               3,2,1,2,8,8 and now k = 5 - 3 = 2\\n\\nAs we can choose the same index multiple times SO AFTER TURNING NEGATIVE NUMBERS\\nTO POSITIVE NUMBERS, OBVIOUSLY WE WILL NOW PICK THE SMALLEST NUMBER TO CHANGE IT\\'S SIGN\\nTO REMAINING K TIMES TO GET THE LARGEST SUM.\\n\\nHere the smallest number now is 1 and k = 2, so -1,1 which is same as 1 cause \\n       if k is even, sign won\\'t change, but if k is odd, sign will change 100%.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        for(int i=0; i<nums.size() && nums[i]<0 && k>0; i++, k--)\\n            nums[i] = -nums[i];    \\n\\n        nums[min_element(begin(nums),end(nums))-begin(nums)] *= ((k&1) == 1? -1 : 1);\\n        return accumulate(begin(nums),end(nums),0);      \\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int :\\n        nums.sort()\\n        i = 0\\n        while i<len(nums) and k>0 and nums[i]<0 :\\n            nums[i] = -nums[i]\\n            i, k = i+1, k-1\\n        nums[nums.index(min(nums))] *= -1 if k&1 else 1\\n        return sum(nums) \\n```\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(sort)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496667,
                "title": "maximize-sum-of-array-after-k-negations-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int i, j=0, sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<k ; i++)\\n        {\\n            if(nums[j]<0)\\n            {\\n                nums[j] *= (-1);\\n                if(j<nums.size()-1 && nums[j+1]<abs(nums[j]))\\n                    j++;\\n            }\\n            else if(nums[j]>=0)\\n            {\\n                nums[j] *= -1;\\n            }\\n        }\\n        sum = accumulate(nums.begin(), nums.end(), 0);\\n        return sum;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4615bd62-f688-4d57-965e-a6968997c323_1683460834.4019096.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int i, j=0, sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<k ; i++)\\n        {\\n            if(nums[j]<0)\\n            {\\n                nums[j] *= (-1);\\n                if(j<nums.size()-1 && nums[j+1]<abs(nums[j]))\\n                    j++;\\n            }\\n            else if(nums[j]>=0)\\n            {\\n                nums[j] *= -1;\\n            }\\n        }\\n        sum = accumulate(nums.begin(), nums.end(), 0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486353,
                "title": "beats-100-java-c-python-non-queue-solution",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\nDont forget to upvote if you like the content below. \\uD83D\\uDE43\\n\\n# Intuition\\nGiven the problem, we should always aim to negate the smallest number in the array in each iteration to maximize the final sum. However, we can use a micro-optimization by calculating the sum once at the beginning and then adjusting it after each negation.\\n\\n# Approach\\nWe start by creating a frequency array, $$numbers$$, with the index representing the number in the original array + $$100$$. This allows us to handle negative numbers seamlessly.\\n\\nNext, we iterate through the $$nums$$ array, count the frequencies, and calculate the sum. Simultaneously, we keep track of the maximum absolute value in the array ($$maxAbs$$), which we will use later to determine the start index for the negation process.\\n\\nIf $$maxAbs$$ is zero after the first pass, it means all elements in the array are zero, and we return $$0$$, as negating zero doesn\\'t change the sum.\\n\\nThen, we perform $$k$$ negations. For each negation, we start at the index $$i$$ equal to $$100 - maxAbs$$, which represents the smallest possible number in the array. We find the first index with a non-zero frequency, decrement its frequency, increment the frequency of its negation $$(200 - i)$$, and adjust the sum by subtracting twice the current number (since we have negated it).\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is $$O(n + k)$$, where $$n$$ is the length of the array and $$k$$ is the number of negations. $$n$$ is for the initial iteration through the nums array, and $$k$$ is for the negations.\\n\\n- Space complexity:\\nThe space complexity is $$O(1)$$, as we only use a constant amount of extra space. The numbers array\\'s size is a constant $$201$$, accommodating all possible values from $$-100$$ to $$100$$.\\n\\nThis solution is optimal for the problem constraints. While a PriorityQueue-based solution could also work, it might not be as fast due to overheads associated with creating and managing the PriorityQueue. Our solution avoids these overheads by using a simple frequency count array and a single pass through the array. The index calculation $$(number + 100)$$ and the negation index calculation $$(200 - index)$$ are straightforward and efficient, making this solution particularly suitable for the given constraints.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        vector<int> numbers(201, 0);\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n : nums) {\\n            maxAbs = max(maxAbs, abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        numbers = [0] * 201\\n        total_sum = 0\\n        max_abs = 0\\n        \\n        for n in nums:\\n            max_abs = max(max_abs, abs(n))\\n            numbers[100 + n] += 1\\n            total_sum += n\\n\\n        if max_abs == 0:\\n            return 0\\n\\n        while k > 0:\\n            k -= 1\\n            i = 100 - max_abs\\n            while numbers[i] == 0:\\n                i += 1\\n            numbers[i] -= 1\\n            numbers[200 - i] += 1\\n            total_sum -= 2 * (i - 100)\\n\\n        return total_sum\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Counting"
                ],
                "code": "```java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        vector<int> numbers(201, 0);\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n : nums) {\\n            maxAbs = max(maxAbs, abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        numbers = [0] * 201\\n        total_sum = 0\\n        max_abs = 0\\n        \\n        for n in nums:\\n            max_abs = max(max_abs, abs(n))\\n            numbers[100 + n] += 1\\n            total_sum += n\\n\\n        if max_abs == 0:\\n            return 0\\n\\n        while k > 0:\\n            k -= 1\\n            i = 100 - max_abs\\n            while numbers[i] == 0:\\n                i += 1\\n            numbers[i] -= 1\\n            numbers[200 - i] += 1\\n            total_sum -= 2 * (i - 100)\\n\\n        return total_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459930,
                "title": "5-line-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nklog(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        int sum=0;\\n        while(k>0)\\n        {\\n                nums[0]=-nums[0];\\n                sort(begin(nums),end(nums));\\n                 k--;\\n        }\\n         for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        int sum=0;\\n        while(k>0)\\n        {\\n                nums[0]=-nums[0];\\n                sort(begin(nums),end(nums));\\n                 k--;\\n        }\\n         for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315221,
                "title": "1005-simple-solution-beats-91",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        last_negative, last_ind = nums[0], 0\\n        for x, item in enumerate(nums):\\n            if k <= 0 or item == 0: break\\n            if item < 0:\\n                last_negative = -item\\n                last_ind = x\\n                nums[x] = -1 * item\\n                k -= 1\\n            elif item > 0:\\n                if k % 2 == 0: break\\n                else:\\n                    if item > last_negative:\\n                        nums[last_ind] = -1* last_negative\\n                        break\\n                    else:\\n                        nums[x] = -item\\n                        break\\n        else:\\n            nums[last_ind] = (-1**k)* last_negative\\n        return sum(nums)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        last_negative, last_ind = nums[0], 0\\n        for x, item in enumerate(nums):\\n            if k <= 0 or item == 0: break\\n            if item < 0:\\n                last_negative = -item\\n                last_ind = x\\n                nums[x] = -1 * item\\n                k -= 1\\n            elif item > 0:\\n                if k % 2 == 0: break\\n                else:\\n                    if item > last_negative:\\n                        nums[last_ind] = -1* last_negative\\n                        break\\n                    else:\\n                        nums[x] = -item\\n                        break\\n        else:\\n            nums[last_ind] = (-1**k)* last_negative\\n        return sum(nums)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060253,
                "title": "easy-python3-intuition-approach",
                "content": "# Code1\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k):\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]\\n        return sum(nums)\\n```\\n\\n# Code2\\n\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k,0,-1):\\n            if min(nums)>=0 and i%2==0:return sum(nums)\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]            \\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k):\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]\\n        return sum(nums)\\n```\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k,0,-1):\\n            if min(nums)>=0 and i%2==0:return sum(nums)\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]            \\n        return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674119,
                "title": "java-priorityqueue-approach",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int p : nums){\\n            pq.offer(p);\\n        }\\n        while(k --> 0){\\n            int temp = pq.poll();\\n            temp = -temp;\\n            pq.offer(temp);\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty()){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int p : nums){\\n            pq.offer(p);\\n        }\\n        while(k --> 0){\\n            int temp = pq.poll();\\n            temp = -temp;\\n            pq.offer(temp);\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty()){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506908,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\n var largestSumAfterKNegations = function(nums, k) {\\n    const sortedNums = nums.sort((a,b) => a-b);\\n    let lowestPos = 0;\\n    for (let i = 0; i < k; i++) {\\n        // keep track of the lowest positive number\\n        if (sortedNums[i] < sortedNums[lowestPos]) lowestPos = i;\\n        // if the number is negative, flip it, otherwise continue to flip the lowest positive number\\n        sortedNums[i] < 0 ? sortedNums[i] = -sortedNums[i] : sortedNums[lowestPos] = -sortedNums[lowestPos];\\n    }\\n    return sortedNums.reduce((a,b) => a + b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n var largestSumAfterKNegations = function(nums, k) {\\n    const sortedNums = nums.sort((a,b) => a-b);\\n    let lowestPos = 0;\\n    for (let i = 0; i < k; i++) {\\n        // keep track of the lowest positive number\\n        if (sortedNums[i] < sortedNums[lowestPos]) lowestPos = i;\\n        // if the number is negative, flip it, otherwise continue to flip the lowest positive number\\n        sortedNums[i] < 0 ? sortedNums[i] = -sortedNums[i] : sortedNums[lowestPos] = -sortedNums[lowestPos];\\n    }\\n    return sortedNums.reduce((a,b) => a + b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096202,
                "title": "python-use-min-heap-to-always-operate-the-minelement-k-times",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        heapq.heapify(nums)\\n        while k > 0:\\n            _min = heapq.heappop(nums)\\n            heapq.heappush(nums, -_min)\\n            k -= 1\\n        res = 0\\n        while n > 0:\\n            res += heapq.heappop(nums)\\n            n -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        heapq.heapify(nums)\\n        while k > 0:\\n            _min = heapq.heappop(nums)\\n            heapq.heappush(nums, -_min)\\n            k -= 1\\n        res = 0\\n        while n > 0:\\n            res += heapq.heappop(nums)\\n            n -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882763,
                "title": "c-solution-beginner-friendly-using-priority-queue",
                "content": "```\\nint n=a.size(),c=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<n;i++)\\n            pq.push(a[i]);\\n        while(k--)\\n        {\\n            int p=pq.top();\\n            pq.pop();\\n            pq.push(-p);\\n        }\\n        while(!pq.empty())\\n        {\\n            c+=pq.top();\\n            pq.pop();\\n        }\\n       return c; \\n    }\\n```\\n``` If you like my approach then please upvote me.```",
                "solutionTags": [],
                "code": "```\\nint n=a.size(),c=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<n;i++)\\n            pq.push(a[i]);\\n        while(k--)\\n        {\\n            int p=pq.top();\\n            pq.pop();\\n            pq.push(-p);\\n        }\\n        while(!pq.empty())\\n        {\\n            c+=pq.top();\\n            pq.pop();\\n        }\\n       return c; \\n    }\\n```\n``` If you like my approach then please upvote me.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809612,
                "title": "greedy-approach-python",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort(key=abs, reverse=True)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] *= -1\\n                k -= 1\\n            if k == 0:\\n                break\\n        if k % 2 != 0:\\n            nums[-1] *= -1\\n        return sum(nums)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort(key=abs, reverse=True)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] *= -1\\n                k -= 1\\n            if k == 0:\\n                break\\n        if k % 2 != 0:\\n            nums[-1] *= -1\\n        return sum(nums)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1794751,
                "title": "python3-priority-queue-min-heap-easy-understanding",
                "content": "TC: O(n + klog(x)) with x < n\\nSC: O(1)\\n\\n```\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        \\n        for _ in range(k):\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        \\n        for _ in range(k):\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1595423,
                "title": "c-solution-with-explanation",
                "content": "```\\nint cmp(const void *a, const void *b){\\n    return *(int*)a > *(int*)b;\\n}\\n\\nint largestSumAfterKNegations(int* nums, int numsSize, int k){\\n    // Sort the array first. \\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int i, N = numsSize, j = 0, sum = 0;\\n    \\n    // Concept: Flip the smallest element at each round. If it becomes larger than the next smallest element, don\\'t flip it in later rounds and switch to the next element. \\n    for(; k > 0; k--){  \\n        nums[j] = -nums[j];\\n        if(j == N - 1){\\n            continue;\\n        }\\n        if(nums[j] > nums[j + 1]){\\n            j++;\\n        }\\n    }\\n    for(i = 0; i < N; i++){\\n        sum += nums[i];\\n    }\\n    \\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(const void *a, const void *b){\\n    return *(int*)a > *(int*)b;\\n}\\n\\nint largestSumAfterKNegations(int* nums, int numsSize, int k){\\n    // Sort the array first. \\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int i, N = numsSize, j = 0, sum = 0;\\n    \\n    // Concept: Flip the smallest element at each round. If it becomes larger than the next smallest element, don\\'t flip it in later rounds and switch to the next element. \\n    for(; k > 0; k--){  \\n        nums[j] = -nums[j];\\n        if(j == N - 1){\\n            continue;\\n        }\\n        if(nums[j] > nums[j + 1]){\\n            j++;\\n        }\\n    }\\n    for(i = 0; i < N; i++){\\n        sum += nums[i];\\n    }\\n    \\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1547583,
                "title": "c-100-lengthy-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        int i=0;\\n        \\n       sort(nums.begin(),nums.end());\\n       while(i<nums.size()&&(k>0&&nums[i]<=0)){\\n           if(nums[i]<0){\\n               nums[i]=-nums[i];\\n               k--;\\n           }\\n           else {\\n               k=0;\\n               break;\\n           }\\n           i++;\\n           }\\n        while(i<nums.size()&&(k>0&&nums[i]>0)){\\n            if(i!=0){\\n                if(nums[i]<=nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i]=-nums[i];\\n                        k=0;\\n                    }\\n                }\\n                if(nums[i]>nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i-1]=-nums[i-1];\\n                        k=0;\\n                    }\\n                }\\n            }\\n            else{\\n                if(k%2!=0){\\n                    \\n                    nums[i]=-nums[i];\\n                    cout<<nums[i]<<endl;\\n                    k=0;\\n                }\\n            }\\n            i++;\\n}\\n            if(k%2!=0){\\n                nums[nums.size()-1]=-nums[nums.size()-1];\\n                k=0;\\n            }      \\n        \\n        for(int j=0;j<nums.size();j++){\\n            sum+=nums[j];\\n        }\\n        return sum;\\n       }\\n    };\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        int i=0;\\n        \\n       sort(nums.begin(),nums.end());\\n       while(i<nums.size()&&(k>0&&nums[i]<=0)){\\n           if(nums[i]<0){\\n               nums[i]=-nums[i];\\n               k--;\\n           }\\n           else {\\n               k=0;\\n               break;\\n           }\\n           i++;\\n           }\\n        while(i<nums.size()&&(k>0&&nums[i]>0)){\\n            if(i!=0){\\n                if(nums[i]<=nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i]=-nums[i];\\n                        k=0;\\n                    }\\n                }\\n                if(nums[i]>nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i-1]=-nums[i-1];\\n                        k=0;\\n                    }\\n                }\\n            }\\n            else{\\n                if(k%2!=0){\\n                    \\n                    nums[i]=-nums[i];\\n                    cout<<nums[i]<<endl;\\n                    k=0;\\n                }\\n            }\\n            i++;\\n}\\n            if(k%2!=0){\\n                nums[nums.size()-1]=-nums[nums.size()-1];\\n                k=0;\\n            }      \\n        \\n        for(int j=0;j<nums.size();j++){\\n            sum+=nums[j];\\n        }\\n        return sum;\\n       }\\n    };\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1502226,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] nums, int k) {     \\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tint min = 101;\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i){\\n\\t\\t\\t\\tif(nums[i] < 0 && k > 0){ // flip a negative number, \\n\\t\\t\\t\\t\\tnums[i] = -nums[i];\\n\\t\\t\\t\\t\\tk--; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(nums[i] < min){\\n\\t\\t\\t\\t\\tmin=nums[i]; // find the minimum in the array \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres += nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tif(k%2==1) \\n\\t\\t\\t\\tres -= 2*min;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\t\\t\\t// step 1 sort \\n\\t\\t\\t// step 2 if there are negative numbers, flip the negatives according to k, and find the minimum in the array \\n\\t\\t\\t// step 3 if k%2==1, we will subtract min twice. \\n\\t\\t\\t// time O(nlogn)\\n\\t\\t\\t// space O(1)",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] nums, int k) {     \\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tint min = 101;\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i){\\n\\t\\t\\t\\tif(nums[i] < 0 && k > 0){ // flip a negative number, \\n\\t\\t\\t\\t\\tnums[i] = -nums[i];\\n\\t\\t\\t\\t\\tk--; \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1115003,
                "title": "easy-way-of-using-priorityqueue-java",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        \\n        //Using of min heap.\\n        //Min heap by default.\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=0;i<A.length;i++)\\n            pq.add(A[i]);\\n        int start = 0;\\n        while(start<K)\\n        {\\n            int min_value = pq.poll();\\n            pq.add(min_value*(-1));\\n            start++;\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum = sum + pq.poll();\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        \\n        //Using of min heap.\\n        //Min heap by default.\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=0;i<A.length;i++)\\n            pq.add(A[i]);\\n        int start = 0;\\n        while(start<K)\\n        {\\n            int min_value = pq.poll();\\n            pq.add(min_value*(-1));\\n            start++;\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum = sum + pq.poll();\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087877,
                "title": "java-minheap-simple-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        \\n        for(int elem: A){\\n            minHeap.add(elem);\\n        }\\n        \\n        for(int i=0 ; i<K ; ++i){\\n            int curr = minHeap.poll();\\n            minHeap.add(-1*curr);\\n        }\\n        \\n        int sum = 0;\\n        while(!minHeap.isEmpty()){\\n            sum += minHeap.poll();\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        \\n        for(int elem: A){\\n            minHeap.add(elem);\\n        }\\n        \\n        for(int i=0 ; i<K ; ++i){\\n            int curr = minHeap.poll();\\n            minHeap.add(-1*curr);\\n        }\\n        \\n        int sum = 0;\\n        while(!minHeap.isEmpty()){\\n            sum += minHeap.poll();\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986825,
                "title": "two-months-of-python-solution",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K) -> int:\\n\\n        minvalue = min(A)\\n        start = 0\\n\\n        while start != K:\\n            for i in range(len(A)):\\n                if A[i] == minvalue:\\n                    A[i] = - A[i]\\n                    break\\n\\n            minvalue = min(A)\\n            start +=1\\n\\n        return sum(A)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K) -> int:\\n\\n        minvalue = min(A)\\n        start = 0\\n\\n        while start != K:\\n            for i in range(len(A)):\\n                if A[i] == minvalue:\\n                    A[i] = - A[i]\\n                    break\\n\\n            minvalue = min(A)\\n            start +=1\\n\\n        return sum(A)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917150,
                "title": "easy-adn-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());      // sorting in begining\\n        int sum=0;\\n        for(int i=0;i<a.size()&&k>0;i++)\\n        {\\n            if(a[i]<0)       // for all negative elements\\n            {\\n                a[i]=-a[i];\\n                k--;\\n            }\\n            else \\n                break;      // else breaking out of loop\\n        }\\n        sort(a.begin(),a.end());           // sorting again to find out the smallest element in the modified array\\n        for(int i=1;i<a.size();i++)            // calculating sum except the smallest element i.e a[0]\\n                sum+=a[i];\\n        if(k%2==0)\\n            return sum+a[0];                    // adding smallest element as it is if k is even\\n        else\\n            return sum-a[0];                   // adding smallest element after changinf sign if k is odd\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());      // sorting in begining\\n        int sum=0;\\n        for(int i=0;i<a.size()&&k>0;i++)\\n        {\\n            if(a[i]<0)       // for all negative elements\\n            {\\n                a[i]=-a[i];\\n                k--;\\n            }\\n            else \\n                break;      // else breaking out of loop\\n        }\\n        sort(a.begin(),a.end());           // sorting again to find out the smallest element in the modified array\\n        for(int i=1;i<a.size();i++)            // calculating sum except the smallest element i.e a[0]\\n                sum+=a[i];\\n        if(k%2==0)\\n            return sum+a[0];                    // adding smallest element as it is if k is even\\n        else\\n            return sum-a[0];                   // adding smallest element after changinf sign if k is odd\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761620,
                "title": "java-2-solutions-using-heap-sorting",
                "content": "Using Priority Queue :\\n```\\nPriorityQueue<Integer> pq = new PriorityQueue<>();\\nfor(int num : A) pq.add(num);\\n\\nwhile(K-- > 0)\\n\\tpq.add(-pq.poll());\\n\\nint sum = 0;\\nwhile(!pq.isEmpty())\\n\\tsum += pq.poll();\\nreturn sum;\\n```\\n\\nUsing Sorting :\\n\\n```\\nArrays.sort(A);\\nint sum = 0;\\n\\nfor(int i = 0; i < A.length; i++){\\n\\n\\twhile(A[i] < 0 && K > 0){\\n\\t\\tA[i] = -A[i];\\n\\t\\tK--;\\n\\t\\ti++;\\n\\t}\\n\\n\\tK = K%2 == 0 ? 0 : 1;\\n\\tif(K > 0){\\n\\t\\tif(i > 0 && A[i] > A[i-1])\\n\\t\\t\\tA[i-1] = -A[i-1];\\n\\t\\telse\\n\\t\\t\\tA[i] = -A[i];\\n\\t}\\n\\tbreak;\\n}\\nfor(int num : A)\\n\\tsum += num;\\nreturn sum;\\n```",
                "solutionTags": [],
                "code": "```\\nPriorityQueue<Integer> pq = new PriorityQueue<>();\\nfor(int num : A) pq.add(num);\\n\\nwhile(K-- > 0)\\n\\tpq.add(-pq.poll());\\n\\nint sum = 0;\\nwhile(!pq.isEmpty())\\n\\tsum += pq.poll();\\nreturn sum;\\n```\n```\\nArrays.sort(A);\\nint sum = 0;\\n\\nfor(int i = 0; i < A.length; i++){\\n\\n\\twhile(A[i] < 0 && K > 0){\\n\\t\\tA[i] = -A[i];\\n\\t\\tK--;\\n\\t\\ti++;\\n\\t}\\n\\n\\tK = K%2 == 0 ? 0 : 1;\\n\\tif(K > 0){\\n\\t\\tif(i > 0 && A[i] > A[i-1])\\n\\t\\t\\tA[i-1] = -A[i-1];\\n\\t\\telse\\n\\t\\t\\tA[i] = -A[i];\\n\\t}\\n\\tbreak;\\n}\\nfor(int num : A)\\n\\tsum += num;\\nreturn sum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601888,
                "title": "java-99-9-1-ms-only-sorting",
                "content": "```\\n private int largestSumAfterKNegations(int[] A,int K){\\n        Arrays.sort(A); \\n        int minIdx = 0;\\n        while(K-- > 0){\\n            if(minIdx < A.length && A[minIdx] < 0){\\n                A[minIdx] = -A[minIdx];\\n\\t\\t\\t\\t//Move minIdx only if the next number is less than min\\n                if(minIdx+1 < A.length && A[minIdx+1] < A[minIdx])minIdx++;\\n            }else{\\n                 A[minIdx] = -A[minIdx];\\n            }\\n            \\n        }\\n        int sum = 0;\\n        for(int num:A){\\n            sum += num;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n private int largestSumAfterKNegations(int[] A,int K){\\n        Arrays.sort(A); \\n        int minIdx = 0;\\n        while(K-- > 0){\\n            if(minIdx < A.length && A[minIdx] < 0){\\n                A[minIdx] = -A[minIdx];\\n\\t\\t\\t\\t//Move minIdx only if the next number is less than min\\n                if(minIdx+1 < A.length && A[minIdx+1] < A[minIdx])minIdx++;\\n            }else{\\n                 A[minIdx] = -A[minIdx];\\n            }\\n            \\n        }\\n        int sum = 0;\\n        for(int num:A){\\n            sum += num;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560334,
                "title": "6-lines-solution-with-c-stl",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        for (int i = 0; i < K; i++)\\n        {\\n            auto itr = min_element(A.begin(), A.end());\\n            *itr = -(*itr);\\n        }\\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```\\n**PEACE**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        for (int i = 0; i < K; i++)\\n        {\\n            auto itr = min_element(A.begin(), A.end());\\n            *itr = -(*itr);\\n        }\\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456042,
                "title": "1005-maximize-sum-of-array-after-k-negations-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Min Heap**\\n| O(T): O(nlgn) | O(S): O(1) | Rt: 48ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\\nComment: always negate the minimum. \\nAlternative: slightly improved. | Rt: 40ms |\\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K % (2 * len(A))): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\\nComment: if you do 2 * len(A) negating, you can always get the original input list. \\nTriple: further improved.  | Rt: 48ms |\\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        K %= 2*len(A)\\n        for i in range(K):\\n            if A[0] >= 0: return sum(A) - ((K - i) & 1) * 2 * A[0] \\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\\nComment: Once all elements are positive, stop the game and check the remaining times need to modify. If the remaining is even, it is the sum of current list (you negate the minimun even times, it remains the same). Otherwise, you need to deduct the minimum twice because you already added it to the sum once (and it is negative after odd times negating). This should boost the runtime however it didn\\'t ....\\n\\nQuestion: could we reduce K by % 2(len(A))? I think not, but the solution get passed. **I clarify the \"Reduce K\" trick in the above solutions (and below) may not be applicable in case some troubles .** \\n\\n\\n**II). Remove and Append**\\n| O(T): O(kn) | O(S): O(1) | Rt: 136ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\\nAlternative: slightly improved.  | Rt: 124ms | O(T): n^2 |\\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K % (2*len(A))): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\\n\\n\\n**III). Greedy**\\n| O(T): O(nlgn) | O(S): O(1) | Rt: 56ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(); K %= 2 * len(A); i = 0\\n        while A[i] < 0 and i < K: A[i], i = -A[i], i + 1\\n        return sum(A) - ((K-i) % 2) * 2 * min(A)\\n```\\n\\n\\n**IV). Counting Sort**\\n| O(T): O(n) | O(S): O(n) | Rt: 56ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        ct = collections.Counter(A)\\n        for i in range(-100, 0):\\n            if K == 0: break\\n            if i in ct: \\n                amt = min(K, ct[i])\\n                ct[i] -= amt\\n                ct[-i] += amt\\n                K -= amt\\n        a = list(ct.elements())\\n        return sum(a) - (K&1) * 2 * min(a) \\n```\\nReferrence: https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/discuss/252254/C++Python-Sort/246430\\nComment: take advantage of the -100 <= A[i] <= 100.\\n\\n\\n**V). Bucket Collect then Counting Sort**\\n| O(T): O(n) | O(S): O(1) | Rt: 48ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        m = [0] * 201\\n        for i in A: m[i+100] += 1\\n        for i in range(0, 100):\\n            if K == 0: break\\n            if m[i]: \\n                amt = min(K, m[i])\\n                m[i] -= amt\\n                # -(i - 100) + 100 = 200 -i\\n                m[200 - i] += amt\\n                K -= amt\\n        suma = sum((i-100) * v for i, v in enumerate(m) if v)\\n        # mina = next(i - 100 for i, v in enumerate(m) if v)\\n        return suma - (K&1) * 2 * min(map(abs, A)) \\n```\\nReferrence: idea from https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/discuss/252849/C%2B%2BJava-O(n)-or-O(1)\\nQuestion: min([5,6,9,-3,3], key=abs) == -3 and min([5,6,9,-4,3], key=abs) == 3. Who tell me Why?\\n",
                "solutionTags": [],
                "code": "```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K % (2 * len(A))): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        K %= 2*len(A)\\n        for i in range(K):\\n            if A[0] >= 0: return sum(A) - ((K - i) & 1) * 2 * A[0] \\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K % (2*len(A))): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(); K %= 2 * len(A); i = 0\\n        while A[i] < 0 and i < K: A[i], i = -A[i], i + 1\\n        return sum(A) - ((K-i) % 2) * 2 * min(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        ct = collections.Counter(A)\\n        for i in range(-100, 0):\\n            if K == 0: break\\n            if i in ct: \\n                amt = min(K, ct[i])\\n                ct[i] -= amt\\n                ct[-i] += amt\\n                K -= amt\\n        a = list(ct.elements())\\n        return sum(a) - (K&1) * 2 * min(a) \\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        m = [0] * 201\\n        for i in A: m[i+100] += 1\\n        for i in range(0, 100):\\n            if K == 0: break\\n            if m[i]: \\n                amt = min(K, m[i])\\n                m[i] -= amt\\n                # -(i - 100) + 100 = 200 -i\\n                m[200 - i] += amt\\n                K -= amt\\n        suma = sum((i-100) * v for i, v in enumerate(m) if v)\\n        # mina = next(i - 100 for i, v in enumerate(m) if v)\\n        return suma - (K&1) * 2 * min(map(abs, A)) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 422182,
                "title": "simple-solution-with-python-40ms",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        i = 0\\n        while K > 0 and A[i] < 0:\\n            A[i] *= -1\\n            i += 1\\n            K -= 1\\n        if K % 2 == 0:\\n            return sum(A)\\n        else:\\n            return sum(A) - 2 * min(A[i],A[i-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        i = 0\\n        while K > 0 and A[i] < 0:\\n            A[i] *= -1\\n            i += 1\\n            K -= 1\\n        if K % 2 == 0:\\n            return sum(A)\\n        else:\\n            return sum(A) - 2 * min(A[i],A[i-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332070,
                "title": "straightforward-java-o-nlogn-and-constant-space-with-thinking-process",
                "content": "The idea is pretty simple:\\n1. The sum maximizes when all numbers are positive.\\n2. If K >= neg(count of negative numbers), we use neg flips to make all negative numbers to positive. If (K - neg) % 2 == 0, good, nothing will be changed; If not, flip the number that has min Math.abs(number) once. \\n3. If K < neg, we just need to flip the first K negative numbers in a sorted array. \\n```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int neg = 0, sum = 0, close = Integer.MAX_VALUE;\\n        for(int i : A){\\n            if(i < 0) neg++;\\n            if(Math.abs(i) < close) close = Math.abs(i);\\n        }\\n        if(K >= neg){\\n            int remain = K - neg;\\n            for(int i : A) sum += Math.abs(i);\\n            return remain % 2 == 0? sum : sum - 2*close;\\n        }\\n        else {\\n            Arrays.sort(A);\\n            for(int i : A){\\n                if(K > 0){\\n                    sum += Math.abs(i);\\n                    K--;\\n                }\\n                else sum += i;\\n            }\\n            return sum;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int neg = 0, sum = 0, close = Integer.MAX_VALUE;\\n        for(int i : A){\\n            if(i < 0) neg++;\\n            if(Math.abs(i) < close) close = Math.abs(i);\\n        }\\n        if(K >= neg){\\n            int remain = K - neg;\\n            for(int i : A) sum += Math.abs(i);\\n            return remain % 2 == 0? sum : sum - 2*close;\\n        }\\n        else {\\n            Arrays.sort(A);\\n            for(int i : A){\\n                if(K > 0){\\n                    sum += Math.abs(i);\\n                    K--;\\n                }\\n                else sum += i;\\n            }\\n            return sum;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331164,
                "title": "javascript-beats-99-5",
                "content": "Runtime: 52 ms, faster than 99.50% of JavaScript online submissions\\nMemory Usage: 35.9 MB, less than 33.80% of JavaScript online submissions\\n\\nTrying to take every short circuit I can.\\n\\n```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (A, K) => {\\n  A.sort((a, b) => a - b);\\n  let sum = 0;\\n  for (let i = 0; i < A.length; i++) {\\n    let val = A[i];\\n    if (0 < K) {\\n      if (val < 0) {\\n        let next = A[i + 1];\\n        if (Math.abs(val) < next && 0 === K % 2) K = 0;\\n        else [val, K] = [-val, K - 1];\\n      } else if (0 !== val && 1 === K % 2) [val, K] = [-val, 0];\\n      else K = 0;\\n    }\\n    sum += val;\\n  }\\n  return sum;\\n};\\n```\\n\\nAnd here is a recursive solution.\\n\\nRuntime: 68 ms, faster than 72.92% of JavaScript online submissions\\nMemory Usage: 36.3 MB, less than 50.00% of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (a, k) => {\\n  if (0 === k) return a.reduce((acc, curr) => acc + curr);\\n  let [min, mindex] = [Infinity];\\n  for (let i = 0; i < a.length; i++) if (a[i] < min) [min, mindex] = [a[i], i];\\n  if (min < 0 || k % 2) a[mindex] = -a[mindex];\\n  return largestSumAfterKNegations(a, min < 0 ? k - 1 : 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (A, K) => {\\n  A.sort((a, b) => a - b);\\n  let sum = 0;\\n  for (let i = 0; i < A.length; i++) {\\n    let val = A[i];\\n    if (0 < K) {\\n      if (val < 0) {\\n        let next = A[i + 1];\\n        if (Math.abs(val) < next && 0 === K % 2) K = 0;\\n        else [val, K] = [-val, K - 1];\\n      } else if (0 !== val && 1 === K % 2) [val, K] = [-val, 0];\\n      else K = 0;\\n    }\\n    sum += val;\\n  }\\n  return sum;\\n};\\n```\n```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (a, k) => {\\n  if (0 === k) return a.reduce((acc, curr) => acc + curr);\\n  let [min, mindex] = [Infinity];\\n  for (let i = 0; i < a.length; i++) if (a[i] < min) [min, mindex] = [a[i], i];\\n  if (min < 0 || k % 2) a[mindex] = -a[mindex];\\n  return largestSumAfterKNegations(a, min < 0 ? k - 1 : 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 253629,
                "title": "c-10-lines-o-nlogn-time-o-1-space-use-only-sort-comparison-beat-99-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(), A.end());\\n        int minIdx = 0;\\n        // Do K steps\\n        for(int i = 0; i < K; i++){\\n            // change the sign of the smallest element\\n            A[minIdx] = -A[minIdx];\\n            if(minIdx == A.size()-1  || A[minIdx] > A[minIdx + 1])  minIdx++;\\n        }\\n        int sum = 0;\\n        for(auto a: A)  sum += a;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(), A.end());\\n        int minIdx = 0;\\n        // Do K steps\\n        for(int i = 0; i < K; i++){\\n            // change the sign of the smallest element\\n            A[minIdx] = -A[minIdx];\\n            if(minIdx == A.size()-1  || A[minIdx] > A[minIdx + 1])  minIdx++;\\n        }\\n        int sum = 0;\\n        for(auto a: A)  sum += a;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253368,
                "title": "quickselect-o-n-solution",
                "content": "We don\\'t need sorted sequence. We just need the K smallest negative elements to negate their sign and if we have less than K negative elements  and the left number of operations is odd - choose the smallest positive (or zero) and negate its sign.\\n```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n\\n        nth_element(A.begin(), A.begin() + K, A.end());\\n        int cnt = K;\\n        int minIdx = 0;\\n        \\n        for (int i = 0; i < K; ++i) {\\n            if (A[i] < 0) {\\n                A[i] = -A[i];\\n                cnt--;\\n            }\\n            if (A[i] < A[minIdx]) minIdx = i;\\n        }\\n        if (cnt % 2 != 0) {\\n            A[minIdx] = -A[minIdx];\\n        }\\n        \\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n\\n        nth_element(A.begin(), A.begin() + K, A.end());\\n        int cnt = K;\\n        int minIdx = 0;\\n        \\n        for (int i = 0; i < K; ++i) {\\n            if (A[i] < 0) {\\n                A[i] = -A[i];\\n                cnt--;\\n            }\\n            if (A[i] < A[minIdx]) minIdx = i;\\n        }\\n        if (cnt % 2 != 0) {\\n            A[minIdx] = -A[minIdx];\\n        }\\n        \\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252965,
                "title": "simple-python-heap-solution",
                "content": "Keep negating the minimum value:\\n\\n```\\nimport heapq\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, S, K):\\n        heapq.heapify(S)\\n        for _ in range(K):\\n            v = heapq.heappop(S)\\n            heapq.heappush(S, -v)\\n        return sum(S)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, S, K):\\n        heapq.heapify(S)\\n        for _ in range(K):\\n            v = heapq.heappop(S)\\n            heapq.heappush(S, -v)\\n        return sum(S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622679,
                "title": "c-min-heap-different-approach",
                "content": "**Test on this example:**\\n`[-8,3,-5,-3,-5,-2]` to understand `if (-smallest > -pq.top())`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        // O(n), min heap\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());    \\n\\n        // while smallest numbers are negative\\n        while (k > 0 && pq.top() < 0) {\\n            int smallest = pq.top();\\n            sum -= 2 * smallest;\\n            pq.pop();\\n            if (-smallest > -pq.top())\\n                pq.push(-smallest);\\n            k--;\\n        }\\n        // when all negatives are done, negate the 0 or smallest positive number multiple times\\n        if (k % 2 == 1) sum -= 2*pq.top(); \\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        // O(n), min heap\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());    \\n\\n        // while smallest numbers are negative\\n        while (k > 0 && pq.top() < 0) {\\n            int smallest = pq.top();\\n            sum -= 2 * smallest;\\n            pq.pop();\\n            if (-smallest > -pq.top())\\n                pq.push(-smallest);\\n            k--;\\n        }\\n        // when all negatives are done, negate the 0 or smallest positive number multiple times\\n        if (k % 2 == 1) sum -= 2*pq.top(); \\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496724,
                "title": "c-solution-simple-to-understand",
                "content": "## Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        for(; i<n; i++){\\n            if (k==0)break;\\n            if (nums[i]>=0)break;\\n            nums[i]*= -1;\\n            k--;\\n        }\\n        if (k&1){\\n            if (i-1>=0){\\n                if (abs(nums[i-1])<abs(nums[i]))nums[i-1]*=-1;\\n                else nums[i]*=-1;\\n            }\\n            else nums[i]*=-1;\\n\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            ans+= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        for(; i<n; i++){\\n            if (k==0)break;\\n            if (nums[i]>=0)break;\\n            nums[i]*= -1;\\n            k--;\\n        }\\n        if (k&1){\\n            if (i-1>=0){\\n                if (abs(nums[i-1])<abs(nums[i]))nums[i-1]*=-1;\\n                else nums[i]*=-1;\\n            }\\n            else nums[i]*=-1;\\n\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            ans+= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231286,
                "title": "c-easy-code",
                "content": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue <int, vector<int>, greater<int> > pq;\\n        for(auto it:nums)\\n        {\\n            pq.push(it);\\n        }\\n        vector<int> ans;\\n        int cnt=0,sum=0;\\n        while(cnt!=k)\\n        {\\n            if(pq.top()==0)\\n            {\\n                ans.push_back(0);\\n            }\\n            int x=pq.top();\\n            pq.pop();\\n            int y=(-1)*(x);\\n            pq.push(y);\\n            cnt++;\\n        }\\n        for(auto it:ans)\\n        {\\n            pq.push(it);\\n        }\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue <int, vector<int>, greater<int> > pq;\\n        for(auto it:nums)\\n        {\\n            pq.push(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3062731,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func largestSumAfterKNegations(_ nums: [Int], _ k: Int) -> Int {\\n        \\n        var ns = nums.sorted()\\n        var i = 0\\n        \\n        while i < k, i < nums.count, ns[i] < 0 {\\n            ns[i] = -ns[i]\\n            i += 1\\n        }\\n        \\n        guard i > k || (k - i) % 2 == 1 else { return ns.reduce(0, +) }\\n        \\n        var mi = ns[min(i, ns.count - 1)]\\n        if i > 0, ns[i - 1] < mi { mi = ns[i - 1] }\\n        \\n        return ns.reduce(0, +) - 2 * mi\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestSumAfterKNegations(_ nums: [Int], _ k: Int) -> Int {\\n        \\n        var ns = nums.sorted()\\n        var i = 0\\n        \\n        while i < k, i < nums.count, ns[i] < 0 {\\n            ns[i] = -ns[i]\\n            i += 1\\n        }\\n        \\n        guard i > k || (k - i) % 2 == 1 else { return ns.reduce(0, +) }\\n        \\n        var mi = ns[min(i, ns.count - 1)]\\n        if i > 0, ns[i - 1] < mi { mi = ns[i - 1] }\\n        \\n        return ns.reduce(0, +) - 2 * mi\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971088,
                "title": "1005-java-2-approach",
                "content": "# Complexity\\n- Time complexity || Runtime : 2 ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity || Memory : 42 MB \\n\\n- Beats : 99.10%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            index++;\\n        }\\n        Arrays.sort(nums);\\n        if(k % 2 == 1) ans -= (nums[0] + nums[0]);\\n        return ans;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity || Runtime : 2 ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity || Memory : 41.7 MB \\n\\n- Beats : 99.10%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 2\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0 , min = Integer.MAX_VALUE;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            if(i < min) min = nums[index];\\n            index++;\\n        }\\n        if(k % 2 == 1) ans -= min + min;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            index++;\\n        }\\n        Arrays.sort(nums);\\n        if(k % 2 == 1) ans -= (nums[0] + nums[0]);\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0 , min = Integer.MAX_VALUE;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            if(i < min) min = nums[index];\\n            index++;\\n        }\\n        if(k % 2 == 1) ans -= min + min;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932116,
                "title": "js-javascript-greedy-easy-to-understand-solution",
                "content": "\\n## Optimized Solution\\nTC :\\nSC: \\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {    \\n    nums.sort((a, b) => a - b);\\n    let modify = 0;\\n    let i = 0;\\n    while (k > 0) {\\n        if (nums[i] < nums[modify]) modify = i;\\n        if (i + 1 < nums.length) i ++;\\n        nums[modify] = -nums[modify];\\n        k --;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```\\n\\n\\n## Easy To Understand \\n- slow\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {\\n    let i = 0;\\n    while (i < k) {\\n        nums.sort((a, b) => a - b);\\n        nums[0] = -nums[0];\\n        i ++;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {    \\n    nums.sort((a, b) => a - b);\\n    let modify = 0;\\n    let i = 0;\\n    while (k > 0) {\\n        if (nums[i] < nums[modify]) modify = i;\\n        if (i + 1 < nums.length) i ++;\\n        nums[modify] = -nums[modify];\\n        k --;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {\\n    let i = 0;\\n    while (i < k) {\\n        nums.sort((a, b) => a - b);\\n        nums[0] = -nums[0];\\n        i ++;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2657499,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = 0,i=0,length=nums.size();\\n        sort(nums.begin(), nums.end());\\n        while(nums[i]<0 && i<length){\\n            if(k<=0)\\n                break;\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k>0 && nums[0]!=0)\\n            if(k%2)\\n                nums[0] *= -1;\\n        for(auto x:nums){\\n            sum += x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = 0,i=0,length=nums.size();\\n        sort(nums.begin(), nums.end());\\n        while(nums[i]<0 && i<length){\\n            if(k<=0)\\n                break;\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k>0 && nums[0]!=0)\\n            if(k%2)\\n                nums[0] *= -1;\\n        for(auto x:nums){\\n            sum += x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549142,
                "title": "c-min-heap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n       priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while(k--){\\n            int t=pq.top();pq.pop();\\n            pq.push(t*-1);\\n        }\\n    \\n        int n=0;\\n       while(!pq.empty()){\\n           int t=pq.top();pq.pop();\\n           n+=t;\\n       }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n       priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while(k--){\\n            int t=pq.top();pq.pop();\\n            pq.push(t*-1);\\n        }\\n    \\n        int n=0;\\n       while(!pq.empty()){\\n           int t=pq.top();pq.pop();\\n           n+=t;\\n       }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544881,
                "title": "c-min-heap-explained",
                "content": "\\t*********please upvote if it helps.\\n\\tclass Solution {\\n\\tpublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n      int n=nums.size();\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto x:nums){\\n            pq.push(x);\\n        }\\n\\t\\t//min will at top so if if we push negative of that then only ans will be minimum\\n        while(k--){\\n            int x=pq.top();\\n            pq.pop();\\n            pq.push(-x);\\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n      int n=nums.size();\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto x:nums){\\n            pq.push(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2480046,
                "title": "c-simple-if-else",
                "content": "**hope u find it helpful**\\n\\n\\t int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin() , nums.end());\\n        \\n        while(k > 0)\\n        {\\n           if(nums[0] == 0)\\n           {\\n               break;\\n           }\\n            \\n           else if(nums[0] > 0)\\n            {\\n                k = k%2 ;\\n                if(k)\\n                {\\n                    nums[0] = -nums[0];\\n                    k=0;\\n                }\\n            }\\n            else{\\n                nums[0] = -nums[0];\\n                k--;\\n                sort(nums.begin() , nums.end());\\n            }\\n        }\\n        int sum = 0;\\n        for(auto i:nums)\\n        {\\n            sum += i;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "**hope u find it helpful**\\n\\n\\t int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin() , nums.end());\\n        \\n        while(k > 0)\\n        {\\n           if(nums[0] == 0)\\n           {\\n               break;\\n           }\\n            \\n           else if(nums[0] > 0)\\n            {\\n                k = k%2 ;\\n                if(k)\\n                {\\n                    nums[0] = -nums[0];\\n                    k=0;\\n                }\\n            }\\n            else{\\n                nums[0] = -nums[0];\\n                k--;\\n                sort(nums.begin() , nums.end());\\n            }\\n        }\\n        int sum = 0;\\n        for(auto i:nums)\\n        {\\n            sum += i;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2465321,
                "title": "c-100-beats-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0, n = nums.size();\\n        while((i<n) && k){\\n            if(nums[i]<0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }else{\\n                break;\\n            }\\n            i++;\\n        }\\n        if(k%2){\\n            if(i==n){\\n                nums[i-1] = -nums[i-1];\\n            }\\n            else if(i>0 && nums[i]>nums[i-1]){\\n                nums[i-1] = -nums[i-1];\\n            }else{\\n                nums[i] = -nums[i];\\n            }\\n        }\\n        int sum = 0;\\n        for(auto &i: nums){\\n            // cout<<i<<\" \";\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0, n = nums.size();\\n        while((i<n) && k){\\n            if(nums[i]<0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }else{\\n                break;\\n            }\\n            i++;\\n        }\\n        if(k%2){\\n            if(i==n){\\n                nums[i-1] = -nums[i-1];\\n            }\\n            else if(i>0 && nums[i]>nums[i-1]){\\n                nums[i-1] = -nums[i-1];\\n            }else{\\n                nums[i] = -nums[i];\\n            }\\n        }\\n        int sum = 0;\\n        for(auto &i: nums){\\n            // cout<<i<<\" \";\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2336382,
                "title": "you-have-to-be-greedy-to-understand-greedy",
                "content": "```\\n  int largestSumAfterKNegations(vector<int>& arr, int k) {\\n    \\n        sort(arr.begin(),arr.end());\\n        \\n        //make the negative numbers positve as many you can\\n        int mino=INT_MAX;\\n        for(int i=0;i<arr.size() and k>0;i++)\\n        {\\n            if(arr[i]<0)  //jitne negative numbers ko positive bna skte bnalo\\n            {\\n                arr[i]=-arr[i]; \\n                k--;\\n            }              \\n            mino=min(arr[i],mino);  //min nikalo bcha hua \\'k\\' jo hoga isi number p krege\\n        }\\n        \\n        int sum=0;\\n        for(auto i:arr)\\n            sum+=i;\\n        \\n    //if even k=2 then 2 3 7  --> -2 3 7 --> 2 3 7 even me no change in array same sum \\n//if odd k=3 then 2 3 7 --> -2 3 7 --> 2 3 7 --> -2 3 7 odd me sum-=2*mino sum-=4 \\n        return k%2?sum-2*mino:sum;  \\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n  int largestSumAfterKNegations(vector<int>& arr, int k) {\\n    \\n        sort(arr.begin(),arr.end());\\n        \\n        //make the negative numbers positve as many you can\\n        int mino=INT_MAX;\\n        for(int i=0;i<arr.size() and k>0;i++)\\n        {\\n            if(arr[i]<0)  //jitne negative numbers ko positive bna skte bnalo\\n            {\\n                arr[i]=-arr[i]; \\n                k--;\\n            }              \\n            mino=min(arr[i],mino);  //min nikalo bcha hua \\'k\\' jo hoga isi number p krege\\n        }\\n        \\n        int sum=0;\\n        for(auto i:arr)\\n            sum+=i;\\n        \\n    //if even k=2 then 2 3 7  --> -2 3 7 --> 2 3 7 even me no change in array same sum \\n//if odd k=3 then 2 3 7 --> -2 3 7 --> 2 3 7 --> -2 3 7 odd me sum-=2*mino sum-=4 \\n        return k%2?sum-2*mino:sum;  \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2298751,
                "title": "java-easy-solution-3ms-faster",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (count < k) {\\n                if (nums[i] < 0) {\\n                    nums[i] = -1 * nums[i];\\n                    count++;\\n                }\\n            }\\n        }\\n        if (count < k) {\\n            Arrays.sort(nums);\\n            while (count < k) {\\n                nums[0] = -1 * nums[0];\\n                count++;\\n            }\\n        }\\n\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n\\n        return sum; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (count < k) {\\n                if (nums[i] < 0) {\\n                    nums[i] = -1 * nums[i];\\n                    count++;\\n                }\\n            }\\n        }\\n        if (count < k) {\\n            Arrays.sort(nums);\\n            while (count < k) {\\n                nums[0] = -1 * nums[0];\\n                count++;\\n            }\\n        }\\n\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n\\n        return sum; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118546,
                "title": "c-faster-6ms-run-time-solution",
                "content": "Firstly, we ```sort then convert``` the negative numbers in the array to positive while decreasing \\'k\\' with each operetion...```[first we sort so the grater negative numbers are changed first]```\\n ```-[if in this process the number of opertions is passed we return the sum of the elements]```\\nThen, if all elements are positive we change the sign of the minimum number in the array for the remaining no. of operations and return the total sum. \\n\\n         Runtime: 6 ms, faster than 69.56%\\n    Memory Usage: 9 MB,   less than 65.64% \\n\\n                     \\nCode:\\n\\n                        UPVOTE if you like the Explanition / Solution \\n\\t\\t \\n```\\nclass Solution \\n{\\npublic:\\n    int largestSumAfterKNegations(vector<int>& n, int k) \\n    {\\n        sort(n.begin(),n.end()); //sorting\\n        for(int i=0;i<n.size();i++)\\n        {\\n            if(n[i]<0){n[i]*=-1;k--;}//converting negative elements if any\\n            if(k==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t\\t//at any point if no. of operations is reached we return the present sum\\n        }\\n        if(k%2==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t//if remaining no. of operations are even the minimum element will not change thus we return current total sum\\n        \\n\\t\\t//else no. of operations are odd the least element will change sign....\\n\\t\\t//hence we subtract it twice from total sum\\n\\t\\tint l=*min_element(n.begin(),n.end());\\n        return accumulate(n.begin(),n.end(),0)-(2*l);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```sort then convert```\n```[first we sort so the grater negative numbers are changed first]```\n```-[if in this process the number of opertions is passed we return the sum of the elements]```\n```\\nclass Solution \\n{\\npublic:\\n    int largestSumAfterKNegations(vector<int>& n, int k) \\n    {\\n        sort(n.begin(),n.end()); //sorting\\n        for(int i=0;i<n.size();i++)\\n        {\\n            if(n[i]<0){n[i]*=-1;k--;}//converting negative elements if any\\n            if(k==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t\\t//at any point if no. of operations is reached we return the present sum\\n        }\\n        if(k%2==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t//if remaining no. of operations are even the minimum element will not change thus we return current total sum\\n        \\n\\t\\t//else no. of operations are odd the least element will change sign....\\n\\t\\t//hence we subtract it twice from total sum\\n\\t\\tint l=*min_element(n.begin(),n.end());\\n        return accumulate(n.begin(),n.end(),0)-(2*l);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104403,
                "title": "c-maximize-sum-of-array-after-k-negations",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int largestSumAfterKNegations(vector<int> &nums, int k)\\n        {\\n            sort(nums.begin(), nums.end());\\n            int i = 0;\\n            while (i < nums.size() and nums[i] < 0 and k > 0)\\n            {\\n                nums[i] = -nums[i];\\n                k--;\\n                i++;\\n            }\\n            bool isOdd = k % 2 != 0;\\n            sort(nums.begin(), nums.end());\\n            if (i < nums.size() and isOdd or k > 0 and isOdd)\\n                nums[0] = -nums[0];\\n            int sum = 0;\\n            for (int x: nums)\\n                sum += x;\\n            return sum;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int largestSumAfterKNegations(vector<int> &nums, int k)\\n        {\\n            sort(nums.begin(), nums.end());\\n            int i = 0;\\n            while (i < nums.size() and nums[i] < 0 and k > 0)\\n            {\\n                nums[i] = -nums[i];\\n                k--;\\n                i++;\\n            }\\n            bool isOdd = k % 2 != 0;\\n            sort(nums.begin(), nums.end());\\n            if (i < nums.size() and isOdd or k > 0 and isOdd)\\n                nums[0] = -nums[0];\\n            int sum = 0;\\n            for (int x: nums)\\n                sum += x;\\n            return sum;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100016,
                "title": "java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num : nums)\\n            pq.add(num);\\n        \\n        while(k > 0 && !pq.isEmpty())\\n        {\\n            pq.add(pq.poll() * -1);\\n            k -= 1;\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum += pq.poll();\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num : nums)\\n            pq.add(num);\\n        \\n        while(k > 0 && !pq.isEmpty())\\n        {\\n            pq.add(pq.poll() * -1);\\n            k -= 1;\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum += pq.poll();\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087015,
                "title": "o-n-using-quick-select-and-no-extra-memory",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int l = nums.length;\\n        int minI = 0, minVal, sum=Math.abs(nums[0]),t,s,e;\\n        for(int i=1;i<l;i++) {\\n            if(Math.abs(nums[i])<= Math.abs(nums[minI])) minI = i;\\n            sum+=Math.abs(nums[i]);\\n        }\\n        minVal = Math.abs(nums[minI]);\\n        swap(nums,minI,l-1);\\n        minI = partition(nums,0,l-1);\\n        if(minI<l && nums[minI]< 0) minI++;\\n        if(k>=minI){\\n            if((k-minI)%2==1) sum -=(2* minVal);\\n        }else{\\n            s = 0;e=minI-1;\\n            t=partition(nums,s,e);\\n            while(t!=k-1){\\n                if(t<k-1) s = t+1; else e = t-1;\\n                t=partition(nums,s,e);\\n            }\\n            for(int i =t+1;i<minI;i++) sum+=2*(nums[i]);\\n        }\\n        return sum;\\n    }\\n    \\n    int partition(int[] nums, int start,int end){\\n        int pivotId = end, slow = start, fast = start;\\n        if(nums[pivotId]>=0)\\n        for(;fast<end; fast++) {if(nums[fast]<nums[pivotId]) swap(nums, fast, slow++);}\\n        else\\n        for(;fast<end; fast++) {if(nums[fast]<=nums[pivotId]) swap(nums, fast, slow++);}\\n        swap(nums, pivotId, slow);\\n        return slow;\\n    }\\n    \\n    void swap(int[] nums, int a,int b){\\n        if (nums[a]==nums[b]) return;\\n        nums[a] = nums[a]^nums[b];\\n        nums[b] = nums[a]^nums[b];\\n        nums[a] = nums[a]^nums[b];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int l = nums.length;\\n        int minI = 0, minVal, sum=Math.abs(nums[0]),t,s,e;\\n        for(int i=1;i<l;i++) {\\n            if(Math.abs(nums[i])<= Math.abs(nums[minI])) minI = i;\\n            sum+=Math.abs(nums[i]);\\n        }\\n        minVal = Math.abs(nums[minI]);\\n        swap(nums,minI,l-1);\\n        minI = partition(nums,0,l-1);\\n        if(minI<l && nums[minI]< 0) minI++;\\n        if(k>=minI){\\n            if((k-minI)%2==1) sum -=(2* minVal);\\n        }else{\\n            s = 0;e=minI-1;\\n            t=partition(nums,s,e);\\n            while(t!=k-1){\\n                if(t<k-1) s = t+1; else e = t-1;\\n                t=partition(nums,s,e);\\n            }\\n            for(int i =t+1;i<minI;i++) sum+=2*(nums[i]);\\n        }\\n        return sum;\\n    }\\n    \\n    int partition(int[] nums, int start,int end){\\n        int pivotId = end, slow = start, fast = start;\\n        if(nums[pivotId]>=0)\\n        for(;fast<end; fast++) {if(nums[fast]<nums[pivotId]) swap(nums, fast, slow++);}\\n        else\\n        for(;fast<end; fast++) {if(nums[fast]<=nums[pivotId]) swap(nums, fast, slow++);}\\n        swap(nums, pivotId, slow);\\n        return slow;\\n    }\\n    \\n    void swap(int[] nums, int a,int b){\\n        if (nums[a]==nums[b]) return;\\n        nums[a] = nums[a]^nums[b];\\n        nums[b] = nums[a]^nums[b];\\n        nums[a] = nums[a]^nums[b];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061193,
                "title": "simple-solution-using-sorting-with-explanation",
                "content": "```go\\nfunc largestSumAfterKNegations(nums []int, k int) int {\\n  // First sort the numbers in ascending order\\n  sort.Ints(nums)\\n  // Let\\'s try to make as much negative numbers positive as possible\\n  // and also compute the sum as a result of this.\\n  // We\\'ll also keep track of the minimum element in this loop that we\\'l use later.\\n  var sum int\\n  min := math.MaxInt32\\n  for i := 0; i < len(nums); i++ {\\n    if k > 0 && nums[i] < 0 {\\n      nums[i] = -nums[i]\\n      k--\\n    }\\n    sum += nums[i]\\n    if nums[i] < min {\\n      min = nums[i]\\n    }\\n  }\\n  // We\\'ve applied as much negations on negative numbers. Now we don\\'t have any more\\n  // negative numbers. If k is even, we don\\'t need to do anything because the negations\\n  // cancel out. If it is odd, we\\'ll apply all the remaining negations on the min of the\\n  // result of the previous step.\\n  if k%2 != 0 {\\n    sum -= 2 * min\\n  }\\n  return sum\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```go\\nfunc largestSumAfterKNegations(nums []int, k int) int {\\n  // First sort the numbers in ascending order\\n  sort.Ints(nums)\\n  // Let\\'s try to make as much negative numbers positive as possible\\n  // and also compute the sum as a result of this.\\n  // We\\'ll also keep track of the minimum element in this loop that we\\'l use later.\\n  var sum int\\n  min := math.MaxInt32\\n  for i := 0; i < len(nums); i++ {\\n    if k > 0 && nums[i] < 0 {\\n      nums[i] = -nums[i]\\n      k--\\n    }\\n    sum += nums[i]\\n    if nums[i] < min {\\n      min = nums[i]\\n    }\\n  }\\n  // We\\'ve applied as much negations on negative numbers. Now we don\\'t have any more\\n  // negative numbers. If k is even, we don\\'t need to do anything because the negations\\n  // cancel out. If it is odd, we\\'ll apply all the remaining negations on the min of the\\n  // result of the previous step.\\n  if k%2 != 0 {\\n    sum -= 2 * min\\n  }\\n  return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008660,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/7cad9926-b5d3-458c-9b5c-7130c339fce5_1651692881.4312992.png)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S in place \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heappush(nums, -heapq.heappop(nums)) for _ in range(k)]\\n        return sum(nums)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heapreplace(nums, -nums[0]) for _ in range(k)] # some optimization\\n        return sum(nums)",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/7cad9926-b5d3-458c-9b5c-7130c339fce5_1651692881.4312992.png)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S in place \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heappush(nums, -heapq.heappop(nums)) for _ in range(k)]\\n        return sum(nums)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heapreplace(nums, -nums[0]) for _ in range(k)] # some optimization\\n        return sum(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 1999055,
                "title": "textbook-greedy-problem",
                "content": "```\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(k==0)\\n                break;\\n            if(nums[i]<0){\\n                nums[i]=nums[i]*-1;\\n                k--;\\n            }\\n            else \\n                break;\\n        }\\n        if(k!=0){\\n            sort(nums.begin(),nums.end());\\n            k=k-(k/2)*2;\\n            if(k==1)\\n                nums[0]=nums[0]*-1;\\n        }\\n        int sum = 0;\\n        for(int x:nums){\\n            sum=sum+x;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(k==0)\\n                break;\\n            if(nums[i]<0){\\n                nums[i]=nums[i]*-1;\\n                k--;\\n            }\\n            else \\n                break;\\n        }\\n        if(k!=0){\\n            sort(nums.begin(),nums.end());\\n            k=k-(k/2)*2;\\n            if(k==1)\\n                nums[0]=nums[0]*-1;\\n        }\\n        int sum = 0;\\n        for(int x:nums){\\n            sum=sum+x;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906868,
                "title": "priority-queue-in-js-or-negation-logic-detailed-explanation-with-time-space-complexity-analysis",
                "content": "2 approaches \\n# Priority Queues\\n\\n- First, we put the array into the priority queue pq\\n- For each negation, we try to negate the **smallest** possible element via` num = pq.peak().element`\\n\\t- If the element is positive -> it becomes only negative (since other elements are larger than this)\\n\\t- If the element is negative -> it becomes positive \\n- After that, we enqueue the negated version of it \\n- After the all iterations, sum all elements to get the sum.\\n\\nTime complexity: O(K log N) - K iterations and heap enqueue and dequeue operate in O(logN) \\nSpace complexity: O(N)\\n```\\n\\nvar largestSumAfterKNegations = function(nums, k) {\\n    const pq = new MinPriorityQueue();\\n    let sum = 0;\\n    \\n    nums.map(e => {\\n        pq.enqueue(e);\\n    });\\n        \\n    for (let i = 1; i <= k; i++) {\\n        let num = pq.dequeue().element;\\n        pq.enqueue(-num);\\n    }\\n            \\n    return pq.toArray().reduce((prev, curr) => {\\n        return prev + curr.element;\\n    }, 0);\\n};\\n```\\n\\n# Negating logic\\n- First, we sort the array\\n- Second, we loop through the array and negate the negative values of the array \\n\\t- Case 1, if the negation K <= the numbers of negative value => all the negations are used correctly, since it will produce the largest sum\\n\\t- Case 2, if the negation K > the numbers of negative value \\n\\t\\t- all the negative ones are now positive\\n\\t\\t- we sum all the numbers\\n\\t\\t- we keep track of the smallest positive value since the all the next negations are actually time this number by -1\\n\\t\\t\\t- When it is positive, it is the smallest\\n\\t\\t\\t- When it is negative, it is also the smallest\\n\\t\\t- depending the leftover negation are odd or even\\n\\t\\t\\t- if odd => sum = sum - (smallest * 2) \\n\\t\\t\\t- if even => sum = sum\\n\\t\\nTime complexity: O(NlogN)\\nSpace complexity: O(1)\\n\\n```\\nvar largestSumAfterKNegations = (A, K) => {\\n    A.sort((a, b) => a - b);\\n    \\n    let negations = 0, sum = 0, smallest = A[0];\\n    \\n    for (let i = 0; i < A.length; i++) {\\n        if (A[i] < 0 && negations < K) {\\n            A[i] = -A[i];\\n            negations++;\\n        }\\n        \\n        sum += A[i];\\n        smallest = Math.min(smallest, A[i]);\\n    }\\n    \\n    return (K - negations) % 2 === 0 ? sum : sum - (smallest * 2);\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nvar largestSumAfterKNegations = function(nums, k) {\\n    const pq = new MinPriorityQueue();\\n    let sum = 0;\\n    \\n    nums.map(e => {\\n        pq.enqueue(e);\\n    });\\n        \\n    for (let i = 1; i <= k; i++) {\\n        let num = pq.dequeue().element;\\n        pq.enqueue(-num);\\n    }\\n            \\n    return pq.toArray().reduce((prev, curr) => {\\n        return prev + curr.element;\\n    }, 0);\\n};\\n```\n```\\nvar largestSumAfterKNegations = (A, K) => {\\n    A.sort((a, b) => a - b);\\n    \\n    let negations = 0, sum = 0, smallest = A[0];\\n    \\n    for (let i = 0; i < A.length; i++) {\\n        if (A[i] < 0 && negations < K) {\\n            A[i] = -A[i];\\n            negations++;\\n        }\\n        \\n        sum += A[i];\\n        smallest = Math.min(smallest, A[i]);\\n    }\\n    \\n    return (K - negations) % 2 === 0 ? sum : sum - (smallest * 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1852427,
                "title": "priority-queue-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        h = []\\n        for num in nums:\\n            heappush(h, num)\\n        while k:\\n            num = heappop(h)\\n            heappush(h, -num)\\n            k -= 1\\n        return sum(h)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        h = []\\n        for num in nums:\\n            heappush(h, num)\\n        while k:\\n            num = heappop(h)\\n            heappush(h, -num)\\n            k -= 1\\n        return sum(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831321,
                "title": "c-simple-concise-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (auto &n: nums) pq.push(n);\\n        for (;k--;) {\\n            int x = pq.top();\\n            pq.pop();\\n            pq.push(x * -1);\\n        }\\n        int ans = 0;\\n        for (;!pq.empty(); ans += pq.top(), pq.pop());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (auto &n: nums) pq.push(n);\\n        for (;k--;) {\\n            int x = pq.top();\\n            pq.pop();\\n            pq.push(x * -1);\\n        }\\n        int ans = 0;\\n        for (;!pq.empty(); ans += pq.top(), pq.pop());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763840,
                "title": "greedy-java-o-n-k-log-n",
                "content": "First toggle the signs of as many negative numbers as you can, starting from the smallest negative number as the smallest negative number will be the largest one (when you toggle the sign of any negative number) and will contribute more to the sum.\\nIn case there is no more negative numbers and `k>0`, toggle the sign of the smallest number k times. So if `k%2==0` there is ultimately no change to the sign of that number, else it becomes negative.\\n\\n```\\npublic int largestSumAfterKNegations1(int[] nums, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue();\\n        int sum=0;\\n        \\n        for(int i:nums){\\n            pq.add(i);\\n            sum+=i;\\n        }\\n        \\n        while(k>0 && pq.peek()<0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n            k--;\\n        }\\n        if(k>0 && k%2!=0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int largestSumAfterKNegations1(int[] nums, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue();\\n        int sum=0;\\n        \\n        for(int i:nums){\\n            pq.add(i);\\n            sum+=i;\\n        }\\n        \\n        while(k>0 && pq.peek()<0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n            k--;\\n        }\\n        if(k>0 && k%2!=0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715780,
                "title": "fastest-but-complex-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            //System.out.println(i+\" \"+count);\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }\\n                else\\n                {\\n                    count+=i;\\n                }\\n                //System.out.println(count+\" \"+k);\\n            }\\n            else if(i==0)\\n            {\\n                k=0;\\n            }\\n            else\\n            {\\n                //System.out.println(count+\" \"+k);\\n                if(k%2==0)\\n                {\\n                    count+=i;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    if(prev==0)\\n                    {\\n                        count+=(-1*i);\\n                        k=0;\\n                    }\\n                    else\\n                    {\\n                        if(prev>i || Math.abs(prev)>i)\\n                        {\\n                            count+=(-1*i);\\n                        }\\n                        else\\n                        {\\n                            count+=prev;\\n                            count+=(prev + i);\\n                        }\\n                        k=0;\\n                    }\\n                }\\n            }\\n        }\\n        if(k%2!=0)\\n        {\\n            count+=(prev + prev);\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            //System.out.println(i+\" \"+count);\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1701952,
                "title": "c-very-simple-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n\\t\\t//negate the minimum element\\n        //start negating negative element \\n\\t\\t//can also use min heap\\n        sort(nums.begin(),nums.end());\\n        \\n        int i=0;\\n        while(k--)\\n        {\\n            nums[i]=-nums[i];\\n            //decesion to increment i -> this is trick\\n            i++;\\n            if(i==nums.size() || nums[i]>nums[i-1]) i--;\\n        }\\n        \\n        int sum=0;\\n        sum=accumulate(nums.begin(),nums.end(),sum);  //sum of all elements\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n\\t\\t//negate the minimum element\\n        //start negating negative element \\n\\t\\t//can also use min heap\\n        sort(nums.begin(),nums.end());\\n        \\n        int i=0;\\n        while(k--)\\n        {\\n            nums[i]=-nums[i];\\n            //decesion to increment i -> this is trick\\n            i++;\\n            if(i==nums.size() || nums[i]>nums[i-1]) i--;\\n        }\\n        \\n        int sum=0;\\n        sum=accumulate(nums.begin(),nums.end(),sum);  //sum of all elements\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644297,
                "title": "c-greedy-with-intuition",
                "content": "intuition : First of all sort the vector and then check if the element at the 0th position is negative (say -a ) ,then replace it by -(-a) and decrement the value of k by 1 else if its 0 then keep it as it is and decrement the value of k by k i.e now k=0 ; else if the 0th element is positive then replace the element by -(a) and decrement k by 1.Do the same until k becomes 0. And finally return the sum of all elemnts .\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int i=0;\\n        while(k!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n            if(nums[i]<0)\\n            {\\n                nums[i]= -nums[i];\\n                k--;\\n            }\\n            else if(nums[i]==0)\\n            {\\n                nums[i]=nums[i];\\n                k=k-k;\\n            }\\n            else\\n            {\\n                nums[i]=-nums[i];\\n                k--;\\n            }\\n        }\\n        int sum=0;\\n        for(auto i:nums)\\n            sum+=i;\\n        return sum;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int i=0;\\n        while(k!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n            if(nums[i]<0)\\n            {\\n                nums[i]= -nums[i];\\n                k--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1640773,
                "title": "maximize-sum-of-array-after-k-negations-c-easy-solution",
                "content": "**Please Upvote \\n If you Liked solution**\\n\\n\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] < 0 && k!=0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }\\n        }\\n        long long int sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            sum += nums[i];\\n        }\\n        if(k%2!=0){\\n            sum = sum - (*min_element(nums.begin(),nums.end())*2);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] < 0 && k!=0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1624514,
                "title": "here-is-my-c-cpp-solutionon-0ms-beats-100-other-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        vector<int>neg;\\n        vector<int>ans;\\n        bool z = false;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                neg.push_back(nums[i]);\\n            }\\n            else\\n                ans.push_back(nums[i]);\\n            if(nums[i] == 0)\\n                z = true;\\n        }\\n        sort(neg.begin(),neg.end());\\n        for(int i = 0;i<neg.size() and k>0;i++)\\n        {\\n            neg[i] *= -1;\\n            k--;\\n        }\\n        for(int i = 0;i<neg.size();i++)\\n        {\\n            ans.push_back(neg[i]);\\n        }\\n        k %= 2;\\n        if(k == 0)return accumulate(ans.begin(),ans.end(),0);\\n        if(k)\\n        {\\n            if(z)\\n            {\\n                return accumulate(ans.begin(),ans.end(),0);\\n            }\\n        }\\n        int mn = *min_element(ans.begin(),ans.end());\\n        for(int i = 0;i<ans.size();i++)\\n        {\\n            if(ans[i] == mn)\\n            {\\n                ans[i] *= -1;\\n                break;\\n            }\\n        }\\n        int sum = accumulate(ans.begin(),ans.end(),0);\\n        return sum;\\n    }\\n};\\nIf you like the solution Please upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        vector<int>neg;\\n        vector<int>ans;\\n        bool z = false;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                neg.push_back(nums[i]);\\n            }\\n            else\\n                ans.push_back(nums[i]);\\n            if(nums[i] == 0)\\n                z = true;\\n        }\\n        sort(neg.begin(),neg.end());\\n        for(int i = 0;i<neg.size() and k>0;i++)\\n        {\\n            neg[i] *= -1;\\n            k--;\\n        }\\n        for(int i = 0;i<neg.size();i++)\\n        {\\n            ans.push_back(neg[i]);\\n        }\\n        k %= 2;\\n        if(k == 0)return accumulate(ans.begin(),ans.end(),0);\\n        if(k)\\n        {\\n            if(z)\\n            {\\n                return accumulate(ans.begin(),ans.end(),0);\\n            }\\n        }\\n        int mn = *min_element(ans.begin(),ans.end());\\n        for(int i = 0;i<ans.size();i++)\\n        {\\n            if(ans[i] == mn)\\n            {\\n                ans[i] *= -1;\\n                break;\\n            }\\n        }\\n        int sum = accumulate(ans.begin(),ans.end(),0);\\n        return sum;\\n    }\\n};\\nIf you like the solution Please upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607986,
                "title": "k-nlog-n-time-complexicity-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n        while(k != 0){\\n            sort(nums.begin(), nums.end());\\n            nums[0] = -nums[0];\\n            k -= 1;    \\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)sum += nums[i];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n        while(k != 0){\\n            sort(nums.begin(), nums.end());\\n            nums[0] = -nums[0];\\n            k -= 1;    \\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)sum += nums[i];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587950,
                "title": "python-40ms-faster-than-95-simplest-logic-no-extra-edge-cases",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        i=0\\n        n = len(nums)\\n        while(i<n and k>0):\\n            if nums[i]<0:\\n                #make it positive\\n                nums[i] = -nums[i]\\n                k-=1\\n                i+=1\\n            elif nums[i]>=0:\\n                break\\n        if k%2==1:\\n            return sum(nums)-2*(min(nums))\\n        else:\\n            return sum(nums)\\n\\t\\t\\t#if k is odd, we will have to take the minimum element 2k+1 times\\n\\t\\t\\t#if its even, we can take whole nums, as it has k nonnegative values\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        i=0\\n        n = len(nums)\\n        while(i<n and k>0):\\n            if nums[i]<0:\\n                #make it positive\\n                nums[i] = -nums[i]\\n                k-=1\\n                i+=1\\n            elif nums[i]>=0:\\n                break\\n        if k%2==1:\\n            return sum(nums)-2*(min(nums))\\n        else:\\n            return sum(nums)\\n\\t\\t\\t#if k is odd, we will have to take the minimum element 2k+1 times\\n\\t\\t\\t#if its even, we can take whole nums, as it has k nonnegative values\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570660,
                "title": "c-o-n-time-85-faster-with-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(auto i: a) pq.push(i);\\n        while(k--) {\\n            int t = pq.top();\\n            pq.pop();\\n            t *= -1;\\n            pq.push(t);\\n        }\\n        int sum = 0;\\n        while(pq.size()) {\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(auto i: a) pq.push(i);\\n        while(k--) {\\n            int t = pq.top();\\n            pq.pop();\\n            t *= -1;\\n            pq.push(t);\\n        }\\n        int sum = 0;\\n        while(pq.size()) {\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519826,
                "title": "c-0ms-stl-accumulate-min-element-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int ops) {//ops => operations remaining\\n\\t\\tsort(a.begin(),a.end());//sort will bring negative elements at the starting\\n        for(int i=0;i<a.size();i++){\\n            if(ops>0&&a[i]<0)a[i]=-a[i],ops--; //turning smallest negative numbers into positive numbers\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Turning -5 -> 5 is better rather than -2 -> 2\\n\\t\\t\\t\\tif(ops==0){         //If run out of operations, stop\\n                return accumulate(a.begin(),a.end(),0);  //sum all elements to 0\\n            }\\n        }\\n\\t\\t//at this point there will be no negative elements remaining in the vector\\n\\t\\t//if number of operations are even, we can change any same element\\'s sign and it will not affect the result\\n        if(ops%2==0)return accumulate(a.begin(),a.end(),0);\\n\\t\\t\\n\\t\\t//if we have odd operations, we can turn smallest number to negative\\n        return accumulate(a.begin(),a.end(),0) -2* (*min_element(a.begin(),a.end()));\\n\\t\\t//We have already counted the positive/zero number in sum, hence subtracting twice\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int ops) {//ops => operations remaining\\n\\t\\tsort(a.begin(),a.end());//sort will bring negative elements at the starting\\n        for(int i=0;i<a.size();i++){\\n            if(ops>0&&a[i]<0)a[i]=-a[i],ops--; //turning smallest negative numbers into positive numbers\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Turning -5 -> 5 is better rather than -2 -> 2\\n\\t\\t\\t\\tif(ops==0){         //If run out of operations, stop\\n                return accumulate(a.begin(),a.end(),0);  //sum all elements to 0\\n            }\\n        }\\n\\t\\t//at this point there will be no negative elements remaining in the vector\\n\\t\\t//if number of operations are even, we can change any same element\\'s sign and it will not affect the result\\n        if(ops%2==0)return accumulate(a.begin(),a.end(),0);\\n\\t\\t\\n\\t\\t//if we have odd operations, we can turn smallest number to negative\\n        return accumulate(a.begin(),a.end(),0) -2* (*min_element(a.begin(),a.end()));\\n\\t\\t//We have already counted the positive/zero number in sum, hence subtracting twice\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424648,
                "title": "python3-nice-trick-faster-than-97-09-memory-less-than-81-00",
                "content": "Explanation:\\nCheck if the array is just a positive numbers, if yes then if k is even then this would not affect anything otherwise flip the minimun element.\\n\\nif there is negative elements in the array, sort the array with absolute value[no importance for the sign] then start from the last element which is the larger one in his absolute value, if this element is negative then flip his sign and decrease k by 1\\nif you reach the minimum element and k != 0 then we have more move to make, in this case if k is even then as usual it has no affect otherwise flip his sign then sum up all the elements.\\n\\n![image](https://assets.leetcode.com/users/images/1cdf6bd7-42a5-4a18-bcc5-31b3ab1dfddb_1629865210.0578444.png)\\n\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\n        less = False\\n        for i in nums:\\n            if i < 0:\\n                less = True\\n                break\\n        \\n        nums.sort(key = lambda x : abs(x))\\n\\n        if not less:\\n            if k % 2 == 0:\\n                return sum(nums)\\n            else:\\n                return sum(nums[1:]) - nums[0]\\n\\n        i = len(nums) - 1\\n        while(k > 0):\\n            if nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n            i -= 1\\n\\n            if i == 0 and k > 0:\\n                if nums[0] > 0:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n                else:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n\\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\n        less = False\\n        for i in nums:\\n            if i < 0:\\n                less = True\\n                break\\n        \\n        nums.sort(key = lambda x : abs(x))\\n\\n        if not less:\\n            if k % 2 == 0:\\n                return sum(nums)\\n            else:\\n                return sum(nums[1:]) - nums[0]\\n\\n        i = len(nums) - 1\\n        while(k > 0):\\n            if nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n            i -= 1\\n\\n            if i == 0 and k > 0:\\n                if nums[0] > 0:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n                else:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n\\n        return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420953,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size() && k>0; i++)\\n        {\\n           if(nums[i]>=0)\\n               break;\\n            nums[i]*=-1;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k%2)\\n            nums[0]*=-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size() && k>0; i++)\\n        {\\n           if(nums[i]>=0)\\n               break;\\n            nums[i]*=-1;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k%2)\\n            nums[0]*=-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395789,
                "title": "python3-priority-queue-very-easy",
                "content": "\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\t\\t\\theapq.heapify(nums)\\n\\t\\t\\twhile k > 0:\\n\\t\\t\\t\\tval=heapq.heappop(nums)\\n\\t\\t\\t\\tval *=  -1\\n\\t\\t\\t\\theapq.heappush(nums,val)\\n\\t\\t\\t\\tk = k -1\\n\\t\\t\\treturn sum(nums)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\t\\t\\theapq.heapify(nums)\\n\\t\\t\\twhile k > 0:\\n\\t\\t\\t\\tval=heapq.heappop(nums)\\n\\t\\t\\t\\tval *=  -1\\n\\t\\t\\t\\theapq.heappush(nums,val)\\n\\t\\t\\t\\tk = k -1\\n\\t\\t\\treturn sum(nums)",
                "codeTag": "Java"
            },
            {
                "id": 1388198,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344662,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(), nums.end());\\n        while(k>0){\\n            k--;\\n            nums[0]=-nums[0];\\n            sort(nums.begin(), nums.end());\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            ans += nums[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(), nums.end());\\n        while(k>0){\\n            k--;\\n            nums[0]=-nums[0];\\n            sort(nums.begin(), nums.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1340418,
                "title": "easy-to-understand-java-beats-99-87",
                "content": "```class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int i=0;\\n        while(i<nums.length && nums[i]<0 && k>0){\\n            nums[i]= -nums[i];\\n            i++;\\n            k--;\\n        }\\n        \\n        if(k>0 && k%2==1){\\n            Arrays.sort(nums);\\n            nums[0]= -nums[0];\\n        }\\n        \\n        int res=0;\\n        for(int n : nums){\\n            res+=n;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int i=0;\\n        while(i<nums.length && nums[i]<0 && k>0){\\n            nums[i]= -nums[i];\\n            i++;\\n            k--;\\n        }\\n        \\n        if(k>0 && k%2==1){\\n            Arrays.sort(nums);\\n            nums[0]= -nums[0];\\n        }\\n        \\n        int res=0;\\n        for(int n : nums){\\n            res+=n;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1331217,
                "title": "c-code",
                "content": "```\\nint largestSumAfterKNegations(vector<int>& v, int k) {\\n        sort(v.begin(), v.end());\\n        \\n        int count{};\\n        //counting negative numbers\\n        for(int i = 0 ; i < v.size(); i++){\\n           if(v[i] >= 0) break;\\n            count++;\\n        }\\n        \\n        //if negative numbers are more than k\\n        if(count > k){ \\n        for(int i = 0; i < k; i++){\\n            v[i] = -v[i];\\n        }}\\n        //negative numbers less than k\\n        else{\\n            int i = 0;\\n            for(; i < count; i++){\\n               v[i] = -v[i];\\n               k--;\\n            } \\n            //k%2 to decrease the value of k\\n             k = k%2;\\n            if(k > 0){\\n             if(i==0 && k > 0) v[0] = -v[0];\\n             else if(v[i] < v[i-1] && k > 0) v[i] = -v[i];\\n             else v[i-1] = -v[i-1];}\\n           }\\n        \\n        int sum{};\\n        for(auto val : v){\\n           sum += val; \\n        }\\n        \\n        return sum;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\nint largestSumAfterKNegations(vector<int>& v, int k) {\\n        sort(v.begin(), v.end());\\n        \\n        int count{};\\n        //counting negative numbers\\n        for(int i = 0 ; i < v.size(); i++){\\n           if(v[i] >= 0) break;\\n            count++;\\n        }\\n        \\n        //if negative numbers are more than k\\n        if(count > k){ \\n        for(int i = 0; i < k; i++){\\n            v[i] = -v[i];\\n        }}\\n        //negative numbers less than k\\n        else{\\n            int i = 0;\\n            for(; i < count; i++){\\n               v[i] = -v[i];\\n               k--;\\n            } \\n            //k%2 to decrease the value of k\\n             k = k%2;\\n            if(k > 0){\\n             if(i==0 && k > 0) v[0] = -v[0];\\n             else if(v[i] < v[i-1] && k > 0) v[i] = -v[i];\\n             else v[i-1] = -v[i-1];}\\n           }\\n        \\n        int sum{};\\n        for(auto val : v){\\n           sum += val; \\n        }\\n        \\n        return sum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1305157,
                "title": "java-quick-sort-faster-than-99-66",
                "content": "I am a newbie just learnt quick sort. If you know any algorithm which can make it even faster, please tell me and I will appreciate it!\\n\\n```\\npublic class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int length = nums.length;\\n        int negNum = 0;\\n        boolean[] neg = new boolean[length];\\n        for (int i = 0; i < length; i++)\\n            if (nums[i] < 0) {\\n                neg[i] = true;\\n                negNum++;\\n                nums[i] = -nums[i];\\n            }\\n\\n        quickSort(neg, nums, 0, length - 1);\\n\\n        if (k < negNum) {\\n            int reverse = 0;\\n            for (int i = 0; i < length; i++) {\\n                if (k <= reverse) {\\n                    for (int j = i; j < length; j++)\\n                        if (neg[j])\\n                            nums[j] = -nums[j];\\n\\n                    break;\\n                }\\n                else {\\n                    if (neg[i])\\n                        reverse++;\\n                }\\n            }\\n        }\\n        else {\\n            k = (k - negNum) % 2;\\n            if (k == 1)\\n                nums[length - 1] = -nums[length - 1];\\n        }\\n\\n        int answer = 0;\\n        for (int i = 0; i < length; i++)\\n            answer += nums[i];\\n\\n        return answer;\\n    }\\n\\n    public static void quickSort(boolean[] neg, int[] arr, int start, int end) {\\n        if (start >= end) return;\\n\\n        int pivot = arr[start];\\n        int i = start, j = end;\\n\\n        while (i != j) {\\n            while (i < j && arr[j] <= pivot)\\n                j--;\\n            swap(neg, arr, i, j);\\n            while (i < j && arr[i] >= pivot)\\n                i++;\\n            swap(neg, arr, i, j);\\n        }\\n\\n        quickSort(neg, arr, start, i-1);\\n        quickSort(neg, arr, i+1, end);\\n    }\\n\\n    public static void swap(boolean[] neg, int[] arr, int a, int b) {\\n        int c = arr[a];\\n        boolean cb = neg[a];\\n\\n        arr[a] = arr[b];\\n        neg[a] = neg[b];\\n\\n        arr[b] = c;\\n        neg[b] = cb;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int length = nums.length;\\n        int negNum = 0;\\n        boolean[] neg = new boolean[length];\\n        for (int i = 0; i < length; i++)\\n            if (nums[i] < 0) {\\n                neg[i] = true;\\n                negNum++;\\n                nums[i] = -nums[i];\\n            }\\n\\n        quickSort(neg, nums, 0, length - 1);\\n\\n        if (k < negNum) {\\n            int reverse = 0;\\n            for (int i = 0; i < length; i++) {\\n                if (k <= reverse) {\\n                    for (int j = i; j < length; j++)\\n                        if (neg[j])\\n                            nums[j] = -nums[j];\\n\\n                    break;\\n                }\\n                else {\\n                    if (neg[i])\\n                        reverse++;\\n                }\\n            }\\n        }\\n        else {\\n            k = (k - negNum) % 2;\\n            if (k == 1)\\n                nums[length - 1] = -nums[length - 1];\\n        }\\n\\n        int answer = 0;\\n        for (int i = 0; i < length; i++)\\n            answer += nums[i];\\n\\n        return answer;\\n    }\\n\\n    public static void quickSort(boolean[] neg, int[] arr, int start, int end) {\\n        if (start >= end) return;\\n\\n        int pivot = arr[start];\\n        int i = start, j = end;\\n\\n        while (i != j) {\\n            while (i < j && arr[j] <= pivot)\\n                j--;\\n            swap(neg, arr, i, j);\\n            while (i < j && arr[i] >= pivot)\\n                i++;\\n            swap(neg, arr, i, j);\\n        }\\n\\n        quickSort(neg, arr, start, i-1);\\n        quickSort(neg, arr, i+1, end);\\n    }\\n\\n    public static void swap(boolean[] neg, int[] arr, int a, int b) {\\n        int c = arr[a];\\n        boolean cb = neg[a];\\n\\n        arr[a] = arr[b];\\n        neg[a] = neg[b];\\n\\n        arr[b] = c;\\n        neg[b] = cb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272999,
                "title": "python-simple-heap-solution-o-nlogk",
                "content": "```python\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:        \\n        heapify(nums)\\n        while nums[0] < 0 and k:\\n            heappush(nums, -heappop(nums))\\n            k -= 1\\n        if k%2:\\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:        \\n        heapify(nums)\\n        while nums[0] < 0 and k:\\n            heappush(nums, -heappop(nums))\\n            k -= 1\\n        if k%2:\\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1265322,
                "title": "o-n-min-k-n-logn-no-sort-only-negatives-in-minheap-and-some-idea-for-special-case-o-n-d",
                "content": "```\\n\\t\\t# O(N+min(K,N)*logN) idea -> divide into positive and negative nums\\n        # make two heaps, try to always remove most negative and make \\n        # him positive, if over then take smallest positive\\n        # and make it neg, if odd count\\n        # if even count just discard\\n        res = 0\\n        negs = [x for x in nums if x < 0]\\n        heapify(negs)\\n        minPos = min([x for x in nums if x >= 0])\\n\\n        \\n        while negs and k:\\n            k -= 1\\n            v = -(heappop(negs))\\n            nums.append(v) # he is now a positive number so he\\n            minPos = min(minPos, v) #  is included in minPos (testcase 78)!\\n            \\n        if negs and k==0:\\n            return  sum(negs) + sum([x for x in nums if x > 0])\\n        \\n        elif k % 2:\\n            return res + sum([x for x in nums if x >= 0]) - 2*minPos\\n        \\n        return  sum([x for x in nums if x >= 0])\\n    \\n    \\n        # can do quickselect for K smallest.. negs O(Negs) but too lazy\\n        # another optimization, if K > no. of negatives THEN no \\n        # q needed!!! just add all absolute values - min abs() \\n        # and return  :D\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\t\\t# O(N+min(K,N)*logN) idea -> divide into positive and negative nums\\n        # make two heaps, try to always remove most negative and make \\n        # him positive, if over then take smallest positive\\n        # and make it neg, if odd count\\n        # if even count just discard\\n        res = 0\\n        negs = [x for x in nums if x < 0]\\n        heapify(negs)\\n        minPos = min([x for x in nums if x >= 0])\\n\\n        \\n        while negs and k:\\n            k -= 1\\n            v = -(heappop(negs))\\n            nums.append(v) # he is now a positive number so he\\n            minPos = min(minPos, v) #  is included in minPos (testcase 78)!\\n            \\n        if negs and k==0:\\n            return  sum(negs) + sum([x for x in nums if x > 0])\\n        \\n        elif k % 2:\\n            return res + sum([x for x in nums if x >= 0]) - 2*minPos\\n        \\n        return  sum([x for x in nums if x >= 0])\\n    \\n    \\n        # can do quickselect for K smallest.. negs O(Negs) but too lazy\\n        # another optimization, if K > no. of negatives THEN no \\n        # q needed!!! just add all absolute values - min abs() \\n        # and return  :D\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1254689,
                "title": "simple-java-solution-easy-to-understand",
                "content": "For every bit remain the cur % 10, and check (cur * 2 + bit) % 5 == 0.\\n\\n```java\\n// AC: Runtime: 3 ms, faster than 59.64% of Java online submissions for Binary Prefix Divisible By 5.\\n// Memory Usage: 39.6 MB, less than 54.20% of Java online submissions for Binary Prefix Divisible By 5.\\n// every bit remain the cur % 10, and check (cur * 2 + bit) % 5 == 0.\\n// T:O(n), S:O(1)\\n//\\nclass Solution {\\n    public List<Boolean> prefixesDivBy5(int[] nums) {\\n        List<Boolean> ret = new LinkedList<>();\\n        int cur = 0;\\n        for (int num : nums) {\\n            cur = cur * 2 + num;\\n            ret.add(cur % 5 == 0);\\n            cur %= 10;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// AC: Runtime: 3 ms, faster than 59.64% of Java online submissions for Binary Prefix Divisible By 5.\\n// Memory Usage: 39.6 MB, less than 54.20% of Java online submissions for Binary Prefix Divisible By 5.\\n// every bit remain the cur % 10, and check (cur * 2 + bit) % 5 == 0.\\n// T:O(n), S:O(1)\\n//\\nclass Solution {\\n    public List<Boolean> prefixesDivBy5(int[] nums) {\\n        List<Boolean> ret = new LinkedList<>();\\n        int cur = 0;\\n        for (int num : nums) {\\n            cur = cur * 2 + num;\\n            ret.add(cur % 5 == 0);\\n            cur %= 10;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243544,
                "title": "c-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());        \\n        \\n        while(k-- != 0) {\\n            int x = pq.top();\\n            \\n            pq.pop();\\n            x *= -1;\\n            pq.push(x);\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());        \\n        \\n        while(k-- != 0) {\\n            int x = pq.top();\\n            \\n            pq.pop();\\n            x *= -1;\\n            pq.push(x);\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243074,
                "title": "c-simple-easy-to-understand-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        while(k--)\\n        {\\n            int x=pq.top();\\n            pq.pop();\\n            x=x*(-1);\\n            pq.push(x);\\n            \\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        while(k--)\\n        {\\n            int x=pq.top();\\n            pq.pop();\\n            x=x*(-1);\\n            pq.push(x);\\n            \\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228053,
                "title": "simple-readable-java-code-beats-99-60-time-o-nlogn",
                "content": "```\\nclass Solution { \\n    public int largestSumAfterKNegations(int[] nums, int k) {    \\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int l = 0;\\n        while(l<nums.length && k>=1){\\n            if(nums[l]<0){\\n                nums[l]=(-1)*nums[l];\\n                k--;\\n                l++;\\n            }\\n            else{\\n               break;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        if(nums[0]==0 || k==0){\\n            for(int i=0; i<nums.length; i++){\\n                ans = ans + nums[i];\\n            }\\n        } \\n        else{  \\n            if(k%2==0){\\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n            }\\n            else{  \\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n                ans = ans-2*(nums[0]);\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    public int largestSumAfterKNegations(int[] nums, int k) {    \\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int l = 0;\\n        while(l<nums.length && k>=1){\\n            if(nums[l]<0){\\n                nums[l]=(-1)*nums[l];\\n                k--;\\n                l++;\\n            }\\n            else{\\n               break;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        if(nums[0]==0 || k==0){\\n            for(int i=0; i<nums.length; i++){\\n                ans = ans + nums[i];\\n            }\\n        } \\n        else{  \\n            if(k%2==0){\\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n            }\\n            else{  \\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n                ans = ans-2*(nums[0]);\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223059,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n                if(nums[i]<0 ){\\n                        if(k>0){\\n                                nums[i]=-nums[i];\\n                                k--;\\n                        }\\n                        else{\\n                                break;\\n                        }\\n                }\\n        }\\n            int res=0;\\n            for(int x:nums){\\n                    res+=x;\\n            }\\n            cout<<res;\\n            if(k==0 or k%2==0){\\n                    return res;\\n            }\\n            sort(nums.begin(),nums.end());\\n            res=res-2*nums[0];\\n            return res;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n                if(nums[i]<0 ){\\n                        if(k>0){\\n                                nums[i]=-nums[i];\\n                                k--;\\n                        }\\n                        else{\\n                                break;\\n                        }\\n                }\\n        }\\n            int res=0;\\n            for(int x:nums){\\n                    res+=x;\\n            }\\n            cout<<res;\\n            if(k==0 or k%2==0){\\n                    return res;\\n            }\\n            sort(nums.begin(),nums.end());\\n            res=res-2*nums[0];\\n            return res;\\n            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1184981,
                "title": "java-o-nlogn-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i = 0;\\n       while(K > 0) {\\n           if(A[i] > 0) {\\n               if(K % 2 == 0)\\n                   K = 0;\\n               else {\\n                   A[i] = -1*A[i];\\n                   K = 0;\\n               }\\n           }\\n           else if(A[i] < 0){\\n               if(i + 1 != A.length && A[i + 1] > 0 && A[i + 1] > -1*A[i]) {\\n                   K--;\\n                   if(K % 2 == 0) {\\n                       A[i] = -1* A[i];\\n                       K = 0;\\n                       \\n                   }\\n                   else{\\n                       K = 0;\\n                       }\\n               }\\n               else{\\n               A[i] = -1* A[i];\\n               K--;\\n               i++;\\n               }\\n           }\\n           else{\\n               K = 0;\\n           }\\n       }\\n        int sum = 0;\\n        for(int j = 0; j < A.length; j++) {\\n            sum += A[j];\\n        }\\n        return sum;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i = 0;\\n       while(K > 0) {\\n           if(A[i] > 0) {\\n               if(K % 2 == 0)\\n                   K = 0;\\n               else {\\n                   A[i] = -1*A[i];\\n                   K = 0;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1155292,
                "title": "c-0ms-100-basket-sort-with-comments",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximize Sum Of Array After K Negations.\\nMemory Usage: 9.1 MB, less than 41.00% of C++ online submissions for Maximize Sum Of Array After K Negations.\\n**General idea:** \\n1. Use basket sort and contain all numbers into array table\\n2. Travers through negative numbers and do two operation : transforme (K negative numbers) and find the greater negative number (flag - for mark : we transform all negative numbers or not) and culculate total sum\\n3.  Travers through positive numbers : culculate total sum and find the minimal positive number.\\n4.  After these if we have K is even or we have 0 in array - our sum is answer;\\n in other case we check mn and mp (minimal negative and minimal positive number) and delete minimal from sum. \\n\\n```\\nclass Solution {\\npublic:\\n  int largestSumAfterKNegations(vector<int>& A, int K) {\\n    int table[201] = {0}, sum = 0, i = 0, j = -100, mn = -1000, mp = 1000;\\n    bool flag = false;\\n    \\n    for(int i = 0 ; i != A.size(); i++) table[A[i] + 100]++;\\n    \\n    for(;i != 100 && K;i++,j++){\\n      if(table[i]){\\n        mn = j;\\n        if(K >= table[i]) {sum -= j*table[i]; K -= table[i];} \\n        else {sum -= j*K; sum += j*(table[i] - K); K = 0; flag = true;} \\n      }\\n    }\\n    for(;i != 100;i++,j++){\\n      if(table[i]){\\n        flag = true;\\n        mn = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n    i = 200, j = 100;\\n    for(;j ;i--,j--){\\n      if(table[i]){\\n        mp = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n   \\n    if(table[100] || K%2 == 0) return sum;\\n    if(!flag || mn == -1000) mn = -mn;\\n   \\n    return mp < mn ? sum - mp*2 : sum - mn*2;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int largestSumAfterKNegations(vector<int>& A, int K) {\\n    int table[201] = {0}, sum = 0, i = 0, j = -100, mn = -1000, mp = 1000;\\n    bool flag = false;\\n    \\n    for(int i = 0 ; i != A.size(); i++) table[A[i] + 100]++;\\n    \\n    for(;i != 100 && K;i++,j++){\\n      if(table[i]){\\n        mn = j;\\n        if(K >= table[i]) {sum -= j*table[i]; K -= table[i];} \\n        else {sum -= j*K; sum += j*(table[i] - K); K = 0; flag = true;} \\n      }\\n    }\\n    for(;i != 100;i++,j++){\\n      if(table[i]){\\n        flag = true;\\n        mn = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n    i = 200, j = 100;\\n    for(;j ;i--,j--){\\n      if(table[i]){\\n        mp = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n   \\n    if(table[100] || K%2 == 0) return sum;\\n    if(!flag || mn == -1000) mn = -mn;\\n   \\n    return mp < mn ? sum - mp*2 : sum - mn*2;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100048,
                "title": "really-simple-solution-using-a-min-heap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        int total = accumulate(A.begin(), A.end(), 0);\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        for(int i : A)  q.push(i);\\n        while(k--){\\n            int t = q.top();\\n            q.pop();\\n            q.push((-t));\\n            total = total + ((-t) - t);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        int total = accumulate(A.begin(), A.end(), 0);\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        for(int i : A)  q.push(i);\\n        while(k--){\\n            int t = q.top();\\n            q.pop();\\n            q.push((-t));\\n            total = total + ((-t) - t);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078815,
                "title": "faster-than-100-percent-c",
                "content": "sort(A.begin(),A.end());\\n        int n=A.size();\\n        int i;\\n        int sum=0;\\n        int negative_c=0;\\n        if(A[0]>=0&&k%2==0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n        }\\n        else if(A[0]>=0&&k%2==1)\\n        {\\n             for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n            sum-=A[0];\\n            sum-=A[0];\\n        }\\n        else \\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                if(A[i]<0)\\n                {\\n                    negative_c++;\\n                }\\n            }\\n            if(negative_c==k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    sum+=abs(A[i]);\\n                }\\n            }\\n            else if(negative_c>k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    if(k>0&&A[i]<0)\\n                    {\\n                        sum+=abs(A[i]);\\n                        k--;\\n                    }\\n                    else if(k<=0)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n            }\\n            else if(k>negative_c)\\n            {\\n                k=k-negative_c;\\n                for(i=0;i<n;i++)\\n                {\\n                    A[i]=abs(A[i]);\\n                }\\n                sort(A.begin(),A.end());\\n                if(k%2==0)\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n                else\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                    sum-=A[0];\\n                    sum-=A[0];\\n                }\\n            }\\n        }\\n        return sum;",
                "solutionTags": [],
                "code": "sort(A.begin(),A.end());\\n        int n=A.size();\\n        int i;\\n        int sum=0;\\n        int negative_c=0;\\n        if(A[0]>=0&&k%2==0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n        }\\n        else if(A[0]>=0&&k%2==1)\\n        {\\n             for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n            sum-=A[0];\\n            sum-=A[0];\\n        }\\n        else \\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                if(A[i]<0)\\n                {\\n                    negative_c++;\\n                }\\n            }\\n            if(negative_c==k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    sum+=abs(A[i]);\\n                }\\n            }\\n            else if(negative_c>k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    if(k>0&&A[i]<0)\\n                    {\\n                        sum+=abs(A[i]);\\n                        k--;\\n                    }\\n                    else if(k<=0)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n            }\\n            else if(k>negative_c)\\n            {\\n                k=k-negative_c;\\n                for(i=0;i<n;i++)\\n                {\\n                    A[i]=abs(A[i]);\\n                }\\n                sort(A.begin(),A.end());\\n                if(k%2==0)\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n                else\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                    sum-=A[0];\\n                    sum-=A[0];\\n                }\\n            }\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 986268,
                "title": "faster-than-99-of-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i] < 0 && K>0)   // if element is negative, reverse it until k iterations\\n            {\\n                A[i]=A[i]*(-1);\\n                K--;\\n            }\\n        }\\n        int index=min_element(A.begin(),A.end())-A.begin(); // find index of minimum element\\n        \\n        if(K%2==1)   // if k is even, no change in array required.. if odd, then reverse                           // smallest\\n        {\\n            A[index]=A[index]*(-1);\\n          \\n        }\\n        int sum=0;\\n\\n        for(auto it:A)\\n            sum+=it;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i] < 0 && K>0)   // if element is negative, reverse it until k iterations\\n            {\\n                A[i]=A[i]*(-1);\\n                K--;\\n            }\\n        }\\n        int index=min_element(A.begin(),A.end())-A.begin(); // find index of minimum element\\n        \\n        if(K%2==1)   // if k is even, no change in array required.. if odd, then reverse                           // smallest\\n        {\\n            A[index]=A[index]*(-1);\\n          \\n        }\\n        int sum=0;\\n\\n        for(auto it:A)\\n            sum+=it;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976835,
                "title": "sort-and-then-one-pass",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i=0,s=0;\\n        while(K>0 && A[i]<0)\\n        {\\n            s-=A[i];\\n            K--;\\n            i++;\\n        }\\n        if(A[0]<0 && K%2!=0 && A[i]!=0)\\n        {\\n            if(-A[i-1]<A[i])\\n            {\\n                s+=2*A[i-1];\\n            }\\n            else\\n            {\\n                s-=A[i++];\\n            }\\n        }\\n        else if(A[i]!=0 && K%2!=0)\\n        {\\n            s-=A[i++];\\n        }\\n        for(;i<A.length;i++)\\n        {\\n            s+=A[i];\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i=0,s=0;\\n        while(K>0 && A[i]<0)\\n        {\\n            s-=A[i];\\n            K--;\\n            i++;\\n        }\\n        if(A[0]<0 && K%2!=0 && A[i]!=0)\\n        {\\n            if(-A[i-1]<A[i])\\n            {\\n                s+=2*A[i-1];\\n            }\\n            else\\n            {\\n                s-=A[i++];\\n            }\\n        }\\n        else if(A[i]!=0 && K%2!=0)\\n        {\\n            s-=A[i++];\\n        }\\n        for(;i<A.length;i++)\\n        {\\n            s+=A[i];\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890598,
                "title": "python-heap-time-o-n-k-ln-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            a = heapq.heappop(A)\\n            heapq.heappush(A, -a)        \\n        return sum(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            a = heapq.heappop(A)\\n            heapq.heappush(A, -a)        \\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857619,
                "title": "c-simple-o-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size(),sum=0,neg=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            if(A[i]<0)\\n                neg++;\\n        }\\n      \\n        if(neg>=k)\\n            for(int i=0;i<k;i++)\\n                A[i]*=-1;\\n        else{\\n            for(int i=0;i<neg;i++)\\n                A[i]*=-1;\\n            k-=neg;\\n            sort(A.begin(),A.end());    \\n            if(k%2!=0)\\n                A[0]*=-1;\\n            }\\n       \\n        for(int i=0;i<n;i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size(),sum=0,neg=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            if(A[i]<0)\\n                neg++;\\n        }\\n      \\n        if(neg>=k)\\n            for(int i=0;i<k;i++)\\n                A[i]*=-1;\\n        else{\\n            for(int i=0;i<neg;i++)\\n                A[i]*=-1;\\n            k-=neg;\\n            sort(A.begin(),A.end());    \\n            if(k%2!=0)\\n                A[0]*=-1;\\n            }\\n       \\n        for(int i=0;i<n;i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854867,
                "title": "go-solution-with-sort",
                "content": "https://github.com/phea/leetcode-go\\n```go\\nfunc largestSumAfterKNegations(A []int, K int) int {\\n\\tsort.Ints(A)\\n\\tvar pos int\\n\\tfor K > 0 {\\n\\t\\tif A[pos] == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif pos < len(A)-1 {\\n\\t\\t\\tif (A[pos] < 0 && A[pos+1] < 0) || A[pos]*-1 > A[pos+1] {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t\\tpos++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tA[pos] *= -1\\n\\t\\t}\\n\\n\\t\\tK--\\n\\t}\\n\\n\\tvar total int\\n\\tfor _, n := range A {\\n\\t\\ttotal += n\\n\\t}\\n\\n\\treturn total\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc largestSumAfterKNegations(A []int, K int) int {\\n\\tsort.Ints(A)\\n\\tvar pos int\\n\\tfor K > 0 {\\n\\t\\tif A[pos] == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif pos < len(A)-1 {\\n\\t\\t\\tif (A[pos] < 0 && A[pos+1] < 0) || A[pos]*-1 > A[pos+1] {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t\\tpos++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tA[pos] *= -1\\n\\t\\t}\\n\\n\\t\\tK--\\n\\t}\\n\\n\\tvar total int\\n\\tfor _, n := range A {\\n\\t\\ttotal += n\\n\\t}\\n\\n\\treturn total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845908,
                "title": "java-brutal-force",
                "content": "I don\\'t think this should be an easy quesiton.\\n```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int m = A.length, neg = 0, min = Integer.MAX_VALUE, sum = 0;\\n        for (int n : A) {\\n            if (n < 0) neg++;\\n            else min = Math.min(n, min);  //find the min to keep turning;\\n            sum += n;\\n        }\\n        if (neg != 0) {\\n            if (neg > K) { // find the smallest negs to turn to positive;\\n                PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);  // min queue\\n                for (int n : A) {\\n                    if (n < 0) pq.offer(n);\\n                    if (pq.size() > K) pq.poll();\\n                }\\n                while (!pq.isEmpty()) sum -= 2 * pq.poll();\\n                return sum;\\n            }\\n            K -= neg;  // turn all neg to positive;\\n            for (int n : A) {\\n                if (n < 0) {\\n                    n *= -1;\\n                    sum += n * 2;\\n                }\\n                min = Math.min(n, min);\\n            }\\n        }\\n        if (K % 2 == 0) return sum;\\n        return sum - 2 * min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int m = A.length, neg = 0, min = Integer.MAX_VALUE, sum = 0;\\n        for (int n : A) {\\n            if (n < 0) neg++;\\n            else min = Math.min(n, min);  //find the min to keep turning;\\n            sum += n;\\n        }\\n        if (neg != 0) {\\n            if (neg > K) { // find the smallest negs to turn to positive;\\n                PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);  // min queue\\n                for (int n : A) {\\n                    if (n < 0) pq.offer(n);\\n                    if (pq.size() > K) pq.poll();\\n                }\\n                while (!pq.isEmpty()) sum -= 2 * pq.poll();\\n                return sum;\\n            }\\n            K -= neg;  // turn all neg to positive;\\n            for (int n : A) {\\n                if (n < 0) {\\n                    n *= -1;\\n                    sum += n * 2;\\n                }\\n                min = Math.min(n, min);\\n            }\\n        }\\n        if (K % 2 == 0) return sum;\\n        return sum - 2 * min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840510,
                "title": "very-simple-pyhon3-solution-using-sort-faster-than-50-46",
                "content": "```\\n\\t\\tfor i in range(K):\\n            A.sort()\\n            A[0] = 0 - A[0]\\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tfor i in range(K):\\n            A.sort()\\n            A[0] = 0 - A[0]\\n        return sum(A)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753996,
                "title": "python-with-explanation-on-greedy",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        #globally optimal strategy:\\n        #if there are negative nums, pick all of these, and pick the smaller ones first\\n        # if there are no negative nums, pick and stick to the smallest one\\n        A.sort()\\n        index = 0\\n        for i in range(len(A)): \\n            if K == 0: \\n                return sum(A)\\n            if A[i] < 0: \\n                A[i] = -A[i]\\n                K -= 1\\n            elif A[i] >= 0: # no more negative nums in A anymore\\n                #look for the smallest num in A\\n                index = A.index(min(A))\\n                break\\n        if K%2 != 0: \\n            A[index] = -A[index]\\n        return sum(A)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        #globally optimal strategy:\\n        #if there are negative nums, pick all of these, and pick the smaller ones first\\n        # if there are no negative nums, pick and stick to the smallest one\\n        A.sort()\\n        index = 0\\n        for i in range(len(A)): \\n            if K == 0: \\n                return sum(A)\\n            if A[i] < 0: \\n                A[i] = -A[i]\\n                K -= 1\\n            elif A[i] >= 0: # no more negative nums in A anymore\\n                #look for the smallest num in A\\n                index = A.index(min(A))\\n                break\\n        if K%2 != 0: \\n            A[index] = -A[index]\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753524,
                "title": "c-o-n-time-o-1-space-using-nth-element",
                "content": "```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        bool flag_zero = 0;\\n        int max_sum = 0;\\n        int min_el = INT_MAX;\\n        \\n        std::nth_element(A.begin(), A.begin() + K, A.end());\\n        \\n        for (int x : A) {\\n            min_el = std::min(min_el, std::abs(x));\\n            \\n            if (x == 0)\\n                flag_zero = 1;\\n            \\n            if (K > 0 && x < 0) {\\n                max_sum -= x;\\n                K--;\\n            } else\\n                max_sum += x;\\n        }\\n        \\n        if (flag_zero || K % 2 == 0)\\n            return max_sum;\\n        \\n        return max_sum - 2 * min_el;    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        bool flag_zero = 0;\\n        int max_sum = 0;\\n        int min_el = INT_MAX;\\n        \\n        std::nth_element(A.begin(), A.begin() + K, A.end());\\n        \\n        for (int x : A) {\\n            min_el = std::min(min_el, std::abs(x));\\n            \\n            if (x == 0)\\n                flag_zero = 1;\\n            \\n            if (K > 0 && x < 0) {\\n                max_sum -= x;\\n                K--;\\n            } else\\n                max_sum += x;\\n        }\\n        \\n        if (flag_zero || K % 2 == 0)\\n            return max_sum;\\n        \\n        return max_sum - 2 * min_el;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 752030,
                "title": "java-99-88",
                "content": "class Solution {\\n\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum =0;\\n        int i=0;\\n        int index=0;\\n        while(K-- >0){\\n            index=i;\\n            if(A[i]>A[i+1]){\\n                i++;\\n                index=i;\\n            }\\n            A[index]=-A[index];\\n        }\\n        for(int a:A){\\n            sum+=a;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum =0;\\n        int i=0;\\n        int index=0;\\n        while(K-- >0){\\n            index=i;\\n            if(A[i]>A[i+1]){\\n                i++;\\n                index=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 744515,
                "title": "java-with-comments-using-priority-queue-very-short-and-simple",
                "content": "```\\n public int largestSumAfterKNegations(int[] A, int K) {    \\n    PriorityQueue<Integer>  minHeap = new  PriorityQueue<Integer>();     \\n    for ( int a : A ) minHeap.add(a);\\n    // for K times , pick the smallest element , multiple by -1 andd into PQ .\\n    // replace A[i] with -A[i], and we repeat this process K times in total.\\n    while( K-- > 0 )  minHeap.add((-1)*minHeap.remove());    \\n    // Now add all elements , which will give max sum .        \\n    int sum =0 ;\\n    while(!minHeap.isEmpty()) sum+= minHeap.remove();\\n    return(sum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int largestSumAfterKNegations(int[] A, int K) {    \\n    PriorityQueue<Integer>  minHeap = new  PriorityQueue<Integer>();     \\n    for ( int a : A ) minHeap.add(a);\\n    // for K times , pick the smallest element , multiple by -1 andd into PQ .\\n    // replace A[i] with -A[i], and we repeat this process K times in total.\\n    while( K-- > 0 )  minHeap.add((-1)*minHeap.remove());    \\n    // Now add all elements , which will give max sum .        \\n    int sum =0 ;\\n    while(!minHeap.isEmpty()) sum+= minHeap.remove();\\n    return(sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732238,
                "title": "simple-python-solution-sort-by-absolute-value",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(key=abs, reverse=True)\\n        k = 0\\n        for i in range(len(A)):\\n            if A[i] < 0:\\n                A[i] = -A[i]\\n                k += 1\\n            if k >= K:\\n                return sum(A)\\n        if (K - k) % 2 == 1:\\n            A[-1] = -A[-1]\\n        return sum(A)\\n```\\nWorks well with very large K.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(key=abs, reverse=True)\\n        k = 0\\n        for i in range(len(A)):\\n            if A[i] < 0:\\n                A[i] = -A[i]\\n                k += 1\\n            if k >= K:\\n                return sum(A)\\n        if (K - k) % 2 == 1:\\n            A[-1] = -A[-1]\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671331,
                "title": "java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        int i = 0;\\n        while(A[i] < 0 && K > 0) {\\n            A[i] = -1 * A[i];\\n            i++;\\n            K--;\\n        }\\n        Arrays.sort(A);\\n        if(K % 2 == 1) {\\n            A[0] = -1 * A[0];\\n        }\\n        for(int j = 0; j < A.length; j++) {\\n            sum += A[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        int i = 0;\\n        while(A[i] < 0 && K > 0) {\\n            A[i] = -1 * A[i];\\n            i++;\\n            K--;\\n        }\\n        Arrays.sort(A);\\n        if(K % 2 == 1) {\\n            A[0] = -1 * A[0];\\n        }\\n        for(int j = 0; j < A.length; j++) {\\n            sum += A[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649806,
                "title": "easy-to-understand-solution-c",
                "content": "The solution is to invert the negative numbers first (as many as possible), so that sum becomes larger. After all the negatives are inverted and we still have K > 0, check for following:\\n* If K is even, return the sum of the array (as no negatives are present at this point)\\n* If K is odd, we need to change sign only for minimum element in current array (so subtract twice of that minimum element from new sum calculated)\\n\\nHope this helps for someone! : )\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        for(int i=0;i<A.size() && K>0 && A[i]<0;i++,K--)\\n            A[i] = -A[i];\\n        int sum = 0, minVal = INT_MAX;\\n        for(int x : A){\\n            sum += x;\\n            minVal = min(x,minVal);\\n        }\\n        if(K & 1)\\n            return (sum - 2 * minVal);\\n        else\\n            return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        for(int i=0;i<A.size() && K>0 && A[i]<0;i++,K--)\\n            A[i] = -A[i];\\n        int sum = 0, minVal = INT_MAX;\\n        for(int x : A){\\n            sum += x;\\n            minVal = min(x,minVal);\\n        }\\n        if(K & 1)\\n            return (sum - 2 * minVal);\\n        else\\n            return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645310,
                "title": "java-2-different-solutions-accepted",
                "content": "ok lets do this!\\n\\nFirst of all this is a problem which can solved using **Greedy Algorithm**!\\nwhy?\\n\\n# intuiton-\\n**we are said to negate an element of the array for k times,and maximise the sum of the array elements!\\nso basically what should come to mind immediately that we should negate the smallest number in the array so that our maximum gets decreased as little as possible!\\nhence we are greedily choosing the lowest element at each iteration !**\\n\\nfirst thing that comes to mind is that we should sort the array in ascending order!\\nthat is correct ,but remember k can be greater than one ,hence we need to sort the array for each iteration of k;\\n\\ncode-\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    Arrays.sort(A);\\n        int t=0;\\n        while(K-- > 0)\\n        {\\n     t=A[0];    //each time choosing the smallest element\\n    A[0]=-t;\\n            Arrays.sort(A);\\n        }\\n        \\n        int s=0;\\n        for(int i  :A)\\n        {\\n            s+=i;\\n        }\\n        return s;       \\n    }\\n}\\n```\\n\\nthis solution does the job but we are sorting the array k times,hence the runtime will be higher!\\n\\nwe can get through this problem of sorting everytime by using a **priority queue**!\\nthe priority queue will itself maintain its first element as the lowest one!\\n\\ncode-\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    \\n        PriorityQueue<Integer> q = new PriorityQueue<>();  //queue will maintain ascending order \\n        for(int k :  A)\\n        {\\n            q.add(k);\\n        }\\n    \\n    \\n    while(K-- > 0)\\n    {\\n       int x=q.poll();\\n        q.add(-x);  //adding the negative value of the lowest element\\n    }\\n    int s=0;\\n        \\n       while(!q.isEmpty())\\n        {\\n            s+=q.poll() ;\\n        }\\n   return s;\\n    }\\n}\\n```\\n\\n\\nhope it helps!\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    Arrays.sort(A);\\n        int t=0;\\n        while(K-- > 0)\\n        {\\n     t=A[0];    //each time choosing the smallest element\\n    A[0]=-t;\\n            Arrays.sort(A);\\n        }\\n        \\n        int s=0;\\n        for(int i  :A)\\n        {\\n            s+=i;\\n        }\\n        return s;       \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    \\n        PriorityQueue<Integer> q = new PriorityQueue<>();  //queue will maintain ascending order \\n        for(int k :  A)\\n        {\\n            q.add(k);\\n        }\\n    \\n    \\n    while(K-- > 0)\\n    {\\n       int x=q.poll();\\n        q.add(-x);  //adding the negative value of the lowest element\\n    }\\n    int s=0;\\n        \\n       while(!q.isEmpty())\\n        {\\n            s+=q.poll() ;\\n        }\\n   return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633557,
                "title": "simpla-java-priority-queue-implementation",
                "content": "Though Process\\n1. Each time we need to flip smallest number\\n2. To Track smallest number use priority queue\\n3. Alternatively you can use loop to track smallest number but it will be tedious to do so\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        int sum=0;\\n        for(int i=0;i<A.length;i++)\\n        {\\n            q.offer(A[i]);\\n            sum=sum+A[i];\\n        }\\n        for(int i=1;i<=K;i++)\\n        {\\n            int item=q.poll();\\n            sum=sum-item;\\n            q.offer(-item);\\n            sum=sum-item;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        int sum=0;\\n        for(int i=0;i<A.length;i++)\\n        {\\n            q.offer(A[i]);\\n            sum=sum+A[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 629515,
                "title": "python-3-heap-97-runtime",
                "content": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        \\n        while(K>0):\\n            min_v = heapq.heappop(A)\\n            heapq.heappush(A, min_v * -1)\\n            K -= 1\\n            \\n        return sum(A)",
                "solutionTags": [],
                "code": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        \\n        while(K>0):\\n            min_v = heapq.heappop(A)\\n            heapq.heappush(A, min_v * -1)\\n            K -= 1\\n            \\n        return sum(A)",
                "codeTag": "Java"
            },
            {
                "id": 610700,
                "title": "cpp-simple-priority-queue-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int> > q(begin(A),end(A));\\n        int x;\\n        while(K--){\\n            x=q.top();\\n            q.pop();\\n            q.push(-x);\\n        }\\n        int s=0;\\n        while(!q.empty()){\\n            s+=q.top();\\n            q.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int> > q(begin(A),end(A));\\n        int x;\\n        while(K--){\\n            x=q.top();\\n            q.pop();\\n            q.push(-x);\\n        }\\n        int s=0;\\n        while(!q.empty()){\\n            s+=q.top();\\n            q.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595661,
                "title": "python-easy-to-understand",
                "content": "```\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(K):\\n            index = A.index(min(A))\\n            A[index] = -A[index]\\n        return sum(A)\\n\\n```\\n\\n************* If helped dont forget to give it a star******************",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(K):\\n            index = A.index(min(A))\\n            A[index] = -A[index]\\n        return sum(A)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590356,
                "title": "c-solution-partial-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        // if there is a single item inverse the item K times \\n        if (1 == A.size())\\n            return 0 == K % 2 ? A[0] : -A[0];\\n        \\n        // use partial sort to set at most K items in order\\n        std::partial_sort(A.begin(), A.begin() + std::min(static_cast<int>(A.size()), K), A.end());\\n        \\n        // inverse by negating at most K negative items\\n        auto it = A.begin();\\n        for (; it != A.end() && *it < 0 && 0 != K; ++it, --K)\\n            *it = -*it;\\n        \\n        // if there is an odd number of inversions left\\n        // and the iterator does not address \\'0\\' value\\n        // we continue maximization by selecting\\n        // an item that the negation of will result in\\n        // the topmost maximum of the sum\\n        if (0 != K % 2 && (it == A.end() || 0 != *it))\\n        {\\n            // if the pointer is at the end then the original array consisted of\\n            // only negative numbers, then we need to inverse the last modified item\\n            // to maximize the sum\\n            if (A.end() == it)\\n                --it;\\n            // if the pointer is at a middle we need to\\n            // decide between two adjacent items which one could result better in the ultimate sum\\n            // be aware, in the modified array order could be violated since negations might have taken place\\n            // in the above\\n            // if the pointer is at the beginning then the array consists of only positive numbers\\n            // then we need to only inverse the first since it is the smallest\\n            else if (A.begin() != it)\\n                it = std::min(it - 1, it, [](auto a, auto b){ return *a < *b; });\\n            *it = -*it;\\n        }\\n        \\n        // summarize the result array\\n        return std::accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        // if there is a single item inverse the item K times \\n        if (1 == A.size())\\n            return 0 == K % 2 ? A[0] : -A[0];\\n        \\n        // use partial sort to set at most K items in order\\n        std::partial_sort(A.begin(), A.begin() + std::min(static_cast<int>(A.size()), K), A.end());\\n        \\n        // inverse by negating at most K negative items\\n        auto it = A.begin();\\n        for (; it != A.end() && *it < 0 && 0 != K; ++it, --K)\\n            *it = -*it;\\n        \\n        // if there is an odd number of inversions left\\n        // and the iterator does not address \\'0\\' value\\n        // we continue maximization by selecting\\n        // an item that the negation of will result in\\n        // the topmost maximum of the sum\\n        if (0 != K % 2 && (it == A.end() || 0 != *it))\\n        {\\n            // if the pointer is at the end then the original array consisted of\\n            // only negative numbers, then we need to inverse the last modified item\\n            // to maximize the sum\\n            if (A.end() == it)\\n                --it;\\n            // if the pointer is at a middle we need to\\n            // decide between two adjacent items which one could result better in the ultimate sum\\n            // be aware, in the modified array order could be violated since negations might have taken place\\n            // in the above\\n            // if the pointer is at the beginning then the array consists of only positive numbers\\n            // then we need to only inverse the first since it is the smallest\\n            else if (A.begin() != it)\\n                it = std::min(it - 1, it, [](auto a, auto b){ return *a < *b; });\\n            *it = -*it;\\n        }\\n        \\n        // summarize the result array\\n        return std::accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574462,
                "title": "c-100-fast-o-k-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        int index=0;\\n        int i=0;\\n        int min=INT_MAX;\\n        int sum=0;\\n            while(A[i]<0 && K)\\n            {\\n                A[i]=-A[i];\\n                if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n                K--;\\n                i++;\\n            }\\n            \\n              if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n              if(K%2==1)\\n                A[index]=-A[index];\\n                \\n        for(int i=0;i<A.size();i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        int index=0;\\n        int i=0;\\n        int min=INT_MAX;\\n        int sum=0;\\n            while(A[i]<0 && K)\\n            {\\n                A[i]=-A[i];\\n                if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n                K--;\\n                i++;\\n            }\\n            \\n              if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n              if(K%2==1)\\n                A[index]=-A[index];\\n                \\n        for(int i=0;i<A.size();i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530233,
                "title": "c-solution-use-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int,vector<int>,greater<int>> q;\\n        for(int i:A)q.push(i);\\n        int res=0;\\n        while(K--){\\n            if(q.top()==0)break;\\n            int k=q.top();q.pop();\\n            q.push(k*-1);\\n        }\\n        while(!q.empty()){\\n            res+=q.top();q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int,vector<int>,greater<int>> q;\\n        for(int i:A)q.push(i);\\n        int res=0;\\n        while(K--){\\n            if(q.top()==0)break;\\n            int k=q.top();q.pop();\\n            q.push(k*-1);\\n        }\\n        while(!q.empty()){\\n            res+=q.top();q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507282,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        i = 0\\n        while K > 0:\\n            A[i] = -A[i]\\n            if A[i] > A[i+1]:\\n                i = i+1\\n            K = K-1\\n            \\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        i = 0\\n        while K > 0:\\n            A[i] = -A[i]\\n            if A[i] > A[i+1]:\\n                i = i+1\\n            K = K-1\\n            \\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495271,
                "title": "a-c-python-3-solution-recursion-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        # print(\" A = \", A)\\n        # print(\"K = \", K)\\n\\n        if (K == 0):\\n            return sum(A)\\n        elif (K == 1):\\n\\n            A[0] = 0-A[0]\\n            return sum(A)\\n        elif (K > 1):\\n\\n            A[0] = 0-A[0]\\n            return self.largestSumAfterKNegations(A, K-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        # print(\" A = \", A)\\n        # print(\"K = \", K)\\n\\n        if (K == 0):\\n            return sum(A)\\n        elif (K == 1):\\n\\n            A[0] = 0-A[0]\\n            return sum(A)\\n        elif (K > 1):\\n\\n            A[0] = 0-A[0]\\n            return self.largestSumAfterKNegations(A, K-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484496,
                "title": "java-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        if(A == null || A.length == 0)\\n            return 0;\\n        int sum = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(int num : A)\\n            pq.add(num);\\n        while(K>0)\\n        {\\n            int num = pq.poll();\\n            pq.add(num*-1);\\n            K--;\\n        }\\n        while(!pq.isEmpty())\\n        {\\n            sum+=pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        if(A == null || A.length == 0)\\n            return 0;\\n        int sum = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(int num : A)\\n            pq.add(num);\\n        while(K>0)\\n        {\\n            int num = pq.poll();\\n            pq.add(num*-1);\\n            K--;\\n        }\\n        while(!pq.isEmpty())\\n        {\\n            sum+=pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451306,
                "title": "o-klogn-solution",
                "content": "Data Structure Used : \\n\\tMin-Heap\\nLogic : \\n\\t  &nbsp; 1) If minimum element is negative, we just change sign of that element and push back into min heap.\\n\\t&nbsp; 2) If minimum element in the array is non negative: ( Base case )\\n\\t\\t&nbsp; &nbsp; a) if K is even:\\n\\t\\t\\t&nbsp; &nbsp; We can just use same index for changing sign even number of times, so our answer is just sum of the array.\\n\\t\\t&nbsp; &nbsp; b) If K is odd:\\n\\t\\t\\t&nbsp; &nbsp; We can do same as before, hence K odd is as good as K  = 1, so we just change sign of minimum element.\\n\\n\\nPython3 Code : \\n\\n```\\nimport heapq \\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        while K:\\n            if A[0] >= 0:\\n                if K & 1:\\n                    heapq.heappush(A,-1*heapq.heappop(A))                    \\n                break\\n            else:\\n                heapq.heappush(A,-1*heapq.heappop(A))                      \\n            K -= 1\\n        return sum(A)\\n```\\nTime Complexity   :   O(N+KLogN)\\nSpace Complexity  :  O(1)",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq \\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        while K:\\n            if A[0] >= 0:\\n                if K & 1:\\n                    heapq.heappush(A,-1*heapq.heappop(A))                    \\n                break\\n            else:\\n                heapq.heappush(A,-1*heapq.heappop(A))                      \\n            K -= 1\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429423,
                "title": "java-greedy-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] A, int K) {\\n\\t\\t\\tQueue<Integer> q = new PriorityQueue<>();\\n\\t\\t\\tfor(int a:A) q.add(a);\\n\\t\\t\\twhile(K>0){\\n\\t\\t\\t\\tq.add(-q.poll());\\n\\t\\t\\t\\tK--;\\n\\t\\t\\t}\\n\\t\\t\\tint res = 0;\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tres += q.poll();\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] A, int K) {\\n\\t\\t\\tQueue<Integer> q = new PriorityQueue<>();\\n\\t\\t\\tfor(int a:A) q.add(a);\\n\\t\\t\\twhile(K>0){\\n\\t\\t\\t\\tq.add(-q.poll());\\n\\t\\t\\t\\tK--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 424914,
                "title": "simple-heap-solution",
                "content": "```\\ndef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\th = heapq.heapify(A)\\n\\tfor _ in range(K):\\n\\t\\tm = heapq.heappop(A)\\n\\t\\theapq.heappush(A, -m)\\n\\treturn sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\th = heapq.heapify(A)\\n\\tfor _ in range(K):\\n\\t\\tm = heapq.heappop(A)\\n\\t\\theapq.heappush(A, -m)\\n\\treturn sum(A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 383851,
                "title": "java-solution-2ms-87-faster-with-comments",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int k) {\\n        /*\\n            Greedy\\n        */\\n        \\n        // first sort the array\\n        Arrays.sort(A);\\n        \\n        /*\\n            keep fliping the negative values in the array, until \\n                there is no more negative values or\\n                k reaches zero or\\n                we are at the end of the array\\n        */\\n        int index = 0;\\n        for (; index < A.length; ++index) {\\n            if (k > 0 && A[index] < 0) {\\n                k--;\\n                A[index] = -A[index];\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        /*\\n            at this stage, if k is even, we just skip this step and calculate the sum\\n            if k is odd, \\n                if index is zero, which means whole array are all positive numbers at the begining, we simply flip the first value\\n                if index >= A.length, we are at the end of the array, flip the last value in the array\\n                if A[index] >= A[index - 1], we are at middle of the array, and we want to flip the smallest value in the array\\n                which is either A[index], or A[index - 1], so we compare them and flip the smaller one\\n        */\\n        if (k % 2 != 0) {\\n            if (index == 0) A[index] = -A[index]; \\n            else if (index >= A.length || A[index] >= A[index - 1]) A[index - 1] = -A[index - 1];\\n            else A[index] = -A[index];\\n        }\\n        \\n        int sum = 0;\\n        for (int i : A) {\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int k) {\\n        /*\\n            Greedy\\n        */\\n        \\n        // first sort the array\\n        Arrays.sort(A);\\n        \\n        /*\\n            keep fliping the negative values in the array, until \\n                there is no more negative values or\\n                k reaches zero or\\n                we are at the end of the array\\n        */\\n        int index = 0;\\n        for (; index < A.length; ++index) {\\n            if (k > 0 && A[index] < 0) {\\n                k--;\\n                A[index] = -A[index];\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        /*\\n            at this stage, if k is even, we just skip this step and calculate the sum\\n            if k is odd, \\n                if index is zero, which means whole array are all positive numbers at the begining, we simply flip the first value\\n                if index >= A.length, we are at the end of the array, flip the last value in the array\\n                if A[index] >= A[index - 1], we are at middle of the array, and we want to flip the smallest value in the array\\n                which is either A[index], or A[index - 1], so we compare them and flip the smaller one\\n        */\\n        if (k % 2 != 0) {\\n            if (index == 0) A[index] = -A[index]; \\n            else if (index >= A.length || A[index] >= A[index - 1]) A[index - 1] = -A[index - 1];\\n            else A[index] = -A[index];\\n        }\\n        \\n        int sum = 0;\\n        for (int i : A) {\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1714633,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1929395,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1835017,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1752530,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 2028770,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1941381,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1876946,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1828596,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1724874,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1699153,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1714633,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1929395,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1835017,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1752530,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 2028770,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1941381,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1876946,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1828596,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1724874,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1699153,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            }
        ]
    }
]