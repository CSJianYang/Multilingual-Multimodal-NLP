[
    {
        "title": "Rearranging Fruits",
        "question_content": "You have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays basket1 and basket2 representing the cost of fruit in each basket. You want to make both baskets equal. To do so, you can use the following operation as many times as you want:\n\n\tChose two indices i and j, and swap the ith&nbsp;fruit of basket1 with the jth&nbsp;fruit of basket2.\n\tThe cost of the swap is min(basket1[i],basket2[j]).\n\nTwo baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.\nReturn the minimum cost to make both the baskets equal or -1 if impossible.\n&nbsp;\nExample 1:\n\nInput: basket1 = [4,2,2,2], basket2 = [1,4,1,2]\nOutput: 1\nExplanation: Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2]. Rearranging both the arrays makes them equal.\n\nExample 2:\n\nInput: basket1 = [2,3,4,1], basket2 = [3,2,5,1]\nOutput: -1\nExplanation: It can be shown that it is impossible to make both the baskets equal.\n\n&nbsp;\nConstraints:\n\n\tbasket1.length == basket2.length\n\t1 <= basket1.length <= 105\n\t1 <= basket1[i],basket2[i]&nbsp;<= 109",
        "solutions": [
            {
                "id": 3143766,
                "title": "c-java-python3-count-and-match-pairs-o-n-time-complexity-with-quickselect",
                "content": "> **I know almost nothing about English, pointing out the mistakes in my article would be much appreciated.**\\n\\n> **In addition, I\\'m too weak, please be critical of my ideas.**\\n---\\n\\n# Intuition\\n1. If the frequency of each number in the two input arrays is even, then you can always find a way to swap the two arrays to become the same. On the contrary, it must be impossible.\\n2. Find a way to find out the numbers in each array that need to be given to the other, so you get two lists. The exchanged pair must form a one-to-one correspondence between the two lists.\\n3. **Within each pair, there are two exchange methods**:\\n    - Direct exchange, the cost is the smaller number.\\n    - Indirect exchange, choose another small number $x$ as the \"intermediate\", swap \"$a_{i}$ with $x$\" and \"$x$ with $b_{j}$\", the cost is $2x$.\\n4. **In order to minimize the result, be sure to make full use of \"small numbers\"**. \\n5. So put all the elements of the two arrays that need to be exchanged together and sort them. **Choose the first half as the \"costs\"**.\\n6. Choose to use \"direct exchange\" or \"indirect exchange\" each time according to the situation. Because the choice of which number is free, **the smallest number in the two arrays can be greedily selected as the intermediate**. (If $x$ is one of $a[i]$ or $b[j]$, the indirect way $2x$ will always greater than direct way $x$, so no need to think of this condition).\\n7. Find the first half can easily use sort with $O(n\\\\log{n})$ time complexity, or use [quickselect](https://en.wikipedia.org/wiki/Quickselect) with $O(n)$ time complexity.\\n\\n# Complexity\\n- Time complexity: $O(n\\\\log{n})$ or $O(n)$\\n- Space complexity: $O(n)$\\n\\n# Code\\nThanks for [Gang-Li\\'s JavaScript solution](https://leetcode.com/problems/rearranging-fruits/solutions/3144240/based-on-realfan-s-solution-improve-the-space-usage-by-not-using-array-in-the-last-step/?orderBy=most_votes)!\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> cnt;\\n        for (auto c: basket1) cnt[c]++;\\n        for (auto c: basket2) cnt[c]--;\\n        vector<int> last;\\n        for (auto &[k, v]: cnt) {\\n            // if v is odd, an even distribution is never possible\\n            if (v % 2) return -1;\\n            // the count of transferred k is |v|/2\\n            for (int i = 0; i < abs(v) / 2; ++i)\\n                last.push_back(k);\\n        }\\n        // find the min of two input arrays as the intermediate\\n        int minx = min(*min_element(basket1.begin(), basket1.end()),\\n                       *min_element(basket2.begin(), basket2.end()));\\n        // sort(last.begin(), last.end()) can be used as well\\n        nth_element(last.begin(), last.begin() + last.size() / 2, last.end());\\n        return accumulate(last.begin(), last.begin() + last.size() / 2, 0ll, \\n            [&](long long s, int x) -> long long { return s + min(2*minx, x); }\\n        );\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int c: basket1) \\n            cnt.put(c, cnt.getOrDefault(c, 0) + 1);\\n        for (int c: basket2) \\n            cnt.put(c, cnt.getOrDefault(c, 0) - 1);\\n        List<Integer> last = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> e: cnt.entrySet()) {\\n            int v = e.getValue();\\n            // if v is odd, an even distribution is never possible\\n            if (v % 2 != 0) return -1;\\n            // the count of transferred k is |v|/2\\n            for (int i = 0; i < Math.abs(v) / 2; ++i)\\n                last.add(e.getKey());\\n        }\\n        // find the min of two input arrays as the intermediate\\n        int minx = Math.min(Arrays.stream(basket1).min().getAsInt(),\\n                            Arrays.stream(basket2).min().getAsInt());\\n        // Use quickselect instead of sort can get a better complexity\\n        Collections.sort(last);\\n        long res = 0;\\n        // The first half may be the cost\\n        for (int i = 0; i < last.size() / 2; ++i) \\n            res += Math.min(last.get(i), minx * 2);\\n        return res;\\n    }\\n}\\n```\\n``` Python3 []\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        cnt = Counter(basket1)\\n        for x in basket2: cnt[x] -= 1\\n        last = []\\n        for k, v in cnt.items():\\n            # if v is odd, an even distribution is never possible\\n            if v % 2 != 0:\\n                return -1\\n            # the count of transferred k is |v|/2\\n            last += [k] * abs(v // 2)\\n        # find the min of two input arrays as the intermediate\\n        minx = min(basket1 + basket2)\\n        # Use quickselect instead of sort can get a better complexity\\n        last.sort()\\n        # The first half may be the cost\\n        return sum(min(2*minx, x) for x in last[0:len(last)//2])\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> cnt;\\n        for (auto c: basket1) cnt[c]++;\\n        for (auto c: basket2) cnt[c]--;\\n        vector<int> last;\\n        for (auto &[k, v]: cnt) {\\n            // if v is odd, an even distribution is never possible\\n            if (v % 2) return -1;\\n            // the count of transferred k is |v|/2\\n            for (int i = 0; i < abs(v) / 2; ++i)\\n                last.push_back(k);\\n        }\\n        // find the min of two input arrays as the intermediate\\n        int minx = min(*min_element(basket1.begin(), basket1.end()),\\n                       *min_element(basket2.begin(), basket2.end()));\\n        // sort(last.begin(), last.end()) can be used as well\\n        nth_element(last.begin(), last.begin() + last.size() / 2, last.end());\\n        return accumulate(last.begin(), last.begin() + last.size() / 2, 0ll, \\n            [&](long long s, int x) -> long long { return s + min(2*minx, x); }\\n        );\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int c: basket1) \\n            cnt.put(c, cnt.getOrDefault(c, 0) + 1);\\n        for (int c: basket2) \\n            cnt.put(c, cnt.getOrDefault(c, 0) - 1);\\n        List<Integer> last = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> e: cnt.entrySet()) {\\n            int v = e.getValue();\\n            // if v is odd, an even distribution is never possible\\n            if (v % 2 != 0) return -1;\\n            // the count of transferred k is |v|/2\\n            for (int i = 0; i < Math.abs(v) / 2; ++i)\\n                last.add(e.getKey());\\n        }\\n        // find the min of two input arrays as the intermediate\\n        int minx = Math.min(Arrays.stream(basket1).min().getAsInt(),\\n                            Arrays.stream(basket2).min().getAsInt());\\n        // Use quickselect instead of sort can get a better complexity\\n        Collections.sort(last);\\n        long res = 0;\\n        // The first half may be the cost\\n        for (int i = 0; i < last.size() / 2; ++i) \\n            res += Math.min(last.get(i), minx * 2);\\n        return res;\\n    }\\n}\\n```\n``` Python3 []\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        cnt = Counter(basket1)\\n        for x in basket2: cnt[x] -= 1\\n        last = []\\n        for k, v in cnt.items():\\n            # if v is odd, an even distribution is never possible\\n            if v % 2 != 0:\\n                return -1\\n            # the count of transferred k is |v|/2\\n            last += [k] * abs(v // 2)\\n        # find the min of two input arrays as the intermediate\\n        minx = min(basket1 + basket2)\\n        # Use quickselect instead of sort can get a better complexity\\n        last.sort()\\n        # The first half may be the cost\\n        return sum(min(2*minx, x) for x in last[0:len(last)//2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143917,
                "title": "java-c-python-two-ways-to-swap",
                "content": "# **Explanation**\\nFirst, we count the fruits `A` and `B`,\\nand check if possible to make even.\\nIf one fruit type has odd quantity,\\nthen it\\'s impossible.\\n\\nFor same fruit in `A` and `B`,\\nthey are even now,\\nwe don\\'t need to swap them.\\n\\nThen we find out the fruits in `A` and `B` that need to be swap.\\nassume\\n`A = [2,2,3,3,1000,1000]`\\n`B = [1,1,1001,10001,1002,1002]`\\n\\nOne way is to swap them one by one,\\nwe can use the small half friut in `A` and `B`,\\nto swap the big half fruit:\\n`[2,2,3,3]` in `A` to swap `[1001,10001,1002,1002]` in `B`\\n`[1,1]` in `A` to swap `[1001,10001,1002,1002]` in `B`,\\nthe cost is `min(A[i], B[j])`\\n\\nThe other way is use the smallest value in `A` and `B`,\\nand swap twice.\\nassume `x = min(A) < min(B)`\\nnow we can swap `x` with `1001` in `B`,\\nthen swap `x` with `2` in `A`.\\nThe cost is `2x`.\\n\\nSo we need to compare this two ways,\\nfor small values to swap,\\nwe apply option 1 and swap directly,\\nfor big values,\\nwe apply option 2 and swap twice using a small value.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn)`\\nSpace `O(nlogn)`\\n<br>\\n\\n**Java**\\n```java\\n    public long minCost(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> count = new TreeMap<>();\\n        for (int a : A)\\n            count.merge(a, 1, Integer::sum);\\n        for (int a : B)\\n            count.merge(a, -1, Integer::sum);\\n        List<Integer> swaps = new ArrayList<>();\\n        long res = 0, small = count.firstKey();\\n        for (int a : count.keySet()) {\\n            if (count.get(a) % 2 > 0) return -1;\\n            int v = Math.abs(count.get(a)) / 2;\\n            for (int i = 0; i < v; ++i)\\n                swaps.add(a);\\n        }\\n        for (int i = 0; i < swaps.size() / 2; ++i)\\n            res += Math.min(swaps.get(i), small * 2);\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    long long minCost(vector<int>& A, vector<int>& B) {\\n        map<int, int> count;\\n        for (int a : A)\\n            ++count[a];\\n        for (int a : B)\\n            --count[a];\\n        vector<long long> swaps;\\n        long long res = 0, small = begin(count)->first;\\n        for (auto [a, v] : count) {\\n            if (v % 2) return -1;\\n            for (int i = 0; i < abs(v) / 2; ++i)\\n                swaps.push_back(a);\\n        }\\n        for (int i = 0; i < swaps.size() / 2; ++i)\\n            res += min(swaps[i], small * 2);\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def minCost(self, A: List[int], B: List[int]) -> int:\\n        count = Counter(A + B)\\n        for c in count:\\n            if count[c] % 2:\\n                return -1\\n            count[c] >>= 1\\n        A2 = list((Counter(A) - count).elements())\\n        B2 = list((Counter(B) - count).elements())\\n        small = min(count)\\n        C = sorted(A2 + B2)\\n        return sum(min(small * 2, C[i]) for i in range(len(A2)))\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long minCost(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> count = new TreeMap<>();\\n        for (int a : A)\\n            count.merge(a, 1, Integer::sum);\\n        for (int a : B)\\n            count.merge(a, -1, Integer::sum);\\n        List<Integer> swaps = new ArrayList<>();\\n        long res = 0, small = count.firstKey();\\n        for (int a : count.keySet()) {\\n            if (count.get(a) % 2 > 0) return -1;\\n            int v = Math.abs(count.get(a)) / 2;\\n            for (int i = 0; i < v; ++i)\\n                swaps.add(a);\\n        }\\n        for (int i = 0; i < swaps.size() / 2; ++i)\\n            res += Math.min(swaps.get(i), small * 2);\\n        return res;\\n    }\\n```\n```cpp\\n    long long minCost(vector<int>& A, vector<int>& B) {\\n        map<int, int> count;\\n        for (int a : A)\\n            ++count[a];\\n        for (int a : B)\\n            --count[a];\\n        vector<long long> swaps;\\n        long long res = 0, small = begin(count)->first;\\n        for (auto [a, v] : count) {\\n            if (v % 2) return -1;\\n            for (int i = 0; i < abs(v) / 2; ++i)\\n                swaps.push_back(a);\\n        }\\n        for (int i = 0; i < swaps.size() / 2; ++i)\\n            res += min(swaps[i], small * 2);\\n        return res;\\n    }\\n```\n```py\\n    def minCost(self, A: List[int], B: List[int]) -> int:\\n        count = Counter(A + B)\\n        for c in count:\\n            if count[c] % 2:\\n                return -1\\n            count[c] >>= 1\\n        A2 = list((Counter(A) - count).elements())\\n        B2 = list((Counter(B) - count).elements())\\n        small = min(count)\\n        C = sorted(A2 + B2)\\n        return sum(min(small * 2, C[i]) for i in range(len(A2)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3143735,
                "title": "ordered-map",
                "content": "We count occurrences of each value in an ordered map. \\n> We use an ordered map so we do not need to sort numbers later.\\n\\nWe increment the count for the first basket, and decrement for the second.\\n\\nIf the final count is zero, the number of occurrences matches - no need to do any swaps with that number.\\n\\nA positive (or negative) count means that there is extra of this number in the first (or the second) basket. \\n\\n> Note that the count must be even, since we need to distribute it equaly between the baskets. \\n\\nThe total number of `swaps` can be determining by summing all positive (or negative) counts and dividing it by two.\\n\\nFinally, we go from the smallest to the largest price (to minitize cost), and do the required number of swaps.\\n\\n> Note that it may be cheaper to do two swaps with the cheapest fruit, that one swap with the current one.\\n\\n**C++**\\n```cpp\\nlong long minCost(vector<int>& b1, vector<int>& b2) {\\n    map<int, long long> m;\\n    for (auto c : b1)\\n        ++m[c];\\n    for (auto c : b2)\\n        --m[c];\\n    long long swaps = 0, res = 0;\\n    for (auto [c, cnt] : m) {\\n        if (cnt % 2)\\n            return -1;\\n        swaps += max(0LL, cnt / 2);\\n    }\\n    for (auto [c, cnt] : m) {\\n        long long take = min(swaps, abs(cnt) / 2);\\n        res += take * min(c, begin(m)->first * 2);\\n        swaps -= take;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long minCost(vector<int>& b1, vector<int>& b2) {\\n    map<int, long long> m;\\n    for (auto c : b1)\\n        ++m[c];\\n    for (auto c : b2)\\n        --m[c];\\n    long long swaps = 0, res = 0;\\n    for (auto [c, cnt] : m) {\\n        if (cnt % 2)\\n            return -1;\\n        swaps += max(0LL, cnt / 2);\\n    }\\n    for (auto [c, cnt] : m) {\\n        long long take = min(swaps, abs(cnt) / 2);\\n        res += take * min(c, begin(m)->first * 2);\\n        swaps -= take;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172002,
                "title": "using-map-very-simple-and-easy-to-understand-solution",
                "content": "# Approach \\nHere approach is to as the size of both the array same then,\\njust add elements count to a map from the array 1 and subtract the no of elements found in the array 2.\\nFinally just traverse the map to check if any of the element cpount is odd or not, if odd found then its not possible to make two array equal so reeturn -1.\\nAlso keep counting number of elements that are in arary1 ( if count is positive ). We device each count by 2, just to keep track of no of elements that need to be matched.\\n\\nThen simply traverse the map again till the count is greater than zero - this means take the sum of lower most half of the elements that need to be moved. Just keep coparing that if the element that need to be moved is less than 2 times of smallest move or not. if it is smaler than 2*smaller element then add it as it is, otherwise add 2*smallest element.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<int, int> mp;\\n        for(int i = 0; i < b1.size(); ++i) { mp[b1[i]]++; mp[b2[i]]--; }\\n        long long ans = 0; \\n        int mn = mp.begin()->first, count = 0;\\n        for(auto m:mp){\\n            if(m.second % 2) return -1;\\n            count += max(0, m.second/2);\\n        }\\n        for(auto m:mp){\\n            if(m.second && count > 0){\\n                long long t1 = min(count , abs(m.second/2)), t2 = min( 2*mn , m.first);\\n                ans += t1 * t2;\\n                count -= abs(m.second/2);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon: \\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<int, int> mp;\\n        for(int i = 0; i < b1.size(); ++i) { mp[b1[i]]++; mp[b2[i]]--; }\\n        long long ans = 0; \\n        int mn = mp.begin()->first, count = 0;\\n        for(auto m:mp){\\n            if(m.second % 2) return -1;\\n            count += max(0, m.second/2);\\n        }\\n        for(auto m:mp){\\n            if(m.second && count > 0){\\n                long long t1 = min(count , abs(m.second/2)), t2 = min( 2*mn , m.first);\\n                ans += t1 * t2;\\n                count -= abs(m.second/2);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143729,
                "title": "c-counting-and-sorting",
                "content": "# Main Idea\\nAt first we will count the total occurence of each fruit cost in both basket.\\n\\nThe first observation is that if the total count of any value is  odd then we cannot partition them in two equal part. So we will return -1.\\n\\nLet us assume that every value has an even number of occurence. Now how many swaps do we need? \\nFor any value $$x$$, if $$x$$ occurs in basket1 $$cnt_1$$ times and it occurs in basket2 $$cnt_2$$ times then we need to swap at least $$abs(cnt_1-cnt_2)/2$$ times.\\nWe will maintain a vector $$to\\\\_swap$$ that will store the values need to be swapped. So if any value $$x$$ needs to be swapped $$y$$ times, we will insert a total of $$y$$ $$x$$\\'s into this vector.\\n\\nNow, according to the question the cost of one swap is the minimum of the two values that are swapped. So it is always better to swap the largest value with the smallest one. Then we can sort the $$to\\\\_swap$$ vector, and in each step we will swap the current first and last element of the vector and remove them.\\n\\nBut there\\'s a catch. Instead of swapping first and last element of vector, we can choose the minimum value of the baskets and use it twice to place the elements in their required position.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n       \\n        unordered_map<int,int>cnt1,cnt2;\\n        int mn = b1[0]; // mn will store the minimum of all the values.\\n        \\n        // count occurence of each cost in each basket\\n        for(int&x:b1)cnt1[x]++, mn = min(mn,x);\\n        for(int&x:b2)cnt2[x]++, mn = min(mn,x);\\n        \\n        // to_swap stores the values that needs to be swapped.\\n        vector<int>to_swap;\\n        for(auto u:cnt1){\\n            int value = u.first;\\n            int occ1 = u.second;\\n            int occ2 = cnt2[value];\\n            int dif = abs(occ1-occ2);\\n            if(dif%2){\\n                return -1;\\n            }\\n            dif/=2;\\n            for(int i=0;i<dif;i++)to_swap.push_back(value);\\n            // we clear the occurences as later we will check unique values of basket2.\\n            cnt1[value] = 0;\\n            cnt2[value] = 0;\\n        }\\n        for(auto&u:cnt2){\\n            int value = u.first;\\n            int occ = u.second;\\n            if(occ%2) return -1;\\n            occ/=2;\\n            for(int i=0;i<occ;i++)to_swap.push_back(value);\\n        }\\n        sort(to_swap.begin(),to_swap.end());\\n        long long ans = 0;\\n        for(int i=0;i<to_swap.size()/2;i++)ans+=min(2ll*mn,1ll*to_swap[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n       \\n        unordered_map<int,int>cnt1,cnt2;\\n        int mn = b1[0]; // mn will store the minimum of all the values.\\n        \\n        // count occurence of each cost in each basket\\n        for(int&x:b1)cnt1[x]++, mn = min(mn,x);\\n        for(int&x:b2)cnt2[x]++, mn = min(mn,x);\\n        \\n        // to_swap stores the values that needs to be swapped.\\n        vector<int>to_swap;\\n        for(auto u:cnt1){\\n            int value = u.first;\\n            int occ1 = u.second;\\n            int occ2 = cnt2[value];\\n            int dif = abs(occ1-occ2);\\n            if(dif%2){\\n                return -1;\\n            }\\n            dif/=2;\\n            for(int i=0;i<dif;i++)to_swap.push_back(value);\\n            // we clear the occurences as later we will check unique values of basket2.\\n            cnt1[value] = 0;\\n            cnt2[value] = 0;\\n        }\\n        for(auto&u:cnt2){\\n            int value = u.first;\\n            int occ = u.second;\\n            if(occ%2) return -1;\\n            occ/=2;\\n            for(int i=0;i<occ;i++)to_swap.push_back(value);\\n        }\\n        sort(to_swap.begin(),to_swap.end());\\n        long long ans = 0;\\n        for(int i=0;i<to_swap.size()/2;i++)ans+=min(2ll*mn,1ll*to_swap[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144124,
                "title": "python-o-n-log-n-count-sorting-solution",
                "content": "# Intuition\\nWe can check each elements using counter.\\n\\nYou can easily come up with exchange two fruits as cheap as possibile.\\n\\nTo achieve this, the simple idea is to exchage larger value fruits and smaller value fruits.\\n\\nBut be careful, you have to check the way to exchange via the cheapest fruits. \\n\\nYou can see that code here\\n\\n```\\n        for v1,v2 in zip(c1,c2):\\n            ans += min(v1,v2, min_v*2)\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        b1 = dict(Counter(basket1))\\n        b2 = dict(Counter(basket2))\\n        \\n        tot = Counter(basket1 + basket2)\\n        \\n        c1 = []\\n        c2 = []\\n        for k, v in tot.items():\\n            if v % 2 != 0:\\n                return -1\\n            b1c = b1.get(k, 0)\\n            b2c = b2.get(k, 0)\\n            if b1c == b2c:\\n                continue\\n            if b1c > b2c:\\n                for i in range((b1c - b2c) // 2):\\n                    c1.append(k)\\n            else:\\n                for i in range((b2c - b1c) // 2):\\n                    c2.append(k)\\n        c1 = sorted(c1)\\n        c2 = sorted(c2, reverse=True)\\n        ans = 0\\n        min_v = min(basket1 + basket2)\\n        for v1,v2 in zip(c1,c2):\\n            ans += min(v1,v2, min_v*2)\\n        return ans\\n```\\n# Q&A\\n\\n### Why min(v1, v2) is not working?\\n\\nLet\\'s assume we have to exchange $basket1=[1, 100, 100], c2=[1, 200, 200]$\\nThen, our array $c1=[100]$ and $c2=[200]$ \\nThe simpleast way is exchange 100 and 200.\\nBut there are more smart solution.\\nThat is to exchange using fruit 1.\\nThe step is follow\\n 1. Exchange [100, 1]. \\n    - Then $basket1=[1, 1, 100]$ $basket2=[100, 200, 200]$ and cost is 1\\n 2. Exchange [1, 200].  \\n    - Then $basket1=[1, 200, 100]$ $basket2=[100, 1, 200]$ and cost is 1\\n\\nThen we can solve this problem with total cost 2.\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n        for v1,v2 in zip(c1,c2):\\n            ans += min(v1,v2, min_v*2)\\n```\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        b1 = dict(Counter(basket1))\\n        b2 = dict(Counter(basket2))\\n        \\n        tot = Counter(basket1 + basket2)\\n        \\n        c1 = []\\n        c2 = []\\n        for k, v in tot.items():\\n            if v % 2 != 0:\\n                return -1\\n            b1c = b1.get(k, 0)\\n            b2c = b2.get(k, 0)\\n            if b1c == b2c:\\n                continue\\n            if b1c > b2c:\\n                for i in range((b1c - b2c) // 2):\\n                    c1.append(k)\\n            else:\\n                for i in range((b2c - b1c) // 2):\\n                    c2.append(k)\\n        c1 = sorted(c1)\\n        c2 = sorted(c2, reverse=True)\\n        ans = 0\\n        min_v = min(basket1 + basket2)\\n        for v1,v2 in zip(c1,c2):\\n            ans += min(v1,v2, min_v*2)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412531,
                "title": "c-best-solution-available-clean-and-easy-code-with-explanation",
                "content": "# Intuition\\nThere are Two possible ways to swap elements optimally\\n1: [10,12,12], [10,25,25]\\n  swap 12 and 25 directly, cost will be 12\\n\\n2: [1,12,12], [1,25,25]\\n  swap 1 and 25 then swap 1 and 12, cost will be 2*1 = 2;\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Check if it is possible to make both arrays equal\\n    bool checkPossible(unordered_map<int, int> &mp1, unordered_map<int, int> &mp2){\\n        for(auto [num, freq] : mp1){\\n            int temp = freq + mp2[num];\\n            if(temp % 2 != 0) return false; \\n        }\\n        return true;\\n    }\\n\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> mp1;\\n        unordered_map<int, int> mp2;\\n        for(auto &i : basket1) mp1[i]++;\\n        for(auto &i : basket2) mp2[i]++;\\n\\n        if(!checkPossible(mp1, mp2)) return -1;\\n        if(!checkPossible(mp2, mp1)) return -1;\\n\\n        sort(basket1.begin(), basket1.end());\\n        sort(basket2.begin(), basket2.end());\\n        long long ans = 0;\\n        int i = 0, j = basket1.size()-1, mini = min(basket1[0], basket2[0]);\\n\\n        // Take 2 pointers, one at starting of 1st array and other at ending of second array\\n        // Keep finding the possible swaping element in both arrays then swap optimally\\n        // There are two possible ways to swap elements : 1) Swap normally. 2) swap via minimum element.\\n        while(i < basket1.size()){\\n            while(i < basket1.size() && mp1[basket1[i]] <= mp2[basket1[i]]){\\n                i++;\\n            }\\n\\n            while(j >= 0 && mp2[basket2[j]] <= mp1[basket2[j]]){\\n                j--;\\n            }\\n\\n            if(i < basket1.size() && j >= 0){\\n                long long temp = min(2*mini, min(basket1[i], basket2[j]));\\n                ans += temp;\\n\\n                int one = basket1[i];\\n                int two = basket2[j];\\n\\n                mp1[one]--;\\n                mp2[one]++;\\n\\n                mp2[two]--;\\n                mp1[two]++;\\n            }\\n\\n            i++;\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Check if it is possible to make both arrays equal\\n    bool checkPossible(unordered_map<int, int> &mp1, unordered_map<int, int> &mp2){\\n        for(auto [num, freq] : mp1){\\n            int temp = freq + mp2[num];\\n            if(temp % 2 != 0) return false; \\n        }\\n        return true;\\n    }\\n\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> mp1;\\n        unordered_map<int, int> mp2;\\n        for(auto &i : basket1) mp1[i]++;\\n        for(auto &i : basket2) mp2[i]++;\\n\\n        if(!checkPossible(mp1, mp2)) return -1;\\n        if(!checkPossible(mp2, mp1)) return -1;\\n\\n        sort(basket1.begin(), basket1.end());\\n        sort(basket2.begin(), basket2.end());\\n        long long ans = 0;\\n        int i = 0, j = basket1.size()-1, mini = min(basket1[0], basket2[0]);\\n\\n        // Take 2 pointers, one at starting of 1st array and other at ending of second array\\n        // Keep finding the possible swaping element in both arrays then swap optimally\\n        // There are two possible ways to swap elements : 1) Swap normally. 2) swap via minimum element.\\n        while(i < basket1.size()){\\n            while(i < basket1.size() && mp1[basket1[i]] <= mp2[basket1[i]]){\\n                i++;\\n            }\\n\\n            while(j >= 0 && mp2[basket2[j]] <= mp1[basket2[j]]){\\n                j--;\\n            }\\n\\n            if(i < basket1.size() && j >= 0){\\n                long long temp = min(2*mini, min(basket1[i], basket2[j]));\\n                ans += temp;\\n\\n                int one = basket1[i];\\n                int two = basket2[j];\\n\\n                mp1[one]--;\\n                mp2[one]++;\\n\\n                mp2[two]--;\\n                mp1[two]++;\\n            }\\n\\n            i++;\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145376,
                "title": "fully-explained-solution-with-steps-beginner-friendly",
                "content": "# Observations:\\n1) To make the 2 arrays identical, a fruit should be present in both the arrays; freq of any fruit present in any array should be even to be perfectly distributed in both arrays\\n2) Take difference freq1[fruit]- freq2[fruit] to find the excess characters and deficit in b1, where fruit is a possible fruit\\n3) Now, if the diff[fruit]  > 0 it signifies that the current fruit is in excess and half of the fruits are swappable from b1 to b2 to make the freq of the fruit in both arrays equal\\n4) If the diff[fruit]  < 0 it signifies that the current fruit is in deficit and the half of the deficit should be taken from b2 into b1 to make freq of the fruit in both arrays equal\\n5) Swapping can be done in 2 ways- \\n     1) direct swapping: 2 elements can be swapped with each other , cost= min(a,b)\\n     2) indirect swapping with a 3rd element : 2 elements can be swapped using a 3rd element common to both arrays \\n         in 2 operations as given,\\n         swap(a,c) and then swap(c,b)\\n         cost = min(a,b) + min (b,c)\\n6) To achieve minimal cost in case of indirect swapping, the third fruit chosen to swap 2 fruits ( a and b ) should be the smallest fruit out of all the fruits\\n     cost= min(a,mn) + min(b,mn)= 2* mn\\n7) For optimal case of swapping, greedily choose the lowest cost fruit in bucket 1 to be swapped with the highest cost fruit in bucket 2\\n     cost= min(2* mn, min(a,b))\\n     Eg: swap from b1 to b2 = [1,9]  and swap from b2 to b1 =[ 2,4]\\n     Now if we swap 1 with 2 cost = 1  \\n             then swap 9 with 4, cost= 4 \\n             cost = 1+4 = 5\\n     however, if we swap 1 with 4 cost =1\\n             then swap 9 with 2, cost=2\\n             cost= 1+2= 3 which is smaller\\n\\n# Approach:\\n1) Maintain a diff freq map\\n2) Maintain 2 vectors which maintain elements swappable from b1 to b2 (excess in b1) and swappable from b2 to b1(deficit in b1)\\n3) if diff[fruit]%2 != 0 return -1\\n4) else if( diff[fruit] > 0) push  excess freq[fruit]/2  in b1Tob2 vector\\n5) else if( diff[fruit] < 0) push deficit -freq[fruit]/2  in b2Tob1 vector\\n6) reverse b2Tob1 vector\\n7) perform swapping optimally, mentioned above and find cost\\n\\n# Complexity:\\n- Time complexity:\\nO(NLogN) sorted map used\\n\\n- Space complexity:\\nO(N)\\n\\n# Code:\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        \\n        map<int,int> freq;\\n        long long ans=0;\\n        \\n        for(auto b: basket1) freq[b]++;\\n        \\n        for(auto b: basket2) freq[b]--;  // made diff freq map\\n        \\n        long long mn= freq.begin()->first; //smallest element to perform indirect swapping\\n        \\n        vector<long long> swapFromB1toB2; //vectors\\n        vector<long long> swapFromB2toB1;\\n        \\n        for(auto x: freq)\\n        {\\n            if(x.second%2 !=0) return -1; //not possible to distribute equally\\n            \\n            if(x.second > 0) // excess in b1\\n            {\\n                int temp= x.second/2;\\n                while(temp-- >0) swapFromB1toB2.push_back(x.first);\\n            }\\n            else if(x.second < 0) //deficit in b1\\n            {\\n                int temp= (-x.second)/2;\\n                while(temp-- >0) swapFromB2toB1.push_back(x.first);\\n            }\\n        }\\n        \\n        reverse(swapFromB2toB1.begin(), swapFromB2toB1.end());// to swap optimally\\n        \\n        for(int i=0;i<swapFromB1toB2.size();i++)\\n        {\\n            // indirect swapping cost= 2* mn\\n            // direct swapping cost= min(swapFromB1toB2[i], swapFromB2toB1[i])\\n            ans+= min(2* mn, min(swapFromB1toB2[i], swapFromB2toB1[i]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        \\n        map<int,int> freq;\\n        long long ans=0;\\n        \\n        for(auto b: basket1) freq[b]++;\\n        \\n        for(auto b: basket2) freq[b]--;  // made diff freq map\\n        \\n        long long mn= freq.begin()->first; //smallest element to perform indirect swapping\\n        \\n        vector<long long> swapFromB1toB2; //vectors\\n        vector<long long> swapFromB2toB1;\\n        \\n        for(auto x: freq)\\n        {\\n            if(x.second%2 !=0) return -1; //not possible to distribute equally\\n            \\n            if(x.second > 0) // excess in b1\\n            {\\n                int temp= x.second/2;\\n                while(temp-- >0) swapFromB1toB2.push_back(x.first);\\n            }\\n            else if(x.second < 0) //deficit in b1\\n            {\\n                int temp= (-x.second)/2;\\n                while(temp-- >0) swapFromB2toB1.push_back(x.first);\\n            }\\n        }\\n        \\n        reverse(swapFromB2toB1.begin(), swapFromB2toB1.end());// to swap optimally\\n        \\n        for(int i=0;i<swapFromB1toB2.size();i++)\\n        {\\n            // indirect swapping cost= 2* mn\\n            // direct swapping cost= min(swapFromB1toB2[i], swapFromB2toB1[i])\\n            ans+= min(2* mn, min(swapFromB1toB2[i], swapFromB2toB1[i]));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144111,
                "title": "explained-with-image-c-sorting-map",
                "content": "# Intuition\\nWe can have solution if frequency of all elements of both array should be \"EVEN\" , \\nWe can do swap operation between \"EXTRA\" elements of both array ,\\nFor (X,Y) - can we do swap between them with better than min(X,Y) cost ?\\n\\n![IMG_0100.PNG](https://assets.leetcode.com/users/images/6378b5b2-6490-40fb-8ace-e8238ab9f43f_1675572380.3932588.png)\\n![IMG_0101.PNG](https://assets.leetcode.com/users/images/92ea8ad8-772e-4503-b844-daddcc287692_1675572394.4508438.png)\\n\\n\\n# Approach\\nWe first check for odd frequency element combining both arrays,  if ther is element then we cannot have solution,\\nelse we find \"EXTRA\" element arrays for each bucket.\\nIt is good to make pair ofr swaps between (Min_of_first , MAX_of_second) .\\nWe can also use (MIN_VALUE_IN_BUCKET) to perform the swap opeartioin at cost of (2*Min_value)  for (X,Y) if  (min(X,Y) > (2 * Min_value)). \\n\\n# Complexity\\n- Time complexity:\\nO(N log N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    void find(vector<long long>&ex1,vector<long long>&ex2,long long& ans,long long mn){\\n        int m = ex1.size();\\n        long long cost = 0;\\n\\n        //mn_cost is the cost we need to pay if we want to swap elements from min value\\n        long long mn_cost = 2ll*mn;\\n\\n        for(int i=0;i<m;++i){\\n            //cur_cost is cost of swapping ex1[i] and ex2[i] , ith extra element of both bucket\\n            long long cur_cost = min(ex1[i],ex2[i]);\\n            \\n            //if swapping with minimum value is efficient we swap with min value individually\\n            if(mn_cost < cur_cost){\\n                cost += mn_cost;\\n            }//else we swap them\\n            else cost += cur_cost;\\n        }\\n\\n        ans = min(ans,cost);\\n    }\\n    \\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        long long ans = 0;\\n        \\n        vector<long long>ex1,ex2;\\n        map<long long ,long long>fre,fre1,fre2;\\n\\n        //we find the frequency of element in both basket\\n        for(auto&x:basket1){\\n            fre1[x]++;\\n            fre[x]++;\\n        }\\n        long long mn = 1e18;\\n        for(auto&x:basket2){\\n            fre2[x]++;\\n            fre[x]++;\\n        }\\n        \\n         //fre1 -- store the frequency of element in bucket1\\n         //fre2 -- store the frequency of elemtn in bucket2\\n        for(auto&x:fre){\\n            mn = min(x.first,mn);\\n\\n            //if any element is odd number of times we cannot divide into two groups\\n            //so it is impossible\\n            if(x.second%2)return -1ll;\\n            \\n            int sz = x.second/2;\\n            //we need sz no of elements in our bucket \\n            //if we have more we need to swap them\\n\\n            //adding extra elements of bucket 1 in ex1\\n            for(int i=0;i<(fre1[x.first]-sz);++i){\\n                ex1.push_back(x.first);\\n            }\\n            //adding extra elements of bucket 2 in ex2\\n            for(int i=0;i<(fre2[x.first]-sz);++i){\\n                ex2.push_back(x.first);\\n            }\\n        }\\n         \\n        //we want to map smallest of extra element of first bucket\\n        //with maximum of extra element of second element and so on.\\n        reverse(ex2.begin(),ex2.end());\\n        \\n        ans = 1e18;\\n        find(ex1,ex2,ans,mn);\\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void find(vector<long long>&ex1,vector<long long>&ex2,long long& ans,long long mn){\\n        int m = ex1.size();\\n        long long cost = 0;\\n\\n        //mn_cost is the cost we need to pay if we want to swap elements from min value\\n        long long mn_cost = 2ll*mn;\\n\\n        for(int i=0;i<m;++i){\\n            //cur_cost is cost of swapping ex1[i] and ex2[i] , ith extra element of both bucket\\n            long long cur_cost = min(ex1[i],ex2[i]);\\n            \\n            //if swapping with minimum value is efficient we swap with min value individually\\n            if(mn_cost < cur_cost){\\n                cost += mn_cost;\\n            }//else we swap them\\n            else cost += cur_cost;\\n        }\\n\\n        ans = min(ans,cost);\\n    }\\n    \\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        long long ans = 0;\\n        \\n        vector<long long>ex1,ex2;\\n        map<long long ,long long>fre,fre1,fre2;\\n\\n        //we find the frequency of element in both basket\\n        for(auto&x:basket1){\\n            fre1[x]++;\\n            fre[x]++;\\n        }\\n        long long mn = 1e18;\\n        for(auto&x:basket2){\\n            fre2[x]++;\\n            fre[x]++;\\n        }\\n        \\n         //fre1 -- store the frequency of element in bucket1\\n         //fre2 -- store the frequency of elemtn in bucket2\\n        for(auto&x:fre){\\n            mn = min(x.first,mn);\\n\\n            //if any element is odd number of times we cannot divide into two groups\\n            //so it is impossible\\n            if(x.second%2)return -1ll;\\n            \\n            int sz = x.second/2;\\n            //we need sz no of elements in our bucket \\n            //if we have more we need to swap them\\n\\n            //adding extra elements of bucket 1 in ex1\\n            for(int i=0;i<(fre1[x.first]-sz);++i){\\n                ex1.push_back(x.first);\\n            }\\n            //adding extra elements of bucket 2 in ex2\\n            for(int i=0;i<(fre2[x.first]-sz);++i){\\n                ex2.push_back(x.first);\\n            }\\n        }\\n         \\n        //we want to map smallest of extra element of first bucket\\n        //with maximum of extra element of second element and so on.\\n        reverse(ex2.begin(),ex2.end());\\n        \\n        ans = 1e18;\\n        find(ex1,ex2,ans,mn);\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145510,
                "title": "beats-100-c-using-map-with-proof",
                "content": "# Beats 100% Proof\\n  https://leetcode.com/problems/rearranging-fruits/submissions/891917887/\\n\\n# Approach\\n- First We Need to have what are the extras that Busket1 has to offer and the extras that Busket2 has to offer.\\n- If Busket1 has X extra elements of Cost K than Busket2 then X % 2 == 0 should satisfy (Vice Versa)\\n- We need to have the minimum existent value.\\n  <strong> Why ? </strong>\\n  - assume we have one 23 Cost-Item extra from Busket1 and 90 Cost-item extra from Busket two.\\n  - What should be minimum cost to swap this 2 ? min (23, 90) ? \\n  - A Big No!\\n  - Rather than direct swap we always has the option of swapping the numbers using a 3rd party element. say We have an element X cost-item.\\n  - Then To Swap (23, 90) using X we swap-cost will be 2X . ( Think Why )\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n- Space complexity: O(N)\\n\\n# Code\\n```\\n#define all(v) begin(v), end(v)\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<int , int> cnt; \\n        int minval = 1e9; \\n        for (int i = 0 ; i < b1.size() ; i++) {\\n            cnt[b1[i]]++ ;\\n            cnt[b2[i]]-- ;\\n            minval = min({minval, b1[i], b2[i]}) ;\\n        }\\n        vector<int> ex1, ex2 ; \\n        for (auto [k, v] : cnt) { \\n            if(abs(v) % 2) return -1; \\n            while(v > 0) {\\n                ex1.push_back(k); \\n                v -= 2;\\n            }\\n            while(v < 0) {\\n                ex2.push_back(k); \\n                v += 2; \\n            }\\n        }\\n        if (ex1.size() != ex2.size()) return -1; \\n        sort(ex1.begin(), ex1.end()); \\n        sort(ex2.begin(), ex2.end(), greater<int>()); \\n        long long cost = 0; \\n        for (int i = 0 ; i<ex1.size() ; i++)\\n            cost += min({2*minval, ex1[i], ex2[i]}); \\n        return cost; \\n    }\\n};\\n```\\n\\nSome Extra Points - \\n- Sorting is not necessary as We are using Ordered Map\\n- If We don\\'t use Sort and just Use reverse for the Extra Busket 2 then it beats 75% which does not make sense to me.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define all(v) begin(v), end(v)\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<int , int> cnt; \\n        int minval = 1e9; \\n        for (int i = 0 ; i < b1.size() ; i++) {\\n            cnt[b1[i]]++ ;\\n            cnt[b2[i]]-- ;\\n            minval = min({minval, b1[i], b2[i]}) ;\\n        }\\n        vector<int> ex1, ex2 ; \\n        for (auto [k, v] : cnt) { \\n            if(abs(v) % 2) return -1; \\n            while(v > 0) {\\n                ex1.push_back(k); \\n                v -= 2;\\n            }\\n            while(v < 0) {\\n                ex2.push_back(k); \\n                v += 2; \\n            }\\n        }\\n        if (ex1.size() != ex2.size()) return -1; \\n        sort(ex1.begin(), ex1.end()); \\n        sort(ex2.begin(), ex2.end(), greater<int>()); \\n        long long cost = 0; \\n        for (int i = 0 ; i<ex1.size() ; i++)\\n            cost += min({2*minval, ex1[i], ex2[i]}); \\n        return cost; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146848,
                "title": "fully-explained-on-paper-with-image-and-extra-example-test-case-c-code-with-full-comments",
                "content": "\\n![Adobe Scan 05 Feb 2023_1.jpg](https://assets.leetcode.com/users/images/14dff042-b2a3-4aa2-b0f0-4602b5d7ba77_1675595752.5658636.jpeg)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        // using map m for finding frequency of every element combined in both baskets\\n        map<ll,ll>m;\\n        // finding the minimum element of both the baskets combined\\n        ll mini = 1e10;\\n        for(auto &it:basket1){\\n            m[it]++;\\n            mini = min(mini,(ll)it); \\n        }\\n        for(auto &it:basket2){\\n            m[it]++;\\n            mini = min(mini,(ll)it); \\n        }\\n        // if frequency of any element combined in both arrays is odd then that cant be divided\\n       for(auto &it:m){\\n           if(it.second & 1){\\n               return -1;\\n           }\\n       }\\n       // ans variable to store the final answer\\n        ll ans = 0 ;\\n        // map to identify which elements are present in basket 1 in excess\\n        map<ll,ll>req1;\\n        // one vector will store excess elements of basket 1, two will do the same for basket 2\\n        vector<int>one,two;\\n        for(auto &it:basket1){\\n            req1[it]++;\\n        }\\n        for(auto &it:req1){\\n            int x =  m[it.first];\\n            int y = it.second;\\n            //if frequency of element in basket 1 is more than what should be in the final basket\\n            if(y > x/2){\\n                for(int i = 0 ;i<y-x/2;i++){\\n                    one.push_back(it.first);\\n                }\\n            }\\n        }\\n        // map to identify which elements are present in basket 2 in excess\\n        map<ll,ll>req2;\\n        for(auto &it:basket2){\\n            req2[it]++;\\n        }\\n        for(auto &it:req2){\\n            int x =  m[it.first];\\n            int y = it.second;\\n            //if frequency of element in basket 2 is more than what should be in the final basket\\n            if(y >x/2 ){\\n                for(int i = 0 ;i<y-x/2;i++){\\n                    two.push_back(it.first);\\n                }\\n            }\\n        }\\n        \\n        sort(one.begin(),one.end());\\n        sort(two.begin(),two.end());\\n        int i = 0 ;\\n        int j = two.size()-1;\\n        while(i<one.size()){\\n            // now i have two options for each swapping, i can swap the current basket1 and basket2 \\n            // excess elements directly or i can use the minimum element to do the same in 2 swaps\\n            ans+= min((ll) 2*mini ,(ll) min(one[i],two[j]));\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        // using map m for finding frequency of every element combined in both baskets\\n        map<ll,ll>m;\\n        // finding the minimum element of both the baskets combined\\n        ll mini = 1e10;\\n        for(auto &it:basket1){\\n            m[it]++;\\n            mini = min(mini,(ll)it); \\n        }\\n        for(auto &it:basket2){\\n            m[it]++;\\n            mini = min(mini,(ll)it); \\n        }\\n        // if frequency of any element combined in both arrays is odd then that cant be divided\\n       for(auto &it:m){\\n           if(it.second & 1){\\n               return -1;\\n           }\\n       }\\n       // ans variable to store the final answer\\n        ll ans = 0 ;\\n        // map to identify which elements are present in basket 1 in excess\\n        map<ll,ll>req1;\\n        // one vector will store excess elements of basket 1, two will do the same for basket 2\\n        vector<int>one,two;\\n        for(auto &it:basket1){\\n            req1[it]++;\\n        }\\n        for(auto &it:req1){\\n            int x =  m[it.first];\\n            int y = it.second;\\n            //if frequency of element in basket 1 is more than what should be in the final basket\\n            if(y > x/2){\\n                for(int i = 0 ;i<y-x/2;i++){\\n                    one.push_back(it.first);\\n                }\\n            }\\n        }\\n        // map to identify which elements are present in basket 2 in excess\\n        map<ll,ll>req2;\\n        for(auto &it:basket2){\\n            req2[it]++;\\n        }\\n        for(auto &it:req2){\\n            int x =  m[it.first];\\n            int y = it.second;\\n            //if frequency of element in basket 2 is more than what should be in the final basket\\n            if(y >x/2 ){\\n                for(int i = 0 ;i<y-x/2;i++){\\n                    two.push_back(it.first);\\n                }\\n            }\\n        }\\n        \\n        sort(one.begin(),one.end());\\n        sort(two.begin(),two.end());\\n        int i = 0 ;\\n        int j = two.size()-1;\\n        while(i<one.size()){\\n            // now i have two options for each swapping, i can swap the current basket1 and basket2 \\n            // excess elements directly or i can use the minimum element to do the same in 2 swaps\\n            ans+= min((ll) 2*mini ,(ll) min(one[i],two[j]));\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173846,
                "title": "python-3-10-lines-counter-w-example-t-m-85-50",
                "content": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n\\n                                                    # Example: [4, 4, 4, 4, 3] [5, 5, 5, 5, 3]\\n\\n        c1, c2 = Counter(basket1), Counter(basket2) # c1, c2 = {3:1, 4:4}, {3:1, 5:4}\\n        c = c1 + c2                                 #      c = {3:2, 4:4, 5:4} \\n                                                    #\\n        for n in c:                                 #   c[3] = 2//2 = 1\\n            c[n], r = divmod(c[n],2)                #   c[4] = 4//2 = 2\\n            if r: return -1                         #   c[5] = 4//2 = 2\\n\\n        mn = min(c)                                 #     mn = 3\\n        c1-= c                                      #     c1 = {4: 2}\\n        c2-= c                                      #     c2 = {5: 2}\\n\\n        arr = sorted(list(c1.elements())            #    arr = sorted([4,4]+[5,5]) = [4,4,5,5] \\n                       + list(c2.elements()))\\n\\n        return sum(min(2*mn, arr[i])                # return sum(min(6,4), min(6,4)) = 8\\n                     for i in range(len(arr)//2))\\n```\\n[https://leetcode.com/problems/rearranging-fruits/submissions/896231451/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n\\n                                                    # Example: [4, 4, 4, 4, 3] [5, 5, 5, 5, 3]\\n\\n        c1, c2 = Counter(basket1), Counter(basket2) # c1, c2 = {3:1, 4:4}, {3:1, 5:4}\\n        c = c1 + c2                                 #      c = {3:2, 4:4, 5:4} \\n                                                    #\\n        for n in c:                                 #   c[3] = 2//2 = 1\\n            c[n], r = divmod(c[n],2)                #   c[4] = 4//2 = 2\\n            if r: return -1                         #   c[5] = 4//2 = 2\\n\\n        mn = min(c)                                 #     mn = 3\\n        c1-= c                                      #     c1 = {4: 2}\\n        c2-= c                                      #     c2 = {5: 2}\\n\\n        arr = sorted(list(c1.elements())            #    arr = sorted([4,4]+[5,5]) = [4,4,5,5] \\n                       + list(c2.elements()))\\n\\n        return sum(min(2*mn, arr[i])                # return sum(min(6,4), min(6,4)) = 8\\n                     for i in range(len(arr)//2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144240,
                "title": "based-on-realfan-s-solution-improve-the-space-usage-by-not-using-array-in-the-last-step",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} basket1\\n * @param {number[]} basket2\\n * @return {number}\\n */\\nvar minCost = function (basket1, basket2) {\\n  function addToMap(map, num) {\\n    let cnt = map.get(num) || 0;\\n    cnt++;\\n    map.set(num, cnt);\\n  }\\n\\n  function deleteFromMap(map, num) {\\n    let cnt = map.get(num) || 0;\\n    cnt--;\\n    map.set(num, cnt);\\n  }\\n\\n  let min = Number.MAX_SAFE_INTEGER;\\n  let map = new Map();\\n  for (let num of basket1) {\\n    addToMap(map, num);\\n    min = Math.min(min, num);\\n  }\\n  for (let num of basket2) {\\n    deleteFromMap(map, num);\\n    min = Math.min(min, num);\\n  }\\n\\n  for (let cnt of map.values()) {\\n    let abs = Math.abs(cnt);\\n    if (abs % 2 !== 0) return -1;\\n  }\\n\\n  let kvs = Array.from(map);\\n  kvs.sort((kv1, kv2) => kv1[0] - kv2[0]);\\n  let totalCount = kvs.reduce((prev, kv) => prev + Math.abs(kv[1]), 0);\\n\\n  let swaped = 0;\\n  let ans = 0;\\n  for (let i = 0; i < kvs.length; i++) {\\n    let [num, freq] = kvs[i];\\n    let half = Math.abs(freq) / 2;\\n    while (half-- > 0) {\\n      ans += Math.min(2 * min, num);\\n      swaped++;\\n      if (swaped === totalCount / 4) return ans;\\n    }\\n  }\\n  \\n  return 0;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} basket1\\n * @param {number[]} basket2\\n * @return {number}\\n */\\nvar minCost = function (basket1, basket2) {\\n  function addToMap(map, num) {\\n    let cnt = map.get(num) || 0;\\n    cnt++;\\n    map.set(num, cnt);\\n  }\\n\\n  function deleteFromMap(map, num) {\\n    let cnt = map.get(num) || 0;\\n    cnt--;\\n    map.set(num, cnt);\\n  }\\n\\n  let min = Number.MAX_SAFE_INTEGER;\\n  let map = new Map();\\n  for (let num of basket1) {\\n    addToMap(map, num);\\n    min = Math.min(min, num);\\n  }\\n  for (let num of basket2) {\\n    deleteFromMap(map, num);\\n    min = Math.min(min, num);\\n  }\\n\\n  for (let cnt of map.values()) {\\n    let abs = Math.abs(cnt);\\n    if (abs % 2 !== 0) return -1;\\n  }\\n\\n  let kvs = Array.from(map);\\n  kvs.sort((kv1, kv2) => kv1[0] - kv2[0]);\\n  let totalCount = kvs.reduce((prev, kv) => prev + Math.abs(kv[1]), 0);\\n\\n  let swaped = 0;\\n  let ans = 0;\\n  for (let i = 0; i < kvs.length; i++) {\\n    let [num, freq] = kvs[i];\\n    let half = Math.abs(freq) / 2;\\n    while (half-- > 0) {\\n      ans += Math.min(2 * min, num);\\n      swaped++;\\n      if (swaped === totalCount / 4) return ans;\\n    }\\n  }\\n  \\n  return 0;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144123,
                "title": "java-swap-min-with-max-or-use-min-to-swap-two-largest",
                "content": "# Intuition\\n* It\\'s possible to make baskets equal if concatination of both baskets has each number even number of time.\\n* You can swap min missing numbers with max missing number\\n    * 2, 2 and 60, 60 => swapping 2 and 60    \\n* OR you can use twice min (not nessesarly missing) number, to swap two largest missing numbers\\n    * 1, 30, 30 and 1, 5, 5 => swapping 1 and 30, arrays turn into 1, 1, 30 and 30, 5, 5 => swapping 1 and 5, arrays turn into 1, 5, 30 and 30, 1, 5\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        var ac = new HashMap<Integer, Integer>();\\n        var cm = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < basket1.length; i++) {\\n            ac.merge(basket1[i], 1, Integer::sum);\\n            cm.merge(basket1[i], 1, Integer::sum);\\n            cm.merge(basket2[i], 1, Integer::sum);\\n        }\\n\\n        int min = Integer.MAX_VALUE;\\n        var m = new TreeMap<Integer, Integer>();\\n        for (var e : cm.entrySet()) {\\n            if (e.getValue() % 2 == 1) {\\n                return -1;\\n            }\\n            min = Math.min(min, e.getKey());\\n            var missingCount = ac.getOrDefault(e.getKey(), 0) - e.getValue() / 2;\\n            if (missingCount == 0) {\\n                continue;\\n            }\\n            // we don\\'t care if missingCount is positive or negative, we care that it\\'s != 0\\n            // i.e. arrays have different count of this number\\n            m.merge(e.getKey(), Math.abs(missingCount), Integer::sum);\\n        }\\n\\n        long res = 0;\\n        while (m.size() > 0) {\\n            if (m.firstKey() <= min * 2) {\\n                // swap min missing with max missing\\n                res += m.firstKey();\\n                if (m.merge(m.firstKey(), -1, Integer::sum) == 0) {\\n                    m.remove(m.firstKey());\\n                }\\n                if (m.merge(m.lastKey(), -1, Integer::sum) == 0) {\\n                    m.remove(m.lastKey());\\n                }\\n            } else {\\n                // use min twice to swap two largest\\n                res += min * 2;\\n                if (m.merge(m.lastKey(), -1, Integer::sum) == 0) {\\n                    m.remove(m.lastKey());\\n                }\\n                if (m.merge(m.lastKey(), -1, Integer::sum) == 0) {\\n                    m.remove(m.lastKey());\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        var ac = new HashMap<Integer, Integer>();\\n        var cm = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < basket1.length; i++) {\\n            ac.merge(basket1[i], 1, Integer::sum);\\n            cm.merge(basket1[i], 1, Integer::sum);\\n            cm.merge(basket2[i], 1, Integer::sum);\\n        }\\n\\n        int min = Integer.MAX_VALUE;\\n        var m = new TreeMap<Integer, Integer>();\\n        for (var e : cm.entrySet()) {\\n            if (e.getValue() % 2 == 1) {\\n                return -1;\\n            }\\n            min = Math.min(min, e.getKey());\\n            var missingCount = ac.getOrDefault(e.getKey(), 0) - e.getValue() / 2;\\n            if (missingCount == 0) {\\n                continue;\\n            }\\n            // we don\\'t care if missingCount is positive or negative, we care that it\\'s != 0\\n            // i.e. arrays have different count of this number\\n            m.merge(e.getKey(), Math.abs(missingCount), Integer::sum);\\n        }\\n\\n        long res = 0;\\n        while (m.size() > 0) {\\n            if (m.firstKey() <= min * 2) {\\n                // swap min missing with max missing\\n                res += m.firstKey();\\n                if (m.merge(m.firstKey(), -1, Integer::sum) == 0) {\\n                    m.remove(m.firstKey());\\n                }\\n                if (m.merge(m.lastKey(), -1, Integer::sum) == 0) {\\n                    m.remove(m.lastKey());\\n                }\\n            } else {\\n                // use min twice to swap two largest\\n                res += min * 2;\\n                if (m.merge(m.lastKey(), -1, Integer::sum) == 0) {\\n                    m.remove(m.lastKey());\\n                }\\n                if (m.merge(m.lastKey(), -1, Integer::sum) == 0) {\\n                    m.remove(m.lastKey());\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143759,
                "title": "easy-understanding-solution-prefix-sum-unordered-map",
                "content": "**Time complexity : 0(n) & Space Complexity: 0(n)**\\n\\n```\\nvector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n    vector<int> v, ans;\\n    unordered_map<char, int> vowel;\\n    vowel[\\'a\\'] = 1;\\n    vowel[\\'e\\'] = 1;\\n    vowel[\\'i\\'] = 1;\\n    vowel[\\'o\\'] = 1;\\n    vowel[\\'u\\'] = 1;\\n\\n\\n    int sum = 0;\\n    for (auto word : words) {\\n        if (vowel[word[0]] && vowel[word[word.size() - 1]])\\n            sum += 1;\\n        \\n        v.push_back(sum);\\n    }\\n\\n\\n    for (auto q : queries) {\\n        if (q[0] == 0)\\n            ans.push_back(v[q[1]]);\\n        else\\n            ans.push_back(v[q[1]] - v[q[0]-1]);\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\\n    vector<int> v, ans;\\n    unordered_map<char, int> vowel;\\n    vowel[\\'a\\'] = 1;\\n    vowel[\\'e\\'] = 1;\\n    vowel[\\'i\\'] = 1;\\n    vowel[\\'o\\'] = 1;\\n    vowel[\\'u\\'] = 1;\\n\\n\\n    int sum = 0;\\n    for (auto word : words) {\\n        if (vowel[word[0]] && vowel[word[word.size() - 1]])\\n            sum += 1;\\n        \\n        v.push_back(sum);\\n    }\\n\\n\\n    for (auto q : queries) {\\n        if (q[0] == 0)\\n            ans.push_back(v[q[1]]);\\n        else\\n            ans.push_back(v[q[1]] - v[q[0]-1]);\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3143675,
                "title": "swap-min-and-max-elements-with-explanation-c",
                "content": "**EXPLANATION:**\\nIf we count all the elements in both arrays, Any element whose **count is odd** shows that after swapping there will be **no possibility that both arrays have the same count** of that element.\\nNow the main logic of the question states that the cost of swapping will be the min of two swapped elements: **(So we can conclude that)**\\n1. We should swap the lowest and the highest elements so that the cost will add up will be min.\\nfor ex: In **{1  1 2 3 1000 1000 }  {4 4 2 3 2000 2000}** in this if we swap **(1000,2000)** will add my **cost+= 1000** whereas the optimal way is to swap **(1,2000)** which will add my **cost+= 1.**\\n2. There is no restriction on keeping minimum swaps, but we need to decrease the Cost of swapping. So there is a possibility that we can further decrease the swapping cost.\\nfor ex: In **{1 2 3 1000 1000 }  {1 2 3 2000 2000}**  we have to swap **{1000,2000}.** there\\'s no other way to decrease the swap count but if we have unlimited swaps, we can do multiple swaps to minimize the cost. therefore, the minimum element can help us to achive it. Let\\'s say we swap using **{1}** which is the **minimum element** in the arrays. So take anyone of them and try to swap.**{1,1000} =>** will result into **{1 1 2 3 1000 }  {1000 2 3 2000 2000}** and swapping again to get back {1} to original position **{1,2000} =>** will result into **{1 2 3 1000 2000}  {1 2 3 1000 2000}**, therefore the cost will be **cost+= 2*(min element)** which is very less than swapping **{1000,2000}**. But the result will be the same as only {1000,2000} gets swapped but using the minimum element twice. \\n3. Now why should I swap the elements which already have the same count in both arrays? So, I just removed them using \"mp2\". And Since all the elements we needed to swap have twice the quantity of the other array (obviously that\\'s why swapping is possible), we have to shift only one out of them. 3rd FOR loop is helping me out with the same.\\n\\nTherefore in both the swapping cases, we have to take a minimum of both cases to get the answer. ( ans+= min(2* min element, min(two swapping element)); )\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        \\n        map<int,int> mp2;\\n        long long ans=0;\\n        int mn=basket1[0];\\n        vector<int> a,b;\\n        \\n        for(auto &it: basket1){\\n            mp2[it]++;  // to seperate doubles in basket 1 and basket 2\\n            mn= min(mn,it); // taking min element in both the baskets\\n        }\\n        for(auto &it: basket2){\\n            mp2[it]--;\\n            mn= min(mn,it);\\n        }\\n \\n        // seperating swapping elements from both baskets\\n        for(auto &it: mp2){\\n\\t\\t    if(it.second%2){\\n                return -1;\\n             }\\n            int q= it.second/2;\\n            int w= it.first;\\n            if(q>0){\\n                while(q--){\\n                    a.push_back(w);\\n                }\\n            }\\n            else if(q<0){\\n                q= -q;\\n                while(q--){\\n                    b.push_back(w);\\n                }\\n            }\\n        }\\n        \\n        if(a.size()!=b.size()){\\n            return -1;\\n        }\\n        \\n        int l=0,r=b.size()-1;\\n        \\n        while(l<a.size()){\\n            ans+= 2*mn< min(a[l],b[r])?2*mn: min(a[l],b[r]);\\n\\t\\t\\t// we can swap the elements using max of first array and min of second array or \\n\\t\\t\\t//using minimumth elements of both the baskets which will use twice operations fro swapping\\n            l++;r--;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        \\n        map<int,int> mp2;\\n        long long ans=0;\\n        int mn=basket1[0];\\n        vector<int> a,b;\\n        \\n        for(auto &it: basket1){\\n            mp2[it]++;  // to seperate doubles in basket 1 and basket 2\\n            mn= min(mn,it); // taking min element in both the baskets\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3152985,
                "title": "rearranging-fruits-java-hashmap-priorityqueue-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        int min=basket1[0];\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int f:basket1){\\n            min=Math.min(min,f);\\n            hm.put(f,hm.getOrDefault(f,0)+1);\\n        }\\n\\n        for(int f:basket2){\\n            min=Math.min(min,f);\\n            hm.put(f,hm.getOrDefault(f,0)-1);\\n            \\n        }\\n\\n        PriorityQueue<Integer> pq=new PriorityQueue<>();\\n        for(int key:hm.keySet()){\\n            if(hm.get(key)%2!=0){\\n                return -1;\\n            }\\n\\n            for(int i=1;i<=Math.abs(hm.get(key))/2;i++){\\n                pq.add(key);\\n            }\\n        }\\n\\n\\n        int k=pq.size()/2;\\n        long ans=0;\\n        while(k-->0){\\n            if(pq.peek()<2*min){\\n                ans+=pq.remove();\\n            }else{\\n                ans+=2*min;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        int min=basket1[0];\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        for(int f:basket1){\\n            min=Math.min(min,f);\\n            hm.put(f,hm.getOrDefault(f,0)+1);\\n        }\\n\\n        for(int f:basket2){\\n            min=Math.min(min,f);\\n            hm.put(f,hm.getOrDefault(f,0)-1);\\n            \\n        }\\n\\n        PriorityQueue<Integer> pq=new PriorityQueue<>();\\n        for(int key:hm.keySet()){\\n            if(hm.get(key)%2!=0){\\n                return -1;\\n            }\\n\\n            for(int i=1;i<=Math.abs(hm.get(key))/2;i++){\\n                pq.add(key);\\n            }\\n        }\\n\\n\\n        int k=pq.size()/2;\\n        long ans=0;\\n        while(k-->0){\\n            if(pq.peek()<2*min){\\n                ans+=pq.remove();\\n            }else{\\n                ans+=2*min;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152454,
                "title": "c-beginner-s-guide-to-solving-this-question-0-ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int,int> mp; //map declared\\n        int i, n=basket1.size();// index for loops declared and array size stored\\n        for(i=0;i<n;i++)//loop 1 starts, no brackets required as single statement loop(in line 7 see comma instead of semi-colon)\\n            mp[basket1[i]]++,//increasing mp by 1 by taking index from basket1\\n            mp[basket2[i]]--;//decreasing mp by 1 by taking index from basket2\\n        vector<int> v;\\n        for(auto [frst,scnd]:mp){ //loop 2 starts, as mp as a map has 2 values, first() and second(), we take them up in every iteration as frst and scnd for easy understanding\\n            scnd = abs(scnd);//changing negative values to positive\\n            if(scnd%2) return -1;//if scnd is not divisible by 2, return -1, ie, minimum cost to make both the baskets equal is impossible.\\n            scnd/=2;//divide scnd by 2\\n            while(scnd--)//loop 3 starts, while scnd is not 0, keep decreasing it by 1\\n                v.push_back(frst);//push frst in v in a loop\\n        }\\n        int minn = mp.begin()->first;//minn stores the first map\\'s first() value\\n        long long ans = 0; //this would store our answer\\n        for(i=0; i<v.size()/2; i++)//loop 4 starts, going on till half of vector v\\'s size\\n            ans += min(v[i], minn*2);//keep adding the minimum of(vector[index],minn*2) in the ans variable\\n        return ans;//NIRVANA\\uD83D\\uDE4F\\uD83C\\uDFFC\\n    }\\n};\\n//Upvote if it helped you \\uD83D\\uDC74\\uD83C\\uDFFC\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int,int> mp; //map declared\\n        int i, n=basket1.size();// index for loops declared and array size stored\\n        for(i=0;i<n;i++)//loop 1 starts, no brackets required as single statement loop(in line 7 see comma instead of semi-colon)\\n            mp[basket1[i]]++,//increasing mp by 1 by taking index from basket1\\n            mp[basket2[i]]--;//decreasing mp by 1 by taking index from basket2\\n        vector<int> v;\\n        for(auto [frst,scnd]:mp){ //loop 2 starts, as mp as a map has 2 values, first() and second(), we take them up in every iteration as frst and scnd for easy understanding\\n            scnd = abs(scnd);//changing negative values to positive\\n            if(scnd%2) return -1;//if scnd is not divisible by 2, return -1, ie, minimum cost to make both the baskets equal is impossible.\\n            scnd/=2;//divide scnd by 2\\n            while(scnd--)//loop 3 starts, while scnd is not 0, keep decreasing it by 1\\n                v.push_back(frst);//push frst in v in a loop\\n        }\\n        int minn = mp.begin()->first;//minn stores the first map\\'s first() value\\n        long long ans = 0; //this would store our answer\\n        for(i=0; i<v.size()/2; i++)//loop 4 starts, going on till half of vector v\\'s size\\n            ans += min(v[i], minn*2);//keep adding the minimum of(vector[index],minn*2) in the ans variable\\n        return ans;//NIRVANA\\uD83D\\uDE4F\\uD83C\\uDFFC\\n    }\\n};\\n//Upvote if it helped you \\uD83D\\uDC74\\uD83C\\uDFFC\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145336,
                "title": "python-frequency-map-approach-greedy-easy-to-understand-optimal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrequency maps were the way to go\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a frequency map where we increment the occurence of instances for the first basket and decrement for the second one so that the possible elements to be exchanged have non-zero frequencies. Here, we check for odd total frequency for a fruit and if found, we return -1. Else, we take half of those non-zero fruits and store them in an array `toBeExchanged`. Then, sorting `toBeExchanged` ensures that we consider minimum element first while we traverse through the array\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        fruitsCount, minFruits = defaultdict(int), min(min(basket1), min(basket2))\\n        for fruit in basket1:\\n            fruitsCount[fruit] += 1\\n        for fruit in basket2:\\n            fruitsCount[fruit] -= 1\\n        toBeExchanged, cost = [], 0\\n        for fruit in fruitsCount:\\n            if fruitsCount[fruit] % 2:\\n                return -1\\n            for num in range(abs(fruitsCount[fruit]) // 2):\\n                toBeExchanged.append(fruit)\\n        toBeExchanged.sort()\\n        for idx in range(len(toBeExchanged) // 2):\\n            cost += min(minFruits * 2, toBeExchanged[idx])\\n        return cost\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```python []\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        fruitsCount, minFruits = defaultdict(int), min(min(basket1), min(basket2))\\n        for fruit in basket1:\\n            fruitsCount[fruit] += 1\\n        for fruit in basket2:\\n            fruitsCount[fruit] -= 1\\n        toBeExchanged, cost = [], 0\\n        for fruit in fruitsCount:\\n            if fruitsCount[fruit] % 2:\\n                return -1\\n            for num in range(abs(fruitsCount[fruit]) // 2):\\n                toBeExchanged.append(fruit)\\n        toBeExchanged.sort()\\n        for idx in range(len(toBeExchanged) // 2):\\n            cost += min(minFruits * 2, toBeExchanged[idx])\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145168,
                "title": "c-map-and-count-easy-solution-beginner-friendly-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Problem needs you to evenly divide the items into baskets, so firstly every items should exists in pair.\\n\\n**Now as it has been told to minimise the swap cost, there can be only two options : :**\\n1. Swap two items costing you the smaller value\\n2. Execute the swap though a third item that might reduce the code\\n \\n*We need to consider the minimum of these two.*\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Process the count of items in each basket and map the differene.\\n2. For any item, the diference should be even or it can\\'t be equally divided\\n3. Stored these **(Items/2)** to be exchanged *( to make their count in both basket equal )* into an Array and kept it in sorted form.\\n4. Taken the **minimum** item among the Baskets as a medium to check if a lesser cost trade exists\\n5.  For items to be exchanged, taken  exactly **first sorted half** of the list as they are going to be swapped with each other\\n6. For each item considered the ***min*( Medium x 2 , Current_Item )**\\n\\n# Complexity\\n- Time complexity : $$O((n+m)log(m+n))+O(m+n)$$\\n- Space complexity : $$O(m+n)$$\\n# Code\\n```\\nclass Solution\\n{\\n  public:\\n    long long minCost(vector<int> &basket1, vector<int> &basket2)\\n    {\\n\\n      unordered_map<int, int> count_fruits;\\n\\n      int mini = INT_MAX;\\n\\n      // Mapping the difference for each fruit in either baskets\\n      for (auto itr : basket1)\\n      {\\n        count_fruits[itr]++;\\n        mini = min(mini, itr);\\n      }\\n\\n      for (auto itr : basket2)\\n      {\\n        count_fruits[itr]--;\\n        mini = min(mini, itr);\\n      }\\n\\n      // Storing the items to be exchanged\\n      vector<int> ex_items;\\n\\n      for (auto itr : count_fruits)\\n      {\\n        // If the difference is odd we cannot divide it\\n        if (itr.second % 2 != 0)\\n          return -1;\\n\\n        for (int i = 0; i < abs(itr.second) / 2; i++)\\n        {\\n          ex_items.push_back(itr.first);\\n        }\\n      }\\n\\n      long long cost = 0;\\n\\n      sort(ex_items.begin(), ex_items.end());\\n\\n      for (int i = 0; i < ex_items.size() / 2; i++)\\n      {\\n        // Considering the minimum of either ways\\n        cost += min(mini * 2, ex_items[i]);\\n      }\\n      return cost;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution\\n{\\n  public:\\n    long long minCost(vector<int> &basket1, vector<int> &basket2)\\n    {\\n\\n      unordered_map<int, int> count_fruits;\\n\\n      int mini = INT_MAX;\\n\\n      // Mapping the difference for each fruit in either baskets\\n      for (auto itr : basket1)\\n      {\\n        count_fruits[itr]++;\\n        mini = min(mini, itr);\\n      }\\n\\n      for (auto itr : basket2)\\n      {\\n        count_fruits[itr]--;\\n        mini = min(mini, itr);\\n      }\\n\\n      // Storing the items to be exchanged\\n      vector<int> ex_items;\\n\\n      for (auto itr : count_fruits)\\n      {\\n        // If the difference is odd we cannot divide it\\n        if (itr.second % 2 != 0)\\n          return -1;\\n\\n        for (int i = 0; i < abs(itr.second) / 2; i++)\\n        {\\n          ex_items.push_back(itr.first);\\n        }\\n      }\\n\\n      long long cost = 0;\\n\\n      sort(ex_items.begin(), ex_items.end());\\n\\n      for (int i = 0; i < ex_items.size() / 2; i++)\\n      {\\n        // Considering the minimum of either ways\\n        cost += min(mini * 2, ex_items[i]);\\n      }\\n      return cost;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144011,
                "title": "duplicate-of-chfnswps",
                "content": "@Leetcode Please check the questions before giving them in contest.\\nLink for original problem : https://www.codechef.com/JULY20A/problems/CHFNSWPS\\n\\nI have submitted one of the solution after contest from above question and it got accepted.\\nhttps://leetcode.com/submissions/detail/891777615/",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3877239,
                "title": "c-easy-and-clean-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& a, vector<int>& b) {\\n        map<int,int>mp;\\n        int n=a.size();\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            mp[a[i]]++;\\n            mp[b[i]]--;\\n            mini=min(mini,a[i]);\\n            mini=min(mini,b[i]);\\n        }\\n        vector<int>x;\\n        for(auto it:mp){\\n            int t=it.second;\\n            if(t%2==1)return -1;\\n            else{\\n                for(int i=0;i<abs(t)/2;i++){\\n                    x.push_back(it.first);\\n                }\\n            }\\n        }\\n        long long ans=0;\\n        int m=x.size();\\n        for(int i=0;i<m/2;i++){\\n            ans+=min(x[i],2*mini);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& a, vector<int>& b) {\\n        map<int,int>mp;\\n        int n=a.size();\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            mp[a[i]]++;\\n            mp[b[i]]--;\\n            mini=min(mini,a[i]);\\n            mini=min(mini,b[i]);\\n        }\\n        vector<int>x;\\n        for(auto it:mp){\\n            int t=it.second;\\n            if(t%2==1)return -1;\\n            else{\\n                for(int i=0;i<abs(t)/2;i++){\\n                    x.push_back(it.first);\\n                }\\n            }\\n        }\\n        long long ans=0;\\n        int m=x.size();\\n        for(int i=0;i<m/2;i++){\\n            ans+=min(x[i],2*mini);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419102,
                "title": "with-comments-explanation",
                "content": "```\\n    //to have equal in both baskets --> total freq would be even\\n    //Instead of using 2 maps we can use 1 map and +basket1 -basket2\\n    //if equal its frequency would be 0\\n    \\n    //To have min ans we swap min with max value\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int,int> mp;\\n        int n = basket1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[basket1[i]]++;\\n            mp[basket2[i]]--;\\n        }\\n        //if any frequency is odd ---> impossible\\n        //further --> we convert each freq as freq/2 to get number of operations --> summation should be 0 of netdiff\\n        // add all operations\\n        //again traverse map add key to ans until operations left\\n        long long netdiff = 0;\\n        long long operations = 0;\\n        long long cost = 0;\\n        for(auto it:mp)\\n        {\\n            if(((int)abs(it.second)%2)==1) return -1;\\n            netdiff += it.second;\\n            if(it.second > 0) operations +=it.second/2;\\n        }\\n        if(netdiff!=0) return -1; //unequally distributed\\n        for(auto it:mp)\\n        {\\n            long long cnt = (int)abs(it.second)/2 <= operations ? (int)abs(it.second)/2 : operations;\\n            cost+=min(it.first, begin(mp)->first * 2)*cnt; //This edge case i was missing // that even though the minimum element has same frequency in both the arrays we can still use it to have minimum swaps //seen from votrubac\\n            // Note that it may be cheaper to do two swaps with the cheapest fruit, that one swap with the current one.\\n\\n\\n            operations-=cnt;\\n            if(operations==0) break;\\n        }\\n        return cost;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\n    //to have equal in both baskets --> total freq would be even\\n    //Instead of using 2 maps we can use 1 map and +basket1 -basket2\\n    //if equal its frequency would be 0\\n    \\n    //To have min ans we swap min with max value\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int,int> mp;\\n        int n = basket1.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[basket1[i]]++;\\n            mp[basket2[i]]--;\\n        }\\n        //if any frequency is odd ---> impossible\\n        //further --> we convert each freq as freq/2 to get number of operations --> summation should be 0 of netdiff\\n        // add all operations\\n        //again traverse map add key to ans until operations left\\n        long long netdiff = 0;\\n        long long operations = 0;\\n        long long cost = 0;\\n        for(auto it:mp)\\n        {\\n            if(((int)abs(it.second)%2)==1) return -1;\\n            netdiff += it.second;\\n            if(it.second > 0) operations +=it.second/2;\\n        }\\n        if(netdiff!=0) return -1; //unequally distributed\\n        for(auto it:mp)\\n        {\\n            long long cnt = (int)abs(it.second)/2 <= operations ? (int)abs(it.second)/2 : operations;\\n            cost+=min(it.first, begin(mp)->first * 2)*cnt; //This edge case i was missing // that even though the minimum element has same frequency in both the arrays we can still use it to have minimum swaps //seen from votrubac\\n            // Note that it may be cheaper to do two swaps with the cheapest fruit, that one swap with the current one.\\n\\n\\n            operations-=cnt;\\n            if(operations==0) break;\\n        }\\n        return cost;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3145091,
                "title": "c-unordered-map-sorting-tc-o-n-log-n-sc-o-n",
                "content": "```\\n/*\\n\\tUse unordered map to store freq of each fruit cost in basket 1\\n\\tthen remove all the costs which are same in basket 2  & add new fruit costs\\n\\tthen map contains only those costs which is either present in basket 1 or 2 \\n\\tif any of the cost has odd freq then we are not able to swap it with any other basket so return -1\\n\\telse add all cost into different vector single times means if freq[10] = 4 then add 4/2 = 2 times that cost [10,10] because we have to swap only single element \\n\\tthen sort it so that we can swap it with smaller value to minimize our total swap cost\\n\\there there is 2 possibility either we can swap it directly then our cost is min of both costs or we can swap 2 times from min value from the baskets then our cost is 2*min value.\\n\\tso we can swap it from which has smaller value\\n\\t\\n\\tEX : [3,16,16][3,15,15]\\n\\tstore diff value in vector [16,15] there are 2 values in vector so total no of swap is 2/2 = 1 \\n\\tsort the vector [15,16]\\n\\tthen swap 15,16 cost = 15  or   swap 3,15 & 3,16 cost = 3*2=6\\n\\tso our min cost is 6 not 15 \\n*/ \\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int,int> bas;  // to store frequency\\n        int mn = INT32_MAX;  // store min value from both basket\\n        for(auto &x:basket1){  // add basket 1 costs\\n            mn = min(mn,x);\\n            bas[x]++;   \\n        }\\n        for(auto &x:basket2) { //remove basket 2 costs\\n            mn = min(mn,x);\\n            bas[x]--;\\n        }\\n        vector<int> min_v; // store all differnt values singles times which we have to swap\\n        for(auto &x:bas){\\n            int size = abs(x.second);\\n            if(size&1) return -1;  // if odd freq present return -1\\n            size/=2;    // add single times \\n            while(size--) min_v.push_back(x.first);\\n        }\\n        sort(min_v.begin(),min_v.end());  // sort the vector to minimize swap cost\\n        long long ans = 0;\\n        for(int i=0;i<min_v.size()/2;i++){  // total no of swap is n/2 so run loop from 0 to n/2\\n            ans+=min(2*mn,min_v[i]);   // our min cost is min of cur min value or swap it 2 times from min value from basket\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf You Like Solution Please Upvote :)\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n/*\\n\\tUse unordered map to store freq of each fruit cost in basket 1\\n\\tthen remove all the costs which are same in basket 2  & add new fruit costs\\n\\tthen map contains only those costs which is either present in basket 1 or 2 \\n\\tif any of the cost has odd freq then we are not able to swap it with any other basket so return -1\\n\\telse add all cost into different vector single times means if freq[10] = 4 then add 4/2 = 2 times that cost [10,10] because we have to swap only single element \\n\\tthen sort it so that we can swap it with smaller value to minimize our total swap cost\\n\\there there is 2 possibility either we can swap it directly then our cost is min of both costs or we can swap 2 times from min value from the baskets then our cost is 2*min value.\\n\\tso we can swap it from which has smaller value\\n\\t\\n\\tEX : [3,16,16][3,15,15]\\n\\tstore diff value in vector [16,15] there are 2 values in vector so total no of swap is 2/2 = 1 \\n\\tsort the vector [15,16]\\n\\tthen swap 15,16 cost = 15  or   swap 3,15 & 3,16 cost = 3*2=6\\n\\tso our min cost is 6 not 15 \\n*/ \\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int,int> bas;  // to store frequency\\n        int mn = INT32_MAX;  // store min value from both basket\\n        for(auto &x:basket1){  // add basket 1 costs\\n            mn = min(mn,x);\\n            bas[x]++;   \\n        }\\n        for(auto &x:basket2) { //remove basket 2 costs\\n            mn = min(mn,x);\\n            bas[x]--;\\n        }\\n        vector<int> min_v; // store all differnt values singles times which we have to swap\\n        for(auto &x:bas){\\n            int size = abs(x.second);\\n            if(size&1) return -1;  // if odd freq present return -1\\n            size/=2;    // add single times \\n            while(size--) min_v.push_back(x.first);\\n        }\\n        sort(min_v.begin(),min_v.end());  // sort the vector to minimize swap cost\\n        long long ans = 0;\\n        for(int i=0;i<min_v.size()/2;i++){  // total no of swap is n/2 so run loop from 0 to n/2\\n            ans+=min(2*mn,min_v[i]);   // our min cost is min of cur min value or swap it 2 times from min value from basket\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144833,
                "title": "c-180-ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSort `basket1` and `basket2`.\\n\\nDenote the minimal value element of `basket1` and `basket2` by `x` and twice of its value by `a`.\\n\\nCompare `basket1` with `basket2`:\\n  Store one element of each `basket1`\\'s extra identical pair in to an array named `u`.\\n  Store one element of each `basket2`\\'s extra identical pair in to an array named `w`.\\n\\n`u` and `w` will have same size denoted by `k`.\\n\\nTo make the 2 baskets equal, one could swap pairs:\\n`swap(u[i], w[k-1-i])`\\nwhih costs `min(u[i], w[k-1-i])`\\nor do a double swaps:\\n```\\nswap(x, u[i])\\nswap(w[k-1-i], x)\\n```    \\nwhich costs `a`.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwe can reuse `basket1` and `basket2` as `u` and `w` to minimize memory usage.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n*ln(n))$$ where `n` is size of `basket1`.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(1)$$ if not count memory occupied by `basket1` and `basket2`.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n = basket1.size();\\n\\n        auto & u = basket1;\\n        auto & w = basket2;\\n\\n        sort(u.begin(), u.end());\\n        sort(w.begin(), w.end());\\n\\n        int a = min(u[0], w[0]);\\n        a <<= 1;\\n\\n        int i, j, k, l;\\n\\n        i = j = k = l = 0;\\n\\n        while(i<n && j<n)\\n        {\\n            if (u[i] == w[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if (u[i] < w[j])\\n            {\\n                if (i == n-1 || u[i] != u[i+1])\\n                    return -1;\\n\\n                u[k++] = u[i];\\n\\n                i += 2;\\n            }\\n            else\\n            {\\n                if (j == n-1 || w[j] != w[j+1])\\n                    return -1;\\n\\n                w[l++] = w[j];\\n\\n                j += 2;\\n            }\\n        }\\n        \\n        while (i<n)\\n        {\\n            if (u[i] != u[i+1])\\n                return -1;\\n\\n            u[k++] = u[i];\\n\\n            i += 2;\\n        }\\n\\n        while (j<n)\\n        {\\n            if (w[j] != w[j+1])\\n                return -1;\\n\\n            w[l++] = w[j];\\n\\n            j += 2;\\n        }\\n    \\n        long long rt = 0;\\n        for (i=0; i<k; i++)\\n        {\\n            rt += min(min(u[i], w[k-1-i]), a);\\n        }\\n        \\n        return rt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nswap(x, u[i])\\nswap(w[k-1-i], x)\\n```\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n = basket1.size();\\n\\n        auto & u = basket1;\\n        auto & w = basket2;\\n\\n        sort(u.begin(), u.end());\\n        sort(w.begin(), w.end());\\n\\n        int a = min(u[0], w[0]);\\n        a <<= 1;\\n\\n        int i, j, k, l;\\n\\n        i = j = k = l = 0;\\n\\n        while(i<n && j<n)\\n        {\\n            if (u[i] == w[j])\\n            {\\n                i++;\\n                j++;\\n            }\\n            else if (u[i] < w[j])\\n            {\\n                if (i == n-1 || u[i] != u[i+1])\\n                    return -1;\\n\\n                u[k++] = u[i];\\n\\n                i += 2;\\n            }\\n            else\\n            {\\n                if (j == n-1 || w[j] != w[j+1])\\n                    return -1;\\n\\n                w[l++] = w[j];\\n\\n                j += 2;\\n            }\\n        }\\n        \\n        while (i<n)\\n        {\\n            if (u[i] != u[i+1])\\n                return -1;\\n\\n            u[k++] = u[i];\\n\\n            i += 2;\\n        }\\n\\n        while (j<n)\\n        {\\n            if (w[j] != w[j+1])\\n                return -1;\\n\\n            w[l++] = w[j];\\n\\n            j += 2;\\n        }\\n    \\n        long long rt = 0;\\n        for (i=0; i<k; i++)\\n        {\\n            rt += min(min(u[i], w[k-1-i]), a);\\n        }\\n        \\n        return rt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144160,
                "title": "c",
                "content": "# Intuition\\nsimple calculute number of swap operations\\nif : number of operation is odd return -1\\nelse : cal. minimun number of swap operations.\\n\\n# Approach\\ntake a view of code\\n\\n# Complexity\\n- Time complexity:\\nO(N log(N))\\n\\n- Space complexity: O(4 * N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<int,int>mp1;\\n        map<int,int>mp2;\\n        map<int,int>mp;\\n        for(auto i : b1) {mp1[i]++;mp[i]++;}\\n        for(auto i : b2) {mp2[i]++;mp[i]++;}\\n        for(auto i : mp) {\\n            if(i.second&1) return -1; // when number of operation is odd then we are able to swap all \\n                                      // values with equal frquency \\n        }\\n        vector<vector<long long int>>pa; // store element with number swap opration required to  that \\n                                        //  element\\n        int val = -1; // store minimun value of booth baskets\\n        for(auto i : mp) {\\n            if(val == -1) val = i.first;\\n            int opr = abs(mp1[i.first] - mp2[i.first]);\\n            if(opr&1) return -1;\\n            opr /= 2;\\n            if(opr != 0)pa.push_back({i.first , opr});\\n        }\\n        sort(begin(pa) , end(pa));\\n        long long sum = 0;\\n        int i=0;\\n        int j=pa.size()-1;\\n        int pr = 0;\\n        int po = 0;\\n        while(i <= j) {\\n            int opr1 = pa[i][1];\\n            int opr2 = pa[j][1];\\n            // edge case\\n            if(i == j) {\\n                opr1 /= 2;\\n                    sum += (pa[i][0] * opr1);\\n                break;\\n            }\\n            // when we swap 2 element with each other \\n            if(min(pa[i][0] , pa[j][0]) < 2*val){if(opr1 >= opr2) {\\n                pa[i][1] -= opr2;\\n                sum += (pa[i][0] * opr2);\\n                j--;\\n            }\\n            else {\\n                pa[j][1] -= opr1;\\n                sum += (pa[i][0] * opr1);\\n                i++;\\n            }}\\n            // when we swap the elements using minimun value (val) of both baskets\\n            else {\\n                sum += ((long long)(opr1+opr2) * val);\\n                i++;\\n                j--;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<int,int>mp1;\\n        map<int,int>mp2;\\n        map<int,int>mp;\\n        for(auto i : b1) {mp1[i]++;mp[i]++;}\\n        for(auto i : b2) {mp2[i]++;mp[i]++;}\\n        for(auto i : mp) {\\n            if(i.second&1) return -1; // when number of operation is odd then we are able to swap all \\n                                      // values with equal frquency \\n        }\\n        vector<vector<long long int>>pa; // store element with number swap opration required to  that \\n                                        //  element\\n        int val = -1; // store minimun value of booth baskets\\n        for(auto i : mp) {\\n            if(val == -1) val = i.first;\\n            int opr = abs(mp1[i.first] - mp2[i.first]);\\n            if(opr&1) return -1;\\n            opr /= 2;\\n            if(opr != 0)pa.push_back({i.first , opr});\\n        }\\n        sort(begin(pa) , end(pa));\\n        long long sum = 0;\\n        int i=0;\\n        int j=pa.size()-1;\\n        int pr = 0;\\n        int po = 0;\\n        while(i <= j) {\\n            int opr1 = pa[i][1];\\n            int opr2 = pa[j][1];\\n            // edge case\\n            if(i == j) {\\n                opr1 /= 2;\\n                    sum += (pa[i][0] * opr1);\\n                break;\\n            }\\n            // when we swap 2 element with each other \\n            if(min(pa[i][0] , pa[j][0]) < 2*val){if(opr1 >= opr2) {\\n                pa[i][1] -= opr2;\\n                sum += (pa[i][0] * opr2);\\n                j--;\\n            }\\n            else {\\n                pa[j][1] -= opr1;\\n                sum += (pa[i][0] * opr1);\\n                i++;\\n            }}\\n            // when we swap the elements using minimun value (val) of both baskets\\n            else {\\n                sum += ((long long)(opr1+opr2) * val);\\n                i++;\\n                j--;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143997,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        count=Counter(basket1+basket2)\\n        for c in count:\\n            if count[c]%2:\\n                return -1\\n\\n            count[c]>>=1\\n\\n        basket11=list((Counter(basket1)-count).elements())\\n        basket21=list((Counter(basket2)-count).elements())\\n        cost=min(min(basket1),min(basket2))\\n        basket=sorted(basket11+basket21)\\n\\n        return sum(min(cost+cost,basket[i]) for i in range(len(basket11)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        count=Counter(basket1+basket2)\\n        for c in count:\\n            if count[c]%2:\\n                return -1\\n\\n            count[c]>>=1\\n\\n        basket11=list((Counter(basket1)-count).elements())\\n        basket21=list((Counter(basket2)-count).elements())\\n        cost=min(min(basket1),min(basket2))\\n        basket=sorted(basket11+basket21)\\n\\n        return sum(min(cost+cost,basket[i]) for i in range(len(basket11)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143992,
                "title": "java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Create a HashMap map to store the frequency of each element in both baskets\\n* Traverse both baskets and update the frequency of each element in map\\n* Create a list list to store elements that have a non-zero frequency in map\\n* Find the minimum element in map and store it in min\\n    * For each element key in map:\\n    * If key is not in map, skip\\n    * If frequency of key is not divisible by 2, return -1\\n    * If frequency of key is divisible by 2, add key to the list list for x/2 times\\n* Sort the list in ascending order\\n* If the size of the list is not divisible by 2, return -1\\n    * Traverse the list from the middle to the start\\n    * If list[i] is greater than 2 * min, add 2 * min to sum\\n    * Else, add list[i] to sum\\n* Return sum\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        long sum = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int ele : basket1)\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        for(int ele : basket2)\\n            map.put(ele,map.getOrDefault(ele,0)-1);\\n        \\n        List<Integer> list = new ArrayList<>();\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int key : map.keySet()){\\n            min = Math.min(min,key);\\n            int x =Math.abs(map.get(key));\\n            if(x == 0)   continue;\\n            if(x%2!=0) return -1;\\n            for(int i=0;i<x/2;i++)\\n                list.add(key);\\n        }\\n            \\n            Collections.sort(list);\\n            if(list.size()%2 != 0)  return -1;\\n            for(int i=list.size()/2 -1;i>=0;i--){\\n                if(list.get(i) > 2*min)\\n                    sum+=2*min;\\n                else sum+=list.get(i);\\n            }\\n                return sum;      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        long sum = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int ele : basket1)\\n            map.put(ele,map.getOrDefault(ele,0)+1);\\n        for(int ele : basket2)\\n            map.put(ele,map.getOrDefault(ele,0)-1);\\n        \\n        List<Integer> list = new ArrayList<>();\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int key : map.keySet()){\\n            min = Math.min(min,key);\\n            int x =Math.abs(map.get(key));\\n            if(x == 0)   continue;\\n            if(x%2!=0) return -1;\\n            for(int i=0;i<x/2;i++)\\n                list.add(key);\\n        }\\n            \\n            Collections.sort(list);\\n            if(list.size()%2 != 0)  return -1;\\n            for(int i=list.size()/2 -1;i>=0;i--){\\n                if(list.get(i) > 2*min)\\n                    sum+=2*min;\\n                else sum+=list.get(i);\\n            }\\n                return sum;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143937,
                "title": "python3-use-3-way-swap-to-achieve-smaller-cost",
                "content": "# Approach\\n1. Count the excess elements in `basket1` and `basket2` that needs to be swapped. Record them in `move1` and `move2`.\\n2. Sort `move1` and `move2`, respectively.\\n3. The optimal strategy to achieve minimal cost is to take the minimum cost comparing (1) the direct \"head/tail\" swap using `move1` and `move2` with (2) a three-way swap using the overall smallest element in `basket1` and `basket2` twice.\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        cnt1, cnt2 = Counter(basket1), Counter(basket2)\\n        minCost = min(min(basket1), min(basket2)) * 2\\n        move1, move2 = [], []\\n        for fruit in cnt1:\\n            if (cnt1[fruit] + cnt2[fruit]) % 2 != 0:\\n                return -1\\n            avgFruit = (cnt1[fruit] + cnt2[fruit]) // 2\\n            if cnt1[fruit] > avgFruit:\\n                move1 += [fruit] * (cnt1[fruit] - avgFruit)\\n        for fruit in cnt2:\\n            if (cnt1[fruit] + cnt2[fruit]) % 2 != 0:\\n                return -1\\n            avgFruit = (cnt1[fruit] + cnt2[fruit]) // 2\\n            if cnt2[fruit] > avgFruit:\\n                move2 += [fruit] * (cnt2[fruit] - avgFruit)\\n        move1.sort()\\n        move2.sort()\\n        ans, m = 0, len(move1)\\n        for i in range(m):\\n            ans += min(min(move1[i], move2[m - 1 - i]), minCost)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        cnt1, cnt2 = Counter(basket1), Counter(basket2)\\n        minCost = min(min(basket1), min(basket2)) * 2\\n        move1, move2 = [], []\\n        for fruit in cnt1:\\n            if (cnt1[fruit] + cnt2[fruit]) % 2 != 0:\\n                return -1\\n            avgFruit = (cnt1[fruit] + cnt2[fruit]) // 2\\n            if cnt1[fruit] > avgFruit:\\n                move1 += [fruit] * (cnt1[fruit] - avgFruit)\\n        for fruit in cnt2:\\n            if (cnt1[fruit] + cnt2[fruit]) % 2 != 0:\\n                return -1\\n            avgFruit = (cnt1[fruit] + cnt2[fruit]) // 2\\n            if cnt2[fruit] > avgFruit:\\n                move2 += [fruit] * (cnt2[fruit] - avgFruit)\\n        move1.sort()\\n        move2.sort()\\n        ans, m = 0, len(move1)\\n        for i in range(m):\\n            ans += min(min(move1[i], move2[m - 1 - i]), minCost)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143793,
                "title": "python-simple-solution-image-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI start this problem from a simple test case.\\n\\n![simple_test_case.jpg](https://assets.leetcode.com/users/images/61c43d56-3eba-48b2-972f-2101b2d273e9_1675587571.1571252.jpeg)\\n\\n\\nGiven two baskets [1, 8, 8] and [1, 9, 9], we have two choices to make them equal.\\n1. Use the minimum number, that is 1 in this example, to swap to a 9 in second basket, and then swap back to a 8 in the first basket, with $$cost = 2 * \\\\min(baskets) = 2 * 1 = 2$$. \\n2. Swap 8 and 9 simultaneously with $$cost = \\\\min(8, 9) = 8$$.\\n\\nIt\\'s obvious that we should swap the numbers using 1 with smaller cost 2, but when should we choose the second choice? Now maybe you got the idea. When the cost to swap two numbers (minimum of two numbers) is smaller than twice the minimum number in baskets, then we should swap them direcly. Othewise we use the minimum number to swap between two baskets.\\n\\nGiven two baskets [5, 8, 8] and [5, 9, 9], the minimum number is 5, so the costs of two choices will be:\\n1. $$2 * min(baskets) = 2 * 5 = 10$$\\n2. $$\\\\min(8, 9) = 8$$\\n\\nAs a result, we should swap 8 and 9 directly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first count every number in two baskets. All the occurrences in two baskets should be even, otherwise it is impossible to make two baskets equal.\\n\\nThen we make an array to store the numbers which should be swapped. The array is sorted increasingly, and only the first half of array will be took into account (they are smaller numbers than the second half). We don\\'t care where are the numbers from in the first half because we can always find a bigger number from a different basket in the second half, e.g. if there are 3 numbers from basket1 and 2 numbers from basket2 in the first half, then there are 2 numbers from basket1 and 3 numbers from basket2 in the second half.\\n\\nFor example, [1,1,2,2,2,3] and [2,3,3,3,3,3], the array will be [1,2,2,3]. We will swap [1,2] and [2,3], so only 1 and 2 are took into cost consideration.\\n\\nFinally, we compare the cost between twice the minimum number and pair costs. Accumulate them as our final answer.\\n\\n# Complexity\\n- Time complexity $$O(sort)$$:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(sort)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Python\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        counter1 = Counter(basket1)\\n        counter2 = Counter(basket2)\\n        total_counter = counter1 + counter2\\n        \\n        arr = []\\n        for key, count in sorted(total_counter.items()):\\n            if count % 2:\\n                return -1\\n            arr.extend([key] * (count // 2 - min(counter1[key], counter2[key])))\\n        \\n        res = 0\\n        min_cost = 2 * min(total_counter.keys())\\n        for c in arr[:len(arr) // 2]:\\n            res += min(c, min_cost)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        counter1 = Counter(basket1)\\n        counter2 = Counter(basket2)\\n        total_counter = counter1 + counter2\\n        \\n        arr = []\\n        for key, count in sorted(total_counter.items()):\\n            if count % 2:\\n                return -1\\n            arr.extend([key] * (count // 2 - min(counter1[key], counter2[key])))\\n        \\n        res = 0\\n        min_cost = 2 * min(total_counter.keys())\\n        for c in arr[:len(arr) // 2]:\\n            res += min(c, min_cost)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143676,
                "title": "python-hashtable-heap",
                "content": "\\n# Approach\\n1. We compare the count of each element in both baskets and store the differences in a heap. \\n1. If the difference is odd, we return -1 because it means we can\\'t match the fruits. \\n2. If the difference is even, we add half of the difference to the heap, representing the number of unmatched fruit pairs. \\n3. Finally, we calculate the minimum cost by popping the smallest element from the heap and adding the minimum of its value and double the absolute minimum value of all fruits. (Take it or use absolute minimum twice to balance mismatch) \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n\\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n``` {python}\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        C1, C2 = Counter(basket1), Counter(basket2)\\n        abs_min = min(min(basket1), min(basket2))\\n        h = []\\n        for i in C1.keys():\\n            if C1[i] > C2[i]:\\n                diff = C1[i] - C2[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        for i in C2.keys():\\n            if C2[i] > C1[i]:\\n                diff = C2[i] - C1[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        n, ans = len(h), 0\\n        for _ in range(n//2):\\n            ans += min(2*abs_min, heappop(h))\\n        return ans\\n                    \\n        \\n```\\nSubmission:\\n![submit.jpg](https://assets.leetcode.com/users/images/f0c9c91f-8abe-44d5-9970-a0cc48a238a2_1675597492.0397966.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "``` {python}\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        C1, C2 = Counter(basket1), Counter(basket2)\\n        abs_min = min(min(basket1), min(basket2))\\n        h = []\\n        for i in C1.keys():\\n            if C1[i] > C2[i]:\\n                diff = C1[i] - C2[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        for i in C2.keys():\\n            if C2[i] > C1[i]:\\n                diff = C2[i] - C1[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        n, ans = len(h), 0\\n        for _ in range(n//2):\\n            ans += min(2*abs_min, heappop(h))\\n        return ans\\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143649,
                "title": "c-min-heap-map-o-n-log-n",
                "content": "**Intuition:** \\nIf there is an odd amount of any fruit, we return -1 because odd amounts can not be evenly partitioned. Else we know an answer is possible. If we know how many extra fruits one basket has, we also know how many extra fruits the other basket has, think why. Now we need to minimize the cost of swapping the fruits until the baskets are similar. Here is a tricky case: \\n```\\n[100, 1, 200, 200, 200]\\n[200, 1, 100, 100, 100]\\n```\\nAn approach I\\'m sure many people tried at first was to swap each minimum fruit that does not belong in its array -- like swapping [200] with [100] two times. But this is not optimal. Instead, we can swap [1] with [200] and then swap it back to its original array. So the cost is only 2. This reveals a key observation in the optimal strategy: The cost for each swap is the the minimum of: the minimum fruit that does not belong in its array, and the absolute minimum fruit times two. This is because we have to swap back the absolute minimum if it did belong in its array.\\n\\n**Explanation:** Return -1 if the frequency of any fruit is odd. Then count how many fruits are out-of-place by counting each fruit that exists more than the total/2. Push all out-of-place fruits into a min-heap. For i = 0 to k where k is out-of-place fruits, increment ans by min(pq.top(), min_fruit * 2).\\n\\n**Complexity** \\n``` \\nTime: O(N log n)\\nSpace: O(n)\\n```\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int, int> freq;\\n        for(auto i : basket1) freq[i]++;\\n        for(auto i : basket2) freq[i]++;\\n        for(auto& i : freq){\\n            if(i.second%2) return -1;\\n            i.second /= 2;\\n        }\\n        map<int, int> b1;\\n        map<int, int> b2;\\n        for(auto i : basket1) b1[i]++;\\n        for(auto i : basket2) b2[i]++;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        int k = 0;\\n        for(auto i : b1){\\n            if(i.second > freq[i.first]) {\\n                int dif = i.second-freq[i.first];\\n                k += dif;\\n                for(int j = 0; j < dif; j++) pq.push(i.first);\\n                i.second--;\\n            }\\n        }\\n        for(auto i : b2){\\n            if(i.second > freq[i.first]){\\n                int dif = i.second-freq[i.first];\\n                for(int j = 0; j < dif; j++) pq.push(i.first);\\n                i.second--;\\n            }\\n        }\\n        long long ans = 0;\\n        int mn = *min_element(basket1.begin(), basket1.end());\\n        mn = min(mn, *min_element(basket2.begin(), basket2.end()));\\n        for(int i = 0; i < k; i++){\\n            ans += min(pq.top(), mn*2);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n[100, 1, 200, 200, 200]\\n[200, 1, 100, 100, 100]\\n```\n``` \\nTime: O(N log n)\\nSpace: O(n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021022,
                "title": "python3-solution-for-beginners",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        basket1.sort()\\n        basket2.sort()\\n        c1 = Counter(basket1)\\n        c2 = Counter(basket2)\\n        \\n        for c in set(basket1):\\n            x = c1[c]\\n            if c in c2:\\n                y = c2[c]\\n            else:\\n                y=0\\n            if (x + y) % 2 != 0:\\n\\n                return -1\\n        \\n        c = c1 + c2\\n        # print(c)\\n        m = min(c)\\n        # print(m)\\n        c3 = c1\\n        c1 = c1 - c2\\n        c2 = c2 - c3\\n        print(c1,c2)\\n        a = sorted(list(c1.elements()) + list(c2.elements()))\\n        res = 0\\n        # print(a)\\n        for i in range(len(a)//2):\\n            res+=min(2*m,a[i])\\n        return res //2\\n\\n\\n        \\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        basket1.sort()\\n        basket2.sort()\\n        c1 = Counter(basket1)\\n        c2 = Counter(basket2)\\n        \\n        for c in set(basket1):\\n            x = c1[c]\\n            if c in c2:\\n                y = c2[c]\\n            else:\\n                y=0\\n            if (x + y) % 2 != 0:\\n\\n                return -1\\n        \\n        c = c1 + c2\\n        # print(c)\\n        m = min(c)\\n        # print(m)\\n        c3 = c1\\n        c1 = c1 - c2\\n        c2 = c2 - c3\\n        print(c1,c2)\\n        a = sorted(list(c1.elements()) + list(c2.elements()))\\n        res = 0\\n        # print(a)\\n        for i in range(len(a)//2):\\n            res+=min(2*m,a[i])\\n        return res //2\\n\\n\\n        \\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003073,
                "title": "simple-100-fastest-solution",
                "content": "# Intuition\\nTwo baskets can be made equal if each of them contains several pairs of fruits that are missing in the other. \\nThe number of missing pairs in the two baskets is the same.\\nSince the cost of swap depends only on the cheap fruit in the pair, you can swap cheap fruits with expensive ones.\\nIn addition, you can swap the cheapest fruit in the basket with the one that is missing, and then swap this cheap fruit back. In this case, the cost of swap will be two times the cost of the cheapest fruit.\\nIn each case we can choose which way to make the baskets equal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(len(basket1)+len(basket2))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(len(basket1)+len(basket2))$$\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        db1 = Counter(basket1)\\n        db12 = Counter(basket2)+db1\\n        if any(v for v in db12.values() if v % 2) : return -1\\n        min_frt = min(db12.keys())\\n        exch = []\\n        for key,v12 in db12.items() :\\n            dv = (v12 >>1) - db1[key]\\n            if dv ==0: continue\\n            exch.extend(repeat(key,abs(dv)))\\n        exch.sort()\\n        return sum(min(fr, 2 * min_frt) for fr in exch[:len(exch) >>1])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        db1 = Counter(basket1)\\n        db12 = Counter(basket2)+db1\\n        if any(v for v in db12.values() if v % 2) : return -1\\n        min_frt = min(db12.keys())\\n        exch = []\\n        for key,v12 in db12.items() :\\n            dv = (v12 >>1) - db1[key]\\n            if dv ==0: continue\\n            exch.extend(repeat(key,abs(dv)))\\n        exch.sort()\\n        return sum(min(fr, 2 * min_frt) for fr in exch[:len(exch) >>1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975759,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        HashMap<Integer,Integer> h1=new HashMap<Integer,Integer>();\\n        HashMap<Integer,Integer> h2=new HashMap<Integer,Integer>();\\n        HashMap<Integer,Long> h=new HashMap<Integer,Long>();\\n        ArrayList<Integer> l1=new ArrayList<Integer>();\\n        ArrayList<Integer> l2=new ArrayList<Integer>();\\n        for(int i=0;i<basket1.length;i++)\\n        {\\n            if(!h1.containsKey(basket1[i]))\\n            {\\n                h1.put(basket1[i],1);\\n            }\\n            else\\n            {\\n                h1.put(basket1[i],h1.get(basket1[i])+1);\\n            }\\n            if(!h2.containsKey(basket2[i]))\\n            {\\n                h2.put(basket2[i],1);\\n            }\\n            else\\n            {\\n                h2.put(basket2[i],h2.get(basket2[i])+1);\\n            }\\n            if(!h.containsKey(basket1[i]))\\n            {\\n                h.put(basket1[i],1L);\\n            }\\n            else\\n            {\\n                h.put(basket1[i],h.get(basket1[i])+1);\\n            }\\n             if(!h.containsKey(basket2[i]))\\n            {\\n                h.put(basket2[i],1L);\\n            }\\n            else\\n            {\\n                h.put(basket2[i],h.get(basket2[i])+1);\\n            }\\n        }\\n        for(Map.Entry<Integer,Long> entry:h.entrySet())\\n        {\\n            long val=entry.getValue();\\n            int key=entry.getKey();\\n            if(val%2!=0)\\n            {\\n                return -1;\\n            }\\n            long p=val/2;\\n            if(!h1.containsKey(key))\\n            {\\n                for(long i=0;i<p;i++)\\n                {\\n                    l1.add(key);\\n                }\\n            }\\n            else\\n            {\\n                int x=h1.get(key);\\n                if(x<p)\\n                {\\n                    long y=p-x;\\n                    for(long i=0;i<y;i++)\\n                    {\\n                        l1.add(key);\\n                    }\\n                }\\n            }\\n            if(!h2.containsKey(key))\\n            {\\n                for(long i=0;i<p;i++)\\n                {\\n                    l2.add(key);\\n                }\\n            }\\n            else\\n            {\\n                int x=h2.get(key);\\n                if(x<p)\\n                {\\n                    long y=p-x;\\n                    for(long i=0;i<y;i++)\\n                    {\\n                        l2.add(key);\\n                    }\\n                }\\n            }\\n        }\\n        if(l1.size()==0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            long result=0;\\n            Collections.sort(l1);\\n            Collections.sort(l2);\\n            Arrays.sort(basket1);\\n            Arrays.sort(basket2);\\n            int min=Math.min(basket1[0],basket2[0]);\\n            int i=0,j=l2.size()-1;\\n            while(i<l1.size() && j>=0)\\n            {\\n                int p=Math.min(l1.get(i),l2.get(j));\\n                if(min*2<p)\\n                {\\n                    result+=min*2;\\n                }\\n                else\\n                {\\n                    result+=p;\\n                }\\n                i++;\\n                j--;\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        HashMap<Integer,Integer> h1=new HashMap<Integer,Integer>();\\n        HashMap<Integer,Integer> h2=new HashMap<Integer,Integer>();\\n        HashMap<Integer,Long> h=new HashMap<Integer,Long>();\\n        ArrayList<Integer> l1=new ArrayList<Integer>();\\n        ArrayList<Integer> l2=new ArrayList<Integer>();\\n        for(int i=0;i<basket1.length;i++)\\n        {\\n            if(!h1.containsKey(basket1[i]))\\n            {\\n                h1.put(basket1[i],1);\\n            }\\n            else\\n            {\\n                h1.put(basket1[i],h1.get(basket1[i])+1);\\n            }\\n            if(!h2.containsKey(basket2[i]))\\n            {\\n                h2.put(basket2[i],1);\\n            }\\n            else\\n            {\\n                h2.put(basket2[i],h2.get(basket2[i])+1);\\n            }\\n            if(!h.containsKey(basket1[i]))\\n            {\\n                h.put(basket1[i],1L);\\n            }\\n            else\\n            {\\n                h.put(basket1[i],h.get(basket1[i])+1);\\n            }\\n             if(!h.containsKey(basket2[i]))\\n            {\\n                h.put(basket2[i],1L);\\n            }\\n            else\\n            {\\n                h.put(basket2[i],h.get(basket2[i])+1);\\n            }\\n        }\\n        for(Map.Entry<Integer,Long> entry:h.entrySet())\\n        {\\n            long val=entry.getValue();\\n            int key=entry.getKey();\\n            if(val%2!=0)\\n            {\\n                return -1;\\n            }\\n            long p=val/2;\\n            if(!h1.containsKey(key))\\n            {\\n                for(long i=0;i<p;i++)\\n                {\\n                    l1.add(key);\\n                }\\n            }\\n            else\\n            {\\n                int x=h1.get(key);\\n                if(x<p)\\n                {\\n                    long y=p-x;\\n                    for(long i=0;i<y;i++)\\n                    {\\n                        l1.add(key);\\n                    }\\n                }\\n            }\\n            if(!h2.containsKey(key))\\n            {\\n                for(long i=0;i<p;i++)\\n                {\\n                    l2.add(key);\\n                }\\n            }\\n            else\\n            {\\n                int x=h2.get(key);\\n                if(x<p)\\n                {\\n                    long y=p-x;\\n                    for(long i=0;i<y;i++)\\n                    {\\n                        l2.add(key);\\n                    }\\n                }\\n            }\\n        }\\n        if(l1.size()==0)\\n        {\\n            return 0;\\n        }\\n        else\\n        {\\n            long result=0;\\n            Collections.sort(l1);\\n            Collections.sort(l2);\\n            Arrays.sort(basket1);\\n            Arrays.sort(basket2);\\n            int min=Math.min(basket1[0],basket2[0]);\\n            int i=0,j=l2.size()-1;\\n            while(i<l1.size() && j>=0)\\n            {\\n                int p=Math.min(l1.get(i),l2.get(j));\\n                if(min*2<p)\\n                {\\n                    result+=min*2;\\n                }\\n                else\\n                {\\n                    result+=p;\\n                }\\n                i++;\\n                j--;\\n            }\\n\\n            return result;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947850,
                "title": "greedy-algorithm-with-minprice-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} basket1\\n * @param {number[]} basket2\\n * @return {number}\\n */\\nvar minCost = function(basket1, basket2) {\\n\\n    let counts = new Map();\\n    let counts1 = new Map();\\n    let counts2 = new Map();\\n\\n    let add_count = (c, x) => {\\n        if (!c.has(x)) {\\n            c.set(x, 1);\\n        } else {\\n            c.set(x, c.get(x) + 1);\\n        }\\n    };\\n\\n    for (let i = 0; i < basket1.length; i++) {\\n        add_count(counts, basket1[i]);\\n        add_count(counts, basket2[i]);\\n        add_count(counts1, basket1[i]);\\n        add_count(counts2, basket2[i]);\\n    }\\n\\n    for (let x of counts.keys()) {\\n        if ((counts.get(x) % 2) != 0) {\\n            return -1;\\n        }\\n    }\\n\\n    let needs = [];\\n    let total_needed = 0;\\n\\n    for (let x of counts.keys()) {\\n        let n = (counts.get(x) / 2) - Math.min(counts1.get(x) || 0, counts2.get(x) || 0);\\n\\n        needs.push([x, n]);\\n        total_needed += n;\\n    }\\n\\n    needs.sort((a, b) => a[0] - b[0]);\\n\\n    let max_cost = needs[0][0] * 2;\\n\\n    total_needed /= 2;\\n\\n    let result = 0;\\n    for (let i = 0; (i < needs.length) && (total_needed > 0); i++) {\\n        let [x, n] = needs[i];\\n\\n        let amt = Math.min(total_needed, n);\\n\\n        result += amt * Math.min(max_cost, x);\\n\\n        total_needed -= amt;\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} basket1\\n * @param {number[]} basket2\\n * @return {number}\\n */\\nvar minCost = function(basket1, basket2) {\\n\\n    let counts = new Map();\\n    let counts1 = new Map();\\n    let counts2 = new Map();\\n\\n    let add_count = (c, x) => {\\n        if (!c.has(x)) {\\n            c.set(x, 1);\\n        } else {\\n            c.set(x, c.get(x) + 1);\\n        }\\n    };\\n\\n    for (let i = 0; i < basket1.length; i++) {\\n        add_count(counts, basket1[i]);\\n        add_count(counts, basket2[i]);\\n        add_count(counts1, basket1[i]);\\n        add_count(counts2, basket2[i]);\\n    }\\n\\n    for (let x of counts.keys()) {\\n        if ((counts.get(x) % 2) != 0) {\\n            return -1;\\n        }\\n    }\\n\\n    let needs = [];\\n    let total_needed = 0;\\n\\n    for (let x of counts.keys()) {\\n        let n = (counts.get(x) / 2) - Math.min(counts1.get(x) || 0, counts2.get(x) || 0);\\n\\n        needs.push([x, n]);\\n        total_needed += n;\\n    }\\n\\n    needs.sort((a, b) => a[0] - b[0]);\\n\\n    let max_cost = needs[0][0] * 2;\\n\\n    total_needed /= 2;\\n\\n    let result = 0;\\n    for (let i = 0; (i < needs.length) && (total_needed > 0); i++) {\\n        let [x, n] = needs[i];\\n\\n        let amt = Math.min(total_needed, n);\\n\\n        result += amt * Math.min(max_cost, x);\\n\\n        total_needed -= amt;\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3928604,
                "title": "python-hard",
                "content": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        N = len(basket1)\\n        \\n        \\n        d = defaultdict(int)\\n        \\n        for val in basket1:\\n            d[val] += 1\\n            \\n        for val in basket2:\\n            d[val] += 1\\n            \\n        for key in d:\\n            if d[key] % 2:\\n                return -1\\n            \\n        \\n       \\n          \\n        basket1.sort()\\n        basket2.sort()\\n        \\n\\n        \\n        \\n        c = Counter(basket1)\\n        d = Counter(basket2)\\n        \\n        ans = []\\n        \\n        for key in c:\\n            if c[key] != 0 and c[key] > d[key]:\\n                ans.append([c[key] - d[key], key])\\n                \\n        for key in d:\\n            if d[key] != 0 and d[key] > c[key]:\\n                ans.append([d[key] - c[key], key])\\n                \\n        \\n        ans.sort(key = lambda x: x[1])\\n        \\n        l, r = 0, len(ans) - 1\\n        \\n        res = 0\\n        \\n  \\n        \\n        tmp = min(min(basket1), min(basket2))\\n\\n        print(ans)\\n        \\n        while l <= r:\\n            amount, val = ans[l]\\n            amount2, val2 = ans[r]\\n            \\n            \\n            if amount <= 0:\\n                l += 1\\n                continue\\n                \\n            if amount2 <= 0:\\n                r -= 1\\n                continue\\n                \\n            \\n            ans[l][0] -= 2\\n            ans[r][0] -= 2\\n            res += min(val, tmp * 2)\\n        \\n        \\n\\n        return res\\n            \\n            \\n        \\n        \\n       \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        N = len(basket1)\\n        \\n        \\n        d = defaultdict(int)\\n        \\n        for val in basket1:\\n            d[val] += 1\\n            \\n        for val in basket2:\\n            d[val] += 1\\n            \\n        for key in d:\\n            if d[key] % 2:\\n                return -1\\n            \\n        \\n       \\n          \\n        basket1.sort()\\n        basket2.sort()\\n        \\n\\n        \\n        \\n        c = Counter(basket1)\\n        d = Counter(basket2)\\n        \\n        ans = []\\n        \\n        for key in c:\\n            if c[key] != 0 and c[key] > d[key]:\\n                ans.append([c[key] - d[key], key])\\n                \\n        for key in d:\\n            if d[key] != 0 and d[key] > c[key]:\\n                ans.append([d[key] - c[key], key])\\n                \\n        \\n        ans.sort(key = lambda x: x[1])\\n        \\n        l, r = 0, len(ans) - 1\\n        \\n        res = 0\\n        \\n  \\n        \\n        tmp = min(min(basket1), min(basket2))\\n\\n        print(ans)\\n        \\n        while l <= r:\\n            amount, val = ans[l]\\n            amount2, val2 = ans[r]\\n            \\n            \\n            if amount <= 0:\\n                l += 1\\n                continue\\n                \\n            if amount2 <= 0:\\n                r -= 1\\n                continue\\n                \\n            \\n            ans[l][0] -= 2\\n            ans[r][0] -= 2\\n            res += min(val, tmp * 2)\\n        \\n        \\n\\n        return res\\n            \\n            \\n        \\n        \\n       \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903936,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n    vector<int> swapped;\\n    unordered_map<int, int> count;\\n\\n    for (const int b : basket1)\\n      ++count[b];\\n\\n    for (const int b : basket2)\\n      --count[b];\\n\\n    for (const auto& [num, freq] : count) {\\n      if (freq % 2 != 0)\\n        return -1;\\n      for (int i = 0; i < abs(freq) / 2; ++i)\\n        swapped.push_back(num);\\n    }\\n\\n    const int minNum = min(*min_element(basket1.begin(), basket1.end()),\\n                           *min_element(basket2.begin(), basket2.end()));\\n    const auto midIt = swapped.begin() + swapped.size() / 2;\\n    nth_element(swapped.begin(), midIt, swapped.end());\\n    return accumulate(swapped.begin(), midIt, 0LL,\\n                      [minNum](long long subtotal, int num) {\\n      return subtotal + min(2 * minNum, num);\\n    });\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n    vector<int> swapped;\\n    unordered_map<int, int> count;\\n\\n    for (const int b : basket1)\\n      ++count[b];\\n\\n    for (const int b : basket2)\\n      --count[b];\\n\\n    for (const auto& [num, freq] : count) {\\n      if (freq % 2 != 0)\\n        return -1;\\n      for (int i = 0; i < abs(freq) / 2; ++i)\\n        swapped.push_back(num);\\n    }\\n\\n    const int minNum = min(*min_element(basket1.begin(), basket1.end()),\\n                           *min_element(basket2.begin(), basket2.end()));\\n    const auto midIt = swapped.begin() + swapped.size() / 2;\\n    nth_element(swapped.begin(), midIt, swapped.end());\\n    return accumulate(swapped.begin(), midIt, 0LL,\\n                      [minNum](long long subtotal, int num) {\\n      return subtotal + min(2 * minNum, num);\\n    });\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876629,
                "title": "consider-indirect-swaps-also",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$+$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n=basket1.size();\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[basket1[i]]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            mp[basket2[i]]--;\\n        }\\n        vector<int> v;\\n        for(auto it : mp){\\n            int key=it.first;\\n            int value=it.second;\\n            if(value%2!=0) return -1;\\n            else{\\n                for(int k=1;k<=abs(value)/2;k++){\\n                    v.push_back(key);\\n                }\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        long long ans=0;\\n        int a=*min_element(basket1.begin(),basket1.end());\\n        int b=*min_element(basket2.begin(),basket2.end());\\n        int mini=min(a,b);\\n        for(int i=0;i<v.size()/2;i++){\\n            ans+=min(v[i],2*mini);\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n=basket1.size();\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[basket1[i]]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            mp[basket2[i]]--;\\n        }\\n        vector<int> v;\\n        for(auto it : mp){\\n            int key=it.first;\\n            int value=it.second;\\n            if(value%2!=0) return -1;\\n            else{\\n                for(int k=1;k<=abs(value)/2;k++){\\n                    v.push_back(key);\\n                }\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        long long ans=0;\\n        int a=*min_element(basket1.begin(),basket1.end());\\n        int b=*min_element(basket2.begin(),basket2.end());\\n        int mini=min(a,b);\\n        for(int i=0;i<v.size()/2;i++){\\n            ans+=min(v[i],2*mini);\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841064,
                "title": "python-faster-than-100-stack-hashmap",
                "content": "# Intuition\\nWe either swap with the min element indirectly or swap with greedily.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        b1f, b2f = collections.Counter(basket1), collections.Counter(basket2)\\n        tc = collections.Counter(basket1 + basket2)\\n        if any(tc[f] % 2 == 1 for f in tc): return -1\\n\\n        b1_min, b2_min = min(b1f), min(b2f)\\n        min_element = min(b1_min, b2_min)\\n\\n        b1_swap, b2_swap = [], []\\n        total = 0\\n        for key in tc:\\n            b1_count, b2_count = b1f[key], b2f[key]\\n            if b1_count == b2_count: continue\\n            \\n            swap_count = abs(b1_count - b2_count) // 2\\n\\n            if b1_count > b2_count: b1_swap.append((key, swap_count))\\n            else: b2_swap.append((key, swap_count))\\n\\n        b1_swap.sort()\\n        b2_swap.sort(reverse=True)\\n\\n        total = 0\\n        while b1_swap and b2_swap:\\n            b1_cost, b1_amount = b1_swap[-1]\\n            b2_cost, b2_amount = b2_swap[-1]\\n\\n            swap_both = min(b1_cost, b2_cost) * min(b1_amount, b2_amount)\\n            swap_via_min = 2 * min_element * min(b1_amount, b2_amount)\\n\\n            if swap_both < swap_via_min:\\n                total += swap_both\\n            else:\\n                total += swap_via_min\\n            if b1_amount == b2_amount:\\n                b1_swap.pop(); b2_swap.pop()\\n            elif b1_amount > b2_amount:\\n                b2_swap.pop()\\n                b1_swap[-1] = (b1_cost, b1_amount - b2_amount)\\n            else:\\n                b1_swap.pop()\\n                b2_swap[-1] = (b2_cost, b2_amount - b1_amount)\\n        \\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        b1f, b2f = collections.Counter(basket1), collections.Counter(basket2)\\n        tc = collections.Counter(basket1 + basket2)\\n        if any(tc[f] % 2 == 1 for f in tc): return -1\\n\\n        b1_min, b2_min = min(b1f), min(b2f)\\n        min_element = min(b1_min, b2_min)\\n\\n        b1_swap, b2_swap = [], []\\n        total = 0\\n        for key in tc:\\n            b1_count, b2_count = b1f[key], b2f[key]\\n            if b1_count == b2_count: continue\\n            \\n            swap_count = abs(b1_count - b2_count) // 2\\n\\n            if b1_count > b2_count: b1_swap.append((key, swap_count))\\n            else: b2_swap.append((key, swap_count))\\n\\n        b1_swap.sort()\\n        b2_swap.sort(reverse=True)\\n\\n        total = 0\\n        while b1_swap and b2_swap:\\n            b1_cost, b1_amount = b1_swap[-1]\\n            b2_cost, b2_amount = b2_swap[-1]\\n\\n            swap_both = min(b1_cost, b2_cost) * min(b1_amount, b2_amount)\\n            swap_via_min = 2 * min_element * min(b1_amount, b2_amount)\\n\\n            if swap_both < swap_via_min:\\n                total += swap_both\\n            else:\\n                total += swap_via_min\\n            if b1_amount == b2_amount:\\n                b1_swap.pop(); b2_swap.pop()\\n            elif b1_amount > b2_amount:\\n                b2_swap.pop()\\n                b1_swap[-1] = (b1_cost, b1_amount - b2_amount)\\n            else:\\n                b1_swap.pop()\\n                b2_swap[-1] = (b2_cost, b2_amount - b1_amount)\\n        \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745974,
                "title": "easy-to-understand-short-solution-c",
                "content": "# Intuition\\n\\nwe need to swap the extra smallest elements of one busket with extra largest elements of another busket so that cost become smallest. On exception is that we can also use the smallest element of both the busket to swap the largest elements among the buskets with cost of 2 * smallest element.\\n\\n\\n# Complexity\\n- Time complexity: `nlogn`\\n\\n- Space complexity: `n`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        \\n        map<int, int> freq;\\n\\n        for(auto f : basket1) freq[f]++;\\n\\n        for(auto f : basket2) freq[f]--;\\n\\n        int sum = 0;\\n\\n        for(auto it = freq.begin(); it!=freq.end(); it++)\\n        {\\n            sum+=it->second;\\n\\n            if(it->second%2) \\n                return -1;\\n\\n            it->second/=2;\\n        }\\n\\n        if(sum) return -1;\\n\\n\\n        long long ans = 0;\\n        auto rt = freq.rbegin();\\n        auto smallest = freq.begin()->first * 2;\\n\\n        \\n        for(auto it = freq.begin(); it!=freq.end(); it++)\\n        {\\n            while(rt!=freq.rend() and it->second<0)\\n            {\\n                if(rt->second>0)\\n                {\\n                    int m = min(abs(it->second), abs(rt->second));\\n\\n                    it->second+=m;\\n                    rt->second-=m;\\n\\n                    ans+= 1LL*min(smallest, min(it->first, rt->first))*m;\\n                }\\n\\n                if(rt->second<=0) rt++;\\n            }\\n           \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        \\n        map<int, int> freq;\\n\\n        for(auto f : basket1) freq[f]++;\\n\\n        for(auto f : basket2) freq[f]--;\\n\\n        int sum = 0;\\n\\n        for(auto it = freq.begin(); it!=freq.end(); it++)\\n        {\\n            sum+=it->second;\\n\\n            if(it->second%2) \\n                return -1;\\n\\n            it->second/=2;\\n        }\\n\\n        if(sum) return -1;\\n\\n\\n        long long ans = 0;\\n        auto rt = freq.rbegin();\\n        auto smallest = freq.begin()->first * 2;\\n\\n        \\n        for(auto it = freq.begin(); it!=freq.end(); it++)\\n        {\\n            while(rt!=freq.rend() and it->second<0)\\n            {\\n                if(rt->second>0)\\n                {\\n                    int m = min(abs(it->second), abs(rt->second));\\n\\n                    it->second+=m;\\n                    rt->second-=m;\\n\\n                    ans+= 1LL*min(smallest, min(it->first, rt->first))*m;\\n                }\\n\\n                if(rt->second<=0) rt++;\\n            }\\n           \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674934,
                "title": "clean-without-map-99-memory-90-time",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        sort(b1.begin(),b1.end());\\n        sort(b2.begin(),b2.end());\\n        b1.push_back(INT_MAX);\\n        b2.push_back(INT_MAX);\\n        vector<int>res;\\n        int x1=0,x2=0;\\n        int l=b1.size();\\n        while(x1<l and x2<l){\\n            if(b1[x1]==b2[x2]){\\n                x1++;x2++;\\n                continue;\\n            }\\n            if(b1[x1]<b2[x2]){\\n                res.push_back(b1[x1]);\\n                if(x1+1>=l or b1[x1]!=b1[x1+1])\\n                    return -1;\\n                x1+=2;\\n            }else{\\n                res.push_back(b2[x2]);\\n                if(x2+1>=l or b2[x2]!=b2[x2+1])\\n                    return -1;\\n                x2+=2;\\n            }\\n        }\\n        ll r=0;\\n        int lres=res.size();\\n        int mm=min(b1[0],b2[0]);\\n        for(int x=0;x<lres/2;x++){\\n            r+=min(2*mm,res[x]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        sort(b1.begin(),b1.end());\\n        sort(b2.begin(),b2.end());\\n        b1.push_back(INT_MAX);\\n        b2.push_back(INT_MAX);\\n        vector<int>res;\\n        int x1=0,x2=0;\\n        int l=b1.size();\\n        while(x1<l and x2<l){\\n            if(b1[x1]==b2[x2]){\\n                x1++;x2++;\\n                continue;\\n            }\\n            if(b1[x1]<b2[x2]){\\n                res.push_back(b1[x1]);\\n                if(x1+1>=l or b1[x1]!=b1[x1+1])\\n                    return -1;\\n                x1+=2;\\n            }else{\\n                res.push_back(b2[x2]);\\n                if(x2+1>=l or b2[x2]!=b2[x2+1])\\n                    return -1;\\n                x2+=2;\\n            }\\n        }\\n        ll r=0;\\n        int lres=res.size();\\n        int mm=min(b1[0],b2[0]);\\n        for(int x=0;x<lres/2;x++){\\n            r+=min(2*mm,res[x]);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617971,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        long long ret = 0 ;\\n        map<int, int>Map ;\\n        for(int i = 0; i < basket1.size(); i++){\\n            Map[basket1[i]]++ ;\\n            Map[basket2[i]]-- ;\\n        }\\n        int m = Map.begin()->first ;\\n        vector<int>arr ;\\n        for(auto [val, cn] : Map){\\n            if(cn %2 != 0)\\n                return -1 ;\\n            for(int i = 0; i < abs(cn)/2; i++)\\n                arr.push_back(val) ;\\n        }\\n        \\n        for(int i = 0; i < arr.size()/2; i++){\\n            ret += fmin(arr[i], 2*m) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        long long ret = 0 ;\\n        map<int, int>Map ;\\n        for(int i = 0; i < basket1.size(); i++){\\n            Map[basket1[i]]++ ;\\n            Map[basket2[i]]-- ;\\n        }\\n        int m = Map.begin()->first ;\\n        vector<int>arr ;\\n        for(auto [val, cn] : Map){\\n            if(cn %2 != 0)\\n                return -1 ;\\n            for(int i = 0; i < abs(cn)/2; i++)\\n                arr.push_back(val) ;\\n        }\\n        \\n        for(int i = 0; i < arr.size()/2; i++){\\n            ret += fmin(arr[i], 2*m) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582865,
                "title": "py3-87-in-both-10-line-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        cnt = Counter(basket1)\\n        for x in basket2: cnt[x] -= 1\\n        last = []\\n        for k, v in cnt.items():\\n            if v % 2 != 0:\\n                return -1\\n            last += [k] * abs(v // 2)\\n        minx = min(basket1 + basket2)\\n        last.sort()\\n        return sum(min(2*minx, x) for x in last[0:len(last)//2])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        cnt = Counter(basket1)\\n        for x in basket2: cnt[x] -= 1\\n        last = []\\n        for k, v in cnt.items():\\n            if v % 2 != 0:\\n                return -1\\n            last += [k] * abs(v // 2)\\n        minx = min(basket1 + basket2)\\n        last.sort()\\n        return sum(min(2*minx, x) for x in last[0:len(last)//2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529978,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n = basket1.size();\\n        int mn = 1e9  +7;\\n        map<int, int> freq1;\\n        map<int, int> freq2;\\n        for (int i = 0; i < n; i++) {\\n            mn = min(mn, min(basket1[i], basket2[i]));\\n            ++freq1[basket1[i]];\\n            ++freq2[basket2[i]];\\n        }\\n        vector<int> first;\\n        vector<int> second;\\n        for (auto [value, freq] : freq1) {\\n            int val = freq2[value];\\n            if (val > freq && (val - freq) % 2 == 0) {\\n                for (int i = 0; i < (val - freq) / 2; i++) {\\n                    second.push_back(value);\\n                }\\n            } else if ((freq - val) % 2 == 0) {\\n                for (int i = 0; i < (freq - val) / 2; i++) {\\n                    first.push_back(value);\\n                }\\n            } else {\\n                return -1;\\n            }\\n        }\\n        for (auto [value, freq] : freq2) {\\n            if (freq1.count(value) == 0) {\\n                int val = freq1[value];\\n                if (val > freq && (val - freq) % 2 == 0) {\\n                    for (int i = 0; i < (val - freq) / 2; i++) {\\n                        first.push_back(value);\\n                    }\\n                } else if ((freq - val) % 2 == 0) {\\n                    for (int i = 0; i < (freq - val) / 2; i++) {\\n                        second.push_back(value);\\n                    }\\n                } else {\\n                    return -1;\\n                }\\n            }\\n            \\n        }\\n        if ((int) first.size() != (int) second.size()) return -1;\\n        int len = first.size();\\n        sort(first.begin(), first.end());\\n        sort(second.rbegin(), second.rend());\\n        long long sol = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (first[i] == mn || second[i] == mn) sol += mn;\\n            else {\\n                sol += min(2 * mn, min(first[i], second[i]));\\n            }\\n        }\\n        return sol;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n = basket1.size();\\n        int mn = 1e9  +7;\\n        map<int, int> freq1;\\n        map<int, int> freq2;\\n        for (int i = 0; i < n; i++) {\\n            mn = min(mn, min(basket1[i], basket2[i]));\\n            ++freq1[basket1[i]];\\n            ++freq2[basket2[i]];\\n        }\\n        vector<int> first;\\n        vector<int> second;\\n        for (auto [value, freq] : freq1) {\\n            int val = freq2[value];\\n            if (val > freq && (val - freq) % 2 == 0) {\\n                for (int i = 0; i < (val - freq) / 2; i++) {\\n                    second.push_back(value);\\n                }\\n            } else if ((freq - val) % 2 == 0) {\\n                for (int i = 0; i < (freq - val) / 2; i++) {\\n                    first.push_back(value);\\n                }\\n            } else {\\n                return -1;\\n            }\\n        }\\n        for (auto [value, freq] : freq2) {\\n            if (freq1.count(value) == 0) {\\n                int val = freq1[value];\\n                if (val > freq && (val - freq) % 2 == 0) {\\n                    for (int i = 0; i < (val - freq) / 2; i++) {\\n                        first.push_back(value);\\n                    }\\n                } else if ((freq - val) % 2 == 0) {\\n                    for (int i = 0; i < (freq - val) / 2; i++) {\\n                        second.push_back(value);\\n                    }\\n                } else {\\n                    return -1;\\n                }\\n            }\\n            \\n        }\\n        if ((int) first.size() != (int) second.size()) return -1;\\n        int len = first.size();\\n        sort(first.begin(), first.end());\\n        sort(second.rbegin(), second.rend());\\n        long long sol = 0;\\n        for (int i = 0; i < len; i++) {\\n            if (first[i] == mn || second[i] == mn) sol += mn;\\n            else {\\n                sol += min(2 * mn, min(first[i], second[i]));\\n            }\\n        }\\n        return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444178,
                "title": "dealing-in-stacks",
                "content": "this is sorting + 2 pointers situation but for ease can see it as sorting + 2 stacks situation.\\nJust be careful with possible swap via a third minimum element pair after finding which values to swap with each other.\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        sort(basket1.begin(), basket1.end());\\n        sort(basket2.begin(), basket2.end());\\n        stack<int> s1, s2;\\n        for(int x: basket1) s1.push(x);\\n        for(int x: basket2) s2.push(x);\\n        vector<int> b1;\\n        vector<int> b2;\\n        int x;\\n        int m = min(basket1[0], basket2[0]);\\n        while(!s1.empty() || !s2.empty()){\\n            if(!s1.empty() && !s2.empty()){\\n                if(s1.top() == s2.top()){\\n                    s1.pop();\\n                    s2.pop();\\n                }\\n                else{\\n                    if(s1.top() > s2.top()){\\n                        if(s1.size() == 1) return -1;\\n                        x = s1.top();\\n                        s1.pop();\\n                        if(x != s1.top()) return -1;\\n                        s1.pop();\\n                        b1.push_back(x);\\n                    }\\n                    else{\\n                       if(s2.size() == 1) return -1;\\n                        x = s2.top();\\n                        s2.pop();\\n                        if(x != s2.top()) return -1;\\n                        s2.pop();\\n                        b2.push_back(x); \\n                    }\\n                }\\n            }\\n            else if(s1.empty()){\\n                if(s2.size() == 1) return -1;\\n                x = s2.top();\\n                s2.pop();\\n                if(x != s2.top()) return -1;\\n                s2.pop();\\n                b2.push_back(x);\\n            }\\n            else{\\n                if(s1.size() == 1) return -1;\\n                x = s1.top();\\n                s1.pop();\\n                if(x != s1.top()) return -1;\\n                s1.pop();\\n                b1.push_back(x);\\n            }\\n        }\\n        if(b1.size() != b2.size()) return -1;\\n        long long ans = 0;\\n        for(int i = 0; i < b1.size(); i++){\\n            ans += min(2*m, min(b1[i], b2[b2.size() - 1 - i]));    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        sort(basket1.begin(), basket1.end());\\n        sort(basket2.begin(), basket2.end());\\n        stack<int> s1, s2;\\n        for(int x: basket1) s1.push(x);\\n        for(int x: basket2) s2.push(x);\\n        vector<int> b1;\\n        vector<int> b2;\\n        int x;\\n        int m = min(basket1[0], basket2[0]);\\n        while(!s1.empty() || !s2.empty()){\\n            if(!s1.empty() && !s2.empty()){\\n                if(s1.top() == s2.top()){\\n                    s1.pop();\\n                    s2.pop();\\n                }\\n                else{\\n                    if(s1.top() > s2.top()){\\n                        if(s1.size() == 1) return -1;\\n                        x = s1.top();\\n                        s1.pop();\\n                        if(x != s1.top()) return -1;\\n                        s1.pop();\\n                        b1.push_back(x);\\n                    }\\n                    else{\\n                       if(s2.size() == 1) return -1;\\n                        x = s2.top();\\n                        s2.pop();\\n                        if(x != s2.top()) return -1;\\n                        s2.pop();\\n                        b2.push_back(x); \\n                    }\\n                }\\n            }\\n            else if(s1.empty()){\\n                if(s2.size() == 1) return -1;\\n                x = s2.top();\\n                s2.pop();\\n                if(x != s2.top()) return -1;\\n                s2.pop();\\n                b2.push_back(x);\\n            }\\n            else{\\n                if(s1.size() == 1) return -1;\\n                x = s1.top();\\n                s1.pop();\\n                if(x != s1.top()) return -1;\\n                s1.pop();\\n                b1.push_back(x);\\n            }\\n        }\\n        if(b1.size() != b2.size()) return -1;\\n        long long ans = 0;\\n        for(int i = 0; i < b1.size(); i++){\\n            ans += min(2*m, min(b1[i], b2[b2.size() - 1 - i]));    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403783,
                "title": "python-easy-sol-o-nlog-n",
                "content": "\\n```\\nclass Solution:\\n    def minCost(self, b1: List[int], b2: List[int]) -> int:\\n        d=defaultdict(int) \\n        e=defaultdict(int)\\n        #counting total occurence of every element in lists\\n        for i in range(0,len(b1),1):\\n            d[b1[i]]+=1\\n            d[b2[i]]+=1\\n            e[b1[i]]+=1\\n        # if any element is occuring odd no of times\\n        for i in d.values():\\n            if(i%2):return -1\\n        #finding elements to be swaped \\n        sw=[]\\n        rd=min(d.keys())\\n        for i in d.keys():\\n            \"\"\"\\n            count should not be equal to half of total count of\\n             element\\n            \"\"\"\\n            if((d[i]//2)-e[i])!=0:\\n                #storing all req elements\\n                for _ in range(0,abs((d[i]//2)-e[i]),1):\\n                    sw.append(i)\\n        ans=0\\n        sw.sort()\\n        #there are two ways to swap elements\\n        # 1 use the minimum_element(here \\'rd\\') we need to use it twice\\n        # 2 use the current element only once\\n        for i in range(len(sw)//2):\\n            ans+=min(sw[i],2*rd)\\n    \\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, b1: List[int], b2: List[int]) -> int:\\n        d=defaultdict(int) \\n        e=defaultdict(int)\\n        #counting total occurence of every element in lists\\n        for i in range(0,len(b1),1):\\n            d[b1[i]]+=1\\n            d[b2[i]]+=1\\n            e[b1[i]]+=1\\n        # if any element is occuring odd no of times\\n        for i in d.values():\\n            if(i%2):return -1\\n        #finding elements to be swaped \\n        sw=[]\\n        rd=min(d.keys())\\n        for i in d.keys():\\n            \"\"\"\\n            count should not be equal to half of total count of\\n             element\\n            \"\"\"\\n            if((d[i]//2)-e[i])!=0:\\n                #storing all req elements\\n                for _ in range(0,abs((d[i]//2)-e[i]),1):\\n                    sw.append(i)\\n        ans=0\\n        sw.sort()\\n        #there are two ways to swap elements\\n        # 1 use the minimum_element(here \\'rd\\') we need to use it twice\\n        # 2 use the current element only once\\n        for i in range(len(sw)//2):\\n            ans+=min(sw[i],2*rd)\\n    \\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397905,
                "title": "c-tricky-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI thought of iterating through each combination of baskets and swapping fruits between them until the cost is minimized. However, this approach would be inefficient as the number of combinations could be very large.\\n\\nAnother naive approach was to just sort the baskets and then swap fruits between adj baskets, but still, I sensed some decent rooms of improvement.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA solid approach was to use a hashmap to store the frequency of each fruit in both baskets, and then iterate through the hashmap to find pairs of fruits that can be swapped to minimize the cost. The cost of swapping two fruits can be calculated as the sum of their frequencies in both baskets.\\n\\nAnd a nice really cool touch, which makes this problem really hard, which I understood only after watching an editorial video was.\\n`\"minVal\"`\\nI just wanna hint at it, go look for it in my code and try to not open this spoiler untill you gave your best trying to understand what it\\'s purpose.\\n\\n<details>\\n  <summary>Spoiler warning</summary>\\n  Once you swap the minVal number form the first basket to second and you have it in the second basket, you can swap it again to from the second basket, back to basket one. Doing this would reduced the cost greatly, and that\\'s why some of your test cases might be failing.\\n</details>\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int,int>mp,mp2;\\n        int minVal = basket1[0];\\n        for(auto i:basket1){\\n            mp[i]++;\\n            minVal = min(minVal,i);\\n        }\\n        for(auto i:basket2){\\n            mp2[i]++;\\n            minVal = min(minVal,i);\\n        }\\n\\n        vector<int>toSwap;\\n\\n        for(auto it : mp){\\n            int cost = it.first;\\n            int freq1 = it.second, freq2 = mp2[it.first];\\n            int diff = abs(freq1 -freq2);\\n            if (diff%2 == 1){\\n                return -1;\\n            }\\n            diff /=2;\\n            // this is for adding all the recommended swaps\\n            while(diff--)\\n                toSwap.push_back(cost);\\n            // we don\\'t need to check again for this cost in mp2\\n            mp[cost]=0;\\n            mp2[cost]=0;\\n        }\\n\\n        for(auto it: mp2){\\n            int cost = it.first;\\n            int  occ = it.second, occ2 = mp[it.first];\\n\\n            int diff = abs(occ-occ2);\\n            if(diff %2){\\n                return -1;\\n            }\\n\\n            diff/=2;\\n\\n            while(diff--){\\n                toSwap.push_back(cost);\\n            }\\n\\n            mp[cost]=0;\\n            mp2[cost]=0;\\n        }  \\n        sort(toSwap.begin(),toSwap.end());\\n        long long ans=0;\\n        for(int i=0; i<toSwap.size()/2; i++){\\n            ans += min(2ll*minVal,1ll*toSwap[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int,int>mp,mp2;\\n        int minVal = basket1[0];\\n        for(auto i:basket1){\\n            mp[i]++;\\n            minVal = min(minVal,i);\\n        }\\n        for(auto i:basket2){\\n            mp2[i]++;\\n            minVal = min(minVal,i);\\n        }\\n\\n        vector<int>toSwap;\\n\\n        for(auto it : mp){\\n            int cost = it.first;\\n            int freq1 = it.second, freq2 = mp2[it.first];\\n            int diff = abs(freq1 -freq2);\\n            if (diff%2 == 1){\\n                return -1;\\n            }\\n            diff /=2;\\n            // this is for adding all the recommended swaps\\n            while(diff--)\\n                toSwap.push_back(cost);\\n            // we don\\'t need to check again for this cost in mp2\\n            mp[cost]=0;\\n            mp2[cost]=0;\\n        }\\n\\n        for(auto it: mp2){\\n            int cost = it.first;\\n            int  occ = it.second, occ2 = mp[it.first];\\n\\n            int diff = abs(occ-occ2);\\n            if(diff %2){\\n                return -1;\\n            }\\n\\n            diff/=2;\\n\\n            while(diff--){\\n                toSwap.push_back(cost);\\n            }\\n\\n            mp[cost]=0;\\n            mp2[cost]=0;\\n        }  \\n        sort(toSwap.begin(),toSwap.end());\\n        long long ans=0;\\n        for(int i=0; i<toSwap.size()/2; i++){\\n            ans += min(2ll*minVal,1ll*toSwap[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231410,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> map1;\\n        unordered_map<int, int> map2;\\n\\n        int min_val = INT_MAX;\\n        for(int ele: basket1) {\\n            map1[ele]++;\\n            min_val = min(min_val, ele);\\n        }\\n        for(int ele: basket2) {\\n            map2[ele]++;\\n            min_val = min(min_val, ele);\\n        }\\n        vector<int> first_swaps;\\n        for(auto& it: map1) {\\n            int count = 0;\\n            if(map2.count(it.first)==0) {\\n                count = it.second;\\n            }else if(it.second > map2[it.first]){\\n                count = it.second - map2[it.first];\\n            }\\n\\n            if(count%2!=0) {\\n                return -1;\\n            }\\n            count/=2;\\n            while(count--!=0) {\\n                first_swaps.push_back(it.first);\\n            }\\n\\n        }\\n\\n\\n\\n\\n\\n        vector<int> second_swaps;\\n        for(auto& it: map2) {\\n            int count = 0;\\n            int key = it.first;\\n            if(map1.count(key) == 0) {\\n                count = it.second;\\n            }else if(it.second > map1[key]){\\n                count = it.second - map1[key];\\n            }\\n\\n            if(count%2!=0) {\\n                return -1;\\n            }\\n\\n            count/=2;\\n            while(count--!=0) {\\n                second_swaps.push_back(key);\\n            }\\n\\n        }\\n\\n\\n\\n        if(first_swaps.size()!=second_swaps.size()) {\\n            return -1;\\n        }\\n\\n\\n        int i = 0;\\n        int j = 0;\\n        long long res = 0;\\n\\n        first_swaps.insert(first_swaps.end(), second_swaps.begin(), second_swaps.end());\\n        std::sort(first_swaps.begin(), first_swaps.end());\\n        for(int i=0;i<first_swaps.size()/2;i++) {\\n            if(min_val*2 < first_swaps[i]) {\\n                res += (long long)min_val*2;\\n            }else {\\n                res += (long long)first_swaps[i];\\n            }\\n        }\\n\\n        return res;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> map1;\\n        unordered_map<int, int> map2;\\n\\n        int min_val = INT_MAX;\\n        for(int ele: basket1) {\\n            map1[ele]++;\\n            min_val = min(min_val, ele);\\n        }\\n        for(int ele: basket2) {\\n            map2[ele]++;\\n            min_val = min(min_val, ele);\\n        }\\n        vector<int> first_swaps;\\n        for(auto& it: map1) {\\n            int count = 0;\\n            if(map2.count(it.first)==0) {\\n                count = it.second;\\n            }else if(it.second > map2[it.first]){\\n                count = it.second - map2[it.first];\\n            }\\n\\n            if(count%2!=0) {\\n                return -1;\\n            }\\n            count/=2;\\n            while(count--!=0) {\\n                first_swaps.push_back(it.first);\\n            }\\n\\n        }\\n\\n\\n\\n\\n\\n        vector<int> second_swaps;\\n        for(auto& it: map2) {\\n            int count = 0;\\n            int key = it.first;\\n            if(map1.count(key) == 0) {\\n                count = it.second;\\n            }else if(it.second > map1[key]){\\n                count = it.second - map1[key];\\n            }\\n\\n            if(count%2!=0) {\\n                return -1;\\n            }\\n\\n            count/=2;\\n            while(count--!=0) {\\n                second_swaps.push_back(key);\\n            }\\n\\n        }\\n\\n\\n\\n        if(first_swaps.size()!=second_swaps.size()) {\\n            return -1;\\n        }\\n\\n\\n        int i = 0;\\n        int j = 0;\\n        long long res = 0;\\n\\n        first_swaps.insert(first_swaps.end(), second_swaps.begin(), second_swaps.end());\\n        std::sort(first_swaps.begin(), first_swaps.end());\\n        for(int i=0;i<first_swaps.size()/2;i++) {\\n            if(min_val*2 < first_swaps[i]) {\\n                res += (long long)min_val*2;\\n            }else {\\n                res += (long long)first_swaps[i];\\n            }\\n        }\\n\\n        return res;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230824,
                "title": "easy-java-solution",
                "content": "# Intuition\\nSince we want the exact same basket, this means that each same fruit should exist in both basket1 and basket2.\\nTherefore, we will sort the fruits and then split it equally amongst the two baskets.\\n Since the cost of the swap of fruits will always be the minimum cost between the two fruits being swapped.\\nWe can if there are three fruits s1, s2 and s3 where s1 is the least cost and the next least cost fruit s2 > 2 * s1 and the distribution of fruit is (s1, s2), (s3) then we can swap the fruits via (s1, s3) then (s2, s1) to have the least cost swap.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long minCost(int[] basket1, int[] basket2) {\\n        HashMap<Integer, Integer> allFruitsMap = aggregateAllFruits(basket1, basket2);\\n\\n        if(!haveSolution(basket1, basket2, allFruitsMap)) return -1;\\n\\n        int leastCostFruit = getLeastCostFruit(basket1, basket2);\\n\\n        HashMap<Integer, Integer> idealBasket = getIdealBasket(allFruitsMap);\\n\\n        //Find out what needs to be swapped for the first basket and second basket\\n        //getDifferences will get both what is lacking for the basket and what is excessive for it\\n        List<Integer> fruitSwapsNeeded = getDifferences(idealBasket, basket1);\\n\\n        Collections.sort(fruitSwapsNeeded);\\n\\n        int noOfSwapsNeeded = fruitSwapsNeeded.size() / 2;\\n\\n        long minCost = 0;\\n\\n        for(int i = 0; i < noOfSwapsNeeded; i++){\\n            minCost += Math.min(leastCostFruit * 2, fruitSwapsNeeded.get(i));\\n        }\\n\\n        return minCost;\\n    }\\n\\n    public List<Integer> getDifferences(HashMap<Integer, Integer> idealBasket, int[] basket){\\n\\n        ArrayList<Integer> store = new ArrayList<>();\\n        HashMap<Integer, Integer> basketMap = new HashMap<Integer, Integer>();\\n\\n        for(int fruit: basket){\\n            basketMap.put(fruit, basketMap.getOrDefault(fruit, 0) + 1);\\n        }\\n\\n        for(int key: idealBasket.keySet()){\\n            int idealBasketFruitCount = idealBasket.getOrDefault(key, 0);\\n            int basketFruitCount = basketMap.getOrDefault(key, 0);\\n            int difference = Math.abs(idealBasketFruitCount - basketFruitCount);\\n\\n            for(int i = 0; i < difference; i++){\\n                store.add(key);\\n            }\\n        }\\n\\n        return store;\\n    }\\n\\n    public HashMap<Integer, Integer> getIdealBasket(HashMap<Integer, Integer> allFruitsMap){\\n        HashMap<Integer, Integer> hMap = new HashMap<>();\\n\\n        for(int key: allFruitsMap.keySet()){\\n            hMap.put(key, allFruitsMap.get(key)/2);\\n        }\\n\\n        return hMap;\\n    }\\n\\n    public HashMap<Integer, Integer> aggregateAllFruits(int[] basket1, int[] basket2){\\n        HashMap<Integer, Integer> hMap = new HashMap<>();\\n\\n        for(int i = 0; i < basket1.length; i++){\\n            hMap.put(basket1[i], hMap.getOrDefault(basket1[i], 0) + 1);\\n        }\\n\\n        for(int i = 0; i < basket2.length; i++){\\n            hMap.put(basket2[i], hMap.getOrDefault(basket2[i], 0) + 1);\\n        }\\n\\n        return hMap;\\n    }\\n\\n    public int getLeastCostFruit(int[] basket1, int[] basket2){\\n        int leastCost = Integer.MAX_VALUE;\\n\\n        for(int no: basket1){\\n            leastCost = Math.min(leastCost, no);\\n        }\\n\\n        for(int no: basket2){\\n            leastCost = Math.min(leastCost, no);\\n        }\\n\\n        return leastCost;\\n    }\\n\\n    public boolean haveSolution(int[] basket1, int[] basket2, HashMap<Integer, Integer> allFruitsMap){\\n        if(basket1.length != basket2.length) return false;\\n\\n        for(int key: allFruitsMap.keySet()){\\n            if(allFruitsMap.get(key) % 2 == 1) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long minCost(int[] basket1, int[] basket2) {\\n        HashMap<Integer, Integer> allFruitsMap = aggregateAllFruits(basket1, basket2);\\n\\n        if(!haveSolution(basket1, basket2, allFruitsMap)) return -1;\\n\\n        int leastCostFruit = getLeastCostFruit(basket1, basket2);\\n\\n        HashMap<Integer, Integer> idealBasket = getIdealBasket(allFruitsMap);\\n\\n        //Find out what needs to be swapped for the first basket and second basket\\n        //getDifferences will get both what is lacking for the basket and what is excessive for it\\n        List<Integer> fruitSwapsNeeded = getDifferences(idealBasket, basket1);\\n\\n        Collections.sort(fruitSwapsNeeded);\\n\\n        int noOfSwapsNeeded = fruitSwapsNeeded.size() / 2;\\n\\n        long minCost = 0;\\n\\n        for(int i = 0; i < noOfSwapsNeeded; i++){\\n            minCost += Math.min(leastCostFruit * 2, fruitSwapsNeeded.get(i));\\n        }\\n\\n        return minCost;\\n    }\\n\\n    public List<Integer> getDifferences(HashMap<Integer, Integer> idealBasket, int[] basket){\\n\\n        ArrayList<Integer> store = new ArrayList<>();\\n        HashMap<Integer, Integer> basketMap = new HashMap<Integer, Integer>();\\n\\n        for(int fruit: basket){\\n            basketMap.put(fruit, basketMap.getOrDefault(fruit, 0) + 1);\\n        }\\n\\n        for(int key: idealBasket.keySet()){\\n            int idealBasketFruitCount = idealBasket.getOrDefault(key, 0);\\n            int basketFruitCount = basketMap.getOrDefault(key, 0);\\n            int difference = Math.abs(idealBasketFruitCount - basketFruitCount);\\n\\n            for(int i = 0; i < difference; i++){\\n                store.add(key);\\n            }\\n        }\\n\\n        return store;\\n    }\\n\\n    public HashMap<Integer, Integer> getIdealBasket(HashMap<Integer, Integer> allFruitsMap){\\n        HashMap<Integer, Integer> hMap = new HashMap<>();\\n\\n        for(int key: allFruitsMap.keySet()){\\n            hMap.put(key, allFruitsMap.get(key)/2);\\n        }\\n\\n        return hMap;\\n    }\\n\\n    public HashMap<Integer, Integer> aggregateAllFruits(int[] basket1, int[] basket2){\\n        HashMap<Integer, Integer> hMap = new HashMap<>();\\n\\n        for(int i = 0; i < basket1.length; i++){\\n            hMap.put(basket1[i], hMap.getOrDefault(basket1[i], 0) + 1);\\n        }\\n\\n        for(int i = 0; i < basket2.length; i++){\\n            hMap.put(basket2[i], hMap.getOrDefault(basket2[i], 0) + 1);\\n        }\\n\\n        return hMap;\\n    }\\n\\n    public int getLeastCostFruit(int[] basket1, int[] basket2){\\n        int leastCost = Integer.MAX_VALUE;\\n\\n        for(int no: basket1){\\n            leastCost = Math.min(leastCost, no);\\n        }\\n\\n        for(int no: basket2){\\n            leastCost = Math.min(leastCost, no);\\n        }\\n\\n        return leastCost;\\n    }\\n\\n    public boolean haveSolution(int[] basket1, int[] basket2, HashMap<Integer, Integer> allFruitsMap){\\n        if(basket1.length != basket2.length) return false;\\n\\n        for(int key: allFruitsMap.keySet()){\\n            if(allFruitsMap.get(key) % 2 == 1) return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3228752,
                "title": "very-clean-code-easy-to-understand",
                "content": "```python3 []\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        result = 0\\n        count1 = Counter(basket1)\\n        count2 = Counter(basket2)\\n        fruits_set = set(basket1 + basket2)\\n        min_fruit = min(fruits_set)\\n\\n        need_swaped_fruits1 = []\\n        need_swaped_fruits2 = []\\n\\n        for fruit in fruits_set:\\n            if (count1[fruit] + count2[fruit]) % 2 != 0:\\n                return -1\\n\\n            diff = abs(count1[fruit] - count2[fruit])\\n\\n            if count1[fruit] > count2[fruit]:\\n                need_swaped_fruits1 += [fruit] * (diff // 2)\\n            else:\\n                need_swaped_fruits2 += [fruit] * (diff // 2)\\n            \\n        need_swaped_fruits1.sort()\\n        need_swaped_fruits2.sort()\\n        need_swaped_fruits2.reverse()\\n\\n        for fruit1, fruit2 in zip(need_swaped_fruits1, need_swaped_fruits2):\\n            result += min(fruit1, fruit2, min_fruit * 2)\\n\\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        result = 0\\n        count1 = Counter(basket1)\\n        count2 = Counter(basket2)\\n        fruits_set = set(basket1 + basket2)\\n        min_fruit = min(fruits_set)\\n\\n        need_swaped_fruits1 = []\\n        need_swaped_fruits2 = []\\n\\n        for fruit in fruits_set:\\n            if (count1[fruit] + count2[fruit]) % 2 != 0:\\n                return -1\\n\\n            diff = abs(count1[fruit] - count2[fruit])\\n\\n            if count1[fruit] > count2[fruit]:\\n                need_swaped_fruits1 += [fruit] * (diff // 2)\\n            else:\\n                need_swaped_fruits2 += [fruit] * (diff // 2)\\n            \\n        need_swaped_fruits1.sort()\\n        need_swaped_fruits2.sort()\\n        need_swaped_fruits2.reverse()\\n\\n        for fruit1, fruit2 in zip(need_swaped_fruits1, need_swaped_fruits2):\\n            result += min(fruit1, fruit2, min_fruit * 2)\\n\\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216151,
                "title": "python-simple-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1, basket2):\\n        d1, d2 = collections.Counter(basket1), collections.Counter(basket2)\\n\\n        d = d1 + d2\\n\\n        for i in d:\\n            d[i], r = divmod(d[i],2)\\n            if r == 1: return -1\\n\\n        min_val = min(d)\\n        d1 -= d\\n        d2 -= d\\n\\n        arr = sorted(list(d1.elements()) + list(d2.elements()))\\n\\n        return sum(min(2*min_val,arr[i]) for i in range(len(arr)//2))\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1, basket2):\\n        d1, d2 = collections.Counter(basket1), collections.Counter(basket2)\\n\\n        d = d1 + d2\\n\\n        for i in d:\\n            d[i], r = divmod(d[i],2)\\n            if r == 1: return -1\\n\\n        min_val = min(d)\\n        d1 -= d\\n        d2 -= d\\n\\n        arr = sorted(list(d1.elements()) + list(d2.elements()))\\n\\n        return sum(min(2*min_val,arr[i]) for i in range(len(arr)//2))\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211260,
                "title": "hashmap-first-solution-with-a-sort-of-a-small-subset-at-the-end-if-required",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse hashmap to match items from basket 1 to basket 2 and determine number of transfers. If any item has an odd number outstanding, balancing is impossible.\\n\\nThe cheapest cost per transfered pair is the lower of the pair, so if the lower of the pair isn\\'t less than twice the cost of the cheapest item in any basket, the cheapest way to transfer is by using that cheapest item twice to do transfer the pair. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplemented a simple hashmap that counts items from basket one as +ve, and items from basket 2 as -ve. Simultaneously it is searching the minimum value item, and keeping a total of the number of odd-counted values. Also keeps track of total number of unique values: if it goes above basketSize balancing is impossible (exiting here also means the hashmap can never get full).\\n\\nWhen all items have been entered into the hashmap, if there are any odd item counts outstanding, balancing is impossible.\\n\\nPasses over the entire hashmap looking for all unbalanced items that are below the 2*minval line, copying them to a new array in case needed, and totaling their transfer values, whilst counting how many are below and above the line.\\nAt the end, if more are above the line than below, we can already calculate the required minimum cost without more work.\\n\\nOtherwise, sort the copied below-line values, and subtract enough from the top end to balance above and below counts from the previous below-line total.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\xB7log(n))$$ for the final sort in worst case, $$\\u03A9(n)$$ for all other actions\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ since all arrays scale with input size\\n# Code\\n```\\nint hashbits = 0;\\n#define BIGNUM 2808820391\\n\\ninline uint32_t hashfunc(int val)\\n{\\n    return ((uint32_t)(val * BIGNUM)) >> hashbits;\\n}\\n\\nint cmp(void* a, void* b)\\n{ return *(int*)b - *(int*)a; } // sort descending order\\n\\nlong long minCost(int* basket1, int basket1Size, int* basket2, int basket2Size){\\n    // use counting hashmap to match elements from basket1 to basket 2 (count basket1 +, count basket2 -)\\n    // if there are elements with odd counts, either positive or negative, operation is impossible - return -1.\\n    //              (can be done during hashmap build using odd totaller - +1 when count goes from even to odd, -1 when goes from odd to even)\\n    //              (use odds += (((count & 1) << 1) - 1) ... even => -1, odd => 1)\\n   \\n    // lowest cost is by using lowest value items to do all needed swaps,\\n    // unless a double-swap has an item that is lower cost than 2 of the lowest cost items.\\n    // so find minimum item cost, double it, find all items below that cost that need to move, use all of them to move other items, then use lowest \\n    //  cost items to move the rest (do not need to be items that need to move as long as number of moves is even - it must be)\\n    if(basket2Size != basket1Size) return -1;\\n    int hashsize = basket1Size + 100; // minimum extra space in the hashtable\\n    __asm__ volatile (\"     bsr     %1, %0      \\\\n\"         // bit scan reverse\\n                    \"       inc     %0          \\\\n\"         // n+=1 to get last unset bit rather than first set bit\\n                    \"       xor     %1, %1      \\\\n\"         // = 0\\n                    \"       bts     %0, %1      \\\\n\"         //  n\\'th bit set        \\n                    : \"+&r\" (hashbits), \"+&r\" (hashsize) );\\n    int map[hashsize]; // next largest power of two\\n    int count[hashsize]; // next largest power of two\\n    for(int i = 0; i < hashsize; map[i++] = 0) count[i] = 0;\\n    hashsize -= 1; // hash mask\\n    hashbits = 32 - hashbits; // right shift to leave old_hashbits remaining bits\\n\\n    // printf(\"%i, %i, %i\\\\n\", basket1Size, hashsize, hashbits);\\n\\n    int odds = 0; // odd counts counter\\n    int min = 1000000000; // minimum item cost\\n    int uniques = 0; // counting uniques. if total number of unique items goes beyond basketSize, balancing them is impossible.\\n\\n    for(int i = 0; i < basket1Size; i++)\\n    {\\n        int m, e = basket1[i];\\n        if(e < min) min = e;\\n        uint32_t hash = hashfunc(e);\\n        while((m = map[hash]))\\n        {\\n            if(m == e) goto match1;\\n            hash = (hash+1) & hashsize;\\n        }\\n        if((++uniques) > basket1Size) return -1;\\n        map[hash] = e;\\n    match1: ;\\n        int c = (count[hash] += 1); // basket1 counts positive\\n        odds += ((c & 1) << 1) - 1; // +1 if now odd, -1 if now even\\n\\n        e = basket2[i];\\n        if(e < min) min = e;\\n        hash = hashfunc(e);\\n        while((m = map[hash]))\\n        {\\n            if(m == e) goto match2;\\n            hash = (hash+1) & hashsize;\\n        }\\n        if((++uniques) > basket1Size) return -1;\\n        map[hash] = e;\\n    match2: ;\\n        c = (count[hash] -= 1); // basket2 counts negative\\n        odds += ((c & 1) << 1) - 1; // +1 if now odd, -1 if now even\\n    }\\n    if(odds) return -1; // odds contains the total number of odd counts in the whole hashmap. if it is not zero, balancing is impossible.\\n\\n    // to find the total minimum cost of swapping we need to scan the entire hashmap, \\n    // all non-zero counts that are less than double the minimum item cost are swapped in pairs with higher value items. \\n    // if there are less items above that line than below it, the highest value items from below the line are swapped,\\n    // otherwise all items from below are counted and all items from above beyond that count are counted as taking minimum item cost to transfer. \\n    int min2 = min * 2;\\n    int above = 0, below = 0; long long totalbelow = 0;\\n    int belowitemslength = 0;\\n    struct items { int m, c; } belowitems[basket1Size];\\n    for(int i = 0; i <= hashsize; i++)\\n    {   int t; if(!(t = count[i])) continue;\\n        int c; if((c = -t) < 0) c = t; // all counts positive now\\n        c >>= 1; // only half of the count needs to move \\n        int m = map[i];\\n        if(m < min2)\\n        {\\n            below += c; totalbelow += (long long)c * m;\\n            belowitems[belowitemslength].m = m;\\n            belowitems[belowitemslength++].c = c;\\n        } else above += c;\\n    }\\n    // printf(\"%i, %i, %i, %lli\\\\n\", below, above, min, totalbelow);\\n    if(below <= above) return totalbelow + ((above - below) * min);\\n    \\n    // now we have to work out which are the items counted as below that we should match with lower items from below min2.\\n    // I guess we have to sort them\\n\\n    qsort(belowitems, belowitemslength, sizeof(struct items), cmp);\\n    int c, m, n = (below - above) / 2;\\n    for(int i = 0; n > 0; i++)\\n    {\\n        c = belowitems[i].c;\\n        m = belowitems[i].m; \\n        totalbelow -= (long long)c * m;\\n        n -= c;\\n    }\\n    if(n < 0) totalbelow -= (long long)m * n; // n is negative so this corrects up the overshoot\\n\\n    return totalbelow;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint hashbits = 0;\\n#define BIGNUM 2808820391\\n\\ninline uint32_t hashfunc(int val)\\n{\\n    return ((uint32_t)(val * BIGNUM)) >> hashbits;\\n}\\n\\nint cmp(void* a, void* b)\\n{ return *(int*)b - *(int*)a; } // sort descending order\\n\\nlong long minCost(int* basket1, int basket1Size, int* basket2, int basket2Size){\\n    // use counting hashmap to match elements from basket1 to basket 2 (count basket1 +, count basket2 -)\\n    // if there are elements with odd counts, either positive or negative, operation is impossible - return -1.\\n    //              (can be done during hashmap build using odd totaller - +1 when count goes from even to odd, -1 when goes from odd to even)\\n    //              (use odds += (((count & 1) << 1) - 1) ... even => -1, odd => 1)\\n   \\n    // lowest cost is by using lowest value items to do all needed swaps,\\n    // unless a double-swap has an item that is lower cost than 2 of the lowest cost items.\\n    // so find minimum item cost, double it, find all items below that cost that need to move, use all of them to move other items, then use lowest \\n    //  cost items to move the rest (do not need to be items that need to move as long as number of moves is even - it must be)\\n    if(basket2Size != basket1Size) return -1;\\n    int hashsize = basket1Size + 100; // minimum extra space in the hashtable\\n    __asm__ volatile (\"     bsr     %1, %0      \\\\n\"         // bit scan reverse\\n                    \"       inc     %0          \\\\n\"         // n+=1 to get last unset bit rather than first set bit\\n                    \"       xor     %1, %1      \\\\n\"         // = 0\\n                    \"       bts     %0, %1      \\\\n\"         //  n\\'th bit set        \\n                    : \"+&r\" (hashbits), \"+&r\" (hashsize) );\\n    int map[hashsize]; // next largest power of two\\n    int count[hashsize]; // next largest power of two\\n    for(int i = 0; i < hashsize; map[i++] = 0) count[i] = 0;\\n    hashsize -= 1; // hash mask\\n    hashbits = 32 - hashbits; // right shift to leave old_hashbits remaining bits\\n\\n    // printf(\"%i, %i, %i\\\\n\", basket1Size, hashsize, hashbits);\\n\\n    int odds = 0; // odd counts counter\\n    int min = 1000000000; // minimum item cost\\n    int uniques = 0; // counting uniques. if total number of unique items goes beyond basketSize, balancing them is impossible.\\n\\n    for(int i = 0; i < basket1Size; i++)\\n    {\\n        int m, e = basket1[i];\\n        if(e < min) min = e;\\n        uint32_t hash = hashfunc(e);\\n        while((m = map[hash]))\\n        {\\n            if(m == e) goto match1;\\n            hash = (hash+1) & hashsize;\\n        }\\n        if((++uniques) > basket1Size) return -1;\\n        map[hash] = e;\\n    match1: ;\\n        int c = (count[hash] += 1); // basket1 counts positive\\n        odds += ((c & 1) << 1) - 1; // +1 if now odd, -1 if now even\\n\\n        e = basket2[i];\\n        if(e < min) min = e;\\n        hash = hashfunc(e);\\n        while((m = map[hash]))\\n        {\\n            if(m == e) goto match2;\\n            hash = (hash+1) & hashsize;\\n        }\\n        if((++uniques) > basket1Size) return -1;\\n        map[hash] = e;\\n    match2: ;\\n        c = (count[hash] -= 1); // basket2 counts negative\\n        odds += ((c & 1) << 1) - 1; // +1 if now odd, -1 if now even\\n    }\\n    if(odds) return -1; // odds contains the total number of odd counts in the whole hashmap. if it is not zero, balancing is impossible.\\n\\n    // to find the total minimum cost of swapping we need to scan the entire hashmap, \\n    // all non-zero counts that are less than double the minimum item cost are swapped in pairs with higher value items. \\n    // if there are less items above that line than below it, the highest value items from below the line are swapped,\\n    // otherwise all items from below are counted and all items from above beyond that count are counted as taking minimum item cost to transfer. \\n    int min2 = min * 2;\\n    int above = 0, below = 0; long long totalbelow = 0;\\n    int belowitemslength = 0;\\n    struct items { int m, c; } belowitems[basket1Size];\\n    for(int i = 0; i <= hashsize; i++)\\n    {   int t; if(!(t = count[i])) continue;\\n        int c; if((c = -t) < 0) c = t; // all counts positive now\\n        c >>= 1; // only half of the count needs to move \\n        int m = map[i];\\n        if(m < min2)\\n        {\\n            below += c; totalbelow += (long long)c * m;\\n            belowitems[belowitemslength].m = m;\\n            belowitems[belowitemslength++].c = c;\\n        } else above += c;\\n    }\\n    // printf(\"%i, %i, %i, %lli\\\\n\", below, above, min, totalbelow);\\n    if(below <= above) return totalbelow + ((above - below) * min);\\n    \\n    // now we have to work out which are the items counted as below that we should match with lower items from below min2.\\n    // I guess we have to sort them\\n\\n    qsort(belowitems, belowitemslength, sizeof(struct items), cmp);\\n    int c, m, n = (below - above) / 2;\\n    for(int i = 0; n > 0; i++)\\n    {\\n        c = belowitems[i].c;\\n        m = belowitems[i].m; \\n        totalbelow -= (long long)c * m;\\n        n -= c;\\n    }\\n    if(n < 0) totalbelow -= (long long)m * n; // n is negative so this corrects up the overshoot\\n\\n    return totalbelow;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3206653,
                "title": "explained-with-example-tc-sc-well-commented",
                "content": "# Intuition\\n \\n     \\n        Denoting Sorted Array for easy understanding\\n\\n        b1: 3 3 3 3 3 3 3 4\\n        b2: 1 1 1 1 3 4 4 4\\n\\n        =>Remove Already Good Ones\\n        b1: 3 3 3 3 3 3\\n        b2: 1 1 1 1 4 4\\n\\n        Note1: freq of each After removal should be EVEN,else NOT possible\\n        Note2: since want minimum cost , PAIR start of b1 with end of b2 \\n        Note3: Only have to move half Count of each i.e 3 1`s , 2 1`s , 1 1`s\\n                b1: 3 3 3 1 1 4\\n                b2: 1 1 3 3 3 4\\n\\n        b1: 3 3 3 (all three needs to be sent to b2)\\n        b2: 1 1 4 (all needs to be sent to b1)\\n\\n        =>Cost Calculation\\n        b1: 3 3 1\\n        b2: 3 1 4\\n        cost = min(1,3) = 1\\n\\n        b1: 3 1 1\\n        b2: 3 3 4\\n        cost = 1 + min(1,3) = 2\\n\\n        b1: 4 1 1\\n        b2: 3 3 3\\n        cost = 2 + min(3,4) = 5 [can be better]\\n        Instead,\\n            Task is to move 4 to b1 with the help of minimum (i.e 1)\\n            b1: 3 1 4\\n            b2: 3 3 1\\n            cost = 2 + min(1,4) = 3\\n\\n            b1: 1 1 4\\n            b2: 3 3 3\\n            cost = 3 + min(1,4) = 4 [better]\\n\\n    \\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(nlogn)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int,int> store1,store2;\\n        vector<int> arr1,arr2;\\n        int minElem = INT_MAX;\\n        long long cost = 0;\\n\\n        for(auto e:basket1){\\n            store1[e]++;\\n            minElem = min(minElem,e);\\n        }\\n        for(auto e:basket2){\\n            store2[e]++;\\n            minElem = min(minElem,e);\\n\\n        }\\n\\n        for(auto e:store1){\\n            int num = e.first;\\n            if(store2.count(num) == 1){\\n                //same element \\n                int common_count = min(store1[num],store2[num]);\\n                store1[num] = store1[num] - common_count;\\n                store2[num] = store2[num] - common_count;\\n\\n            }\\n            if(store1[num]%2 != 0){\\n                //freq ODD , cant make EQUAL\\n                return -1;\\n            }\\n\\n            //Now , push Only Half Count to arr1\\n            int count = store1[num]/2;\\n        \\n            while(count > 0){\\n                arr1.push_back(num);\\n                count--;\\n            }\\n            \\n        }\\n        for(auto e:store2){\\n            int num = e.first;\\n            if(store1.count(num) == 1){\\n                //same element \\n                int common_count = min(store1[num],store2[num]);\\n                store1[num] = store1[num] - common_count;\\n                store2[num] = store2[num] - common_count;\\n\\n            }\\n            if(store2[num]%2 != 0){\\n                //freq ODD , cant make EQUAL\\n                return -1;\\n            }\\n\\n            //Now , push Only Half Count to arr1\\n            int count = store2[num]/2;\\n        \\n            while(count > 0){\\n                arr2.push_back(num);\\n                count--;\\n            }\\n            \\n        }\\n\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n\\n        int n = arr1.size();\\n        for(int i=0;i<n;i++){\\n            //chose cost of first and last swap   OR  using minElem \\n            cost = cost + min(2*minElem,min(arr1[i],arr2[n-i-1]));\\n        }\\n        return cost;\\n        \\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int,int> store1,store2;\\n        vector<int> arr1,arr2;\\n        int minElem = INT_MAX;\\n        long long cost = 0;\\n\\n        for(auto e:basket1){\\n            store1[e]++;\\n            minElem = min(minElem,e);\\n        }\\n        for(auto e:basket2){\\n            store2[e]++;\\n            minElem = min(minElem,e);\\n\\n        }\\n\\n        for(auto e:store1){\\n            int num = e.first;\\n            if(store2.count(num) == 1){\\n                //same element \\n                int common_count = min(store1[num],store2[num]);\\n                store1[num] = store1[num] - common_count;\\n                store2[num] = store2[num] - common_count;\\n\\n            }\\n            if(store1[num]%2 != 0){\\n                //freq ODD , cant make EQUAL\\n                return -1;\\n            }\\n\\n            //Now , push Only Half Count to arr1\\n            int count = store1[num]/2;\\n        \\n            while(count > 0){\\n                arr1.push_back(num);\\n                count--;\\n            }\\n            \\n        }\\n        for(auto e:store2){\\n            int num = e.first;\\n            if(store1.count(num) == 1){\\n                //same element \\n                int common_count = min(store1[num],store2[num]);\\n                store1[num] = store1[num] - common_count;\\n                store2[num] = store2[num] - common_count;\\n\\n            }\\n            if(store2[num]%2 != 0){\\n                //freq ODD , cant make EQUAL\\n                return -1;\\n            }\\n\\n            //Now , push Only Half Count to arr1\\n            int count = store2[num]/2;\\n        \\n            while(count > 0){\\n                arr2.push_back(num);\\n                count--;\\n            }\\n            \\n        }\\n\\n        sort(arr1.begin(),arr1.end());\\n        sort(arr2.begin(),arr2.end());\\n\\n        int n = arr1.size();\\n        for(int i=0;i<n;i++){\\n            //chose cost of first and last swap   OR  using minElem \\n            cost = cost + min(2*minElem,min(arr1[i],arr2[n-i-1]));\\n        }\\n        return cost;\\n        \\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193139,
                "title": "rearranging-fruits-hard-problem-easy-solution-using-maps-100-fast",
                "content": "# Intuition\\nMap the difference of occurence of each element of basket 1 and basket 2.\\n\\n# Approach\\nIf any of difference id odd then it is not posible to split them equally therefor giving us a base case. Assuming all the differences are even, then calculate the number of swaps. Also check the cost of each element,if the cost is less than 2 time smallest element then take the mincost.\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Please Upvote the solution\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int,int> m;\\n        int n = basket1.size();\\n        for(int i=0;i<n;i++){\\n            m[basket1[i]]++;\\n            --m[basket2[i]];\\n        }\\n        int dif,minswap=0,a=m.begin()->first;\\n        for(auto it:m){\\n            dif = it.second;\\n            if(dif%2!=0){\\n                return -1;\\n            }\\n            minswap+=max(0,dif/2);\\n        }\\n        long long ans=0;\\n        for(auto it:m){\\n            if(it.second!=0 && minswap>0){\\n                long long x = min(minswap,abs(it.second/2));\\n                long long y = min(2*a,it.first);\\n                ans += x*y;\\n                minswap -= abs(it.second/2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int,int> m;\\n        int n = basket1.size();\\n        for(int i=0;i<n;i++){\\n            m[basket1[i]]++;\\n            --m[basket2[i]];\\n        }\\n        int dif,minswap=0,a=m.begin()->first;\\n        for(auto it:m){\\n            dif = it.second;\\n            if(dif%2!=0){\\n                return -1;\\n            }\\n            minswap+=max(0,dif/2);\\n        }\\n        long long ans=0;\\n        for(auto it:m){\\n            if(it.second!=0 && minswap>0){\\n                long long x = min(minswap,abs(it.second/2));\\n                long long y = min(2*a,it.first);\\n                ans += x*y;\\n                minswap -= abs(it.second/2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188735,
                "title": "c-gready-solution",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) \\n    {\\n        ll mn=INT_MAX;\\n        map<int,int>record,b1,b2;\\n        for(auto &x:basket1)record[x]++,b1[x]++,mn=min(mn,1ll*x);\\n        for(auto &x:basket2)record[x]++,b2[x]++,mn=min(mn,1ll*x);\\n        for(auto &x:record)\\n        {\\n            if(x.second%2)return -1;\\n            x.second/=2;\\n        }\\n        ll res=0;\\n        deque<int>dq1,dq2;\\n        for(auto &x:b1)\\n            for(int i=0;i<x.second-record[x.first];i++)\\n                dq1.push_back(x.first);\\n        for(auto &x:b2)\\n            for(int i=0;i<x.second-record[x.first];i++)\\n                dq2.push_back(x.first);\\n        while(dq1.size())\\n        {\\n            int l1=dq1.front();\\n            int l2=dq2.front();\\n            if(mn*2<=min(l1,l2))break;\\n            if(l1<l2)\\n            {\\n                res+=l1;\\n                dq1.pop_front();\\n                dq2.pop_back();\\n            }else\\n            {\\n                res+=l2;\\n                dq1.pop_back();\\n                dq2.pop_front();\\n            }\\n        }\\n        res+=dq1.size()*2*mn;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) \\n    {\\n        ll mn=INT_MAX;\\n        map<int,int>record,b1,b2;\\n        for(auto &x:basket1)record[x]++,b1[x]++,mn=min(mn,1ll*x);\\n        for(auto &x:basket2)record[x]++,b2[x]++,mn=min(mn,1ll*x);\\n        for(auto &x:record)\\n        {\\n            if(x.second%2)return -1;\\n            x.second/=2;\\n        }\\n        ll res=0;\\n        deque<int>dq1,dq2;\\n        for(auto &x:b1)\\n            for(int i=0;i<x.second-record[x.first];i++)\\n                dq1.push_back(x.first);\\n        for(auto &x:b2)\\n            for(int i=0;i<x.second-record[x.first];i++)\\n                dq2.push_back(x.first);\\n        while(dq1.size())\\n        {\\n            int l1=dq1.front();\\n            int l2=dq2.front();\\n            if(mn*2<=min(l1,l2))break;\\n            if(l1<l2)\\n            {\\n                res+=l1;\\n                dq1.pop_front();\\n                dq2.pop_back();\\n            }else\\n            {\\n                res+=l2;\\n                dq1.pop_back();\\n                dq2.pop_front();\\n            }\\n        }\\n        res+=dq1.size()*2*mn;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3183289,
                "title": "java-javascript-two-swap-ways-picture-explanations",
                "content": "First, we should count basket1 and basket2, if any fruit has odd quantity,\\nthen it\\'s impossible for success to swap, we can **return -1** immediately.\\n\\nNext, two baskets total length are even now, then we find out the fruits in basket1 and basket2 which need to be swap.\\n\\n---\\n\\n### Key point : **The cost of the swap is min(basket1[i],basket2[j])**\\n\\nFor Example : \\n```\\nbasket1 = [1, 1, 20, 20, 20]\\nbasket2 = [100, 100, 20, 8, 8]\\n```\\n\\n#### 1. Direct Swap\\nChoice one fruit from two baskets to direct swap, very straightforward.\\nThe minimum cost is `Min(basket1[i], basket2[i])`\\n\\n<img src=\"https://assets.leetcode.com/users/images/4d0e0781-dc45-4527-8800-d266a3278269_1676348084.6343546.png\" width=\"600px\" height=\"auto\"/>\\n<br>\\n<br>\\n\\n#### 2. Indirect Swap\\nThe other way is to use the smallest value in basket1 and basket2, and swap two times.\\n<img src=\"https://assets.leetcode.com/users/images/e9b81ac9-9feb-4f5b-900f-9432a74cfa2d_1676348140.9636006.png\" width=\"600px\" height=\"auto\"/>\\n\\n<br>\\n\\nSo we need to compare which swap way is the minimum cost.\\n\\n* Time Complexity : O(nlogn)\\n* Space Complexity : O(n)\\n\\n---\\n<br>\\n\\n#### Java\\n\\n```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        int n = basket1.length;\\n        \\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        Map<Integer, Integer> map2 = new HashMap<>();\\n        int minVal = Integer.MAX_VALUE; // Use on indirect swap\\n        \\n        // Counting the basket\\'s number to each HashMap\\n        for(int i = 0; i < n; i++){\\n            map1.put(basket1[i], map1.getOrDefault(basket1[i], 0) + 1);\\n            map2.put(basket2[i], map2.getOrDefault(basket2[i], 0) + 1);\\n            minVal = Math.min(minVal, basket1[i]);\\n            minVal = Math.min(minVal, basket2[i]);\\n        }\\n        \\n        // build swap list, if any number is too more, add numbers to prepare swap list\\n        List<Integer> swapList1 = new ArrayList<>();\\n        for(int key: map1.keySet()){\\n            int c1 = map1.get(key);\\n            int c2 = map2.getOrDefault(key, 0);\\n            if((c1 + c2) % 2 == 1) return -1; // if number is odd count, immediately return -1\\n            if(c1 > c2){\\n                int addCnt = (c1 - c2) / 2;\\n                while(addCnt-- > 0){\\n                    swapList1.add(key);\\n                }\\n            }\\n        }\\n        \\n        List<Integer> swapList2 = new ArrayList<>();\\n        for(int key: map2.keySet()){\\n            int c1 = map1.getOrDefault(key, 0);\\n            int c2 = map2.get(key);\\n            if((c1 + c2) % 2 == 1) return -1;  // if number is odd count, immediately return -1\\n            if(c2 > c1){\\n                int addCnt = (c2 - c1) / 2;\\n                while(addCnt-- > 0){\\n                    swapList2.add(key);\\n                }\\n            }\\n        }\\n        \\n        // Sorting\\n        Collections.sort(swapList1);\\n        Collections.sort(swapList2, (a, b) -> b - a);\\n        \\n        // visite swap list\\n        long res = 0;\\n        for(int i = 0; i < swapList1.size(); i++){\\n            // Two choices to swap, direct swap or indirect swap\\n            res += Math.min(2 * minVal, \\n                            Math.min(swapList1.get(i), swapList2.get(i))\\n                           );\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n#### Javascript\\n\\n```\\n/**\\n * @param {number[]} basket1\\n * @param {number[]} basket2\\n * @return {number}\\n */\\nvar minCost = function(basket1, basket2) {\\n    const [map1, map2] = [new Map(), new Map()];\\n    let minVal = Number.MAX_SAFE_INTEGER;\\n    \\n    // Counting the basket\\'s number to each HashMap\\n    for(const val of basket1){\\n        if(!map1.has(val))\\n            map1.set(val, 0);\\n        map1.set(val, map1.get(val) + 1);\\n        minVal = Math.min(minVal, val);\\n    }\\n    for(const val of basket2){\\n        if(!map2.has(val))\\n            map2.set(val, 0);\\n        map2.set(val, map2.get(val) + 1);\\n        minVal = Math.min(minVal, val);\\n    }\\n    \\n    // build swap list\\n    const [swapList1, swapList2] = [[], []];\\n    for(const [key, c1] of map1.entries()){\\n        const c2 = map2.get(key) || 0;\\n        if((c1 + c2) % 2) return -1;\\n        if(c1 > c2){\\n            let addCnt = (c1 - c2) >> 1;\\n            while(addCnt--){\\n                swapList1.push(key);\\n            }\\n        }\\n    }\\n    for(const [key, c2] of map2.entries()){\\n        const c1 = map1.get(key) || 0;\\n        if((c1 + c2) % 2) return -1;\\n        if(c2 > c1){\\n            let addCnt = (c2 - c1) >> 1;\\n            while(addCnt--){\\n                swapList2.push(key);\\n            }\\n        }\\n    }\\n    \\n    // Sorting\\n    swapList1.sort((a, b) => a - b);\\n    swapList2.sort((a, b) => b - a);\\n    const n = swapList1.length;\\n    \\n    // visite swap list\\n    let res = 0;\\n    for(let i = 0; i < n; i++){\\n        // Two choices to swap, direct swap or indirect swap\\n        res += Math.min(2 * minVal, swapList1[i], swapList2[i]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nbasket1 = [1, 1, 20, 20, 20]\\nbasket2 = [100, 100, 20, 8, 8]\\n```\n```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        int n = basket1.length;\\n        \\n        Map<Integer, Integer> map1 = new HashMap<>();\\n        Map<Integer, Integer> map2 = new HashMap<>();\\n        int minVal = Integer.MAX_VALUE; // Use on indirect swap\\n        \\n        // Counting the basket\\'s number to each HashMap\\n        for(int i = 0; i < n; i++){\\n            map1.put(basket1[i], map1.getOrDefault(basket1[i], 0) + 1);\\n            map2.put(basket2[i], map2.getOrDefault(basket2[i], 0) + 1);\\n            minVal = Math.min(minVal, basket1[i]);\\n            minVal = Math.min(minVal, basket2[i]);\\n        }\\n        \\n        // build swap list, if any number is too more, add numbers to prepare swap list\\n        List<Integer> swapList1 = new ArrayList<>();\\n        for(int key: map1.keySet()){\\n            int c1 = map1.get(key);\\n            int c2 = map2.getOrDefault(key, 0);\\n            if((c1 + c2) % 2 == 1) return -1; // if number is odd count, immediately return -1\\n            if(c1 > c2){\\n                int addCnt = (c1 - c2) / 2;\\n                while(addCnt-- > 0){\\n                    swapList1.add(key);\\n                }\\n            }\\n        }\\n        \\n        List<Integer> swapList2 = new ArrayList<>();\\n        for(int key: map2.keySet()){\\n            int c1 = map1.getOrDefault(key, 0);\\n            int c2 = map2.get(key);\\n            if((c1 + c2) % 2 == 1) return -1;  // if number is odd count, immediately return -1\\n            if(c2 > c1){\\n                int addCnt = (c2 - c1) / 2;\\n                while(addCnt-- > 0){\\n                    swapList2.add(key);\\n                }\\n            }\\n        }\\n        \\n        // Sorting\\n        Collections.sort(swapList1);\\n        Collections.sort(swapList2, (a, b) -> b - a);\\n        \\n        // visite swap list\\n        long res = 0;\\n        for(int i = 0; i < swapList1.size(); i++){\\n            // Two choices to swap, direct swap or indirect swap\\n            res += Math.min(2 * minVal, \\n                            Math.min(swapList1.get(i), swapList2.get(i))\\n                           );\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} basket1\\n * @param {number[]} basket2\\n * @return {number}\\n */\\nvar minCost = function(basket1, basket2) {\\n    const [map1, map2] = [new Map(), new Map()];\\n    let minVal = Number.MAX_SAFE_INTEGER;\\n    \\n    // Counting the basket\\'s number to each HashMap\\n    for(const val of basket1){\\n        if(!map1.has(val))\\n            map1.set(val, 0);\\n        map1.set(val, map1.get(val) + 1);\\n        minVal = Math.min(minVal, val);\\n    }\\n    for(const val of basket2){\\n        if(!map2.has(val))\\n            map2.set(val, 0);\\n        map2.set(val, map2.get(val) + 1);\\n        minVal = Math.min(minVal, val);\\n    }\\n    \\n    // build swap list\\n    const [swapList1, swapList2] = [[], []];\\n    for(const [key, c1] of map1.entries()){\\n        const c2 = map2.get(key) || 0;\\n        if((c1 + c2) % 2) return -1;\\n        if(c1 > c2){\\n            let addCnt = (c1 - c2) >> 1;\\n            while(addCnt--){\\n                swapList1.push(key);\\n            }\\n        }\\n    }\\n    for(const [key, c2] of map2.entries()){\\n        const c1 = map1.get(key) || 0;\\n        if((c1 + c2) % 2) return -1;\\n        if(c2 > c1){\\n            let addCnt = (c2 - c1) >> 1;\\n            while(addCnt--){\\n                swapList2.push(key);\\n            }\\n        }\\n    }\\n    \\n    // Sorting\\n    swapList1.sort((a, b) => a - b);\\n    swapList2.sort((a, b) => b - a);\\n    const n = swapList1.length;\\n    \\n    // visite swap list\\n    let res = 0;\\n    for(let i = 0; i < n; i++){\\n        // Two choices to swap, direct swap or indirect swap\\n        res += Math.min(2 * minVal, swapList1[i], swapList2[i]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177286,
                "title": "c-o-nlogn",
                "content": "```\\nlong long minCost(vector<int>& b1, vector<int>& b2) {\\n            sort(b1.begin(), b1.end());\\n            sort(b2.begin(), b2.end());\\n            map<int, int> m;\\n            int mini = INT_MAX;\\n            for(int i = 0 ; i < b1.size(); i++) {\\n                mini = min(mini, b1[i]);\\n                mini = min(mini, b2[i]);\\n                m[b1[i]]++;\\n                m[b2[i]]--;\\n            }\\n\\n            vector<int>s1,s2;\\n            for(int i=0; i<b1.size(); i++) {\\n                if(m[b1[i]] %2 != 0) return -1;\\n                if(m[b1[i]] >  0) {\\n                    for(int j = 0; j < m[b1[i]]; j++) {\\n                        s1.push_back(b1[i]);\\n                    }\\n                    m[b1[i]]=0;\\n                }\\n            }\\n\\n            for(int i=0; i<b2.size(); i++) {\\n                if(m[b2[i]] %2 != 0) return -1;\\n                if(m[b2[i]] < 0) {\\n                    for(int j = 0; j < (m[b2[i]]*-1); j++) {\\n                        s2.push_back(b2[i]);\\n                    }\\n                    m[b2[i]]=0;\\n                }\\n            }\\n            if (s1.size() != s2.size()) return -1;\\n\\n            long long int ans = 0;\\n            for(int i = 0 ; i < s1.size(); i=i+2) {\\n                ans = ans + min(min(s1[i], s2[s2.size()-1-i]), 2 *mini);\\n            }\\n            return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long minCost(vector<int>& b1, vector<int>& b2) {\\n            sort(b1.begin(), b1.end());\\n            sort(b2.begin(), b2.end());\\n            map<int, int> m;\\n            int mini = INT_MAX;\\n            for(int i = 0 ; i < b1.size(); i++) {\\n                mini = min(mini, b1[i]);\\n                mini = min(mini, b2[i]);\\n                m[b1[i]]++;\\n                m[b2[i]]--;\\n            }\\n\\n            vector<int>s1,s2;\\n            for(int i=0; i<b1.size(); i++) {\\n                if(m[b1[i]] %2 != 0) return -1;\\n                if(m[b1[i]] >  0) {\\n                    for(int j = 0; j < m[b1[i]]; j++) {\\n                        s1.push_back(b1[i]);\\n                    }\\n                    m[b1[i]]=0;\\n                }\\n            }\\n\\n            for(int i=0; i<b2.size(); i++) {\\n                if(m[b2[i]] %2 != 0) return -1;\\n                if(m[b2[i]] < 0) {\\n                    for(int j = 0; j < (m[b2[i]]*-1); j++) {\\n                        s2.push_back(b2[i]);\\n                    }\\n                    m[b2[i]]=0;\\n                }\\n            }\\n            if (s1.size() != s2.size()) return -1;\\n\\n            long long int ans = 0;\\n            for(int i = 0 ; i < s1.size(); i=i+2) {\\n                ans = ans + min(min(s1[i], s2[s2.size()-1-i]), 2 *mini);\\n            }\\n            return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3175587,
                "title": "fundamental-approach-c-hash-maps",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> umap1, umap2;\\n        int n = basket1.size();\\n        int minVal = INT_MAX;\\n        for(int i=0;i<n;i++) {\\n            umap1[basket1[i]]++;\\n            umap2[basket2[i]]++;\\n            minVal = min(minVal, min(basket2[i], basket1[i]));\\n        }\\n        vector<int> toSwap;\\n        for(auto ele: umap1) {\\n            int diff = abs(ele.second-umap2[ele.first]);\\n            if(diff%2 != 0)\\n                return -1;\\n            diff /= 2;\\n            while(diff--) {\\n                toSwap.push_back(ele.first);\\n            }\\n            umap1[ele.first] = 0;\\n            umap2[ele.first] = 0;\\n        }\\n        for(auto ele: umap2) {\\n            int diff = abs(ele.second-umap1[ele.first]);\\n            if(diff%2 != 0)\\n                return -1;\\n            diff /= 2;\\n            while(diff--) {\\n                toSwap.push_back(ele.first);\\n            }\\n            umap1[ele.first] = 0;\\n            umap2[ele.first] = 0;\\n        }\\n        long long cost = 0;\\n        cout<<toSwap.size();\\n        sort(toSwap.begin(), toSwap.end());\\n        for(int i=0;i<toSwap.size()/2;i++) {\\n            cost += min(2*minVal, toSwap[i]);\\n        }\\n        return cost;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: (DeepCodes) YouTube Channel\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> umap1, umap2;\\n        int n = basket1.size();\\n        int minVal = INT_MAX;\\n        for(int i=0;i<n;i++) {\\n            umap1[basket1[i]]++;\\n            umap2[basket2[i]]++;\\n            minVal = min(minVal, min(basket2[i], basket1[i]));\\n        }\\n        vector<int> toSwap;\\n        for(auto ele: umap1) {\\n            int diff = abs(ele.second-umap2[ele.first]);\\n            if(diff%2 != 0)\\n                return -1;\\n            diff /= 2;\\n            while(diff--) {\\n                toSwap.push_back(ele.first);\\n            }\\n            umap1[ele.first] = 0;\\n            umap2[ele.first] = 0;\\n        }\\n        for(auto ele: umap2) {\\n            int diff = abs(ele.second-umap1[ele.first]);\\n            if(diff%2 != 0)\\n                return -1;\\n            diff /= 2;\\n            while(diff--) {\\n                toSwap.push_back(ele.first);\\n            }\\n            umap1[ele.first] = 0;\\n            umap2[ele.first] = 0;\\n        }\\n        long long cost = 0;\\n        cout<<toSwap.size();\\n        sort(toSwap.begin(), toSwap.end());\\n        for(int i=0;i<toSwap.size()/2;i++) {\\n            cost += min(2*minVal, toSwap[i]);\\n        }\\n        return cost;\\n    }\\n};\\n// Please consider upvoting if the solution helped! Thank you :)\\n// Credits: (DeepCodes) YouTube Channel\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3174948,
                "title": "java-easy-solution-using-greedy-construction",
                "content": "# Intuition\\nGreedy + Construction.\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        int n = basket1.length;\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int i = 0; i < n; ++i) {\\n            cnt.merge(basket1[i], 1, Integer::sum);\\n            cnt.merge(basket2[i], -1, Integer::sum);\\n        }\\n        int mi = 1 << 30;\\n        List<Integer> nums = new ArrayList<>();\\n        for (var e : cnt.entrySet()) {\\n            int x = e.getKey(), v = e.getValue();\\n            if (v % 2 != 0) {\\n                return -1;\\n            }\\n            for (int i = Math.abs(v) / 2; i > 0; --i) {\\n                nums.add(x);\\n            }\\n            mi = Math.min(mi, x);\\n        }\\n        Collections.sort(nums);\\n        int m = nums.size();\\n        long ans = 0;\\n        for (int i = 0; i < m / 2; ++i) {\\n            ans += Math.min(nums.get(i), mi * 2);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        int n = basket1.length;\\n        Map<Integer, Integer> cnt = new HashMap<>();\\n        for (int i = 0; i < n; ++i) {\\n            cnt.merge(basket1[i], 1, Integer::sum);\\n            cnt.merge(basket2[i], -1, Integer::sum);\\n        }\\n        int mi = 1 << 30;\\n        List<Integer> nums = new ArrayList<>();\\n        for (var e : cnt.entrySet()) {\\n            int x = e.getKey(), v = e.getValue();\\n            if (v % 2 != 0) {\\n                return -1;\\n            }\\n            for (int i = Math.abs(v) / 2; i > 0; --i) {\\n                nums.add(x);\\n            }\\n            mi = Math.min(mi, x);\\n        }\\n        Collections.sort(nums);\\n        int m = nums.size();\\n        long ans = 0;\\n        for (int i = 0; i < m / 2; ++i) {\\n            ans += Math.min(nums.get(i), mi * 2);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173339,
                "title": "1sentence-xor-price-counts-2-to-get-prices-to-exchange-min-min-a-b-2-minelem-is-optimal",
                "content": "# Code\\n```\\ndef minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n    f1 = Counter(basket1)\\n    f2 = Counter(basket2)\\n    minPrice = 1000000001\\n    for price, count in (f1+f2).items():\\n        if count % 2: return -1\\n        minPrice = min(minPrice, price)\\n    fxor = (f1-f2)+(f2-f1)\\n    prices = sorted([val for v, cnt in fxor.items() for val in [v] * (cnt//2)])\\n    ret = 0\\n    for i, price in enumerate(prices[:len(prices)//2]):\\n        if price < 2 * minPrice:\\n            ret += price\\n        else:\\n            ret += minPrice * 2 * (len(prices)//2 - i)\\n            break\\n    return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n    f1 = Counter(basket1)\\n    f2 = Counter(basket2)\\n    minPrice = 1000000001\\n    for price, count in (f1+f2).items():\\n        if count % 2: return -1\\n        minPrice = min(minPrice, price)\\n    fxor = (f1-f2)+(f2-f1)\\n    prices = sorted([val for v, cnt in fxor.items() for val in [v] * (cnt//2)])\\n    ret = 0\\n    for i, price in enumerate(prices[:len(prices)//2]):\\n        if price < 2 * minPrice:\\n            ret += price\\n        else:\\n            ret += minPrice * 2 * (len(prices)//2 - i)\\n            break\\n    return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3171193,
                "title": "c-ordered-map",
                "content": "# Observation\\n- If count of some number including both array is not even than we have to return -1\\n- Else we have to swap number and cost will be min(first_number,second_number) but what if we taking some another number to swap those two so our cost is going to be `2*another_number` and that another_number has to lay in conditon 2*another_number is less than first number as well as second number\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& bas1, vector<int>& bas2) {\\n        map<int,int> mp,mp1,mp2;\\n        int mn=INT_MAX;\\n        for(auto x:bas1){\\n            mp[x]++;\\n            mp1[x]++;\\n            mn=min(mn,x);\\n        }\\n        for(auto x:bas2){\\n            mp[x]++;\\n            mp1[x]--;\\n            mn=min(mn,x);\\n        }\\n        \\n        for(auto x:mp){\\n            if(x.second%2==1){\\n                return -1;\\n            }\\n        }\\n        \\n       vector<vector<int>> reduce1,reduce2;\\n\\n       for(auto x:mp1){\\n           int diff=abs(mp1[x.first]-mp2[x.first])/2;\\n           if(diff!=0){\\n               if(mp1[x.first]>mp2[x.first]){\\n                   reduce1.push_back({x.first,diff});\\n               }\\n               else{\\n                    reduce2.push_back({x.first,diff});\\n               }\\n           }\\n           mp1.erase(x.first);\\n           mp2.erase(x.first);\\n       } \\n\\n        for(auto x:mp2){\\n           int diff=abs(mp1[x.first]-mp2[x.first])/2;\\n           if(diff!=0){\\n               if(mp1[x.first]>mp2[x.first]){\\n                   reduce1.push_back({x.first,diff});\\n               }\\n               else{\\n                    reduce2.push_back({x.first,diff});\\n               }\\n           }\\n       } \\n\\n        sort(reduce1.begin(),reduce1.end());\\n        sort(reduce2.begin(),reduce2.end());\\n        int i=0,j=reduce2.size()-1;\\n        long long ans=0;\\n        while(i<reduce1.size() && j>=0){\\n            int mi=min(reduce1[i][1],reduce2[j][1]);\\n            reduce1[i][1]-=mi;\\n            reduce2[j][1]-=mi;\\n            ans+=1ll*mi*min({1ll*reduce1[i][0],1ll*reduce2[j][0],2ll*mn});\\n            if(reduce1[i][1]==0){\\n                i++;\\n            }\\n            if(reduce2[j][1]==0){\\n                j--;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& bas1, vector<int>& bas2) {\\n        map<int,int> mp,mp1,mp2;\\n        int mn=INT_MAX;\\n        for(auto x:bas1){\\n            mp[x]++;\\n            mp1[x]++;\\n            mn=min(mn,x);\\n        }\\n        for(auto x:bas2){\\n            mp[x]++;\\n            mp1[x]--;\\n            mn=min(mn,x);\\n        }\\n        \\n        for(auto x:mp){\\n            if(x.second%2==1){\\n                return -1;\\n            }\\n        }\\n        \\n       vector<vector<int>> reduce1,reduce2;\\n\\n       for(auto x:mp1){\\n           int diff=abs(mp1[x.first]-mp2[x.first])/2;\\n           if(diff!=0){\\n               if(mp1[x.first]>mp2[x.first]){\\n                   reduce1.push_back({x.first,diff});\\n               }\\n               else{\\n                    reduce2.push_back({x.first,diff});\\n               }\\n           }\\n           mp1.erase(x.first);\\n           mp2.erase(x.first);\\n       } \\n\\n        for(auto x:mp2){\\n           int diff=abs(mp1[x.first]-mp2[x.first])/2;\\n           if(diff!=0){\\n               if(mp1[x.first]>mp2[x.first]){\\n                   reduce1.push_back({x.first,diff});\\n               }\\n               else{\\n                    reduce2.push_back({x.first,diff});\\n               }\\n           }\\n       } \\n\\n        sort(reduce1.begin(),reduce1.end());\\n        sort(reduce2.begin(),reduce2.end());\\n        int i=0,j=reduce2.size()-1;\\n        long long ans=0;\\n        while(i<reduce1.size() && j>=0){\\n            int mi=min(reduce1[i][1],reduce2[j][1]);\\n            reduce1[i][1]-=mi;\\n            reduce2[j][1]-=mi;\\n            ans+=1ll*mi*min({1ll*reduce1[i][0],1ll*reduce2[j][0],2ll*mn});\\n            if(reduce1[i][1]==0){\\n                i++;\\n            }\\n            if(reduce2[j][1]==0){\\n                j--;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165777,
                "title": "c-detailed-solution-using-maps-easy-to-understand",
                "content": "# **!! Please upvote if you find this helpful !!**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is to store the frequency of each elements of both arrays in 2 maps: mp1 and mp2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store the frequencies in mp1 and mp2.\\n- Get the minimum element in both arrays and store it as minVal.\\n- Create a vector toSwap that contains the elements to be swapped from both arrays.\\n- Traverse each map separately for every **element** in the map.Store the freq of the **element** as: occ1 = mp1[**element**] and occ2=mp2[**element**]. Get the absolute diff off occ1 and occ2.If the diff is odd return -1 else push the **element** in the toSwap vector **(diff/2)** times. \"Dont forget to make the mp1[**element**] and mp2[**element**] to be 0\"\\n- At last sort the toSwap vector to get the minimum values of swapped elements in front of array.\\n- Traverse the **half toSwap array** and maintain a variable minimum_cost as answer: **minimum_cost+=min(2*minVal,toSwap[i])**.(This is coz for swapping of 2 larger elements like 3<->5 : we would make a swap with minimum element , 1<->3 and then 1<->5 for swapping of 3<-5>...........This way we reduced the cost to 2*minVal(2 in this case) instead of 3 and thus cost is minimized).\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        unordered_map<int,int> mp1;\\n        unordered_map<int,int> mp2;\\n        int minval=b1[0];\\n        for(int i=0;i<b1.size();i++){\\n            mp1[b1[i]]++;\\n            minval=min(minval,b1[i]);            \\n            mp2[b2[i]]++;\\n            minval=min(minval,b2[i]);\\n        }\\n        vector<int>toSwap;\\n\\n        for(auto it:mp1){\\n            int cost=it.first;\\n            int occ1=it.second,occ2=mp2[it.first];\\n\\n            int diff=abs(occ1-occ2);\\n\\n            if(diff%2 == 1)\\n            return -1;\\n\\n            diff=diff/2;\\n            while(diff--){\\n                toSwap.push_back(cost);\\n            }\\n            mp1[cost]=0;//imp so that we do no push in toswap vector in secodn loop\\n            mp2[cost]=0;//imp\\n        }\\n        for(auto it:mp2){\\n            int cost=it.first;\\n            int occ1=mp1[it.first],occ2=it.second;\\n\\n            int diff=abs(occ1-occ2);\\n\\n            if(diff%2 == 1)\\n            return -1;\\n\\n            diff=diff/2;\\n            while(diff--){\\n                toSwap.push_back(cost);\\n            }\\n            mp1[cost]=0;\\n            mp2[cost]=0;\\n        }\\n\\n        sort(toSwap.begin(),toSwap.end());\\n\\n        long long ans=0;\\n\\n        for(int i=0;i<toSwap.size()/2;i++){\\n            ans+=min(2ll*minval,1ll*toSwap[i]); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        unordered_map<int,int> mp1;\\n        unordered_map<int,int> mp2;\\n        int minval=b1[0];\\n        for(int i=0;i<b1.size();i++){\\n            mp1[b1[i]]++;\\n            minval=min(minval,b1[i]);            \\n            mp2[b2[i]]++;\\n            minval=min(minval,b2[i]);\\n        }\\n        vector<int>toSwap;\\n\\n        for(auto it:mp1){\\n            int cost=it.first;\\n            int occ1=it.second,occ2=mp2[it.first];\\n\\n            int diff=abs(occ1-occ2);\\n\\n            if(diff%2 == 1)\\n            return -1;\\n\\n            diff=diff/2;\\n            while(diff--){\\n                toSwap.push_back(cost);\\n            }\\n            mp1[cost]=0;//imp so that we do no push in toswap vector in secodn loop\\n            mp2[cost]=0;//imp\\n        }\\n        for(auto it:mp2){\\n            int cost=it.first;\\n            int occ1=mp1[it.first],occ2=it.second;\\n\\n            int diff=abs(occ1-occ2);\\n\\n            if(diff%2 == 1)\\n            return -1;\\n\\n            diff=diff/2;\\n            while(diff--){\\n                toSwap.push_back(cost);\\n            }\\n            mp1[cost]=0;\\n            mp2[cost]=0;\\n        }\\n\\n        sort(toSwap.begin(),toSwap.end());\\n\\n        long long ans=0;\\n\\n        for(int i=0;i<toSwap.size()/2;i++){\\n            ans+=min(2ll*minval,1ll*toSwap[i]); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164145,
                "title": "15-lines-c-8-lines-py-only-keep-fruits-appear-more-than-half-times-and-swap-all-of-these",
                "content": "For each basket, only fruits appear more than half times of total need to be swapped to the other. For thest fruits we keep `frequency(fruit) - total frequency(fruit) / 2` rest in basket, and drop the rest. for example:\\n\\n[1,3,3,3,3,3,4,4,6,6,8]\\n[1,2,2,3,5,5,7,7,8,9,9]\\n\\nwe only keep:\\n[3,3,4,6]\\n[2,5,7,9]\\n\\nNow we should swap **all** the fruits in those two baskets into the other side.\\n\\nwe have two ways to swap:\\n1. swap smallest in basket1 with largest in basket2, for example:\\n[3,3,4,6]\\n[9,7,5,2]\\nswaps (3,9), (3,7), (4,5), etc\\n\\n2. swap both fruits in basket1 and basket2 with a common smallest fruit, for example if we have a common fruit number 1:\\n[1][3,3,4,6]\\n[1][9,7,5,2]\\nswaps (3,1) (9,1), (3,1),(7,1), etc\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int, int> m1, m2, m3;\\n        for (int i : basket1) ++m1[i], ++m3[i];\\n        for (int i : basket2) ++m2[i], ++m3[i];\\n        int minc = min(m1.begin()->first, m2.begin()->first);\\n        vector<int> a1, a2;  // numbers more than half, in ascending order\\n        for (auto [k, v]: m3) {\\n            if (v & 1) return -1;\\n            for (int i = 0; i < m1[k] - v/2; ++i) a1.push_back(k);\\n            for (int i = 0; i < m2[k] - v/2; ++i) a2.push_back(k);\\n        }\\n        long long ret = 0;\\n        for (int i = 0, n = a1.size(); i < n; ++i) {\\n            // swap smallest number in a1 with largest number in a2, or swap them with smallest in total\\n            ret += min({a1[i], a2[n-1-i], minc*2});\\n        }\\n        return ret;\\n    }\\n};\\n```\\n# Python3\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        d1, d2, d3 = Counter(basket1), Counter(basket2), Counter(basket1 + basket2)\\n        a1, a2 = [], []\\n        for k, v in sorted(d3.items()):\\n            if v&1: return -1\\n            a1.extend([k] * (d1[k] - v//2))\\n            a2.extend([k] * (d2[k] - v//2))\\n        minc = min(d3.keys())\\n        return sum(min(a1[i], a2[len(a2) - 1 - i], minc*2) for i in range(len(a1)))\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int, int> m1, m2, m3;\\n        for (int i : basket1) ++m1[i], ++m3[i];\\n        for (int i : basket2) ++m2[i], ++m3[i];\\n        int minc = min(m1.begin()->first, m2.begin()->first);\\n        vector<int> a1, a2;  // numbers more than half, in ascending order\\n        for (auto [k, v]: m3) {\\n            if (v & 1) return -1;\\n            for (int i = 0; i < m1[k] - v/2; ++i) a1.push_back(k);\\n            for (int i = 0; i < m2[k] - v/2; ++i) a2.push_back(k);\\n        }\\n        long long ret = 0;\\n        for (int i = 0, n = a1.size(); i < n; ++i) {\\n            // swap smallest number in a1 with largest number in a2, or swap them with smallest in total\\n            ret += min({a1[i], a2[n-1-i], minc*2});\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        d1, d2, d3 = Counter(basket1), Counter(basket2), Counter(basket1 + basket2)\\n        a1, a2 = [], []\\n        for k, v in sorted(d3.items()):\\n            if v&1: return -1\\n            a1.extend([k] * (d1[k] - v//2))\\n            a2.extend([k] * (d2[k] - v//2))\\n        minc = min(d3.keys())\\n        return sum(min(a1[i], a2[len(a2) - 1 - i], minc*2) for i in range(len(a1)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163229,
                "title": "python-greedy-solution",
                "content": "Pair the lowest values of one basket with the highest ones of the other, using the smallest value as a currency wherever more cost efficient\\n```\\nclass Solution:\\n  def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n    basket1.sort()\\n    basket2.sort()\\n    \\n    f1 = defaultdict(lambda: 0)\\n    f2 = defaultdict(lambda: 0)\\n    f = defaultdict(lambda: 0)\\n    \\n    for v in basket1:\\n      f1[v] += 1\\n      f[v] += 1\\n      \\n    for v in basket2:\\n      f2[v] += 1\\n      f[v] += 1\\n      \\n    values = [v for v in f]\\n    values.sort()\\n    smallest = values[0]\\n    \\n    one_to_two = []\\n    two_to_one = []\\n    for v in values:\\n      if f[v] % 2 == 1:\\n        return -1\\n      half = f[v] // 2\\n      if half == f1[v]:\\n        continue\\n      if half > f1[v]:  \\n        two_to_one += ([v] * (half - f1[v]))\\n      elif half > f2[v]:\\n        one_to_two += ([v] * (half - f2[v]))\\n        \\n    if len(two_to_one) != len(one_to_two):\\n      return -1\\n    \\n    tot = 0\\n    greedy_pairing = [pr for pr in zip(two_to_one, reversed(one_to_two))]\\n    for pr in greedy_pairing:\\n      min_val = min(pr)\\n      if (2 * smallest) < min_val:\\n        tot += (2 * smallest)\\n      else:\\n        tot += min_val\\n    return tot\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n    basket1.sort()\\n    basket2.sort()\\n    \\n    f1 = defaultdict(lambda: 0)\\n    f2 = defaultdict(lambda: 0)\\n    f = defaultdict(lambda: 0)\\n    \\n    for v in basket1:\\n      f1[v] += 1\\n      f[v] += 1\\n      \\n    for v in basket2:\\n      f2[v] += 1\\n      f[v] += 1\\n      \\n    values = [v for v in f]\\n    values.sort()\\n    smallest = values[0]\\n    \\n    one_to_two = []\\n    two_to_one = []\\n    for v in values:\\n      if f[v] % 2 == 1:\\n        return -1\\n      half = f[v] // 2\\n      if half == f1[v]:\\n        continue\\n      if half > f1[v]:  \\n        two_to_one += ([v] * (half - f1[v]))\\n      elif half > f2[v]:\\n        one_to_two += ([v] * (half - f2[v]))\\n        \\n    if len(two_to_one) != len(one_to_two):\\n      return -1\\n    \\n    tot = 0\\n    greedy_pairing = [pr for pr in zip(two_to_one, reversed(one_to_two))]\\n    for pr in greedy_pairing:\\n      min_val = min(pr)\\n      if (2 * smallest) < min_val:\\n        tot += (2 * smallest)\\n      else:\\n        tot += min_val\\n    return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161421,
                "title": "antarnab-100-faster-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    //public long minCost(int[] basket1, int[] basket2) {\\n            public long minCost(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> count = new TreeMap<>();\\n        for (int a : A)\\n            count.merge(a, 1, Integer::sum);\\n        for (int a : B)\\n            count.merge(a, -1, Integer::sum);\\n        List<Integer> swaps = new ArrayList<>();\\n        long res = 0, small = count.firstKey();\\n        for (int a : count.keySet()) {\\n            if (count.get(a) % 2 > 0) return -1;\\n            int v = Math.abs(count.get(a)) / 2;\\n            for (int i = 0; i < v; ++i)\\n                swaps.add(a);\\n        }\\n        for (int i = 0; i < swaps.size() / 2; ++i)\\n            res += Math.min(swaps.get(i), small * 2);\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //public long minCost(int[] basket1, int[] basket2) {\\n            public long minCost(int[] A, int[] B) {\\n        TreeMap<Integer, Integer> count = new TreeMap<>();\\n        for (int a : A)\\n            count.merge(a, 1, Integer::sum);\\n        for (int a : B)\\n            count.merge(a, -1, Integer::sum);\\n        List<Integer> swaps = new ArrayList<>();\\n        long res = 0, small = count.firstKey();\\n        for (int a : count.keySet()) {\\n            if (count.get(a) % 2 > 0) return -1;\\n            int v = Math.abs(count.get(a)) / 2;\\n            for (int i = 0; i < v; ++i)\\n                swaps.add(a);\\n        }\\n        for (int i = 0; i < swaps.size() / 2; ++i)\\n            res += Math.min(swaps.get(i), small * 2);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160688,
                "title": "a-few-solutions",
                "content": "Use a map `m` as a counter, ie. `+1`, `-1` for each value `a`, `b` of the input arrays `A`, `B` correspondingly.\\n\\nReturn `-1` if any value\\'s frequency is odd, otherwise return the accumulated sum of the minimum of 2 choices:\\n\\n1. we can use the minimum value `lo` as an auxillary to perform `2` swaps for each `i`<sup>th</sup> pair we need to `swap`\\n2. we can swap the min/max pair of values by sorting the values to `swap` and paying the cost of each pair\\'s minimum, ie. the first half of `swap`\\n\\n![image](https://assets.leetcode.com/users/images/82a15f63-a869-4613-8ff3-136fe1cf13b8_1675952129.0728688.png)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minCost(A: IntArray, B: IntArray): Long {\\n        var m = mutableMapOf<Int, Int>()\\n        for ((a, b) in A zip B) {\\n            m[a] = (m[a] ?: 0) + 1\\n            m[b] = (m[b] ?: 0) - 1\\n        }\\n        if (m.any{ (_, cnt) -> cnt % 2 == 1 })\\n            return -1\\n        var (lo, swap) = Pair(Math.min(A.min()!!, B.min()!!).toLong(), m.map{ (x, cnt) -> List(Math.abs(cnt) / 2){ x.toLong() } }.flatten())\\n        return swap.sorted().slice(0 until swap.size / 2).map{ Math.min(2 * lo, it) }.sum()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minCost = (A, B, m = new Map()) => {\\n    for (let [a, b] of _.zip(A, B)) {\\n        m.set(a, (m.get(a) || 0) + 1);\\n        m.set(b, (m.get(b) || 0) - 1);\\n    }\\n    if ([...m].some(([_, cnt]) => cnt & 1))\\n        return -1;\\n    let [lo, swap] = [Math.min(...A, ...B), _.flatten([...m].map(([x, cnt]) => Array(Math.abs(cnt) / 2).fill(x)))];\\n    return _.sum(swap.sort((a, b) => a - b).slice(0, swap.length / 2).map(x => Math.min(2 * lo, x)));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minCost(self, A: List[int], B: List[int]) -> int:\\n        m = Counter()\\n        for a, b in zip(A, B):\\n            m[a] += 1\\n            m[b] -= 1\\n        lo, swap = min(*A, *B), [x for x, cnt in m.items() for _ in range(abs(cnt) // 2)]\\n        return sum(min(2 * lo, x) for x in sorted(swap)[:len(swap) // 2]) if not any(cnt & 1 for cnt in m.values()) else -1\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn min_cost(A: VI, B: VI) -> i64 {\\n        let mut m = HashMap::<&i32, i64>::new();\\n        for (a, b) in A.iter().zip(B.iter()) {\\n            *m.entry(a).or_insert(0) += 1;\\n            *m.entry(b).or_insert(0) -= 1;\\n        }\\n        if m.values().any(|cnt| cnt % 2 == 1) {\\n            return -1;\\n        }\\n        let lo = *min(A.iter().min().unwrap(), B.iter().min().unwrap()) as i64;\\n        let mut swap = m.into_iter().map(|(x, cnt)| vec![x.clone() as i64; (cnt.abs() / 2) as usize]).flatten().collect::<Vec<i64>>();\\n        swap.sort();\\n        swap[..swap.len() / 2].into_iter().map(|x| min(2 * lo, *x)).sum()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    LL minCost(VI& A, VI& B, Map m = {}, VI swap = {}) {\\n        for (auto i{ 0 }; i < A.size(); ++i)\\n            ++m[A[i]], --m[B[i]];\\n        if (any_of(m.begin(), m.end(), [](auto& pair) { return pair.second & 1; }))\\n            return -1;\\n        LL lo = min(*min_element(A.begin(), A.end()),\\n                    *min_element(B.begin(), B.end()));\\n        for (auto [x, cnt]: m)\\n            swap.insert(swap.end(), abs(cnt) / 2, x);\\n        sort(swap.begin(), swap.end());\\n        return accumulate(swap.begin(), swap.begin() + (swap.size() / 2), 0LL, [=](auto t, auto x) { return t + min(2 * lo, LL(x)); });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minCost(A: IntArray, B: IntArray): Long {\\n        var m = mutableMapOf<Int, Int>()\\n        for ((a, b) in A zip B) {\\n            m[a] = (m[a] ?: 0) + 1\\n            m[b] = (m[b] ?: 0) - 1\\n        }\\n        if (m.any{ (_, cnt) -> cnt % 2 == 1 })\\n            return -1\\n        var (lo, swap) = Pair(Math.min(A.min()!!, B.min()!!).toLong(), m.map{ (x, cnt) -> List(Math.abs(cnt) / 2){ x.toLong() } }.flatten())\\n        return swap.sorted().slice(0 until swap.size / 2).map{ Math.min(2 * lo, it) }.sum()\\n    }\\n}\\n```\n```\\nlet minCost = (A, B, m = new Map()) => {\\n    for (let [a, b] of _.zip(A, B)) {\\n        m.set(a, (m.get(a) || 0) + 1);\\n        m.set(b, (m.get(b) || 0) - 1);\\n    }\\n    if ([...m].some(([_, cnt]) => cnt & 1))\\n        return -1;\\n    let [lo, swap] = [Math.min(...A, ...B), _.flatten([...m].map(([x, cnt]) => Array(Math.abs(cnt) / 2).fill(x)))];\\n    return _.sum(swap.sort((a, b) => a - b).slice(0, swap.length / 2).map(x => Math.min(2 * lo, x)));\\n};\\n```\n```\\nclass Solution:\\n    def minCost(self, A: List[int], B: List[int]) -> int:\\n        m = Counter()\\n        for a, b in zip(A, B):\\n            m[a] += 1\\n            m[b] -= 1\\n        lo, swap = min(*A, *B), [x for x, cnt in m.items() for _ in range(abs(cnt) // 2)]\\n        return sum(min(2 * lo, x) for x in sorted(swap)[:len(swap) // 2]) if not any(cnt & 1 for cnt in m.values()) else -1\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::min;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn min_cost(A: VI, B: VI) -> i64 {\\n        let mut m = HashMap::<&i32, i64>::new();\\n        for (a, b) in A.iter().zip(B.iter()) {\\n            *m.entry(a).or_insert(0) += 1;\\n            *m.entry(b).or_insert(0) -= 1;\\n        }\\n        if m.values().any(|cnt| cnt % 2 == 1) {\\n            return -1;\\n        }\\n        let lo = *min(A.iter().min().unwrap(), B.iter().min().unwrap()) as i64;\\n        let mut swap = m.into_iter().map(|(x, cnt)| vec![x.clone() as i64; (cnt.abs() / 2) as usize]).flatten().collect::<Vec<i64>>();\\n        swap.sort();\\n        swap[..swap.len() / 2].into_iter().map(|x| min(2 * lo, *x)).sum()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    LL minCost(VI& A, VI& B, Map m = {}, VI swap = {}) {\\n        for (auto i{ 0 }; i < A.size(); ++i)\\n            ++m[A[i]], --m[B[i]];\\n        if (any_of(m.begin(), m.end(), [](auto& pair) { return pair.second & 1; }))\\n            return -1;\\n        LL lo = min(*min_element(A.begin(), A.end()),\\n                    *min_element(B.begin(), B.end()));\\n        for (auto [x, cnt]: m)\\n            swap.insert(swap.end(), abs(cnt) / 2, x);\\n        sort(swap.begin(), swap.end());\\n        return accumulate(swap.begin(), swap.begin() + (swap.size() / 2), 0LL, [=](auto t, auto x) { return t + min(2 * lo, LL(x)); });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160312,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn log(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\npublic:\\n    long long minCost(vector<int >& basket1, vector<int>& basket2) {\\n            \\n            long long a,i;\\n            map<long long,long long>ma;\\n            long long mn =  1e9+10;\\n            long long ans = 0;\\n            for(i = 0 ; i < basket1.size() ; i++) {\\n                    ma[basket1[i]]++;\\n                    if( mn > basket1[i]) {\\n                    mn = basket1[i];\\n                            \\n                    }\\n            }\\n            for(i = 0 ; i < basket2.size() ; i++) {\\n                    ma[basket2[i]]--;\\n                    if(mn > basket2[i]) {\\n                    mn = basket2[i];\\n                    }\\n            }\\n        vector<long long >vec;\\n            for(auto u : ma) {\\n                    if(abs(u.second) %2 ==1 ) {\\n                            return -1;\\n                    }\\n                    if(abs(u.second) != 0) {\\n                            \\n                            for( i = 0 ; i < abs(u.second)/2 ; i++){\\n                            vec.push_back(u.first);}\\n                    }\\n            }\\n            sort(vec.begin() ,vec.end());\\n            for(i = 0 ;i < vec.size()/2 ; i++) {\\n                    \\n                    if(2*mn < vec[i]) {\\n                            \\n                    ans += (2*mn) ;}\\n                    else{\\n                            ans+=vec[i];\\n                    }\\n                    \\n            }\\n            return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    long long minCost(vector<int >& basket1, vector<int>& basket2) {\\n            \\n            long long a,i;\\n            map<long long,long long>ma;\\n            long long mn =  1e9+10;\\n            long long ans = 0;\\n            for(i = 0 ; i < basket1.size() ; i++) {\\n                    ma[basket1[i]]++;\\n                    if( mn > basket1[i]) {\\n                    mn = basket1[i];\\n                            \\n                    }\\n            }\\n            for(i = 0 ; i < basket2.size() ; i++) {\\n                    ma[basket2[i]]--;\\n                    if(mn > basket2[i]) {\\n                    mn = basket2[i];\\n                    }\\n            }\\n        vector<long long >vec;\\n            for(auto u : ma) {\\n                    if(abs(u.second) %2 ==1 ) {\\n                            return -1;\\n                    }\\n                    if(abs(u.second) != 0) {\\n                            \\n                            for( i = 0 ; i < abs(u.second)/2 ; i++){\\n                            vec.push_back(u.first);}\\n                    }\\n            }\\n            sort(vec.begin() ,vec.end());\\n            for(i = 0 ;i < vec.size()/2 ; i++) {\\n                    \\n                    if(2*mn < vec[i]) {\\n                            \\n                    ans += (2*mn) ;}\\n                    else{\\n                            ans+=vec[i];\\n                    }\\n                    \\n            }\\n            return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159294,
                "title": "python3-o-nlogn-count-sort-and-accumulate",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is easy to find that if we want the 2 baskets equal, every number must have even occurence. We use *cnt* to check the aforementioned condition. Then we get all numbers needed to swap in 2 baskets and sort the array *swp*. All we need is to process the first half of *swp*, there are two case:\\n(1) if the cost is bigger than min values in all baskets, we can do swap this value and any number from second half of *swp* with min values as intermediary value two times, so the cost is 2 * minv. \\n(2) Otherwise, swap this value and any number from second half with cost v. \\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        cnt1, cnt2 = Counter(basket1), Counter(basket2)\\n        cnt = cnt1 + cnt2\\n        if any(v & 1 for v in cnt.values()): return -1\\n        swp, minv = [], float(\\'inf\\')\\n        for k, v in cnt.items():\\n            minv = min(minv, k)\\n            if cnt1[k] == v // 2: continue\\n            elif cnt1[k] > v // 2: swp += [k] * (cnt1[k] - v // 2)\\n            else: swp += [k] * (cnt2[k] - v // 2)\\n        return sum(min(minv * 2, v) for v in sorted(swp)[:len(swp) // 2])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        cnt1, cnt2 = Counter(basket1), Counter(basket2)\\n        cnt = cnt1 + cnt2\\n        if any(v & 1 for v in cnt.values()): return -1\\n        swp, minv = [], float(\\'inf\\')\\n        for k, v in cnt.items():\\n            minv = min(minv, k)\\n            if cnt1[k] == v // 2: continue\\n            elif cnt1[k] > v // 2: swp += [k] * (cnt1[k] - v // 2)\\n            else: swp += [k] * (cnt2[k] - v // 2)\\n        return sum(min(minv * 2, v) for v in sorted(swp)[:len(swp) // 2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158991,
                "title": "c-ordered-map-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2)\\n    {\\n        map<int,int> mp;\\n        for(auto &b:basket1)\\n        {\\n            mp[b]++;\\n        }\\n        for(auto&b:basket2)\\n        {\\n            mp[b]--;\\n        }\\n        long long ans=0,small=begin(mp)->first;\\n        vector<long long > v;\\n        for(auto &[a,cnt]:mp)\\n        {\\n            if(cnt%2)\\n                return -1;\\n            for(int i=0;i<abs(cnt)/2;i++)\\n            {\\n                v.push_back(a);\\n            }\\n        }\\n        for(int i=0;i<(v.size())/2;i++)\\n        {\\n            ans+=min(v[i],small*2);   \\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2)\\n    {\\n        map<int,int> mp;\\n        for(auto &b:basket1)\\n        {\\n            mp[b]++;\\n        }\\n        for(auto&b:basket2)\\n        {\\n            mp[b]--;\\n        }\\n        long long ans=0,small=begin(mp)->first;\\n        vector<long long > v;\\n        for(auto &[a,cnt]:mp)\\n        {\\n            if(cnt%2)\\n                return -1;\\n            for(int i=0;i<abs(cnt)/2;i++)\\n            {\\n                v.push_back(a);\\n            }\\n        }\\n        for(int i=0;i<(v.size())/2;i++)\\n        {\\n            ans+=min(v[i],small*2);   \\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158028,
                "title": "python-with-explanation",
                "content": "# Intuition\\nFirst impression is we need two maps to count the frequency, and then we need to check if there is a odd number of total count of two maps. If yes, there is no solution. Then we should focus on the even number of total counts. \\nConsider we have two arrs [1,6,6] [7,7,1]\\nWe have two ways of swap:\\n1. We can swap 1 with 7 and then swap 1, with 6 -> [7,6,6] [1,7,1] ->[7,6,1][6,7,1] total cost would be min(1,7) + min(1,6) = 2 *1 = 2\\n2. We can swap 6, 7 together total cost would be min(6,7) = 6\\n\\nSo how do we compare the better solution?\\n\\n\\n# Approach\\nFirst we need to define the numbers with need to swap, in this case in 6, 7.\\nTo find the numbers we need to swap, we can get a counter of total of two maps, and check the diff with minimum of frequences in either map. For this example, from [1,1,6,6,7,7]  We know we just need [1,6,7] as final, then we - min of 1, 6, 7 from each map. So to be swapped map would be [6,7]\\n\\nThen We just need to compare 2 *min of (1,6,7) with 6\\n\\nWhat does that mean, means we need compare if we want to swap the minmum for twice or directly swap the to be swapped pairs.\\nWe don\\'t have to compare second half of arr of to be swapped since anyway they can swapped with smaller number in first half.\\n\\nUse another exmaple to visualize\\n\\n[3,4,5,5,7,7,9,9][3,4,6,6,10,10,10,10]-> to be swapped\\n[5,6,7,9,10,10]\\nres would be \\n5 +6 +6 = 17\\n\\n\\n# Complexity\\n- Time complexity:\\nnlog(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minCost(self, b1: List[int], b2: List[int]) -> int:\\n        \"\"\"\\n        to check if its possible and how many steps to make them same, we need to get a Counter of both baskets\\n        To make it works, we need to make sure both have same lengt\\n        \"\"\"\\n        c1, c2 = Counter(b1), Counter(b2)\\n        tc = c1 + c2\\n        arr = []\\n        for key, value in sorted(tc.items()):\\n            if value % 2 == 1:\\n                return -1\\n            \\n            arr.extend((value//2 - min(c1[key], c2[key])) *[key])\\n        minswap = min(tc.keys()) * 2\\n        res = 0\\n        for a in arr[:len(arr)//2]:\\n            res += min(minswap, a)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minCost(self, b1: List[int], b2: List[int]) -> int:\\n        \"\"\"\\n        to check if its possible and how many steps to make them same, we need to get a Counter of both baskets\\n        To make it works, we need to make sure both have same lengt\\n        \"\"\"\\n        c1, c2 = Counter(b1), Counter(b2)\\n        tc = c1 + c2\\n        arr = []\\n        for key, value in sorted(tc.items()):\\n            if value % 2 == 1:\\n                return -1\\n            \\n            arr.extend((value//2 - min(c1[key], c2[key])) *[key])\\n        minswap = min(tc.keys()) * 2\\n        res = 0\\n        for a in arr[:len(arr)//2]:\\n            res += min(minswap, a)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157152,
                "title": "easy-understandable-simple-solution-c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int,int> mp1,mp2;\\n        int mn = INT_MAX;\\n        set<int> st;\\n        for(auto it : basket1)\\n        {\\n            mn = min(mn,it);\\n            mp1[it]++;\\n            st.insert(it);\\n        }\\n        \\n        for(auto it : basket2)\\n        {\\n            mn = min(mn,it);\\n            mp2[it]++;\\n            st.insert(it);\\n        }\\n        \\n        \\n        vector<int> swap;\\n        for(auto it : st)\\n        {\\n            if((mp1[it]+mp2[it])%2)\\n            {\\n                return -1;\\n            }else{\\n                int diff = abs(mp1[it]-mp2[it]);\\n                diff /= 2;\\n                while(diff--)\\n                {\\n                    swap.push_back(it);\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        sort(swap.begin(),swap.end());\\n        for(int i=0;i<swap.size()/2;i++)\\n        {\\n            ans += min(2*mn,swap[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<int,int> mp1,mp2;\\n        int mn = INT_MAX;\\n        set<int> st;\\n        for(auto it : basket1)\\n        {\\n            mn = min(mn,it);\\n            mp1[it]++;\\n            st.insert(it);\\n        }\\n        \\n        for(auto it : basket2)\\n        {\\n            mn = min(mn,it);\\n            mp2[it]++;\\n            st.insert(it);\\n        }\\n        \\n        \\n        vector<int> swap;\\n        for(auto it : st)\\n        {\\n            if((mp1[it]+mp2[it])%2)\\n            {\\n                return -1;\\n            }else{\\n                int diff = abs(mp1[it]-mp2[it]);\\n                diff /= 2;\\n                while(diff--)\\n                {\\n                    swap.push_back(it);\\n                }\\n            }\\n        }\\n        \\n        long long ans = 0;\\n        sort(swap.begin(),swap.end());\\n        for(int i=0;i<swap.size()/2;i++)\\n        {\\n            ans += min(2*mn,swap[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155677,
                "title": "python-simple-python-solution-using-hashmap-95-faster",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 806 ms, faster than 95.48% of Python3 online submissions for Rearranging Fruits.\\n# Memory Usage: 36.9 MB, less than 86.45% of Python3 online submissions for Rearranging Fruits.\\n\\n![image](https://assets.leetcode.com/users/images/1185c379-629a-4ee2-9dd6-ee94cf76d8b2_1675773319.5963256.png)\\n\\n\\tclass Solution:\\n\\t\\tdef minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n\\n\\t\\t\\tfruit_count = defaultdict(int)\\n\\t\\t\\tmin_fruit_cost = min(min(basket1), min(basket2))\\n\\t\\t\\tfruit_swap = []\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor fruit in basket1:\\n\\t\\t\\t\\tfruit_count[fruit] = fruit_count[fruit] + 1\\n\\n\\t\\t\\tfor fruit in basket2:\\n\\t\\t\\t\\tfruit_count[fruit] = fruit_count[fruit] - 1\\n\\n\\t\\t\\tfor key in fruit_count:\\n\\n\\t\\t\\t\\tif fruit_count[key] % 2 != 0:\\n\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\tfor _ in range(abs(fruit_count[key]) // 2):\\n\\t\\t\\t\\t\\tfruit_swap.append(key)\\n\\n\\t\\t\\tfruit_swap = sorted(fruit_swap)\\n\\n\\t\\t\\tfor index in range(len(fruit_swap) // 2):\\n\\t\\t\\t\\tresult = result + min(min_fruit_cost * 2, fruit_swap[index])\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 806 ms, faster than 95.48% of Python3 online submissions for Rearranging Fruits.\\n# Memory Usage: 36.9 MB, less than 86.45% of Python3 online submissions for Rearranging Fruits.\\n\\n![image](https://assets.leetcode.com/users/images/1185c379-629a-4ee2-9dd6-ee94cf76d8b2_1675773319.5963256.png)\\n\\n\\tclass Solution:\\n\\t\\tdef minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n\\n\\t\\t\\tfruit_count = defaultdict(int)\\n\\t\\t\\tmin_fruit_cost = min(min(basket1), min(basket2))\\n\\t\\t\\tfruit_swap = []\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor fruit in basket1:\\n\\t\\t\\t\\tfruit_count[fruit] = fruit_count[fruit] + 1\\n\\n\\t\\t\\tfor fruit in basket2:\\n\\t\\t\\t\\tfruit_count[fruit] = fruit_count[fruit] - 1\\n\\n\\t\\t\\tfor key in fruit_count:\\n\\n\\t\\t\\t\\tif fruit_count[key] % 2 != 0:\\n\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\tfor _ in range(abs(fruit_count[key]) // 2):\\n\\t\\t\\t\\t\\tfruit_swap.append(key)\\n\\n\\t\\t\\tfruit_swap = sorted(fruit_swap)\\n\\n\\t\\t\\tfor index in range(len(fruit_swap) // 2):\\n\\t\\t\\t\\tresult = result + min(min_fruit_cost * 2, fruit_swap[index])\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 3154520,
                "title": "java-concise-soltuion-easy-to-understand",
                "content": "class Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        HashMap < Integer , Integer > map1=new HashMap<>();        \\n        HashMap < Integer , Integer > map2=new HashMap<>();\\n        ArrayList<Integer> a =new ArrayList<>();\\n        \\n        //Tree Set to get all the values with distint frequencies\\n        TreeSet<Integer>set=new TreeSet<>();\\n        long sum=0;\\n                \\n        //count the frequency  the elements in both the arrays\\n        for(int i=0;i<basket1.length;i++){\\n            map1.put(basket1[i],map1.getOrDefault(basket1[i],0)+1);\\n            map2.put(basket2[i],map2.getOrDefault(basket2[i],0)+1);\\n        }\\n        \\n        for(int i=0;i<basket1.length;i++)\\n            set.add(basket1[i]);\\n        for(int j=0;j<basket2.length;j++)\\n            set.add(basket2[j]);\\n        \\n        //if off number of frequencies are present return -1\\n        for(int i:set){\\n            if((map1.getOrDefault(i,0)+map2.getOrDefault(i,0))%2!=0)\\n                return -1;\\n             if(map1.getOrDefault(i,0)!=map2.getOrDefault(i,0)){\\n\\t\\t\\t \\n                  for(int j=0;j<Math.abs(map1.getOrDefault(i,0)-map2.getOrDefault(i,0))/2;j++)\\n                 a.add(i);\\n\\t\\t\\t\\n             }   \\n        }\\n        \\n        //There can be two ways to swap \\n        //Either multiply the element with the miimum number\\n        //OR\\n        //Add the number itself\\n        \\n        int min=set.first();\\n        for(int i=0;i<a.size()/2;i++){\\n        sum+=Math.min(a.get(i),2*min);\\n        }\\n        return sum;\\n     }\\n}",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "class Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        HashMap < Integer , Integer > map1=new HashMap<>();        \\n        HashMap < Integer , Integer > map2=new HashMap<>();\\n        ArrayList<Integer> a =new ArrayList<>();\\n        \\n        //Tree Set to get all the values with distint frequencies\\n        TreeSet<Integer>set=new TreeSet<>();\\n        long sum=0;\\n                \\n        //count the frequency  the elements in both the arrays\\n        for(int i=0;i<basket1.length;i++){\\n            map1.put(basket1[i],map1.getOrDefault(basket1[i],0)+1);\\n            map2.put(basket2[i],map2.getOrDefault(basket2[i],0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3154202,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) \\n    {\\n        \\n   \\n        unordered_map<long long,long long>m,l,o;\\n        vector<pair<long long,long long>>v1,v2;\\n        int mi=INT_MAX;\\n        for(int i=0;i<b1.size();i++)\\n        {\\n            m[b1[i]]++;\\n            l[b1[i]]++;\\n            mi=min(mi,b1[i]);\\n        }\\n         for(int i=0;i<b2.size();i++)\\n        {\\n            m[b2[i]]++;\\n             o[b2[i]]++;\\n             mi=min(mi,b2[i]);\\n        }\\n        \\n        for(auto a: m)\\n        {\\n            if(a.second%2!=0)\\n                return -1;\\n        }\\n        for(auto a : l)\\n        {\\n            int l2=0;\\n            int p=a.first;\\n            if(o.find(p)!=o.end())\\n                l2=o[p];\\n            if(a.second>l2)\\n            {\\n                v1.push_back({a.first,(a.second-l2)/2});\\n            }\\n        }\\n        for(auto a : o)\\n        {\\n            int l2=0;\\n            if(l.find(a.first)!=l.end())\\n                l2=l[a.first];\\n            if(a.second>l2)\\n            {\\n                v2.push_back({a.first,(a.second-l2)/2});\\n            }\\n        }\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        \\n        int i=0,j=v2.size()-1;\\n        long long s=0;\\n        while(i<v1.size() && j>-1)\\n        {\\n           // cout<<v1[i].first<<\" \"<<v2[j].first<<endl;\\n            if(v1[i].second<v2[j].second)\\n            {\\n                \\n                s=s+min(((long long)mi)*2*(v1[i].second),(long long)min(v2[j].first,v1[i].first)*((long long)(v1[i].second)));\\n                v2[j].second-=v1[i].second;\\n                i++;\\n            }\\n            else if(v1[i].second==v2[j].second)\\n            {\\n               s=s+min(((long long)mi)*2*(v1[i].second),(long long)min(v2[j].first,v1[i].first)*(v1[i].second));\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                s=s+min(((long long)mi)*2*(v2[j].second),(long long)min(v2[j].first,v1[i].first)*(v2[j].second));\\n                v1[i].second-=v2[j].second;\\n                j--;\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) \\n    {\\n        \\n   \\n        unordered_map<long long,long long>m,l,o;\\n        vector<pair<long long,long long>>v1,v2;\\n        int mi=INT_MAX;\\n        for(int i=0;i<b1.size();i++)\\n        {\\n            m[b1[i]]++;\\n            l[b1[i]]++;\\n            mi=min(mi,b1[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3154134,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `basket1`\\n */\\nclass Solution {\\n public:\\n  long long minCost(const vector<int> &basket1, const vector<int> &basket2) {\\n    const int n = static_cast<int>(basket1.size());\\n    unordered_map<int, int> distinct_fruit_to_count;\\n    for (int i = 0; i < n; ++i) {\\n      ++distinct_fruit_to_count[basket1[i]];\\n      --distinct_fruit_to_count[basket2[i]];\\n    }\\n    \\n    vector<int> fruits;\\n    int min_cost = numeric_limits<int>::max();\\n    for (const auto [fruit, count] : distinct_fruit_to_count) {\\n      if (count % 2 == 1) {\\n        return -1LL;\\n      }\\n      for (int i = 0; i < abs(count) / 2; ++i) {\\n        fruits.emplace_back(fruit);\\n      }\\n      min_cost = min(min_cost, fruit);\\n    }\\n    \\n    nth_element(fruits.begin(), fruits.begin() + fruits.size() / 2, fruits.end());\\n    long long ret = 0LL;\\n    for (size_t i = 0; i < fruits.size() / 2; ++i) {\\n      ret += min(fruits[i], 2 * min_cost);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `basket1`\\n */\\nclass Solution {\\n public:\\n  long long minCost(const vector<int> &basket1, const vector<int> &basket2) {\\n    const int n = static_cast<int>(basket1.size());\\n    unordered_map<int, int> distinct_fruit_to_count;\\n    for (int i = 0; i < n; ++i) {\\n      ++distinct_fruit_to_count[basket1[i]];\\n      --distinct_fruit_to_count[basket2[i]];\\n    }\\n    \\n    vector<int> fruits;\\n    int min_cost = numeric_limits<int>::max();\\n    for (const auto [fruit, count] : distinct_fruit_to_count) {\\n      if (count % 2 == 1) {\\n        return -1LL;\\n      }\\n      for (int i = 0; i < abs(count) / 2; ++i) {\\n        fruits.emplace_back(fruit);\\n      }\\n      min_cost = min(min_cost, fruit);\\n    }\\n    \\n    nth_element(fruits.begin(), fruits.begin() + fruits.size() / 2, fruits.end());\\n    long long ret = 0LL;\\n    for (size_t i = 0; i < fruits.size() / 2; ++i) {\\n      ret += min(fruits[i], 2 * min_cost);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152484,
                "title": "swift-solution-using-dictionary",
                "content": "Swift solution based on \\nhttps://leetcode.com/problems/rearranging-fruits/solutions/3143735/ordered-map/\\n\\n# Code\\n```\\nclass Solution {\\n    func minCost(_ b1: [Int], _ b2: [Int]) -> Int {\\n        var m: [Int: Int] = [:]\\n        for c in b1 {\\n            m[c, default: 0] += 1\\n        }\\n        \\n        for c in b2 {\\n            m[c, default: 0] -= 1\\n        }\\n        \\n        var swaps = 0, res = 0\\n        \\n        for (c, cnt) in m {\\n            if cnt % 2 == 1 {\\n                return -1\\n            }\\n            swaps += max(0, cnt / 2)\\n        }\\n        \\n        let m1 = m.sorted(by: { $0.key < $1.key })\\n        \\n        for (c, cnt) in m1 {\\n            let take = min(swaps, abs(cnt) / 2)\\n            res += take * min(c, m1.first!.key * 2)\\n            swaps -= take\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minCost(_ b1: [Int], _ b2: [Int]) -> Int {\\n        var m: [Int: Int] = [:]\\n        for c in b1 {\\n            m[c, default: 0] += 1\\n        }\\n        \\n        for c in b2 {\\n            m[c, default: 0] -= 1\\n        }\\n        \\n        var swaps = 0, res = 0\\n        \\n        for (c, cnt) in m {\\n            if cnt % 2 == 1 {\\n                return -1\\n            }\\n            swaps += max(0, cnt / 2)\\n        }\\n        \\n        let m1 = m.sorted(by: { $0.key < $1.key })\\n        \\n        for (c, cnt) in m1 {\\n            let take = min(swaps, abs(cnt) / 2)\\n            res += take * min(c, m1.first!.key * 2)\\n            swaps -= take\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152472,
                "title": "easy-solution-in-c-hashmap",
                "content": "# Complexity\\n- Time complexity:\\n**O(nlogn)**\\n\\n- Space complexity:\\n**O(n)**\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n=basket2.size(),mini=INT_MAX;\\n        map<int,int> mp1,mp2;\\n        for(int i=0;i<n;i++){\\n            mp1[basket1[i]]++;\\n            mp2[basket2[i]]++;\\n            mini=min(mini,min(basket1[i],basket2[i]));   //mini storing the min element out of both the arrays\\n        }\\n        vector<int> v1,v2;\\n        for(auto it:mp1){   \\n            int x=it.first;\\n            if(mp1[x]>mp2[x]){\\n                int diff=mp1[x]-mp2[x];\\n                if((diff & 1)==0){   //even condition check\\n                    for(int i=0;i<diff/2;i++)\\n                        v1.push_back(x);\\n                }\\n                else\\n                    return -1;\\n            }\\n        }\\n        for(auto it:mp2){   \\n            int x=it.first;\\n            if(mp2[x]>mp1[x]){\\n                int diff=mp2[x]-mp1[x];\\n                if((diff & 1)==0){\\n                    for(int i=0;i<diff/2;i++)\\n                        v2.push_back(x);\\n                }\\n                else\\n                    return -1;\\n            }\\n        }\\n        long minCost=0;\\n        for(int i=0;i<v1.size();i++)\\n            minCost+=min(min(v1[i],v2[v1.size()-i-1]),2*mini);\\n        return minCost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n=basket2.size(),mini=INT_MAX;\\n        map<int,int> mp1,mp2;\\n        for(int i=0;i<n;i++){\\n            mp1[basket1[i]]++;\\n            mp2[basket2[i]]++;\\n            mini=min(mini,min(basket1[i],basket2[i]));   //mini storing the min element out of both the arrays\\n        }\\n        vector<int> v1,v2;\\n        for(auto it:mp1){   \\n            int x=it.first;\\n            if(mp1[x]>mp2[x]){\\n                int diff=mp1[x]-mp2[x];\\n                if((diff & 1)==0){   //even condition check\\n                    for(int i=0;i<diff/2;i++)\\n                        v1.push_back(x);\\n                }\\n                else\\n                    return -1;\\n            }\\n        }\\n        for(auto it:mp2){   \\n            int x=it.first;\\n            if(mp2[x]>mp1[x]){\\n                int diff=mp2[x]-mp1[x];\\n                if((diff & 1)==0){\\n                    for(int i=0;i<diff/2;i++)\\n                        v2.push_back(x);\\n                }\\n                else\\n                    return -1;\\n            }\\n        }\\n        long minCost=0;\\n        for(int i=0;i<v1.size();i++)\\n            minCost+=min(min(v1[i],v2[v1.size()-i-1]),2*mini);\\n        return minCost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150889,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nIn this question we have to rearrage the element in the two arrays such that they both become equal with minimum cost.\\n\\nOnce we see the question we can say that if the element which have odd frequency so it cant be divided equally so ans for this case is -1. \\n\\nFor solving this problem we can think of something like using a map and store the frequency of the elements and then we can use the frequency to get which element to swap or which element not.\\n\\nAnd there is two ways which you swap by swapping with the element which is smaller than the two indexes or we can swap double with the minimum element and the ans is minimum of both the cases.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n- First declare an unorodered map and increment the frequency of first array and decrement the frequency of elements in second array. We get the difference of frequencies of an element in two array by this.\\n- If the freq of that element is odd in the map its not possible to rearrage and return -1.\\n- When we find any other frequencies we have to maintain a vector which stores all the element which need to rearranged.\\n- The number of swaps we do is the half the number of frequencies they are found so we store the elements half times in toSwap vector.\\n- Sort the vector in ascending order.\\n- And after it we calculate the cost by considering the first half elements as cost = min(basket1[i], basket2[j]) and swapping with the smallest element and the answer will be the minmum of both the cases.\\n- Problem solved \\u270C\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n = basket1.size();\\n        \\n        int minEle = 1e9;\\n        \\n        unordered_map<int, int> freq;\\n        \\n        for(int i = 0; i < n; i++){\\n            freq[basket1[i]]++;\\n            freq[basket2[i]]--;\\n            \\n            minEle = min(minEle, min(basket1[i], basket2[i]));\\n        }\\n        \\n        vector <int> toSwap;\\n        \\n        for(auto &[u, v] : freq){\\n            if(abs(v) % 2 == 1) return -1;\\n            \\n            for(int i = 0; i < abs(v)/2 ; i++){\\n                toSwap.push_back(u);\\n            }  \\n        }\\n        \\n        sort(toSwap.begin(), toSwap.end());\\n        \\n        long long ans = 0;\\n        \\n        for(int i = 0; i < toSwap.size()/2; i++){\\n            ans += min(2ll*minEle, 1ll*toSwap[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n = basket1.size();\\n        \\n        int minEle = 1e9;\\n        \\n        unordered_map<int, int> freq;\\n        \\n        for(int i = 0; i < n; i++){\\n            freq[basket1[i]]++;\\n            freq[basket2[i]]--;\\n            \\n            minEle = min(minEle, min(basket1[i], basket2[i]));\\n        }\\n        \\n        vector <int> toSwap;\\n        \\n        for(auto &[u, v] : freq){\\n            if(abs(v) % 2 == 1) return -1;\\n            \\n            for(int i = 0; i < abs(v)/2 ; i++){\\n                toSwap.push_back(u);\\n            }  \\n        }\\n        \\n        sort(toSwap.begin(), toSwap.end());\\n        \\n        long long ans = 0;\\n        \\n        for(int i = 0; i < toSwap.size()/2; i++){\\n            ans += min(2ll*minEle, 1ll*toSwap[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150693,
                "title": "java-treemap-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be solved by storing values of both arrays in arraylist and sorting it on further.Now finally diving them into two equal parts. \\nBut the above approach is navie and it takes so much time. Now using treemap and stroing the element and frequency which look the above problem easy.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We store the frequency of each element in a treemap.\\n2. We iterate over the treemap and add the elements to an arraylist.\\n3. We sort the arraylist.\\n4. We iterate over the arraylist and add the minimum of the element and 2*min to the answer.\\n\\n# Complexity\\n- Time complexity:O(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public long minCost(int[] a, int[] b) \\n    {\\n        TreeMap<Integer,Integer> m=new TreeMap<>();\\n        for(int i:a)\\n            m.put(i,m.getOrDefault(i,0)+1);\\n        for(int i:b)\\n            m.put(i,m.getOrDefault(i,0)-1);\\n        System.out.println(m);\\n        ArrayList<Integer> l=new ArrayList<>();\\n        long min=m.firstKey();\\n        for(Map.Entry<Integer,Integer> e:m.entrySet())\\n        {\\n            int x=Math.abs(e.getValue());\\n            if(x%2==1)\\n                return -1;\\n            for(int i=x;i>0;i=i-2)\\n                l.add(e.getKey());\\n        }\\n        long s=0;\\n        System.out.println(l);\\n        \\n        for(int i=0;i<l.size()/2;i++)\\n            s+=Math.min(l.get(i),2*min);\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution \\n{\\n    public long minCost(int[] a, int[] b) \\n    {\\n        TreeMap<Integer,Integer> m=new TreeMap<>();\\n        for(int i:a)\\n            m.put(i,m.getOrDefault(i,0)+1);\\n        for(int i:b)\\n            m.put(i,m.getOrDefault(i,0)-1);\\n        System.out.println(m);\\n        ArrayList<Integer> l=new ArrayList<>();\\n        long min=m.firstKey();\\n        for(Map.Entry<Integer,Integer> e:m.entrySet())\\n        {\\n            int x=Math.abs(e.getValue());\\n            if(x%2==1)\\n                return -1;\\n            for(int i=x;i>0;i=i-2)\\n                l.add(e.getKey());\\n        }\\n        long s=0;\\n        System.out.println(l);\\n        \\n        for(int i=0;i<l.size()/2;i++)\\n            s+=Math.min(l.get(i),2*min);\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150674,
                "title": "c-solution",
                "content": "swaping the smallest number 2 times may result in less cost\\n\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n     map<long long,long long> mp;\\n        int mi=INT_MAX;\\n        for(long long i=0;i<basket1.size();i++)\\n        {\\n            mi=min(mi,basket1[i]);\\n            mi=min(mi,basket2[i]);\\n            \\n            mp[basket1[i]]++;\\n             mp[basket2[i]]--;\\n        }\\n        \\n        vector<long long> vec;\\n        for(auto it:mp)\\n        {\\n            if(abs(it.second)%2==1)\\n                return -1;\\n            for(long long i=0;i<abs(it.second)/2;i++)\\n                vec.push_back(it.first);\\n                \\n        }\\n        sort(vec.begin(),vec.end());\\n        long long ans=0;\\n        for(long long i=0;i<vec.size()/2;i++)\\n        {\\n            ans+=min(2*mi*1ll,vec[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n     map<long long,long long> mp;\\n        int mi=INT_MAX;\\n        for(long long i=0;i<basket1.size();i++)\\n        {\\n            mi=min(mi,basket1[i]);\\n            mi=min(mi,basket2[i]);\\n            \\n            mp[basket1[i]]++;\\n             mp[basket2[i]]--;\\n        }\\n        \\n        vector<long long> vec;\\n        for(auto it:mp)\\n        {\\n            if(abs(it.second)%2==1)\\n                return -1;\\n            for(long long i=0;i<abs(it.second)/2;i++)\\n                vec.push_back(it.first);\\n                \\n        }\\n        sort(vec.begin(),vec.end());\\n        long long ans=0;\\n        for(long long i=0;i<vec.size()/2;i++)\\n        {\\n            ans+=min(2*mi*1ll,vec[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149618,
                "title": "python-greedy-o-nlogn",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        counter = Counter(basket1) + Counter(basket2)\\n        for k in counter:\\n            if counter[k]%2: return -1\\n            counter[k] //= 2\\n        counter1 = Counter(basket1)\\n        opt = min(counter.keys())\\n        b1, b2 = [], []\\n        for k in counter:\\n            if counter[k] - counter1[k]>0:\\n                b1.extend([k]*(counter[k] - counter1[k]))\\n            else:\\n                b2.extend([k]*(counter1[k] - counter[k]))\\n        b1.sort()\\n        b2.sort(reverse = True)\\n        res = 0\\n        for x,y in zip(b1,b2):\\n            res += min(min(x,y), 2*opt)\\n        return res\\n            \\n        \\n                \\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        counter = Counter(basket1) + Counter(basket2)\\n        for k in counter:\\n            if counter[k]%2: return -1\\n            counter[k] //= 2\\n        counter1 = Counter(basket1)\\n        opt = min(counter.keys())\\n        b1, b2 = [], []\\n        for k in counter:\\n            if counter[k] - counter1[k]>0:\\n                b1.extend([k]*(counter[k] - counter1[k]))\\n            else:\\n                b2.extend([k]*(counter1[k] - counter[k]))\\n        b1.sort()\\n        b2.sort(reverse = True)\\n        res = 0\\n        for x,y in zip(b1,b2):\\n            res += min(min(x,y), 2*opt)\\n        return res\\n            \\n        \\n                \\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148822,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, A: List[int], B: List[int]) -> int:\\n        count = Counter(A + B)\\n        for c in count:\\n            if count[c] % 2:\\n                return -1\\n            count[c] >>= 1\\n        A2 = list((Counter(A) - count).elements())\\n        B2 = list((Counter(B) - count).elements())\\n        small = min(count)\\n        C = sorted(A2 + B2)\\n        return sum(min(small * 2, C[i]) for i in range(len(A2)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, A: List[int], B: List[int]) -> int:\\n        count = Counter(A + B)\\n        for c in count:\\n            if count[c] % 2:\\n                return -1\\n            count[c] >>= 1\\n        A2 = list((Counter(A) - count).elements())\\n        B2 = list((Counter(B) - count).elements())\\n        small = min(count)\\n        C = sorted(A2 + B2)\\n        return sum(min(small * 2, C[i]) for i in range(len(A2)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148791,
                "title": "fast-c-solution-with-early-exits-unordered-map",
                "content": "Count imbalances and swap paying the cost equal to either the next lowest imbalanced number or twice the smallest element in both arrays.  Keep track of swaps left and make early exists when the remaining cost will always be paid by the smallest number.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& v1, vector<int>& v2) {\\n        long long ans=0;\\n        unordered_map<int,int> balance;\\n        for (int d: v1) { balance[d]++; }\\n        for (int d: v2) { balance[d]--; }\\n        long long swaps_left=0, total_balance=0;\\n        vector<int> v;\\n        v.reserve(balance.size());\\n        for (auto [d,k]: balance) {\\n            if (k%2!=0) return -1;\\n            swaps_left+=abs(k);\\n            total_balance+=k;\\n            v.push_back(d);\\n        }\\n        if (total_balance!=0 || swaps_left%4>0) return -1;\\n        swaps_left/=4;  // total number of swaps\\n        sort(v.begin(),v.end());\\n        int min_cost=2*v[0];\\n        for (auto d: v) {\\n            if (balance[d]==0) continue;\\n            if (d>=min_cost) {    // we will use the smallest number \\n                ans+=swaps_left*min_cost;  // for the remaining swaps\\n                return ans;\\n            }\\n            long k=abs(balance[d])/2;\\n            if (k>=swaps_left) {    // out of swaps -- early exit\\n                ans+=swaps_left*d;\\n                return ans;\\n            }\\n            ans+=k*d;\\n            swaps_left-=k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& v1, vector<int>& v2) {\\n        long long ans=0;\\n        unordered_map<int,int> balance;\\n        for (int d: v1) { balance[d]++; }\\n        for (int d: v2) { balance[d]--; }\\n        long long swaps_left=0, total_balance=0;\\n        vector<int> v;\\n        v.reserve(balance.size());\\n        for (auto [d,k]: balance) {\\n            if (k%2!=0) return -1;\\n            swaps_left+=abs(k);\\n            total_balance+=k;\\n            v.push_back(d);\\n        }\\n        if (total_balance!=0 || swaps_left%4>0) return -1;\\n        swaps_left/=4;  // total number of swaps\\n        sort(v.begin(),v.end());\\n        int min_cost=2*v[0];\\n        for (auto d: v) {\\n            if (balance[d]==0) continue;\\n            if (d>=min_cost) {    // we will use the smallest number \\n                ans+=swaps_left*min_cost;  // for the remaining swaps\\n                return ans;\\n            }\\n            long k=abs(balance[d])/2;\\n            if (k>=swaps_left) {    // out of swaps -- early exit\\n                ans+=swaps_left*d;\\n                return ans;\\n            }\\n            ans+=k*d;\\n            swaps_left-=k;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148588,
                "title": "easy-to-understand-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n = basket1.size();\\n        \\n        map<long long ,long long> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[basket1[i]]++;\\n            mp[basket2[i]]--;\\n        }\\n       \\n        vector<long long> swapNeeded;\\n        long long minE = begin(mp)->first;\\n        \\n        long long totalSwaps = 0;\\n        for (auto[a,n1] : mp) {\\n            if (n1 % 2)\\n                return -1;\\n            // only possitive fruits freq can be takens as they will have their negative counters parts\\n            // we need swap only half on other side \\n            totalSwaps += max(0LL,n1/2); \\n        }\\n        \\n        long long result = 0;\\n        for (auto &p : mp) {\\n            long long swaps = abs(p.second)/2;\\n            if (swaps > totalSwaps) {\\n                swaps = totalSwaps;\\n            }\\n            // try swapping with minimumm element which has double cost\\n            // or just swap the current element itself\\n            long long cost = swaps*(min(p.first,2*minE));\\n            result += cost;\\n            // reduce the total swaps\\n            totalSwaps -= swaps;\\n            if (totalSwaps == 0)\\n                return result;\\n        }\\n        \\n        return result;\\n        \\n    }\\n\\t}\\n    \\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int n = basket1.size();\\n        \\n        map<long long ,long long> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[basket1[i]]++;\\n            mp[basket2[i]]--;\\n        }\\n       \\n        vector<long long> swapNeeded;\\n        long long minE = begin(mp)->first;\\n        \\n        long long totalSwaps = 0;\\n        for (auto[a,n1] : mp) {\\n            if (n1 % 2)\\n                return -1;\\n            // only possitive fruits freq can be takens as they will have their negative counters parts\\n            // we need swap only half on other side \\n            totalSwaps += max(0LL,n1/2); \\n        }\\n        \\n        long long result = 0;\\n        for (auto &p : mp) {\\n            long long swaps = abs(p.second)/2;\\n            if (swaps > totalSwaps) {\\n                swaps = totalSwaps;\\n            }\\n            // try swapping with minimumm element which has double cost\\n            // or just swap the current element itself\\n            long long cost = swaps*(min(p.first,2*minE));\\n            result += cost;\\n            // reduce the total swaps\\n            totalSwaps -= swaps;\\n            if (totalSwaps == 0)\\n                return result;\\n        }\\n        \\n        return result;\\n        \\n    }\\n\\t}\\n    \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3148316,
                "title": "go-python-o-n-log-n-time-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` golang []\\nfunc minCost(basket1 []int, basket2 []int) int64 {\\n    c1 := make(map[int]int)\\n    for _,num := range(basket1){\\n        c1[num]+=1\\n    }\\n\\n    c2 := make(map[int]int)\\n    for _,num := range(basket2){\\n        c2[num]+=1\\n    }\\n    \\n    for key,value := range(c1){\\n        if (value + c2[key]) % 2 == 1{\\n            return -1\\n        }\\n    }\\n\\n    for key,value := range(c2){\\n        if (value + c1[key]) % 2 == 1{\\n            return -1\\n        }\\n    }\\n\\n    b1 := []int{}\\n    for key,value := range(c1){\\n        if value > c2[key]{\\n            tmp := []int{}\\n            for i:=0;i<((value-c2[key])/2);i++{\\n                tmp = append(tmp,key)\\n            }\\n            b1 = append(b1,tmp...)\\n        }\\n    }\\n    \\n    b2 := []int{}\\n    for key,value := range(c2){\\n        if value > c1[key]{\\n            tmp := []int{}\\n            for i:=0;i<((value-c1[key])/2);i++{\\n                tmp = append(tmp,key)\\n            }\\n            b2 = append(b2,tmp...)\\n        }\\n    }\\n\\n    min_item := min(min_in_array(basket1),min_in_array(basket2))\\n    \\n    sort.Ints(b1)\\n    sort.Ints(b2)\\n\\n    cost := 0\\n    for len(b1) > 0{\\n        x := min(popleft(&b1),pop(&b2))\\n        cost+=min(x,min_item*2)\\n    }\\n    return int64(cost)\\n}\\n\\nfunc min_in_array(array []int) int{\\n    min_item := array[0]\\n    for i:=1;i<len(array);i++{\\n        min_item = min(min_item,array[i])\\n    }\\n    return min_item\\n}\\n\\nfunc min(a,b int) int{\\n    if a<b{\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc popleft(array *[]int) int{\\n    item := (*array)[0]\\n    *array = (*array)[1:]\\n    return item\\n}\\n\\nfunc pop(array *[]int) int{\\n    n := len(*array)\\n    item := (*array)[n-1]\\n    *array = (*array)[:n-1]\\n    return item\\n}\\n```\\n```python []\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        c1 = defaultdict(int)\\n        for num in basket1:\\n            c1[num]+=1\\n\\n        c2 = defaultdict(int)\\n        for num in basket2:\\n            c2[num]+=1\\n        \\n        for key,value in c1.items():\\n            if (value + c2[key]) % 2:\\n                return -1\\n        \\n        for key,value in c1.items():\\n            if (value + c1[key]) % 2:\\n                return -1\\n\\n        b1 = []\\n        for key,value in c1.items():\\n            if value > c2[key]:\\n                b1.extend([key]*((value-c2[key])//2))\\n        \\n        b2 = []\\n        for key,value in c2.items():\\n            if value > c1[key]:\\n                b2.extend([key]*((value-c1[key])//2))\\n\\n        min_item = min(min(basket1),min(basket2))\\n        \\n        b1 = deque(sorted(b1))\\n        b2 = deque(sorted(b2))\\n        \\n        cost = 0\\n        while b1:\\n            x = min(b1.popleft(),b2.pop())\\n            cost+=min(x,min_item*2)\\n        return cost\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "``` golang []\\nfunc minCost(basket1 []int, basket2 []int) int64 {\\n    c1 := make(map[int]int)\\n    for _,num := range(basket1){\\n        c1[num]+=1\\n    }\\n\\n    c2 := make(map[int]int)\\n    for _,num := range(basket2){\\n        c2[num]+=1\\n    }\\n    \\n    for key,value := range(c1){\\n        if (value + c2[key]) % 2 == 1{\\n            return -1\\n        }\\n    }\\n\\n    for key,value := range(c2){\\n        if (value + c1[key]) % 2 == 1{\\n            return -1\\n        }\\n    }\\n\\n    b1 := []int{}\\n    for key,value := range(c1){\\n        if value > c2[key]{\\n            tmp := []int{}\\n            for i:=0;i<((value-c2[key])/2);i++{\\n                tmp = append(tmp,key)\\n            }\\n            b1 = append(b1,tmp...)\\n        }\\n    }\\n    \\n    b2 := []int{}\\n    for key,value := range(c2){\\n        if value > c1[key]{\\n            tmp := []int{}\\n            for i:=0;i<((value-c1[key])/2);i++{\\n                tmp = append(tmp,key)\\n            }\\n            b2 = append(b2,tmp...)\\n        }\\n    }\\n\\n    min_item := min(min_in_array(basket1),min_in_array(basket2))\\n    \\n    sort.Ints(b1)\\n    sort.Ints(b2)\\n\\n    cost := 0\\n    for len(b1) > 0{\\n        x := min(popleft(&b1),pop(&b2))\\n        cost+=min(x,min_item*2)\\n    }\\n    return int64(cost)\\n}\\n\\nfunc min_in_array(array []int) int{\\n    min_item := array[0]\\n    for i:=1;i<len(array);i++{\\n        min_item = min(min_item,array[i])\\n    }\\n    return min_item\\n}\\n\\nfunc min(a,b int) int{\\n    if a<b{\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc popleft(array *[]int) int{\\n    item := (*array)[0]\\n    *array = (*array)[1:]\\n    return item\\n}\\n\\nfunc pop(array *[]int) int{\\n    n := len(*array)\\n    item := (*array)[n-1]\\n    *array = (*array)[:n-1]\\n    return item\\n}\\n```\n```python []\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        c1 = defaultdict(int)\\n        for num in basket1:\\n            c1[num]+=1\\n\\n        c2 = defaultdict(int)\\n        for num in basket2:\\n            c2[num]+=1\\n        \\n        for key,value in c1.items():\\n            if (value + c2[key]) % 2:\\n                return -1\\n        \\n        for key,value in c1.items():\\n            if (value + c1[key]) % 2:\\n                return -1\\n\\n        b1 = []\\n        for key,value in c1.items():\\n            if value > c2[key]:\\n                b1.extend([key]*((value-c2[key])//2))\\n        \\n        b2 = []\\n        for key,value in c2.items():\\n            if value > c1[key]:\\n                b2.extend([key]*((value-c1[key])//2))\\n\\n        min_item = min(min(basket1),min(basket2))\\n        \\n        b1 = deque(sorted(b1))\\n        b2 = deque(sorted(b2))\\n        \\n        cost = 0\\n        while b1:\\n            x = min(b1.popleft(),b2.pop())\\n            cost+=min(x,min_item*2)\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148210,
                "title": "misspelling-and-my-100-golang-solution",
                "content": "![image](https://assets.leetcode.com/users/images/20e71611-5bfd-494a-aee5-9ed567f963a6_1675631755.030241.png)\\n\\n@LeetCode, the highlighted is a misspelling. It should be `basket2`.\\n\\n---\\n\\n##### My Golang Solution\\n\\n```go\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\ntype pair struct {\\n\\tquan1, quan2 int\\n}\\n\\nfunc minCost(basket1 []int, basket2 []int) int64 {\\n\\n\\tminOfAll := math.MaxInt32\\n\\n\\tcounts := make(map[int]*pair)\\n\\tfor i := range basket1 {\\n\\n\\t\\t// process basket1[i]\\n\\t\\tif val, ok := counts[basket1[i]]; !ok {\\n\\t\\t\\tcounts[basket1[i]] = &pair{1, 0}\\n\\t\\t} else {\\n\\t\\t\\tval.quan1++\\n\\t\\t}\\n\\t\\tminOfAll = min(minOfAll, basket1[i])\\n\\n\\t\\t// process basket2[i]\\n\\t\\tif val, ok := counts[basket2[i]]; !ok {\\n\\t\\t\\tcounts[basket2[i]] = &pair{0, 1}\\n\\t\\t} else {\\n\\t\\t\\tval.quan2++\\n\\t\\t}\\n\\t\\tminOfAll = min(minOfAll, basket2[i])\\n\\t}\\n\\n\\tvar needSwitches []int\\n\\tfor k, v := range counts {\\n\\t\\tquan1, quan2 := v.quan1, v.quan2\\n\\n\\t\\tsame := min(quan1, quan2)\\n\\t\\tquanCombined := quan1 - same + quan2 - same\\n\\n\\t\\t// any odd net will not work\\n\\t\\tif quanCombined&1 == 1 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\tquanCombined >>= 1\\n\\n\\t\\tfor ; quanCombined != 0; quanCombined-- {\\n\\t\\t\\tneedSwitches = append(needSwitches, k)\\n\\t\\t}\\n\\t}\\n\\tsort.Ints(needSwitches)\\n\\n\\tvar res int\\n\\tfor i := 0; i < len(needSwitches) / 2; i++ {\\n\\t\\tres += min(minOfAll*2, needSwitches[i])\\n\\t}\\n\\treturn int64(res)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\ntype pair struct {\\n\\tquan1, quan2 int\\n}\\n\\nfunc minCost(basket1 []int, basket2 []int) int64 {\\n\\n\\tminOfAll := math.MaxInt32\\n\\n\\tcounts := make(map[int]*pair)\\n\\tfor i := range basket1 {\\n\\n\\t\\t// process basket1[i]\\n\\t\\tif val, ok := counts[basket1[i]]; !ok {\\n\\t\\t\\tcounts[basket1[i]] = &pair{1, 0}\\n\\t\\t} else {\\n\\t\\t\\tval.quan1++\\n\\t\\t}\\n\\t\\tminOfAll = min(minOfAll, basket1[i])\\n\\n\\t\\t// process basket2[i]\\n\\t\\tif val, ok := counts[basket2[i]]; !ok {\\n\\t\\t\\tcounts[basket2[i]] = &pair{0, 1}\\n\\t\\t} else {\\n\\t\\t\\tval.quan2++\\n\\t\\t}\\n\\t\\tminOfAll = min(minOfAll, basket2[i])\\n\\t}\\n\\n\\tvar needSwitches []int\\n\\tfor k, v := range counts {\\n\\t\\tquan1, quan2 := v.quan1, v.quan2\\n\\n\\t\\tsame := min(quan1, quan2)\\n\\t\\tquanCombined := quan1 - same + quan2 - same\\n\\n\\t\\t// any odd net will not work\\n\\t\\tif quanCombined&1 == 1 {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\tquanCombined >>= 1\\n\\n\\t\\tfor ; quanCombined != 0; quanCombined-- {\\n\\t\\t\\tneedSwitches = append(needSwitches, k)\\n\\t\\t}\\n\\t}\\n\\tsort.Ints(needSwitches)\\n\\n\\tvar res int\\n\\tfor i := 0; i < len(needSwitches) / 2; i++ {\\n\\t\\tres += min(minOfAll*2, needSwitches[i])\\n\\t}\\n\\treturn int64(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3147420,
                "title": "greedy-solution-in-java",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy\\n\\n# Complexity\\n- Time complexity: o(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        long min = Long.MAX_VALUE;\\n        for (int i = 0; i < basket1.length; i++) {\\n            map1.put(basket1[i], map1.getOrDefault(basket1[i], 0) + 1);\\n            map1.put(basket2[i], map1.getOrDefault(basket2[i], 0) - 1);\\n            min = Math.min(min, basket1[i]);\\n            min = Math.min(min, basket2[i]);\\n        }\\n\\n        long ans = 0;\\n        List<Integer> arr = new ArrayList<>();\\n        for (int v: map1.keySet()) {\\n            int diff = Math.abs(map1.get(v));\\n            if (diff % 2 != 0) {\\n                return -1;\\n            }\\n            diff /= 2;\\n            while (diff-- > 0) {\\n                arr.add(v);\\n                System.out.print(v + \" \");\\n            }\\n        }\\n        Collections.sort(arr);\\n        for (int i = 0; i < (arr.size()) / 2; i++) {\\n            //Either swap using minElement as intermediate or direct swap\\n            ans += Math.min(2 * min, arr.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        long min = Long.MAX_VALUE;\\n        for (int i = 0; i < basket1.length; i++) {\\n            map1.put(basket1[i], map1.getOrDefault(basket1[i], 0) + 1);\\n            map1.put(basket2[i], map1.getOrDefault(basket2[i], 0) - 1);\\n            min = Math.min(min, basket1[i]);\\n            min = Math.min(min, basket2[i]);\\n        }\\n\\n        long ans = 0;\\n        List<Integer> arr = new ArrayList<>();\\n        for (int v: map1.keySet()) {\\n            int diff = Math.abs(map1.get(v));\\n            if (diff % 2 != 0) {\\n                return -1;\\n            }\\n            diff /= 2;\\n            while (diff-- > 0) {\\n                arr.add(v);\\n                System.out.print(v + \" \");\\n            }\\n        }\\n        Collections.sort(arr);\\n        for (int i = 0; i < (arr.size()) / 2; i++) {\\n            //Either swap using minElement as intermediate or direct swap\\n            ans += Math.min(2 * min, arr.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147387,
                "title": "python-7-line-solution",
                "content": "```\\ndef minCost(self, b1: List[int], b2: List[int]) -> int:\\n\\tc1, c2, nums = Counter(b1), Counter(b2), []\\n\\tfor k in c1.keys()|c2.keys():\\n\\t\\tif (c1[k]+c2[k])%2:\\n\\t\\t\\treturn -1\\n\\t\\tnums.extend([k]*(abs(c1[k]-c2[k])//2))\\n\\tsmall, n, nums = min(b1+b2), len(nums), sorted(nums)\\n\\treturn sum(min(small*2, nums[i]) for i in range(n//2))\\n```",
                "solutionTags": [],
                "code": "```\\ndef minCost(self, b1: List[int], b2: List[int]) -> int:\\n\\tc1, c2, nums = Counter(b1), Counter(b2), []\\n\\tfor k in c1.keys()|c2.keys():\\n\\t\\tif (c1[k]+c2[k])%2:\\n\\t\\t\\treturn -1\\n\\t\\tnums.extend([k]*(abs(c1[k]-c2[k])//2))\\n\\tsmall, n, nums = min(b1+b2), len(nums), sorted(nums)\\n\\treturn sum(min(small*2, nums[i]) for i in range(n//2))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3147332,
                "title": "c-take-care-of-swapping-with-minelement-case",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        set<int>st;\\n        map<int,int>bask1;\\n        map<int,int>bask2;\\n        for(auto it : basket1){\\n            bask1[it]++;\\n            st.insert(it);\\n        }\\n        for(auto it : basket2){\\n            bask2[it]++;\\n            st.insert(it);\\n        }\\n        \\n        int minele = INT_MAX;\\n        \\n        for(auto it : st){\\n            minele = min(minele,it);\\n        }\\n        \\n        int n = basket1.size();\\n        vector<int>swapele;\\n       for(auto it : st){\\n           if(bask1[it] == bask2[it]){\\n               continue;\\n           }\\n           else{\\n               if(bask1[it] > bask2[it]){\\n                   int diff = bask1[it] - bask2[it];\\n                   if(diff%2!=0){\\n                       return -1;\\n                   }\\n                   for(int i=0;i<diff/2;i++){\\n                       swapele.push_back(it);\\n                   }\\n               }\\n               else{\\n                   int diff = bask2[it] - bask1[it];\\n                    if(diff%2!=0){\\n                       return -1;\\n                   }\\n                   for(int i=0;i<diff/2;i++){\\n                       swapele.push_back(it);\\n                   }\\n               }\\n           }\\n       }\\n        long long cost = 0;\\n        int sz = swapele.size();\\n        for(int i=0;i<sz/2;i++){\\n            cost += min(2*minele,min(swapele[i],swapele[sz-i-1]));\\n        }\\n        \\n        return cost;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        set<int>st;\\n        map<int,int>bask1;\\n        map<int,int>bask2;\\n        for(auto it : basket1){\\n            bask1[it]++;\\n            st.insert(it);\\n        }\\n        for(auto it : basket2){\\n            bask2[it]++;\\n            st.insert(it);\\n        }\\n        \\n        int minele = INT_MAX;\\n        \\n        for(auto it : st){\\n            minele = min(minele,it);\\n        }\\n        \\n        int n = basket1.size();\\n        vector<int>swapele;\\n       for(auto it : st){\\n           if(bask1[it] == bask2[it]){\\n               continue;\\n           }\\n           else{\\n               if(bask1[it] > bask2[it]){\\n                   int diff = bask1[it] - bask2[it];\\n                   if(diff%2!=0){\\n                       return -1;\\n                   }\\n                   for(int i=0;i<diff/2;i++){\\n                       swapele.push_back(it);\\n                   }\\n               }\\n               else{\\n                   int diff = bask2[it] - bask1[it];\\n                    if(diff%2!=0){\\n                       return -1;\\n                   }\\n                   for(int i=0;i<diff/2;i++){\\n                       swapele.push_back(it);\\n                   }\\n               }\\n           }\\n       }\\n        long long cost = 0;\\n        int sz = swapele.size();\\n        for(int i=0;i<sz/2;i++){\\n            cost += min(2*minele,min(swapele[i],swapele[sz-i-1]));\\n        }\\n        \\n        return cost;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147186,
                "title": "map-c-cinch-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<ll ,ll> mp1, mp2;\\n        set<ll> st; \\n        vector<int> nums1, nums2;\\n\\n        for(auto it : b1)\\n            mp1[it]++, st.insert(it);\\n        for(auto it : b2)\\n            mp2[it]++, st.insert(it);\\n        \\n        ll mini = *st.begin();\\n\\n        for(auto it : st){\\n            int x = mp1[it];\\n            int y = mp2[it];\\n\\n            if((x + y)%2)\\n                return -1;\\n            \\n            if(x == y)\\n                continue;\\n            \\n            if(x > y){\\n                x -= y;\\n                x /= 2;\\n                while(x--)\\n                    nums1.push_back(it);\\n            }\\n            else{\\n                y -= x;\\n                y /= 2;\\n                while(y--)\\n                    nums2.push_back(it);\\n            }\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        ll cost=0;\\n        int n = nums1.size();\\n        for(int i=0; i<n; i++){\\n            ll x = min(nums1[n-i-1], nums2[i]);\\n            cost += min(x, 2*mini);\\n        }\\n\\n        return cost;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<ll ,ll> mp1, mp2;\\n        set<ll> st; \\n        vector<int> nums1, nums2;\\n\\n        for(auto it : b1)\\n            mp1[it]++, st.insert(it);\\n        for(auto it : b2)\\n            mp2[it]++, st.insert(it);\\n        \\n        ll mini = *st.begin();\\n\\n        for(auto it : st){\\n            int x = mp1[it];\\n            int y = mp2[it];\\n\\n            if((x + y)%2)\\n                return -1;\\n            \\n            if(x == y)\\n                continue;\\n            \\n            if(x > y){\\n                x -= y;\\n                x /= 2;\\n                while(x--)\\n                    nums1.push_back(it);\\n            }\\n            else{\\n                y -= x;\\n                y /= 2;\\n                while(y--)\\n                    nums2.push_back(it);\\n            }\\n        }\\n\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        ll cost=0;\\n        int n = nums1.size();\\n        for(int i=0; i<n; i++){\\n            ll x = min(nums1[n-i-1], nums2[i]);\\n            cost += min(x, 2*mini);\\n        }\\n\\n        return cost;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147143,
                "title": "python-3-freq-map-two-pointers",
                "content": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        c1, c2 = dict(Counter(basket1)), dict(Counter(basket2))\\n        \\n        # freq map from b1 to b2, and from b2 to b1\\n        m12, m21 = {}, {}\\n        for k in c1:\\n            if c1[k] == c2.get(k, 0): continue\\n            tot = c1[k] + c2.get(k, 0)\\n            if tot % 2:\\n                return -1\\n            if c1[k] > c2.get(k, 0):\\n                m12[k] = c1[k] - tot // 2\\n            else:\\n                m21[k] = c2.get(k, 0) - tot // 2\\n\\n        for k in c2:\\n            if k in m12 or k in m21 or c2[k] == c1.get(k, 0): continue\\n            tot = c2[k] + c1.get(k, 0)\\n            if tot % 2:\\n                return -1\\n            if c2[k] > c1.get(k, 0):\\n                m21[k] = c2[k] - tot // 2\\n            else:\\n                m12[k] = c1.get(k, 0) - tot // 2\\n        \\n        # impossible to swap if unmatched swap counts\\n        if sum(m12.values()) != sum(m21.values()): return -1\\n        \\n        # number to swap sorted\\n        pos, neg = sorted(m12), sorted(m21)\\n        \\n        # minimum element for two backets\\n        common_min = min(basket1+basket2)\\n        ans = 0\\n        \\n        # match minimum with maximum\\n        i, j = 0, len(neg) - 1\\n        \\n        while i < len(pos):\\n            x, y = m12[pos[i]], m21[neg[j]]\\n            removed = min(x, y)\\n            m12[pos[i]] -= removed\\n            m21[neg[j]] -= removed\\n            # either mutual swap or use the minimum pile to swap\\n            ans += min(min(pos[i], neg[j]) * removed, common_min * removed * 2)\\n            if not m12[pos[i]]:\\n                i += 1\\n            if not m21[neg[j]]:\\n                j -= 1\\n        \\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        c1, c2 = dict(Counter(basket1)), dict(Counter(basket2))\\n        \\n        # freq map from b1 to b2, and from b2 to b1\\n        m12, m21 = {}",
                "codeTag": "Java"
            },
            {
                "id": 3147134,
                "title": "easy-to-understand-2-pointer-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        if len(basket1) != len(basket2): return -1\\n        b1_c = Counter(basket1)\\n        b2_c = Counter(basket2)\\n        l_b1 = []\\n        l_b2 = []\\n        for k,v in b1_c.items():\\n            l_b1.append([k,v])\\n            if k not in b2_c:\\n                l_b2.append([k,0])\\n        for k,v in b2_c.items():\\n            l_b2.append([k,v])\\n            if k not in b1_c:\\n                l_b1.append([k,0])\\n        l_b1.sort()\\n        l_b2.sort()\\n        del b1_c\\n        del b2_c\\n        for index, i in enumerate(l_b1):\\n            if (l_b1[index][1] + l_b2[index][1]) % 2:\\n                return -1\\n        l, r = 0, len(l_b1) - 1\\n        spec = l_b1[l][0]\\n        ans = 0\\n        while l <= r:\\n            if l_b1[r][1] == l_b2[r][1]:\\n                r -= 1\\n                continue\\n            if l_b1[l][1] == l_b2[l][1]:\\n                l += 1\\n                continue    \\n            if l_b1[l][1] < l_b2[l][1]:\\n                l_b1[l][1] = l_b1[l][1] + 1\\n                l_b2[l][1] = l_b2[l][1] - 1\\n            \\n            elif l_b1[l][1] > l_b2[l][1]:\\n                l_b1[l][1] = l_b1[l][1] - 1\\n                l_b2[l][1] = l_b2[l][1] + 1\\n\\n            if l_b1[r][1] < l_b2[r][1]:\\n                l_b1[r][1] = l_b1[r][1] + 1\\n                l_b2[r][1] = l_b2[r][1] - 1\\n\\n            elif l_b1[r][1] > l_b2[r][1]:\\n                l_b1[r][1] = l_b1[r][1] - 1\\n                l_b2[r][1] = l_b2[r][1] + 1\\n            ans += min(2 * spec, min(l_b1[l][0], l_b1[r][0]))\\n        return ans\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        if len(basket1) != len(basket2): return -1\\n        b1_c = Counter(basket1)\\n        b2_c = Counter(basket2)\\n        l_b1 = []\\n        l_b2 = []\\n        for k,v in b1_c.items():\\n            l_b1.append([k,v])\\n            if k not in b2_c:\\n                l_b2.append([k,0])\\n        for k,v in b2_c.items():\\n            l_b2.append([k,v])\\n            if k not in b1_c:\\n                l_b1.append([k,0])\\n        l_b1.sort()\\n        l_b2.sort()\\n        del b1_c\\n        del b2_c\\n        for index, i in enumerate(l_b1):\\n            if (l_b1[index][1] + l_b2[index][1]) % 2:\\n                return -1\\n        l, r = 0, len(l_b1) - 1\\n        spec = l_b1[l][0]\\n        ans = 0\\n        while l <= r:\\n            if l_b1[r][1] == l_b2[r][1]:\\n                r -= 1\\n                continue\\n            if l_b1[l][1] == l_b2[l][1]:\\n                l += 1\\n                continue    \\n            if l_b1[l][1] < l_b2[l][1]:\\n                l_b1[l][1] = l_b1[l][1] + 1\\n                l_b2[l][1] = l_b2[l][1] - 1\\n            \\n            elif l_b1[l][1] > l_b2[l][1]:\\n                l_b1[l][1] = l_b1[l][1] - 1\\n                l_b2[l][1] = l_b2[l][1] + 1\\n\\n            if l_b1[r][1] < l_b2[r][1]:\\n                l_b1[r][1] = l_b1[r][1] + 1\\n                l_b2[r][1] = l_b2[r][1] - 1\\n\\n            elif l_b1[r][1] > l_b2[r][1]:\\n                l_b1[r][1] = l_b1[r][1] - 1\\n                l_b2[r][1] = l_b2[r][1] + 1\\n            ans += min(2 * spec, min(l_b1[l][0], l_b1[r][0]))\\n        return ans\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147021,
                "title": "clean-and-concise-hashmap-and-sorting-solution-c",
                "content": "# Approach\\nthere are 2 options to swap either swap 2 fruits directly or take help of a smaller cost fruit for swapping\\ntaking help of smaller cost fruit will increase times of swapping but can reduce cost\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n- Space complexity: O(3N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<long long,long long> mp1,mp2;\\n        for(auto &fc : b1) mp1[fc]++;\\n        for(auto &fc : b2) mp2[fc]++;\\n        \\n        for(auto &[k,v] : mp1)\\n            if((v+mp2[k]) % 2) return -1;\\n        \\n        for(auto &[k,v] : mp2)\\n            if((v+mp1[k]) % 2) return -1;\\n        \\n        vector<long long> vec; \\n        long long sm = LLONG_MAX;\\n        \\n        for(auto [k,v] : mp1){\\n            long long need = abs(v-mp2[k])/2;\\n            if(mp2[k]) sm = min(sm,k);\\n            mp1.erase(k); mp2.erase(k);\\n            while(need--) vec.push_back(k);\\n        }\\n        \\n        for(auto [k,v] : mp2){\\n            long long need = abs(v-mp1[k])/2;\\n            if(mp1[k]) sm = min(sm,k);\\n            mp1.erase(k); mp2.erase(k);\\n            while(need--) vec.push_back(k);\\n        }\\n        \\n        sort(vec.begin(),vec.end());\\n        \\n        long long int ans = 0;\\n        for(int i=0;i<vec.size()/2;i++){\\n            ans += min(sm+sm,vec[i]);\\n            sm = min(sm,vec[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<long long,long long> mp1,mp2;\\n        for(auto &fc : b1) mp1[fc]++;\\n        for(auto &fc : b2) mp2[fc]++;\\n        \\n        for(auto &[k,v] : mp1)\\n            if((v+mp2[k]) % 2) return -1;\\n        \\n        for(auto &[k,v] : mp2)\\n            if((v+mp1[k]) % 2) return -1;\\n        \\n        vector<long long> vec; \\n        long long sm = LLONG_MAX;\\n        \\n        for(auto [k,v] : mp1){\\n            long long need = abs(v-mp2[k])/2;\\n            if(mp2[k]) sm = min(sm,k);\\n            mp1.erase(k); mp2.erase(k);\\n            while(need--) vec.push_back(k);\\n        }\\n        \\n        for(auto [k,v] : mp2){\\n            long long need = abs(v-mp1[k])/2;\\n            if(mp1[k]) sm = min(sm,k);\\n            mp1.erase(k); mp2.erase(k);\\n            while(need--) vec.push_back(k);\\n        }\\n        \\n        sort(vec.begin(),vec.end());\\n        \\n        long long int ans = 0;\\n        for(int i=0;i<vec.size()/2;i++){\\n            ans += min(sm+sm,vec[i]);\\n            sm = min(sm,vec[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146902,
                "title": "python-clean-explanation-and-basic-implementation-using-maps",
                "content": "### So here is the idea:\\n\\n- Obviously to have same elements in both the baskets, you would need each element to repeat even number of times.\\n- Separate out the elements you need and the elements you have extra in basket1.\\n- For every low/small element in the required list, you can swap it with a high/larger element from the extras list.\\n- Hence for each swap you would take min(low element, high element).\\n- But, instead of doing a swap directly, what if you use a much smaller element as an intermediary.\\n- This means swap(low, intermediary) and swap(high, intermediary).\\n- Take the minimum of these two methods of swap as cost.\\n- Add up cost :))\\n- Remember that having the required elements in basket 1 means you have the rest in basket 2.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        d = {}\\n        mini = min(min(basket1), min(basket2))\\n        \\n        if len(basket1) != len(basket2): return -1\\n        \\n        def coun_(arr):\\n            mp = {}\\n            for i in arr:\\n                if i in mp: mp[i] += 1\\n                else: mp[i] = 1\\n            return mp\\n        \\n        for i in basket1:\\n            if i in d: d[i] += 1\\n            else: d[i] = 1\\n                \\n        for i in basket2:\\n            if i in d: d[i] += 1\\n            else: d[i] = 1\\n                \\n        for i in d:\\n            if d[i]&1: return -1\\n        \\n        req = {i: d[i]//2 for i in d}\\n        \\n        b1 = coun_(basket1)\\n        b2 = coun_(basket2)\\n        \\n        extra = []\\n        req_arr = []\\n        \\n        for i in req:\\n            if i not in b1:\\n                b1[i] = 0\\n            if req[i] < b1[i]:\\n                extra.extend([i]*(b1[i] - req[i]))\\n            elif req[i] > b1[i]:\\n                req_arr.extend([i]*(req[i] - b1[i]))\\n                \\n        extra.sort(reverse = True)\\n        req_arr.sort()\\n        \\n        s = 0\\n        for i in range(len(extra)):\\n            # print(mini, req_arr[i], extra)\\n            s += min(2*mini, min(req_arr[i], extra[i]))\\n        \\n        return s\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        d = {}\\n        mini = min(min(basket1), min(basket2))\\n        \\n        if len(basket1) != len(basket2): return -1\\n        \\n        def coun_(arr):\\n            mp = {}\\n            for i in arr:\\n                if i in mp: mp[i] += 1\\n                else: mp[i] = 1\\n            return mp\\n        \\n        for i in basket1:\\n            if i in d: d[i] += 1\\n            else: d[i] = 1\\n                \\n        for i in basket2:\\n            if i in d: d[i] += 1\\n            else: d[i] = 1\\n                \\n        for i in d:\\n            if d[i]&1: return -1\\n        \\n        req = {i: d[i]//2 for i in d}\\n        \\n        b1 = coun_(basket1)\\n        b2 = coun_(basket2)\\n        \\n        extra = []\\n        req_arr = []\\n        \\n        for i in req:\\n            if i not in b1:\\n                b1[i] = 0\\n            if req[i] < b1[i]:\\n                extra.extend([i]*(b1[i] - req[i]))\\n            elif req[i] > b1[i]:\\n                req_arr.extend([i]*(req[i] - b1[i]))\\n                \\n        extra.sort(reverse = True)\\n        req_arr.sort()\\n        \\n        s = 0\\n        for i in range(len(extra)):\\n            # print(mini, req_arr[i], extra)\\n            s += min(2*mini, min(req_arr[i], extra[i]))\\n        \\n        return s\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146894,
                "title": "maps-and-sorting-cpp-solve-cpp-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmaps solve cpp solve \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmaps st store values and sorting\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        // [4,2,2,2], basket2 = [1,4,1,2]\\n        //     4 2 2 2            4 2 1 1  long long sols2=0;\\n            map<int,int> mapp;\\n        int starts=INT_MAX;\\n        for(int po=0;po<basket1.size();po++){\\n            mapp[basket1[po]]++;\\n        }\\n        map<int,int> mapp2;\\n        for(int po=0;po<basket2.size();po++){\\n            mapp2[basket2[po]]++;\\n        }\\n        vector<int> sols; \\n        vector<int> sols2;\\n        sort(basket1.begin(),basket1.end());\\n        sort(basket2.begin(),basket2.end());\\n        for(int po=0;po<basket1.size();po++){\\n            if(mapp2[basket1[po]]==0){                \\n                sols.push_back(basket1[po]);\\n            }\\n            else\\n                 mapp2[basket1[po]]--;\\n            starts=min(starts,basket1[po]);\\n        }\\n        for(auto it=mapp2.begin();it!=mapp2.end();it++){\\n            if(it->second>0){\\n                for(int po=0;po<it->second;po++){\\n            sols2.push_back(it->first);}\\n           }\\n            starts=min(starts,it->first);\\n        }\\n        long long s=0;\\n        // sort(sols.begin(),sols.end());\\n        // sort(sols2.begin(),sols2.end());\\n        int i=0,j=sols2.size()-1; \\n        if(sols.size()!=sols2.size())\\n            return -1;\\n        if(sols.size()%2!=0&&sols2.size()%2!=0)\\n            return -1;\\n        // for(int po=0;po<sols.size();po++){\\n        //     cout<<sols[po]<<\".\"<<sols2[po]<<\".\";\\n        // }\\n        while(i+1<sols.size()&&j-1<sols2.size()){\\n            if(sols[i]!=sols[i+1])\\n                return -1;\\n            if(sols2[j]!=sols2[j-1])\\n                return -1;\\n            else\\n                s+=min(2*starts,min(sols[i],sols2[j]));\\n            i+=2;\\n            j-=2;\\n        }\\n    return s;}\\n};\\n\\n \\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        // [4,2,2,2], basket2 = [1,4,1,2]\\n        //     4 2 2 2            4 2 1 1  long long sols2=0;\\n            map<int,int> mapp;\\n        int starts=INT_MAX;\\n        for(int po=0;po<basket1.size();po++){\\n            mapp[basket1[po]]++;\\n        }\\n        map<int,int> mapp2;\\n        for(int po=0;po<basket2.size();po++){\\n            mapp2[basket2[po]]++;\\n        }\\n        vector<int> sols; \\n        vector<int> sols2;\\n        sort(basket1.begin(),basket1.end());\\n        sort(basket2.begin(),basket2.end());\\n        for(int po=0;po<basket1.size();po++){\\n            if(mapp2[basket1[po]]==0){                \\n                sols.push_back(basket1[po]);\\n            }\\n            else\\n                 mapp2[basket1[po]]--;\\n            starts=min(starts,basket1[po]);\\n        }\\n        for(auto it=mapp2.begin();it!=mapp2.end();it++){\\n            if(it->second>0){\\n                for(int po=0;po<it->second;po++){\\n            sols2.push_back(it->first);}\\n           }\\n            starts=min(starts,it->first);\\n        }\\n        long long s=0;\\n        // sort(sols.begin(),sols.end());\\n        // sort(sols2.begin(),sols2.end());\\n        int i=0,j=sols2.size()-1; \\n        if(sols.size()!=sols2.size())\\n            return -1;\\n        if(sols.size()%2!=0&&sols2.size()%2!=0)\\n            return -1;\\n        // for(int po=0;po<sols.size();po++){\\n        //     cout<<sols[po]<<\".\"<<sols2[po]<<\".\";\\n        // }\\n        while(i+1<sols.size()&&j-1<sols2.size()){\\n            if(sols[i]!=sols[i+1])\\n                return -1;\\n            if(sols2[j]!=sols2[j-1])\\n                return -1;\\n            else\\n                s+=min(2*starts,min(sols[i],sols2[j]));\\n            i+=2;\\n            j-=2;\\n        }\\n    return s;}\\n};\\n\\n \\n```",
                "codeTag": "C++"
            },
            {
                "id": 3146844,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        long long ans = 0;\\n        sort(b1.begin(), b1.end());\\n        sort(b2.begin(), b2.end());\\n        int mb = min(b1[0], b2[0]);\\n        unordered_map<int, int> f1, f2;\\n        for(auto& b : b1) ++f1[b];\\n        for(auto& b : b2) ++f2[b];\\n        int i = 0, n = b1.size(), j = n-1;\\n        \\n        while(i < n || 0 <= j){\\n            if(i < n && f1[b1[i]] <= f2[b1[i]]) ++i;\\n            else if(0 <= j && f1[b2[j]] >= f2[b2[j]]) --j;\\n            else if(i == n || j < 0 || (f1[b1[i]] - f2[b1[i]])%2 == 1 || (f1[b2[j]] - f2[b2[j]])%2 == 1) return -1;\\n            else{\\n                ans += min({b1[i], b2[j], 2*mb});\\n                --f1[b1[i]];\\n                ++f2[b1[i]];\\n                ++f1[b2[j]];\\n                --f2[b2[j]];\\n                ++i;\\n                --j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        long long ans = 0;\\n        sort(b1.begin(), b1.end());\\n        sort(b2.begin(), b2.end());\\n        int mb = min(b1[0], b2[0]);\\n        unordered_map<int, int> f1, f2;\\n        for(auto& b : b1) ++f1[b];\\n        for(auto& b : b2) ++f2[b];\\n        int i = 0, n = b1.size(), j = n-1;\\n        \\n        while(i < n || 0 <= j){\\n            if(i < n && f1[b1[i]] <= f2[b1[i]]) ++i;\\n            else if(0 <= j && f1[b2[j]] >= f2[b2[j]]) --j;\\n            else if(i == n || j < 0 || (f1[b1[i]] - f2[b1[i]])%2 == 1 || (f1[b2[j]] - f2[b2[j]])%2 == 1) return -1;\\n            else{\\n                ans += min({b1[i], b2[j], 2*mb});\\n                --f1[b1[i]];\\n                ++f2[b1[i]];\\n                ++f1[b2[j]];\\n                --f2[b2[j]];\\n                ++i;\\n                --j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146836,
                "title": "very-intuitive-and-fully-explained-basic-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere the intuition to use greedy comes from the time complexity as we need something linear.now here there is one edge case you should see that is if question asked you to get minimum steps to make array equal then you would have discarded all the elemnts of the array whose counts are equal in both array but here the question is not that so you have two choices while swapping any element of array, and that you need to see very carefully.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntwo choices are -:\\nexample -: 1) 28 28 8\\n           2) 32 32 8\\nnow onw thing you can do is to swap(28 ,32) and you get your answer =28 but a better solution could be swap(28,8) then swap(32,8) hence answer=16 which is better , so for each inequality while swappinh you need to check is the min number is less than least value of array*2.\\n\\nnow some thing you need to take care is that if the differnec in occurence of a number in two array is odd than it could never form an equal array hence answer would always be -1. and if the differnce sum of both the arrays are not equal then also answer would be -1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int min_val=INT_MAX;\\n        vector<pair<int,int>> vec1;\\n        vector<pair<int,int>> vec2;\\n        map<int,int> mp1;\\n        map<int,int> mp2;\\n        for(int i=0;i<basket1.size();i++){\\n            min_val=min(basket1[i],min_val);\\n            mp1[basket1[i]]+=1;\\n        }\\n        for(int i=0;i<basket2.size();i++){\\n            min_val=min(basket2[i],min_val);\\n            mp2[basket2[i]]+=1;\\n        }\\n        long long check1=0;\\n        long long check2=0;\\n        for(auto it:mp2){\\n            int val1=it.second;\\n            int val2=mp1[it.first];\\n            if(val1>val2){\\n                int a=val1-val2;\\n                if(a%2){\\n                    return -1;\\n                }\\n                check2+=a;\\n                vec2.push_back(make_pair(it.first,a));\\n            }\\n            else if(val1<val2){\\n                int a=val2-val1;\\n                if(a%2){\\n                    return -1;\\n                }\\n                check1+=a;\\n                vec1.push_back(make_pair(it.first,a));\\n            }\\n        }\\n        for(auto it:mp1){\\n            int val1=it.second;\\n            int val2=mp2[it.first];\\n            if(val2==0){\\n                int a=val1-val2;\\n                if(a%2){\\n                    return -1;\\n                }\\n                check1+=a;\\n                vec1.push_back(make_pair(it.first,a));\\n            }\\n        }\\n        if(check1!=check2){\\n            return -1;\\n        }\\n        long long ans=0;\\n        int p1=0;\\n        int p2=0;\\n        int p3=vec1.size()-1;\\n        int p4=vec2.size()-1;\\n        while((p1<=p3)&&(p2<=p4)){\\n          if(vec1[p1].first<vec2[p2].first){\\n             if(vec1[p1].first<2*min_val){\\n               int b=min(vec1[p1].second,vec2[p4].second);\\n               ans+=(long long)(b/2)*vec1[p1].first;\\n               vec1[p1].second=vec1[p1].second-b;\\n               vec2[p4].second=vec2[p4].second-b;\\n               if(vec1[p1].second==0 && vec2[p4].second==0){\\n                  p1++;\\n                  p4--;\\n               }\\n               else if(vec1[p1].second==0){\\n                   p1++;\\n               }\\n               else if(vec2[p4].second==0){\\n                  p4--;\\n               }\\n             }\\n             else{\\n                int b=min(vec1[p1].second,vec2[p4].second);\\n               ans+=(long long)(b/2)*(2*min_val);\\n               vec1[p1].second=vec1[p1].second-b;\\n               vec2[p4].second=vec2[p4].second-b;\\n               if(vec1[p1].second==0 &&  vec2[p4].second==0){\\n                  p1++;\\n                  p4--;\\n               }\\n               else if(vec1[p1].second==0){\\n                   p1++;\\n               }\\n               else if(vec2[p4].second==0){\\n                  p4--;\\n               }\\n             }\\n          }\\n          else{\\n             if(vec2[p2].first<2*min_val){\\n               int b=min(vec2[p2].second,vec1[p3].second);\\n               ans+=(long long)(b/2)*vec2[p2].first;\\n               vec2[p2].second=vec2[p2].second-b;\\n               vec1[p3].second=vec1[p3].second-b;\\n               if(vec2[p2].second==0 && vec1[p3].second==0){\\n                  p2++;\\n                  p3--;\\n               }\\n               else if(vec2[p2].second==0){\\n                   p2++;\\n               }\\n               else if(vec1[p3].second==0){\\n                  p3--;\\n               }\\n             }\\n             else{\\n                int b=min(vec2[p2].second,vec1[p3].second);\\n               ans+=(long long)(b/2)*(2*min_val);\\n               vec2[p2].second=vec2[p2].second-b;\\n               vec1[p3].second=vec1[p3].second-b;\\n               if(vec2[p2].second==0 && vec1[p3].second==0){\\n                  p2++;\\n                  p3--;\\n               }\\n               else if(vec2[p2].second==0){\\n                   p2++;\\n               }\\n               else if(vec1[p3].second==0){\\n                  p3--;\\n               }\\n             }\\n          }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        int min_val=INT_MAX;\\n        vector<pair<int,int>> vec1;\\n        vector<pair<int,int>> vec2;\\n        map<int,int> mp1;\\n        map<int,int> mp2;\\n        for(int i=0;i<basket1.size();i++){\\n            min_val=min(basket1[i],min_val);\\n            mp1[basket1[i]]+=1;\\n        }\\n        for(int i=0;i<basket2.size();i++){\\n            min_val=min(basket2[i],min_val);\\n            mp2[basket2[i]]+=1;\\n        }\\n        long long check1=0;\\n        long long check2=0;\\n        for(auto it:mp2){\\n            int val1=it.second;\\n            int val2=mp1[it.first];\\n            if(val1>val2){\\n                int a=val1-val2;\\n                if(a%2){\\n                    return -1;\\n                }\\n                check2+=a;\\n                vec2.push_back(make_pair(it.first,a));\\n            }\\n            else if(val1<val2){\\n                int a=val2-val1;\\n                if(a%2){\\n                    return -1;\\n                }\\n                check1+=a;\\n                vec1.push_back(make_pair(it.first,a));\\n            }\\n        }\\n        for(auto it:mp1){\\n            int val1=it.second;\\n            int val2=mp2[it.first];\\n            if(val2==0){\\n                int a=val1-val2;\\n                if(a%2){\\n                    return -1;\\n                }\\n                check1+=a;\\n                vec1.push_back(make_pair(it.first,a));\\n            }\\n        }\\n        if(check1!=check2){\\n            return -1;\\n        }\\n        long long ans=0;\\n        int p1=0;\\n        int p2=0;\\n        int p3=vec1.size()-1;\\n        int p4=vec2.size()-1;\\n        while((p1<=p3)&&(p2<=p4)){\\n          if(vec1[p1].first<vec2[p2].first){\\n             if(vec1[p1].first<2*min_val){\\n               int b=min(vec1[p1].second,vec2[p4].second);\\n               ans+=(long long)(b/2)*vec1[p1].first;\\n               vec1[p1].second=vec1[p1].second-b;\\n               vec2[p4].second=vec2[p4].second-b;\\n               if(vec1[p1].second==0 && vec2[p4].second==0){\\n                  p1++;\\n                  p4--;\\n               }\\n               else if(vec1[p1].second==0){\\n                   p1++;\\n               }\\n               else if(vec2[p4].second==0){\\n                  p4--;\\n               }\\n             }\\n             else{\\n                int b=min(vec1[p1].second,vec2[p4].second);\\n               ans+=(long long)(b/2)*(2*min_val);\\n               vec1[p1].second=vec1[p1].second-b;\\n               vec2[p4].second=vec2[p4].second-b;\\n               if(vec1[p1].second==0 &&  vec2[p4].second==0){\\n                  p1++;\\n                  p4--;\\n               }\\n               else if(vec1[p1].second==0){\\n                   p1++;\\n               }\\n               else if(vec2[p4].second==0){\\n                  p4--;\\n               }\\n             }\\n          }\\n          else{\\n             if(vec2[p2].first<2*min_val){\\n               int b=min(vec2[p2].second,vec1[p3].second);\\n               ans+=(long long)(b/2)*vec2[p2].first;\\n               vec2[p2].second=vec2[p2].second-b;\\n               vec1[p3].second=vec1[p3].second-b;\\n               if(vec2[p2].second==0 && vec1[p3].second==0){\\n                  p2++;\\n                  p3--;\\n               }\\n               else if(vec2[p2].second==0){\\n                   p2++;\\n               }\\n               else if(vec1[p3].second==0){\\n                  p3--;\\n               }\\n             }\\n             else{\\n                int b=min(vec2[p2].second,vec1[p3].second);\\n               ans+=(long long)(b/2)*(2*min_val);\\n               vec2[p2].second=vec2[p2].second-b;\\n               vec1[p3].second=vec1[p3].second-b;\\n               if(vec2[p2].second==0 && vec1[p3].second==0){\\n                  p2++;\\n                  p3--;\\n               }\\n               else if(vec2[p2].second==0){\\n                   p2++;\\n               }\\n               else if(vec1[p3].second==0){\\n                  p3--;\\n               }\\n             }\\n          }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146737,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& v1, vector<int>& v2) {\\n        unordered_map<int,int> m;\\n        for(auto x:v1) m[x]++;\\n        for(auto x:v2) m[x]--;\\n        vector<int> v;\\n        for(auto [x, n]:m){\\n            if(n % 2 != 0) return -1;\\n            for(int i=0;i<abs(n)/2;i++) v.push_back(x);\\n        }\\n        sort(v.begin(), v.end());\\n        const int xmin = min(*min_element(v1.begin(), v1.end()), *min_element(v2.begin(), v2.end()));\\n        long long res = 0;\\n        for(int i=0;i<v.size()/2;i++){\\n            res += min(xmin*2, v[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& v1, vector<int>& v2) {\\n        unordered_map<int,int> m;\\n        for(auto x:v1) m[x]++;\\n        for(auto x:v2) m[x]--;\\n        vector<int> v;\\n        for(auto [x, n]:m){\\n            if(n % 2 != 0) return -1;\\n            for(int i=0;i<abs(n)/2;i++) v.push_back(x);\\n        }\\n        sort(v.begin(), v.end());\\n        const int xmin = min(*min_element(v1.begin(), v1.end()), *min_element(v2.begin(), v2.end()));\\n        long long res = 0;\\n        for(int i=0;i<v.size()/2;i++){\\n            res += min(xmin*2, v[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146516,
                "title": "rust-ordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) Removing common entries from both lists.\\n2) Loading the remaining entries into corresponding ordered map lists.\\n3) Selecting the smallest entries from the map list, marching them with the biggest entries from the other list. If the maximum matching number is 1, returning -1.\\n4) Removing the matching entries from both list.\\n5) Counting the cost of the swap. Assumw 2k is the number of the matching, the cost is either k * current smallest value, or 2 * k * overall smallest value.   \\n   \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution {\\n    pub fn min_cost(basket1: Vec<i32>, basket2: Vec<i32>) -> i64 {\\n        let mn = i32::min(*basket1.iter().min().unwrap(), *basket2.iter().min().unwrap()) as i64;\\n        let (mut mp1, mut mp2) = (BTreeMap::<i32, i32>::new(), BTreeMap::<i32, i32>::new());\\n\\n        for a in basket1 { *mp1.entry(a).or_insert(0) += 1; }\\n        for a in basket2 {\\n            if mp1.contains_key(&a) == false {\\n                *mp2.entry(a).or_insert(0) += 1;\\n                continue\\n            }\\n            if *mp1.get(&a).unwrap() == 1 { mp1.remove(&a); }\\n            else                          { *mp1.entry(a).or_insert(0) -= 1; }\\n        }\\n\\n        let mut ret = 0;\\n        while mp1.is_empty() == false {\\n            let (a, b) = (*mp1.keys().next().unwrap(), *mp2.keys().next().unwrap());\\n            let (c, d) = (*mp1.keys().next_back().unwrap(), *mp2.keys().next_back().unwrap());\\n            if a < b {\\n                let k = i32::min(*mp1.get(&a).unwrap() / 2, *mp2.get(&d).unwrap() / 2);\\n                if k == 0 { return -1 }\\n            \\n                if *mp1.get(&a).unwrap() == 2 * k { mp1.remove(&a); }\\n                else                              { *mp1.entry(a).or_insert(0) -= 2 * k; }\\n\\n                if *mp2.get(&d).unwrap() == 2 * k { mp2.remove(&d); }\\n                else                              { *mp2.entry(d).or_insert(0) -= 2 * k; }\\n\\n                ret += i64::min((a as i64) * k as i64, mn * 2 * k as i64);\\n            }  else {\\n                let k = i32::min(*mp2.get(&b).unwrap() / 2, *mp1.get(&c).unwrap() / 2);\\n                if k == 0 { return -1 }\\n\\n                if *mp2.get(&b).unwrap() == 2 * k { mp2.remove(&b); }\\n                else                              { *mp2.entry(b).or_insert(0) -= 2 * k; }\\n\\n                if *mp1.get(&c).unwrap() == 2 * k { mp1.remove(&c); }\\n                else            { *mp1.entry(c).or_insert(0) -= 2 * k; }\\n\\n                ret += i64::min((b as i64) * k as i64, mn * 2 * k as i64);\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution {\\n    pub fn min_cost(basket1: Vec<i32>, basket2: Vec<i32>) -> i64 {\\n        let mn = i32::min(*basket1.iter().min().unwrap(), *basket2.iter().min().unwrap()) as i64;\\n        let (mut mp1, mut mp2) = (BTreeMap::<i32, i32>::new(), BTreeMap::<i32, i32>::new());\\n\\n        for a in basket1 { *mp1.entry(a).or_insert(0) += 1; }\\n        for a in basket2 {\\n            if mp1.contains_key(&a) == false {\\n                *mp2.entry(a).or_insert(0) += 1;\\n                continue\\n            }\\n            if *mp1.get(&a).unwrap() == 1 { mp1.remove(&a); }\\n            else                          { *mp1.entry(a).or_insert(0) -= 1; }\\n        }\\n\\n        let mut ret = 0;\\n        while mp1.is_empty() == false {\\n            let (a, b) = (*mp1.keys().next().unwrap(), *mp2.keys().next().unwrap());\\n            let (c, d) = (*mp1.keys().next_back().unwrap(), *mp2.keys().next_back().unwrap());\\n            if a < b {\\n                let k = i32::min(*mp1.get(&a).unwrap() / 2, *mp2.get(&d).unwrap() / 2);\\n                if k == 0 { return -1 }\\n            \\n                if *mp1.get(&a).unwrap() == 2 * k { mp1.remove(&a); }\\n                else                              { *mp1.entry(a).or_insert(0) -= 2 * k; }\\n\\n                if *mp2.get(&d).unwrap() == 2 * k { mp2.remove(&d); }\\n                else                              { *mp2.entry(d).or_insert(0) -= 2 * k; }\\n\\n                ret += i64::min((a as i64) * k as i64, mn * 2 * k as i64);\\n            }  else {\\n                let k = i32::min(*mp2.get(&b).unwrap() / 2, *mp1.get(&c).unwrap() / 2);\\n                if k == 0 { return -1 }\\n\\n                if *mp2.get(&b).unwrap() == 2 * k { mp2.remove(&b); }\\n                else                              { *mp2.entry(b).or_insert(0) -= 2 * k; }\\n\\n                if *mp1.get(&c).unwrap() == 2 * k { mp1.remove(&c); }\\n                else            { *mp1.entry(c).or_insert(0) -= 2 * k; }\\n\\n                ret += i64::min((b as i64) * k as i64, mn * 2 * k as i64);\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3146013,
                "title": "solution",
                "content": "```C++ []\\nstatic const auto init = []{\\n    cin.tie(nullptr);\\n    ios::sync_with_stdio(false);\\n    return false;\\n}();\\n\\nclass Solution {\\npublic:\\n\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> diff;\\n        int n = basket1.size();\\n        long long minelem = INT_MAX;\\n        int oddcnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            ++diff[basket1[i]];\\n            --diff[basket2[i]];\\n            minelem = min(minelem, (long long)min(basket1[i], basket2[i]));\\n        }\\n\\n        vector<int> lack_extra;\\n        for (auto & [k, v]: diff) {\\n            if (v % 2) return -1;\\n            int upper = abs(v)/2;\\n            for (int i = 0; i < upper; ++i) {lack_extra.push_back(k);}\\n        }\\n        \\n        int sz = lack_extra.size()/2;\\n        long long res = 0;\\n\\n        nth_element(begin(lack_extra), begin(lack_extra)+sz, end(lack_extra));\\n        for (int i = 0; i < sz; ++i) {\\n            res += lack_extra[i] > minelem*2?minelem<<1:lack_extra[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        m = min(min(basket1), min(basket2))\\n        f1 = Counter(basket1)\\n        f2 = Counter(basket2)\\n        basket1.sort()\\n        basket2.sort()\\n        i = len(basket2)-1\\n        ans = 0 \\n        for x in basket1: \\n            if f1[x] > f2[x]: \\n                while 0 <= i and f1[basket2[i]] >= f2[basket2[i]]: i -= 1\\n                if 0 <= i: \\n                    ans += min(x, basket2[i], 2*m)\\n                    f1[x] -= 1\\n                    f2[x] += 1\\n                    f2[basket2[i]] -= 1\\n                    f1[basket2[i]] += 1\\n                else: return -1 \\n        if f1 != f2: return -1 \\n        return ans \\n```\\n\\n```Java []\\nclass Solution {\\n\\tprivate static class Fruit implements Comparable<Fruit> {\\n\\t\\tint cost;\\n\\t\\tint count;\\n\\t\\tFruit next;\\n\\n\\t\\tFruit(int cost, Fruit next) {\\n\\t\\t\\tthis.cost = cost;\\n\\t\\t\\tthis.next = next;\\n\\t\\t}\\n\\n\\t\\tpublic int compareTo(Fruit other) {\\n\\t\\t\\treturn other.cost - cost;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class Garden implements Iterable<Fruit> {\\n\\t\\tfinal int n;\\n\\t\\tfinal Fruit[] trees;\\n\\t\\tint size;\\n\\t\\tint minCost = Integer.MAX_VALUE;\\n\\n\\t\\tGarden(int capacity) {\\n\\t\\t\\tn = capacity + 17;\\n\\t\\t\\ttrees = new Fruit[n];\\n\\t\\t}\\n\\n\\t\\tFruit pickOrGrow(int cost) {\\n\\t\\t\\tint treeIndex = cost % n;\\n\\t\\t\\tFruit first = trees[treeIndex];\\n\\t\\t\\tFruit fruit = first;\\n\\t\\t\\twhile (fruit != null && fruit.cost != cost)\\n\\t\\t\\t\\tfruit = fruit.next;\\n\\t\\t\\tif (fruit == null) {\\n\\t\\t\\t\\ttrees[treeIndex] = fruit = new Fruit(cost, first);\\n\\t\\t\\t\\tsize++;\\n\\t\\t\\t\\tif (cost < minCost)\\n\\t\\t\\t\\t\\tminCost = cost;\\n\\t\\t\\t}\\n\\t\\t\\treturn fruit;\\n\\t\\t}\\n\\n\\t\\tint size() {\\n\\t\\t\\treturn size;\\n\\t\\t}\\n\\n\\t\\tpublic Iterator<Fruit> iterator() {\\n\\t\\t\\treturn new Iterator<Fruit>() {\\n\\t\\t\\t\\tint treeIndex = -1;\\n\\t\\t\\t\\tFruit currentFruit;\\n\\n\\t\\t\\t\\tpublic boolean hasNext() {\\n\\t\\t\\t\\t\\twhile (currentFruit == null) {\\n\\t\\t\\t\\t\\t\\tif (++treeIndex == n)\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\tcurrentFruit = trees[treeIndex];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tpublic Fruit next() {\\n\\t\\t\\t\\t\\tif (!hasNext())\\n\\t\\t\\t\\t\\t\\tthrow new java.util.NoSuchElementException();\\n\\t\\t\\t\\t\\tFruit result = currentFruit;\\n\\t\\t\\t\\t\\tcurrentFruit = currentFruit.next;\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\tint minCost() {\\n\\t\\t\\treturn minCost;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static long minCost(int[] basket1, int[] basket2) {\\n\\t\\tGarden garden = new Garden(basket1.length << 1);\\n\\t\\tint count = 1;\\n\\t\\tfor (int[] basket : new int[][] { basket1, basket2 }) {\\n\\t\\t\\tfor (int cost : basket)\\n\\t\\t\\t\\tgarden.pickOrGrow(cost).count += count;\\n\\t\\t\\tcount = -count;\\n\\t\\t}\\n\\t\\tint mCost = garden.minCost() << 1;\\n\\t\\tlong result = 0;\\n\\t\\tint movedFruits = 0;\\n\\t\\tint remainingSwaps = 0;\\n\\t\\tList<Fruit> cheapFruits = new ArrayList<>(garden.size());\\n\\t\\tfor (Fruit fruit : garden) {\\n\\t\\t\\tint balance = fruit.count;\\n\\t\\t\\tif (balance == 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif ((balance & 1) != 0)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tmovedFruits += count = Math.abs(balance) >> 1;\\n\\t\\t\\tif (fruit.cost < mCost) {\\n\\t\\t\\t\\tresult += count * (long) fruit.cost;\\n\\t\\t\\t\\tremainingSwaps -= fruit.count = count;\\n\\t\\t\\t\\tcheapFruits.add(fruit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tremainingSwaps += movedFruits >> 1;\\n\\t\\tif (remainingSwaps >= 0)\\n\\t\\t\\treturn result + remainingSwaps * (long) mCost;\\n\\t\\tQueue<Fruit> queue = new PriorityQueue<>(cheapFruits);\\n\\t\\tFruit fruit;\\n\\t\\tdo {\\n\\t\\t\\tfruit = queue.poll();\\n\\t\\t\\tresult -= fruit.count * (long) fruit.cost;\\n\\t\\t} while ((remainingSwaps += fruit.count) < 0);\\n\\t\\treturn result + remainingSwaps * (long) fruit.cost;\\n\\t}\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nstatic const auto init = []{\\n    cin.tie(nullptr);\\n    ios::sync_with_stdio(false);\\n    return false;\\n}();\\n\\nclass Solution {\\npublic:\\n\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> diff;\\n        int n = basket1.size();\\n        long long minelem = INT_MAX;\\n        int oddcnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            ++diff[basket1[i]];\\n            --diff[basket2[i]];\\n            minelem = min(minelem, (long long)min(basket1[i], basket2[i]));\\n        }\\n\\n        vector<int> lack_extra;\\n        for (auto & [k, v]: diff) {\\n            if (v % 2) return -1;\\n            int upper = abs(v)/2;\\n            for (int i = 0; i < upper; ++i) {lack_extra.push_back(k);}\\n        }\\n        \\n        int sz = lack_extra.size()/2;\\n        long long res = 0;\\n\\n        nth_element(begin(lack_extra), begin(lack_extra)+sz, end(lack_extra));\\n        for (int i = 0; i < sz; ++i) {\\n            res += lack_extra[i] > minelem*2?minelem<<1:lack_extra[i];\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        m = min(min(basket1), min(basket2))\\n        f1 = Counter(basket1)\\n        f2 = Counter(basket2)\\n        basket1.sort()\\n        basket2.sort()\\n        i = len(basket2)-1\\n        ans = 0 \\n        for x in basket1: \\n            if f1[x] > f2[x]: \\n                while 0 <= i and f1[basket2[i]] >= f2[basket2[i]]: i -= 1\\n                if 0 <= i: \\n                    ans += min(x, basket2[i], 2*m)\\n                    f1[x] -= 1\\n                    f2[x] += 1\\n                    f2[basket2[i]] -= 1\\n                    f1[basket2[i]] += 1\\n                else: return -1 \\n        if f1 != f2: return -1 \\n        return ans \\n```\n```Java []\\nclass Solution {\\n\\tprivate static class Fruit implements Comparable<Fruit> {\\n\\t\\tint cost;\\n\\t\\tint count;\\n\\t\\tFruit next;\\n\\n\\t\\tFruit(int cost, Fruit next) {\\n\\t\\t\\tthis.cost = cost;\\n\\t\\t\\tthis.next = next;\\n\\t\\t}\\n\\n\\t\\tpublic int compareTo(Fruit other) {\\n\\t\\t\\treturn other.cost - cost;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class Garden implements Iterable<Fruit> {\\n\\t\\tfinal int n;\\n\\t\\tfinal Fruit[] trees;\\n\\t\\tint size;\\n\\t\\tint minCost = Integer.MAX_VALUE;\\n\\n\\t\\tGarden(int capacity) {\\n\\t\\t\\tn = capacity + 17;\\n\\t\\t\\ttrees = new Fruit[n];\\n\\t\\t}\\n\\n\\t\\tFruit pickOrGrow(int cost) {\\n\\t\\t\\tint treeIndex = cost % n;\\n\\t\\t\\tFruit first = trees[treeIndex];\\n\\t\\t\\tFruit fruit = first;\\n\\t\\t\\twhile (fruit != null && fruit.cost != cost)\\n\\t\\t\\t\\tfruit = fruit.next;\\n\\t\\t\\tif (fruit == null) {\\n\\t\\t\\t\\ttrees[treeIndex] = fruit = new Fruit(cost, first);\\n\\t\\t\\t\\tsize++;\\n\\t\\t\\t\\tif (cost < minCost)\\n\\t\\t\\t\\t\\tminCost = cost;\\n\\t\\t\\t}\\n\\t\\t\\treturn fruit;\\n\\t\\t}\\n\\n\\t\\tint size() {\\n\\t\\t\\treturn size;\\n\\t\\t}\\n\\n\\t\\tpublic Iterator<Fruit> iterator() {\\n\\t\\t\\treturn new Iterator<Fruit>() {\\n\\t\\t\\t\\tint treeIndex = -1;\\n\\t\\t\\t\\tFruit currentFruit;\\n\\n\\t\\t\\t\\tpublic boolean hasNext() {\\n\\t\\t\\t\\t\\twhile (currentFruit == null) {\\n\\t\\t\\t\\t\\t\\tif (++treeIndex == n)\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\tcurrentFruit = trees[treeIndex];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tpublic Fruit next() {\\n\\t\\t\\t\\t\\tif (!hasNext())\\n\\t\\t\\t\\t\\t\\tthrow new java.util.NoSuchElementException();\\n\\t\\t\\t\\t\\tFruit result = currentFruit;\\n\\t\\t\\t\\t\\tcurrentFruit = currentFruit.next;\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\n\\t\\tint minCost() {\\n\\t\\t\\treturn minCost;\\n\\t\\t}\\n\\t}\\n\\n\\tpublic static long minCost(int[] basket1, int[] basket2) {\\n\\t\\tGarden garden = new Garden(basket1.length << 1);\\n\\t\\tint count = 1;\\n\\t\\tfor (int[] basket : new int[][] { basket1, basket2 }) {\\n\\t\\t\\tfor (int cost : basket)\\n\\t\\t\\t\\tgarden.pickOrGrow(cost).count += count;\\n\\t\\t\\tcount = -count;\\n\\t\\t}\\n\\t\\tint mCost = garden.minCost() << 1;\\n\\t\\tlong result = 0;\\n\\t\\tint movedFruits = 0;\\n\\t\\tint remainingSwaps = 0;\\n\\t\\tList<Fruit> cheapFruits = new ArrayList<>(garden.size());\\n\\t\\tfor (Fruit fruit : garden) {\\n\\t\\t\\tint balance = fruit.count;\\n\\t\\t\\tif (balance == 0)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tif ((balance & 1) != 0)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tmovedFruits += count = Math.abs(balance) >> 1;\\n\\t\\t\\tif (fruit.cost < mCost) {\\n\\t\\t\\t\\tresult += count * (long) fruit.cost;\\n\\t\\t\\t\\tremainingSwaps -= fruit.count = count;\\n\\t\\t\\t\\tcheapFruits.add(fruit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tremainingSwaps += movedFruits >> 1;\\n\\t\\tif (remainingSwaps >= 0)\\n\\t\\t\\treturn result + remainingSwaps * (long) mCost;\\n\\t\\tQueue<Fruit> queue = new PriorityQueue<>(cheapFruits);\\n\\t\\tFruit fruit;\\n\\t\\tdo {\\n\\t\\t\\tfruit = queue.poll();\\n\\t\\t\\tresult -= fruit.count * (long) fruit.cost;\\n\\t\\t} while ((remainingSwaps += fruit.count) < 0);\\n\\t\\treturn result + remainingSwaps * (long) fruit.cost;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145749,
                "title": "btreemap-and-two-ways-to-swap-approach-in-rust",
                "content": "# Approach\\nRust version of the following [great solution](https://leetcode.com/problems/rearranging-fruits/solutions/3143917/java-c-python-two-ways-to-swap/) with explanation.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_cost(basket1: Vec<i32>, basket2: Vec<i32>) -> i64 {\\n        let costs = std::collections::BTreeMap::<i32, i32>::new();\\n        let costs = basket1.iter().fold(costs, |mut costs, &cost| { *costs.entry(cost).or_insert(0) += 1; costs });\\n        let costs = basket2.iter().fold(costs, |mut costs, &cost| { *costs.entry(cost).or_insert(0) -= 1; costs });\\n        let mut swaps = Vec::<i32>::new();\\n        for (cost, count) in costs.iter().map(|(&cost, &count)| (cost, count.abs() as usize)) {\\n            if count & 1 > 0 {\\n                return -1;\\n            }\\n            swaps.extend(std::iter::repeat(cost).take(count >> 1));\\n        }\\n        let mut cost = 0;\\n        if let Some(small) = costs.keys().next().map(|&val| val as i64) {\\n            for swap in swaps.iter().take(swaps.len() >> 1).map(|&val| val as i64) {\\n                cost += swap.min(2 * small);\\n            }\\n        }\\n\\n        cost\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_cost(basket1: Vec<i32>, basket2: Vec<i32>) -> i64 {\\n        let costs = std::collections::BTreeMap::<i32, i32>::new();\\n        let costs = basket1.iter().fold(costs, |mut costs, &cost| { *costs.entry(cost).or_insert(0) += 1; costs });\\n        let costs = basket2.iter().fold(costs, |mut costs, &cost| { *costs.entry(cost).or_insert(0) -= 1; costs });\\n        let mut swaps = Vec::<i32>::new();\\n        for (cost, count) in costs.iter().map(|(&cost, &count)| (cost, count.abs() as usize)) {\\n            if count & 1 > 0 {\\n                return -1;\\n            }\\n            swaps.extend(std::iter::repeat(cost).take(count >> 1));\\n        }\\n        let mut cost = 0;\\n        if let Some(small) = costs.keys().next().map(|&val| val as i64) {\\n            for swap in swaps.iter().take(swaps.len() >> 1).map(|&val| val as i64) {\\n                cost += swap.min(2 * small);\\n            }\\n        }\\n\\n        cost\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3145488,
                "title": "map-set-c-easy-solution",
                "content": "**Please Upvote My Solution**\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2)\\n    {\\n        set<int> unique_elements;\\n        map<int,int> freq1,freq2;\\n        \\n        for(auto it : basket1)\\n            freq1[it]++,unique_elements.insert(it);\\n        for(auto it : basket2)\\n            freq2[it]++,unique_elements.insert(it);\\n        \\n        int mini = *min_element(unique_elements.begin(),unique_elements.end());\\n        vector<int> diff1,diff2;\\n        \\n        for(auto element : unique_elements)\\n        {\\n            int f1 = freq1[element];\\n            int f2 = freq2[element];\\n            \\n            if(f1==f2) continue;\\n            int diff = abs(f1-f2);\\n            if(diff%2!=0) return -1;\\n            \\n            if(f1>f2)\\n            {\\n                for(int i=0;i<diff/2;i++)\\n                    diff1.push_back(element);\\n            }\\n            else\\n            {\\n                for(int i=0;i<diff/2;i++)\\n                    diff2.push_back(element);\\n            }\\n        }\\n        \\n        if(diff1.size() != diff2.size()) return -1;\\n        reverse(diff2.begin(),diff2.end());\\n        \\n        int n = diff1.size();\\n        long long cost = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cost+=(long)min(mini*2, min(diff2[i],diff1[i]));\\n        }\\n        \\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2)\\n    {\\n        set<int> unique_elements;\\n        map<int,int> freq1,freq2;\\n        \\n        for(auto it : basket1)\\n            freq1[it]++,unique_elements.insert(it);\\n        for(auto it : basket2)\\n            freq2[it]++,unique_elements.insert(it);\\n        \\n        int mini = *min_element(unique_elements.begin(),unique_elements.end());\\n        vector<int> diff1,diff2;\\n        \\n        for(auto element : unique_elements)\\n        {\\n            int f1 = freq1[element];\\n            int f2 = freq2[element];\\n            \\n            if(f1==f2) continue;\\n            int diff = abs(f1-f2);\\n            if(diff%2!=0) return -1;\\n            \\n            if(f1>f2)\\n            {\\n                for(int i=0;i<diff/2;i++)\\n                    diff1.push_back(element);\\n            }\\n            else\\n            {\\n                for(int i=0;i<diff/2;i++)\\n                    diff2.push_back(element);\\n            }\\n        }\\n        \\n        if(diff1.size() != diff2.size()) return -1;\\n        reverse(diff2.begin(),diff2.end());\\n        \\n        int n = diff1.size();\\n        long long cost = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            cost+=(long)min(mini*2, min(diff2[i],diff1[i]));\\n        }\\n        \\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145296,
                "title": "greedy-strategy-analysis",
                "content": "We\\'ll work backwards from the end goal to the start of the implementation.\\n\\n### Analysis\\n\\nLet\\'s think about the problem\\'s properties, and take advantage of it as much as possible.\\nReally pay attention to `min(basket1[i], basket2[j])` for the cost, which means we want to use this as much as possible.\\nAlso keep in mind the order of the array doesn\\'t matter.\\n\\nConsider we have two baskets in sorted order, what that means is if we know which numbers to swap, we want to ensure our minimum is as low as possible. **Our strategy is to use two pointers to track which numbers to swap, one starts with lowest and other with highest**. This can be visualized like below:\\n```\\ni=1, j=10\\ni=2, j=9\\ni=3, j=8\\n...\\ni=6, j=5\\n...\\n```\\nWhat I\\'m trying to show is by using this two pointer strategy, **we keep the minimum number to swap in the pair to at most `(max_elem-min_elem)/2`**. This also keeps the minimum as low as possible at all times.\\n\\nThere\\'s one other way to swap two pairs of numbers, and that\\'s **using the minimum number twice**. Consider the following:\\n```\\nbasket1=[8,10000,20000,20000,20000]\\nbasket2=[8,10000,10000,10000,20000]\\nwe have to swap numbers (10000,20000)\\nif we swap (10000,20000) naively, the cost will be 10000, since min(10000,20000)=10000\\nhowever, we can swap (8,10000) and swap (8,20000), the cost will be 16, since min(8,10000)+min(8,20000)=8+8=16\\n```\\nSo the line below is doing precisely that (`basket1` and `basket2` is sorted at this point):\\n```cpp\\nans += min(min(basket1[0], basket2[0]) * 2, min(basket1[i], basket2[j]));\\n```\\n\\nNow with the strategy out of the way, how do we check if it\\'s possible to make both baskets equal?\\nIf both baskets are the same, that means the frequency of each element in both baskets are the same. **Which means the frequency of each number has to be even, since any number doubled (being in both baskets) is an even number**. So, this code counts that:\\n```cpp\\n    unordered_map<int, int> cnt, cnt1, cnt2;\\n    for (int v : basket1) {\\n      cnt[v]++;\\n      cnt1[v]++; // not for checking if possible, used later\\n    }\\n    for (int v : basket2) {\\n      cnt[v]++;\\n      cnt2[v]++; // not for checking if possible, used later\\n    }\\n    for (auto [_, k] : cnt) {\\n      if (k & 1) {\\n        return -1;\\n      }\\n    }\\n```\\n\\n### Implementation Detail\\n\\nThe way I did my two pointer method was for pairs of numbers **that have frequency in their respective array more than half of the frequency in both arrays**. This means both numbers are \"extras\" in their arrays, and thus need to be swapped away.\\nWith that being said, I move the pointers in their opposite directions, skipping over numbers that don\\'t need to be swapped away (in other words, their frequency in their array is less or equal than half of their total frequency. Less than half means we have to keep the number, and we need more of the number from other array to level the frequency out).\\n```cpp\\n      while (i < n && cnt1[basket1[i]] <= cnt[basket1[i]] / 2) {\\n        i++;\\n      }\\n      while (j >= 0 && cnt2[basket2[j]] <= cnt[basket2[j]] / 2) {\\n        j--;\\n      }\\n```\\n\\n---\\n\\n```cpp\\n#define all(x) x.begin(), x.end()\\n\\nclass Solution {\\npublic:\\n  long long minCost(vector<int> &basket1, vector<int> &basket2) {\\n    int n = basket1.size();\\n\\n    unordered_map<int, int> cnt, cnt1, cnt2;\\n    for (int v : basket1) {\\n      cnt[v]++;\\n      cnt1[v]++;\\n    }\\n    for (int v : basket2) {\\n      cnt[v]++;\\n      cnt2[v]++;\\n    }\\n    for (auto [_, k] : cnt) {\\n      if (k & 1) {\\n        return -1;\\n      }\\n    }\\n    \\n    sort(all(basket1));\\n    sort(all(basket2));\\n\\n    long long ans = 0;\\n    int i = 0, j = n - 1;\\n    while (true) {\\n      while (i < n && cnt1[basket1[i]] <= cnt[basket1[i]] / 2) {\\n        i++;\\n      }\\n      while (j >= 0 && cnt2[basket2[j]] <= cnt[basket2[j]] / 2) {\\n        j--;\\n      }\\n      if (i == n || j == 0) {\\n        break;\\n      }\\n\\n      ans += min(min(basket1[0], basket2[0]) * 2, min(basket1[i], basket2[j]));\\n      cnt1[basket1[i++]]--;\\n      cnt2[basket2[j--]]--;\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\ni=1, j=10\\ni=2, j=9\\ni=3, j=8\\n...\\ni=6, j=5\\n...\\n```\n```\\nbasket1=[8,10000,20000,20000,20000]\\nbasket2=[8,10000,10000,10000,20000]\\nwe have to swap numbers (10000,20000)\\nif we swap (10000,20000) naively, the cost will be 10000, since min(10000,20000)=10000\\nhowever, we can swap (8,10000) and swap (8,20000), the cost will be 16, since min(8,10000)+min(8,20000)=8+8=16\\n```\n```cpp\\nans += min(min(basket1[0], basket2[0]) * 2, min(basket1[i], basket2[j]));\\n```\n```cpp\\n    unordered_map<int, int> cnt, cnt1, cnt2;\\n    for (int v : basket1) {\\n      cnt[v]++;\\n      cnt1[v]++; // not for checking if possible, used later\\n    }\\n    for (int v : basket2) {\\n      cnt[v]++;\\n      cnt2[v]++; // not for checking if possible, used later\\n    }\\n    for (auto [_, k] : cnt) {\\n      if (k & 1) {\\n        return -1;\\n      }\\n    }\\n```\n```cpp\\n      while (i < n && cnt1[basket1[i]] <= cnt[basket1[i]] / 2) {\\n        i++;\\n      }\\n      while (j >= 0 && cnt2[basket2[j]] <= cnt[basket2[j]] / 2) {\\n        j--;\\n      }\\n```\n```cpp\\n#define all(x) x.begin(), x.end()\\n\\nclass Solution {\\npublic:\\n  long long minCost(vector<int> &basket1, vector<int> &basket2) {\\n    int n = basket1.size();\\n\\n    unordered_map<int, int> cnt, cnt1, cnt2;\\n    for (int v : basket1) {\\n      cnt[v]++;\\n      cnt1[v]++;\\n    }\\n    for (int v : basket2) {\\n      cnt[v]++;\\n      cnt2[v]++;\\n    }\\n    for (auto [_, k] : cnt) {\\n      if (k & 1) {\\n        return -1;\\n      }\\n    }\\n    \\n    sort(all(basket1));\\n    sort(all(basket2));\\n\\n    long long ans = 0;\\n    int i = 0, j = n - 1;\\n    while (true) {\\n      while (i < n && cnt1[basket1[i]] <= cnt[basket1[i]] / 2) {\\n        i++;\\n      }\\n      while (j >= 0 && cnt2[basket2[j]] <= cnt[basket2[j]] / 2) {\\n        j--;\\n      }\\n      if (i == n || j == 0) {\\n        break;\\n      }\\n\\n      ans += min(min(basket1[0], basket2[0]) * 2, min(basket1[i], basket2[j]));\\n      cnt1[basket1[i++]]--;\\n      cnt2[basket2[j--]]--;\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144979,
                "title": "o-n",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> cnt;\\n        for (auto c: basket1) cnt[c]++;\\n        for (auto c: basket2) cnt[c]--;\\n        vector<int> last;\\n        int minx = min(*min_element(basket1.begin(), basket1.end()), *min_element(basket2.begin(), basket2.end()));\\n        for (auto &[k, v]: cnt) {\\n            if (v % 2) return -1;\\n            for (int i = 0; i < abs(v) / 2; ++i) last.push_back(k);\\n        }\\n        sort(last.begin(), last.end());\\n        long long res = 0;\\n        for (int i = 0; i < last.size() / 2; ++i)\\n            res += min(last[i], minx * 2);\\n        return res;\\n    }\\n};\\n```\\n# Java\\n```\\nclass Solution {\\n    public long minCost(int[] A, int[] B) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.merge(a, 1, Integer::sum);\\n        for (int b : B)\\n            count.merge(b, -1, Integer::sum);\\n        List<Integer> swaps = new ArrayList<>();\\n        long res = 0, small = Integer.MAX_VALUE;\\n        for (int a : count.keySet()) {\\n            if (count.get(a) % 2 > 0) return -1;\\n            int v = Math.abs(count.get(a)) / 2;\\n            for (int i = 0; i < v; ++i)\\n                swaps.add(a);\\n            small = Math.min(small, a);\\n        }\\n        Collections.sort(swaps);\\n        for (int i = 0; i < swaps.size() / 2; ++i)\\n            res += Math.min(swaps.get(i), small * 2);\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        unordered_map<int, int> cnt;\\n        for (auto c: basket1) cnt[c]++;\\n        for (auto c: basket2) cnt[c]--;\\n        vector<int> last;\\n        int minx = min(*min_element(basket1.begin(), basket1.end()), *min_element(basket2.begin(), basket2.end()));\\n        for (auto &[k, v]: cnt) {\\n            if (v % 2) return -1;\\n            for (int i = 0; i < abs(v) / 2; ++i) last.push_back(k);\\n        }\\n        sort(last.begin(), last.end());\\n        long long res = 0;\\n        for (int i = 0; i < last.size() / 2; ++i)\\n            res += min(last[i], minx * 2);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long minCost(int[] A, int[] B) {\\n        Map<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.merge(a, 1, Integer::sum);\\n        for (int b : B)\\n            count.merge(b, -1, Integer::sum);\\n        List<Integer> swaps = new ArrayList<>();\\n        long res = 0, small = Integer.MAX_VALUE;\\n        for (int a : count.keySet()) {\\n            if (count.get(a) % 2 > 0) return -1;\\n            int v = Math.abs(count.get(a)) / 2;\\n            for (int i = 0; i < v; ++i)\\n                swaps.add(a);\\n            small = Math.min(small, a);\\n        }\\n        Collections.sort(swaps);\\n        for (int i = 0; i < swaps.size() / 2; ++i)\\n            res += Math.min(swaps.get(i), small * 2);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144838,
                "title": "python-two-swap-stategy",
                "content": "# Intuition\\n\\nfirst, find all the num we need to swap\\n\\n1. count basket1, store extra value in `arr1`\\n2. count basket2, store extra value in `arr2`\\n3. if there exist num which can\\'t be split evenly, return `-1`\\n\\nthen we can greedily swap by pairing up minimum value in `arr1` with maximum value in `arr2`\\n\\nand there is still another strategy hard to come up with, we can swap value in `arr1` and `arr2` with minimum value.\\n\\nex. \\nminimum value = 4, arr1 = [24], arr2 = [28]\\n\\nif minimum value in arr1, we can swap `28` with minimum value first, then swap `24` with minimum value.\\n\\nin the end, minimum value is still in original array, and we cost `2 * minimum value` rather than `min(24, 28)`\\n\\ntherfore, we iterate through `arr1[i]` and choose `min(2 * minValue, min(arr1[i], arr2[n-1-i])` as cost.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        counter1 = Counter(basket1)\\n        counter2 = Counter(basket2)\\n        arr1 = []\\n        arr2 = []\\n        for k, v in counter1.items():\\n            if (v + counter2[k]) % 2 != 0: return -1\\n            \\n            extra = v - (v + counter2[k])//2\\n            while extra > 0:\\n                arr1.append(k)\\n                extra -= 1\\n        \\n        for k, v in counter2.items():\\n            if (v + counter1[k]) % 2 != 0: return -1\\n\\n            extra = v - (v + counter1[k])//2\\n            while extra > 0:\\n                arr2.append(k)\\n                extra -= 1\\n\\n        arr1.sort()\\n        arr2.sort()\\n\\n        minValue = min(min(basket1), min(basket2))\\n        minCost = 0\\n        n = len(arr1)\\n        for i in range(n):\\n            minCost += min(2*minValue, min(arr1[i], arr2[n-1-i]))\\n            \\n        return minCost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        counter1 = Counter(basket1)\\n        counter2 = Counter(basket2)\\n        arr1 = []\\n        arr2 = []\\n        for k, v in counter1.items():\\n            if (v + counter2[k]) % 2 != 0: return -1\\n            \\n            extra = v - (v + counter2[k])//2\\n            while extra > 0:\\n                arr1.append(k)\\n                extra -= 1\\n        \\n        for k, v in counter2.items():\\n            if (v + counter1[k]) % 2 != 0: return -1\\n\\n            extra = v - (v + counter1[k])//2\\n            while extra > 0:\\n                arr2.append(k)\\n                extra -= 1\\n\\n        arr1.sort()\\n        arr2.sort()\\n\\n        minValue = min(min(basket1), min(basket2))\\n        minCost = 0\\n        n = len(arr1)\\n        for i in range(n):\\n            minCost += min(2*minValue, min(arr1[i], arr2[n-1-i]))\\n            \\n        return minCost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144831,
                "title": "map-c-easy-commented-code",
                "content": "# Read comments to understand the code\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        \\n        //store total frequency of elements in mp\\n        map<int,int>mp;\\n        for(auto i:basket1)\\n            mp[i]++;\\n        for(auto i:basket2)\\n            mp[i]++;\\n\\n        //if any frequency is odd return -1\\n        for(auto i:mp)\\n        {\\n            if(i.second%2==1)\\n                return -1;\\n        }\\n        //convert basket 1 and 2 into maps a and b\\n        map<int,int>a;\\n        for(auto i:basket1)\\n            a[i]++;\\n        map<int,int>b;\\n        for(auto i:basket2)\\n            b[i]++;\\n        \\n        //store all extra elements of a in v1 \\n        vector<int>v1;\\n        for(auto i:a)\\n        {\\n            if(mp[i.first]/2<i.second)\\n            {\\n                for(int j=mp[i.first]/2;j<i.second;j++)\\n                    v1.push_back(i.first);\\n            }\\n        }\\n        //store all extra elements of a in v2\\n        vector<int>v2;\\n        for(auto i:b)\\n        {\\n            if(mp[i.first]/2<i.second)\\n            {\\n                for(int j=mp[i.first]/2;j<i.second;j++)\\n                    v2.push_back(i.first);\\n            }\\n        }\\n        //sort a and reverse sort b to select min of a and max of b at every step\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        reverse(v2.begin(),v2.end());\\n        \\n        //there is always a possibilty that you can swap with minimum element twice\\n        int mn=min(a.begin()->first,b.begin()->first); \\n        \\n        if(v1.size()!=v2.size())\\n            return -1;\\n\\n        //final answer\\n        long long ans=0;\\n        for(int i=0;i<v1.size();i++)\\n            ans+=min({2*mn,v1[i],v2[i]});\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        \\n        //store total frequency of elements in mp\\n        map<int,int>mp;\\n        for(auto i:basket1)\\n            mp[i]++;\\n        for(auto i:basket2)\\n            mp[i]++;\\n\\n        //if any frequency is odd return -1\\n        for(auto i:mp)\\n        {\\n            if(i.second%2==1)\\n                return -1;\\n        }\\n        //convert basket 1 and 2 into maps a and b\\n        map<int,int>a;\\n        for(auto i:basket1)\\n            a[i]++;\\n        map<int,int>b;\\n        for(auto i:basket2)\\n            b[i]++;\\n        \\n        //store all extra elements of a in v1 \\n        vector<int>v1;\\n        for(auto i:a)\\n        {\\n            if(mp[i.first]/2<i.second)\\n            {\\n                for(int j=mp[i.first]/2;j<i.second;j++)\\n                    v1.push_back(i.first);\\n            }\\n        }\\n        //store all extra elements of a in v2\\n        vector<int>v2;\\n        for(auto i:b)\\n        {\\n            if(mp[i.first]/2<i.second)\\n            {\\n                for(int j=mp[i.first]/2;j<i.second;j++)\\n                    v2.push_back(i.first);\\n            }\\n        }\\n        //sort a and reverse sort b to select min of a and max of b at every step\\n        sort(v1.begin(),v1.end());\\n        sort(v2.begin(),v2.end());\\n        reverse(v2.begin(),v2.end());\\n        \\n        //there is always a possibilty that you can swap with minimum element twice\\n        int mn=min(a.begin()->first,b.begin()->first); \\n        \\n        if(v1.size()!=v2.size())\\n            return -1;\\n\\n        //final answer\\n        long long ans=0;\\n        for(int i=0;i<v1.size();i++)\\n            ans+=min({2*mn,v1[i],v2[i]});\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144814,
                "title": "easy-c-solution-using-2-maps",
                "content": "\\n\\n# Complexity\\n- Time complexity: ```nlogn```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:```n```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n#define ff first\\n#define ss second\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<ll, int>mpb1, mpb2;\\n        int n = b1.size();\\n        vector<pll>v1, v2;\\n        for(int i= 0 ; i<n; i++){\\n            mpb1[b1[i]]++;\\n            mpb2[b2[i]]++;\\n        }\\n        int cnt = 0;\\n        for(auto &i: mpb1){\\n            if((i.ss+mpb2[i.ff])%2)return -1;\\n            if((i.ss-mpb2[i.ff]) > 0){\\n                cnt+=(i.ss-mpb2[i.ff]);\\n                v1.push_back({i.ff, (i.ss-mpb2[i.ff])/2});\\n            }\\n        }\\n        for(auto &i: mpb2){\\n            if((i.ss + mpb1[i.ff])%2)return -1;\\n            if((i.ss-mpb1[i.ff])> 0){\\n                cnt-=(i.ss-mpb1[i.ff]);\\n                v2.push_back({i.ff, (i.ss-mpb1[i.ff])/2});\\n            }\\n        }\\n        if(cnt != 0)return -1;\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end(), greater<pll>());\\n        int i = 0, j = 0, m = v2.size();\\n        n = v1.size();\\n        ll ans = 0, minval = min(mpb1.begin()->ff, mpb2.begin()->ff);\\n        while(j<m && i<n){\\n            ll mi = min(v1[i].ss, v2[j].ss);\\n            ans+=min(2*minval*mi, min(v1[i].ff, v2[j].ff)*mi);\\n            v1[i].ss-=mi;\\n            v2[j].ss-=mi;\\n            if(v1[i].ss == 0)i++;\\n            if(v2[j].ss == 0)j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```nlogn```\n```n```\n```\\n#define ll long long\\n#define ff first\\n#define ss second\\n#define pll pair<ll, ll>\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        map<ll, int>mpb1, mpb2;\\n        int n = b1.size();\\n        vector<pll>v1, v2;\\n        for(int i= 0 ; i<n; i++){\\n            mpb1[b1[i]]++;\\n            mpb2[b2[i]]++;\\n        }\\n        int cnt = 0;\\n        for(auto &i: mpb1){\\n            if((i.ss+mpb2[i.ff])%2)return -1;\\n            if((i.ss-mpb2[i.ff]) > 0){\\n                cnt+=(i.ss-mpb2[i.ff]);\\n                v1.push_back({i.ff, (i.ss-mpb2[i.ff])/2});\\n            }\\n        }\\n        for(auto &i: mpb2){\\n            if((i.ss + mpb1[i.ff])%2)return -1;\\n            if((i.ss-mpb1[i.ff])> 0){\\n                cnt-=(i.ss-mpb1[i.ff]);\\n                v2.push_back({i.ff, (i.ss-mpb1[i.ff])/2});\\n            }\\n        }\\n        if(cnt != 0)return -1;\\n        sort(v1.begin(), v1.end());\\n        sort(v2.begin(), v2.end(), greater<pll>());\\n        int i = 0, j = 0, m = v2.size();\\n        n = v1.size();\\n        ll ans = 0, minval = min(mpb1.begin()->ff, mpb2.begin()->ff);\\n        while(j<m && i<n){\\n            ll mi = min(v1[i].ss, v2[j].ss);\\n            ans+=min(2*minval*mi, min(v1[i].ff, v2[j].ff)*mi);\\n            v1[i].ss-=mi;\\n            v2[j].ss-=mi;\\n            if(v1[i].ss == 0)i++;\\n            if(v2[j].ss == 0)j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144730,
                "title": "solution-with-btreemap",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_cost(basket1: Vec<i32>, basket2: Vec<i32>) -> i64 {\\n        let mut m = std::collections::BTreeMap::<i64, i64>::new();\\n        for c in basket1 {\\n            *m.entry(c as i64).or_insert(0) += 1;\\n        }\\n        for c in basket2 {\\n            *m.entry(c as i64).or_insert(0) -= 1;\\n        }\\n        let mut swaps = 0;\\n        let mut res = 0;\\n        for &cnt in m.values() {\\n            if cnt % 2 != 0 {\\n                return -1;\\n            }\\n            swaps += (cnt / 2).max(0);\\n        }\\n        let first = *m.iter().next().unwrap().0;\\n        for (&c, &cnt) in &m {\\n            let take = swaps.min(cnt.abs() / 2);\\n            res += take * c.min(first * 2);\\n            swaps -= take;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_cost(basket1: Vec<i32>, basket2: Vec<i32>) -> i64 {\\n        let mut m = std::collections::BTreeMap::<i64, i64>::new();\\n        for c in basket1 {\\n            *m.entry(c as i64).or_insert(0) += 1;\\n        }\\n        for c in basket2 {\\n            *m.entry(c as i64).or_insert(0) -= 1;\\n        }\\n        let mut swaps = 0;\\n        let mut res = 0;\\n        for &cnt in m.values() {\\n            if cnt % 2 != 0 {\\n                return -1;\\n            }\\n            swaps += (cnt / 2).max(0);\\n        }\\n        let first = *m.iter().next().unwrap().0;\\n        for (&c, &cnt) in &m {\\n            let take = swaps.min(cnt.abs() / 2);\\n            res += take * c.min(first * 2);\\n            swaps -= take;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144555,
                "title": "use-java-linkedlist-will-get-tle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor anyone using same algorithm having the same issue\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic long minCost(int[] basket1, int[] basket2) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int min1 = (int)(1e9);\\n        for(int i: basket1){\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n            min1 = Math.min(min1, i);\\n        }\\n        for(int i: basket2){\\n            map.put(i, map.getOrDefault(i, 0) - 1);\\n            min1 = Math.min(min1, i);\\n        }\\n        \\n        List<Integer> tt = new ArrayList<>();//use LinkedList can\\'t pass\\'\\n        for(int i: map.keySet()){\\n            int key = Math.abs(map.get(i));\\n            if(key != 0){\\n                if(key % 2 != 0) return -1;\\n                for(int k = 0; k < key/2; k++){\\n                    tt.add(i);\\n                }\\n            }\\n        }\\n        Collections.sort(tt);\\n\\n        long res = 0;\\n        for(int i = 0; i < tt.size()/2; i++){\\n            res += Math.min(min1*2L, tt.get(i));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long minCost(int[] basket1, int[] basket2) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int min1 = (int)(1e9);\\n        for(int i: basket1){\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n            min1 = Math.min(min1, i);\\n        }\\n        for(int i: basket2){\\n            map.put(i, map.getOrDefault(i, 0) - 1);\\n            min1 = Math.min(min1, i);\\n        }\\n        \\n        List<Integer> tt = new ArrayList<>();//use LinkedList can\\'t pass\\'\\n        for(int i: map.keySet()){\\n            int key = Math.abs(map.get(i));\\n            if(key != 0){\\n                if(key % 2 != 0) return -1;\\n                for(int k = 0; k < key/2; k++){\\n                    tt.add(i);\\n                }\\n            }\\n        }\\n        Collections.sort(tt);\\n\\n        long res = 0;\\n        for(int i = 0; i < tt.size()/2; i++){\\n            res += Math.min(min1*2L, tt.get(i));\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144362,
                "title": "simple-c-map-greedy",
                "content": "# Simplest C++ Code\\n\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& a, vector<int>& b) {\\n        \\n        map<int,int> m,p,q;\\n        int mn = 1e9;\\n        for(auto x:a)\\n            m[x]++,q[x]++,mn = min(mn,x);\\n        for(auto x:b)\\n            m[x]++,p[x]++,mn = min(mn,x);\\n        for(auto x:m)\\n        {\\n            if(x.second%2)\\n                return -1;\\n        }\\n        vector<int> l,r;\\n        for(auto x:p)\\n        {\\n            int e = x.first;\\n            if(q[e]<p[e])\\n            {\\n                int j = (q[e]+p[e])/2 - q[e];\\n                while(j--)\\n                    l.push_back(e);\\n            }\\n        }\\n        for(auto x:q)\\n        {\\n            int e = x.first;\\n            if(p[e]<q[e])\\n            {\\n                int j = (q[e]+p[e])/2 - p[e];\\n                while(j--)\\n                    r.push_back(e);\\n            }\\n        }\\n        int y = l.size();\\n        reverse(r.begin(),r.end());\\n        long long ans= 0; \\n        for(int i=0;i<y;i++)\\n            ans+=min(mn*2,min(l[i],r[i]));\\n         \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& a, vector<int>& b) {\\n        \\n        map<int,int> m,p,q;\\n        int mn = 1e9;\\n        for(auto x:a)\\n            m[x]++,q[x]++,mn = min(mn,x);\\n        for(auto x:b)\\n            m[x]++,p[x]++,mn = min(mn,x);\\n        for(auto x:m)\\n        {\\n            if(x.second%2)\\n                return -1;\\n        }\\n        vector<int> l,r;\\n        for(auto x:p)\\n        {\\n            int e = x.first;\\n            if(q[e]<p[e])\\n            {\\n                int j = (q[e]+p[e])/2 - q[e];\\n                while(j--)\\n                    l.push_back(e);\\n            }\\n        }\\n        for(auto x:q)\\n        {\\n            int e = x.first;\\n            if(p[e]<q[e])\\n            {\\n                int j = (q[e]+p[e])/2 - p[e];\\n                while(j--)\\n                    r.push_back(e);\\n            }\\n        }\\n        int y = l.size();\\n        reverse(r.begin(),r.end());\\n        long long ans= 0; \\n        for(int i=0;i<y;i++)\\n            ans+=min(mn*2,min(l[i],r[i]));\\n         \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144213,
                "title": "hard-level-c-solution",
                "content": "\\n# Code\\n```\\ntypedef long long ll; \\nclass Solution { \\npublic: \\n    \\n     \\n    long long minCost(vector<int>& v1, vector<int>& v2) { \\n        map<ll,ll> m;         int n=v1.size(); \\n        ll x=v2[n-1]; \\n         \\n        for(int i=0;i<n;i++){ \\n            m[v1[i]]++; \\n            m[v2[i]]--; \\n        } \\n         \\n        bool flag=false; \\n        v1.clear(); \\n    v2.clear(); \\n    \\n    ll mi = x; \\n    \\n    for(auto i:m) \\n    { \\n     mi = min(mi, i.first); \\n     x = abs(i.second); \\n    \\n     if(x%2) \\n      flag = true; \\n    \\n     x = i.second; \\n    \\n     if(x > 0) \\n     { \\n      x /= 2; \\n    \\n      while(x--) \\n       v1.push_back(i.first); \\n     } \\n     else if(x < 0) \\n     { \\n      x = abs(x)/2; \\n    \\n      while(x--) \\n       v2.push_back(i.first); \\n     } \\n    }     \\n    if(flag) \\n    { \\n     return -1; \\n    }     \\n    reverse(v2.begin(),v2.end()); \\n    ll ans = 0;    \\n    for(int i=0;i<v1.size();i++) \\n     ans += min(2*mi,1ll*min(v1[i],v2[i]));    \\n    return ans;          \\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll; \\nclass Solution { \\npublic: \\n    \\n     \\n    long long minCost(vector<int>& v1, vector<int>& v2) { \\n        map<ll,ll> m;         int n=v1.size(); \\n        ll x=v2[n-1]; \\n         \\n        for(int i=0;i<n;i++){ \\n            m[v1[i]]++; \\n            m[v2[i]]--; \\n        } \\n         \\n        bool flag=false; \\n        v1.clear(); \\n    v2.clear(); \\n    \\n    ll mi = x; \\n    \\n    for(auto i:m) \\n    { \\n     mi = min(mi, i.first); \\n     x = abs(i.second); \\n    \\n     if(x%2) \\n      flag = true; \\n    \\n     x = i.second; \\n    \\n     if(x > 0) \\n     { \\n      x /= 2; \\n    \\n      while(x--) \\n       v1.push_back(i.first); \\n     } \\n     else if(x < 0) \\n     { \\n      x = abs(x)/2; \\n    \\n      while(x--) \\n       v2.push_back(i.first); \\n     } \\n    }     \\n    if(flag) \\n    { \\n     return -1; \\n    }     \\n    reverse(v2.begin(),v2.end()); \\n    ll ans = 0;    \\n    for(int i=0;i<v1.size();i++) \\n     ans += min(2*mi,1ll*min(v1[i],v2[i]));    \\n    return ans;          \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144193,
                "title": "go-funky-maps-and-sort",
                "content": "```\\nfunc minCost(basket1 []int, basket2 []int) int64 {\\n    all, b1, b2 := make(map[int]int), make(map[int]int), make(map[int]int)\\n\\n    for _, fruit := range basket1 {\\n        all[fruit]++\\n        b1[fruit]++\\n    }\\n\\n    for _, fruit := range basket2 {\\n        all[fruit]++\\n        b2[fruit]++\\n    }\\n\\n    smallest := 1000000001\\n\\n    for fruit, count := range all {\\n        if count % 2 != 0 {\\n            return -1\\n        }\\n        smallest = min(smallest, fruit)\\n    }\\n\\n    lack1, lack2 := []int{}, []int{}\\n\\n    for fruit, count := range b1 {\\n        if count > b2[fruit] {\\n            diff := count - b2[fruit]\\n            diff >>= 1\\n            b1[fruit] -= diff\\n            b2[fruit] += diff\\n            \\n            for i := 0; i < diff; i++ {\\n                lack2 = append(lack2, fruit)\\n            }\\n        }\\n    }\\n\\n    for fruit, count := range b2 {\\n        if count > b1[fruit] {\\n            diff := count - b1[fruit]\\n            diff >>= 1\\n            b2[fruit] -= diff\\n            b1[fruit] += diff\\n\\n            for i := 0; i < diff; i++ {\\n                lack1 = append(lack1, fruit)\\n            }\\n        }\\n    }\\n\\n    sort.Ints(lack1)\\n    sort.Sort(sort.Reverse(sort.IntSlice(lack2)))\\n\\n    res := 0\\n\\n    for i := 0; i < len(lack1); i++ {\\n        res += min(min(lack1[i], lack2[i]), smallest * 2)\\n    }\\n    \\n    return int64(res)\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minCost(basket1 []int, basket2 []int) int64 {\\n    all, b1, b2 := make(map[int]int), make(map[int]int), make(map[int]int)\\n\\n    for _, fruit := range basket1 {\\n        all[fruit]++\\n        b1[fruit]++\\n    }\\n\\n    for _, fruit := range basket2 {\\n        all[fruit]++\\n        b2[fruit]++\\n    }\\n\\n    smallest := 1000000001\\n\\n    for fruit, count := range all {\\n        if count % 2 != 0 {\\n            return -1\\n        }\\n        smallest = min(smallest, fruit)\\n    }\\n\\n    lack1, lack2 := []int{}, []int{}\\n\\n    for fruit, count := range b1 {\\n        if count > b2[fruit] {\\n            diff := count - b2[fruit]\\n            diff >>= 1\\n            b1[fruit] -= diff\\n            b2[fruit] += diff\\n            \\n            for i := 0; i < diff; i++ {\\n                lack2 = append(lack2, fruit)\\n            }\\n        }\\n    }\\n\\n    for fruit, count := range b2 {\\n        if count > b1[fruit] {\\n            diff := count - b1[fruit]\\n            diff >>= 1\\n            b2[fruit] -= diff\\n            b1[fruit] += diff\\n\\n            for i := 0; i < diff; i++ {\\n                lack1 = append(lack1, fruit)\\n            }\\n        }\\n    }\\n\\n    sort.Ints(lack1)\\n    sort.Sort(sort.Reverse(sort.IntSlice(lack2)))\\n\\n    res := 0\\n\\n    for i := 0; i < len(lack1); i++ {\\n        res += min(min(lack1[i], lack2[i]), smallest * 2)\\n    }\\n    \\n    return int64(res)\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3144172,
                "title": "hashmap-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSwapping with min element between the 2 baskets saves cost\\n\\n# Approach\\nTrack mismatch between baskets and find the min swaps\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int minb = Integer.MAX_VALUE;\\n        for (int b : basket1) {\\n            minb = Math.min(minb, b);\\n            map.put(b, map.getOrDefault(b, 0) + 1);\\n        }\\n        for (int b : basket2) {\\n            minb = Math.min(minb, b);\\n            map.put(b, map.getOrDefault(b, 0) - 1);\\n        }\\n        \\n        \\n        for (int v : map.values()) {\\n            if (Math.abs(v) % 2 == 1) {\\n                return -1;\\n            }\\n        }\\n        \\n        List<Integer> pos = new ArrayList<>();\\n        List<Integer> neg = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int k = entry.getKey();\\n            int v = entry.getValue();\\n            \\n            if (v > 0) {\\n                for (int i = 0; i < v / 2; i++) {\\n                    pos.add(k);\\n                }\\n            } else if (v < 0) {\\n                v *= -1;\\n                for (int i = 0; i < v / 2; i++) {\\n                    neg.add(k);\\n                }\\n            }\\n        }\\n        \\n        Collections.sort(pos);\\n        Collections.sort(neg, Collections.reverseOrder());\\n\\n        long sum = 0;\\n        for (int i = 0; i < pos.size(); i++) {\\n            int currMin = Math.min(pos.get(i), neg.get(i));\\n            if (currMin < 2 * minb) {\\n                sum += currMin;\\n            } else {\\n                sum += 2 * minb;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public long minCost(int[] basket1, int[] basket2) {\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int minb = Integer.MAX_VALUE;\\n        for (int b : basket1) {\\n            minb = Math.min(minb, b);\\n            map.put(b, map.getOrDefault(b, 0) + 1);\\n        }\\n        for (int b : basket2) {\\n            minb = Math.min(minb, b);\\n            map.put(b, map.getOrDefault(b, 0) - 1);\\n        }\\n        \\n        \\n        for (int v : map.values()) {\\n            if (Math.abs(v) % 2 == 1) {\\n                return -1;\\n            }\\n        }\\n        \\n        List<Integer> pos = new ArrayList<>();\\n        List<Integer> neg = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int k = entry.getKey();\\n            int v = entry.getValue();\\n            \\n            if (v > 0) {\\n                for (int i = 0; i < v / 2; i++) {\\n                    pos.add(k);\\n                }\\n            } else if (v < 0) {\\n                v *= -1;\\n                for (int i = 0; i < v / 2; i++) {\\n                    neg.add(k);\\n                }\\n            }\\n        }\\n        \\n        Collections.sort(pos);\\n        Collections.sort(neg, Collections.reverseOrder());\\n\\n        long sum = 0;\\n        for (int i = 0; i < pos.size(); i++) {\\n            int currMin = Math.min(pos.get(i), neg.get(i));\\n            if (currMin < 2 * minb) {\\n                sum += currMin;\\n            } else {\\n                sum += 2 * minb;\\n            }\\n            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144120,
                "title": "c-good-quality-code-greedily-do-efficient-trades",
                "content": "The approach is when we know we have to swap elements or trade elements we can follow 2 steps\\n- Use a minimum element as a decoy and do 2 swaps to reduce cost\\n- Trade two number that needs to exchange in both baskets\\n- Normal Trade when above 2 trade cannot happen.\\n\\nWe using a count map to store frequency and then calculating how many Swaps needed.\\nAfter that checking above conditions for trade and return the answer as directed.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        // To store in sorted manner the elements\\n        map<long long int,long long int> count;\\n        int xorval = 0,minElement=INT_MAX;\\n        for(int x : basket1){\\n            xorval^=x;\\n            count[x]++;\\n            minElement = min(minElement,x);\\n        }    \\n        for(int x : basket2){\\n            xorval^=x;\\n            count[x]--;\\n            minElement = min(minElement,x);\\n        } \\n        if(xorval!=0) return -1; //No Equal frequencies so return -1;\\n        long long swapsNeeded = 0;\\n        for(auto [val,count]:count){\\n            if(count>0)\\n                swapsNeeded+=count/2;\\n        }\\n        long long ans = 0;\\n        for(auto [val,count]: count){\\n            if(val>=2*minElement){\\n                // We can swap a minimum element to reduce cost and use it as a decoy\\n                // All the bigger elements also satisfy this as its a sorted Map;\\n                return ans+2*minElement*swapsNeeded; \\n            }\\n            if(abs(count)/2 >= swapsNeeded){\\n                // Means we have small numbers that we can trade for swaps for bigger numbers. \\n                return ans+swapsNeeded*val;\\n            }\\n            // If we dont satisfy good trades do a normal trade\\n            ans += (val*abs(count))/2;\\n            swapsNeeded-=abs(count)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Bit Manipulation",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        // To store in sorted manner the elements\\n        map<long long int,long long int> count;\\n        int xorval = 0,minElement=INT_MAX;\\n        for(int x : basket1){\\n            xorval^=x;\\n            count[x]++;\\n            minElement = min(minElement,x);\\n        }    \\n        for(int x : basket2){\\n            xorval^=x;\\n            count[x]--;\\n            minElement = min(minElement,x);\\n        } \\n        if(xorval!=0) return -1; //No Equal frequencies so return -1;\\n        long long swapsNeeded = 0;\\n        for(auto [val,count]:count){\\n            if(count>0)\\n                swapsNeeded+=count/2;\\n        }\\n        long long ans = 0;\\n        for(auto [val,count]: count){\\n            if(val>=2*minElement){\\n                // We can swap a minimum element to reduce cost and use it as a decoy\\n                // All the bigger elements also satisfy this as its a sorted Map;\\n                return ans+2*minElement*swapsNeeded; \\n            }\\n            if(abs(count)/2 >= swapsNeeded){\\n                // Means we have small numbers that we can trade for swaps for bigger numbers. \\n                return ans+swapsNeeded*val;\\n            }\\n            // If we dont satisfy good trades do a normal trade\\n            ans += (val*abs(count))/2;\\n            swapsNeeded-=abs(count)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3144037,
                "title": "o-n-log-n-greedy-full-explained-c",
                "content": "# Intuition\\nGreedy\\n\\n# Approach\\nFirst notice that the total frequency of each number must be even, now, after checking that, we can know how many occurrences of x must be in each array, and we can also know the excess of some number in each array, therefore we know that numbers to be swaped from B1 and B2, let\\'s call these arrays S1 and S2, for example for the arrays:\\n\\n$b1 = [1,1,5,5,5,5]$ , $b2 = [1,1,4,4,4,4]$ \\nAnd the numbers that must be swaped are:\\n$s1 = [5,5]$ $s2 = [4,4]$\\n\\nThe optimal way to swap this numbers is take the minimum from $s1$ and $s2$ and match with the maximum of the other array, in the example we take the number $4$ from $s2$ and swap with the number $5$ of $s1$.\\n \\nThis operation adds that $min(s1_i,s2_i)$ to our answer and reduces the size of both arrays by one, so repeat this action $|s1|$ times.\\n\\nBut there is another way to reduce this arrays, if we use this greedy for our example the answer will be $8$ but the optimal answer is $4$.\\n\\nLet\\'s take the minimum number of both matrices $b1$ and $b2$, in this case the number $1$, regardless of whether it should be exchanged or not, it is true that at least one occurrence of this number exists in some array and that it is not present in either $s1$ or $s2$, so we can swap with some big element of $s1$ or $s2$ and \\'waste\\' one swap, i say waste because the size of $s1$ or $s2$ doesn\\'t change but then we can use those minimum again to swap with some other big number. \\nExample:\\n\\nFirst bring the global minimum to $s1$ or $s2$ depends on who has the maximum\\n$s1 = [5,5]$ $s2 = [4,4]$ $\\\\rightarrow$  $s1 = [5,1]$ , $s2=[4,4]$\\nThis add the global minimum to our answer. $\\\\rightarrow$ $ans = 1$\\nThen swap with the maximum and reduce the size of both by one \\n$s1 = [5,1]$ , $s2=[4,4]$ $\\\\rightarrow$  $s1 = [5]$ , $s2=[4]$\\nAgain add the global minimum to our answer. $\\\\rightarrow$ $ans = 2$\\n\\nThis operation also reduces the size by one but with cost $globalMin*2$ and if we repeat again we see that the answer will be $4$\\n\\nSo for our global optimal answer we need to check those two operations at the begin with the whole array and each time that we reduce $|s1|$ by one\\n\\n# Complexity\\n- Time complexity:\\n$O(n log(n))$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        \\n        long long ans = 0;\\n        \\n        map<int,int> mp1;\\n        map<int,int> mp2;\\n        map<int,int> mp;\\n        \\n        int n = b1.size();\\n        \\n        for(int i = 0;i<n;i++){\\n            mp1[b1[i]]++;\\n            mp2[b2[i]]++;\\n            mp[b1[i]]++;\\n            mp[b2[i]]++;\\n        }\\n        bool flag = true;\\n        for(auto &c:mp){\\n            if(c.second&1){\\n                flag = false;    \\n            }\\n            c.second/=2;\\n        }\\n        if(!flag)return -1;\\n        \\n        multiset<int> st1;\\n        multiset<int> st2;\\n        \\n        for(auto c:mp1){\\n            int need = mp[c.first];\\n            if(c.second>need){\\n                for(int i =0;i<c.second-need;i++){\\n                    st1.insert(c.first);\\n                }\\n            }\\n        }\\n        for(auto c:mp2){\\n            int need = mp[c.first];\\n            if(c.second>need){\\n                for(int i =0;i<c.second-need;i++){\\n                    st2.insert(c.first);\\n                }\\n            }\\n        }\\n    \\n        int N = st1.size();\\n        \\n        long long mn1 = *min_element(b1.begin(),b1.end());\\n        long long mn2 = *min_element(b2.begin(),b2.end());\\n        long long mn = min(mn1,mn2);\\n        \\n        ans = mn*N*2;\\n        long long res = 0;\\n        for(int i = 0;i<N;i++){\\n            int mn1 = *st1.begin();\\n            int mn2 = *st2.begin();\\n            \\n            if(mn1<mn2){\\n                int mx = *st2.rbegin();\\n                \\n                st1.erase(st1.begin());\\n                st2.erase(st2.find(mx));\\n                res+=mn1;\\n            }\\n            else{\\n                int mx = *st1.rbegin();\\n                \\n                st1.erase(st1.find(mx));\\n                st2.erase(st2.begin());\\n                res+=mn2;\\n            }\\n            ans = min(ans,res+((N-(i+1))*2*mn));\\n        }\\n        ans = min(ans,res);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& b1, vector<int>& b2) {\\n        \\n        long long ans = 0;\\n        \\n        map<int,int> mp1;\\n        map<int,int> mp2;\\n        map<int,int> mp;\\n        \\n        int n = b1.size();\\n        \\n        for(int i = 0;i<n;i++){\\n            mp1[b1[i]]++;\\n            mp2[b2[i]]++;\\n            mp[b1[i]]++;\\n            mp[b2[i]]++;\\n        }\\n        bool flag = true;\\n        for(auto &c:mp){\\n            if(c.second&1){\\n                flag = false;    \\n            }\\n            c.second/=2;\\n        }\\n        if(!flag)return -1;\\n        \\n        multiset<int> st1;\\n        multiset<int> st2;\\n        \\n        for(auto c:mp1){\\n            int need = mp[c.first];\\n            if(c.second>need){\\n                for(int i =0;i<c.second-need;i++){\\n                    st1.insert(c.first);\\n                }\\n            }\\n        }\\n        for(auto c:mp2){\\n            int need = mp[c.first];\\n            if(c.second>need){\\n                for(int i =0;i<c.second-need;i++){\\n                    st2.insert(c.first);\\n                }\\n            }\\n        }\\n    \\n        int N = st1.size();\\n        \\n        long long mn1 = *min_element(b1.begin(),b1.end());\\n        long long mn2 = *min_element(b2.begin(),b2.end());\\n        long long mn = min(mn1,mn2);\\n        \\n        ans = mn*N*2;\\n        long long res = 0;\\n        for(int i = 0;i<N;i++){\\n            int mn1 = *st1.begin();\\n            int mn2 = *st2.begin();\\n            \\n            if(mn1<mn2){\\n                int mx = *st2.rbegin();\\n                \\n                st1.erase(st1.begin());\\n                st2.erase(st2.find(mx));\\n                res+=mn1;\\n            }\\n            else{\\n                int mx = *st1.rbegin();\\n                \\n                st1.erase(st1.find(mx));\\n                st2.erase(st2.begin());\\n                res+=mn2;\\n            }\\n            ans = min(ans,res+((N-(i+1))*2*mn));\\n        }\\n        ans = min(ans,res);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143991,
                "title": "less-memory-than-100-specific-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe fruits can be rearranged equally in the two baskets if the number of each kind of fruit is even.\\nThe fruits whose numbers are different need to be swapped. To equalize the numbers, we need to swap half the difference.\\nThere are two possible kinds of swaps:\\n* in pairs among the fruits that need to be swapped\\n* or swapping them with some third fruit.\\n\\nIn the second case, the only logical choice is the fruit with minimum cost, call it mn.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen swapping the fruits in pairs, the cost of each swap is that of the cheapest fruit in the pair. When swapping with a third fruit, the cost of a pair swap is 2mn. Thus, swapping in pairs is better as long as the cheapest fruit in the pair costs less than 2mn.\\nWe add up the costs of the cheapest fruits that need to be swapped, up to 2mn. We then add the number of remaining pairs times 2mn. The total is the answer.\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        dct=defaultdict(int)\\n        for i, f in enumerate(basket1):\\n            dct[f]+=1\\n        for i, f in enumerate(basket2):\\n            dct[f]-=1\\n        ans=[]\\n        for k in dct.keys():\\n            v=dct[k]\\n            if v&1:\\n                return -1\\n            ans+=[k]*abs(v>>1)\\n            \\n        ans.sort()\\n        lng=len(ans)>>1\\n        mn=min(dct.keys())<<1\\n        s=0\\n        i=0\\n        while i<lng and ans[i]<mn:\\n            s+=ans[i]\\n            i+=1\\n        return s+(lng-i)*mn\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        dct=defaultdict(int)\\n        for i, f in enumerate(basket1):\\n            dct[f]+=1\\n        for i, f in enumerate(basket2):\\n            dct[f]-=1\\n        ans=[]\\n        for k in dct.keys():\\n            v=dct[k]\\n            if v&1:\\n                return -1\\n            ans+=[k]*abs(v>>1)\\n            \\n        ans.sort()\\n        lng=len(ans)>>1\\n        mn=min(dct.keys())<<1\\n        s=0\\n        i=0\\n        while i<lng and ans[i]<mn:\\n            s+=ans[i]\\n            i+=1\\n        return s+(lng-i)*mn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143950,
                "title": "c-hashtable-solution-with-explanation",
                "content": "# Intuition\\nLets think about two questions:\\n1. When to swap?\\n2. How to swap?\\n\\n- Swapping is need when there is more element A in `array a` then `array b`\\n    - Also, sum of element A is even\\n    - otherwise, return -1\\n- How to swap will create minimum costs\\n    - cost of swaping the smallest and largest element needed to be swap, or\\n    - swap the current element with smallest element \\n- For example: (first case)\\n    - `[1, 1, 1]`, `[1, 6, 6]`\\n    - `Array a`: 1 -> 3 and `Array b`: 1 -> 1, 6 -> 2\\n    - We swap the smallest and largest element, that is swapping with 1 and 6\\n- For example: (second case)\\n    - `[1, 100, 100]`, `[1, 999, 999]`\\n    - Costs of swapping 100 and 999 = 100\\n    - Costs of swapping 1 and 100 and 1 and 999 = 1 * 2\\n    - We choose first swapping 1 with 100 and get `[1, 1, 100]` and `[100, 999, 999]`\\n    - Then swap 1 with 999 and get `[1, 999, 100]` and `[100, 1, 999]`\\n\\nThen, the following is the implementation\\n- We use hashmap to store how many element needed to be swap. \\n- Then, we swap each item, and check which case of swapping is used.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<long long, long long> dict, dict1;\\n        int smallest(INT_MAX);\\n        for (auto &a: basket1) {\\n            smallest = min(smallest, a);\\n            dict[a]++;\\n            dict1[a]++;\\n        }\\n        for (auto &a: basket2) {\\n            dict[a]++;\\n            smallest = min(smallest, a);\\n        }\\n        long long ans(0);\\n        long long count(0);\\n        for (auto &a: dict) {\\n            if (a.second % 2 == 1) return -1;\\n            a.second /= 2;\\n            if (dict1.find(a.first) != dict1.end()){\\n                a.second -= dict1[a.first];\\n            }\\n            if (a.second < 0){\\n                count += abs(a.second);\\n            }\\n        }\\n        for (auto &a: dict){\\n            if (a.second == 0) continue;\\n            if (count > abs(a.second)){\\n                ans += abs(min(a.first, 2LL * smallest) * a.second);\\n                count -= abs(a.second);\\n            }else if (count == 0) {\\n                break;\\n            }\\n            else{\\n                ans += abs(min(a.first, 2LL * smallest) * count);\\n                count -= abs(count);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\\n        map<long long, long long> dict, dict1;\\n        int smallest(INT_MAX);\\n        for (auto &a: basket1) {\\n            smallest = min(smallest, a);\\n            dict[a]++;\\n            dict1[a]++;\\n        }\\n        for (auto &a: basket2) {\\n            dict[a]++;\\n            smallest = min(smallest, a);\\n        }\\n        long long ans(0);\\n        long long count(0);\\n        for (auto &a: dict) {\\n            if (a.second % 2 == 1) return -1;\\n            a.second /= 2;\\n            if (dict1.find(a.first) != dict1.end()){\\n                a.second -= dict1[a.first];\\n            }\\n            if (a.second < 0){\\n                count += abs(a.second);\\n            }\\n        }\\n        for (auto &a: dict){\\n            if (a.second == 0) continue;\\n            if (count > abs(a.second)){\\n                ans += abs(min(a.first, 2LL * smallest) * a.second);\\n                count -= abs(a.second);\\n            }else if (count == 0) {\\n                break;\\n            }\\n            else{\\n                ans += abs(min(a.first, 2LL * smallest) * count);\\n                count -= abs(count);\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143948,
                "title": "python-sorting-two-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting and two pointer\\nSort the input\\nUse Two Pointers to loop\\nCount the number of mismatch and add the mistmatch to an array\\nTo calculate the total, add the minimum of mistmatch value or the smallest number to the total.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M log M + N log N) where M =len(basket1), N =len(basket2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M + N )where M =len(basket1), N =len(basket2)\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n\\n        N = len(basket1)\\n        \\n        #sort the input\\n        b1 = sorted(basket1)\\n        b2 = sorted(basket2)\\n\\n        #two pointers\\n        p1 = 0\\n        p2 = 0\\n        \\n        #Check if the count of each number is not even, return -1\\n        c = Counter(b1) + Counter(b2)\\n        for k in c:\\n            if c[k] %2 !=0:\\n                return -1\\n        \\n        cost = []\\n\\n        smalest_number = 0\\n        \\n        while p1 < N and p2 < N:\\n            if smalest_number == 0:\\n                smalest_number = min(b1[p1],b2[p2])\\n\\n            if b1[p1] == b2[p2]:\\n\\n                p1+=1\\n                p2+=1\\n                \\n            elif b1[p1] <= b2[p2]:\\n                cost.append( b1[p1])\\n                p1+=2\\n\\n            else:\\n                cost.append( b2[p2])\\n                p2+=2\\n\\n        while p1 < N:\\n\\n            cost.append( b1[p1])\\n            p1+=2\\n        while p2 < N:\\n\\n            cost.append( b2[p2])\\n            p2+=2\\n\\n        tot = 0\\n        for i in range(len(cost)//2):\\n            if cost[i] == smalest_number:\\n                tot += smalest_number\\n            elif cost[i] < (smalest_number *2 ):\\n                tot += cost[i]\\n            else:\\n                tot += smalest_number *2\\n\\n        return tot\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n\\n        N = len(basket1)\\n        \\n        #sort the input\\n        b1 = sorted(basket1)\\n        b2 = sorted(basket2)\\n\\n        #two pointers\\n        p1 = 0\\n        p2 = 0\\n        \\n        #Check if the count of each number is not even, return -1\\n        c = Counter(b1) + Counter(b2)\\n        for k in c:\\n            if c[k] %2 !=0:\\n                return -1\\n        \\n        cost = []\\n\\n        smalest_number = 0\\n        \\n        while p1 < N and p2 < N:\\n            if smalest_number == 0:\\n                smalest_number = min(b1[p1],b2[p2])\\n\\n            if b1[p1] == b2[p2]:\\n\\n                p1+=1\\n                p2+=1\\n                \\n            elif b1[p1] <= b2[p2]:\\n                cost.append( b1[p1])\\n                p1+=2\\n\\n            else:\\n                cost.append( b2[p2])\\n                p2+=2\\n\\n        while p1 < N:\\n\\n            cost.append( b1[p1])\\n            p1+=2\\n        while p2 < N:\\n\\n            cost.append( b2[p2])\\n            p2+=2\\n\\n        tot = 0\\n        for i in range(len(cost)//2):\\n            if cost[i] == smalest_number:\\n                tot += smalest_number\\n            elif cost[i] < (smalest_number *2 ):\\n                tot += cost[i]\\n            else:\\n                tot += smalest_number *2\\n\\n        return tot\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143899,
                "title": "hash-table-heap-combo",
                "content": "class Solution:\\n\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        C1, C2 = Counter(basket1), Counter(basket2)\\n        abs_min = min(min(basket1), min(basket2))\\n        h = []\\n        for i in C1.keys():\\n            if C1[i] > C2[i]:\\n                diff = C1[i] - C2[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        for i in C2.keys():\\n            if C2[i] > C1[i]:\\n                diff = C2[i] - C1[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        n, ans = len(h), 0\\n        for _ in range(n//2):\\n            ans += min(2*abs_min, heappop(h))\\n        return ans",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def minCost(self, basket1: List[int], basket2: List[int]) -> int:\\n        C1, C2 = Counter(basket1), Counter(basket2)\\n        abs_min = min(min(basket1), min(basket2))\\n        h = []\\n        for i in C1.keys():\\n            if C1[i] > C2[i]:\\n                diff = C1[i] - C2[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        for i in C2.keys():\\n            if C2[i] > C1[i]:\\n                diff = C2[i] - C1[i]\\n                if diff % 2:\\n                    return -1\\n                for _ in range(diff//2):\\n                    heappush(h, i)\\n        n, ans = len(h), 0\\n        for _ in range(n//2):\\n            ans += min(2*abs_min, heappop(h))\\n        return ans",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1793198,
                "content": [
                    {
                        "username": "user3954sk",
                        "content": "Once I read the question correctly (I initially started with the assumption that equal meant that the sum was equal!) this was a nice question.  No complex data structures, just pure logic (and then frustration when I forgot to account for the cost requiring 64 bit...).\\nSPOILER ALERT - Don\\'t read on if you don\\'t want a hint.\\nIf you need a hint, then consider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "brinuke",
                        "content": "What is `bakste2.length`? Looks like someone swapped letters in description instead of fruits."
                    },
                    {
                        "username": "lcaa02",
                        "content": "For the test case \\n[84,80,43,8,80,88,43,14,100,88]\\n[32,32,42,68,68,100,42,84,14,8]\\n\\ncan anyone please explain, how is the expected value 48?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Same logic I applied  haha and failed....\\n\\nConsider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "lcaa02",
                        "content": "[@applebeeble](/applebeeble) ohh right! Got it. thanks!!"
                    },
                    {
                        "username": "applebeeble",
                        "content": "use the minimum element 8 to do 6 swaps."
                    },
                    {
                        "username": "tejasX",
                        "content": "can somebody help me here ? What exactly i am missing?\n\n```\nclass Solution {\npublic:\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\n        unordered_map<int,int> Map1;\n        unordered_map<int,int> Map2;\n        \n        //fruits:\n        unordered_set<int> f;\n        for(auto ele: basket1){\n            Map1[ele]++;\n            f.insert(ele);\n        }\n        for(auto ele: basket2){\n            Map2[ele]++;\n            f.insert(ele);\n        }\n        \n        //cost from swapping:\n        vector<int> c1;\n        vector<int> c2;\n        \n        //pass req from basket1:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f1 <= f2) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f2;\n            while(added--) c1.push_back(fruit);\n        }\n        \n        //pass req from basket2:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f2 <= f1) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f1;\n            while(added--) c2.push_back(fruit);\n        }\n        \n        // for(auto c: c1) cout << c << \" \";\n        // cout << endl;\n        // for(auto c: c2) cout << c << \" \";\n        // cout << endl;\n        \n        if(c1.size() != c2.size()) return -1;\n        \n        sort(c1.begin(), c1.end());\n        sort(c2.begin(), c2.end());\n        \n        // to find min sum of all swaps using four pointers:\n        int n = c1.size();\n        int max1 = n-1, min1 = 0;\n        int max2 = n-1, min2 = 0;\n        \n        long long cost = 0;\n        for(int i=0;i<n;i++){\n            if(c1[max1] + c2[min2] < c2[max2] + c1[min1]){\n                cost += min(c1[max1], c2[min2]);\n                max1--;\n                min2++;\n            }\n            else{\n                cost += min(c2[max2], c1[min1]);\n                max2--;\n                min1++;\n            }\n        }\n        \n        return cost;        \n    }\n};\n```"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I think you will fail with the case:\\n[1,100,100],[1,200,200] (answer 2 - swap 1 with 200 and then swap 100 with 1)."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "You have small vocabulary error in Constraints block."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I have a hard time with this one, thought about it overnight and still don\\'t get it. Here are a few interesting examples that I have thought of\\n\\n[1,3],[5,9] is impossible, despite the sum is an even number - so we can\\'t detect whether a rearrangement is possible by odd/even.\\n\\nA satisfying arrangement [1,9],[5,5] has both the max and min in the same side, while, [1,6,6],[2,2,9] has the max and min on different side, we can\\'t decide if the max/min should be on the same side or not.\\n\\nThe example [1,1,5,5], [2,2,4,4] can also be [1,2,4,5], [1,2,4,5], in general there could be multiple satisfying arrangements, even after excluding sorting.\\n\\nThe example [1,3,5,10], [2,4,6,7] show that a solution can be quite interleaving. Starting from a random arrangement, such as [1,2,3,4], [5,6,7,10], swapping the light side heaviest with the heavy side lightest (i.e. 4 with 5) is a wrong move. The right moves (i.e. swap([1,3],[6,7]) seems rather random with no obvious pattern.\\n\\nI am stuck, I try not to read solutions (yet), any hints would be great."
                    },
                    {
                        "username": "shi_logic",
                        "content": "You can think about it greedily, as we often use the smaller one to match the bigger one or use the minimum number as a bridge to swap two other elements in both arrays. So you can think of sorting and using a two-point method to solve it."
                    },
                    {
                        "username": "applebeeble",
                        "content": "Shouldn\\'t this problem be medium? At the beginning I came up with the idea that I can use the smallest element to do the swap for larger elements. However, when I saw the difficulty is hard, I overthought. My time was run out during the contest, I was pretty close the correct solution. It is just min_element * number of elements that are different than target (target is the target array) + 2 or not + 2. I was trying to figure out the condition regarding plus 2 or not and ran out of the time as this is the last question during the contest.\\n\\nTLDR: This should be a medium problem, math-focused. No extra complex data structures needed. Result = min_element * num_different_element + 2 or not."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "What you said here basically means \"we will always use minimum number to help our swap\". This is actually not true, [3,4,4,4,4] - [3,5,5,5,5], the optimal cost is swapping 4 with 5 twice - 3 (the minimum) is not involved at all.\n\nThe solution is we do normal direct swap, but if using minimum number can help us to get lower cost, THEN we use minimum num to help us. (`when cost(direct swap) > minimum num * 2, we use minimum number to help us`)\n\nAs for that \"+2 or not\", i don't quite get it why you want to +2. Please let me know your idea here. Why 2?\n\nThis is a fair HARD, i think your solution is actually wrong which made you feel this is medium. "
                    }
                ]
            },
            {
                "id": 1788610,
                "content": [
                    {
                        "username": "user3954sk",
                        "content": "Once I read the question correctly (I initially started with the assumption that equal meant that the sum was equal!) this was a nice question.  No complex data structures, just pure logic (and then frustration when I forgot to account for the cost requiring 64 bit...).\\nSPOILER ALERT - Don\\'t read on if you don\\'t want a hint.\\nIf you need a hint, then consider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "brinuke",
                        "content": "What is `bakste2.length`? Looks like someone swapped letters in description instead of fruits."
                    },
                    {
                        "username": "lcaa02",
                        "content": "For the test case \\n[84,80,43,8,80,88,43,14,100,88]\\n[32,32,42,68,68,100,42,84,14,8]\\n\\ncan anyone please explain, how is the expected value 48?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Same logic I applied  haha and failed....\\n\\nConsider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "lcaa02",
                        "content": "[@applebeeble](/applebeeble) ohh right! Got it. thanks!!"
                    },
                    {
                        "username": "applebeeble",
                        "content": "use the minimum element 8 to do 6 swaps."
                    },
                    {
                        "username": "tejasX",
                        "content": "can somebody help me here ? What exactly i am missing?\n\n```\nclass Solution {\npublic:\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\n        unordered_map<int,int> Map1;\n        unordered_map<int,int> Map2;\n        \n        //fruits:\n        unordered_set<int> f;\n        for(auto ele: basket1){\n            Map1[ele]++;\n            f.insert(ele);\n        }\n        for(auto ele: basket2){\n            Map2[ele]++;\n            f.insert(ele);\n        }\n        \n        //cost from swapping:\n        vector<int> c1;\n        vector<int> c2;\n        \n        //pass req from basket1:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f1 <= f2) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f2;\n            while(added--) c1.push_back(fruit);\n        }\n        \n        //pass req from basket2:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f2 <= f1) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f1;\n            while(added--) c2.push_back(fruit);\n        }\n        \n        // for(auto c: c1) cout << c << \" \";\n        // cout << endl;\n        // for(auto c: c2) cout << c << \" \";\n        // cout << endl;\n        \n        if(c1.size() != c2.size()) return -1;\n        \n        sort(c1.begin(), c1.end());\n        sort(c2.begin(), c2.end());\n        \n        // to find min sum of all swaps using four pointers:\n        int n = c1.size();\n        int max1 = n-1, min1 = 0;\n        int max2 = n-1, min2 = 0;\n        \n        long long cost = 0;\n        for(int i=0;i<n;i++){\n            if(c1[max1] + c2[min2] < c2[max2] + c1[min1]){\n                cost += min(c1[max1], c2[min2]);\n                max1--;\n                min2++;\n            }\n            else{\n                cost += min(c2[max2], c1[min1]);\n                max2--;\n                min1++;\n            }\n        }\n        \n        return cost;        \n    }\n};\n```"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I think you will fail with the case:\\n[1,100,100],[1,200,200] (answer 2 - swap 1 with 200 and then swap 100 with 1)."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "You have small vocabulary error in Constraints block."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I have a hard time with this one, thought about it overnight and still don\\'t get it. Here are a few interesting examples that I have thought of\\n\\n[1,3],[5,9] is impossible, despite the sum is an even number - so we can\\'t detect whether a rearrangement is possible by odd/even.\\n\\nA satisfying arrangement [1,9],[5,5] has both the max and min in the same side, while, [1,6,6],[2,2,9] has the max and min on different side, we can\\'t decide if the max/min should be on the same side or not.\\n\\nThe example [1,1,5,5], [2,2,4,4] can also be [1,2,4,5], [1,2,4,5], in general there could be multiple satisfying arrangements, even after excluding sorting.\\n\\nThe example [1,3,5,10], [2,4,6,7] show that a solution can be quite interleaving. Starting from a random arrangement, such as [1,2,3,4], [5,6,7,10], swapping the light side heaviest with the heavy side lightest (i.e. 4 with 5) is a wrong move. The right moves (i.e. swap([1,3],[6,7]) seems rather random with no obvious pattern.\\n\\nI am stuck, I try not to read solutions (yet), any hints would be great."
                    },
                    {
                        "username": "shi_logic",
                        "content": "You can think about it greedily, as we often use the smaller one to match the bigger one or use the minimum number as a bridge to swap two other elements in both arrays. So you can think of sorting and using a two-point method to solve it."
                    },
                    {
                        "username": "applebeeble",
                        "content": "Shouldn\\'t this problem be medium? At the beginning I came up with the idea that I can use the smallest element to do the swap for larger elements. However, when I saw the difficulty is hard, I overthought. My time was run out during the contest, I was pretty close the correct solution. It is just min_element * number of elements that are different than target (target is the target array) + 2 or not + 2. I was trying to figure out the condition regarding plus 2 or not and ran out of the time as this is the last question during the contest.\\n\\nTLDR: This should be a medium problem, math-focused. No extra complex data structures needed. Result = min_element * num_different_element + 2 or not."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "What you said here basically means \"we will always use minimum number to help our swap\". This is actually not true, [3,4,4,4,4] - [3,5,5,5,5], the optimal cost is swapping 4 with 5 twice - 3 (the minimum) is not involved at all.\n\nThe solution is we do normal direct swap, but if using minimum number can help us to get lower cost, THEN we use minimum num to help us. (`when cost(direct swap) > minimum num * 2, we use minimum number to help us`)\n\nAs for that \"+2 or not\", i don't quite get it why you want to +2. Please let me know your idea here. Why 2?\n\nThis is a fair HARD, i think your solution is actually wrong which made you feel this is medium. "
                    }
                ]
            },
            {
                "id": 1788412,
                "content": [
                    {
                        "username": "user3954sk",
                        "content": "Once I read the question correctly (I initially started with the assumption that equal meant that the sum was equal!) this was a nice question.  No complex data structures, just pure logic (and then frustration when I forgot to account for the cost requiring 64 bit...).\\nSPOILER ALERT - Don\\'t read on if you don\\'t want a hint.\\nIf you need a hint, then consider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "brinuke",
                        "content": "What is `bakste2.length`? Looks like someone swapped letters in description instead of fruits."
                    },
                    {
                        "username": "lcaa02",
                        "content": "For the test case \\n[84,80,43,8,80,88,43,14,100,88]\\n[32,32,42,68,68,100,42,84,14,8]\\n\\ncan anyone please explain, how is the expected value 48?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Same logic I applied  haha and failed....\\n\\nConsider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "lcaa02",
                        "content": "[@applebeeble](/applebeeble) ohh right! Got it. thanks!!"
                    },
                    {
                        "username": "applebeeble",
                        "content": "use the minimum element 8 to do 6 swaps."
                    },
                    {
                        "username": "tejasX",
                        "content": "can somebody help me here ? What exactly i am missing?\n\n```\nclass Solution {\npublic:\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\n        unordered_map<int,int> Map1;\n        unordered_map<int,int> Map2;\n        \n        //fruits:\n        unordered_set<int> f;\n        for(auto ele: basket1){\n            Map1[ele]++;\n            f.insert(ele);\n        }\n        for(auto ele: basket2){\n            Map2[ele]++;\n            f.insert(ele);\n        }\n        \n        //cost from swapping:\n        vector<int> c1;\n        vector<int> c2;\n        \n        //pass req from basket1:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f1 <= f2) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f2;\n            while(added--) c1.push_back(fruit);\n        }\n        \n        //pass req from basket2:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f2 <= f1) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f1;\n            while(added--) c2.push_back(fruit);\n        }\n        \n        // for(auto c: c1) cout << c << \" \";\n        // cout << endl;\n        // for(auto c: c2) cout << c << \" \";\n        // cout << endl;\n        \n        if(c1.size() != c2.size()) return -1;\n        \n        sort(c1.begin(), c1.end());\n        sort(c2.begin(), c2.end());\n        \n        // to find min sum of all swaps using four pointers:\n        int n = c1.size();\n        int max1 = n-1, min1 = 0;\n        int max2 = n-1, min2 = 0;\n        \n        long long cost = 0;\n        for(int i=0;i<n;i++){\n            if(c1[max1] + c2[min2] < c2[max2] + c1[min1]){\n                cost += min(c1[max1], c2[min2]);\n                max1--;\n                min2++;\n            }\n            else{\n                cost += min(c2[max2], c1[min1]);\n                max2--;\n                min1++;\n            }\n        }\n        \n        return cost;        \n    }\n};\n```"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I think you will fail with the case:\\n[1,100,100],[1,200,200] (answer 2 - swap 1 with 200 and then swap 100 with 1)."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "You have small vocabulary error in Constraints block."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I have a hard time with this one, thought about it overnight and still don\\'t get it. Here are a few interesting examples that I have thought of\\n\\n[1,3],[5,9] is impossible, despite the sum is an even number - so we can\\'t detect whether a rearrangement is possible by odd/even.\\n\\nA satisfying arrangement [1,9],[5,5] has both the max and min in the same side, while, [1,6,6],[2,2,9] has the max and min on different side, we can\\'t decide if the max/min should be on the same side or not.\\n\\nThe example [1,1,5,5], [2,2,4,4] can also be [1,2,4,5], [1,2,4,5], in general there could be multiple satisfying arrangements, even after excluding sorting.\\n\\nThe example [1,3,5,10], [2,4,6,7] show that a solution can be quite interleaving. Starting from a random arrangement, such as [1,2,3,4], [5,6,7,10], swapping the light side heaviest with the heavy side lightest (i.e. 4 with 5) is a wrong move. The right moves (i.e. swap([1,3],[6,7]) seems rather random with no obvious pattern.\\n\\nI am stuck, I try not to read solutions (yet), any hints would be great."
                    },
                    {
                        "username": "shi_logic",
                        "content": "You can think about it greedily, as we often use the smaller one to match the bigger one or use the minimum number as a bridge to swap two other elements in both arrays. So you can think of sorting and using a two-point method to solve it."
                    },
                    {
                        "username": "applebeeble",
                        "content": "Shouldn\\'t this problem be medium? At the beginning I came up with the idea that I can use the smallest element to do the swap for larger elements. However, when I saw the difficulty is hard, I overthought. My time was run out during the contest, I was pretty close the correct solution. It is just min_element * number of elements that are different than target (target is the target array) + 2 or not + 2. I was trying to figure out the condition regarding plus 2 or not and ran out of the time as this is the last question during the contest.\\n\\nTLDR: This should be a medium problem, math-focused. No extra complex data structures needed. Result = min_element * num_different_element + 2 or not."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "What you said here basically means \"we will always use minimum number to help our swap\". This is actually not true, [3,4,4,4,4] - [3,5,5,5,5], the optimal cost is swapping 4 with 5 twice - 3 (the minimum) is not involved at all.\n\nThe solution is we do normal direct swap, but if using minimum number can help us to get lower cost, THEN we use minimum num to help us. (`when cost(direct swap) > minimum num * 2, we use minimum number to help us`)\n\nAs for that \"+2 or not\", i don't quite get it why you want to +2. Please let me know your idea here. Why 2?\n\nThis is a fair HARD, i think your solution is actually wrong which made you feel this is medium. "
                    }
                ]
            },
            {
                "id": 1802217,
                "content": [
                    {
                        "username": "user3954sk",
                        "content": "Once I read the question correctly (I initially started with the assumption that equal meant that the sum was equal!) this was a nice question.  No complex data structures, just pure logic (and then frustration when I forgot to account for the cost requiring 64 bit...).\\nSPOILER ALERT - Don\\'t read on if you don\\'t want a hint.\\nIf you need a hint, then consider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "brinuke",
                        "content": "What is `bakste2.length`? Looks like someone swapped letters in description instead of fruits."
                    },
                    {
                        "username": "lcaa02",
                        "content": "For the test case \\n[84,80,43,8,80,88,43,14,100,88]\\n[32,32,42,68,68,100,42,84,14,8]\\n\\ncan anyone please explain, how is the expected value 48?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Same logic I applied  haha and failed....\\n\\nConsider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "lcaa02",
                        "content": "[@applebeeble](/applebeeble) ohh right! Got it. thanks!!"
                    },
                    {
                        "username": "applebeeble",
                        "content": "use the minimum element 8 to do 6 swaps."
                    },
                    {
                        "username": "tejasX",
                        "content": "can somebody help me here ? What exactly i am missing?\n\n```\nclass Solution {\npublic:\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\n        unordered_map<int,int> Map1;\n        unordered_map<int,int> Map2;\n        \n        //fruits:\n        unordered_set<int> f;\n        for(auto ele: basket1){\n            Map1[ele]++;\n            f.insert(ele);\n        }\n        for(auto ele: basket2){\n            Map2[ele]++;\n            f.insert(ele);\n        }\n        \n        //cost from swapping:\n        vector<int> c1;\n        vector<int> c2;\n        \n        //pass req from basket1:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f1 <= f2) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f2;\n            while(added--) c1.push_back(fruit);\n        }\n        \n        //pass req from basket2:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f2 <= f1) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f1;\n            while(added--) c2.push_back(fruit);\n        }\n        \n        // for(auto c: c1) cout << c << \" \";\n        // cout << endl;\n        // for(auto c: c2) cout << c << \" \";\n        // cout << endl;\n        \n        if(c1.size() != c2.size()) return -1;\n        \n        sort(c1.begin(), c1.end());\n        sort(c2.begin(), c2.end());\n        \n        // to find min sum of all swaps using four pointers:\n        int n = c1.size();\n        int max1 = n-1, min1 = 0;\n        int max2 = n-1, min2 = 0;\n        \n        long long cost = 0;\n        for(int i=0;i<n;i++){\n            if(c1[max1] + c2[min2] < c2[max2] + c1[min1]){\n                cost += min(c1[max1], c2[min2]);\n                max1--;\n                min2++;\n            }\n            else{\n                cost += min(c2[max2], c1[min1]);\n                max2--;\n                min1++;\n            }\n        }\n        \n        return cost;        \n    }\n};\n```"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I think you will fail with the case:\\n[1,100,100],[1,200,200] (answer 2 - swap 1 with 200 and then swap 100 with 1)."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "You have small vocabulary error in Constraints block."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I have a hard time with this one, thought about it overnight and still don\\'t get it. Here are a few interesting examples that I have thought of\\n\\n[1,3],[5,9] is impossible, despite the sum is an even number - so we can\\'t detect whether a rearrangement is possible by odd/even.\\n\\nA satisfying arrangement [1,9],[5,5] has both the max and min in the same side, while, [1,6,6],[2,2,9] has the max and min on different side, we can\\'t decide if the max/min should be on the same side or not.\\n\\nThe example [1,1,5,5], [2,2,4,4] can also be [1,2,4,5], [1,2,4,5], in general there could be multiple satisfying arrangements, even after excluding sorting.\\n\\nThe example [1,3,5,10], [2,4,6,7] show that a solution can be quite interleaving. Starting from a random arrangement, such as [1,2,3,4], [5,6,7,10], swapping the light side heaviest with the heavy side lightest (i.e. 4 with 5) is a wrong move. The right moves (i.e. swap([1,3],[6,7]) seems rather random with no obvious pattern.\\n\\nI am stuck, I try not to read solutions (yet), any hints would be great."
                    },
                    {
                        "username": "shi_logic",
                        "content": "You can think about it greedily, as we often use the smaller one to match the bigger one or use the minimum number as a bridge to swap two other elements in both arrays. So you can think of sorting and using a two-point method to solve it."
                    },
                    {
                        "username": "applebeeble",
                        "content": "Shouldn\\'t this problem be medium? At the beginning I came up with the idea that I can use the smallest element to do the swap for larger elements. However, when I saw the difficulty is hard, I overthought. My time was run out during the contest, I was pretty close the correct solution. It is just min_element * number of elements that are different than target (target is the target array) + 2 or not + 2. I was trying to figure out the condition regarding plus 2 or not and ran out of the time as this is the last question during the contest.\\n\\nTLDR: This should be a medium problem, math-focused. No extra complex data structures needed. Result = min_element * num_different_element + 2 or not."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "What you said here basically means \"we will always use minimum number to help our swap\". This is actually not true, [3,4,4,4,4] - [3,5,5,5,5], the optimal cost is swapping 4 with 5 twice - 3 (the minimum) is not involved at all.\n\nThe solution is we do normal direct swap, but if using minimum number can help us to get lower cost, THEN we use minimum num to help us. (`when cost(direct swap) > minimum num * 2, we use minimum number to help us`)\n\nAs for that \"+2 or not\", i don't quite get it why you want to +2. Please let me know your idea here. Why 2?\n\nThis is a fair HARD, i think your solution is actually wrong which made you feel this is medium. "
                    }
                ]
            },
            {
                "id": 1791945,
                "content": [
                    {
                        "username": "user3954sk",
                        "content": "Once I read the question correctly (I initially started with the assumption that equal meant that the sum was equal!) this was a nice question.  No complex data structures, just pure logic (and then frustration when I forgot to account for the cost requiring 64 bit...).\\nSPOILER ALERT - Don\\'t read on if you don\\'t want a hint.\\nIf you need a hint, then consider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "brinuke",
                        "content": "What is `bakste2.length`? Looks like someone swapped letters in description instead of fruits."
                    },
                    {
                        "username": "lcaa02",
                        "content": "For the test case \\n[84,80,43,8,80,88,43,14,100,88]\\n[32,32,42,68,68,100,42,84,14,8]\\n\\ncan anyone please explain, how is the expected value 48?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Same logic I applied  haha and failed....\\n\\nConsider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "lcaa02",
                        "content": "[@applebeeble](/applebeeble) ohh right! Got it. thanks!!"
                    },
                    {
                        "username": "applebeeble",
                        "content": "use the minimum element 8 to do 6 swaps."
                    },
                    {
                        "username": "tejasX",
                        "content": "can somebody help me here ? What exactly i am missing?\n\n```\nclass Solution {\npublic:\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\n        unordered_map<int,int> Map1;\n        unordered_map<int,int> Map2;\n        \n        //fruits:\n        unordered_set<int> f;\n        for(auto ele: basket1){\n            Map1[ele]++;\n            f.insert(ele);\n        }\n        for(auto ele: basket2){\n            Map2[ele]++;\n            f.insert(ele);\n        }\n        \n        //cost from swapping:\n        vector<int> c1;\n        vector<int> c2;\n        \n        //pass req from basket1:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f1 <= f2) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f2;\n            while(added--) c1.push_back(fruit);\n        }\n        \n        //pass req from basket2:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f2 <= f1) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f1;\n            while(added--) c2.push_back(fruit);\n        }\n        \n        // for(auto c: c1) cout << c << \" \";\n        // cout << endl;\n        // for(auto c: c2) cout << c << \" \";\n        // cout << endl;\n        \n        if(c1.size() != c2.size()) return -1;\n        \n        sort(c1.begin(), c1.end());\n        sort(c2.begin(), c2.end());\n        \n        // to find min sum of all swaps using four pointers:\n        int n = c1.size();\n        int max1 = n-1, min1 = 0;\n        int max2 = n-1, min2 = 0;\n        \n        long long cost = 0;\n        for(int i=0;i<n;i++){\n            if(c1[max1] + c2[min2] < c2[max2] + c1[min1]){\n                cost += min(c1[max1], c2[min2]);\n                max1--;\n                min2++;\n            }\n            else{\n                cost += min(c2[max2], c1[min1]);\n                max2--;\n                min1++;\n            }\n        }\n        \n        return cost;        \n    }\n};\n```"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I think you will fail with the case:\\n[1,100,100],[1,200,200] (answer 2 - swap 1 with 200 and then swap 100 with 1)."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "You have small vocabulary error in Constraints block."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I have a hard time with this one, thought about it overnight and still don\\'t get it. Here are a few interesting examples that I have thought of\\n\\n[1,3],[5,9] is impossible, despite the sum is an even number - so we can\\'t detect whether a rearrangement is possible by odd/even.\\n\\nA satisfying arrangement [1,9],[5,5] has both the max and min in the same side, while, [1,6,6],[2,2,9] has the max and min on different side, we can\\'t decide if the max/min should be on the same side or not.\\n\\nThe example [1,1,5,5], [2,2,4,4] can also be [1,2,4,5], [1,2,4,5], in general there could be multiple satisfying arrangements, even after excluding sorting.\\n\\nThe example [1,3,5,10], [2,4,6,7] show that a solution can be quite interleaving. Starting from a random arrangement, such as [1,2,3,4], [5,6,7,10], swapping the light side heaviest with the heavy side lightest (i.e. 4 with 5) is a wrong move. The right moves (i.e. swap([1,3],[6,7]) seems rather random with no obvious pattern.\\n\\nI am stuck, I try not to read solutions (yet), any hints would be great."
                    },
                    {
                        "username": "shi_logic",
                        "content": "You can think about it greedily, as we often use the smaller one to match the bigger one or use the minimum number as a bridge to swap two other elements in both arrays. So you can think of sorting and using a two-point method to solve it."
                    },
                    {
                        "username": "applebeeble",
                        "content": "Shouldn\\'t this problem be medium? At the beginning I came up with the idea that I can use the smallest element to do the swap for larger elements. However, when I saw the difficulty is hard, I overthought. My time was run out during the contest, I was pretty close the correct solution. It is just min_element * number of elements that are different than target (target is the target array) + 2 or not + 2. I was trying to figure out the condition regarding plus 2 or not and ran out of the time as this is the last question during the contest.\\n\\nTLDR: This should be a medium problem, math-focused. No extra complex data structures needed. Result = min_element * num_different_element + 2 or not."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "What you said here basically means \"we will always use minimum number to help our swap\". This is actually not true, [3,4,4,4,4] - [3,5,5,5,5], the optimal cost is swapping 4 with 5 twice - 3 (the minimum) is not involved at all.\n\nThe solution is we do normal direct swap, but if using minimum number can help us to get lower cost, THEN we use minimum num to help us. (`when cost(direct swap) > minimum num * 2, we use minimum number to help us`)\n\nAs for that \"+2 or not\", i don't quite get it why you want to +2. Please let me know your idea here. Why 2?\n\nThis is a fair HARD, i think your solution is actually wrong which made you feel this is medium. "
                    }
                ]
            },
            {
                "id": 1789779,
                "content": [
                    {
                        "username": "user3954sk",
                        "content": "Once I read the question correctly (I initially started with the assumption that equal meant that the sum was equal!) this was a nice question.  No complex data structures, just pure logic (and then frustration when I forgot to account for the cost requiring 64 bit...).\\nSPOILER ALERT - Don\\'t read on if you don\\'t want a hint.\\nIf you need a hint, then consider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "brinuke",
                        "content": "What is `bakste2.length`? Looks like someone swapped letters in description instead of fruits."
                    },
                    {
                        "username": "lcaa02",
                        "content": "For the test case \\n[84,80,43,8,80,88,43,14,100,88]\\n[32,32,42,68,68,100,42,84,14,8]\\n\\ncan anyone please explain, how is the expected value 48?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Same logic I applied  haha and failed....\\n\\nConsider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "lcaa02",
                        "content": "[@applebeeble](/applebeeble) ohh right! Got it. thanks!!"
                    },
                    {
                        "username": "applebeeble",
                        "content": "use the minimum element 8 to do 6 swaps."
                    },
                    {
                        "username": "tejasX",
                        "content": "can somebody help me here ? What exactly i am missing?\n\n```\nclass Solution {\npublic:\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\n        unordered_map<int,int> Map1;\n        unordered_map<int,int> Map2;\n        \n        //fruits:\n        unordered_set<int> f;\n        for(auto ele: basket1){\n            Map1[ele]++;\n            f.insert(ele);\n        }\n        for(auto ele: basket2){\n            Map2[ele]++;\n            f.insert(ele);\n        }\n        \n        //cost from swapping:\n        vector<int> c1;\n        vector<int> c2;\n        \n        //pass req from basket1:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f1 <= f2) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f2;\n            while(added--) c1.push_back(fruit);\n        }\n        \n        //pass req from basket2:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f2 <= f1) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f1;\n            while(added--) c2.push_back(fruit);\n        }\n        \n        // for(auto c: c1) cout << c << \" \";\n        // cout << endl;\n        // for(auto c: c2) cout << c << \" \";\n        // cout << endl;\n        \n        if(c1.size() != c2.size()) return -1;\n        \n        sort(c1.begin(), c1.end());\n        sort(c2.begin(), c2.end());\n        \n        // to find min sum of all swaps using four pointers:\n        int n = c1.size();\n        int max1 = n-1, min1 = 0;\n        int max2 = n-1, min2 = 0;\n        \n        long long cost = 0;\n        for(int i=0;i<n;i++){\n            if(c1[max1] + c2[min2] < c2[max2] + c1[min1]){\n                cost += min(c1[max1], c2[min2]);\n                max1--;\n                min2++;\n            }\n            else{\n                cost += min(c2[max2], c1[min1]);\n                max2--;\n                min1++;\n            }\n        }\n        \n        return cost;        \n    }\n};\n```"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I think you will fail with the case:\\n[1,100,100],[1,200,200] (answer 2 - swap 1 with 200 and then swap 100 with 1)."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "You have small vocabulary error in Constraints block."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I have a hard time with this one, thought about it overnight and still don\\'t get it. Here are a few interesting examples that I have thought of\\n\\n[1,3],[5,9] is impossible, despite the sum is an even number - so we can\\'t detect whether a rearrangement is possible by odd/even.\\n\\nA satisfying arrangement [1,9],[5,5] has both the max and min in the same side, while, [1,6,6],[2,2,9] has the max and min on different side, we can\\'t decide if the max/min should be on the same side or not.\\n\\nThe example [1,1,5,5], [2,2,4,4] can also be [1,2,4,5], [1,2,4,5], in general there could be multiple satisfying arrangements, even after excluding sorting.\\n\\nThe example [1,3,5,10], [2,4,6,7] show that a solution can be quite interleaving. Starting from a random arrangement, such as [1,2,3,4], [5,6,7,10], swapping the light side heaviest with the heavy side lightest (i.e. 4 with 5) is a wrong move. The right moves (i.e. swap([1,3],[6,7]) seems rather random with no obvious pattern.\\n\\nI am stuck, I try not to read solutions (yet), any hints would be great."
                    },
                    {
                        "username": "shi_logic",
                        "content": "You can think about it greedily, as we often use the smaller one to match the bigger one or use the minimum number as a bridge to swap two other elements in both arrays. So you can think of sorting and using a two-point method to solve it."
                    },
                    {
                        "username": "applebeeble",
                        "content": "Shouldn\\'t this problem be medium? At the beginning I came up with the idea that I can use the smallest element to do the swap for larger elements. However, when I saw the difficulty is hard, I overthought. My time was run out during the contest, I was pretty close the correct solution. It is just min_element * number of elements that are different than target (target is the target array) + 2 or not + 2. I was trying to figure out the condition regarding plus 2 or not and ran out of the time as this is the last question during the contest.\\n\\nTLDR: This should be a medium problem, math-focused. No extra complex data structures needed. Result = min_element * num_different_element + 2 or not."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "What you said here basically means \"we will always use minimum number to help our swap\". This is actually not true, [3,4,4,4,4] - [3,5,5,5,5], the optimal cost is swapping 4 with 5 twice - 3 (the minimum) is not involved at all.\n\nThe solution is we do normal direct swap, but if using minimum number can help us to get lower cost, THEN we use minimum num to help us. (`when cost(direct swap) > minimum num * 2, we use minimum number to help us`)\n\nAs for that \"+2 or not\", i don't quite get it why you want to +2. Please let me know your idea here. Why 2?\n\nThis is a fair HARD, i think your solution is actually wrong which made you feel this is medium. "
                    }
                ]
            },
            {
                "id": 1788388,
                "content": [
                    {
                        "username": "user3954sk",
                        "content": "Once I read the question correctly (I initially started with the assumption that equal meant that the sum was equal!) this was a nice question.  No complex data structures, just pure logic (and then frustration when I forgot to account for the cost requiring 64 bit...).\\nSPOILER ALERT - Don\\'t read on if you don\\'t want a hint.\\nIf you need a hint, then consider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "brinuke",
                        "content": "What is `bakste2.length`? Looks like someone swapped letters in description instead of fruits."
                    },
                    {
                        "username": "lcaa02",
                        "content": "For the test case \\n[84,80,43,8,80,88,43,14,100,88]\\n[32,32,42,68,68,100,42,84,14,8]\\n\\ncan anyone please explain, how is the expected value 48?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Same logic I applied  haha and failed....\\n\\nConsider these two test cases:\\n[2,2,100,100],[3,3,200,200] (answer 5)\\n[1,100,100],[1,200,200] (answer 2)\\nWhy is the approach different for these two cases?"
                    },
                    {
                        "username": "lcaa02",
                        "content": "[@applebeeble](/applebeeble) ohh right! Got it. thanks!!"
                    },
                    {
                        "username": "applebeeble",
                        "content": "use the minimum element 8 to do 6 swaps."
                    },
                    {
                        "username": "tejasX",
                        "content": "can somebody help me here ? What exactly i am missing?\n\n```\nclass Solution {\npublic:\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\n        unordered_map<int,int> Map1;\n        unordered_map<int,int> Map2;\n        \n        //fruits:\n        unordered_set<int> f;\n        for(auto ele: basket1){\n            Map1[ele]++;\n            f.insert(ele);\n        }\n        for(auto ele: basket2){\n            Map2[ele]++;\n            f.insert(ele);\n        }\n        \n        //cost from swapping:\n        vector<int> c1;\n        vector<int> c2;\n        \n        //pass req from basket1:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f1 <= f2) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f2;\n            while(added--) c1.push_back(fruit);\n        }\n        \n        //pass req from basket2:\n        for(auto fruit: f){\n            int f1 = Map1[fruit];\n            int f2 = Map2[fruit];\n            \n            if(f2 <= f1) continue;\n            if((f1+f2) % 2 != 0) return -1;\n            \n            int equal = (f1+f2)/2;\n            Map1[fruit] = equal;\n            Map2[fruit] = equal;\n            \n            int added = equal - f1;\n            while(added--) c2.push_back(fruit);\n        }\n        \n        // for(auto c: c1) cout << c << \" \";\n        // cout << endl;\n        // for(auto c: c2) cout << c << \" \";\n        // cout << endl;\n        \n        if(c1.size() != c2.size()) return -1;\n        \n        sort(c1.begin(), c1.end());\n        sort(c2.begin(), c2.end());\n        \n        // to find min sum of all swaps using four pointers:\n        int n = c1.size();\n        int max1 = n-1, min1 = 0;\n        int max2 = n-1, min2 = 0;\n        \n        long long cost = 0;\n        for(int i=0;i<n;i++){\n            if(c1[max1] + c2[min2] < c2[max2] + c1[min1]){\n                cost += min(c1[max1], c2[min2]);\n                max1--;\n                min2++;\n            }\n            else{\n                cost += min(c2[max2], c1[min1]);\n                max2--;\n                min1++;\n            }\n        }\n        \n        return cost;        \n    }\n};\n```"
                    },
                    {
                        "username": "user3954sk",
                        "content": "I think you will fail with the case:\\n[1,100,100],[1,200,200] (answer 2 - swap 1 with 200 and then swap 100 with 1)."
                    },
                    {
                        "username": "Vensk1y",
                        "content": "You have small vocabulary error in Constraints block."
                    },
                    {
                        "username": "cecilia5",
                        "content": "I have a hard time with this one, thought about it overnight and still don\\'t get it. Here are a few interesting examples that I have thought of\\n\\n[1,3],[5,9] is impossible, despite the sum is an even number - so we can\\'t detect whether a rearrangement is possible by odd/even.\\n\\nA satisfying arrangement [1,9],[5,5] has both the max and min in the same side, while, [1,6,6],[2,2,9] has the max and min on different side, we can\\'t decide if the max/min should be on the same side or not.\\n\\nThe example [1,1,5,5], [2,2,4,4] can also be [1,2,4,5], [1,2,4,5], in general there could be multiple satisfying arrangements, even after excluding sorting.\\n\\nThe example [1,3,5,10], [2,4,6,7] show that a solution can be quite interleaving. Starting from a random arrangement, such as [1,2,3,4], [5,6,7,10], swapping the light side heaviest with the heavy side lightest (i.e. 4 with 5) is a wrong move. The right moves (i.e. swap([1,3],[6,7]) seems rather random with no obvious pattern.\\n\\nI am stuck, I try not to read solutions (yet), any hints would be great."
                    },
                    {
                        "username": "shi_logic",
                        "content": "You can think about it greedily, as we often use the smaller one to match the bigger one or use the minimum number as a bridge to swap two other elements in both arrays. So you can think of sorting and using a two-point method to solve it."
                    },
                    {
                        "username": "applebeeble",
                        "content": "Shouldn\\'t this problem be medium? At the beginning I came up with the idea that I can use the smallest element to do the swap for larger elements. However, when I saw the difficulty is hard, I overthought. My time was run out during the contest, I was pretty close the correct solution. It is just min_element * number of elements that are different than target (target is the target array) + 2 or not + 2. I was trying to figure out the condition regarding plus 2 or not and ran out of the time as this is the last question during the contest.\\n\\nTLDR: This should be a medium problem, math-focused. No extra complex data structures needed. Result = min_element * num_different_element + 2 or not."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "What you said here basically means \"we will always use minimum number to help our swap\". This is actually not true, [3,4,4,4,4] - [3,5,5,5,5], the optimal cost is swapping 4 with 5 twice - 3 (the minimum) is not involved at all.\n\nThe solution is we do normal direct swap, but if using minimum number can help us to get lower cost, THEN we use minimum num to help us. (`when cost(direct swap) > minimum num * 2, we use minimum number to help us`)\n\nAs for that \"+2 or not\", i don't quite get it why you want to +2. Please let me know your idea here. Why 2?\n\nThis is a fair HARD, i think your solution is actually wrong which made you feel this is medium. "
                    }
                ]
            }
        ]
    }
]